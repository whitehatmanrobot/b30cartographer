sageMode();

    if (LogFile != NULL) {
        va_start(va, pszfmt);
        fprintf(LogFile, "BUILD: ");

        if (Frb.fOpen) {
            fprintf (LogFile, "%s(%hu): ", Frb.pszFile, Frb.cLine);
        }

        vfprintf(LogFile, pszfmt, va);
        va_end(va);
        fflush(LogFile);
    }
}


VOID _cdecl
BuildErrorRaw(char *pszfmt, ...)
{
    register va_list va;

    EnterMessageMode();

    va_start(va, pszfmt);
    vfprintf(stderr, pszfmt, va);
    va_end(va);
    fflush(stderr);

    LeaveMessageMode();

    if (LogFile != NULL) {
        va_start(va, pszfmt);
        vfprintf(LogFile, pszfmt, va);
        va_end(va);
        fflush(LogFile);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   memfind
//
//  Synopsis:   Finds a sub-string by length (can contain nulls)
//
//  Arguments:  [pvWhere]   -- String to search (can contain nulls)
//              [cbWhere]   -- Length in bytes of the string to search
//              [pvWhat]    -- String to search for (can contain nulls)
//              [cbWhat]    -- Length in bytes of the string to search for
//
//  Returns:    Pointer to the first occurence of pvWhat in pvWhere
//              NULL, if not found or if the input parameters are not valid
//
//----------------------------------------------------------------------------

VOID*
memfind(VOID* pvWhere, DWORD cbWhere, VOID* pvWhat, DWORD cbWhat)
{
    DWORD dwWhat = 0;
    DWORD dwWhere = 0;
    DWORD dwFoundStart = 0;

    // input validation
    if (cbWhere < cbWhat || pvWhere == NULL || pvWhat == NULL)
        return NULL;

    while (dwFoundStart <= cbWhere - cbWhat && dwWhat < cbWhat)
    {
        if ( ((BYTE*)pvWhat)[dwWhat] != ((BYTE*)pvWhere)[dwWhere])
        {
            dwWhat = 0;
            dwFoundStart++;
            dwWhere = dwFoundStart;
        }
        else
        {
            dwWhat++;
            dwWhere++;
        }
    }

    if (dwWhat == cbWhat)
        return (BYTE*)pvWhere + dwFoundStart;
    return NULL;
}

//
// XML Logging
//

//#define MAX_XML_BUFFER_SIZE 2048
char szXMLPrivateBuffer[2048];//MAX_XML_BUFFER_SIZE];

BOOL
XMLInit(VOID)
{
    UINT i;

    char buffer[MAX_PATH];
    char* psz = buffer + GetModuleFileName(NULL, buffer, sizeof(buffer));

    while (psz > buffer && *psz != '\\') {
        --psz;
    }
    ++psz;
    strcpy(psz, XML_SCHEMA);

    // check if there is a schema file in the current directory
    if (GetFileAttributes(XML_SCHEMA) == 0xFFFFFFFF) {
        // copy the schema to the current directory
        if (!CopyFile(buffer, XML_SCHEMA, FALSE)) {
            BuildError("(Fatal Error) Unable to copy the XML schema file\n");
            return FALSE;
        }
    }

    AllocMem(sizeof(PXMLTHREADSTATE)*(NumberProcesses+1), (VOID**)&PXMLThreadStates, MT_PXMLTHREADSTATE);

    for (i = 0; i < NumberProcesses+1; i++) {
        AllocMem(sizeof(XMLTHREADSTATE), (VOID**)&(PXMLThreadStates[i]), MT_XMLTHREADSTATE);
        memset(PXMLThreadStates[i], 0, sizeof(XMLTHREADSTATE));
        PXMLThreadStates[i]->iXMLFileStart = -1;
    }
    AllocMem(sizeof(XMLTHREADSTATE), (VOID**)&(PXMLGlobalState), MT_XMLTHREADSTATE);
    memset(PXMLGlobalState, 0, sizeof(XMLTHREADSTATE));
    PXMLGlobalState->iXMLFileStart = 0;
    InitializeCriticalSection(&XMLCriticalSection);

    return TRUE;
}

VOID
XMLUnInit(VOID)
{
    UINT i;
    for (i = 0; i < NumberProcesses+1; i++) {
        FreeMem((VOID**)&(PXMLThreadStates[i]), MT_XMLTHREADSTATE);
    }
    FreeMem((VOID**)&PXMLGlobalState, MT_XMLTHREADSTATE);
    FreeMem((VOID**)&PXMLThreadStates, MT_PXMLTHREADSTATE);
    DeleteCriticalSection(&XMLCriticalSection);
}

VOID _cdecl
XMLThreadWrite(PTHREADSTATE ThreadState, LPCSTR pszFmt, ...)
{
    register va_list va;
    DWORD dwBufferLen;
    PXMLTHREADSTATE OtherXMLState;
    PXMLTHREADSTATE XMLState;
    UINT i;

    if (!XMLFile)
        return;

    XMLEnterCriticalSection();

    XMLState = PXMLThreadStates[ThreadState->XMLThreadIndex];
    XMLThreadInitBuffer(ThreadState);

    // build the string to write out
    va_start(va, pszFmt);
    _vsnprintf(szXMLPrivateBuffer, sizeof(szXMLPrivateBuffer), pszFmt, va);
    va_end(va);
    dwBufferLen = strlen(szXMLPrivateBuffer);

    // write it into the file
    fseek(XMLFile, XMLState->iXMLFileStart + XMLState->iXMLBufferPos, SEEK_SET);
    fwrite(szXMLPrivateBuffer, 1, dwBufferLen, XMLFile);
    // put back the thread tail
    fwrite(XMLState->XMLBuffer + XMLState->iXMLBufferPos, 1, XMLState->iXMLBufferLen - XMLState->iXMLBufferPos, XMLFile);

    // insert the string into the thread buffer
    memmove(XMLState->XMLBuffer + XMLState->iXMLBufferPos + dwBufferLen, XMLState->XMLBuffer + XMLState->iXMLBufferPos, XMLState->iXMLBufferLen - XMLState->iXMLBufferPos + 1); // include the null terminator
    memmove(XMLState->XMLBuffer + XMLState->iXMLBufferPos, szXMLPrivateBuffer, dwBufferLen);
    XMLState->iXMLBufferPos += dwBufferLen;
    XMLState->iXMLBufferLen += dwBufferLen;

    // write back the threads that got overwritten
    // will reorder them but it doesn't really matter since the final order is 
    // the one in they finish

    for (i = 0; i < NumberProcesses+1; i++) {
        if (i != ThreadState->XMLThreadIndex) {
            OtherXMLState = PXMLThreadStates[i];
            if (OtherXMLState->iXMLFileStart < XMLState->iXMLFileStart) {
                continue;
            }

            OtherXMLState->iXMLFileStart = ftell(XMLFile);
            fwrite(OtherXMLState->XMLBuffer, 1, OtherXMLState->iXMLBufferLen, XMLFile);
        }
    }

    // update the global tail position
    PXMLGlobalState->iXMLFileStart = ftell(XMLFile);
    // write back the global tail
    fwrite(PXMLGlobalState->XMLBuffer,  1, PXMLGlobalState->iXMLBufferLen, XMLFile);

    fflush(XMLFile);    
    XMLLeaveCriticalSection();
}

VOID _cdecl
XMLThreadOpenTag(PTHREADSTATE ThreadState, LPCSTR pszTag, LPCSTR pszFmt, ...)
{
    register va_list va;
    DWORD dwMidBufferLen;
    DWORD dwBufferLen;
    DWORD dwTagLen = strlen(pszTag);
    PXMLTHREADSTATE OtherXMLState;
    PXMLTHREADSTATE XMLState;
    UINT i;

    if (!XMLFile)
        return;

    XMLEnterCriticalSection();

    XMLState = PXMLThreadStates[ThreadState->XMLThreadIndex];
    XMLThreadInitBuffer(ThreadState);

    // build the string to write out
    szXMLPrivateBuffer[0] = '<';
    strcpy(szXMLPrivateBuffer + 1, pszTag);

    if (pszFmt != NULL) {
        va_start(va, pszFmt);
        strcat(szXMLPrivateBuffer, " ");
        vsprintf(szXMLPrivateBuffer + strlen(szXMLPrivateBuffer), pszFmt, va);
        va_end(va);
    }

    strcat(szXMLPrivateBuffer, ">");

    dwMidBufferLen = strlen(szXMLPrivateBuffer);

    szXMLPrivateBuffer[dwMidBufferLen] = '<';
    szXMLPrivateBuffer[dwMidBufferLen + 1] = '/';
    memcpy(szXMLPrivateBuffer + dwMidBufferLen + 2, pszTag, dwTagLen);
    szXMLPrivateBuffer[dwMidBufferLen + dwTagLen + 2] = '>';

    dwBufferLen = dwMidBufferLen + dwTagLen + 3;

    // write it into the file
    fseek(XMLFile, XMLState->iXMLFileStart + XMLState->iXMLBufferPos, SEEK_SET);
    fwrite(szXMLPrivateBuffer, 1, dwBufferLen, XMLFile);
    // put back the thread tail
    fwrite(XMLState->XMLBuffer + XMLState->iXMLBufferPos, 1, XMLState->iXMLBufferLen - XMLState->iXMLBufferPos, XMLFile);

    // insert the string into the thread buffer
    memmove(XMLState->XMLBuffer + XMLState->iXMLBufferPos + dwBufferLen, XMLState->XMLBuffer + XMLState->iXMLBufferPos, XMLState->iXMLBufferLen - XMLState->iXMLBufferPos + 1); // include the null terminator
    memmove(XMLState->XMLBuffer + XMLState->iXMLBufferPos, szXMLPrivateBuffer, dwBufferLen);
    // don't increase the buffer pos with the full string length but until the end of the open tag only
    XMLState->iXMLBufferPos += dwMidBufferLen;
    XMLState->iXMLBufferLen += dwBufferLen;

    // write back the threads that got overwritten
    // will reorder them but it doesn't really matter since the final order is 
    // the one in they finish

    for (i = 0; i < NumberProcesses+1; i++) {
        if (i != ThreadState->XMLThreadIndex) {
            OtherXMLState = PXMLThreadStates[i];
            if (OtherXMLState->iXMLFileStart < XMLState->iXMLFileStart) {
                continue;
            }

            OtherXMLState->iXMLFileStart = ftell(XMLFile);
            fwrite(OtherXMLState->XMLBuffer, 1, OtherXMLState->iXMLBufferLen, XMLFile);
        }
    }

    // update the global tail position
    PXMLGlobalState->iXMLFileStart = ftell(XMLFile);
    // write back the global tail
    fwrite(PXMLGlobalState->XMLBuffer,  1, PXMLGlobalState->iXMLBufferLen, XMLFile);

    fflush(XMLFile);    
    XMLLeaveCriticalSection();
}

VOID
XMLThreadCloseTag(PTHREADSTATE ThreadState, LPCSTR pszTag)
{
    PXMLTHREADSTATE XMLState = PXMLThreadStates[ThreadState->XMLThreadIndex];
    char* psz = XMLState->XMLBuffer + XMLState->iXMLBufferPos;

    if (!XMLFile)
        return;

    XMLEnterCriticalSection();
    if (XMLState->iXMLFileStart == -1)
    {
        XMLLeaveCriticalSection();
        return;
    }

    assert(*psz == '<');
    assert(strncmp(psz+2, pszTag, strlen(pszTag))==0);
    while (*psz != '>')
        psz++;
    psz++;
    XMLState->iXMLBufferPos += psz - (XMLState->XMLBuffer + XMLState->iXMLBufferPos);
    XMLLeaveCriticalSection();

}

VOID
XMLThreadReleaseBuffer(PTHREADSTATE ThreadState)
{
    // this op may cause the other thread blocks to move towards the end of the file
    // but we can't keep more than one block per thread so we have to live with it

    UINT i;
    long iMinFileStart = LONG_MAX;
    int iMinThreadIndex = -1;
    PXMLTHREADSTATE OtherXMLState;
    PXMLTHREADSTATE XMLState;

    if (!XMLFile)
        return;

    XMLEnterCriticalSection();

    XMLState = PXMLThreadStates[ThreadState->XMLThreadIndex];
    if (XMLState->iXMLFileStart == -1) {
        XMLLeaveCriticalSection();
        return;
    }

    assert(XMLState->iXMLBufferPos == XMLState->iXMLBufferLen);

    // find the thread with the smallest file position

    for (i = 0; i < NumberProcesses+1; i++) {
        OtherXMLState = PXMLThreadStates[i];
        if (OtherXMLState->iXMLFileStart != -1 && OtherXMLState->iXMLFileStart < iMinFileStart) {
            iMinFileStart = OtherXMLState->iXMLFileStart;
            iMinThreadIndex = i;
        }
    }

    if (iMinThreadIndex == (int) ThreadState->XMLThreadIndex) {
        // got lucky - this thread is the first one, so we don't need to do anything
        XMLState->iXMLFileStart = -1;
        XMLLeaveCriticalSection();
        return; 
    }

    // dump out all threads starting with ours - not sure if the order matters
    // got the seek pos at the prev step
    fseek(XMLFile, iMinFileStart, SEEK_SET);
    fwrite(XMLState->XMLBuffer, 1, XMLState->iXMLBufferLen, XMLFile);
    XMLState->iXMLFileStart = -1;

    for (i = 0; i < NumberProcesses+1; i++) {
        if (i != ThreadState->XMLThreadIndex) {
            OtherXMLState = PXMLThreadStates[i];
            if (OtherXMLState->iXMLFileStart != -1) {
                OtherXMLState->iXMLFileStart = ftell(XMLFile);
                fwrite(OtherXMLState->XMLBuffer, 1, OtherXMLState->iXMLBufferLen, XMLFile);
            }
        }
    }

    // no need to write out the global tail because it didn't move
    fflush(XMLFile);
    XMLLeaveCriticalSection();
}

VOID
XMLThreadInitBuffer(PTHREADSTATE ThreadState)
{
    PXMLTHREADSTATE XMLState;

    if (!XMLFile)
        return;

    XMLEnterCriticalSection();

    XMLState = PXMLThreadStates[ThreadState->XMLThreadIndex];
    if (XMLState->iXMLFileStart == -1) {
        XMLState->iXMLFileStart = PXMLGlobalState->iXMLFileStart;
        XMLState->iXMLBufferLen = 0;
        XMLState->iXMLBufferPos = 0;
        XMLState->fXMLInAction = FALSE;
    }

    XMLLeaveCriticalSection();
}

VOID _cdecl
XMLGlobalWrite(LPCSTR pszFmt, ...)
{
    register va_list va;
    DWORD dwBufferLen;
    UINT i;

    if (!XMLFile)
        return;

    XMLEnterCriticalSection();

    for (i = 0; i < NumberProcesses+1; i++) {
        if (PXMLThreadStates[i]->iXMLFileStart != -1) {
            XMLLeaveCriticalSection();
            return;
        }
    }

    // build the string to write out
    va_start(va, pszFmt);
    _vsnprintf(szXMLPrivateBuffer, sizeof(szXMLPrivateBuffer), pszFmt, va);
    va_end(va);
    dwBufferLen = strlen(szXMLPrivateBuffer);

    // write it out
    fseek(XMLFile, PXMLGlobalState->iXMLFileStart, SEEK_SET);
    fwrite(szXMLPrivateBuffer, 1, dwBufferLen, XMLFile);
    // write out the global tail
    fwrite(PXMLGlobalState->XMLBuffer, 1, PXMLGlobalState->iXMLBufferLen, XMLFile);
    // and update the tail position
    PXMLGlobalState->iXMLFileStart += dwBufferLen;

    fflush(XMLFile);
    XMLLeaveCriticalSection();
}

VOID _cdecl
XMLGlobalOpenTag(LPCSTR pszTag, LPCSTR pszFmt, ...)
{
    register va_list va;
    DWORD dwBufferLen;
    DWORD dwTagLen = strlen(pszTag);
    UINT i;

    if (!XMLFile)
        return;

    XMLEnterCriticalSection();

    for (i = 0; i < NumberProcesses+1; i++) {
        PXMLTHREADSTATE OtherXMLState = PXMLThreadStates[i];
        if (OtherXMLState->iXMLFileStart != -1) {
            XMLLeaveCriticalSection();
            return;
        }
    }

    // build the string to write out
    szXMLPrivateBuffer[0] = '<';
    strcpy(szXMLPrivateBuffer + 1, pszTag);

    if (pszFmt != NULL) {
        va_start(va, pszFmt);
        strcat(szXMLPrivateBuffer, " ");
        vsprintf(szXMLPrivateBuffer + strlen(szXMLPrivateBuffer), pszFmt, va);
        va_end(va);
    }

    strcat(szXMLPrivateBuffer, ">");

    dwBufferLen = strlen(szXMLPrivateBuffer);

    // insert the closing tag in the global tail
    memmove(PXMLGlobalState->XMLBuffer + dwTagLen + 3, PXMLGlobalState->XMLBuffer, PXMLGlobalState->iXMLBufferLen+1);   // include the null terminator
    PXMLGlobalState->XMLBuffer[0] = '<';
    PXMLGlobalState->XMLBuffer[1] = '/';
    memcpy(PXMLGlobalState->XMLBuffer + 2, pszTag, dwTagLen);
    PXMLGlobalState->XMLBuffer[dwTagLen + 2] = '>';
    PXMLGlobalState->iXMLBufferLen += dwTagLen + 3;

    // write out the string
    fseek(XMLFile, PXMLGlobalState->iXMLFileStart, SEEK_SET);
    fwrite(szXMLPrivateBuffer, 1, dwBufferLen, XMLFile);
    // put back the global tail
    PXMLGlobalState->iXMLFileStart += dwBufferLen;
    fwrite(PXMLGlobalState->XMLBuffer, 1, PXMLGlobalState->iXMLBufferLen, XMLFile);

    fflush(XMLFile);
    XMLLeaveCriticalSection();
}

VOID
XMLGlobalCloseTag()
{
    char* psz;
    DWORD dwTagLen;

    if (!XMLFile)
        return;

    XMLEnterCriticalSection();

    if (PXMLGlobalState->iXMLBufferLen == 0) {
        XMLLeaveCriticalSection();
        return;
    }

    psz = PXMLGlobalState->XMLBuffer;
    while (*psz != '>')
        psz++;
    psz++;
    dwTagLen = psz - PXMLGlobalState->XMLBuffer;
    memmove(PXMLGlobalState->XMLBuffer, psz, PXMLGlobalState->iXMLBufferLen - dwTagLen + 1);    // include the null terminator
    PXMLGlobalState->iXMLBufferLen -= dwTagLen;
    PXMLGlobalState->iXMLFileStart += dwTagLen;
    XMLLeaveCriticalSection();
}

VOID
XMLUpdateEndTag(BOOL fCompleted)
{
    char* pszBuild;
    char* pszEnd;
    DWORD cbBufferLen;
    time_t ltime;

    if (!XMLFile)
        return;

    XMLEnterCriticalSection();

    pszBuild = strstr(PXMLGlobalState->XMLBuffer, "</BUILD>");
    if (pszBuild == NULL) {
        // no build tag is open yet
        XMLLeaveCriticalSection();
        return;
    }
    
    // remove the existing end tag
    pszEnd = strstr(PXMLGlobalState->XMLBuffer, "<END ");
    if (pszEnd != NULL) {
        memmove(pszEnd, pszBuild, strlen(pszBuild)+1);
        PXMLGlobalState->iXMLBufferLen -= (pszBuild - pszEnd);
        pszBuild = pszEnd;
    }

    // generate the new end tag
    time(&ltime);
    sprintf(szXMLPrivateBuffer, "<END TIME=\"%s\" ELAPSED=\"%s\" PASSES=\"%d\" COMPLETED=\"%d\" ", ctime(&ltime), FormatElapsedTime(XMLStartTicks), NumberPasses, fCompleted);
    strcat(szXMLPrivateBuffer, XMLBuildMetricsString(&RunningTotals));
    strcat(szXMLPrivateBuffer, "/>");
    cbBufferLen = strlen(szXMLPrivateBuffer);

    // insert the new end tag into the buffer
    memmove(pszBuild + cbBufferLen, pszBuild, strlen(pszBuild)+1);
    memmove(pszBuild, szXMLPrivateBuffer, cbBufferLen);
    PXMLGlobalState->iXMLBufferLen += cbBufferLen;

    // write it out
    fseek(XMLFile, PXMLGlobalState->iXMLFileStart, SEEK_SET);
    fwrite(PXMLGlobalState->XMLBuffer, 1, PXMLGlobalState->iXMLBufferLen, XMLFile);

    fflush(XMLFile);
    XMLLeaveCriticalSection();
}

static char cEntity[5] = { "<&>\"'" };
static char* pszEntityEncoding[5] = { 
    "&lt;",
    "&amp;",
    "&gt;",
    "&quot;",
    "&apos;"
};

LPSTR
XMLEncodeBuiltInEntities(LPSTR pszString, DWORD cbStringSize)
{
    DWORD cbStringLen = strlen(pszString);
    char* psz = pszString;
    DWORD cbExtraLen = 0;
    size_t pos = 0;
    char* pszTarget = NULL;
    char* pszSource = NULL;
    DWORD cbSourceLen = 0;

    cbStringSize -= 1;  // remove the null char
    
    while ((pos = strcspn(psz, cEntity)) != strlen(psz)) {
        cbExtraLen += strlen(pszEntityEncoding[strchr(cEntity, psz[pos])-cEntity])-1;
        psz += pos+1;
    }

    if (cbExtraLen + cbStringLen > cbStringSize)
        return NULL;

    if (0 == cbExtraLen)
        return pszString;

    psz = pszString + cbStringSize - cbStringLen;
    memmove(psz, pszString, cbStringLen+1);

    pszTarget = pszString;

    while ((pos = strcspn(psz, cEntity)) != strlen(psz)) {
        memmove(pszTarget, psz, pos);
        pszTarget += pos;
        psz += pos;

        pszSource = pszEntityEncoding[strchr(cEntity, *psz)-cEntity];
        cbSourceLen = strlen(pszSource);
        memmove(pszTarget, pszSource, cbSourceLen);
        pszTarget += cbSourceLen;
        psz++;
    }
    memmove(pszTarget, psz, pos);
    pszTarget += pos;
    *pszTarget = 0;

    return pszString;
}

LPSTR
XMLEncodeBuiltInEntitiesCopy(LPSTR pszString, LPSTR pszTarget)
{
    size_t pos = 0;
    char* pszSource;
    DWORD cbSourceLen;
    char* psz = pszTarget;

    while ((pos = strcspn(pszString, cEntity)) != strlen(pszString)) {
        memmove(psz, pszString, pos);
        psz += pos;
        pszString += pos;

        pszSource = pszEntityEncoding[strchr(cEntity, *pszString)-cEntity];
        cbSourceLen = strlen(pszSource);
        memmove(psz, pszSource, cbSourceLen);
        psz += cbSourceLen;
        pszString++;
    }
    memmove(psz, pszString, pos);
    psz += pos;
    *psz = 0;
    return pszTarget;
}

LPSTR
XMLBuildMetricsString(PBUILDMETRICS Metrics)
{
    static char buffer[512];

    buffer[0] = 0;

    if (0 != Metrics->NumberCompiles)
        sprintf(buffer + strlen(buffer), "FILESCOMPILED=\"%d\" ", Metrics->NumberCompiles);
    if (0 != Metrics->NumberCompileErrors)
        sprintf(buffer + strlen(buffer), "COMPILEEERRORS=\"%d\" ", Metrics->NumberCompileErrors);
    if (0 != Metrics->NumberCompileWarnings)
        sprintf(buffer + strlen(buffer), "COMPILEWARNINGS=\"%d\" ", Metrics->NumberCompileWarnings);
    if (0 != Metrics->NumberLibraries)
        sprintf(buffer + strlen(buffer), "LIBRARIESBUILT=\"%d\" ", Metrics->NumberLibraries);
    if (0 != Metrics->NumberLibraryErrors)
        sprintf(buffer + strlen(buffer), "LIBRARYERRORS=\"%d\" ", Metrics->NumberLibraryErrors);
    if (0 != Metrics->NumberLibraryWarnings)
        sprintf(buffer + strlen(buffer), "LIBRARYWARNINGS=\"%d\" ", Metrics->NumberLibraryWarnings);
    if (0 != Metrics->NumberLinks)
        sprintf(buffer + strlen(buffer), "EXECUTABLESBUILT=\"%d\" ", Metrics->NumberLinks);
    if (0 != Metrics->NumberLinkErrors)
        sprintf(buffer + strlen(buffer), "LINKERRORS=\"%d\" ", Metrics->NumberLinkErrors);
    if (0 != Metrics->NumberLinkWarnings)
        sprintf(buffer + strlen(buffer), "LINKWARNINGS=\"%d\" ", Metrics->NumberLinkWarnings);
    if (0 != Metrics->NumberBSCMakes)
        sprintf(buffer + strlen(buffer), "BROWSERDBS=\"%d\" ", Metrics->NumberBSCMakes);
    if (0 != Metrics->NumberBSCErrors)
        sprintf(buffer + strlen(buffer), "BSCERRORS=\"%d\" ", Metrics->NumberBSCErrors);
    if (0 != Metrics->NumberBSCWarnings)
        sprintf(buffer + strlen(buffer), "BSCWARNINGS=\"%d\" ", Metrics->NumberBSCWarnings);
    if (0 != Metrics->NumberVSToolErrors)
        sprintf(buffer + strlen(buffer), "VSTOOLERRORS=\"%d\" ", Metrics->NumberVSToolErrors);
    if (0 != Metrics->NumberVSToolWarnings)
        sprintf(buffer + strlen(buffer), "VSTOOLWARNINGS=\"%d\" ", Metrics->NumberVSToolWarnings);

    return buffer;
}

VOID _cdecl
XMLWriteFragmentFile(LPCSTR pszBaseFileName, LPCSTR pszFmt, ...)
{
    register va_list va;
    FILE* PFile;

    char szFileName[DB_MAX_PATH_LENGTH];
    sprintf(szFileName, "%s\\%s_%s.xml", XMLFragmentDirectory, FormatCurrentDateTime(), pszBaseFileName);

    XMLEnterCriticalSection();

    va_start(va, pszFmt);
    vsprintf(szXMLPrivateBuffer, pszFmt, va);
    va_end(va);

    PFile = fopen(szFileName, "wb");
    if (PFile) {
        fwrite(szXMLPrivateBuffer, 1, strlen(szXMLPrivateBuffer), PFile);
        fclose(PFile);
    }
    
    XMLLeaveCriticalSection();
}

VOID _cdecl
XMLWriteDirFragmentFile(BOOL fOpen, LPCSTR pszRelPath, LPCSTR pszFmt, ...)
{
    register va_list va;
    FILE* PFile;
    char* psz;

    char szFileName[DB_MAX_PATH_LENGTH];
    sprintf(szFileName, "%s\\%s_%s_%s", XMLFragmentDirectory, FormatCurrentDateTime(), fOpen ? "DIR" : "DIRSUMMARY", pszRelPath);
    psz = szFileName+strlen(szFileName)-1;
    if (*psz == '\\') {
        *psz = 0;
    }
    strcat(szFileName, ".xml");
    psz = szFileName+strlen(XMLFragmentDirectory)+1;
    while (*psz) {
        if (*psz == '\\') {
            *psz = '_';
        }
        ++psz;
    }

    if (fXMLOutput) {
        // protect against multi-threaded access
        XMLEnterCriticalSection();
    }

    va_start(va, pszFmt);
    vsprintf(szXMLPrivateBuffer, pszFmt, va);
    va_end(va);

    PFile = fopen(szFileName, "wb");
    if (PFile) {
        fwrite(szXMLPrivateBuffer, 1, strlen(szXMLPrivateBuffer), PFile);
        fclose(PFile);
    }

    if (fXMLOutput) {
        XMLLeaveCriticalSection();
    }
}

VOID
AddBuildMetrics(PBUILDMETRICS TargetMetrics, PBUILDMETRICS SourceMetrics)
{
    TargetMetrics->NumberCompileWarnings += SourceMetrics->NumberCompileWarnings;
    TargetMetrics->NumberCompileErrors += SourceMetrics->NumberCompileErrors;
    TargetMetrics->NumberCompiles += SourceMetrics->NumberCompiles;
    TargetMetrics->NumberLibraries += SourceMetrics->NumberLibraries;
    TargetMetrics->NumberLibraryWarnings += SourceMetrics->NumberLibraryWarnings;
    TargetMetrics->NumberLibraryErrors += SourceMetrics->NumberLibraryErrors;
    TargetMetrics->NumberLinks += SourceMetrics->NumberLinks;
    TargetMetrics->NumberLinkWarnings += SourceMetrics->NumberLinkWarnings;
    TargetMetrics->NumberLinkErrors += SourceMetrics->NumberLinkErrors;
    TargetMetrics->NumberBSCMakes += SourceMetrics->NumberBSCMakes;
    TargetMetrics->NumberBSCWarnings += SourceMetrics->NumberBSCWarnings;
    TargetMetrics->NumberBSCErrors += SourceMetrics->NumberBSCErrors;
    TargetMetrics->NumberVSToolErrors += SourceMetrics->NumberVSToolErrors;
    TargetMetrics->NumberVSToolWarnings += SourceMetrics->NumberVSToolWarnings;
    TargetMetrics->NumberDirActions += SourceMetrics->NumberDirActions;
    TargetMetrics->NumberActWarnings += SourceMetrics->NumberActWarnings;
    TargetMetrics->NumberActErrors += SourceMetrics->NumberActErrors;
}

VOID
XMLEnterCriticalSection()
{
    if (fXMLOutput) {
        EnterCriticalSection(&XMLCriticalSection);
    }
}

VOID
XMLLeaveCriticalSection()
{
    if (fXMLOutput) {
        LeaveCriticalSection(&XMLCriticalSection);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\cdimage.h ===
#define CDIMAGE_NAME    "CDIMAGE"               //
#define CDIMAGE_VERSION STRINGIZE( VERSION )    //  careful, use only a-chars
#define CDIMAGE_DATE    "(12/06/2000 TM)"       //

#ifdef XBOX

    #undef  CDIMAGE_NAME
    #define CDIMAGE_NAME "XDiscImage"

#endif // XBOX


#ifdef DVDIMAGE_ONLY

    #undef  CDIMAGE_NAME
    #define CDIMAGE_NAME "DVDIMAGE"

#endif // DVDIMAGE_ONLY


#define MAJOR_VERSION_TEXT  CDIMAGE_NAME " " CDIMAGE_VERSION
#define MINOR_VERSION_TEXT  CDIMAGE_DATE

#define CDIMAGE_SIGNATURE_TEXT "Microsoft CD-ROM Disc Signature Version 2.0"


#define CD_SECTORSIZE 2048                      // constant for CDs



//
//  Implemention Note:  block numbers are 32-bits in ISO-9660, but offsets
//  are represented as 64-bit since block numbers are multiplied by 2048 (2^11).
//  This means that the max image size is ( 2^32 * 2^11 ) = 2^43 or 8 terabytes
//  (0x80000000000 or 8,796,093,022,208 bytes).
//

#define MAX_LEVELS  256

//
//  74-minute CD:                                        4,440 seconds
//  times 75 frames (sectors) per second:              333,000 frames (sectors)
//  times 2048 bytes per frame (sector)            681,984,000 bytes
//

#define MAX_IMAGE_BYTES         681984000       // 74-minute CD maximum bytes
#define MAX_IMAGE_BYTES_TEXT    "681,984,000"

#ifdef JOEHOL

    #undef  MAX_IMAGE_BYTES
    #undef  MAX_IMAGE_BYTES_TEXT

    #define MAX_IMAGE_BYTES         679477248       // fudge down to 648.0MB
    #define MAX_IMAGE_BYTES_TEXT    "679,477,248"

    #define PRIVATE_BUILD_TEXT  "Private version for Windows NT CD Burn Lab\n\n"

#endif

#define MAX_QUEUED_WRITES     4
#define MAX_QUEUED_READS      4
#define MAX_QUEUED_OPENS      4

#define SCAN_REPORT_INCREMENT 500


#define IS_DIRECTORY    0x80000000  // use sign bit so compiler can optimize
#define IS_DUPLICATE    0x00000001
#define IS_WRITTEN      0x00000002
#define IS_HIDDEN       0x00000080
#define CHECK_SHORTNAME 0x00008000
#define NO_DIRENTRY     0x00000100


typedef struct _FILETIME_INFO   FILETIME_INFO,   *PFILETIME_INFO;
typedef struct _DIRECTORY_INFO  DIRECTORY_INFO,  *PDIRECTORY_INFO;
typedef struct _UDFINFO         UDFINFO,         *PUDFINFO;
typedef struct _DIRENTRY        DIRENTRY,        *PDIRENTRY;

struct _FILETIME_INFO {
    FILETIME ftLastWriteTime;
    FILETIME ftLastAccessTime;
    FILETIME ftCreationTime;
    };

struct _DIRECTORY_INFO {
    PDIRENTRY pFirstTargetFile;
    PDIRENTRY pNextTargetDir;
    PDIRENTRY pAlternateFirstFile;
    PDIRENTRY pAlternateNextDir;
    DWORD     dwUnicodeBlock;
    DWORD     dwUnicodeDirSize;
    DWORD     dwUnicodeIndex;
    DWORD     dwDirIndex;
    };

struct _UDFINFO {
    ULONG ulFIDLength;        // FID extent length in bytes (for Dir only)
    ULONG ulICBBlockNumber;   // Location of ICB for file or dir FID extent follows
    ULONG ulLinkCount;        // File Link Count
    };

typedef struct _DIRENTRY {

    LPSTR               pszFileName;        // offset 0
    LPWSTR              pszUnicodeName;     // offset 4
    DWORDLONG           dwlFileSize;        // offset 8
    DWORD               dwStartingBlock;    // offset 16
    DWORD               dwFlags;            // offset 20 IS_DIRECTORY, IS_DUPLICATE, IS_WRITTEN, IS_HIDDEN
    WORD                wFileNameLength;    // offset 24
    WORD                wUnicodeNameLength; // offset 26

    PDIRENTRY           pParentDir;         // offset 28
    PDIRENTRY           pNextSourceFile;    // offset 32
    PDIRENTRY           pNextTargetFile;    // offset 36
    PDIRENTRY           pAlternateNextFile; // offset 40

    PFILETIME_INFO      pFileTimeInfo;      // offset 44 valid iff ( ! bUseGlobalTime )
    PUDFINFO            pUdfInfo;           // offset 48 valid iff ( bEncodeUDF )

    union {                                 // IS_DIRECTORY, IS_DUPLICATE exclusive
        PDIRECTORY_INFO pDirectoryInfo;     // offset 52 valid iff ( dwFlags & IS_DIRECTORY )
        PDIRENTRY       pPrimary;           // offset 52 valid iff ( dwFlags & IS_DUPLICATE )
        };
                                            // offset 56 (length of retail structure)
#ifdef DEBUG
    ULONG               dwDirOffset;        // offset 56
    ULONG               dwUnicodeDirOffset; // offset 60
#endif

    /*
    BYTE                IcbFile[CD_SECTORSIZE]; // valid iff ( bEncodeUDF)
    */
                                                // offset 64 (length of debug structure)
    };


//
//  The following variable and function declarations are defined in and
//  exported from cdimage.c.
//

extern OSVERSIONINFO OsInfo;
extern WCHAR         wchVolumeLabel[];
extern PDIRENTRY     pStartOfLevel[];
extern DWORDLONG     dwlTotalNumberOfFiles;
extern DWORDLONG     dwlTotalNumberOfDirectories;
extern DWORD         dwNextMetaBlockNumber;
extern DWORD         dwTotalImageBlocks;
extern LONGLONG      LocalTimeBiasInFileTimeUnits;
extern FILETIME      ftGlobalFileTime;
extern BOOL          bScanOnly;
extern BOOL          bUseGlobalTime;
extern BOOL          bUseAnsiFileNames;
extern BOOL          bOptimizeStorage;
extern BOOL          bContinueAfterFailedSourceOpen;
extern LPSTR         pszSourceTree;
extern LPSTR         pszTargetFile;
extern CHAR          chVolumeLabel[];
extern CHAR          uchVolumeLabel[];
extern WCHAR         wchVolumeLabel[];
extern DWORD         dwBlockSize;
extern PBNODE pFirstBlockHashTree;

extern DWORDLONG dwlTotalDupFiles;
extern DWORDLONG dwlTotalDupFileBytes;          // allocation size

extern BOOL bOpenReadWrite;
extern BOOL bShowDuplicates;

#define IS_SECTOR_ALIGNED( AbsoluteOffset ) (( (AbsoluteOffset) % CD_SECTORSIZE ) == 0 )

#ifdef DEBUG

    #define SECTOR_NUMBER_FROM_BLOCK_NUMBER( BlockNumber ) \
                ( ASSERT( IS_SECTOR_ALIGNED( BlockNumber * (DWORDLONG) dwBlockSize )) ? \
                ( BlockNumber / ( CD_SECTORSIZE / dwBlockSize )) : 0 )

#else

    #define SECTOR_NUMBER_FROM_BLOCK_NUMBER( BlockNumber ) ( BlockNumber / ( CD_SECTORSIZE / dwBlockSize ))

#endif // DEBUG

#define CD_BLOCKS_FROM_SIZE(x) ((DWORD)(ROUNDUP2_64((x),dwBlockSize)/dwBlockSize))

#define BLOCK_NUMBER_FROM_SECTOR_NUMBER( SectorNumber ) ( SectorNumber * ( CD_SECTORSIZE / dwBlockSize ))

VOID
WriteZeroedSectors(
    IN DWORD SectorNumber,
    IN DWORD NumberOfSectors
    );

LPWSTR
AnsiToUnicode(
    IN LPSTR AnsiBuffer,
    IN OUT OPTIONAL LPWSTR UnicodeBuffer
    );

DWORD
AllocateMetaBlocks(
    IN DWORD SizeInBytes
    );

VOID
HeaderWrite(
    IN DWORDLONG Offset,
    IN PVOID     Buffer,
    IN ULONG     Length
    );

DWORD
PaddedFileDataWrite(
    IN DWORDLONG Offset,
    IN PVOID     Buffer,
    IN ULONG     Length
    );

DWORD
FileDataRead(
    IN DWORDLONG Offset,
    IN PVOID     Buffer,
    IN ULONG     Length
    );

VOID
GenericRead(
    IN DWORDLONG dwlOffset,
    IN DWORD dwLength,
    OUT PVOID pBuffer
    );

BOOL SetImageLength(
    IN LONGLONG llOffset
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\buffer.h ===
DWORD
AdjustWorkingSetAndLockImage(
    DWORD MinimumRingBufferSize,
    DWORD IndividualBufferSize
    );


DWORD
InitializeBufferAllocator(
    DWORD RequestedRingBufferSize,
    DWORD MinimumRingBufferSize,
    DWORD IndividualBufferSize
    );


PVOID
AllocateBuffer(
    UINT nBufferSize,
    BOOL bZeroMemory
    );


VOID
ReleaseBuffer(
    PVOID pBuffer
    );


DWORD
GetLargestFreeBufferSize(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\error.h ===
#define GETLASTERROR 0xFFFFFFFF

void __cdecl WarnFailedSourceOpen( DWORD dwGLE, const char *szFormat, ... );
void __cdecl ErrorExit(  DWORD dwGLE, const char *szFormat, ... );
void ErrorExitV( DWORD dwGLE, const char *szFormat, va_list vaArgs );


LPSTR
ErrorTextFromErrorCode(
    IN  DWORD ErrorCode,
    OUT LPSTR ErrorText
    );


#ifdef DEBUG
    BOOL __inline Assert( const char *szText,
                          const char *szFile,
                          unsigned    line ) {
        ErrorExit( 0, "ASSERT( %s ) FAILED, %s (%d)\n", szText, szFile, line );
        return FALSE;
        }
#endif

typedef VOID ( *PTERMINATION_HANDLER )( PVOID pContext );

VOID
RegisterTerminationHandler(
    PTERMINATION_HANDLER pHandler,
    PVOID                pContext
    );

extern volatile BOOL bGlobalErrorExitInProgress;

void InitializeErrorHandler( void );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\cdimage.c ===
#include "precomp.h"
#pragma hdrstop

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//  cdimage.c   Program for generating ISO-9660 CD images from a tree      //
//              of files (commonly referred to as premastering).           //
//                                                                         //
//              Code is targeted as Win32 console application.             //
//                                                                         //
//              Author: Tom McGuire (tommcg)                               //
//                                                                         //
//              Original version written February 1993.                    //
//                                                                         //
//              (C) Copyright 1993-2000, Microsoft Corporation             //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

typedef struct _TRANSFER_CONTEXT {
    HANDLE hOpenContext;
    HANDLE hEventComplete;
    } TRANSFER_CONTEXT, *PTRANSFER_CONTEXT;

PDIRENTRY pRootDir;

PDIRENTRY pStartOfLevel[ MAX_LEVELS ];
PDIRENTRY pAlternateStartOfLevel[ MAX_LEVELS ];

LPSTR pszSourceTree;
LPSTR pszTargetFile;

HANDLE hTargetFile;
HANDLE hTargetContext;

CHAR szRootPath[ MAX_NAME_LENGTH ];
CHAR   chVolumeLabel[ 32 + 1 ] =  "CD_ROM";     // mixed case
CHAR  uchVolumeLabel[ 32 + 1 ] =  "CD_ROM";     // upper case
WCHAR wchVolumeLabel[ 32 + 1 ] = L"DVD_ROM";    // mixed case (Unicode)

WCHAR UnicodeRootPath[ MAX_NAME_LENGTH ];

CHAR IsoVolumeCreationTime[ 18 ];       // yyyymmddhhmmsshho

UCHAR cGlobalIsoTimeStamp[ 7 ];
signed char IsoLocalTimeBias;
LONGLONG LocalTimeBiasInFileTimeUnits;

PUCHAR pFileBuffer;

PBNODE pFirstBlockHashTree = NULL;
PBNODE pWholeFileHashTree;

DWORD nDirectories;

DWORD dwHeaderBlocks;
DWORD dwLookupTableSize;
DWORD dwLookupTableAllocation;
DWORD dwJolietLookupTableSize;
DWORD dwJolietLookupTableAllocation;
DWORD dwStartingJolietDirectoryBlock;
DWORD dwStartingIsoDirectoryBlock;
DWORD dwStartingJolietPathTableBlock;
DWORD dwStartingIsoPathTableBlock;
DWORD dwStartingFileBlock;
DWORD dwTotalImageBlocks;
DWORD dwTotalFileBlocks;
DWORD dwSourceSectorSize;
DWORD dwTotalBufferBytes;
DWORD dwReserveBufferBytes;
DWORD dwMaxQueuedWriteBufferBytes;
DWORD dwNextMetaBlockNumber;
DWORD dwMetaSlackStartingBlock;
DWORD dwMetaSlackNumberOfBlocks;
DWORD dwBlockSize = CD_SECTORSIZE;      // default, but may be changed by option
DWORD dwSlackBytesToWriteAtEndOfFiles;
DWORD dwMetaPaddingBeforeDirectoriesBytes;

DWORDLONG dwlMetaPaddingBeforeDirectoriesOffset;
DWORDLONG dwlTotalHeaderBytes;           // dwStartingFileBlock * dwBlockSize
DWORDLONG dwlTotalImageBytes;            // dwTotalImageBlocks * dwBlockSize
DWORDLONG dwlTotalMetaBytes;             // dwlTotalHeaderBytes plus final block CRC bytes if any
DWORDLONG dwlTotalInitialBytes;
DWORDLONG dwlTotalFileSizes;
DWORDLONG dwlTotalNumberOfFiles;
DWORDLONG dwlTotalNumberOfDirectories;
DWORDLONG dwlNextFileScanReportThreshold;
DWORDLONG dwlNextDirectoryScanReportThreshold;
DWORDLONG dwlTotalDupFiles;
DWORDLONG dwlTotalDupFileBytes;          // allocation size
DWORDLONG dwlReportRawSize;
DWORDLONG dwlReportAllocSize;
DWORDLONG dwlShowTreeAlloc;

DWORD    dwStubFileSize;
DWORD    dwStubFileBlock;
LPSTR    StubFileName;
CHAR     StubSourceFile[ MAX_PATH ];
PCHAR    StubFileContents;
FILETIME ftStubTime;

ULONG ElToritoBootSectorFileSize;
PVOID ElToritoBootSectorFileData;
ULONG ElToritoBootCatalogBlock;
ULONG ElToritoBootSectorBlock;
WORD  ElToritoLoadSegment;

ULONG AutoCrcHeaderBlock;
ULONG AutoCrcFinalBlock;

ULONG ulAnchorSectorNumber = 0;
ULONG ulAnchorSlackSector  = 0;

ULONG HeaderCrc = 0xFFFFFFFF;      // initial CRC value
ULONG FileDataCrc;                 // must start at zero (final header crc)

DEBUGCODE( DWORDLONG dwlNextHeaderOffset );
DEBUGCODE( DWORDLONG dwlNextFileDataOffset );


//
//  All these boolean flags are default FALSE
//

BOOL bReportZeroLength;
BOOL bReportExceedLevels;
BOOL bReportAllFiles;
BOOL bReportInvalidDosNames;
BOOL bReportInvalidIsoNames;
BOOL bUseGlobalTime;
BOOL bAllowLongNames;
BOOL bDontUpcase;
BOOL bOptimizeStorage;
BOOL bOptimizeFast;
BOOL bShowDuplicates;
BOOL bOptimizeDiamond;
BOOL bOptimizeFileNames;
BOOL bSuppressOptimizeFileNames;
BOOL bIgnoreMaxImageSize;
BOOL bAllocationSummary;
BOOL bHiddenFiles;
BOOL bUseAnsiFileNames;
BOOL bRestrictToNt3xCompatibleNames;
BOOL bViolatesNt3xCompatibility;
BOOL bEncodeJoliet;
BOOL bGenerateShortNames;
BOOL bEncodeGMT;
BOOL bElTorito;
BOOL bEncodeAutoCrc;
BOOL bCrcCorrectionInTvd;
BOOL bUnicodeNames;
BOOL bScanOnly;
BOOL bSignImage;
BOOL bSignImageAttempt;
BOOL bSignFooter;
BOOL bRoundDirectorySizes;
BOOL bHackI386Directory;
BOOL bAllowExactAlignedDirs;
BOOL bReportBadShortNames;
BOOL bReportBadShortNameWarning;
BOOL bSuppressWarnSameFirstBlockNotIdentical;
BOOL bContinueAfterFailedSourceOpen;
BOOL bOpenReadWrite = FALSE;
BOOL bFastShortNameGeneration;

// Udf options
BOOL bEncodeUdf;
BOOL bEncodeOnlyUdf;
BOOL bUdfEmbedData;
BOOL bUdfSparse;
BOOL bUdfEmbedFID;
BOOL bUdfUseLongADs;
BOOL bUdfUseRandomExtents;
BOOL bUdfVideoZone;
BOOL bUdf8BitFileNames;
BOOL bUdfXbox;

extern USHORT	 CURRENT_UDF_VERSION;
extern DWORDLONG UniqueID;
extern DWORD     ulVATICBLocation;
#ifdef DONTCOMPILE

    BOOL bOneDirectoryRecordPerSector;
    BOOL bOneDirectoryRecordPerTwoSectors;
    BOOL bOptimizeDepthFirst;
    BOOL bOptimizeDepthAfter;
    BOOL bOptimizeReverseSort;
    BOOL bModifyOrder;

    #define MAX_SPECIFIED_DIRS 100

    LPSTR DirectoryFirst[ MAX_SPECIFIED_DIRS ];
    DWORD nDirectoryFirst;

    LPSTR ReverseSort[ MAX_SPECIFIED_DIRS ];
    DWORD nReverseSort;

#endif // DONTCOMPILE

PDIRENTRY pHackI386Directory;

LPSTR ImageSignatureDescription;
MD5_HASH SignatureHash = MD5_INITIAL_VALUE;
UCHAR SignatureVersionText[ 64 ] = CDIMAGE_SIGNATURE_TEXT;

OSVERSIONINFO OsInfo = { sizeof( OSVERSIONINFO ) };

FILETIME ftGlobalFileTime;

union {
    WCHAR W[ MAX_PATH_LENGTH ];        // 128K
     CHAR A[ MAX_PATH_LENGTH ];        // 64K
    } DescentNameBuffer,
      ReportNameBuffer;

union {
    WIN32_FIND_DATAA A;
    WIN32_FIND_DATAW W;
    } FindData;

void DeleteTargetFile( void );
void OpenTargetFile( void );
void CloseTargetFile( void );
void ScanSourceTree( void );
PDIRENTRY AlphabeticalInsertNode( PDIRENTRY pFirst, PDIRENTRY pNew );
void LinkDirectories( PDIRENTRY pDirNode, UINT uLevel );
void ComputeHeaderBlocks( void );
void ComputeDirectorySizes( void );
void ComputeStartingFileBlockLocation( void );
void AssignDirectoryBlockNumbers( void );
void WriteSecondAnchorSector( void );
void GenerateAndWriteLookupTables( void );
void PadCopy( PUCHAR pDest, UINT uLength, LPSTR pSource );
void MakeLittleEndian( PUCHAR pMem, UINT uBytes, DWORD dwValue );
void MakeBigEndian( PUCHAR pMem, UINT uBytes, DWORD dwValue );
void MakeDualEndian( PUCHAR pMem, UINT uBytes, DWORD dwValue );
void WriteDirectories( void );
void WriteFiles( void );
VOID TransferFileThread( PVOID pParam );
VOID UdfTransferFileThread( PVOID pParam );
BOOL TransferAndCheckForDuplicateFast( PDIRENTRY pFile,
                                       DWORDLONG dwlOffset,
                                       HANDLE    hReadContext,
                                       DWORDLONG dwlFileSize );
BOOL TransferAndCheckForDuplicateSlow( PDIRENTRY pFile,
                                       DWORDLONG dwlOffset,
                                       HANDLE    hReadContext,
                                       DWORDLONG dwlFileSize );
LPSTR AllocFullName( PDIRENTRY pFile );
VOID ReadTargetFile( DWORDLONG dwlOffset, PVOID pBuffer, DWORD dwBytesToRead );
VOID MakeFileDuplicate( PDIRENTRY pFile, PDIRENTRY pPrimary );
VOID ReportTransferProgress( DWORDLONG dwlOffset );
VOID ReportHeaderProgress( DWORDLONG dwlOffset );

PUCHAR MakeRootEntries( PUCHAR pMem, PDIRENTRY pDir );
PUCHAR MakeRootEntry( PUCHAR pMem, PDIRENTRY pDir, UCHAR DirName );

PUCHAR MakeJolietRootEntries( PUCHAR pMem, PDIRENTRY pDir );
PUCHAR MakeJolietRootEntry( PUCHAR pMem, PDIRENTRY pDir, UCHAR DirName );

void GetFilePath( PDIRENTRY pDir, LPSTR pBuffer );
void MakeIsoTimeStampFromFileTime( PUCHAR pMem, FILETIME ftFileTime );
void MakeIsoVolumeCreationTime( PCHAR pMem, FILETIME ftFileTime );
BOOL NonDchars( LPSTR pszFileName );
void ParseOptions( int argc, char *argv[] );
void ParseTimeStamp( LPSTR pArg );
void Usage( void );
BOOL IsDigit( char ch );
BOOL IsValidDosName( LPSTR pszFileName );
BOOL IsAcceptableDosName( LPSTR pszFileName );
BOOL IsAcceptableDosNameW( LPWSTR pszFileName );
BOOL IsValidIsoDirectoryName( LPSTR pszFileName );
BOOL IsValidIsoFileName( LPSTR pszFileName );
void DuplicateFileStorageOptimization( void );
void CopyRight( void );
UINT CompareAligned( PVOID p1, PVOID p2, UINT nSize );
BOOL IsFileNameDotOrDotDot( LPCSTR pszFileName );
void ReportAllocationSummary( void );

LPWSTR AnsiToUnicode( IN LPSTR AnsiBuffer, IN OUT OPTIONAL LPWSTR UnicodeBuffer );
LPSTR UnicodeToAnsi( IN LPWSTR UnicodeBuffer, IN OUT OPTIONAL LPSTR AnsiBuffer );
BOOL IsFileNameDotOrDotDotW( LPCWSTR pszUnicodeName );
PDIRENTRY JolietInsertNode( PDIRENTRY pFirst, PDIRENTRY pNew );
void ComputeJolietDirectorySizes( void );
void GenerateShortNames( void );
void GetStubFileContents( void );
void GenerateStubs( void );

void WritePrimaryVolumeDescriptor( ULONG SectorNumber );
void WriteJolietVolumeDescriptor( ULONG SectorNumber );
void WriteElToritoBootVolumeDescriptor( ULONG SectorNumber );
void WriteVolumeDescriptorTerminator( ULONG SectorNumber );
void WriteElToritoBootCatalog( ULONG SectorNumber );
void WriteElToritoBootSector( ULONG SectorNumber );
void UniCopy( PUCHAR pDest, UINT uLength, LPSTR pSource );
void CopyAndInvertUnicode( LPWSTR TargetBuffer, LPWSTR SourceBuffer, ULONG ByteCount );
void GenerateAndWriteJolietLookupTables( void );
void WriteJolietDirectories( void );
void LinkAlternateDirectories( PDIRENTRY pDirNode, UINT uLevel );
PDIRENTRY RecursiveGenerateShortNames( PDIRENTRY pParentDir );
PDIRENTRY GenerateAndInsertShortName( PDIRENTRY pFirstFile, PDIRENTRY pNewFile );
void ComputeAlternateDirectorySizes( void );
void GenerateAndWriteAlternateLookupTables( void );
void WriteAlternateDirectories( void );
void WriteStubs( void );
void ComputeModifiedOrdering( void );

void ShowIsoTree( void );
void ShowJolietTree( void );
void ShowAlternateTree( void );

PDIRENTRY StartRecursiveDescent( void );


VOID EnqueueUdfFiles(PTRANSFER_CONTEXT pTx, PDWORDLONG pdwlTotalSourceBytes);

PDIRENTRY
RecursiveDescent(
    PDIRENTRY pParentDir,
    LPSTR     DescentBufferPointer,
    ULONG     Depth,
    ULONG     NameLengthOfParents
    );

BOOL IsValidJolietFileName( LPWSTR FileName );

PDIRENTRY StartRecursiveDescentJoliet( void );

PDIRENTRY
RecursiveDescentJoliet(
    PDIRENTRY pParentDir,
    LPWSTR    DescentBufferPointer,
    ULONG     Depth,
    ULONG     NameLengthOfParents
    );

LPSTR  GenerateFullName(  PDIRENTRY pDir, LPSTR  pBuffer );
LPWSTR GenerateFullNameW( PDIRENTRY pDir, LPWSTR pBuffer );
LPSTR  GenerateFullNameSource(  PDIRENTRY pDir, LPSTR  pBuffer );
LPWSTR GenerateFullNameSourceW( PDIRENTRY pDir, LPWSTR pBuffer );

VOID ReadElToritoBootSectorFile( PCHAR ElToritoBootSectorFileName );
VOID WriteAutoCrcHeaderBlock( VOID );
VOID WriteAutoCrcFinalBlock( VOID );

VOID
HeaderWrite(
    IN DWORDLONG Offset,
    IN PVOID     Buffer,
    IN ULONG     Length
    );

VOID
FileDataWrite(
    IN DWORDLONG Offset,
    IN PVOID     Buffer,
    IN ULONG     Length
    );

VOID
LargeDataSplitWrite(
    IN DWORDLONG Offset,
    IN PVOID     Buffer,
    IN ULONG     Length
    );

VOID
GenericWrite(
    IN DWORDLONG Offset,
    IN PVOID     Buffer,
    IN ULONG     Length
    );

DWORD
AllocateMetaBlocks(
    IN DWORD SizeInBytes
    );

DWORD
AllocateMetaBlocksSectorAligned(
    IN DWORD SizeInBytes
    );

VOID
WriteZeroedSectors(
    IN DWORD SectorNumber,
    IN DWORD NumberOfSectors
    );

VOID
WriteZeroedBlocks(
    IN DWORD BlockNumber,
    IN DWORD NumberOfBlocks
    );

VOID
GenerateSignatureDescription(
    VOID
    );

BOOL
InitSignatureStuff(
    VOID
    );

BOOL
GenerateImageSignature(
    IN  PMD5_HASH HashValue,
    IN  LPSTR     SignatureDescription,
    OUT PDWORD    SignatureIdentfier,
    OUT PUCHAR    SignatureBuffer
    );


VOID
ReportScanProgress(
    VOID
    )
    {
    fprintf( stderr ,
        "\rScanning source tree (%I64d files in %I64d directories) ",
        dwlTotalNumberOfFiles,
        dwlTotalNumberOfDirectories
        );
    fflush( stdout );
    }


VOID
IncrementTotalNumberOfDirectories(
    VOID
    )
    {
    if ( ++dwlTotalNumberOfDirectories >= dwlNextDirectoryScanReportThreshold ) {
        dwlNextDirectoryScanReportThreshold += SCAN_REPORT_INCREMENT;
        ReportScanProgress();
        }
    }


VOID
IncrementTotalNumberOfFiles(
    VOID
    )
    {
    if ( ++dwlTotalNumberOfFiles >= dwlNextFileScanReportThreshold ) {
        dwlNextFileScanReportThreshold += SCAN_REPORT_INCREMENT;
        ReportScanProgress();
        }
    }


//////////////////////////////////////////////////////////////////////////////

#ifdef DONTCOMPILE

void ShowTree( PDIRENTRY pFirstNode, UINT uLevel ) {

    PDIRENTRY p;

    for ( p = pFirstNode; p != NULL; p = p->pNextTargetFile ) {

        printf( "%*s%s %9I64d bytes %9d block-location\r\n",
                uLevel * 2,
                "",
                p->pszFileName,
                p->dwlFileSize,
                p->dwStartingBlock );

        if ( p->dwFlags & IS_DIRECTORY ) {
            ASSERT( p->pDirectoryInfo != NULL );
            ShowTree( p->pDirectoryInfo->pFirstTargetFile, uLevel + 1 );
            }
        }
    }

#endif // DONTCOMPILE

#ifdef DONTCOMPILE

VOID
TestMD5(
    VOID
    );

#endif // DONTCOMPILE


void _cdecl main( int argc, char *argv[] ) {

    SYSTEMTIME st;
    ULONG SectorNumber;
    int i;

//  TestMD5();

    CopyRight();

    //
    //  CDIMAGE makes extensive use of 64-bit OVERLAPPED file i/o, which is
    //  currently only supported on WinNT, and not on Win95 or Win32s.
    //

    GetVersionEx( &OsInfo );

    //
    //  CDIMAGE requires NT 4.0 and will not work on NT 3.51 or Win95.
    //

    if (( OsInfo.dwPlatformId != VER_PLATFORM_WIN32_NT ) ||
        ( OsInfo.dwMajorVersion < 4 )) {

        printf( CDIMAGE_NAME " requires Windows NT 4.0 or Windows 2000\r\n" );
        fflush( stdout );
        exit( 1 );
        }

    SetErrorMode( SEM_FAILCRITICALERRORS );

    InitializeErrorHandler();

    InitializeRecyclePackage();

    MyHeapInit();

    InitializeNtDllPointers();  //  CDIMAGE will still work even if this fails,
                                //  although GetSectorSize() will have to take
                                //  the slow path-name-based route, and
                                //  MyIsDebuggerPresent will always return
                                //  FALSE.

    //
    //  To make two subsequently created images of the same tree of files
    //  the same, chop the time portion of the stamp to midnight.  This will
    //  cause the root directory to get the same time stamp twice on two
    //  subsequently created images on the same day.
    //

    GetSystemTime( &st );

    st.wHour         = 0;
    st.wMinute       = 0;
    st.wSecond       = 0;
    st.wMilliseconds = 0;

    SystemTimeToFileTime( &st, &ftGlobalFileTime );

    ParseOptions( argc, argv );     // this might change ftGlobalFileTime

    if ( bUseAnsiFileNames )
        SetFileApisToANSI();
    else
        SetFileApisToOEM();


    if ( bEncodeGMT ) {

        IsoLocalTimeBias = 0;
        NsrLocalTimeBias = 0;
        LocalTimeBiasInFileTimeUnits = 0;

        }

    else {

        TIME_ZONE_INFORMATION tz;
        LONG CurrentBias = 0;

        switch( GetTimeZoneInformation( &tz )) {

            case TIME_ZONE_ID_STANDARD:

                CurrentBias = tz.Bias + tz.StandardBias;
                break;

            case TIME_ZONE_ID_DAYLIGHT:

                CurrentBias = tz.Bias + tz.DaylightBias;
                break;

            case TIME_ZONE_ID_UNKNOWN:

                CurrentBias = tz.Bias;
                break;

            default:

                ErrorExit(
                    GETLASTERROR,
                    "\r\nERROR: Unable to determine time zone bias\r\n"
                    );

            }

        NsrLocalTimeBias = (short) -( CurrentBias );

        ASSERT(( NsrLocalTimeBias >= TIMESTAMP_Z_MIN ) &&
               ( NsrLocalTimeBias <= TIMESTAMP_Z_MAX ));

        // IsoLocalTimeBias is number of 15 minute intervals from -48 (west) to +52 (east)

        ASSERT((( -( CurrentBias ) / 15 ) >= -48 ) && (( -( CurrentBias ) / 15 ) <= +52 ));

        IsoLocalTimeBias = (signed char)( -( CurrentBias ) / 15 );

        ASSERT(( IsoLocalTimeBias >= -48 ) && ( IsoLocalTimeBias <= +52 ));

        if (( IsoLocalTimeBias < -48 ) || ( IsoLocalTimeBias > +52 )) {
            IsoLocalTimeBias = 0;
            }

        LocalTimeBiasInFileTimeUnits = (LONGLONG) IsoLocalTimeBias      // 15 minute intervals
                                     * (LONGLONG) 15                    // minutes
                                     * (LONGLONG) 60                    // seconds
                                     * (LONGLONG) 1000                  // milliseconds
                                     * (LONGLONG) 1000                  // microseconds
                                     * (LONGLONG) 10;                   // 100-nanoseconds

        if ( bUseGlobalTime ) {

            //
            //  User-specified time is in local time, but we need it
            //  to be system time.
            //

            *(UNALIGNED DWORDLONG*)&ftGlobalFileTime -= LocalTimeBiasInFileTimeUnits;

            }
        }

    MakeIsoTimeStampFromFileTime( cGlobalIsoTimeStamp, ftGlobalFileTime );
    MakeNsrTimeStampFromFileTime( &GlobalNsrTimeStamp, ftGlobalFileTime );

    MakeIsoVolumeCreationTime( IsoVolumeCreationTime, ftGlobalFileTime );

    i = 1;

    while (( i < argc ) && ( argv[ i ] == NULL ))
        ++i;

    if ( i < argc ) {

        pszSourceTree = argv[ i++ ];

        while (( i < argc ) && ( argv[ i ] == NULL ))
            ++i;

        if ( i < argc ) {

            pszTargetFile = argv[ i ];

            if ( bScanOnly )
                Usage();

            }
        else {

            if ( ! bScanOnly )
                Usage();

            }
        }
    else {
        Usage();
        }


#ifndef DVDIMAGE_ONLY

    if ( bSignImage ) {
        if ( ! InitSignatureStuff() ) {
            bSignImage = FALSE;
            }
        }

    if ( bSignImage ) {
        bEncodeAutoCrc = TRUE;     // BUGBUG: requirement for now, so force on
        }

#endif // ! DVDIMAGE_ONLY


    InitializeThreadPool(( bOptimizeStorage ) && ( ! bOptimizeFast ) ? 5 : 4 );

    dwTotalBufferBytes = AdjustWorkingSetAndLockImage(
                             bOptimizeStorage ? 0x200000 : 0x100000,
                             FX_BLOCKSIZE
                             );

    if ( ! bScanOnly )
        DeleteTargetFile();

    printf( "\r\nScanning source tree " );
    fflush( stdout );

    dwlNextFileScanReportThreshold      = SCAN_REPORT_INCREMENT;
    dwlNextDirectoryScanReportThreshold = SCAN_REPORT_INCREMENT;

    ScanSourceTree();

    printf( "\rScanning source tree complete (%I64d files in %I64d directories)\r\n",
            dwlTotalNumberOfFiles,
            dwlTotalNumberOfDirectories
            );
    fflush( stdout );

    printf( "\r\nComputing directory information " );
    fflush( stdout );

//  ShowTree( pRootDir, 0 );

    LinkDirectories( pRootDir, 0 );

#ifdef DONTCOMPILE
    if ( bModifyOrder )
        ComputeModifiedOrdering();
#endif // DONTCOMPILE

    ComputeHeaderBlocks();      // ISO-9660 Volume Descriptor sequence

    if( bElTorito ) {
        ElToritoBootCatalogBlock = AllocateMetaBlocksSectorAligned( 1 );
        }

    if ( ! bEncodeOnlyUdf ) {

        if ( bEncodeJoliet ) {

            if ( bGenerateShortNames )
                GenerateShortNames();
            else
                GenerateStubs();

            ComputeJolietDirectorySizes();

            ComputeAlternateDirectorySizes();

            }

        else {

            if( bEncodeUdf ) {
			
    		    GenerateShortNames();
            }

            ComputeDirectorySizes();

            }
        }

    else {

        GenerateStubs();

        ComputeAlternateDirectorySizes();

        }

    AssignDirectoryBlockNumbers();

    if ( bEncodeUdf ) {
        if (bUdfVideoZone)
        {
            SetCurrentUDFVersion(0x102);
            printf("\nUDF Video Zone Compatibility - Setting version to 1.02");
        }
        else
		    SetCurrentUDFVersion(0x150);

		ASSERT( dwBlockSize == CD_SECTORSIZE );

        if ( dwNextMetaBlockNumber < ANCHOR_SECTOR ) {

            //
            //  Waste remaining sectors up to ANCHOR_SECTOR.
            //

            ASSERT( dwMetaSlackStartingBlock == 0 );

            dwMetaSlackStartingBlock  = dwNextMetaBlockNumber;
            dwMetaSlackNumberOfBlocks = ANCHOR_SECTOR - dwMetaSlackStartingBlock;
            dwNextMetaBlockNumber     = ANCHOR_SECTOR + 1;

            DEBUGCODE( printf( "\r\nWARNING: UDF meta data has %d sectors of slack space\r\n",
                               dwMetaSlackNumberOfBlocks ));

            }

        else {

            //
            //  Even if dwMetaSlackNumberOfBlocks is zero,
            //  dwMetaSlackStartingBlock should be non-zero in this
            //  case, indicating the anchor has been correctly skipped.
            //

            ASSERT( dwMetaSlackStartingBlock != 0 );

            }

        ComputeUDFDirectorySizes();
        AssignUDFDirectoryBlockNumbers();

        }

    if( bElTorito ) {
        ElToritoBootSectorBlock = AllocateMetaBlocksSectorAligned( ElToritoBootSectorFileSize );
        }

    ASSERT( IS_SECTOR_ALIGNED( dwNextMetaBlockNumber * dwBlockSize ));

    if ( bEncodeAutoCrc ) {
        AutoCrcHeaderBlock = AllocateMetaBlocksSectorAligned( 1 );
        }

    ComputeStartingFileBlockLocation();

    if ( bEncodeUdf )
        ComputeUDFPartitionLength();

    printf( "\rComputing directory information complete\r\n" );
    fflush( stdout );

    printf( "\r\nImage file %s %I64d bytes %s\r\n",
            bScanOnly ? "would be" : "is",
            dwlTotalImageBytes,
            bOptimizeStorage ? "(before optimization)" : "" );
    fflush( stdout );

    if (( ! bIgnoreMaxImageSize ) &&
        ( ! bOptimizeStorage    ) &&
        ( dwlTotalImageBytes > MAX_IMAGE_BYTES )) {

        ErrorExit(
            0,
            "ERROR: Image is %I64d bytes too large for 74-minute CD (" MAX_IMAGE_BYTES_TEXT ")\r\n"
            "       (use -m to override%s\r\n",
            dwlTotalImageBytes - MAX_IMAGE_BYTES,
            " or try -o to optimize storage)"
            );
        }

    if (( bScanOnly ) && ( ! bOptimizeStorage )) {

        printf( "\r\nNo image file created (-q option selected)\r\n" );
        printf( "Done.\r\n" );
        fflush( stdout );

        if ( bAllocationSummary ) {
            ReportAllocationSummary();
            }

        exit( 0 );
        }

    OpenTargetFile();

    if ( bScanOnly ) {
        printf( "\r\nReading %I64d files in %I64d directories\r\n",
                dwlTotalNumberOfFiles,
                dwlTotalNumberOfDirectories
                );
        }
    else {
        printf( "\r\nWriting %I64d files in %I64d directories to %s\r\n",
                dwlTotalNumberOfFiles,
                dwlTotalNumberOfDirectories,
                pszTargetFile
                );
        }

    printf( "\r\n" );

    fflush( stdout );

    if (( bOptimizeStorage ) && ( ! bScanOnly )) {

        if ( bOptimizeFast ) {

            //
            //  Need to maintain three free read buffers for
            //  optimal read-ahead speed while queueing as
            //  many writes as possible.
            //

            dwReserveBufferBytes = 3 * FX_BLOCKSIZE;

            }

        else {

            //
            //  For slow optimization where we're reading both
            //  the source file and it's suspect duplicate, we
            //  need twice as many free read-ahead buffers.
            //

            dwReserveBufferBytes = 6 * FX_BLOCKSIZE;

            }
        }

    else {

        dwReserveBufferBytes = 0;

        }

    dwTotalBufferBytes = InitializeBufferAllocator(
                             dwTotalBufferBytes,
                             dwReserveBufferBytes + ( 2 * FX_BLOCKSIZE ),
                             FX_BLOCKSIZE
                             );

    dwMaxQueuedWriteBufferBytes = dwTotalBufferBytes - dwReserveBufferBytes;

    WriteFiles();

  
    DEBUGCODE( printf("\r\nDone transfering files - writing directory information\r\n" ));

#ifdef DONTCOMPILE

    printf( "\r\n" );

    if ( bEncodeJoliet ) {
        ShowJolietTree();
        ShowAlternateTree();
        if ( bGenerateShortNames )
            ShowIsoTree();
        }

    printf( "\r\n" );

#endif // DONTCOMPILE

    WriteZeroedSectors( 0, 16 );    // initial 16 sectors of zeros

    SectorNumber = 16;              // start of volume descriptor sequence

    WritePrimaryVolumeDescriptor( SectorNumber++ );

    if ( bElTorito )
        WriteElToritoBootVolumeDescriptor( SectorNumber++ );

    if ( bEncodeJoliet )
        WriteJolietVolumeDescriptor( SectorNumber++ );

    WriteVolumeDescriptorTerminator( SectorNumber++ );

    if ( bEncodeUdf ) {

        //
        //  UDF volume recognition sequence must follow immediately
        //  behind ISO-9660 volume descriptor terminator.
        //

        WriteBEA01Descriptor( SectorNumber++ );
		WriteNSRDescriptor(SectorNumber++);
        WriteTEA01Descriptor( SectorNumber++ );

        }

    if ( bElTorito ) {

        WriteElToritoBootCatalog( SectorNumber++ );
        }

    if ( bEncodeJoliet ) {
        GenerateAndWriteJolietLookupTables();
        }

    if ( bEncodeJoliet || bEncodeOnlyUdf ) {
        GenerateAndWriteAlternateLookupTables();
        }
    else {
        GenerateAndWriteLookupTables();
        }


    if (( bEncodeOnlyUdf ) || (( bEncodeJoliet ) && ( ! bGenerateShortNames ))) {
        ASSERT( dwStubFileBlock != 0 );
        WriteStubs();
        }
    else {
        ASSERT( dwStubFileBlock == 0 );
        }

    if ( dwlMetaPaddingBeforeDirectoriesOffset ) {

        PVOID pBuffer = AllocateBuffer( dwMetaPaddingBeforeDirectoriesBytes, TRUE );

        HeaderWrite( dwlMetaPaddingBeforeDirectoriesOffset, pBuffer, dwMetaPaddingBeforeDirectoriesBytes );

        }


    ASSERT( IS_SECTOR_ALIGNED( dwlNextHeaderOffset ));


    if ( ! bEncodeOnlyUdf ) {

        if ( bEncodeJoliet ) {

            WriteJolietDirectories();

            WriteAlternateDirectories();

            }

        else {

            WriteDirectories();

            }
        }

    else {

        WriteAlternateDirectories();

        }


    if ( bEncodeUdf ) {

        ASSERT( dwBlockSize == CD_SECTORSIZE );

        if ( dwMetaSlackNumberOfBlocks != 0 ) {
            ASSERT( dwMetaSlackStartingBlock + dwMetaSlackNumberOfBlocks == ANCHOR_SECTOR );
            WriteZeroedBlocks( dwMetaSlackStartingBlock, dwMetaSlackNumberOfBlocks );
            }

        // write UDF Anchor Pointer and Volume Descriptor Sequences

        // BUGBUG - write directories first because partition size might change
        WriteUDFDirectories();

        WriteUDFAnchorAndVDS();

		
		ulAnchorSectorNumber = dwTotalImageBlocks-1;
      

        WriteSecondAnchorSector();
		
	    }

    if ( bElTorito ) {
        WriteElToritoBootSector( ElToritoBootSectorBlock );
        }

    if ( bEncodeAutoCrc ) {
        ASSERT( ! bEncodeUdf );     // UDF writes sectors out of sequential order
        WriteAutoCrcHeaderBlock();
        }

    if (( bEncodeAutoCrc ) || ( bSignImage )) {
        WriteAutoCrcFinalBlock();
        }

    if ( bReportAllFiles )
        printf( "\r\n" );
    else
        fprintf( stderr, "\r100%% complete\r\n" );

    fflush( stdout );

    if ( bSignImage ) {
        printf( "\r\nImage contains digital signature\r\n" );
        fflush( stdout );
        }

    if ( bOptimizeStorage ) {

        printf( "\r\nStorage optimization saved %I64d files, %I64d bytes (%d%% of image)\r\n",
                dwlTotalDupFiles,
                dwlTotalDupFileBytes,
                ( 100 - (DWORD)(( dwlTotalImageBytes * 100 ) / dwlTotalInitialBytes )));

        fflush( stdout );

//
//  Note that percent of bytes in files is a more impressive figure, but less
//  meaningful that percent of bytes in image.
//
//              (DWORD)(((DWORDLONG)dwTotalDupFileBytes * 100 ) / ( dwTotalFileBlocks * dwBlockSize )));
//

        printf( "\r\nAfter optimization, image file %s %I64d bytes\r\n",
                bScanOnly ? "would be" : "is",
                dwlTotalImageBytes
              );

        fflush( stdout );

        if (( ! bIgnoreMaxImageSize ) && ( dwlTotalImageBytes > MAX_IMAGE_BYTES )) {

            ErrorExit(
                0,
                "ERROR: Image is %I64d bytes too large for 74-minute CD (" MAX_IMAGE_BYTES_TEXT ")\r\n"
                "       (use -m to override%s\r\n",
                dwlTotalImageBytes - MAX_IMAGE_BYTES,
                ")"
                );
            }
        }

    else {

        printf( "\r\nFinal image file %s %I64d bytes\r\n",
                bScanOnly ? "would be" : "is",
                dwlTotalImageBytes
              );

        }

    DEBUGCODE( printf( "\r\nFlushing buffers\r\n" ));

    CloseTargetFile();

    DEBUGCODE( printf( "\r\nMaxBtreeDepth=%d\r\n", nMaxBtreeDepth ));

    if ( bViolatesNt3xCompatibility ) {

        printf(
            "\r\n"
            "WARNING: This image contains filenames and/or directory names that are\r\n"
            "         NOT COMPATIBLE with Windows NT 3.51.  If compatibility with\r\n"
            "         Windows NT 3.51 is required, use the -nt switch rather than\r\n"
            "         the -n switch.\r\n"
            "\r\n"
            );
        fflush( stdout );
        }

    if ( bReportBadShortNameWarning ) {
        printf(
            "\r\n"
            "WARNING: This image contains filenames and/or directory names that might be\r\n"
            "         inaccessible to 16-bit applications running under Windows NT 4.0\r\n"
            "         without Service Pack 2+.  An obscure bug in Windows NT 4.0 prevents\r\n"
            "         16-bit apps from opening some enumerated files and directories that\r\n"
            "         have long names when the hexadecimal \"uniquifier\" of the generated\r\n"
            "         short name contains non-numeric characters (a function of the offset\r\n"
            "         of the directory entry within the directory).  This problem only\r\n"
            "         occurs for 16-bit apps that try to open enumerated files on the CD,\r\n"
            "         not for 16-bit apps that open specific files according to a list of\r\n"
            "         filenames such as most 16-bit setup applications.  For more info\r\n"
            "         about this particular issue, email \"cdmakers\".\r\n"
            "\r\n"
            );
        fflush( stdout );
        }

    if ( bEncodeUdf ) {

        printf(
            "\r\n"
            "WARNING: This image contains UDF file system structures.\r\n"
            "\r\n"
            );
        if(bUdfEmbedData || bUdfSparse || bUdfEmbedFID || bOptimizeStorage)
            printf("Space saved because of embedding, sparseness or optimization = %u\r\n",gdwSpaceSaved);

        if(bUdfSparse)
            printf("\r\nWARNING: This image may be unusable on Win9x due to possible sparse files\r\n");

        fflush( stdout );
        }

    if ( bSignImageAttempt && ! bSignImage ) {

        printf(
            "\r\n"
            "WARNING: IMAGE DOES NOT CONTAIN DIGITAL SIGNATURE AS REQUESTED.\r\n"
            "\r\n"
            );
        fflush( stdout );
        }

    if ( bScanOnly ) {
        printf( "\r\nNo image file created (-q option selected)\r\n" );
        }

    printf( "\r\nDone.\r\n" );
    fflush( stdout );

    if ( bAllocationSummary ) {
        ReportAllocationSummary();
        }

    exit( 0 );

    }


void CopyRight( void ) {

    printf( "\r\n"

#ifdef DVDIMAGE_ONLY

            "%s DVD-ROM Premastering Utility\r\n"

#else   // ! DVDIMAGE_ONLY

            "%s CD-ROM and DVD-ROM Premastering Utility\r\n"

#endif // DVDIMAGE_ONLY

            "Copyright (C) Microsoft, 1993-2001.  All rights reserved.\r\n"
#ifdef XBOX
            "For Xbox Use Only\r\n"
#else  // XBOX
            "For Microsoft internal use only.\r\n"
#endif // XBOX
            "\r\n",
            MAJOR_VERSION_TEXT
          );

#ifdef PRIVATE_BUILD_TEXT
    printf( PRIVATE_BUILD_TEXT );
#endif

    fflush( stdout );

    }


VOID
AbortTargetFile(
    PVOID pContext
    )
    {
    if ( hTargetFile != NULL )
        AbortWriter( (HANDLE)pContext );
    }


void OpenTargetFile( void ) {

    dwlTotalInitialBytes = dwlTotalImageBytes;

    if ( ! bScanOnly ) {

        hTargetContext = CreateWriteContext( pszTargetFile,         // file name
                                             0,                     // sector size
                                             dwlTotalInitialBytes,  // initial size
                                             MAX_QUEUED_WRITES );   // concurrent

        if ( hTargetContext == NULL ) {
            ErrorExit( GETLASTERROR,
                       "ERROR: Unable to create file \"%s\" of %I64d bytes\r\n",
                       pszTargetFile,
                       dwlTotalInitialBytes );
            }


        hTargetFile = GetFileHandleFromWriteContext( hTargetContext );

        //
        //  NOTE:  This app assumes that a sector size of dwBlockSize (512 or 2048)
        //         is sufficient alignment for overlapped/unbuffered i/o on
        //         the target image file.  It's ok for the target image file's
        //         sector alignment requirement to be smaller than dwBlockSize, but
        //         it cannot be larger than dwBlockSize since we do writes to the
        //         target in dwBlockSize aligned offsets and lengths.
        //

#ifdef DEBUG
        {
        DWORD dwSectorSize;

        dwSectorSize = GetSectorSize( hTargetFile, NULL, pszTargetFile );

        ASSERT( dwSectorSize != 0 );
        ASSERT( dwSectorSize <= dwBlockSize );
        ASSERT( ISALIGN2( dwBlockSize, dwSectorSize ));
        }
#endif

        RegisterTerminationHandler( AbortTargetFile, (PVOID)hTargetContext );

        }
    }


void CloseTargetFile( void ) {
    DWORDLONG dwlLength;
    hTargetFile = NULL;
    dwlLength=(DWORDLONG) dwTotalImageBlocks * (DWORDLONG) dwBlockSize;
    ASSERT( IS_SECTOR_ALIGNED( dwlLength ));
    CloseWriteContext( hTargetContext, dwlLength);
    }


PDIRENTRY
NewDirNode(
    IN BOOL IsDirectory
    )
    {
    PDIRENTRY NewNode = MyAllocNeverFree( sizeof( DIRENTRY ));

    if ( IsDirectory ) {
        NewNode->dwFlags = IS_DIRECTORY;
        NewNode->pDirectoryInfo = MyAllocNeverFree( sizeof( DIRECTORY_INFO ));
        }

    if ( ! bUseGlobalTime )
        NewNode->pFileTimeInfo = MyAllocNeverFree( sizeof( FILETIME_INFO ));

    if ( bEncodeUdf )
    {
        NewNode->pUdfInfo = MyAllocNeverFree( sizeof( UDFINFO ));
        NewNode->pUdfInfo->ulICBBlockNumber=0;
        NewNode->pUdfInfo->ulLinkCount=0;
    }

    return NewNode;
    }


VOID DetermineRootPath( VOID ) {

    WCHAR  UnicodeBuffer[ MAX_NAME_LENGTH ];
    WCHAR  UnicodeSource[ MAX_NAME_LENGTH ];
    CHAR   AnsiBuffer[ MAX_NAME_LENGTH ];
    ULONG  Length;
    LPSTR  NotUsed;
    LPWSTR NotUsedW;

    *AnsiBuffer = 0;        // in case GetFullPathName fails

    GetFullPathNameA(
        pszSourceTree,
        MAX_NAME_LENGTH,
        AnsiBuffer,
        &NotUsed
        );

    Length = strlen( AnsiBuffer );

    if ( Length == 0 ) {
        strcpy( AnsiBuffer, "." );
        Length = 1;
        }

    if (( AnsiBuffer[ Length - 1 ] != '\\' ) &&
        ( AnsiBuffer[ Length - 1 ] != ':' )) {
        strcat( AnsiBuffer, "\\" );
        }

    strcpy( szRootPath, AnsiBuffer );

    if ( bUnicodeNames ) {

        AnsiToUnicode( pszSourceTree, UnicodeSource );

        *UnicodeBuffer = 0;     // in case GetFullPathName fails

        GetFullPathNameW(
            UnicodeSource,
            MAX_NAME_LENGTH,
            UnicodeBuffer,
            &NotUsedW
            );

        Length = lstrlenW( UnicodeBuffer );

        if ( Length == 0 ) {
            lstrcpyW( UnicodeBuffer, (LPCWSTR)L"." );
            Length = 1;
            }

        if (( UnicodeBuffer[ Length - 1 ] != L'\\' ) &&
            ( UnicodeBuffer[ Length - 1 ] != L':' )) {
            lstrcatW( UnicodeBuffer, (LPCWSTR)L"\\" );
            }

        lstrcpyW( UnicodeSource, (LPCWSTR)L"\\\\?\\" );

        if (( wcsncmp( UnicodeBuffer, (LPCWSTR)L"\\\\",    2 ) == 0 ) &&
            ( wcsncmp( UnicodeBuffer, (LPCWSTR)L"\\\\.\\", 4 ) != 0 )) {

            lstrcatW( UnicodeSource, (LPCWSTR)L"UNC" );
            lstrcatW( UnicodeSource, UnicodeBuffer + 1 );

            }

        else {

            lstrcatW( UnicodeSource, UnicodeBuffer );

            }

        lstrcpyW( UnicodeRootPath, UnicodeSource );

        }

    }


void ScanSourceTree( void ) {

    HANDLE hFind;

    DetermineRootPath();

    if ( ! bDontUpcase )
        strupr( szRootPath );

    pRootDir = NewDirNode( TRUE );
    pRootDir->pszFileName         = "";
    pRootDir->pszUnicodeName      = (LPWSTR)L"";
    pRootDir->wFileNameLength     = 1;
    pRootDir->wUnicodeNameLength  = 1;
    pRootDir->pParentDir          = pRootDir;

    ASSERT( pRootDir->pDirectoryInfo != NULL );

    if ( ! bUseGlobalTime ) {

        ASSERT( pRootDir->pFileTimeInfo != NULL );

        //
        //  Note that the Joliet root directory name is also a single byte.
        //  For both cases, the name of the root directory is a single 0x00.
        //

        if ( bUnicodeNames ) {

            hFind = FindFirstFileW( UnicodeRootPath, &FindData.W );

            if ( hFind == INVALID_HANDLE_VALUE ) {

                //
                //  Try removing trailing backslash if not "c:\"
                //

                LPWSTR p = wcschr( UnicodeRootPath, 0 ) - 1;

                if (( *p == L'\\' ) && ( *( p - 1 ) != L':' )) {

                    *p = 0;     // truncate trailing backslash

                    hFind = FindFirstFileW( UnicodeRootPath, &FindData.W );

                    *p = '\\';  // replace trailing backslash

                    }
                }
            }

        else {

            hFind = FindFirstFileA( szRootPath, &FindData.A );

            if (( hFind == INVALID_HANDLE_VALUE ) && ( strlen( szRootPath ) > 1 )) {

                //
                //  Try removing trailing backslash if not "c:\"
                //

                LPSTR p = strchr( szRootPath, 0 ) - 1;

                if (( *p == '\\' ) && ( *( p - 1 ) != ':' )) {

                    *p = 0;     // truncate trailing backslash

                    hFind = FindFirstFileA( szRootPath, &FindData.A );

                    *p = '\\';  // replace trailing backslash

                    }
                }
            }


        if ( hFind != INVALID_HANDLE_VALUE ) {
            FindClose( hFind );
            if ( bUnicodeNames ) {
                pRootDir->pFileTimeInfo->ftLastWriteTime  = FindData.W.ftLastWriteTime;
                pRootDir->pFileTimeInfo->ftLastAccessTime = FindData.W.ftLastAccessTime;
                pRootDir->pFileTimeInfo->ftCreationTime   = FindData.W.ftCreationTime;
                }
            else {
                pRootDir->pFileTimeInfo->ftLastWriteTime  = FindData.A.ftLastWriteTime;
                pRootDir->pFileTimeInfo->ftLastAccessTime = FindData.A.ftLastAccessTime;
                pRootDir->pFileTimeInfo->ftCreationTime   = FindData.A.ftCreationTime;
                }
            }
        else {
            pRootDir->pFileTimeInfo->ftLastWriteTime  = ftGlobalFileTime;
            pRootDir->pFileTimeInfo->ftLastAccessTime = ftGlobalFileTime;
            pRootDir->pFileTimeInfo->ftCreationTime   = ftGlobalFileTime;
            }

        }


    if ( bUnicodeNames ) {
        pRootDir->pDirectoryInfo->pFirstTargetFile = StartRecursiveDescentJoliet();
        }
    else {
        pRootDir->pDirectoryInfo->pFirstTargetFile = StartRecursiveDescent();
        }

    if ( pRootDir->pDirectoryInfo->pFirstTargetFile == NULL ) {
        ErrorExit( 0, "ERROR: No files found in \"%s\"\r\n", szRootPath );
        }
    }


PDIRENTRY AlphabeticalInsertNode( PDIRENTRY pFirst, PDIRENTRY pNew ) {

    PDIRENTRY pPrev, pNext;
    PCHAR p, q;
    INT iCmp;

    if (( p = strchr( pNew->pszFileName, '.' )) != NULL )
        *p = 0x01;      // for sorting purposes

    for ( pPrev = NULL, pNext = pFirst;
          pNext != NULL;
          pPrev = pNext, pNext = pNext->pNextTargetFile ) {

        if (( q = strchr( pNext->pszFileName, '.' )) != NULL )
            *q = 0x01;      // for sorting purposes

        iCmp = strcmp( pNew->pszFileName, pNext->pszFileName );

        if ( q != NULL )
            *q = '.';       // restore character changed for sorting

        if ( iCmp < 0 )
            break;

        }

    if ( p != NULL )
        *p = '.';       // restore character changed for sorting

    pNew->pNextTargetFile = pNext;

    if ( pPrev == NULL )
        return pNew;
    else {
        pPrev->pNextTargetFile = pNew;
        return pFirst;
        }

    }


void LinkDirectories( PDIRENTRY pDirNode, UINT uLevel ) {

    PDIRENTRY p;

    if ( uLevel >= MAX_LEVELS ) {
        ErrorExit( 0, "ERROR: Directory depth greater than %d levels.\r\n", MAX_LEVELS );
        }

    p = pStartOfLevel[ uLevel ];

    if ( p == NULL )
        pStartOfLevel[ uLevel ] = pDirNode;
    else {
        ASSERT( p->pDirectoryInfo != NULL );
        while ( p->pDirectoryInfo->pNextTargetDir != NULL ) {
            p = p->pDirectoryInfo->pNextTargetDir;
            ASSERT( p->pDirectoryInfo != NULL );
            }
        p->pDirectoryInfo->pNextTargetDir = pDirNode;
        }

    for ( p = pDirNode->pDirectoryInfo->pFirstTargetFile; p != NULL; p = p->pNextTargetFile ) {
        if ( p->dwFlags & IS_DIRECTORY ) {
            ASSERT( p->pDirectoryInfo != NULL );
            LinkDirectories( p, uLevel + 1 );
            }
        }
    }


void ComputeDirectorySizes( void ) {

    PDIRENTRY pDir, pFile;
    DWORD dwDirOffset, dwTableOffset, dwNextBound, dwNextLimit, dwEntryLen;
    UINT uLevel;
    CHAR OddNameBuffer[ 224 ];      // 221 is absolute max name length
    CHAR EvenNameBuffer[ 224 ];
    UINT NameIndex = 0;

    dwTableOffset = 0;
    nDirectories = 0;

    for ( uLevel = 0; pStartOfLevel[ uLevel ]; uLevel++ ) {

        for ( pDir = pStartOfLevel[ uLevel ]; pDir; pDir = pDir->pDirectoryInfo->pNextTargetDir ) {

            ASSERT( pDir->pDirectoryInfo != NULL );

            //
            //  Each table entry is 8 bytes plus the length of the name,
            //  but the next entry must start at a word (2-byte) boundary,
            //  so round-up offset if necessary.
            //

            ASSERT( pDir->wFileNameLength != 0 );

            if (( dwTableOffset += ( 8 + pDir->wFileNameLength )) & 1 )
                ++dwTableOffset;

            pDir->pDirectoryInfo->dwDirIndex = ++nDirectories;

            if ( pDir->pParentDir->pDirectoryInfo->dwDirIndex > 0xFFFF ) {

                ErrorExit(
                    0,
                    "ERROR: Too many directories in volume (directory number of a parent directory\r\n"
                    "       cannot exceed 65535 because it is stored in a 16-bit field).\r\n"
                    );
                }

#ifdef DONTCOMPILE

            if ( bOneDirectoryRecordPerSector || bOneDirectoryRecordPerTwoSectors ) {
                dwDirOffset = CD_SECTORSIZE * 2 * ( bOneDirectoryRecordPerTwoSectors ? 2 : 1 );
                for ( pFile = pDir->pDirectoryInfo->pFirstTargetFile; pFile; pFile = pFile->pNextTargetFile ) {
                    dwDirOffset += CD_SECTORSIZE * ( bOneDirectoryRecordPerTwoSectors ? 2 : 1 );
                    }
                }
            else

#endif // DONTCOMPILE

                {

                dwDirOffset = 34 * 2;               // for "." and ".." entries
                dwNextBound = CD_SECTORSIZE;        // don't straddle sector boundary

                if ( bReportBadShortNames ) {
                    ZeroMemory( OddNameBuffer,  sizeof( OddNameBuffer ));
                    ZeroMemory( EvenNameBuffer, sizeof( EvenNameBuffer ));
                    NameIndex = 2;                  // for . and .. entries
                    }

                if ( bAllowExactAlignedDirs )
                    dwNextLimit = CD_SECTORSIZE;     // more efficient packing
                else
                    dwNextLimit = CD_SECTORSIZE - 1; // don't break MSCDEX

                for ( pFile = pDir->pDirectoryInfo->pFirstTargetFile; pFile; pFile = pFile->pNextTargetFile ) {

                    ASSERT( pFile->wFileNameLength != 0 );
                    ASSERT( pFile->wFileNameLength <= 221 );

                    dwEntryLen  = pFile->wFileNameLength + 33;
                    dwEntryLen += dwEntryLen & 1;

                    if (( dwDirOffset + dwEntryLen ) > dwNextLimit ) {
                        dwDirOffset  = dwNextBound;
                        dwNextBound += CD_SECTORSIZE;
                        dwNextLimit += CD_SECTORSIZE;
                        }

                    DEBUGCODE( pFile->dwDirOffset = dwDirOffset );

                    if ( bReportBadShortNames ) {

                        //
                        //  Check for potential conflict with bug in NT 4.0
                        //  where CDFS shortname generation fails when the hex
                        //  offset of the direntry shifted right 5 bits
                        //  contains hex characters 'a' through 'f' (non-
                        //  numeric hex characters).
                        //

                        PCHAR WhichNameBuffer = ( NameIndex++ & 1 ) ? OddNameBuffer : EvenNameBuffer;
                        BOOL  CheckShortName  = ( pFile->dwFlags & CHECK_SHORTNAME ) ? TRUE : FALSE;
                        BOOL  IsDirectory     = ( pFile->dwFlags & IS_DIRECTORY    ) ? TRUE : FALSE;

                        if ( ! CheckShortName ) {

                            if ( bOptimizeFileNames || IsDirectory ) {

                                if (( WhichNameBuffer[ pFile->wFileNameLength ] == '.' ) ||
                                    ( WhichNameBuffer[ pFile->wFileNameLength ] == ' ' )) {

                                    CheckShortName = TRUE;

                                    }
                                }
                            }

                        if ( CheckShortName ) {

                            if (( ! IsDirectory ) && ( ! bOptimizeFileNames )) {

                                if ( IsAcceptableDosName( pFile->pszFileName )) {

                                    CheckShortName = FALSE;

                                    }
                                }
                            }

                        if ( CheckShortName ) {

                            CHAR  Uniquifier[ 12 ];
                            PCHAR p;

                            sprintf( Uniquifier, "%X", dwDirOffset >> 5 );

                            for ( p = Uniquifier; *p; p++ ) {

                                if ( *p > '9' ) {

                                    printf(
                                        "\r\nWARNING: %sname \"%s\" may be inaccessible to 16-bit apps "
                                        "under NT 4.0 (see footnote).\r\n",
                                        IsDirectory ? "Directory " : "File",
                                        GenerateFullName( pFile, ReportNameBuffer.A )
                                        );

                                    fflush( stdout );
                                    bReportBadShortNameWarning = TRUE;
                                    break;

                                    }
                                }
                            }

                        CopyMemory( WhichNameBuffer, pFile->pszFileName, pFile->wFileNameLength );

                        }

                    dwDirOffset += dwEntryLen;

                    }
                }

            //
            //  ISO-9660 6.8.1.3 specifies that the length of a directory
            //  INCLUDES the unused bytes at the end of the last sector,
            //  meaning this number should be rounded up to CD_SECTORSIZE.
            //  Since NT 3.1 media, we have always encoded actual versus
            //  rounded and never heard of any problems.
            //

            if ( bRoundDirectorySizes ) {
                pDir->dwlFileSize = ROUNDUP2( dwDirOffset, CD_SECTORSIZE );
                }
            else {
                pDir->dwlFileSize = dwDirOffset;
                }
            }
        }

    dwLookupTableSize       = dwTableOffset;
    dwLookupTableAllocation = ROUNDUP2( dwLookupTableSize, dwBlockSize );

    }


void ComputeAlternateDirectorySizes( void ) {

    PDIRENTRY pDir, pFile;
    DWORD dwDirOffset, dwTableOffset, dwNextBound, dwNextLimit, dwEntryLen;
    UINT uLevel;

    dwTableOffset = 0;
    nDirectories = 0;

    for ( uLevel = 0; pAlternateStartOfLevel[ uLevel ]; uLevel++ ) {

        for ( pDir = pAlternateStartOfLevel[ uLevel ];
              pDir;
              pDir = pDir->pDirectoryInfo->pAlternateNextDir ) {

            ASSERT( pDir->pDirectoryInfo != NULL );

            //
            //  Each table entry is 8 bytes plus the length of the name,
            //  but the next entry must start at a word (2-byte) boundary,
            //  so round-up offset if necessary.
            //

            ASSERT( pDir->wFileNameLength != 0 );

            if (( dwTableOffset += ( 8 + pDir->wFileNameLength )) & 1 )
                ++dwTableOffset;

            pDir->pDirectoryInfo->dwDirIndex = ++nDirectories;

            if ( pDir->pParentDir->pDirectoryInfo->dwDirIndex > 0xFFFF ) {

                ErrorExit(
                    0,
                    "ERROR: Too many directories in volume (directory number of a parent directory\r\n"
                    "       cannot exceed 65535 because it is stored in a 16-bit field).\r\n"
                    );
                }

            dwDirOffset = 34 * 2;               // for "." and ".." entries
            dwNextBound = CD_SECTORSIZE;        // don't straddle sector boundary

            if ( bAllowExactAlignedDirs )
                dwNextLimit = CD_SECTORSIZE;     // more efficient packing
            else
                dwNextLimit = CD_SECTORSIZE - 1; // don't break MSCDEX

            for ( pFile = pDir->pDirectoryInfo->pAlternateFirstFile; pFile; pFile = pFile->pAlternateNextFile ) {

                ASSERT( pFile->wFileNameLength != 0 );

                dwEntryLen  = pFile->wFileNameLength + 33;
                dwEntryLen += dwEntryLen & 1;

                if (( dwDirOffset + dwEntryLen ) > dwNextLimit ) {
                    dwDirOffset  = dwNextBound;
                    dwNextBound += CD_SECTORSIZE;
                    dwNextLimit += CD_SECTORSIZE;
                    }

                DEBUGCODE( pFile->dwDirOffset = dwDirOffset );

                dwDirOffset += dwEntryLen;

                }

            //
            //  ISO-9660 6.8.1.3 specifies that the length of a directory
            //  INCLUDES the unused bytes at the end of the last sector,
            //  meaning this number should be rounded up to CD_SECTORSIZE.
            //  Since NT 3.1 media, we have always encode actual versus
            //  rounded and never heard of any problems.
            //

            if ( bRoundDirectorySizes ) {
                pDir->dwlFileSize = ROUNDUP2( dwDirOffset, CD_SECTORSIZE );
                }
            else {
                pDir->dwlFileSize = dwDirOffset;
                }

            }
        }

    dwLookupTableSize       = dwTableOffset;
    dwLookupTableAllocation = ROUNDUP2( dwLookupTableSize, dwBlockSize );

    }


void ComputeHeaderBlocks( void ) {

    DWORD dwHeaderSectors = 18;

    // initial sectors 0-15 plus PVD and Terminator sectors = 18

    if ( bElTorito )
        dwHeaderSectors++;       // BVD for El Torito

    if ( bEncodeJoliet )
        dwHeaderSectors++;       // SVD for Joliet

    if ( bEncodeUdf )
        dwHeaderSectors += 3;    // NSR descriptors "BEA01" "NSR02" "TEA01"

    ASSERT(( ! bEncodeUdf ) || ( dwHeaderSectors < ANCHOR_SECTOR ));

    dwHeaderBlocks = BLOCK_NUMBER_FROM_SECTOR_NUMBER( dwHeaderSectors );

    dwNextMetaBlockNumber = dwHeaderBlocks;

    }


void AssignDirectoryBlockNumbers( void ) {

    PDIRENTRY pDir;
    UINT uLevel;

    ASSERT( dwHeaderBlocks != 0 );      //  assume this is already computed
    ASSERT( IS_SECTOR_ALIGNED( dwNextMetaBlockNumber * dwBlockSize ));

    ASSERT(( dwLookupTableAllocation != 0 ) || ( dwJolietLookupTableAllocation != 0 ));

    if ( dwJolietLookupTableAllocation )
        dwStartingJolietPathTableBlock = AllocateMetaBlocks( dwJolietLookupTableAllocation * 2 );

    if ( dwLookupTableAllocation )
        dwStartingIsoPathTableBlock = AllocateMetaBlocks( dwLookupTableAllocation * 2 );

    if (( bEncodeJoliet ) || ( bEncodeOnlyUdf )) {

        if ( ! bGenerateShortNames ) {

            ASSERT( dwStubFileSize > 0 );

            dwStubFileBlock = AllocateMetaBlocks( dwStubFileSize );

            }
        }

    if ( ! IS_SECTOR_ALIGNED( (DWORDLONG) dwNextMetaBlockNumber * dwBlockSize )) {

        dwlMetaPaddingBeforeDirectoriesOffset = (DWORDLONG) dwNextMetaBlockNumber * dwBlockSize;
        dwMetaPaddingBeforeDirectoriesBytes   = (DWORD)( ROUNDUP2_64(((DWORDLONG) dwNextMetaBlockNumber * dwBlockSize ), CD_SECTORSIZE )
                                              - ((DWORDLONG) dwNextMetaBlockNumber * dwBlockSize ));

        dwNextMetaBlockNumber += CD_BLOCKS_FROM_SIZE( dwMetaPaddingBeforeDirectoriesBytes );

        }


    DEBUGCODE( dwStartingJolietDirectoryBlock = dwNextMetaBlockNumber );

    if ( bEncodeJoliet ) {

        for ( uLevel = 0; pStartOfLevel[ uLevel ]; uLevel++ ) {
            for ( pDir = pStartOfLevel[ uLevel ]; pDir; pDir = pDir->pDirectoryInfo->pNextTargetDir ) {

                ASSERT( pDir->pDirectoryInfo != NULL );
                ASSERT( pDir->pDirectoryInfo->dwUnicodeDirSize != 0 );

                pDir->pDirectoryInfo->dwUnicodeBlock =
                            AllocateMetaBlocksSectorAligned(
                                    pDir->pDirectoryInfo->dwUnicodeDirSize );

                }
            }
        }

    DEBUGCODE( dwStartingIsoDirectoryBlock = dwNextMetaBlockNumber );

    if (( bEncodeJoliet ) || ( bEncodeOnlyUdf )) {

        for ( uLevel = 0; pAlternateStartOfLevel[ uLevel ]; uLevel++ ) {
            for ( pDir = pAlternateStartOfLevel[ uLevel ];
                  pDir;
                  pDir = pDir->pDirectoryInfo->pAlternateNextDir ) {

                ASSERT( pDir->pDirectoryInfo != NULL );
                ASSERT( pDir->dwlFileSize != 0 );
                ASSERT( pDir->dwlFileSize < 0xFFFFFFFF );

                pDir->dwStartingBlock = AllocateMetaBlocksSectorAligned( (DWORD)( pDir->dwlFileSize ));

                }
            }

        if ( ! bGenerateShortNames ) {

            ASSERT( dwStubFileBlock != 0 );

            //
            //  We know the stub file is linked at
            //  pRootDir->pDirectoryInfo->pAlternateFirstFile,
            //  and we need to update its starting block location.
            //

            ASSERT( pRootDir->pDirectoryInfo != NULL );
            ASSERT( pRootDir->pDirectoryInfo->pAlternateFirstFile != NULL );
            ASSERT( pRootDir->pDirectoryInfo->pAlternateFirstFile->dwlFileSize == dwStubFileSize );
            ASSERT( pRootDir->pDirectoryInfo->pAlternateFirstFile->dwStartingBlock == 0 );

            pRootDir->pDirectoryInfo->pAlternateFirstFile->dwStartingBlock = dwStubFileBlock;

            }
        }

    else {

        for ( uLevel = 0; pStartOfLevel[ uLevel ]; uLevel++ ) {
            for ( pDir = pStartOfLevel[ uLevel ]; pDir; pDir = pDir->pDirectoryInfo->pNextTargetDir ) {

                ASSERT( pDir->dwlFileSize != 0 );
                ASSERT( pDir->dwlFileSize < 0xFFFFFFFF );

                pDir->dwStartingBlock = AllocateMetaBlocksSectorAligned( (DWORD)( pDir->dwlFileSize ));

                }
            }
        }
    }


void ComputeStartingFileBlockLocation( void ) {

    ASSERT(( ! bEncodeUdf ) || ( dwNextMetaBlockNumber > ANCHOR_SECTOR ));

    dwStartingFileBlock = dwNextMetaBlockNumber;
    dwTotalImageBlocks  = dwStartingFileBlock
                        + ROUNDUP2( dwTotalFileBlocks, ( CD_SECTORSIZE / dwBlockSize ))
                        + (( bEncodeAutoCrc || bSignImage ) ? CD_BLOCKS_FROM_SIZE( CD_SECTORSIZE ) : 0 );

    if (bEncodeUdf)
    {
       ulAnchorSlackSector = dwTotalImageBlocks;
       dwTotalImageBlocks = ROUNDUP2(dwTotalImageBlocks + 1, 32768 / CD_SECTORSIZE);
       ulAnchorSectorNumber = dwTotalImageBlocks - 1;
    }

    dwlTotalHeaderBytes = (DWORDLONG)dwStartingFileBlock * dwBlockSize;
    dwlTotalMetaBytes   = dwlTotalHeaderBytes + (( bEncodeAutoCrc || bSignImage ) ? CD_SECTORSIZE : 0 );
    dwlTotalImageBytes  = (DWORDLONG)dwTotalImageBlocks  * dwBlockSize;

    }


void PadCopy( PUCHAR pDest, UINT uLength, LPSTR pSource ) {

    for ( ; uLength && *pSource; uLength-- )
        *pDest++ = *pSource++;

    for ( ; uLength; uLength-- )
        *pDest++ = ' ';

    }


void MakeDualEndian( PUCHAR pMem, UINT uBytes, DWORD dwValue ) {

    MakeLittleEndian( pMem, uBytes, dwValue );
    MakeBigEndian( pMem + uBytes, uBytes, dwValue );

    }


void MakeLittleEndian( PUCHAR pMem, UINT uBytes, DWORD dwValue ) {

    switch ( uBytes ) {
        case 4:
            *(UNALIGNED DWORD*)pMem = dwValue;
            break;
        case 2:
            ASSERT( dwValue < 0x10000 );
            *(UNALIGNED WORD*)pMem = (WORD)dwValue;
            break;
        default:
            ASSERT(( uBytes == 4 ) || ( uBytes == 2 ));
        }
    }


void MakeBigEndian( PUCHAR pMem, UINT uBytes, DWORD dwValue ) {

    ASSERT(( uBytes > 2 ) || ( dwValue < 0x10000 ));

    switch ( uBytes ) {
        case 4:
            *pMem++ = *(((PUCHAR)&dwValue) + 3 );
            *pMem++ = *(((PUCHAR)&dwValue) + 2 );
            // don't break, fall through
        case 2:
            *pMem++ = *(((PUCHAR)&dwValue) + 1 );
            *pMem++ = *(((PUCHAR)&dwValue) + 0 );
            break;

        default:
            ASSERT(( uBytes == 4 ) || ( uBytes == 2 ));

        }
    }


void GenerateAndWriteLookupTables( void ) {

    PUCHAR pL, pM, pLookupTableL, pLookupTableM;
    PUCHAR pBuffer;
    UINT uLevel, uLen;
    PDIRENTRY pDir;
    DWORD dwTableSize;
    DWORD dwCombinedTableSize;
    DWORDLONG dwlOffset;

    dwTableSize = dwLookupTableAllocation;              // local copy

    ASSERT( ISALIGN2( dwTableSize, dwBlockSize ));

    dwCombinedTableSize = dwTableSize * 2;

    pBuffer = AllocateBuffer( dwCombinedTableSize, TRUE );

    pL = pLookupTableL = pBuffer;                       // LittleEndian table
    pM = pLookupTableM = pBuffer + dwTableSize;         // BigEndian table

    //
    // root directory is odd, so do it separately, then start loop at level 1
    //

    *pL = 0x01;
    *pM = 0x01;

    ASSERT( pRootDir->dwStartingBlock != 0 );

    MakeLittleEndian( pL + 2, 4, pRootDir->dwStartingBlock );
    MakeBigEndian(    pM + 2, 4, pRootDir->dwStartingBlock );

    ASSERT( pRootDir->pParentDir->pDirectoryInfo->dwDirIndex != 0 );
    ASSERT( pRootDir->pParentDir->pDirectoryInfo->dwDirIndex < 0x10000 );

    MakeLittleEndian( pL + 6, 2, pRootDir->pParentDir->pDirectoryInfo->dwDirIndex );
    MakeBigEndian(    pM + 6, 2, pRootDir->pParentDir->pDirectoryInfo->dwDirIndex );

    pL += 10;
    pM += 10;

    for ( uLevel = 1; pStartOfLevel[ uLevel ]; uLevel++ ) {
        for ( pDir = pStartOfLevel[ uLevel ]; pDir; pDir = pDir->pDirectoryInfo->pNextTargetDir ) {

            ASSERT( pDir->pDirectoryInfo != NULL );
            ASSERT( pDir->wFileNameLength != 0 );

            uLen = (UINT) pDir->wFileNameLength;

            *pL = (UCHAR) uLen;
            *pM = (UCHAR) uLen;

            ASSERT( pDir->dwStartingBlock != 0 );

            MakeLittleEndian( pL + 2, 4, pDir->dwStartingBlock );
            MakeBigEndian(    pM + 2, 4, pDir->dwStartingBlock );

            ASSERT( pDir->pParentDir->pDirectoryInfo->dwDirIndex != 0 );
            ASSERT( pDir->pParentDir->pDirectoryInfo->dwDirIndex < 0x10000 );

            MakeLittleEndian( pL + 6, 2, pDir->pParentDir->pDirectoryInfo->dwDirIndex );
            MakeBigEndian(    pM + 6, 2, pDir->pParentDir->pDirectoryInfo->dwDirIndex );

            memcpy( pL + 8, pDir->pszFileName, uLen );
            memcpy( pM + 8, pDir->pszFileName, uLen );

            pL += ( uLen + 8 ) + ( uLen & 1 );
            pM += ( uLen + 8 ) + ( uLen & 1 );

            ASSERT( pL < ( pLookupTableL + dwTableSize ));
            ASSERT( pM < ( pLookupTableM + dwTableSize ));  // redundant

            }
        }

    ASSERT( dwStartingIsoPathTableBlock != 0 );

    dwlOffset = (DWORDLONG)dwStartingIsoPathTableBlock * dwBlockSize;

    HeaderWrite( dwlOffset, pBuffer, dwCombinedTableSize );

    dwlOffset += dwCombinedTableSize;

    ASSERT( ROUNDUP2_64( dwlOffset, CD_SECTORSIZE ) == ((DWORDLONG)dwStartingJolietDirectoryBlock * dwBlockSize ));

    }



void GenerateAndWriteAlternateLookupTables( void ) {

    PUCHAR pL, pM, pLookupTableL, pLookupTableM;
    PUCHAR pBuffer;
    UINT uLevel, uLen;
    PDIRENTRY pDir;
    DWORD dwTableSize;
    DWORD dwCombinedTableSize;
    DWORDLONG dwlOffset;

    dwTableSize = dwLookupTableAllocation;              // local copy

    ASSERT( ISALIGN2( dwTableSize, dwBlockSize ));

    dwCombinedTableSize = dwTableSize * 2;

    pBuffer = AllocateBuffer( dwCombinedTableSize, TRUE );

    pL = pLookupTableL = pBuffer;                       // LittleEndian table
    pM = pLookupTableM = pBuffer + dwTableSize;         // BigEndian table

    //
    // root directory is odd, so do it separately, then start loop at level 1
    //

    *pL = 0x01;
    *pM = 0x01;

    ASSERT( pRootDir->dwStartingBlock != 0 );

    MakeLittleEndian( pL + 2, 4, pRootDir->dwStartingBlock );
    MakeBigEndian(    pM + 2, 4, pRootDir->dwStartingBlock );

    ASSERT( pRootDir->pParentDir->pDirectoryInfo->dwDirIndex != 0 );
    ASSERT( pRootDir->pParentDir->pDirectoryInfo->dwDirIndex < 0x10000 );

    MakeLittleEndian( pL + 6, 2, pRootDir->pParentDir->pDirectoryInfo->dwDirIndex );
    MakeBigEndian(    pM + 6, 2, pRootDir->pParentDir->pDirectoryInfo->dwDirIndex );

    pL += 10;
    pM += 10;

    for ( uLevel = 1; pAlternateStartOfLevel[ uLevel ]; uLevel++ ) {
        for ( pDir = pAlternateStartOfLevel[ uLevel ];
              pDir;
              pDir = pDir->pDirectoryInfo->pAlternateNextDir ) {

            ASSERT( pDir->pDirectoryInfo != NULL );
            ASSERT( pDir->wFileNameLength != 0 );

            uLen = (UINT) pDir->wFileNameLength;

            *pL = (UCHAR) uLen;
            *pM = (UCHAR) uLen;

            ASSERT( pDir->dwStartingBlock != 0 );

            MakeLittleEndian( pL + 2, 4, pDir->dwStartingBlock );
            MakeBigEndian(    pM + 2, 4, pDir->dwStartingBlock );

            ASSERT( pDir->pParentDir->pDirectoryInfo->dwDirIndex != 0 );
            ASSERT( pDir->pParentDir->pDirectoryInfo->dwDirIndex < 0x10000 );

            MakeLittleEndian( pL + 6, 2, pDir->pParentDir->pDirectoryInfo->dwDirIndex );
            MakeBigEndian(    pM + 6, 2, pDir->pParentDir->pDirectoryInfo->dwDirIndex );

            memcpy( pL + 8, pDir->pszFileName, uLen );
            memcpy( pM + 8, pDir->pszFileName, uLen );

            pL += ( uLen + 8 ) + ( uLen & 1 );
            pM += ( uLen + 8 ) + ( uLen & 1 );

            ASSERT( pL < ( pLookupTableL + dwTableSize ));
            ASSERT( pM < ( pLookupTableM + dwTableSize ));  // redundant

            }
        }

    ASSERT( dwStartingIsoPathTableBlock != 0 );

    dwlOffset = (DWORDLONG)dwStartingIsoPathTableBlock * dwBlockSize;

    HeaderWrite( dwlOffset, pBuffer, dwCombinedTableSize );

    }


void WriteDirectories( void ) {

    PDIRENTRY pDir, pFile;
    PUCHAR pBuffer, pMem, pBoundary, pLimit;
    UINT uLevel, uNameLen, uEntryLen;
    DWORD dwDirAllocation;
    DWORDLONG dwlOffset;

    for ( uLevel = 0; pStartOfLevel[ uLevel ]; uLevel++ ) {
        for ( pDir = pStartOfLevel[ uLevel ]; pDir; pDir = pDir->pDirectoryInfo->pNextTargetDir ) {

            ASSERT( pDir->pDirectoryInfo != NULL );
            ASSERT( pDir->dwlFileSize != 0 );
            ASSERT( pDir->dwlFileSize < 0x100000000 );

            dwDirAllocation = ROUNDUP2( pDir->dwlFileSize, CD_SECTORSIZE );

            pBuffer = AllocateBuffer( dwDirAllocation, TRUE );

            pMem = MakeRootEntries( pBuffer, pDir );

            pBoundary = pBuffer + CD_SECTORSIZE;

            if ( bAllowExactAlignedDirs )
                pLimit = pBoundary;         // more efficient packing
            else
                pLimit = pBoundary - 1;     // don't break MSCDEX

            for ( pFile = pDir->pDirectoryInfo->pFirstTargetFile; pFile; pFile = pFile->pNextTargetFile ) {

                if ( ! ( pFile->dwFlags & NO_DIRENTRY )) {

                    ASSERT( pFile->wFileNameLength != 0 );
                    ASSERT( pFile->dwlFileSize < 0x100000000 );

                    uNameLen   = (UINT) pFile->wFileNameLength;
                    uEntryLen  = uNameLen + 33;
                    uEntryLen += uEntryLen & 1;

                    if (( pMem + uEntryLen ) > pLimit ) {
                        pMem = pBoundary;
                        pBoundary += CD_SECTORSIZE;
                        pLimit    += CD_SECTORSIZE;
                        }

                    ASSERT(( pFile->dwDirOffset == (DWORD)( pMem - pBuffer )) || ( bContinueAfterFailedSourceOpen ));
                    ASSERT(( pMem + uEntryLen ) < ( pBuffer + dwDirAllocation ));
                    ASSERT(( pFile->dwlFileSize == 0 ) || ( pFile->dwStartingBlock != 0 ));

                    *pMem = (UCHAR) uEntryLen;
                    MakeDualEndian( pMem +  2, 4, pFile->dwStartingBlock );
                    MakeDualEndian( pMem + 10, 4, (DWORD)( pFile->dwlFileSize ));

                    *( pMem + 28 ) = 0x01;
                    *( pMem + 31 ) = 0x01;
                    *( pMem + 32 ) = (UCHAR) uNameLen;

                    if ( bUseGlobalTime )
                        memcpy( pMem + 18, cGlobalIsoTimeStamp, 6 );
                    else {
                        ASSERT( pFile->pFileTimeInfo != NULL );
                        MakeIsoTimeStampFromFileTime( pMem + 18, pFile->pFileTimeInfo->ftLastWriteTime );
                        }

                    if ( pFile->dwFlags & IS_HIDDEN ) {
                        *( pMem + 25 ) |= 0x01;
                        }

                    if ( pFile->dwFlags & IS_DIRECTORY ) {

                        *( pMem + 25 ) |= 0x02;

                        memcpy( pMem + 33, pFile->pszFileName, uNameLen );

                        ASSERT( ! ( pFile->dwFlags & IS_DUPLICATE ));
                        ASSERT( pFile->pDirectoryInfo != NULL );
                        ASSERT( pFile->dwStartingBlock != 0 );
                        ASSERT( pFile->dwlFileSize != 0 );

                        }

                    else {

                        if ( bOptimizeFileNames ) {
                            memcpy( pMem + 33, pFile->pszFileName, uNameLen );
                            }
                        else {
                            memcpy( pMem + 33, pFile->pszFileName, uNameLen - 2 );
                            memcpy( pMem + 33 + uNameLen - 2, ";1", 2 );
                            }

                        //
                        //  pFile->pDirectoryInfo and pFile->pPrimary share the
                        //  same address, so we can only assert that pDirectoryInfo
                        //  is NULL if not IS_DUPLICATE.
                        //

                        ASSERT(( pFile->dwFlags & IS_DUPLICATE ) || ( pFile->pDirectoryInfo == NULL ));

                        }

                    pMem += uEntryLen;

                    }

                else {

                    ASSERT(( pFile->dwFlags & NO_DIRENTRY ) && ( bContinueAfterFailedSourceOpen ));

                    }
                }

            dwlOffset = (DWORDLONG)( pDir->dwStartingBlock ) * dwBlockSize;

            ASSERT( IS_SECTOR_ALIGNED( dwlOffset ));

            HeaderWrite( dwlOffset, pBuffer, dwDirAllocation );

            }
        }
    }



void WriteAlternateDirectories( void ) {

    PDIRENTRY pDir, pFile;
    PUCHAR pBuffer, pMem, pBoundary, pLimit;
    UINT uLevel, uNameLen, uEntryLen;
    DWORD dwDirAllocation;
    DWORDLONG dwlOffset;

    for ( uLevel = 0; pAlternateStartOfLevel[ uLevel ]; uLevel++ ) {
        for ( pDir = pAlternateStartOfLevel[ uLevel ];
              pDir;
              pDir = pDir->pDirectoryInfo->pAlternateNextDir ) {

            ASSERT( pDir->pDirectoryInfo != NULL );
            ASSERT( pDir->dwlFileSize != 0 );
            ASSERT( pDir->dwlFileSize < 0x100000000 );

            dwDirAllocation = ROUNDUP2( pDir->dwlFileSize, CD_SECTORSIZE );

            pBuffer = AllocateBuffer( dwDirAllocation, TRUE );

            pMem = MakeRootEntries( pBuffer, pDir );

            pBoundary = pBuffer + CD_SECTORSIZE;

            if ( bAllowExactAlignedDirs )
                pLimit = pBoundary;         // more efficient packing
            else
                pLimit = pBoundary - 1;     // don't break MSCDEX

            for ( pFile = pDir->pDirectoryInfo->pAlternateFirstFile; pFile; pFile = pFile->pAlternateNextFile ) {

                if ( ! ( pFile->dwFlags & NO_DIRENTRY )) {

                    ASSERT( pFile->wFileNameLength != 0 );
                    ASSERT( pFile->dwlFileSize < 0x100000000 );

                    uNameLen   = (UINT) pFile->wFileNameLength;
                    uEntryLen  = uNameLen + 33;
                    uEntryLen += uEntryLen & 1;

                    if (( pMem + uEntryLen ) > pLimit ) {
                        pMem = pBoundary;
                        pBoundary += CD_SECTORSIZE;
                        pLimit    += CD_SECTORSIZE;
                        }

                    ASSERT(( pFile->dwDirOffset == (DWORD)( pMem - pBuffer )) || ( bContinueAfterFailedSourceOpen ));
                    ASSERT(( pMem + uEntryLen ) < ( pBuffer + dwDirAllocation ));
                    ASSERT(( pFile->dwlFileSize == 0 ) || ( pFile->dwStartingBlock != 0 ));

                    *pMem = (UCHAR) uEntryLen;
                    MakeDualEndian( pMem +  2, 4, pFile->dwStartingBlock );
                    MakeDualEndian( pMem + 10, 4, (DWORD)( pFile->dwlFileSize ));

                    *( pMem + 28 ) = 0x01;
                    *( pMem + 31 ) = 0x01;
                    *( pMem + 32 ) = (UCHAR) uNameLen;

                    if ( bUseGlobalTime )
                        memcpy( pMem + 18, cGlobalIsoTimeStamp, 6 );
                    else {
                        ASSERT( pFile->pFileTimeInfo != NULL );
                        MakeIsoTimeStampFromFileTime( pMem + 18, pFile->pFileTimeInfo->ftLastWriteTime );
                        }

                    if ( pFile->dwFlags & IS_HIDDEN ) {
                        *( pMem + 25 ) |= 0x01;
                        }

                    if ( pFile->dwFlags & IS_DIRECTORY ) {

                        *( pMem + 25 ) |= 0x02;

                        memcpy( pMem + 33, pFile->pszFileName, uNameLen );

                        ASSERT( ! ( pFile->dwFlags & IS_DUPLICATE ));
                        ASSERT( pFile->pDirectoryInfo != NULL );
                        ASSERT( pFile->dwStartingBlock != 0 );
                        ASSERT( pFile->dwlFileSize != 0 );

                        }

                    else {

                        if ( bOptimizeFileNames ) {
                            memcpy( pMem + 33, pFile->pszFileName, uNameLen );
                            }
                        else {
                            memcpy( pMem + 33, pFile->pszFileName, uNameLen - 2 );
                            memcpy( pMem + 33 + uNameLen - 2, ";1", 2 );
                            }

                        //
                        //  pFile->pDirectoryInfo and pFile->pPrimary share the
                        //  same address, so we can only assert that pDirectoryInfo
                        //  is NULL if not IS_DUPLICATE.
                        //

                        ASSERT(( pFile->dwFlags & IS_DUPLICATE ) || ( pFile->pDirectoryInfo == NULL ));

                        }

                    pMem += uEntryLen;

                    }

                else {

                    ASSERT(( pFile->dwFlags & NO_DIRENTRY ) && ( bContinueAfterFailedSourceOpen ));

                    }
                }

            dwlOffset = (DWORDLONG)( pDir->dwStartingBlock ) * dwBlockSize;

            ASSERT( IS_SECTOR_ALIGNED( dwlOffset ));

            HeaderWrite( dwlOffset, pBuffer, dwDirAllocation );

            }
        }
    }


PUCHAR MakeRootEntry( PUCHAR pMem, PDIRENTRY pDir, UCHAR DirName ) {

    ASSERT( pDir->dwFlags & IS_DIRECTORY );
    ASSERT( pDir->dwStartingBlock != 0 );

    *pMem = 34;

    MakeDualEndian( pMem +  2, 4, pDir->dwStartingBlock );
    MakeDualEndian( pMem + 10, 4, (DWORD)( pDir->dwlFileSize ));

    if ( bUseGlobalTime )
        memcpy( pMem + 18, cGlobalIsoTimeStamp, 6 );
    else {
        ASSERT( pDir->pFileTimeInfo != NULL );
        ASSERT( *(UNALIGNED DWORDLONG*)&( pDir->pFileTimeInfo->ftLastWriteTime ) != 0 );
        MakeIsoTimeStampFromFileTime( pMem + 18, pDir->pFileTimeInfo->ftLastWriteTime );
        }

    *( pMem + 25 ) = 0x02;      // flag for directory
    *( pMem + 28 ) = 0x01;      // volume sequence number (big endian)
    *( pMem + 31 ) = 0x01;      // volume sequence number (little endian)
    *( pMem + 32 ) = 0x01;      // length of name
    *( pMem + 33 ) = DirName;   // single byte name (0x00 or 0x01 for parent)

    return pMem + 34;
    }


PUCHAR MakeRootEntries( PUCHAR pMem, PDIRENTRY pDir ) {

    pMem = MakeRootEntry( pMem, pDir,             0 );      // "." entry
    pMem = MakeRootEntry( pMem, pDir->pParentDir, 1 );      // ".." entry

    return pMem;
    }


PUCHAR MakeJolietRootEntry( PUCHAR pMem, PDIRENTRY pDir, UCHAR DirName ) {

    ASSERT( pDir->dwFlags & IS_DIRECTORY );
    ASSERT( pDir->pDirectoryInfo != NULL );
    ASSERT( pDir->pDirectoryInfo->dwUnicodeBlock != 0 );

    *pMem = 34;

    MakeDualEndian( pMem +  2, 4, pDir->pDirectoryInfo->dwUnicodeBlock );
    MakeDualEndian( pMem + 10, 4, pDir->pDirectoryInfo->dwUnicodeDirSize );

    if ( bUseGlobalTime )
        memcpy( pMem + 18, cGlobalIsoTimeStamp, 6 );
    else {
        ASSERT( pDir->pFileTimeInfo != NULL );
        ASSERT( *(UNALIGNED DWORDLONG*)&( pDir->pFileTimeInfo->ftLastWriteTime ) != 0 );
        MakeIsoTimeStampFromFileTime( pMem + 18, pDir->pFileTimeInfo->ftLastWriteTime );
        }

    *( pMem + 25 ) = 0x02;      // flag for directory
    *( pMem + 28 ) = 0x01;      // volume sequence number (big endian)
    *( pMem + 31 ) = 0x01;      // volume sequence number (little endian)
    *( pMem + 32 ) = 0x01;      // length of name
    *( pMem + 33 ) = DirName;   // single byte name (0x00 or 0x01 for parent)

    return pMem + 34;
    }


PUCHAR MakeJolietRootEntries( PUCHAR pMem, PDIRENTRY pDir ) {

    pMem = MakeJolietRootEntry( pMem, pDir,             0 );    // "." entry
    pMem = MakeJolietRootEntry( pMem, pDir->pParentDir, 1 );    // ".." entry

    return pMem;
    }


void GetFilePath( PDIRENTRY pDir, LPSTR pBuffer ) {

    if ( pDir->pParentDir == pDir )             // root parent points to itself
        strcpy( pBuffer, szRootPath );
    else {
        GetFilePath( pDir->pParentDir, pBuffer );
        strcat( pBuffer, pDir->pszFileName );
        strcat( pBuffer, "\\" );
        }
    }


LPSTR
AllocFullName(
    PDIRENTRY pFile
    )
    {
    CHAR szFullName[ MAX_PATH_LENGTH ];         // this is a 64K stack buffer
    LPSTR pAlloc;

    GetFilePath( pFile->pParentDir, szFullName );
    strcat( szFullName, pFile->pszFileName );

    pAlloc = MyHeapAlloc( strlen( szFullName ) + 1 );
    strcpy( pAlloc, szFullName );

    return pAlloc;
    }


void GetFilePathW( PDIRENTRY pDir, LPWSTR pBuffer ) {

    if ( pDir->pParentDir == pDir )             // root parent points to itself
        lstrcpyW( pBuffer, UnicodeRootPath );
    else {
        GetFilePathW( pDir->pParentDir, pBuffer );
        lstrcatW( pBuffer, pDir->pszUnicodeName );
        lstrcatW( pBuffer, (LPCWSTR) L"\\" );
        }
    }

LPWSTR
AllocFullUnicodeName(
    PDIRENTRY pFile
    )
    {
    WCHAR szFullName[ MAX_PATH_LENGTH ];        // this is a 128K stack buffer
    LPWSTR pAlloc;

    GetFilePathW( pFile->pParentDir, szFullName );
    lstrcatW( szFullName, pFile->pszUnicodeName );

    pAlloc = MyHeapAlloc(( lstrlenW( szFullName ) + 1 ) * 2 );
    lstrcpyW( pAlloc, szFullName );

    return pAlloc;
    }


VOID
WarnTwoFilesSameFirstBlockNotIdentical(
    PDIRENTRY pOriginalFile,
    PDIRENTRY pSimilarFile
    )
    {
    if ( ! bSuppressWarnSameFirstBlockNotIdentical ) {

        printf(
            "\r\n"
            "WARNING: These two files are identical for the first %d bytes, but differ\r\n"
            "at some point beyond that.  This could be intentional, but it might indicate\r\n"
            "that one of these two source files is corrupt:\r\n",
            FX_BLOCKSIZE
            );

        if ( bUnicodeNames ) {
            ASSERT( pOriginalFile->pszUnicodeName );
            GenerateFullNameSourceW( pOriginalFile, DescentNameBuffer.W );
            printf( "  %S\r\n", DescentNameBuffer.W );
            GenerateFullNameSourceW( pSimilarFile, DescentNameBuffer.W );
            printf( "  %S\r\n", DescentNameBuffer.W );
            }
        else {
            ASSERT( pOriginalFile->pszFileName );
            GenerateFullNameSource( pOriginalFile, DescentNameBuffer.A );
            printf( "  %s\r\n", DescentNameBuffer.A );
            GenerateFullNameSource( pSimilarFile, DescentNameBuffer.A );
            printf( "  %s\r\n", DescentNameBuffer.A );
            }

        fflush( stdout );

        }
    }

void WriteFiles( void ) {

    PDIRENTRY pDir, pFile, pPrev;
    UINT uLevel;
    DWORDLONG dwlTotalSourceBytes;
    DWORDLONG dwlFileSize;
    TRANSFER_CONTEXT Tx;
    LPSTR pszFileName;
    LPWSTR pszUnicodeName;
    BOOL Success;
    PUCHAR    pBuffer;

    dwSourceSectorSize = GetSectorSize(
                             NULL,
                             *UnicodeRootPath ? UnicodeRootPath : NULL,
                             *szRootPath ? szRootPath : NULL
                             );

    ASSERT( dwSourceSectorSize != 0 );

    Tx.hOpenContext   = CreateOpenContext( MAX_QUEUED_OPENS );
    Tx.hEventComplete = AllocateAutoEvent();

    if(bEncodeUdf)
	{
        StartThread( UdfTransferFileThread, &Tx, THREAD_PRIORITY_NORMAL );
	}
    else
	{
        StartThread( TransferFileThread, &Tx, THREAD_PRIORITY_NORMAL );
	}

    if ( ! bReportAllFiles ) {
        fprintf(stderr, "0%% complete" );
        fflush( stdout );
        fflush( stderr );
        }

    dwlTotalSourceBytes = 0;

    if ( bHackI386Directory )
        {
        if ( pHackI386Directory )
            {

            //
            //  Create a reverse pointing linked list using the pNextSourceFile
            //  field, then walk the reverse ordered list writing files.
            //

            pPrev = NULL;

            for ( pFile = pHackI386Directory->pDirectoryInfo->pFirstTargetFile; pFile; pFile = pFile->pNextTargetFile )
                {
                pFile->pNextSourceFile = pPrev;
                pPrev = pFile;
                }

            for ( pFile = pPrev; pFile; pFile = pFile->pNextSourceFile )
                {
                if ( ! ( pFile->dwFlags & ( IS_DIRECTORY | IS_WRITTEN )))
                    {
					HANDLE hFile;

					if(pFile->pszUnicodeName)
					{
						hFile=CreateFileW(pFile->pszUnicodeName,
									      0,
										  FILE_SHARE_READ,
										  NULL,
										  OPEN_EXISTING,
										  0,
										  NULL);
					}
					else
					{
						hFile=CreateFileA(pFile->pszFileName,
									      0,
										  FILE_SHARE_READ,
										  NULL,
										  OPEN_EXISTING,
										  0,
										  NULL);
					}

					if(INVALID_HANDLE_VALUE == hFile)
					{
						// assume file size is unchanged
						dwlFileSize = pFile->dwlFileSize;
					}
					else
					{
						dwlFileSize = GetFileSize64( hFile );

						if(dwlFileSize != pFile->dwlFileSize)
						{
							printf("\r\nWarning the size for %s [%S] has been changed - ",pFile->pszFileName,pFile->pszUnicodeName);

							if(ROUNDUP2_64(dwlFileSize,dwBlockSize) <= ROUNDUP2_64(pFile->dwlFileSize,dwBlockSize))
							{
								printf("still fits in allocation unit - continuing\r\n");
							}
							else
							{
								printf("bigger than allocation unit - image may exceed max size\r\n");
							}
						}
					}


                    if ( dwlFileSize > 0 ) {

                        pFile->dwFlags |= IS_WRITTEN;

                        if ( pFile->pszUnicodeName ) {
                            pszUnicodeName = AllocFullUnicodeName( pFile );
                            pszFileName = NULL;
                            }
                        else {
                            pszFileName = AllocFullName( pFile );
                            pszUnicodeName = NULL;
                            }

                        Success = QueueOpenFile(
                                      Tx.hOpenContext,
                                      pszUnicodeName,
                                      pszFileName,
                                      dwSourceSectorSize,
                                      FX_BLOCKSIZE,
                                      dwlFileSize,
                                      MAX_QUEUED_READS,
                                      pFile
                                      );

                        if ( Success ) {

                            dwlTotalSourceBytes += dwlFileSize;

                            }

                        else {

                            pFile->dwFlags |= NO_DIRENTRY;  // don't create directory entry
                            MyHeapFree( pszFileName ? pszFileName : (PVOID) pszUnicodeName );

                            dwlTotalFileSizes  -= dwlFileSize;
                            dwlTotalImageBytes -= ROUNDUP2_64( dwlFileSize, dwBlockSize );
                            dwTotalImageBlocks -= CD_BLOCKS_FROM_SIZE( dwlFileSize );

                            }
                        }
                    }
                }
            }
        else {

            printf( "\r\nWARNING: -y5 specified, but no \\i386 directory exists\r\n" );
            fflush( stdout );
            }
        }

	if(bEncodeUdf)
	{
		EnqueueUdfFiles(&Tx,&dwlTotalSourceBytes);
	}
	else
	{
		for ( uLevel = 0; pStartOfLevel[ uLevel ]; uLevel++ ) {
			for ( pDir = pStartOfLevel[ uLevel ]; pDir; pDir = pDir->pDirectoryInfo->pNextTargetDir ) {
				for ( pFile = pDir->pDirectoryInfo->pFirstTargetFile; pFile; pFile = pFile->pNextTargetFile ) {
					if ( ! ( pFile->dwFlags & ( IS_DIRECTORY | IS_WRITTEN ))) {

						dwlFileSize = pFile->dwlFileSize;

							if ( dwlFileSize > 0 ) {

							pFile->dwFlags |= IS_WRITTEN;

							if ( pFile->pszUnicodeName ) {
								pszUnicodeName = AllocFullUnicodeName( pFile );
								pszFileName = NULL;
								}
							else {
								pszFileName = AllocFullName( pFile );
								pszUnicodeName = NULL;
								}

                            Success = QueueOpenFile(
                                          Tx.hOpenContext,
                                          pszUnicodeName,
                                          pszFileName,
                                          dwSourceSectorSize,
                                          FX_BLOCKSIZE,
                                          dwlFileSize,
                                          MAX_QUEUED_READS,
                                          pFile
                                          );

							if ( Success ) {

								dwlTotalSourceBytes += dwlFileSize;

								}

							else {

								pFile->dwFlags |= NO_DIRENTRY;  // don't create directory entry
								MyHeapFree( pszFileName ? pszFileName : (PVOID) pszUnicodeName );

								dwlTotalFileSizes  -= dwlFileSize;
								dwlTotalImageBytes -= ROUNDUP2_64( dwlFileSize, dwBlockSize );
								dwTotalImageBlocks -= CD_BLOCKS_FROM_SIZE( dwlFileSize );

								}
							}
						}
					}
				}
			}
	}

    CloseOpenContext( Tx.hOpenContext );
    WaitForSingleObject( Tx.hEventComplete, INFINITE );
    RecycleAutoEvent( Tx.hEventComplete );

    if (bEncodeUdf)
    {
		dwSlackBytesToWriteAtEndOfFiles = (ulAnchorSlackSector - ulAnchorSlackSector + 1) * dwBlockSize;
        
        pBuffer = AllocateBuffer( dwSlackBytesToWriteAtEndOfFiles, TRUE );

        FileDataWrite(
            (DWORDLONG) dwTotalImageBlocks * dwBlockSize,
            pBuffer,
            dwSlackBytesToWriteAtEndOfFiles
            );

        dwlTotalFileSizes  += dwSlackBytesToWriteAtEndOfFiles;
        dwlTotalImageBytes += ROUNDUP2_64( dwSlackBytesToWriteAtEndOfFiles, dwBlockSize );
        dwTotalImageBlocks += CD_BLOCKS_FROM_SIZE( dwSlackBytesToWriteAtEndOfFiles );
    }

#ifdef DEBUG
    if(!bEncodeUdf)
        ASSERT( dwlTotalSourceBytes == dwlTotalFileSizes );
#endif
    ASSERT( (DWORDLONG)dwTotalImageBlocks * dwBlockSize == dwlTotalImageBytes );

    }


VOID TransferFileThread( PVOID pParam ) {

    PTRANSFER_CONTEXT pTX = pParam;
    HANDLE    hOpenContext = pTX->hOpenContext;
    PDIRENTRY pFile;
    HANDLE    hReadContext;
    DWORDLONG dwlFileSize;
    DWORDLONG dwlOffset;
    DWORDLONG dwlTotalRead;
    DWORD     dwBytesRead;
    DWORD     dwBytesToWrite;
    DWORD     dwStatus;
    PUCHAR    pBuffer;
    LPSTR     pszFileName;
    LPWSTR    pszUnicodeName;
    DWORD     dwNextBlock;
    BOOL      bAllocate;

    dwNextBlock = dwStartingFileBlock;

    DEBUGCODE( dwlNextFileDataOffset = (DWORDLONG)dwNextBlock * dwBlockSize );

    ASSERT( dwSourceSectorSize != 0 );

    for (;;) {

        hReadContext = WaitForOpen(
                            hOpenContext,
                            &pszUnicodeName,
                            &pszFileName,
                            &pFile
                            );

        if ( hReadContext == NULL ) {
            break;
            }

        if ( bReportAllFiles ) {
            if ( pszUnicodeName )
                printf( "\r\n%S", pszUnicodeName );
            else
                printf( "\r\n%s", pszFileName );
            fflush( stdout );
            }

        dwlFileSize = pFile->dwlFileSize;

        ASSERT( dwlFileSize != 0 );

        dwlOffset = (DWORDLONG)dwNextBlock * dwBlockSize;

        if ( bOptimizeStorage ) {
            if ( bOptimizeFast ) {
                bAllocate = TransferAndCheckForDuplicateFast( pFile,
                                                              dwlOffset,
                                                              hReadContext,
                                                              dwlFileSize );
                }
            else {
                bAllocate = TransferAndCheckForDuplicateSlow( pFile,
                                                              dwlOffset,
                                                              hReadContext,
                                                              dwlFileSize );
                }
            }

        else {

            dwStatus     = 0;
            dwlTotalRead = 0;

            while ( dwStatus == 0 ) {

                dwStatus = WaitForRead( hReadContext, &pBuffer, &dwBytesRead );

                ASSERT( ISALIGN2( dwBytesRead, dwBlockSize ) || ( dwStatus != 0 ));

                dwBytesToWrite = ROUNDUP2( dwBytesRead, dwBlockSize );

                ZeroMemory( pBuffer + dwBytesRead, dwBytesToWrite - dwBytesRead );

                FileDataWrite( dwlOffset, pBuffer, dwBytesToWrite );

                dwlOffset += dwBytesToWrite;

                dwlTotalRead += dwBytesRead;
                }

            ASSERT( dwlTotalRead == dwlFileSize );

            bAllocate = TRUE;

            }

        CloseReadContext( hReadContext, TRUE );

        if ( pszUnicodeName )
            MyHeapFree( pszUnicodeName );

        if ( pszFileName )
            MyHeapFree( pszFileName );

        if ( bAllocate ) {
            pFile->dwStartingBlock = dwNextBlock;
            dwNextBlock += CD_BLOCKS_FROM_SIZE( dwlFileSize );
#ifdef DEBUG
            if ( bOptimizeStorage ) {
                dwlNextFileDataOffset = (DWORDLONG) dwNextBlock * dwBlockSize;
                }
#endif // DEBUG

            }
        }


    if ( ! IS_SECTOR_ALIGNED( (DWORDLONG) dwNextBlock * dwBlockSize )) {

        dwSlackBytesToWriteAtEndOfFiles = (DWORD)
             (ROUNDUP2_64(((DWORDLONG) dwNextBlock * dwBlockSize ), CD_SECTORSIZE )
             - ((DWORDLONG) dwNextBlock * dwBlockSize ));

        pBuffer = AllocateBuffer( dwSlackBytesToWriteAtEndOfFiles, TRUE );

        FileDataWrite(
            (DWORDLONG) dwNextBlock * dwBlockSize,
            pBuffer,
            dwSlackBytesToWriteAtEndOfFiles
            );

        dwNextBlock += CD_BLOCKS_FROM_SIZE( dwSlackBytesToWriteAtEndOfFiles );

        }


    ASSERT( IS_SECTOR_ALIGNED( (DWORDLONG) dwNextBlock * dwBlockSize ));

    dwTotalImageBlocks = dwNextBlock;

    if ( bEncodeAutoCrc )
        dwTotalImageBlocks += BLOCK_NUMBER_FROM_SECTOR_NUMBER( 1 );

    dwlTotalImageBytes = (DWORDLONG)dwTotalImageBlocks * dwBlockSize;

    SetEvent( pTX->hEventComplete );

    }

VOID UdfTransferFileThread( PVOID pParam )
{
    PTRANSFER_CONTEXT pTX = pParam;
    HANDLE    hOpenContext = pTX->hOpenContext;
    PDIRENTRY pFile;
    HANDLE    hReadContext;
    LPSTR     pszFileName;
    LPWSTR    pszUnicodeName;
    DWORD     dwNextBlock;
    DWORD   dwNextIcbBlock;
    DEBUGCODE( DWORD dwStartingDataBlock );

    dwNextIcbBlock = dwStartingFileBlock;
    dwNextBlock = dwNextIcbBlock + GetIcbBlockCount();

    DEBUGCODE( printf("ICB blocks start at %u and go to %u\r\n",dwNextIcbBlock,dwNextBlock) );

    DEBUGCODE(dwStartingDataBlock = dwNextBlock);

    DEBUGCODE( dwlNextFileDataOffset = (DWORDLONG)dwNextBlock * dwBlockSize );
    ASSERT( dwSourceSectorSize != 0 );

    for (;;)
    {

        hReadContext = WaitForOpen(
                            hOpenContext,
                            &pszUnicodeName,
                            &pszFileName,
                            &pFile
                            );

        if ( hReadContext == NULL )
        {
            break;
        }

        if ( bReportAllFiles )
        {
            if ( pszUnicodeName )
                printf( "%S [%S]\r\n", pszUnicodeName,pFile->pszUnicodeName );
            else
                printf( "%s\r\n", pszFileName );
            fflush( stdout );
        }

#ifdef UDF_DBG
        printf("Starting block = %u\r\n",dwNextBlock);
        printf( "[%S]\r\n",pFile->pszUnicodeName );
        printf("Make extent\r\n");
#endif

        ASSERT(dwNextIcbBlock < dwStartingDataBlock);

        MakeFileExtent(pFile,&dwNextBlock,dwNextIcbBlock,hReadContext);

        dwNextIcbBlock++;

        CloseReadContext(hReadContext,TRUE);

        if ( pszUnicodeName )
            MyHeapFree( pszUnicodeName );

        if ( pszFileName )
            MyHeapFree( pszFileName );
    }

    if ( ! IS_SECTOR_ALIGNED( (DWORDLONG) dwNextBlock * dwBlockSize ))
    {
		BYTE* pBuffer;

        dwSlackBytesToWriteAtEndOfFiles = (DWORD)
             (ROUNDUP2_64(((DWORDLONG) dwNextBlock * dwBlockSize ), CD_SECTORSIZE )
             - ((DWORDLONG) dwNextBlock * dwBlockSize ));

        pBuffer = AllocateBuffer( dwSlackBytesToWriteAtEndOfFiles, TRUE );

        FileDataWrite(
            (DWORDLONG) dwNextBlock * dwBlockSize,
            pBuffer,
            dwSlackBytesToWriteAtEndOfFiles
            );

        dwNextBlock += CD_BLOCKS_FROM_SIZE( dwSlackBytesToWriteAtEndOfFiles );
    }

    ASSERT( IS_SECTOR_ALIGNED( (DWORDLONG) dwNextBlock * dwBlockSize ));

    dwTotalImageBlocks = dwNextBlock;

	/*
    if ( bEncodeAutoCrc )
        dwTotalImageBlocks += BLOCK_NUMBER_FROM_SECTOR_NUMBER( 1 );
		*/

    dwlTotalImageBytes = (DWORDLONG)dwTotalImageBlocks * dwBlockSize;

    SetEvent( pTX->hEventComplete );
}

BOOL TransferAndCheckForDuplicateSlow( PDIRENTRY pFile,
                                       DWORDLONG dwlOffset,
                                       HANDLE    hReadContext,
                                       DWORDLONG dwlFileSize ) {

    PDIRENTRY       pFileDup;
    DWORD           dwBytesRead;
    DWORDLONG       dwlTotalRead;
    DWORD           dwBytesToWrite;
    DWORD           dwBytesToHash;
    DWORD           dwStatus;
    DWORDLONG       dwlDupOffset;
    PUCHAR          pBuffer;
    PUCHAR          pDupBuffer;
    PBNODE          pBnode;
    BOOL            bDuplicate;
    HANDLE          hDupReadContext;
    DWORD           dwDupStatus;
    DWORD           dwDupBytesRead;
    LPSTR           pDupFileName;
    LPWSTR          pDupUnicodeName;
    DWORD           dwDiamondTime;
    ULONG           PossibleCrc;
    MD5_HASH        PossibleHash;
    HASH_AND_LENGTH FirstBlockHashAndLength;

    InitMD5( &FirstBlockHashAndLength.Hash );
    FirstBlockHashAndLength.Length = dwlFileSize;

    PossibleCrc   = FileDataCrc;
    PossibleHash  = SignatureHash;
    bDuplicate    = FALSE;
    pDupBuffer    = NULL;
    pFileDup      = NULL;
    dwlDupOffset  = 0;
    dwDiamondTime = 0;          // not necessary, but prevents compiler warning

    dwStatus = WaitForRead( hReadContext, &pBuffer, &dwBytesRead );

    ASSERT( ISALIGN2( dwBytesRead, dwBlockSize ) || ( dwStatus != 0 ));
    ASSERT(( dwBytesRead == FX_BLOCKSIZE ) || ( dwBytesRead == dwlFileSize ));

    dwlTotalRead = dwBytesRead;

    dwBytesToHash  = ROUNDUP2( dwBytesRead, 64 );
    dwBytesToWrite = ROUNDUP2( dwBytesRead, dwBlockSize );
    ZeroMemory( pBuffer + dwBytesRead, dwBytesToWrite - dwBytesRead );

    if ( bEncodeAutoCrc )
        PossibleCrc = Crc32( PossibleCrc, pBuffer, dwBytesToWrite );

    if ( bSignImage )
        UpdateMD5_Multiple64ByteChunks( &PossibleHash, pBuffer, dwBytesToWrite );

    if (( bOptimizeDiamond ) && ( *(UNALIGNED DWORD*)pBuffer == 'FCSM' )) {
        dwDiamondTime = *(UNALIGNED DWORD*)( pBuffer + 0x36 );
        *(UNALIGNED DWORD*)( pBuffer + 0x36 ) = 0;
        }

    UpdateMD5_Multiple64ByteChunks( &FirstBlockHashAndLength.Hash, pBuffer, dwBytesToHash );

    if (( bOptimizeDiamond ) && ( *(UNALIGNED DWORD*)pBuffer == 'FCSM' )) {
        *(UNALIGNED DWORD*)( pBuffer + 0x36 ) = dwDiamondTime;
        }

    bDuplicate = LookupOrAddBnode(
                     &pFirstBlockHashTree,
                     &FirstBlockHashAndLength,
                     pFile,
                     &pBnode
                     );

    if ( bDuplicate ) {

        pFileDup = pBnode->pContext;

        ASSERT( pFileDup->dwlFileSize == dwlFileSize );

        dwlDupOffset = (DWORDLONG)( pFileDup->dwStartingBlock ) * dwBlockSize;

        if ( pFileDup->pszUnicodeName ) {
            pDupUnicodeName = AllocFullUnicodeName( pFileDup );
            pDupFileName = NULL;
            }
        else {
            pDupFileName = AllocFullName( pFileDup );
            pDupUnicodeName = NULL;
            }

        hDupReadContext = CreateReadContext( pDupUnicodeName,
                                             pDupFileName,
                                             NULL,
                                             dwSourceSectorSize,
                                             FX_BLOCKSIZE,
                                             2,
                                             NULL,
                                             0,
                                             pFileDup->dwlFileSize );

        dwDupStatus = WaitForRead( hDupReadContext, &pDupBuffer, &dwDupBytesRead );

        ASSERT( dwDupStatus == dwStatus );
        ASSERT( dwDupBytesRead == dwBytesRead );

        if (( bOptimizeDiamond ) && ( *(UNALIGNED DWORD*)pDupBuffer == 'FCSM' )) {
            *(UNALIGNED DWORD*)( pDupBuffer + 0x36 ) = dwDiamondTime;
            }

        bDuplicate = ( memcmp( pBuffer, pDupBuffer, dwBytesRead ) == 0 );

        if ( ! bDuplicate )
            StopIssuingReads( hDupReadContext );

        ReleaseBuffer( pDupBuffer );

        if ( ! bDuplicate ) {

            CloseReadContext( hDupReadContext, TRUE );

            GenericWrite( dwlOffset, pBuffer, dwBytesToWrite );

            }

        else {

            QueueMaybeWrite( hTargetContext,
                             pBuffer,
                             dwlOffset,
                             dwBytesToWrite,
                             NULL,
                             NULL,
                             dwMaxQueuedWriteBufferBytes );
            }

        dwlOffset += dwBytesToWrite;

        ReportTransferProgress( dwlOffset );

        while ( dwStatus == 0 ) {

            dwStatus = WaitForRead( hReadContext, &pBuffer, &dwBytesRead );

            ASSERT( ISALIGN2( dwBytesRead, dwBlockSize ) || ( dwStatus != 0 ));

            dwlTotalRead += dwBytesRead;

            if ( bDuplicate ) {

                dwDupStatus = WaitForRead( hDupReadContext, &pDupBuffer, &dwDupBytesRead );

                ASSERT( dwDupStatus == dwStatus );
                ASSERT( dwDupBytesRead == dwBytesRead );

                bDuplicate = ( memcmp( pBuffer, pDupBuffer, dwBytesRead ) == 0 );

                ReleaseBuffer( pDupBuffer );

                if ( ! bDuplicate ) {

                    StopIssuingReads( hDupReadContext );

                    FlushMaybeQueue( hTargetContext );

                    CloseReadContext( hDupReadContext, TRUE );

                    }
                }

            dwBytesToWrite = ROUNDUP2( dwBytesRead, dwBlockSize );
            ZeroMemory( pBuffer + dwBytesRead, dwBytesToWrite - dwBytesRead );

            if ( bEncodeAutoCrc )
                PossibleCrc = Crc32( PossibleCrc, pBuffer, dwBytesToWrite );

            if ( bSignImage )
                UpdateMD5_Multiple64ByteChunks( &PossibleHash, pBuffer, dwBytesToWrite );

            if ( bDuplicate ) {

                QueueMaybeWrite( hTargetContext,
                                 pBuffer,
                                 dwlOffset,
                                 dwBytesToWrite,
                                 NULL,
                                 NULL,
                                 dwMaxQueuedWriteBufferBytes );
                }
            else {

                GenericWrite( dwlOffset, pBuffer, dwBytesToWrite );

                }

            dwlOffset += dwBytesToWrite;

            ReportTransferProgress( dwlOffset );
            }


        if ( bDuplicate ) {

            CloseReadContext( hDupReadContext, TRUE );
            DiscardMaybeQueue( hTargetContext );
            MakeFileDuplicate( pFile, pFileDup );

            }
        else {

            WarnTwoFilesSameFirstBlockNotIdentical( pFileDup, pFile );

            FlushMaybeQueue( hTargetContext );
            FileDataCrc   = PossibleCrc;
            SignatureHash = PossibleHash;

            }

        if ( pDupUnicodeName )
            MyHeapFree( pDupUnicodeName );

        if ( pDupFileName )
            MyHeapFree( pDupFileName );

        }

    else {

        GenericWrite( dwlOffset, pBuffer, dwBytesToWrite );

        dwlOffset += dwBytesToWrite;

        ReportTransferProgress( dwlOffset );

        while ( dwStatus == 0 ) {

            dwStatus = WaitForRead( hReadContext, &pBuffer, &dwBytesRead );

            ASSERT( ISALIGN2( dwBytesRead, dwBlockSize ) || ( dwStatus != 0 ));

            dwlTotalRead += dwBytesRead;

            dwBytesToWrite = ROUNDUP2( dwBytesRead, dwBlockSize );
            ZeroMemory( pBuffer + dwBytesRead, dwBytesToWrite - dwBytesRead );

            if ( bEncodeAutoCrc )
                PossibleCrc = Crc32( PossibleCrc, pBuffer, dwBytesToWrite );

            if ( bSignImage )
                UpdateMD5_Multiple64ByteChunks( &PossibleHash, pBuffer, dwBytesToWrite );

            GenericWrite( dwlOffset, pBuffer, dwBytesToWrite );

            dwlOffset += dwBytesToWrite;

            ReportTransferProgress( dwlOffset );
            }

        FileDataCrc   = PossibleCrc;
        SignatureHash = PossibleHash;
        }

    ASSERT( dwlTotalRead == dwlFileSize );

    return ( ! bDuplicate );
    }


BOOL TransferAndCheckForDuplicateFast( PDIRENTRY pFile,
                                       DWORDLONG dwlOffset,
                                       HANDLE    hReadContext,
                                       DWORDLONG dwlFileSize ) {

    PDIRENTRY       pFileDup;
    PDIRENTRY       pFirstDup;
    DWORD           dwBytesRead;
    DWORDLONG       dwlTotalRead;
    DWORD           dwBytesToWrite;
    DWORD           dwBytesToHash;
    DWORD           dwStatus;
    PUCHAR          pBuffer;
    PBNODE          pBnode;
    BOOL            bFirstBlockMatch;
    BOOL            bWholeFileMatch;
    BOOL            bNewFile;
    DWORD           dwDiamondTime;
    ULONG           PossibleCrc;
    MD5_HASH        PossibleHash;
    HASH_AND_LENGTH FirstBlockHashAndLength;
    HASH_AND_LENGTH WholeFileHashAndLength;

    InitMD5( &FirstBlockHashAndLength.Hash );
    FirstBlockHashAndLength.Length = dwlFileSize;

    PossibleCrc  = FileDataCrc;
    PossibleHash = SignatureHash;

    bNewFile = TRUE;

    dwlTotalRead  = 0;
    dwDiamondTime = 0;          // not necessary, but prevents compiler warning

    dwStatus = WaitForRead( hReadContext, &pBuffer, &dwBytesRead );

    ASSERT( ISALIGN2( dwBytesRead, dwBlockSize ) || ( dwStatus != 0 ));
    ASSERT(( dwBytesRead == FX_BLOCKSIZE ) || ( dwBytesRead == dwlFileSize ));

    dwlTotalRead += dwBytesRead;

    dwBytesToHash  = ROUNDUP2( dwBytesRead, 64 );
    dwBytesToWrite = ROUNDUP2( dwBytesRead, dwBlockSize );

    ZeroMemory( pBuffer + dwBytesRead, dwBytesToWrite - dwBytesRead );

    if ( bEncodeAutoCrc )
        PossibleCrc = Crc32( PossibleCrc, pBuffer, dwBytesToWrite );

    if ( bSignImage )
        UpdateMD5_Multiple64ByteChunks( &PossibleHash, pBuffer, dwBytesToWrite );

    if (( bOptimizeDiamond ) && ( *(UNALIGNED DWORD*)pBuffer == 'FCSM' )) {
        dwDiamondTime = *(UNALIGNED DWORD*)( pBuffer + 0x36 );
        *(UNALIGNED DWORD*)( pBuffer + 0x36 ) = 0;
        }

    UpdateMD5_Multiple64ByteChunks( &FirstBlockHashAndLength.Hash, pBuffer, dwBytesToHash );
    WholeFileHashAndLength = FirstBlockHashAndLength;   // copy whole structure

    if (( bOptimizeDiamond ) && ( *(UNALIGNED DWORD*)pBuffer == 'FCSM' )) {
        *(UNALIGNED DWORD*)( pBuffer + 0x36 ) = dwDiamondTime;
        }

    bFirstBlockMatch = LookupOrAddBnode(
                           &pFirstBlockHashTree,
                           &FirstBlockHashAndLength,
                           pFile,
                           &pBnode
                           );

    if ( bFirstBlockMatch ) {

        pFirstDup = pBnode->pContext;

        ASSERT( pFirstDup->dwlFileSize == dwlFileSize );

        QueueMaybeWrite( hTargetContext,
                         pBuffer,
                         dwlOffset,
                         dwBytesToWrite,
                         NULL,
                         NULL,
                         dwMaxQueuedWriteBufferBytes );
        }

    else {

        pFirstDup = NULL;

        GenericWrite( dwlOffset, pBuffer, dwBytesToWrite );

        }

    dwlOffset += dwBytesToWrite;

    ReportTransferProgress( dwlOffset );

    while ( dwStatus == 0 ) {

        dwStatus = WaitForRead( hReadContext, &pBuffer, &dwBytesRead );

        ASSERT( ISALIGN2( dwBytesRead, dwBlockSize ) || ( dwStatus != 0 ));

        dwlTotalRead  += dwBytesRead;
        dwBytesToWrite = ROUNDUP2( dwBytesRead, dwBlockSize );
        dwBytesToHash  = ROUNDUP2( dwBytesRead, 64 );

        ZeroMemory( pBuffer + dwBytesRead, dwBytesToWrite - dwBytesRead );

        UpdateMD5_Multiple64ByteChunks( &WholeFileHashAndLength.Hash, pBuffer, dwBytesToHash );

        if ( bEncodeAutoCrc )
            PossibleCrc = Crc32( PossibleCrc, pBuffer, dwBytesToWrite );

        if ( bSignImage )
            UpdateMD5_Multiple64ByteChunks( &PossibleHash, pBuffer, dwBytesToWrite );

        if ( bFirstBlockMatch ) {

            QueueMaybeWrite( hTargetContext,
                             pBuffer,
                             dwlOffset,
                             dwBytesToWrite,
                             NULL,
                             NULL,
                             dwMaxQueuedWriteBufferBytes );
            }

        else {

            GenericWrite( dwlOffset, pBuffer, dwBytesToWrite );

            }

        dwlOffset += dwBytesToWrite;

        ReportTransferProgress( dwlOffset );

        }

    ASSERT( dwlTotalRead == dwlFileSize );

    bWholeFileMatch = LookupOrAddBnode(
                          &pWholeFileHashTree,
                          &WholeFileHashAndLength,
                          pFile,
                          &pBnode
                          );

    if ( bFirstBlockMatch ) {

        if ( bWholeFileMatch ) {

            //
            //  There is an extremely high probability that this file is a
            //  duplicate.  Odds are 1/2^128 (1 in 3.4e38 or 340 undecillion)
            //  that the MD5 hashes of two different files with equal length
            //  are not the same, assuming of course that MD5 hash values
            //  are flatly distributed.
            //

            DiscardMaybeQueue( hTargetContext );    // don't write to image

            pFileDup = pBnode->pContext;

            ASSERT( pFileDup->dwlFileSize == dwlFileSize );

            MakeFileDuplicate( pFile, pFileDup );

            bNewFile = FALSE;

            }

        else {

            ASSERT( pFirstDup != NULL );

            WarnTwoFilesSameFirstBlockNotIdentical( pFirstDup, pFile );

            FlushMaybeQueue( hTargetContext );      // commit to image

            FileDataCrc   = PossibleCrc;
            SignatureHash = PossibleHash;
            }
        }

    else {

        FileDataCrc   = PossibleCrc;
        SignatureHash = PossibleHash;
        }

    return bNewFile;

    }


VOID
MakeFileDuplicate(
    PDIRENTRY pFile,
    PDIRENTRY pPrimary
    )
    {
    DWORDLONG dwlFileSize;

    pFile->dwFlags        |= IS_DUPLICATE;
    pFile->pPrimary        = pPrimary;
    pFile->dwStartingBlock = pPrimary->dwStartingBlock;

    dwlFileSize = pFile->dwlFileSize;

    dwlTotalDupFiles++;
    dwlTotalDupFileBytes += ROUNDUP2_64( dwlFileSize, dwBlockSize );
    dwlTotalImageBytes   -= ROUNDUP2_64( dwlFileSize, dwBlockSize );
    dwTotalImageBlocks   -= CD_BLOCKS_FROM_SIZE( dwlFileSize );

    if ( bShowDuplicates ) {

        if ( pFile->pszUnicodeName ) {

            ASSERT( pFile->pPrimary->pszUnicodeName );

            GenerateFullNameSourceW( pFile, DescentNameBuffer.W );
            printf( "\r\n%S is duplicate of ", DescentNameBuffer.W );
            GenerateFullNameSourceW( pFile->pPrimary, DescentNameBuffer.W );
            printf( "%S\r\n", DescentNameBuffer.W );
            fflush( stdout );

            }

        else {

            ASSERT( pFile->pszFileName );
            ASSERT( pFile->pPrimary->pszFileName );

            GenerateFullNameSource( pFile, DescentNameBuffer.A );
            printf( "\r\n%s is duplicate of ", DescentNameBuffer.A );
            GenerateFullNameSource( pFile->pPrimary, DescentNameBuffer.A );
            printf( "%s\r\n", DescentNameBuffer.A );
            fflush( stdout );

            }
        }
    }


VOID
ReportTransferProgress(
    DWORDLONG dwlOffset
    )
    {
    static DWORDLONG dwlNextOffset;

    if ( bReportAllFiles )
        return;

    if ( dwlOffset > dwlNextOffset ) {

        DWORDLONG dwlTotalBytesDone;
        DWORDLONG dwlBytesPerPercent;
        DWORDLONG dwlBytesNextPercent;
        DWORD     dwPercentComplete;
        static DWORD dwOldPercent = 0;

        dwlTotalBytesDone   = dwlOffset - dwlTotalMetaBytes;
        dwPercentComplete   = (DWORD)(( dwlTotalBytesDone * 100) / dwlTotalImageBytes );
        dwlBytesPerPercent  = dwlTotalImageBytes / 100;
        dwlBytesNextPercent = ( dwPercentComplete + 1 ) * dwlBytesPerPercent;
        dwlNextOffset       = dwlBytesNextPercent + dwlTotalMetaBytes;

        // bugbug, this should fix the UDF progress, but not screw up the ISO
        dwPercentComplete = dwPercentComplete % 100;

        if(dwOldPercent > dwPercentComplete)
            dwPercentComplete = dwOldPercent;

        dwOldPercent = dwPercentComplete;

        fprintf(stderr, "\r%d%% complete", dwPercentComplete );
        fflush( stderr );
        }

    }


VOID
ReportHeaderProgress(
    DWORDLONG dwlOffset
    )
    {
    static DWORDLONG dwlNextOffset;

    if ( bReportAllFiles )
        return;

    if ( dwlOffset > dwlNextOffset ) {

        DWORDLONG dwlTotalFileBytes;
        DWORDLONG dwlTotalBytesDone;
        DWORDLONG dwlBytesPerPercent;
        DWORDLONG dwlBytesNextPercent;
        DWORD     dwPercentComplete;
        static DWORD dwOldPercent = 0;

        dwlTotalFileBytes   = dwlTotalImageBytes - dwlTotalMetaBytes;
        dwlTotalBytesDone   = dwlTotalFileBytes + dwlOffset;
        dwPercentComplete   = (DWORD)(( dwlTotalBytesDone * 100 ) / dwlTotalImageBytes );
        dwlBytesPerPercent  = dwlTotalImageBytes / 100;
        dwlBytesNextPercent = ( dwPercentComplete + 1 ) * dwlBytesPerPercent;
        dwlNextOffset       = dwlBytesNextPercent - dwlTotalFileBytes;

                // bugbug, this should fix the UDF progress, but not screw up the ISO
        dwPercentComplete = dwPercentComplete % 100;

        if(dwOldPercent > dwPercentComplete)
            dwPercentComplete = dwOldPercent;

        dwOldPercent = dwPercentComplete;

        fprintf( stderr, "\r%d%% complete", dwPercentComplete );
        fflush( stderr );
        }

    }


void MakeIsoTimeStampFromFileTime( PUCHAR pMem, FILETIME ftFileTime ) {

    SYSTEMTIME st;

    ZeroMemory( &st, sizeof( st ));      // in case FileTimeToSystemTime fails.

    *(UNALIGNED DWORDLONG*)&ftFileTime += LocalTimeBiasInFileTimeUnits;

    FileTimeToSystemTime( &ftFileTime, &st );

    *( pMem + 0 ) = (UCHAR)( st.wYear - 1900 );
    *( pMem + 1 ) = (UCHAR)( st.wMonth );
    *( pMem + 2 ) = (UCHAR)( st.wDay );
    *( pMem + 3 ) = (UCHAR)( st.wHour );
    *( pMem + 4 ) = (UCHAR)( st.wMinute );
    *( pMem + 5 ) = (UCHAR)( st.wSecond );
    *( pMem + 6 ) = (UCHAR)( IsoLocalTimeBias );

    }


void MakeIsoVolumeCreationTime( PCHAR pMem, FILETIME ftFileTime ) {

    SYSTEMTIME st;

    ZeroMemory( &st, sizeof( st ));      // in case FileTimeToSystemTime fails.

    *(UNALIGNED DWORDLONG*)&ftFileTime += LocalTimeBiasInFileTimeUnits;

    FileTimeToSystemTime( &ftFileTime, &st );

    sprintf(
        pMem,
        "%04d%02d%02d%02d%02d%02d%02d%c",
        st.wYear,
        st.wMonth,
        st.wDay,
        st.wHour,
        st.wMinute,
        st.wSecond,
        0,                  // hundredths of seconds
        IsoLocalTimeBias
        );

    }


void DeleteTargetFile( void ) {

    if ( ! DeleteFile( pszTargetFile )) {

        DWORD ErrorCode = GetLastError();


        if (( ErrorCode != ERROR_PATH_NOT_FOUND ) &&
            ( ErrorCode != ERROR_FILE_NOT_FOUND )) {

            ErrorExit( GETLASTERROR,
                       "ERROR: Could not delete existing file \"%s\"\r\n",
                       pszTargetFile );

            }
        }
    }


BOOL NonDchars( LPSTR pszFileName ) {

    PUCHAR p;
    UCHAR  c;

    //
    //  Note -- we'll consider a '.' to be a dchar here since
    //  it is valid in filenames, so when calling this routine
    //  for valid directory names, you'll have to special-case
    //  the '.' and check for it separately from call to NonDchars.
    //

    for ( p = (PUCHAR) pszFileName; ( c = *p ) != '\0'; p++ )

        if ((( c < '0' ) && ( c != '.' )) ||
            (( c > '9' ) && ( c <  'A' )) ||
            (( c > 'Z' ) && ( c != '_' )))

            return TRUE;

    return FALSE;

    }


void ParseOptions( int argc, char *argv[] ) {

    BOOL bJS = FALSE;
    BOOL bUS = FALSE;
    char *p;
    int i;

    //
    //  The option arguments may appear anywhere in the command line
    //  (beginning, end, middle, mixed), so for each option we encounter,
    //  we'll mark it NULL after processing it.  Then, the other Parse
    //  routines can loop through the whole command line again, and just
    //  ignore NULLs.
    //

    for ( i = 1; i < argc; i++ ) {

        p = argv[ i ];

        if (( p ) && ( *p == '-' ) || ( *p == '/' )) {     // process flags

            ++p;

            if (strcmp(p, "xbox") == 0) {

                bUdfXbox = TRUE;
                argv[ i ] = NULL;
                continue;
            }

            switch( tolower( *p )) {

                case '?':
                    Usage();
                    break;

                case 't':
                    bUseGlobalTime = TRUE;
                    ParseTimeStamp( p + 1 );
                    argv[ i ] = NULL;
                    break;

                case 'g':
                    bEncodeGMT = TRUE;
                    argv[ i ] = NULL;
                    break;

                case 'h':
                    bHiddenFiles = TRUE;
                    argv[ i ] = NULL;
                    break;

                case 'l':

                    if ( strlen( p + 1 ) > 32 ) {
                        ErrorExit( 0, "ERROR: Maximum volume label length is 32 characters\r\n" );
                        }

                    strcpy(  chVolumeLabel, p + 1 );                //  chVolumeLabel is mixed case
                    strcpy( uchVolumeLabel, p + 1 );
                    strupr( uchVolumeLabel );                       // uchVolumeLabel is upper case
                    AnsiToUnicode( chVolumeLabel, wchVolumeLabel ); // wchVolumeLabel is mixed case
                    argv[ i ] = NULL;
                    break;

                case 'u':
                    switch ( tolower( *( ++p ) ))
                    {
                        case '2':
                            bEncodeOnlyUdf      = TRUE;

                        case '1':
                            bEncodeUdf          = TRUE;
                            bUnicodeNames       = TRUE;
                            bOptimizeFileNames  = TRUE;
                            bIgnoreMaxImageSize = TRUE;
                            break;

                        case 'r':
                            bUS = TRUE;
                            strcpy( StubSourceFile, p + 1 );
                            if ( *StubSourceFile == 0 ) {
                                Usage();
                                }
                            break;

                        case 'e':
                            bUdfEmbedData=TRUE;
                            break;

                        case 's':
                            bUdfSparse=TRUE;
                            break;

                        case 'f':
                            bUdfEmbedFID=TRUE;
                            break;

                        case 'v':
                            bUdfVideoZone = TRUE;
                            break;

                        default:
                            Usage();
                        }
                    argv[ i ] = NULL;
                    break;


#ifndef DVDIMAGE_ONLY

                case 'j':
                    switch ( tolower( *( ++p ) )) {
                        case '1':
                            bGenerateShortNames = TRUE;

                            // fall through, don't break
                        case '2':
                            bEncodeJoliet       = TRUE;
                            bUnicodeNames       = TRUE;
                            bOptimizeFileNames  = TRUE;
                            break;
                        case 's':
                            bJS = TRUE;
                            strcpy( StubSourceFile, p + 1 );
                            if ( *StubSourceFile == 0 ) {
                                Usage();
                                }
                            break;
                        default:
                            Usage();
                        }
                    argv[ i ] = NULL;
                    break;

                case 'w':

                    //
                    //  Assume at least level 1.
                    //

                    bReportExceedLevels    = TRUE;
                    bReportInvalidIsoNames = TRUE;

                    p++;

                    if ( *p >= '2' )
                        bReportInvalidDosNames = TRUE;

                    if ( *p >= '3' )
                        bReportZeroLength = TRUE;

                    if ( *p >= '4' )
                        bReportAllFiles = TRUE;

                    argv[ i ] = NULL;
                    break;

                case 'n':

                    bAllowLongNames = TRUE;
                    bOptimizeFileNames = TRUE;

                    if ( tolower( *( p + 1 )) == 't' )
                        bRestrictToNt3xCompatibleNames = TRUE;

                    argv[ i ] = NULL;
                    break;

                case 'd':
                    bDontUpcase = TRUE;
                    argv[ i ] = NULL;
                    break;

                case 'c':
                    bUseAnsiFileNames = TRUE;
                    argv[ i ] = NULL;
                    break;

                case 'o':

                    bOptimizeStorage   = TRUE;  // store duplicate files once
                    bOptimizeFileNames = TRUE;  // default, no trailing ";1"
                    bOptimizeFast      = TRUE;  // default, use MD5

                    for (;;) {

                        switch ( tolower( *( ++p ) )) {

                            case 'x':           // obsolete, now the default
                            case 'f':           // obsolete, now the default
                                continue;

                            case 's':
                                bShowDuplicates = TRUE;
                                continue;

                            case 'i':
                                bOptimizeDiamond = TRUE;
                                continue;

                            case 'c':
                                bOptimizeFast = FALSE;  // revert to slow binary comparisons
                                continue;

#ifdef DONTCOMPILE
                            case 'd':

                                bOptimizeDepthFirst = TRUE;

                                if ( *( p + 1 ) == '[' ) {
                                    p = p + 2;
                                    for (;;) {
                                        char *q = strchr( p, ',' );
                                        if ( q == NULL )
                                            q = strchr( p, ']' );
                                        if ( q == NULL )
                                            Usage();
                                        if ( q > p ) {
                                            if ( nDirectoryFirst >= MAX_SPECIFIED_DIRS ) {
                                                ErrorExit( 0, "ERROR: Can specify up to %d directories with %s\r\n", MAX_SPECIFIED_DIRS, "-od" );
                                                }
                                            DirectoryFirst[ nDirectoryFirst ] = MyAllocNeverFree(( q - p ) + 1 );
                                            memcpy( DirectoryFirst[ nDirectoryFirst++ ], p, q - p );
                                            }
                                        if ( *q == ']' ) {
                                            p = q;
                                            break;
                                            }
                                        p = q + 1;
                                        }
                                    }

                                continue;

                            case 'a':

                                bOptimizeDepthAfter = TRUE;

                                if ( *( p + 1 ) == '[' ) {
                                    p = p + 2;
                                    for (;;) {
                                        char *q = strchr( p, ',' );
                                        if ( q == NULL )
                                            q = strchr( p, ']' );
                                        if ( q == NULL )
                                            Usage();
                                        if ( q > p ) {
                                            if ( nDirectoryFirst >= MAX_SPECIFIED_DIRS ) {
                                                ErrorExit( 0, "ERROR: Can specify up to %d directories with %s\r\n", MAX_SPECIFIED_DIRS, "-oa" );
                                                }
                                            DirectoryFirst[ nDirectoryFirst ] = MyAllocNeverFree(( q - p ) + 1 );
                                            memcpy( DirectoryFirst[ nDirectoryFirst++ ], p, q - p );
                                            }
                                        if ( *q == ']' ) {
                                            p = q;
                                            break;
                                            }
                                        p = q + 1;
                                        }
                                    }

                                continue;

                            case 'z':

                                if ( *( p + 1 ) == '[' ) {
                                    p = p + 2;
                                    for (;;) {
                                        char *q = strchr( p, ',' );
                                        if ( q == NULL )
                                            q = strchr( p, ']' );
                                        if ( q == NULL )
                                            Usage();
                                        if ( q > p ) {
                                            if ( nReverseSort >= MAX_SPECIFIED_DIRS ) {
                                                ErrorExit( 0, "ERROR: Can specify up to %d directories with %s\r\n", MAX_SPECIFIED_DIRS, "-oz" );
                                                }
                                            ReverseSort[ nReverseSort ] = MyAllocNeverFree(( q - p ) + 1 );
                                            memcpy( ReverseSort[ nReverseSort++ ], p, q - p );
                                            }
                                        if ( *q == ']' ) {
                                            p = q;
                                            break;
                                            }
                                        p = q + 1;
                                        }
                                    }
                                else {
                                    bOptimizeReverseSort = TRUE;
                                    }

                                continue;

#endif // DONTCOMPILE

                            case ';':

                                //
                                //  Undocumented -; option disables the filename optimizations
                                //  and always appends the ";0" to filenames and puts trailing
                                //  dots on filenames without extensions.  This behavior is
                                //  typically enabled with -n or -o.
                                //

                                bSuppressOptimizeFileNames = TRUE;
                                continue;

                            case 0:
                                break;

                            default:        // invalid -o option
                                Usage();
                            }
                        break;
                        }
                    argv[ i ] = NULL;
                    break;

                case 'm':
                    bIgnoreMaxImageSize = TRUE;
                    argv[ i ] = NULL;
                    break;

                case 'a':
                    bAllocationSummary = TRUE;
                    argv[ i ] = NULL;
                    break;

                case 'x':
                    bEncodeAutoCrc = TRUE;

                    if ( tolower( *( p + 1 )) == 'x' ) {    // -xx
                        bCrcCorrectionInTvd = TRUE;
                        }

                    argv[ i ] = NULL;
                    break;

                case 'b':
                    bElTorito = TRUE;
                    ReadElToritoBootSectorFile( p + 1 );
                    argv[ i ] = NULL;

                    //
                    //  The etfsboot.com El Torito boot sector file that we're
                    //  currently using for NT product media does not correctly
                    //  handle filenames encoded with trailing ";1", so we'll
                    //  explicitly turn off ";1" encoding here.  This can be
                    //  overridden with the -; or -y1 switches.
                    //

                    bOptimizeFileNames = TRUE;
                    break;

                case 'q':
                    bScanOnly = TRUE;
                    argv[ i ] = NULL;
                    break;

                case 'k':
                    bContinueAfterFailedSourceOpen = TRUE;
                    argv[ i ] = NULL;
                    break;

                case 's':
                    {
                    unsigned length = strlen( p + 1 );

                    if ( length == 0 ) {
                        ErrorExit( 0, "ERROR: Must specify server and RPC endpoint name immediately following -s\r\n" );
                        }

                    SignatureRpcEndpointName = MyAllocNeverFree( length + 1 );
                    memcpy( SignatureRpcEndpointName, p + 1, length + 1 );
                    bSignImageAttempt = TRUE;
                    bSignImage = TRUE;
                    argv[ i ] = NULL;
                    break;
                    }

                case ';':

                    //
                    //  Undocumented -; option disables the filename optimizations
                    //  and always appends the ";0" to filenames and puts trailing
                    //  dots on filenames without extensions.  This behavior is
                    //  typically enabled with -n or -o.
                    //

                    bSuppressOptimizeFileNames = TRUE;
                    argv[ i ] = NULL;
                    break;

                case 'y':

                    for (;;) {
                        switch ( tolower( *( ++p ) )) {

                            case '1':
                            case ';':
                                bSuppressOptimizeFileNames = TRUE;
                                continue;

                            case '2':
                                bRoundDirectorySizes = TRUE;
                                continue;

#ifdef DONTCOMPILE

                            case '3':
                                bOneDirectoryRecordPerSector = TRUE;
                                bRoundDirectorySizes = TRUE;
                                continue;

                            case '4':
                                bOneDirectoryRecordPerTwoSectors = TRUE;
                                bRoundDirectorySizes = TRUE;
                                continue;

#endif // DONTCOMPILE

                            case '5':
                                bHackI386Directory = TRUE;
                                continue;

                            case '6':
                                bAllowExactAlignedDirs = TRUE;
                                continue;

                            case '7':
                                bReportBadShortNames = TRUE;
                                continue;

                            case 'd':
                                bSuppressWarnSameFirstBlockNotIdentical = TRUE;
                                continue;

                            case 'b':
                                dwBlockSize = 512;
                                continue;

                            case 0:
                                break;

                            case 'w':
                                bOpenReadWrite=TRUE;
                                break;

                            case 'l':
                                bUdfUseLongADs=TRUE;
                                break;

                            case 'r':
								srand(time(NULL));
                                bUdfUseRandomExtents=TRUE;
                                break;

                            case 't':
                                ElToritoLoadSegment = (WORD)strtoul( p + 1, NULL, 16 );
                                break;

                            case 'f':
                                bFastShortNameGeneration = TRUE;
                                break;

                            default:        // invalid -t option
                                Usage();
                            }

                        break;
                        }

                    argv[ i ] = NULL;
                    break;


#endif // DVDIMAGE_ONLY

                default:
                    ErrorExit( 0, "ERROR: Invalid flag \"-%c\"\r\n", *p );

                }
            }

        else {

            //
            //  Assume this is a file pattern argument.  Just leave it alone.
            //

            }

        }

    if (bUdfXbox) {

        bUdf8BitFileNames = TRUE;

        // -u1

        bEncodeUdf          = TRUE;
        bUnicodeNames       = TRUE;
        bOptimizeFileNames  = TRUE;
        bIgnoreMaxImageSize = TRUE;

        if (bElTorito) {

            // -j1

            bGenerateShortNames = TRUE;

        } else {

            // -u2

            bEncodeOnlyUdf      = TRUE;

            bUdfEmbedFID=TRUE;
        }
    }

#ifdef DVDIMAGE_ONLY

    if ( ! bEncodeOnlyUdf ) {

        bEncodeUdf          = TRUE;
        bUnicodeNames       = TRUE;
        bEncodeJoliet       = TRUE;
        bGenerateShortNames = TRUE;
        bOptimizeFileNames  = TRUE;
        bIgnoreMaxImageSize = TRUE;

        }

#endif // DVDIMAGE_ONLY

    if ( bSuppressOptimizeFileNames ) {
        bOptimizeFileNames = FALSE;
        }

#ifdef DONTCOMPILE

    if ( bOptimizeDepthFirst || bOptimizeDepthAfter || bOptimizeReverseSort || nDirectoryFirst || nReverseSort ) {
        bModifyOrder = TRUE;
        }

    if ( bOptimizeDepthFirst && bOptimizeDepthAfter ) {
        ErrorExit( 0, "ERROR: Cannot specify both -od and -oa\r\n" );
        }

#endif // DONTCOMPILE

    if (( bEncodeOnlyUdf ) && ( bAllowLongNames || bDontUpcase || bEncodeJoliet || bOptimizeDiamond)) {
        ErrorExit( 0, "ERROR: With -u2, cannot use -n, -nt, -d, -j1, -j2, or -oi\r\n" );
    }

    if(bFastShortNameGeneration)
    {
        printf("Using fast short name generation will cause different short names to be generated\r\n");
    }

    if (( !bEncodeOnlyUdf ) && ( bUdfSparse || bUdfEmbedData || bUdfEmbedFID)) {
        ErrorExit( 0, "ERROR: Cannot use -ue, -us, -uf without -u2\r\n" );
        }

    if(bUdfVideoZone && !bEncodeUdf)
    {
        ErrorExit(0, "ERROR: Cannot use -uv without -u1 or -u2\r\n");
    }

    if(bUdfVideoZone && (bUdfSparse || bUdfEmbedData || bUdfEmbedFID || bOptimizeStorage))
    {
        ErrorExit(0, "ERROR: Cannot use -uv with -us -ue -uf or -o \r\n");
    }

    if(!bEncodeOnlyUdf && bEncodeUdf && (bUdfSparse || bUdfEmbedData))
    {
        ErrorExit(0, "ERROR: Cannot use -us or -uf with -u1\r\n");
    }

    if(bEncodeUdf && bAllowLongNames)
    {
        ErrorExit(0, "ERROR: Cannot use -n or -nt with -u1 or -u2\r\n");
    }

    if(bEncodeUdf && !bEncodeOnlyUdf && (bUdfUseLongADs || bUdfUseRandomExtents))
    {
        ErrorExit(0, "ERROR: Cannot use -yl or -yr with -u1\r\n");
    }

    if(bUdfSparse)
    {
        printf("\r\nWARNING: This image may not work on Windows9x due to sparse files\r\n");
    }

    if (( bEncodeUdf ) && ( bAllocationSummary || bEncodeAutoCrc || bSignImage)) {
        ErrorExit( 0, "ERROR: With -u1 and -u2, cannot use -a, -s, or -x\r\n" );
        }

    if (( bEncodeJoliet ) && ( bAllowLongNames || bDontUpcase )) {
        ErrorExit( 0, "ERROR: With -j1 and -j2, cannot use -n, -nt, or -d\r\n" );
        }

    if (( bEncodeJoliet ) && ( strlen( chVolumeLabel ) > 16 )) {
        ErrorExit( 0, "ERROR: Maximum Joliet Unicode volume label length is 16 characters\r\n" );
        }

    if (( bDontUpcase ) && ( bRestrictToNt3xCompatibleNames )) {
        ErrorExit( 0, "ERROR: With -nt, cannot use -d\r\n" );
        }

    if (( bReportBadShortNames ) && ( bContinueAfterFailedSourceOpen )) {
        ErrorExit( 0, "ERROR: With -k, cannot use -y7\r\n" );
        }

    if (( dwBlockSize != CD_SECTORSIZE ) && ( bEncodeUdf )) {
        ErrorExit( 0, "ERROR: With -u1 and -u2, cannot use -yb (512 byte blocks)\r\n" );
        }

    if (( bJS ) && (( ! bEncodeJoliet ) || ( bGenerateShortNames ))) {
        ErrorExit( 0, "ERROR: Can only use -js with -j2\r\n" );
        }

    if (( bUS ) && ( ! bEncodeOnlyUdf )) {
        ErrorExit( 0, "ERROR: Can only use -us with -u2\r\n" );
        }

    if ((( bEncodeJoliet ) && ( ! bGenerateShortNames )) || ( bEncodeOnlyUdf )) {
        GetStubFileContents();
        }

    if ( dwBlockSize != CD_SECTORSIZE ) {
        printf( "\r\nWARNING: 512 byte blocksizes are for testing only!  DO NOT use for retail discs!\r\n" );
        }

    }


void ParseTimeStamp( LPSTR pArg ) {

    //
    //  Expected form: month/day/year/hour/minute/second
    //  with any non-digit character(s) being a delimiter.
    //

    SYSTEMTIME st;
    UINT i, arg[ 6 ] = { 0, 0, 0, 0, 0, 0 };
    char *p = pArg;

    if ( *p ) {

        for ( i = 0; i < 6; i++ ) {

            while ( IsDigit( *p ))
                arg[ i ] = ( arg[ i ] * 10 ) + ( *p++ - '0' );

            while (( *p ) && ( ! IsDigit( *p ))) ++p;

            }

        if ( arg[ 2 ] < 1000 ) {
            ErrorExit( 0, "ERROR: Must specify a 4 digit year with -t\r\n" );
        }

        st.wYear         = (WORD) arg[ 2 ];
        st.wMonth        = (WORD) arg[ 0 ];
        st.wDay          = (WORD) arg[ 1 ];
        st.wHour         = (WORD) arg[ 3 ];
        st.wMinute       = (WORD) arg[ 4 ];
        st.wSecond       = (WORD) arg[ 5 ];
        st.wMilliseconds = 0;

        if (( st.wYear   > 2150 ) ||
            ( st.wMonth  >   12 ) ||
            ( st.wDay    >   31 ) ||
            ( st.wHour   >   23 ) ||
            ( st.wMinute >   59 ) ||
            ( st.wSecond >   59 ) ||
            ( ! SystemTimeToFileTime( &st, &ftGlobalFileTime )))
            {
            ErrorExit( 0, "ERROR: Invalid time: %s\r\n", pArg );
            }
        }
    }


void Usage( void ) {

    printf(

"Usage: " CDIMAGE_NAME " [options] sourceroot targetfile\r\n"
"\r\n"
"       -l  volume label, no spaces (e.g. -lMYLABEL)\r\n"
"       -t  time stamp for all files and directories, no spaces, any delimiter\r\n"
"             (e.g. -t12/31/2000,15:01:00)\r\n"
"       -g  encode GMT time for files rather than local time\r\n"
"       -h  include hidden files and directories\r\n"

#ifdef XBOX

"       -xbox  encode a file system compatible with Xbox\r\n"
"       -o  optimize storage by encoding duplicate files only once\r\n"
"       -oc slower duplicate file detection using binary comparisons rather\r\n"
"             than MD5 hash values\r\n"
"       -os show duplicate files while creating image\r\n"
"           (-o options can be combined like -ocs)\r\n"
"       -q  scan source files only, don't create an image file\r\n"
"       -w  warning level followed by number (e.g. -w4)\r\n"
"           1  report non-ISO or non-Joliet compliant filenames or depth\r\n"
"           2  report non-DOS compliant filenames\r\n"
"           3  report zero-length files\r\n"
"           4  report each file name copied to image\r\n"

          );

#else

#ifdef DVDIMAGE_ONLY

"       -u1 encode \"UDF-Bridge\" media\r\n"
"       -u2 encode \"UDF\" file system without a mirror ISO-9660 file system\r\n"
"             (requires a UDF capable operating system to read the files)\r\n"
"       -ur non-UDF \"readme.txt\" file for images encoded with -u2 option\r\n"
"             (e.g. -usc:\\location\\readme.txt). This file will be visible as\r\n"
"             the only file in the root directory of the disc on systems that\r\n"
"             do not support the UDF format.\r\n"
"       -us sparse UDF files\r\n"
"       -ue embed file data in UDF extent entry\r\n"
"       -uf embed UDF FID entries\r\n"
"       -uv UDF Video Zone compatibility enforced\r\n"

#else // ! DVDIMAGE_ONLY

"       -n  allow long filenames (longer than DOS 8.3 names)\r\n"
"       -nt allow long filenames, restricted to NT 3.51 compatibility\r\n"
"             (-nt and -d cannot be used together)\r\n"
"       -d  don't force lowercase filenames to uppercase\r\n"
"       -c  use ANSI filenames versus OEM filenames from source\r\n"
"       -j1 encode Joliet Unicode filenames AND generate DOS-compatible 8.3\r\n"
"             filenames in the ISO-9660 name space (can be read by either\r\n"
"             Joliet systems or conventional ISO-9660 systems, but some of the\r\n"
"             filenames in the ISO-9660 name space might be changed to comply\r\n"
"             with DOS 8.3 and/or ISO-9660 naming restrictions)\r\n"
"       -j2 encode Joliet Unicode filenames without standard ISO-9660 names\r\n"
"             (requires a Joliet operating system to read files from the CD)\r\n"
"           When using the -j1 or -j2 options, the -n, -nt, and -d options\r\n"
"             do not apply and cannot be used.\r\n"
"       -js non-Joliet \"readme.txt\" file for images encoded with -j2 option\r\n"
"             (e.g. -jsc:\\location\\readme.txt). This file will be visible as\r\n"
"             the only file in the root directory of the disc on systems that\r\n"
"             do not support the Joliet format (Windows 3.1, NT 3.x, etc).\r\n"
"       -u1 encode \"UDF-Bridge\" media\r\n"
"       -u2 encode \"UDF\" file system without a mirror ISO-9660 file system\r\n"
"             (requires a UDF capable operating system to read the files)\r\n"
"       -ur non-UDF \"readme.txt\" file for images encoded with -u2 option\r\n"
"             (e.g. -usc:\\location\\readme.txt). This file will be visible as\r\n"
"             the only file in the root directory of the disc on systems that\r\n"
"             do not support the UDF format.\r\n"
"       -us sparse UDF files\r\n"
"       -ue embed file data in UDF extent entry\r\n"
"       -uf embed UDF FID entries\r\n"
"       -uv UDF Video Zone compatibility enforced\r\n"
"       -b  \"El Torito\" boot sector file, no spaces\r\n"
"             (e.g. -bc:\\location\\cdboot.bin)\r\n"
"       -s  sign image file with digital signature (no spaces, provide RPC\r\n"
"             server and endpoint name like -sServerName:EndPointName)\r\n"
"       -x  compute and encode \"AutoCRC\" values in image\r\n"
"       -o  optimize storage by encoding duplicate files only once\r\n"
"       -oc slower duplicate file detection using binary comparisons rather\r\n"
"             than MD5 hash values\r\n"
"       -oi ignore diamond compression timestamps when comparing files\r\n"
"       -os show duplicate files while creating image\r\n"
"           (-o options can be combined like -ocis)\r\n"

#ifdef DONTCOMPILE

"       -od order directory and file contents in depth-as-encountered order\r\n"
"             versus level-first order, and store specified directories ahead\r\n"
"             of all others (just -od or use -od[dir1,dir2,dir2\\subdir1] to\r\n"
"             specify directories to store first)\r\n"
"       -oa order directory and file contents in depth-after-encountered order\r\n"
"             versus level-first order, and store specified directories ahead\r\n"
"             of all others (just -od or use -oa[dir1,dir2,dir2\\subdir1] to\r\n"
"             specify directories to store first)\r\n"
"       -oz order directory and file contents in reverse alphabetical order\r\n"
"             for the directories specified or for all directories if none\r\n"
"             are specified (just -oz or -oz[dir1,dir2,dir2\\subdir1])\r\n"
"           (-o options can be combined like -ocisd[dir1,dir2]z[dir1,dir2])\r\n"

#endif // DONTCOMPILE

"       -w  warning level followed by number (e.g. -w4)\r\n"
"           1  report non-ISO or non-Joliet compliant filenames or depth\r\n"
"           2  report non-DOS compliant filenames\r\n"
"           3  report zero-length files\r\n"
"           4  report each file name copied to image\r\n"
"       -y  test option followed by number (e.g. -y1), used to generate\r\n"
"             non-standard variations of ISO-9660 for testing purposes:\r\n"
"           1 encode trailing version number ';1' on filenames (7.5.1)\r\n"
"           2 round directory sizes to multiples of 2K (6.8.1.3)\r\n"

#ifdef DONTCOMPILE

"           3 one directory record per logical sector (6.8.1.3)\r\n"
"           4 one directory record per two logical sectors (6.8.1.3)\r\n"

#endif // DONTCOMPILE

"           5 write \\i386 directory files first, in reverse sort order\r\n"
"           6 allow directory records to be exactly aligned at ends of sectors\r\n"
"               (ISO-9660 6.8.1.1 conformant but breaks MSCDEX)\r\n"
"           7 warn about generated shortnames for 16-bit apps under NT 4.0\r\n"
"           b blocksize 512 bytes rather than 2048 bytes\r\n"
"           d suppress warning for non-identical files with same initial 64K\r\n"
"           l UDF - long ads used in file entries instead of short ads\r\n"
"           r UDF - number of ad's is random\r\n"
"           w open source files with write sharing\r\n"
"           t load segment in hex for El Torito boot image (e.g. -yt7C0)\n"
"           f use a faster way to generate short names\n"
"       -k  (keep) create image even if fail to open some of the source files\r\n"
"       -m  ignore maximum image size of " MAX_IMAGE_BYTES_TEXT " bytes\r\n"
"       -a  allocation summary shows file and directory sizes\r\n"
"       -q  scan source files only, don't create an image file\r\n"

#endif // ! DVDIMAGE_ONLY

"\r\n"

          );

#ifndef DVDIMAGE_ONLY

    printf(

"       NOTE: Many of these options allow you to create CD images\r\n"
"             that are NOT compliant with ISO-9660 and may also\r\n"
"             NOT be compatibile with one or more operating systems.\r\n"
"             If you want strict ISO and DOS compliance, use the -w2\r\n"
"             warning level and correct any discrepencies reported.\r\n"
"             YOU are responsible for insuring that any generated CDs\r\n"
"             are compatible with all appropriate operating systems.\r\n"
"             Also note that Microsoft company information is placed\r\n"
"             in the image volume header, so don't use this program\r\n"
"             to generate CDs for companies other than Microsoft.\r\n"
"\r\n"

          );

#endif // ! DVDIMAGE_ONLY

#endif

    fflush( stdout );
    exit( 1 );

    }


BOOL IsDigit( char ch ) {

    if (( ch >= '0' ) && ( ch <= '9' ))
        return TRUE;
    else
        return FALSE;
    }


BOOL IsAcceptableDosName( LPSTR pszFileName ) {

    LPSTR  pBegin, pDot, pEnd;
    PUCHAR p;
    UCHAR  c;

    //
    //  Check for 8.3 format and valid characters.  Make sure no more
    //  than one '.' in name and that it's not the first character.
    //  We only check for minimal invalid characters here versus the
    //  more strict IsValidDosName() test.  Note that all extended
    //  (>127) characters are considered "valid" by this test.
    //

    pBegin = pszFileName;
    pEnd   = strchr( pBegin, '\0' );
    pDot   = strchr( pBegin, '.' );

    if ( pDot == NULL )
        pDot = pEnd;
    else {
        if ( strchr( pDot + 1, '.' ))
            return FALSE;
        }

    if (( pDot == pBegin ) || (( pDot - pBegin ) > 8 ) || (( pEnd - pDot ) > 4 ))
        return FALSE;

    for ( p = (PUCHAR) pszFileName; ( c = *p ) != '\0'; p++ ) {
        if (( c <= 0x20 ) || ( strchr( "*?:;,+<>/\\\"\'[]", c )))
            return FALSE;

        }

    return TRUE;
    }


BOOL IsAcceptableDosNameW( LPWSTR pszUnicodeName ) {

    LPWSTR pBegin, pDot, pEnd;
    PWCHAR p;
    WCHAR  c;

    //
    //  Check for 8.3 format and valid characters.  Make sure no more
    //  than one '.' in name and that it's not the first character.
    //  We only check for minimal invalid characters here versus the
    //  more strict IsValidDosName() test.  Note that all extended
    //  (>127) characters are considered "valid" by this test.
    //

    pBegin = pszUnicodeName;
    pEnd   = wcschr( pBegin, L'\0' );
    pDot   = wcschr( pBegin, L'.' );

    if ( pDot == NULL )
        pDot = pEnd;
    else {
        if ( wcschr( pDot + 1, L'.' ))
            return FALSE;
        }

    if (( pDot == pBegin ) || (( pDot - pBegin ) > 8 ) || (( pEnd - pDot ) > 4 ))
        return FALSE;

    for ( p = (PWCHAR) pszUnicodeName; ( c = *p ) != L'\0'; p++ ) {
        if (( c <= 0x20 ) || ( wcschr( (PWCHAR)L"*?:;,+<>/\\\"\'[]", c )))
            return FALSE;

        }

    return TRUE;
    }


BOOL IsValidDosName( LPSTR pszFileName ) {

    LPSTR  pBegin, pDot, pEnd;
    PUCHAR p;
    UCHAR  c;

    //
    //  Check for 8.3 format and valid characters.  Make sure no more
    //  than one '.' in name and that it's not the first character.
    //  List of valid DOS filename characters taken from Microsoft
    //  MS-DOS Programmer's Reference.
    //

    pBegin = pszFileName;
    pEnd   = strchr( pBegin, '\0' );
    pDot   = strchr( pBegin, '.' );

    if ( pDot == NULL )
        pDot = pEnd;
    else {
        if ( strchr( pDot + 1, '.' ))
            return FALSE;
        }

    if (( pDot == pBegin ) || (( pDot - pBegin ) > 8 ) || (( pEnd - pDot ) > 4 ))
        return FALSE;

    for ( p = (PUCHAR) pszFileName; ( c = *p ) != '\0'; p++ ) {

        if ( ! ((( c >= 'A' ) && ( c <= 'Z' )) ||
                (( c >= 'a' ) && ( c <= 'z' )) ||
                (( c >= '0' ) && ( c <= '9' )) ||
                ( strchr( ".!#$%^&()-_{}~", c ))))

            return FALSE;

        }

    return TRUE;

    }


BOOL IsValidIsoDirectoryName( LPSTR pszFileName ) {

    ULONG nLen = strlen( pszFileName );
    ULONG i;
    CHAR  c;

    if ( nLen > 31 )
        return FALSE;

    for ( i = 0; i < nLen; i++ ) {

        c = pszFileName[ i ];

        if ( ! ((( c >= 'A' ) && ( c <= 'Z' )) ||
                (( c >= '0' ) && ( c <= '9' )) ||
                (( c == '_' )))) {

            return FALSE;
            }
        }

    return TRUE;

    }


BOOL IsValidIsoFileName( LPSTR pszFileName ) {

    ULONG nLen = strlen( pszFileName );
    LPSTR pDot = strchr( pszFileName, '.' );
    ULONG i;
    CHAR  c;

    if ( pDot ) {

        if ( strchr( pDot + 1, '.' ))
            return FALSE;                               // more than one '.'

        if ( nLen > 31 )
            return FALSE;

        }

    else {

        if ( nLen > 30 )
            return FALSE;

        }

    for ( i = 0; i < nLen; i++ ) {

        c = pszFileName[ i ];

        if ( ! ((( c >= 'A' ) && ( c <= 'Z' )) ||
                (( c >= '0' ) && ( c <= '9' )) ||
                (( c == '_' ) || ( c == '.' )))) {

            return FALSE;
            }
        }

    return TRUE;
    }


BOOL IsValidNt3xCompatibleFileName( LPSTR pszFileName ) {

    signed char *p = pszFileName;

    while ( *p != 0 )
        if ( *p++ <= 32 )
            return FALSE;

    return TRUE;

    }


BOOL IsValidNt3xCompatibleDirectoryName( LPSTR pszFileName ) {

    signed char *p = pszFileName;

    while ( *p != 0 )
        if ( *p++ <= 32 )
            return FALSE;

    if (( p - pszFileName ) > 37 )  // NT barfs on dirnames longer than 37
        return FALSE;

    return TRUE;

    }


#ifdef DONTCOMPILE  // use memcmp instead

UINT CompareAligned( PVOID p1, PVOID p2, UINT nSize ) {

    //
    //  Buffers are expected to be DWORD aligned.  The return
    //  value is the offset of the miscompare, or nSize if
    //  buffers are equivalent.  The offset returned may be a
    //  non-DWORD aligned number such as 6 if that is the byte
    //  offset of the first miscompare.
    //

    UINT nAligned = nSize & ( ~ ( sizeof( DWORD ) - 1 ));
    UINT n = 0;

    while (( n < nAligned ) && ( *(PDWORD)p1 == *(PDWORD)p2 )) {
        p1 = (PDWORD)p1 + 1;
        p2 = (PDWORD)p2 + 1;
        n += sizeof( DWORD );
        }

    while (( n < nSize ) && ( *(PUCHAR)p1 == *(PUCHAR)p2 )) {
        p1 = (PUCHAR)p1 + 1;
        p2 = (PUCHAR)p2 + 1;
        n++;
        }

    return n;
    }

#endif // DONTCOMPILE

ULONG EncodingNameLength( LPSTR pFileName, BOOL IsDirectory ) {

    ULONG NameLength = strlen( pFileName );

    if (( ! IsDirectory ) && ( ! bOptimizeFileNames )) {
        if ( ! strchr( pFileName, '.' ))
            NameLength += 3;        // trailing ".;1"
        else
            NameLength += 2;        // trailing ";1"
        }

    return NameLength;
    }



BOOL IsFileNameDotOrDotDot( LPCSTR pszFileName ) {

    //
    //  What we're looking for is DOT-NULL or DOT-DOT-NULL.  Any trash
    //  beyond the NULL is legal, so we'll mask off all but first two
    //  bytes for the DOT-NULL and three bytes for the DOT-DOT-NULL
    //  comparisons.  Note dependence on little-endian byte ordering.
    //

    DWORD dwFirstFourBytes = *(UNALIGNED DWORD *)pszFileName;

    if ((( dwFirstFourBytes & 0x0000FFFF ) == 0x0000002E ) ||
        (( dwFirstFourBytes & 0x00FFFFFF ) == 0x00002E2E )) {

        return TRUE;
        }

    return FALSE;
    }


BOOL IsFileNameDotOrDotDotW( LPCWSTR pszUnicodeName ) {

    //
    //  What we're looking for is DOT-NULL or DOT-DOT-NULL.  Any trash
    //  beyond the NULL is legal, so we'll mask off all but first two
    //  chars for the DOT-NULL and three chars for the DOT-DOT-NULL
    //  comparisons.  Note dependence on little-endian byte ordering.
    //

    DWORDLONG dwlFirstEightBytes = *(UNALIGNED DWORDLONG *)pszUnicodeName;
    DWORD     dwFirstFourBytes = (DWORD)dwlFirstEightBytes;

    if (( dwFirstFourBytes == 0x0000002E ) ||
        (( dwlFirstEightBytes & 0x0000FFFFFFFFFFFF )
                             == 0x00000000002E002E )) {

        return TRUE;
        }

    return FALSE;
    }



LPSTR GenerateFullName( PDIRENTRY pDir, LPSTR pBuffer ) {

    if ( pDir->pParentDir == pDir )             // root parent points to itself
        *pBuffer = 0;
    else {
        GenerateFullName( pDir->pParentDir, pBuffer );
        strcat( pBuffer, "\\" );
        strcat( pBuffer, pDir->pszFileName );
        }

    return pBuffer;
    }


LPWSTR GenerateFullNameW( PDIRENTRY pDir, LPWSTR pBuffer ) {

    if ( pDir->pParentDir == pDir )             // root parent points to itself
        *pBuffer = 0;
    else {
        GenerateFullNameW( pDir->pParentDir, pBuffer );
        lstrcatW( pBuffer, (LPCWSTR) L"\\" );
        lstrcatW( pBuffer, pDir->pszUnicodeName );
        }

    return pBuffer;
    }


LPSTR GenerateFullNameSource( PDIRENTRY pDir, LPSTR pBuffer ) {

    GetFilePath( pDir->pParentDir, pBuffer );
    strcat( pBuffer, pDir->pszFileName );
    return pBuffer;
    }


LPWSTR GenerateFullNameSourceW( PDIRENTRY pDir, LPWSTR pBuffer ) {

    GetFilePathW( pDir->pParentDir, pBuffer );
    lstrcatW( pBuffer, pDir->pszUnicodeName );
    return pBuffer;
    }


void ReportAllocationFiles( PDIRENTRY pDirectory ) {

    PDIRENTRY pNode;
    DWORDLONG dwlRawSize, dwlAllocSize;

    ASSERT( pDirectory->pDirectoryInfo != NULL );

    for ( pNode = pDirectory->pDirectoryInfo->pFirstTargetFile; pNode; pNode = pNode->pNextTargetFile ) {

        if ( pNode->dwFlags & IS_DIRECTORY ) {

            ASSERT( pNode->pDirectoryInfo != NULL );

            if ( bEncodeJoliet ) {

                ASSERT( pNode->pDirectoryInfo->dwUnicodeDirSize != 0 );

                dwlRawSize   = pNode->pDirectoryInfo->dwUnicodeDirSize;
                dwlAllocSize = ROUNDUP2_64( dwlRawSize, CD_SECTORSIZE );

                dwlReportRawSize   += dwlRawSize;
                dwlReportAllocSize += dwlAllocSize;

                GenerateFullNameW( pNode, ReportNameBuffer.W );

                printf(
                    "%10I64d %10I64d %5s %S\r\n",
                    dwlRawSize,
                    dwlAllocSize,
                    "[DIR]",
                    ReportNameBuffer.W
                    );

                if ( bGenerateShortNames ) {

                    ASSERT( pNode->pszFileName != NULL );
                    ASSERT( pNode->dwlFileSize != 0 );

                    dwlRawSize   = pNode->dwlFileSize;
                    dwlAllocSize = ROUNDUP2_64( dwlRawSize, CD_SECTORSIZE );

                    dwlReportRawSize   += dwlRawSize;
                    dwlReportAllocSize += dwlAllocSize;

                    GenerateFullName( pNode, ReportNameBuffer.A );

                    printf(
                        "%10I64d %10I64d %5s %s\r\n",
                        dwlRawSize,
                        dwlAllocSize,
                        "[DIR]",
                        ReportNameBuffer.A
                        );

                    }
                }

            else {

                ASSERT( pNode->dwlFileSize != 0 );

                dwlRawSize   = pNode->dwlFileSize;
                dwlAllocSize = ROUNDUP2_64( dwlRawSize, CD_SECTORSIZE );

                dwlReportRawSize   += dwlRawSize;
                dwlReportAllocSize += dwlAllocSize;

                GenerateFullName( pNode, ReportNameBuffer.A );

                printf(
                    "%10I64d %10I64d %5s %s\r\n",
                    dwlRawSize,
                    dwlAllocSize,
                    "[DIR]",
                    ReportNameBuffer.A
                    );

                }

            ReportAllocationFiles( pNode );

            }

        else {      // not a directory

            dwlRawSize = pNode->dwlFileSize;

            dwlAllocSize = ( pNode->dwFlags & IS_DUPLICATE ) ? 0 :
                           ROUNDUP2_64( dwlRawSize, dwBlockSize );

            dwlReportRawSize   += dwlRawSize;
            dwlReportAllocSize += dwlAllocSize;

            if ( bEncodeJoliet ) {

                GenerateFullNameW( pNode, ReportNameBuffer.W );

                printf(
                    "%10I64d %10I64d %5s %S\r\n",
                    dwlRawSize,
                    dwlAllocSize,
                    "",
                    ReportNameBuffer.W
                    );

                if ( bGenerateShortNames ) {

                    ASSERT( pNode->pszFileName != NULL );

                    GenerateFullName( pNode, ReportNameBuffer.A );

                    printf(
                        "                            %s\r\n",
                        ReportNameBuffer.A
                        );

                    }
                }

            else {

                GenerateFullName( pNode, ReportNameBuffer.A );

                printf(
                    "%10I64d %10I64d %5s %s\r\n",
                    dwlRawSize,
                    dwlAllocSize,
                    "",
                    ReportNameBuffer.A
                    );

                }
            }
        }
    }


void ReportAllocationSummary( void ) {

    printf( "\r\n"
            "===================== Allocation Summary =====================\r\n"
            "\r\n"
            "  Raw Size   Blk Size\r\n"
            " ---------  ---------\r\n"

          );

    printf( "%10d %10d %5s %s\r\n",
            16 * CD_SECTORSIZE,
            16 * CD_SECTORSIZE,
            "[SYS]",
            "[ISO-9660 System Area (not used)]"
          );

    printf( "%10d %10d %5s %s\r\n",
            CD_SECTORSIZE,
            CD_SECTORSIZE,
            "[SYS]",
            "[ISO-9660 Primary Volume Descriptor]"
          );

    dwlReportRawSize   = 17 * CD_SECTORSIZE;
    dwlReportAllocSize = 17 * CD_SECTORSIZE;

    if ( bElTorito ) {

        printf( "%10d %10d %5s %s\r\n",
                CD_SECTORSIZE,
                CD_SECTORSIZE,
                "[SYS]",
                "[ISO-9660 Boot Volume Descriptor (El Torito)]"
              );

        dwlReportRawSize   += CD_SECTORSIZE;
        dwlReportAllocSize += CD_SECTORSIZE;

        }

    if ( bEncodeJoliet ) {

        printf( "%10d %10d %5s %s\r\n",
                CD_SECTORSIZE,
                CD_SECTORSIZE,
                "[SYS]",
                "[ISO-9660 Secondary Volume Descriptor (Joliet)]"
              );

        dwlReportRawSize   += CD_SECTORSIZE;
        dwlReportAllocSize += CD_SECTORSIZE;

        }

    printf( "%10d %10d %5s %s\r\n",
            CD_SECTORSIZE,
            CD_SECTORSIZE,
            "[SYS]",
            "[ISO-9660 Volume Descriptor Terminator]"
          );

    dwlReportRawSize   += CD_SECTORSIZE;
    dwlReportAllocSize += CD_SECTORSIZE;

    ASSERT( dwlReportAllocSize == ((DWORDLONG)dwHeaderBlocks * dwBlockSize ));

    if ( bElTorito ) {

        printf( "%10d %10d %5s %s\r\n",
                CD_SECTORSIZE,
                CD_SECTORSIZE,
                "[SYS]",
                "[El Torito Boot Catalog]"
              );

        dwlReportRawSize   += CD_SECTORSIZE;
        dwlReportAllocSize += CD_SECTORSIZE;

        printf( "%10d %10d %5s %s\r\n",
                ElToritoBootSectorFileSize,
                ROUNDUP2( ElToritoBootSectorFileSize, CD_SECTORSIZE ),
                "[SYS]",
                "[El Torito Boot Sector File]"
              );

        dwlReportRawSize   += ElToritoBootSectorFileSize;
        dwlReportAllocSize += ROUNDUP2( ElToritoBootSectorFileSize, CD_SECTORSIZE );

        }

    if ( bEncodeJoliet ) {

        printf( "%10d %10d %5s %s\r\n",
                dwJolietLookupTableSize,
                dwJolietLookupTableAllocation,
                "[SYS]",
                "[Joliet Type-L Path Table]"
              );

        printf( "%10d %10d %5s %s\r\n",
                dwJolietLookupTableSize,
                dwJolietLookupTableAllocation,
                "[SYS]",
                "[Joliet Type-M Path Table]"
              );

        dwlReportRawSize   += dwJolietLookupTableSize       * 2;
        dwlReportAllocSize += dwJolietLookupTableAllocation * 2;

        }

    printf( "%10d %10d %5s %s\r\n",
            dwLookupTableSize,
            dwLookupTableAllocation,
            "[SYS]",
            "[ISO-9660 Type-L Path Table]"
          );

    printf( "%10d %10d %5s %s\r\n",
            dwLookupTableSize,
            dwLookupTableAllocation,
            "[SYS]",
            "[ISO-9660 Type-M Path Table]"
          );

    dwlReportRawSize   += dwLookupTableSize       * 2;
    dwlReportAllocSize += dwLookupTableAllocation * 2;

    if ( bEncodeJoliet && ( ! bGenerateShortNames )) {

        printf( "%10d %10d %5s %s\r\n",
                dwStubFileSize,
                ROUNDUP2( dwStubFileSize, dwBlockSize ),
                "",
                "[Joliet Stub File for Non-Joliet Systems]"
              );

        dwlReportRawSize   += dwStubFileSize;
        dwlReportAllocSize += ROUNDUP2( dwStubFileSize, dwBlockSize );

        }

    if ( dwlMetaPaddingBeforeDirectoriesOffset ) {

        printf( "%10d %10d %5s %s\r\n",
                dwMetaPaddingBeforeDirectoriesBytes,
                dwMetaPaddingBeforeDirectoriesBytes,
                "",
                "[Padding to align directories on sector boundary]"
              );

        dwlReportRawSize   += dwMetaPaddingBeforeDirectoriesBytes;
        dwlReportAllocSize += dwMetaPaddingBeforeDirectoriesBytes;

        }

    //
    //  Need to add padding blocks to get block alignment to sector alignment
    //  for first directory (root directory) entry.
    //

    if ( bEncodeAutoCrc ) {

        //
        //  Actually, the CRC block comes after the directory blocks but
        //  before the first file block.  But, since we're reporting
        //  directories mixed with files, we'll report the CRC block
        //  allocation here.
        //

        printf( "%10d %10d %5s %s\r\n",
                CD_SECTORSIZE,
                CD_SECTORSIZE,
                "[SYS]",
                "[AutoCRC Header Signature Block]"
              );

        dwlReportRawSize   += CD_SECTORSIZE;
        dwlReportAllocSize += CD_SECTORSIZE;

        }

    if ( bEncodeJoliet ) {

        printf( "%10d %10d %5s %s\r\n",
                pRootDir->pDirectoryInfo->dwUnicodeDirSize,
                ROUNDUP2( pRootDir->pDirectoryInfo->dwUnicodeDirSize, CD_SECTORSIZE ),
                "[DIR]",
                "\\" );

        printf( "%10d %10d %5s %s\r\n",
                (DWORD)( pRootDir->dwlFileSize ),
                ROUNDUP2( pRootDir->dwlFileSize, CD_SECTORSIZE ),
                "[DIR]",
                "\\" );

        dwlReportRawSize   += pRootDir->pDirectoryInfo->dwUnicodeDirSize + pRootDir->dwlFileSize;
        dwlReportAllocSize += ROUNDUP2( pRootDir->pDirectoryInfo->dwUnicodeDirSize, CD_SECTORSIZE )
                            + ROUNDUP2( pRootDir->dwlFileSize, CD_SECTORSIZE );

        }

    else {

        printf( "%10d %10d %5s %s\r\n",
                (DWORD)( pRootDir->dwlFileSize ),
                ROUNDUP2( pRootDir->dwlFileSize, CD_SECTORSIZE ),
                "[DIR]",
                "\\" );

        dwlReportRawSize   += pRootDir->dwlFileSize;
        dwlReportAllocSize += ROUNDUP2( pRootDir->dwlFileSize, CD_SECTORSIZE );

        }

    ReportAllocationFiles( pRootDir );

    if ( dwSlackBytesToWriteAtEndOfFiles ) {

        printf( "%10d %10d %5s %s\r\n",
                dwSlackBytesToWriteAtEndOfFiles,
                dwSlackBytesToWriteAtEndOfFiles,
                "",
                "[Padding to align end of image on sector boundary]"
              );

        dwlReportRawSize   += dwSlackBytesToWriteAtEndOfFiles;
        dwlReportAllocSize += dwSlackBytesToWriteAtEndOfFiles;

        }

    //
    //  Need to add padding blocks to get block alignment to sector alignment
    //  for final CRC block.
    //

    if ( bEncodeAutoCrc ) {

        printf( "%10d %10d %5s %s\r\n",
                CD_SECTORSIZE,
                CD_SECTORSIZE,
                "[SYS]",
                "[AutoCRC Image Signature Block]"
              );

        dwlReportRawSize   += CD_SECTORSIZE;
        dwlReportAllocSize += CD_SECTORSIZE;

        }

    printf( " ---------  ---------\r\n" );

    printf( "%10I64d %10I64d [TOT] %I64d files in %I64d directories\r\n\r\n",
            dwlReportRawSize,
            dwlReportAllocSize,
            dwlTotalNumberOfFiles,
            dwlTotalNumberOfDirectories );

    ASSERT( dwlReportAllocSize == dwlTotalImageBytes );

    }


LPWSTR
AnsiToUnicode(
    IN              LPSTR  AnsiBuffer,
    IN OUT OPTIONAL LPWSTR UnicodeBuffer
    )
    {
    int Length = strlen( AnsiBuffer ) + 1;
    int Result;

    if ( UnicodeBuffer == NULL ) {
        UnicodeBuffer = MyAllocNeverFree( Length * 2 );
        }

    Result = MultiByteToWideChar(
                bUseAnsiFileNames ? CP_ACP : CP_OEMCP,
                0,
                AnsiBuffer,
                Length,
                UnicodeBuffer,
                Length
                );

    if ( Result == 0 ) {

        DEBUGCODE(
            ErrorExit(
                GETLASTERROR,
                "ERROR: AnsiToUnicode( \"%s\" ) conversion failed\r\n",
                AnsiBuffer
                )
            );
        }

    return UnicodeBuffer;
    }


LPSTR UnicodeToAnsi(
    IN              LPWSTR UnicodeBuffer,
    IN OUT OPTIONAL LPSTR  AnsiBuffer
    )
    {
    int Length = lstrlenW( UnicodeBuffer ) + 1;
    int Result;

    if ( AnsiBuffer == NULL ) {
        AnsiBuffer = MyAllocNeverFree( Length );
        }

    Result = WideCharToMultiByte(
                bUseAnsiFileNames ? CP_ACP : CP_OEMCP,
                0,
                UnicodeBuffer,
                Length,
                AnsiBuffer,
                Length,
                NULL,
                NULL
                );

    if ( Result == 0 ) {

        DEBUGCODE(
            ErrorExit(
                GETLASTERROR,
                "ERROR: UnicodeToAnsi( \"%S\" ) conversion failed\r\n",
                UnicodeBuffer
                )
            );
        }

    return AnsiBuffer;
    }


int __fastcall CompareRawUnicodeStrings( LPCWSTR String1, LPCWSTR String2 ) {

    PUSHORT p1 = (PUSHORT)String1;
    PUSHORT p2 = (PUSHORT)String2;

    while (( *p1 == *p2 ) && ( *p1 )) {
        ++p1;
        ++p2;
        }

    return ( *p1 < *p2 ) ? -1 : ( *p1 > *p2 ) ? +1 : 0;
    }


PDIRENTRY JolietInsertNode( PDIRENTRY pFirst, PDIRENTRY pNew ) {

    PDIRENTRY pPrev, pNext;

    for ( pPrev = NULL, pNext = pFirst;
          pNext != NULL;
          pPrev = pNext, pNext = pNext->pNextTargetFile ) {

        //
        //  According to RickDew, use the "bag of bytes" sorting
        //  method rather than case-insensitive sorting or ISO-9660
        //  sorting (filename then extension).
        //

        if ( CompareRawUnicodeStrings( pNew->pszUnicodeName, pNext->pszUnicodeName ) < 0 )
            break;

        }

    pNew->pNextTargetFile = pNext;

    if ( pPrev == NULL )
        return pNew;
    else {
        pPrev->pNextTargetFile = pNew;
        return pFirst;
        }

    }


void ComputeJolietDirectorySizes( void ) {

    PDIRENTRY pDir, pFile;
    DWORD dwDirOffset, dwTableOffset, dwNextBound, dwEntryLen;
    DWORD dwNameLength;
    UINT uLevel;
    WCHAR OddNameBuffer[ 112 ];      // 110 is absolute max name length
    WCHAR EvenNameBuffer[ 112 ];
    UINT NameIndex = 0;

    dwTableOffset = 0;
    nDirectories = 0;

    for ( uLevel = 0; pStartOfLevel[ uLevel ]; uLevel++ ) {

        for ( pDir = pStartOfLevel[ uLevel ]; pDir; pDir = pDir->pDirectoryInfo->pNextTargetDir ) {

            ASSERT( pDir->pDirectoryInfo != NULL );

            //
            //  Each table entry is 8 bytes plus the length in bytes of the
            //  name, but the next entry must start at a word (2-byte)
            //  boundary, so round-up offset if necessary.
            //

            ASSERT( pDir->wUnicodeNameLength != 0 );

            dwNameLength = pDir->wUnicodeNameLength;

            if ( pDir != pRootDir )             // except for root dir name
                dwNameLength *= 2;              // unicode characters to bytes

            if (( dwTableOffset += ( 8 + dwNameLength )) & 1 )
                ++dwTableOffset;

            pDir->pDirectoryInfo->dwUnicodeIndex = ++nDirectories;

            if ( pDir->pParentDir->pDirectoryInfo->dwUnicodeIndex > 0xFFFF ) {

                ErrorExit(
                    0,
                    "ERROR: Too many directories in volume (directory number of a parent directory\r\n"
                    "       cannot exceed 65535 because it is stored in a 16-bit field).\r\n"
                    );
                }

            dwDirOffset = 34 * 2;               // for "." and ".." entries

            dwNextBound = CD_SECTORSIZE;        // can't straddle a sector boundary

            if ( bReportBadShortNames ) {
                ZeroMemory( OddNameBuffer,  sizeof( OddNameBuffer ));
                ZeroMemory( EvenNameBuffer, sizeof( EvenNameBuffer ));
                NameIndex = 2;                  // for . and .. entries
                }

            //
            //  Note that MSCDEX will never read the Joliet namespace, so
            //  not necessary to avoid exactly aligned directory records
            //  at ends of sectors.
            //

            for ( pFile = pDir->pDirectoryInfo->pFirstTargetFile; pFile; pFile = pFile->pNextTargetFile ) {

                ASSERT( pFile->wUnicodeNameLength != 0 );
                ASSERT( pFile->wUnicodeNameLength <= 110 );

                dwEntryLen  = ( pFile->wUnicodeNameLength * 2 ) + 33;
                dwEntryLen += dwEntryLen & 1;

                if (( dwDirOffset + dwEntryLen ) > dwNextBound ) {
                    dwDirOffset  = dwNextBound;
                    dwNextBound += CD_SECTORSIZE;
                    }

                DEBUGCODE( pFile->dwUnicodeDirOffset = dwDirOffset );

                if ( bReportBadShortNames ) {

                    //
                    //  Check for potential conflict with bug in NT 4.0
                    //  where CDFS shortname generation fails when the hex
                    //  offset of the direntry shifted right 5 bits
                    //  contains hex characters 'a' through 'f' (non-
                    //  numeric hex characters).
                    //

                    PWCHAR WhichNameBuffer = ( NameIndex++ & 1 ) ? OddNameBuffer : EvenNameBuffer;
                    BOOL   CheckShortName  = ( pFile->dwFlags & CHECK_SHORTNAME ) ? TRUE : FALSE;
                    BOOL   IsDirectory     = ( pFile->dwFlags & IS_DIRECTORY    ) ? TRUE : FALSE;

                    if ( ! CheckShortName ) {

                        if ( bOptimizeFileNames || IsDirectory ) {

                            if (( WhichNameBuffer[ pFile->wUnicodeNameLength ] == '.' ) ||
                                ( WhichNameBuffer[ pFile->wUnicodeNameLength ] == ' ' )) {

                                CheckShortName = TRUE;

                                }
                            }
                        }

                    if ( CheckShortName ) {

                        if (( ! IsDirectory ) && ( ! bOptimizeFileNames )) {

                            if ( IsAcceptableDosNameW( pFile->pszUnicodeName )) {

                                CheckShortName = FALSE;

                                }
                            }
                        }

                    if ( CheckShortName ) {

                        CHAR  Uniquifier[ 12 ];
                        PCHAR p;

                        sprintf( Uniquifier, "%X", dwDirOffset >> 5 );

                        for ( p = Uniquifier; *p; p++ ) {

                            if ( *p > '9' ) {

                                printf(
                                    "\r\nWARNING: %sname \"%S\" may be inaccessible to 16-bit apps "
                                    "under NT 4.0 (see footnote).\r\n",
                                    IsDirectory ? "Directory " : "File",
                                    GenerateFullNameW( pFile, ReportNameBuffer.W )
                                    );

                                fflush( stdout );
                                bReportBadShortNameWarning = TRUE;
                                break;

                                }
                            }
                        }

                    CopyMemory( WhichNameBuffer, pFile->pszUnicodeName, pFile->wUnicodeNameLength * 2 );

                    }

                dwDirOffset += dwEntryLen;

                }

            //
            //  ISO-9660 6.8.1.3 specifies that the length of a directory
            //  INCLUDES the unused bytes at the end of the last sector,
            //  meaning this number should be rounded up to CD_SECTORSIZE.
            //  Since NT 3.1 media, we have always encode actual versus
            //  rounded and never heard of any problems.
            //

            if ( bRoundDirectorySizes ) {
                pDir->pDirectoryInfo->dwUnicodeDirSize = ROUNDUP2( dwDirOffset, CD_SECTORSIZE );
                }
            else {
                pDir->pDirectoryInfo->dwUnicodeDirSize = dwDirOffset;
                }

            }
        }

    dwJolietLookupTableSize       = dwTableOffset;
    dwJolietLookupTableAllocation = ROUNDUP2( dwTableOffset, dwBlockSize );

    }



void WritePrimaryVolumeDescriptor( ULONG SectorNumber ) {

    PUCHAR pHeader;
    DWORD  dwBlock;

    ASSERT( SectorNumber == 16 );       // PVD must be at sector 16

    pHeader = AllocateBuffer( CD_SECTORSIZE, TRUE );

    pHeader[   0 ] = 0x01;      // primary volume descriptor
    pHeader[   6 ] = 0x01;      // volume descriptor version
    pHeader[ 881 ] = 0x01;      // file structure version

    memcpy(  pHeader +   1, "CD001", 5 );

    PadCopy( pHeader +   8,  32, "" );
    PadCopy( pHeader +  40,  32, uchVolumeLabel );          // upper case label
    PadCopy( pHeader + 190, 128, uchVolumeLabel );          // upper case label
    PadCopy( pHeader + 318, 128, "MICROSOFT CORPORATION" );
    PadCopy( pHeader + 446, 128, "MICROSOFT CORPORATION, ONE MICROSOFT WAY, REDMOND WA 98052, (425) 882-8080" );
    PadCopy( pHeader + 574, 128, MAJOR_VERSION_TEXT " " MINOR_VERSION_TEXT );
    PadCopy( pHeader + 702, 111, "" );

    memcpy(  pHeader + 813, IsoVolumeCreationTime, 17 );    // volume creation time
    memcpy(  pHeader + 830, "0000000000000000",    17 );    // last modification time (not specified)
    memcpy(  pHeader + 847, "0000000000000000",    17 );    // expiration time (not specified)
    memcpy(  pHeader + 864, "0000000000000000",    17 );    // effective time (not specified)

    // total volume size in blocks
    MakeDualEndian( pHeader +  80, 4, dwTotalImageBlocks );

    // volume set size (always 1)
    MakeDualEndian( pHeader + 120, 2, 1 );

    // volume sequence (always 1)
    MakeDualEndian( pHeader + 124, 2, 1 );

    // logical block size (2048 or 512)
    MakeDualEndian( pHeader + 128, 2, dwBlockSize );

    // path table size (in bytes [including terminating 0-byte?])
    MakeDualEndian( pHeader + 132, 4, dwLookupTableSize );

    ASSERT( dwStartingIsoPathTableBlock != 0 );

    dwBlock = dwStartingIsoPathTableBlock;

    // Type-L path table block location
    MakeLittleEndian( pHeader + 140, 4, dwBlock );
    dwBlock += CD_BLOCKS_FROM_SIZE( dwLookupTableAllocation );

    // Type-M path table block location
    MakeBigEndian( pHeader + 148, 4, dwBlock );
    dwBlock += CD_BLOCKS_FROM_SIZE( dwLookupTableAllocation );

    // Root directory "." entry gets copied at offset 156

    MakeRootEntry( pHeader + 156, pRootDir, 0 );

    HeaderWrite( SectorNumber * CD_SECTORSIZE, pHeader, CD_SECTORSIZE );

    }


void WriteJolietVolumeDescriptor( ULONG SectorNumber ) {

    PUCHAR pBuffer;
    DWORD  dwBlock;

    ASSERT( SectorNumber > 16 );

    pBuffer = AllocateBuffer( CD_SECTORSIZE, TRUE );

    pBuffer[   0 ] = 0x02;      // secondary volume descriptor
    pBuffer[   6 ] = 0x01;      // volume descriptor version
    pBuffer[ 881 ] = 0x01;      // file structure version

    memcpy(  pBuffer +   1, "CD001", 5 );

    memcpy(  pBuffer +  88, "%/E", 3 );                     // Joliet UCS-2 Level 3 escape sequence

    UniCopy( pBuffer +   8,  32, "" );
    UniCopy( pBuffer +  40,  32, chVolumeLabel );           // mixed case label
    UniCopy( pBuffer + 190, 128, chVolumeLabel );           // mixed case label
    UniCopy( pBuffer + 318, 128, "Microsoft Corporation" );
    UniCopy( pBuffer + 446, 128, "Microsoft Corporation, One Microsoft Way, Redmond WA 98052" );
    UniCopy( pBuffer + 574, 128, MAJOR_VERSION_TEXT " " MINOR_VERSION_TEXT );
    UniCopy( pBuffer + 702, 111, "" );

    memcpy(  pBuffer + 813, IsoVolumeCreationTime, 17 );    // volume creation time
    memcpy(  pBuffer + 830, "0000000000000000",    17 );    // last modification time (not specified)
    memcpy(  pBuffer + 847, "0000000000000000",    17 );    // expiration time (not specified)
    memcpy(  pBuffer + 864, "0000000000000000",    17 );    // effective time (not specified)

    // total volume size in blocks
    MakeDualEndian( pBuffer +  80, 4, dwTotalImageBlocks );

    // volume set size (always 1)
    MakeDualEndian( pBuffer + 120, 2, 1 );

    // volume sequence (always 1)
    MakeDualEndian( pBuffer + 124, 2, 1 );

    // logical block size (2048 or 512)
    MakeDualEndian( pBuffer + 128, 2, dwBlockSize );

    // path table size (in bytes [including terminating 0-byte?])
    MakeDualEndian( pBuffer + 132, 4, dwJolietLookupTableSize );

    ASSERT( dwStartingJolietPathTableBlock != 0 );

    dwBlock = dwStartingJolietPathTableBlock;

    // Type-L path table block location
    MakeLittleEndian( pBuffer + 140, 4, dwBlock );
    dwBlock += CD_BLOCKS_FROM_SIZE( dwJolietLookupTableAllocation );

    // Type-M path table block location
    MakeBigEndian( pBuffer + 148, 4, dwBlock );
    dwBlock += CD_BLOCKS_FROM_SIZE( dwJolietLookupTableAllocation );

    // Root directory "." entry gets copied at offset 156

    MakeJolietRootEntry( pBuffer + 156, pRootDir, 0 );

    HeaderWrite( SectorNumber * CD_SECTORSIZE, pBuffer, CD_SECTORSIZE );

    }


const unsigned char CompaqBootPatch[] = {
    0xFA, 0x33, 0xC0, 0x8E, 0xD0, 0xBC, 0x00, 0x7C, 0x8B, 0xF4, 0x8E, 0xC0,
    0x8E, 0xD8, 0xFB, 0xEB, 0x51, 0x43, 0x44, 0x2D, 0x52, 0x4F, 0x4D, 0x20,
    0x6E, 0x6F, 0x74, 0x20, 0x62, 0x6F, 0x6F, 0x74, 0x61, 0x62, 0x6C, 0x65,
    0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x73, 0x79, 0x73,
    0x74, 0x65, 0x6D, 0x2E, 0x52, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x20, 0x43,
    0x44, 0x2D, 0x52, 0x4F, 0x4D, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x70, 0x72,
    0x65, 0x73, 0x73, 0x20, 0x45, 0x4E, 0x54, 0x45, 0x52, 0x20, 0x6B, 0x65,
    0x79, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x69, 0x6E, 0x75,
    0x65, 0x2E, 0xBD, 0x11, 0x7C, 0xB4, 0x13, 0xB0, 0x00, 0xB9, 0x23, 0x00,
    0xB6, 0x00, 0xB2, 0x00, 0xB7, 0x00, 0xB3, 0x07, 0xCD, 0x10, 0xBD, 0x34,
    0x7C, 0xB4, 0x13, 0xB0, 0x00, 0xB9, 0x2E, 0x00, 0xB6, 0x01, 0xB2, 0x00,
    0xB7, 0x00, 0xB3, 0x07, 0xCD, 0x10, 0xB4, 0x00, 0xCD, 0x16, 0x3C, 0x00,
    0x74, 0xF8, 0x80, 0xFC, 0x1C, 0x75, 0xF3, 0xEA, 0xF0, 0xFF, 0x00, 0xF0
    };

//
//  The above 16-bit x86 code stream is produced from this code sequence:
//
//  .MODEL tiny
//  .DATA
//
//  .CODE
//  ORG 7C00h
//
//  Start:
//
//  CLI                                     ;Disable interrupts
//  XOR  AX,AX                              ;Initialize registers
//  MOV  SS,AX                              ;and segment pointers
//  MOV  SP,7C00h                           ;
//  MOV  SI,SP                              ;Setup stack at load point
//  MOV  ES,AX                              ;
//  MOV  DS,AX                              ;
//
//  STI                                     ;Enable interrupts
//
//  JMP CODE                                ;
//  BOOT_STRING  DB  'CD-ROM not bootable on this system.'
//  BOOT_STRING2 DB  'Remove CD-ROM and press ENTER key to continue.'
//
//  CODE:
//
//  MOV  BP,OFFSET BOOT_STRING              ;Setup string pointer for display
//  MOV  AH,13H                             ;Service
//  MOV  AL,0                               ;sub service
//  MOV  CX,35                              ;String size
//  MOV  DH,0                               ;Row
//  MOV  DL,0                               ;Collumn
//  MOV  BH,0                               ;Display Page
//  MOV  BL,07H                             ;Attribute
//
//  INT  10H                                ;
//
//  MOV  BP,OFFSET BOOT_STRING2             ;Setup string pointer for display
//  MOV  AH,13H                             ;Service
//  MOV  AL,0                               ;sub service
//  MOV  CX,46                              ;String size
//  MOV  DH,1                               ;Row
//  MOV  DL,0                               ;Collumn
//  MOV  BH,0                               ;Display Page
//  MOV  BL,07H                             ;Attribute
//
//  INT  10H                                ;
//
//  KEY_LOOP:
//  MOV AH,00H                              ;Service (Read next KeyChar)
//  INT 16H                                 ;Wait for key press
//  CMP AL,0H                               ;Check for extended scan code
//  JZ  KEY_LOOP                            ;
//  CMP AH,1CH                              ;If ENTER pressed...
//  JNZ KEY_LOOP                            ;
//                                          ;Reboot
//  DB  0EAH                                ;Far JMP
//  DW  0FFF0H,0F000H                       ;Offset:Segment
//
//  END Start
//


void WriteElToritoBootVolumeDescriptor( ULONG SectorNumber ) {

    PUCHAR pBuffer;

    ASSERT( SectorNumber == 17 );   // El Torito BVD must be at sector 17

    pBuffer = AllocateBuffer( CD_SECTORSIZE, TRUE );

    pBuffer[ 0 ] = 0x00;        // boot volume descriptor
    pBuffer[ 6 ] = 0x01;        // volume descriptor version

    memcpy( pBuffer + 1, "CD001", 5 );
    memcpy( pBuffer + 7, "EL TORITO SPECIFICATION", 23 );

    *(UNALIGNED DWORD*)( pBuffer + 0x47 ) = SECTOR_NUMBER_FROM_BLOCK_NUMBER( ElToritoBootCatalogBlock );

    //
    //  06/10/96  Compaq gave us this instruction stream to place at
    //            offset 512 in the El Torito BVD to prevent errant
    //            BIOS from locking up on CD-ROM boot and prompt user
    //            to remove CD before rebooting.
    //

    memcpy( pBuffer + 512, CompaqBootPatch, sizeof( CompaqBootPatch ));

    HeaderWrite( SectorNumber * CD_SECTORSIZE, pBuffer, CD_SECTORSIZE );

    }


void WriteVolumeDescriptorTerminator( ULONG SectorNumber ) {

    PUCHAR pBuffer;

    ASSERT( SectorNumber > 16 );

    pBuffer = AllocateBuffer( CD_SECTORSIZE, TRUE );

    pBuffer[ 0 ] = 0xFF;        // terminator volume descriptor
    pBuffer[ 6 ] = 0x01;        // volume descriptor version

    memcpy( pBuffer + 1, "CD001", 5 );

    if ( bCrcCorrectionInTvd ) {

        DWORD PartialCrc = Crc32( HeaderCrc, pBuffer, ( CD_SECTORSIZE - 4 ));

        *(UNALIGNED DWORD*)( pBuffer + ( CD_SECTORSIZE - 4 )) = PartialCrc;

        }

    HeaderWrite( SectorNumber * CD_SECTORSIZE, pBuffer, CD_SECTORSIZE );

    }


void WriteElToritoBootCatalog( ULONG SectorNumber ) {

    PUCHAR pBuffer;
    DWORD  CheckSum;
    BYTE   BootMediaType;
    WORD   BootSectorCount;
    ULONG  i;

    ASSERT( SectorNumber == SECTOR_NUMBER_FROM_BLOCK_NUMBER( ElToritoBootCatalogBlock ));

    pBuffer = AllocateBuffer( CD_SECTORSIZE, TRUE );

    //
    //  First 0x20 bytes is the validation entry
    //

    pBuffer[ 0x00 ] = 0x01;     // Validation Entry Header ID
    pBuffer[ 0x01 ] = 0x00;     // Platform ID = 80x86

    memcpy( pBuffer + 4, "Microsoft Corporation", 21 );

    pBuffer[ 0x1E ] = 0x55;     // key byte
    pBuffer[ 0x1F ] = 0xAA;     // key byte

    for ( CheckSum = 0, i = 0; i < 0x20; i += 2 ) {
        CheckSum += *(UNALIGNED WORD*)( pBuffer + i );
        }

    CheckSum = ( 0x10000 - ( CheckSum & 0xFFFF ));

    *(UNALIGNED WORD*)( pBuffer + 0x1C ) = (WORD)CheckSum;

#ifdef DEBUG

    //
    //  Verify checksum algorithm
    //

    for ( CheckSum = 0, i = 0; i < 0x20; i += 2 ) {
        CheckSum += *(UNALIGNED WORD*)( pBuffer + i );
        }

    ASSERT(( CheckSum & 0xFFFF ) == 0 );

#endif // DEBUG

    //
    //  Second 0x20 bytes is the initial/default entry.
    //

    //
    //  If ElToritoBootSectorFileSize is exactly the size of a floppy image,
    //  we'll assume that floppy emulation mode is desired and set the
    //  appropriate BootMediaType and set the BootSectorCount to 1.
    //  Otherwise, we assume the boot sector file is a "no emulation mode"
    //  boot loader program and load the whole file from the CD at boot time.
    //

    switch ( ElToritoBootSectorFileSize ) {
        case 1228800:
            BootMediaType   = 1;        //  1.2MB floppy
            BootSectorCount = 1;
            break;
        case 1474560:
            BootMediaType   = 2;        //  1.44MB floppy
            BootSectorCount = 1;
            break;
        case 2949120:
            BootMediaType   = 3;        //  2.88MB floppy
            BootSectorCount = 1;
            break;
        default:
            BootMediaType   = 0;        //  "no emulation" mode
            BootSectorCount = (WORD)( ROUNDUP2( ElToritoBootSectorFileSize, 0x200 ) / 0x200 );
            break;
        }

    pBuffer[ 0x20 ] = 0x88;             // Initial/Default Entry Boot Indicator
    pBuffer[ 0x21 ] = BootMediaType;

    // Load Segment (where to load in DOS memory).  If zero, loads at 0x07C0.

    *(UNALIGNED WORD*)(pBuffer + 0x22) = ElToritoLoadSegment;

    // Sector Count (number of 512-byte "virtual sectors" to load from CD):

    *(UNALIGNED WORD*)( pBuffer + 0x26 ) = BootSectorCount;

    // Load address (CD sector number) of boot sector file:

    *(UNALIGNED DWORD*)( pBuffer + 0x28 ) = SECTOR_NUMBER_FROM_BLOCK_NUMBER( ElToritoBootSectorBlock );

    HeaderWrite( SectorNumber * CD_SECTORSIZE, pBuffer, CD_SECTORSIZE );

    }


void WriteElToritoBootSector( ULONG SectorNumber ) {

    PUCHAR pBuffer;
    ULONG  AllocSize;

    AllocSize = ROUNDUP2( ElToritoBootSectorFileSize, CD_SECTORSIZE );

    pBuffer = AllocateBuffer( AllocSize, FALSE );

    CopyMemory( pBuffer, ElToritoBootSectorFileData, ElToritoBootSectorFileSize );

    if ( AllocSize > ElToritoBootSectorFileSize )
        ZeroMemory( pBuffer   + ElToritoBootSectorFileSize,
                    AllocSize - ElToritoBootSectorFileSize );

    HeaderWrite( SectorNumber * CD_SECTORSIZE, pBuffer, AllocSize );

    }


void CopyAndInvertUnicode( LPWSTR TargetBuffer, LPWSTR SourceBuffer, ULONG ByteCount ) {

    PUCHAR Target = (PUCHAR) TargetBuffer;
    PUCHAR Source = (PUCHAR) SourceBuffer;
    UCHAR Byte1, Byte2;

    ByteCount &= ~1;            // insure even

    while ( ByteCount ) {

        Byte1 = *Source++;
        Byte2 = *Source++;

        *Target++ = Byte2;
        *Target++ = Byte1;

        ByteCount -= 2;
        }
    }


void UniCopy( PUCHAR pDest, UINT uLength, LPSTR pSource ) {

    CHAR  AnsiBuffer[ 256 ];
    WCHAR UnicodeBuffer[ 128 ];
    PCHAR p, q;

    ASSERT( uLength < sizeof( AnsiBuffer ));
    ASSERT( strlen( pSource ) < sizeof( AnsiBuffer ));

    strcpy( AnsiBuffer, pSource );

    q = &AnsiBuffer[ uLength / 2 ];

    *q = 0;

    p = strchr( AnsiBuffer, 0 );

    while ( p < q )
        *p++ = ' ';

    AnsiToUnicode( AnsiBuffer, UnicodeBuffer );

    CopyAndInvertUnicode( (LPWSTR)pDest, UnicodeBuffer, uLength );

    }


void GenerateAndWriteJolietLookupTables( void ) {

    PUCHAR pL, pM, pLookupTableL, pLookupTableM;
    PUCHAR pBuffer;
    UINT uLevel, uLen;
    PDIRENTRY pDir;
    DWORD dwTableSize;
    DWORD dwCombinedTableSize;
    DWORDLONG dwlOffset;

    dwTableSize = dwJolietLookupTableAllocation;              // local copy

    ASSERT( ISALIGN2( dwTableSize, dwBlockSize ));

    //
    //  Note: Not sure if Joliet requires a type-M (big endian) path table,
    //  since all known Joliet systems at this time only use the type-L
    //  table, but since Joliet does not explicitly state the type-M table
    //  is optional, and ISO-9660's description of the SVD's type-M table
    //  (8.5.10) does not say the type-M table is optional, we'll always
    //  encode a type-M table even though it is a waste of space on the CD.
    //

    dwCombinedTableSize = dwTableSize * 2;

    pBuffer = AllocateBuffer( dwCombinedTableSize, TRUE );

    pL = pLookupTableL = pBuffer;                       // LittleEndian table
    pM = pLookupTableM = pBuffer + dwTableSize;         // BigEndian table

    //
    // root directory is odd, so do it separately, then start loop at level 1
    //

    *pL = 0x01;     // length of name
    *pM = 0x01;     // length of name

    MakeLittleEndian( pL + 2, 4, pRootDir->pDirectoryInfo->dwUnicodeBlock );
    MakeBigEndian(    pM + 2, 4, pRootDir->pDirectoryInfo->dwUnicodeBlock );

    ASSERT( pRootDir->pParentDir->pDirectoryInfo->dwUnicodeIndex != 0 );
    ASSERT( pRootDir->pParentDir->pDirectoryInfo->dwUnicodeIndex < 0x10000 );

    MakeLittleEndian( pL + 6, 2, pRootDir->pParentDir->pDirectoryInfo->dwUnicodeIndex );
    MakeBigEndian(    pM + 6, 2, pRootDir->pParentDir->pDirectoryInfo->dwUnicodeIndex );

    pL += 10;
    pM += 10;

    for ( uLevel = 1; pStartOfLevel[ uLevel ]; uLevel++ ) {
        for ( pDir = pStartOfLevel[ uLevel ]; pDir; pDir = pDir->pDirectoryInfo->pNextTargetDir ) {

            ASSERT( pDir->pDirectoryInfo != NULL );
            ASSERT( pDir->wUnicodeNameLength != 0 );

            uLen = (UINT) pDir->wUnicodeNameLength * 2;

            *pL = (UCHAR) uLen;
            *pM = (UCHAR) uLen;

            MakeLittleEndian( pL + 2, 4, pDir->pDirectoryInfo->dwUnicodeBlock );
            MakeBigEndian(    pM + 2, 4, pDir->pDirectoryInfo->dwUnicodeBlock );

            ASSERT( pDir->pParentDir->pDirectoryInfo->dwUnicodeIndex != 0 );
            ASSERT( pDir->pParentDir->pDirectoryInfo->dwUnicodeIndex < 0x10000 );

            MakeLittleEndian( pL + 6, 2, pDir->pParentDir->pDirectoryInfo->dwUnicodeIndex );
            MakeBigEndian(    pM + 6, 2, pDir->pParentDir->pDirectoryInfo->dwUnicodeIndex );

            //
            //  Both the L-path table and M-path table get a big-endian
            //  unicode name, so CopyAndInvert the name once into the
            //  L-path table, and then just memcpy to the M-path table.
            //

            CopyAndInvertUnicode( (LPWSTR)( pL + 8 ), pDir->pszUnicodeName, uLen );
            memcpy( pM + 8, pL + 8, uLen );

            pL += ( uLen + 8 ) + ( uLen & 1 );
            pM += ( uLen + 8 ) + ( uLen & 1 );

            ASSERT( pL < ( pLookupTableL + dwTableSize ));
            ASSERT( pM < ( pLookupTableM + dwTableSize ));  // redundant

            }
        }

    //
    //  Joliet lookup tables are written just behind the header blocks.
    //

    ASSERT( dwStartingJolietPathTableBlock != 0 );

    dwlOffset = (DWORDLONG)dwStartingJolietPathTableBlock * dwBlockSize;

    HeaderWrite( dwlOffset, pBuffer, dwCombinedTableSize );

    }


void WriteJolietDirectories( void ) {

    PDIRENTRY pDir, pFile;
    PUCHAR pBuffer, pMem, pBoundary;
    UINT uLevel, uNameLen, uEntryLen;
    DWORD dwDirAllocation;
    DWORDLONG dwlOffset;

    for ( uLevel = 0; pStartOfLevel[ uLevel ]; uLevel++ ) {
        for ( pDir = pStartOfLevel[ uLevel ]; pDir; pDir = pDir->pDirectoryInfo->pNextTargetDir ) {

            ASSERT( pDir->pDirectoryInfo != NULL );
            ASSERT( pDir->pDirectoryInfo->dwUnicodeDirSize != 0 );

            dwDirAllocation = ROUNDUP2( pDir->pDirectoryInfo->dwUnicodeDirSize, CD_SECTORSIZE );

            pBuffer = AllocateBuffer( dwDirAllocation, TRUE );

            pMem = MakeJolietRootEntries( pBuffer, pDir );

            pBoundary = pBuffer + CD_SECTORSIZE;

            //
            //  Note that MSCDEX will never read the Joliet namespace, so
            //  not necessary to avoid exactly aligned directory records
            //  at ends of sectors.
            //

            for ( pFile = pDir->pDirectoryInfo->pFirstTargetFile; pFile; pFile = pFile->pNextTargetFile ) {

                if ( ! ( pFile->dwFlags & NO_DIRENTRY )) {

                    ASSERT( pFile->wUnicodeNameLength != 0 );
                    ASSERT( pFile->dwlFileSize < 0x100000000 );

                    uNameLen   = (UINT) pFile->wUnicodeNameLength * 2;
                    uEntryLen  = uNameLen + 33;
                    uEntryLen += uEntryLen & 1;

                    if (( pMem + uEntryLen ) > pBoundary ) {
                        pMem = pBoundary;
                        pBoundary += CD_SECTORSIZE;
                        }

                    ASSERT(( pFile->dwUnicodeDirOffset == (DWORD)( pMem - pBuffer )) || ( bContinueAfterFailedSourceOpen ));
                    ASSERT(( pMem + uEntryLen ) < ( pBuffer + dwDirAllocation ));

                    *pMem = (UCHAR) uEntryLen;

                    if ( pFile->dwFlags & IS_HIDDEN ) {
                        *( pMem + 25 ) |= 0x01;
                        }

                    if ( pFile->dwFlags & IS_DIRECTORY ) {

                        *( pMem + 25 ) |= 0x02;

                        ASSERT( ! ( pFile->dwFlags & IS_DUPLICATE ));
                        ASSERT( pFile->pDirectoryInfo != NULL );
                        ASSERT( pFile->pDirectoryInfo->dwUnicodeBlock   != 0 );
                        ASSERT( pFile->pDirectoryInfo->dwUnicodeDirSize != 0 );

                        MakeDualEndian( pMem +  2, 4, pFile->pDirectoryInfo->dwUnicodeBlock );
                        MakeDualEndian( pMem + 10, 4, pFile->pDirectoryInfo->dwUnicodeDirSize );

                        }

                    else {

                        //
                        //  pFile->pDirectoryInfo and pFile->pPrimary share the
                        //  same address, so we can only assert that pDirectoryInfo
                        //  is NULL if not IS_DUPLICATE.
                        //

                        ASSERT(( pFile->dwFlags & IS_DUPLICATE ) || ( pFile->pDirectoryInfo == NULL ));
                        ASSERT(( pFile->dwlFileSize == 0 ) || ( pFile->dwStartingBlock != 0 ));

                        MakeDualEndian( pMem +  2, 4, pFile->dwStartingBlock );
                        MakeDualEndian( pMem + 10, 4, (DWORD)( pFile->dwlFileSize ));

                        }

                    *( pMem + 28 ) = 0x01;
                    *( pMem + 31 ) = 0x01;
                    *( pMem + 32 ) = (UCHAR) uNameLen;

                    if ( bUseGlobalTime )
                        memcpy( pMem + 18, cGlobalIsoTimeStamp, 6 );
                    else {
                        ASSERT( pFile->pFileTimeInfo != NULL );
                        MakeIsoTimeStampFromFileTime( pMem + 18, pFile->pFileTimeInfo->ftLastWriteTime );
                        }

                    CopyAndInvertUnicode( (LPWSTR)( pMem + 33 ), pFile->pszUnicodeName, uNameLen );

                    pMem += uEntryLen;

                    }

                else {

                    ASSERT(( pFile->dwFlags & NO_DIRENTRY ) && ( bContinueAfterFailedSourceOpen ));

                    }
                }

            dwlOffset = (DWORDLONG)( pDir->pDirectoryInfo->dwUnicodeBlock ) * dwBlockSize;

            ASSERT( IS_SECTOR_ALIGNED( dwlOffset ));

            HeaderWrite( dwlOffset, pBuffer, dwDirAllocation );

            }
        }
    }


BOOL StripDotsAndSpaces( LPSTR Buffer ) {

    LPSTR Source = Buffer;
    LPSTR Target = Buffer;
    BOOL  Modify = FALSE;
    CHAR ch;

    for (;;) {

        switch ( ch = *Source++ ) {

            case 0:

                *Target = 0;
                return Modify;

            case ' ':
            case '.':

                Modify = TRUE;
                break;

            default:

                *Target++ = ch;

            }
        }
    }


BOOL ReplaceNonIsoCharsWithUnderscore( LPSTR FileName ) {

    LPSTR NamePointer = FileName;
    BOOL Modify = FALSE;
    CHAR ch;

    while (( ch = *NamePointer ) != 0 ) {

        if ( ! ((( ch >= '0' ) && ( ch <= '9' )) ||
                (( ch >= 'A' ) && ( ch <= 'Z' )) ||
                (( ch == '_' )))) {

            *NamePointer = '_';
            Modify = TRUE;
            }

        ++NamePointer;

        }

    return Modify;
    }


BOOL __inline TruncateString( LPSTR String, ULONG Length ) {

    if ( strlen( String ) > Length ) {
        String[ Length ] = 0;
        return TRUE;
        }

    return FALSE;
    }


void GetStubFileContents( void ) {

    if ( *StubSourceFile ) {

        HANDLE hFile;
        DWORD  Actual;
        BOOL   Success;

        StubFileName = strrchr( StubSourceFile, '\\' );

        if ( StubFileName == NULL ) {
             StubFileName = strrchr( StubSourceFile, ':' );
             }

        if ( StubFileName == NULL ) {
             StubFileName = StubSourceFile;
             }
        else {
             StubFileName++;
             }

        hFile = CreateFile(
                    StubSourceFile,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );

        if ( hFile == INVALID_HANDLE_VALUE ) {

            ErrorExit(
                GETLASTERROR,
                "ERROR: Could not open stub file \"%s\"\r\n",
                StubSourceFile
                );
            }

        dwStubFileSize = GetFileSize( hFile, NULL );

        if ( dwStubFileSize == 0xFFFFFFFF ) {

            ErrorExit(
                GETLASTERROR,
                "ERROR: Could not determine stub file size \"%s\"\r\n",
                StubSourceFile
                );
            }

        if ( dwStubFileSize == 0 ) {

            ErrorExit(
                0,
                "ERROR: Stub file \"%s\" size is zero\r\n",
                StubSourceFile
                );
            }

        StubFileContents = MyAllocNeverFree( dwStubFileSize );

        Success = ReadFile(
                      hFile,
                      StubFileContents,
                      dwStubFileSize,
                      &Actual,
                      NULL
                      );

        if ( ! Success ) {

            ErrorExit(
                GETLASTERROR,
                "ERROR: Failure reading stub file \"%s\"\r\n",
                StubSourceFile
                );
            }

        if ( Actual != dwStubFileSize ) {

            ErrorExit(
                0,
                "ERROR: Failure reading stub file \"%s\"\r\n"
                "Actual bytes (%d) not equal to requested (%d)\r\n",
                StubSourceFile,
                Actual,
                dwStubFileSize
                );
            }

        GetFileTime( hFile, NULL, NULL, &ftStubTime );

        CloseHandle( hFile );

        _strupr( StubFileName );

        if ( ! IsValidDosName( StubFileName )) {
            ErrorExit(
                0,
                "ERROR: Stub file name \"%s\" is not DOS 8.3 compliant\r\n",
                StubFileName
                );
            }

        if ( ! IsValidIsoFileName( StubFileName )) {
            ErrorExit(
                0,
                "ERROR: Stub file name \"%s\" is not ISO-9660 compliant\r\n",
                StubFileName
                );
            }
        }

    else {

        StubFileName = "README.TXT";

        if ( bEncodeOnlyUdf ) {

            StubFileContents =
"This disc contains a \"UDF\" file system and requires an operating system\r\n"
"that supports the ISO-13346 \"UDF\" file system specification.\r\n";

            }

        else {

            StubFileContents =
"This disc contains Unicode file names and requires an operating system\r\n"
"that supports the ISO-9660 \"Joliet\" CD-ROM file system specification\r\n"
"such as Microsoft Windows 95 or Microsoft Windows NT 4.0.\r\n";

            }

        dwStubFileSize = strlen( StubFileContents );
        ftStubTime = ftGlobalFileTime;

        }
    }


void GenerateStubs( void ) {

    PDIRENTRY pStub = NewDirNode( FALSE );

    ASSERT(   StubFileName != NULL );
    ASSERT(  *StubFileName != 0 );
    ASSERT( dwStubFileSize != 0 );
    ASSERT( StubFileContents != NULL );

    pStub->pszFileName     = StubFileName;
    pStub->wFileNameLength = (WORD)strlen( StubFileName );
    pStub->dwlFileSize     = dwStubFileSize;
    pStub->pParentDir      = pRootDir;

    if ( pStub->pFileTimeInfo ) {
         pStub->pFileTimeInfo->ftLastWriteTime  = ftStubTime;
         pStub->pFileTimeInfo->ftLastAccessTime = ftStubTime;
         pStub->pFileTimeInfo->ftCreationTime   = ftStubTime;
         }

    pRootDir->pDirectoryInfo->pAlternateFirstFile = pStub;

    pAlternateStartOfLevel[ 0 ] = pRootDir;

    }


void GenerateShortNames( void ) {

    pRootDir->pDirectoryInfo->pAlternateFirstFile = RecursiveGenerateShortNames( pRootDir );

    LinkAlternateDirectories( pRootDir, 0 );

    }


PDIRENTRY RecursiveGenerateShortNames( PDIRENTRY pParentDir ) {

    PDIRENTRY pFile, pFirst;

    ASSERT( pParentDir->pDirectoryInfo != NULL );
    ASSERT( pParentDir->pDirectoryInfo->pAlternateFirstFile == NULL );

    pFirst = NULL;

    for ( pFile = pParentDir->pDirectoryInfo->pFirstTargetFile; pFile; pFile = pFile->pNextTargetFile ) {

        pFirst = GenerateAndInsertShortName( pFirst, pFile );

        if ( pFile->dwFlags & IS_DIRECTORY ) {

            ASSERT( pFile->pDirectoryInfo != NULL );
            ASSERT( pFile->pDirectoryInfo->pAlternateFirstFile == NULL );

            pFile->pDirectoryInfo->pAlternateFirstFile = RecursiveGenerateShortNames( pFile );

            }
        }

    ASSERT( pParentDir->pDirectoryInfo->pAlternateFirstFile == NULL );

    return pFirst;
    }


UINT DecimalDigitsInInteger( UINT Integer ) {

    return (( Integer <         10 ) ? 1 :
            ( Integer <        100 ) ? 2 :
            ( Integer <       1000 ) ? 3 :
            ( Integer <      10000 ) ? 4 :
            ( Integer <     100000 ) ? 5 :
            ( Integer <    1000000 ) ? 6 :
            ( Integer <   10000000 ) ? 7 :
            ( Integer <  100000000 ) ? 8 :
            ( Integer < 1000000000 ) ? 9 : 10 );
    }

VOID GenerateShortNameForFile( PDIRENTRY pNewFile, LPSTR ShortName , UINT UniqueNumber) {

    CHAR AnsiName[ MAX_NAME_LENGTH ];
    LPSTR Extension;
    LPSTR End;
    BOOL bModified = FALSE;
    UINT AnsiLength;
    UINT Digits;
    UINT Index;

    //
    //  All the generated names in this directory must be unique.
    //

    ASSERT( pNewFile->pszFileName    == NULL );
    ASSERT( pNewFile->pszUnicodeName != NULL );

    UnicodeToAnsi( pNewFile->pszUnicodeName, AnsiName );

    if ( pNewFile->dwFlags & IS_DIRECTORY ) {

        //
        //  Directories can't have extensions.
        //

        Extension = NULL;
        }

    else {

        //
        //  Find extension separator (last dot) and break name
        //  into base and extension by writing a terminator over
        //  the separator.
        //

        Extension = strrchr( AnsiName, '.' );

        if ( Extension != NULL ) {

            *Extension++ = 0;

            StripDotsAndSpaces( Extension );

            TruncateString( Extension, 3 );

            strupr( Extension );

            ReplaceNonIsoCharsWithUnderscore( Extension );

            }
        }

    StripDotsAndSpaces( AnsiName );

    TruncateString( AnsiName, 8 );

    strupr( AnsiName );

    ReplaceNonIsoCharsWithUnderscore( AnsiName );

    AnsiLength = strlen( AnsiName );

    if ( AnsiLength == 0 )
        bModified = TRUE;

    memcpy( ShortName, AnsiName, AnsiLength + 1 );

    if ( bModified || (1 != UniqueNumber))
    {

        // this limits us to 10 million files w/ generated short names if fast generate short names is on

        Digits = DecimalDigitsInInteger( UniqueNumber );

        if ( Digits > 7 ) {
            ErrorExit(
                0,
                "ERROR: Unable to generate unique short name for %S\r\n",
                pNewFile->pszUnicodeName
                );
            }

        Index = AnsiLength;

        if (( Index + Digits ) > 7 ) {
            Index = 7 - Digits;
            }

        sprintf( ShortName + Index, "_%d", UniqueNumber++ );
    }

    if ( Extension ) {

        *( End = strchr( ShortName, 0 )) = '.';
        strcpy( End + 1, Extension );

        }
    }

PDIRENTRY GenerateAndInsertShortName( PDIRENTRY pFirstFile, PDIRENTRY pNewFile )
    {
    PDIRENTRY pPrev, pNext, pReturn;
    INT iCmp;
    CHAR ShortName[ 8 + 3 + 1 + 1 ];
    static UINT UniqueNumber = 1;
    UINT Length;

    //
    //  Since we the generated file name is an ISO-9660 character set name,
    //  we can assume the period is sorted lower than any other character,
    //  so we don't have to replace it for sorting purposes.
    //

    if(!bFastShortNameGeneration)
    {
        UniqueNumber = 1;
    }

    ASSERT(NULL != pNewFile);

    pPrev = NULL;
    pNext = pFirstFile;

    // get the short file name
    GenerateShortNameForFile(pNewFile, ShortName, UniqueNumber++ );
    ASSERT( strlen( ShortName ) > 0 );

    while(NULL != pNext)
    {

        iCmp = strcmp( ShortName, pNext->pszFileName );

        // do we have a collision
        if(0 == iCmp)
        {
            // get a new short file name
            GenerateShortNameForFile(pNewFile, ShortName, UniqueNumber++ );
            ASSERT( strlen( ShortName ) > 0 );

            // do I need to start at the beginning again?
            if(pPrev != NULL)
            {
                // our current position in the list may be invalidated, due to
                // short name generation
                if(strcmp( ShortName, pPrev->pszFileName ) < 0)
                {
                    // reset pointers and loop
                    pPrev = NULL;
                    pNext = pFirstFile;
                }
            }
        }
        else
        {
            // no collision

            // does it fit between the prev & next nodes?
            if ( iCmp < 0 )
            {
                break;          // insert here
            }

            // get ready for next loop
            pPrev = pNext;
            pNext = pNext->pAlternateNextFile;
        }
    }

    // we know where to insert the node, so stick it in
    pNewFile->pAlternateNextFile = pNext;

    if ( pPrev == NULL )
    {
        // list is empty or this node is supposed to go first
        pReturn = pNewFile;
    }
    else
    {
        // it goes in the middle/end of the list

        pNext = pPrev->pAlternateNextFile;

        pPrev->pAlternateNextFile = pNewFile;

        pReturn = pFirstFile;
    }

    // allocate & store the short file name in the node
    ASSERT( pNewFile->pszFileName == NULL );

    Length = strlen( ShortName );
    pNewFile->pszFileName = MyAllocNeverFree( Length + 1 );
    memcpy( pNewFile->pszFileName, ShortName, Length );

    pNewFile->wFileNameLength = (WORD)Length;

    ASSERT( bOptimizeFileNames );       // assume no trailing dot or ";1"

    // return the head node (which might have changed)
    return pReturn;

    }

void LinkAlternateDirectories( PDIRENTRY pDirNode, UINT uLevel ) {

    PDIRENTRY p;

    ASSERT( uLevel < MAX_LEVELS );

    if (( bReportExceedLevels ) && ( uLevel >= 8 )) {
        printf( "\r\nWARNING: Non-ISO directory depth exceeds 8 levels: \"%s\"\r\n",
                GenerateFullName( pDirNode, ReportNameBuffer.A ));
        fflush( stdout );
        }

    p = pAlternateStartOfLevel[ uLevel ];

    if ( p == NULL )
        pAlternateStartOfLevel[ uLevel ] = pDirNode;
    else {
        ASSERT( p->pDirectoryInfo != NULL );
        while ( p->pDirectoryInfo->pAlternateNextDir != NULL ) {
            p = p->pDirectoryInfo->pAlternateNextDir;
            ASSERT( p->pDirectoryInfo != NULL );
            }
        p->pDirectoryInfo->pAlternateNextDir = pDirNode;
        }

    for ( p = pDirNode->pDirectoryInfo->pAlternateFirstFile;
          p != NULL;
          p = p->pAlternateNextFile ) {

          if ( p->dwFlags & IS_DIRECTORY ) {
              ASSERT( p->pDirectoryInfo != NULL );
              LinkAlternateDirectories( p, uLevel + 1 );
              }
          }
    }


void WriteStubs( void ) {

    DWORD     dwAlloc   = ROUNDUP2( dwStubFileSize, dwBlockSize );
    PUCHAR    pBuffer   = AllocateBuffer( dwAlloc, TRUE );
    DWORDLONG dwlOffset = (DWORDLONG) dwStubFileBlock * dwBlockSize;

    CopyMemory( pBuffer, StubFileContents, dwStubFileSize );

    HeaderWrite( dwlOffset, pBuffer, dwAlloc );

    ASSERT( ROUNDUP2_64( dwlOffset + dwAlloc, CD_SECTORSIZE ) == ((DWORDLONG)dwStartingJolietDirectoryBlock * dwBlockSize ));

    }


#ifdef DONTCOMPILE


void ShowIsoTreeRecursive( PDIRENTRY pFirstNode, UINT uLevel ) {

    PDIRENTRY p;

    for ( p = pFirstNode; p != NULL; p = p->pNextTargetFile ) {

        ASSERT( p->pszFileName != NULL );

#ifdef SHOW_EACH_ENTRY

        printf(
            "%*s%s\r\n",
            uLevel * 2,
            "",
            p->pszFileName
            );

#endif

        #error "files and dirs have different rounding"

        if ( ! ( p->dwFlags & IS_DUPLICATE ))
            dwlShowTreeAlloc += ROUNDUP2_64( p->dwlFileSize, dwBlockSize )
                              + p->pDirectoryInfo ?
                                    ROUNDUP2( p->pDirectoryInfo->dwUnicodeDirSize, CD_SECTORSIZE ) :
                                    0;

        if ( p->dwFlags & IS_DIRECTORY )
            ShowIsoTreeRecursive( p->pDirectoryInfo->pFirstTargetFile, uLevel + 1 );

        }

    }


void ShowJolietTreeRecursive( PDIRENTRY pFirstNode, UINT uLevel ) {

    PDIRENTRY p;

    for ( p = pFirstNode; p != NULL; p = p->pNextTargetFile ) {

        ASSERT( p->pszUnicodeName != NULL );

#ifdef SHOW_EACH_ENTRY

        printf(
            "%*s%S\r\n",
            uLevel * 2,
            "",
            p->pszUnicodeName
            );

#endif

        #error "files and dirs have different rounding"

        if ( ! ( p->dwFlags & IS_DUPLICATE ))
            dwlShowTreeAlloc += ROUNDUP2_64( p->dwlFileSize, CD_SECTORSIZE )
                              + p->pDirectoryInfo ?
                                    ROUNDUP2( p->pDirectoryInfo->dwUnicodeDirSize, CD_SECTORSIZE ) :
                                    0;

        if ( p->dwFlags & IS_DIRECTORY )
            ShowJolietTreeRecursive( p->pDirectoryInfo->pFirstTargetFile, uLevel + 1 );

        }
    }


void ShowAlternateTreeRecursive( PDIRENTRY pFirstNode, UINT uLevel ) {

    PDIRENTRY p;

    for ( p = pFirstNode; p != NULL; p = p->pAlternateNextFile ) {

        ASSERT( p->pszFileName != NULL );

#ifdef SHOW_EACH_ENTRY

        printf(
            "%*s%s\r\n",
            uLevel * 2,
            "",
            p->pszFileName
            );

#endif

        #error "files and dirs have different rounding"

        if ( ! ( p->dwFlags & IS_DUPLICATE ))
            dwlShowTreeAlloc += ROUNDUP2_64( p->dwlFileSize, CD_SECTORSIZE )
                              + p->pDirectoryInfo ?
                                    ROUNDUP2( p->pDirectoryInfo->dwUnicodeDirSize, CD_SECTORSIZE ) :
                                    0;

        if ( p->dwFlags & IS_DIRECTORY )
            ShowAlternateTreeRecursive( p->pDirectoryInfo->pAlternateFirstFile, uLevel + 1 );

        }
    }



void ShowIsoTree( void ) {

    dwlShowTreeAlloc = 0;

    ShowIsoTreeRecursive( pRootDir, 0 );

    printf( "Total Iso allocation is %I64d\r\n", dwlShowTreeAlloc );

    }


void ShowJolietTree( void ) {

    dwlShowTreeAlloc = 0;

    ShowJolietTreeRecursive( pRootDir, 0 );

    printf( "Total Joliet allocation is %I64d\r\n", dwlShowTreeAlloc );

    }


void ShowAlternateTree( void ) {

    dwlShowTreeAlloc = 0;

    ShowAlternateTreeRecursive( pRootDir, 0 );

    printf( "Total Alternate allocation is %I64d\r\n", dwlShowTreeAlloc );

    }


#endif // DONTCOMPILE


PDIRENTRY
StartRecursiveDescent(
    VOID
    )
    {
    ULONG NameLength = strlen( szRootPath );
    PDIRENTRY Return;
    HANDLE hFind;

    memcpy( DescentNameBuffer.A, szRootPath, NameLength );

    DescentNameBuffer.A[ NameLength     ] = '*';    // append "*" to DescentNameBuffer
    DescentNameBuffer.A[ NameLength + 1 ] = 0;      // terminate the string

    hFind = FindFirstFileA( DescentNameBuffer.A, &FindData.A );

    if ( hFind == INVALID_HANDLE_VALUE ) {
        ErrorExit(
            GETLASTERROR,
            "ERROR: Failure enumerating files in directory \"%s\"\r\n",
            szRootPath
            );
        }

    FindClose( hFind );

    DescentNameBuffer.A[ NameLength ] = 0;      // chop off the trailing "*"

    Return = RecursiveDescent(
                    pRootDir,
                    DescentNameBuffer.A + NameLength,
                    1,  // depth of root directory
                    1   // name length of root directory
                    );

    return Return;
    }


PDIRENTRY
RecursiveDescent(
    PDIRENTRY pParentDir,
    LPSTR     DescentBufferPointer,
    ULONG     Depth,
    ULONG     NameLengthOfParents
    )
    {
    PDIRENTRY pFirstNode, pNewNode;
    PCHAR     pFindName;
    ULONG     NameLength;
    ULONG     AllocLength;
    BOOL      IsDirectory;
    HANDLE    hFind;
    DWORDLONG dwlFileSize;

    IncrementTotalNumberOfDirectories();

    pFirstNode = NULL;

    *( DescentBufferPointer + 0 ) = '*';    // append "*" to DescentNameBuffer
    *( DescentBufferPointer + 1 ) = 0;      // terminate string

    hFind = FindFirstFileA( DescentNameBuffer.A, &FindData.A );

    if ( hFind == INVALID_HANDLE_VALUE ) {

        if ( GetLastError() == ERROR_PATH_NOT_FOUND ) {

            WarnFailedSourceOpen(
                0,
                "Failure enumerating files in directory \"%s\"\r\n"
                "The specific error code (path not found) could indicate that the directory\r\n"
                "was deleted by another process during the directory scan, or it could indicate\r\n"
                "that the directory name contains some Unicode characters that do not have a\r\n"
                "corresponding %s character mapping (try %susing -c, or use -j1 or -j2 for\r\n"
                "full Unicode names)\r\n",
                GenerateFullNameSource( pParentDir, ReportNameBuffer.A ),
                bUseAnsiFileNames ? "ANSI" : "OEM",
                bUseAnsiFileNames ? "not " : ""
                );
            }

        else if ( GetLastError() != ERROR_FILE_NOT_FOUND ) {

            WarnFailedSourceOpen(
                GETLASTERROR,
                "Failure enumerating files in directory \"%s\"\r\n",
                GenerateFullNameSource( pParentDir, ReportNameBuffer.A )
                );
            }

        return NULL;
        }

    *( DescentBufferPointer + 0 ) = 0;      // restore DescentNameBuffer

    do {

        if ((( ! ( FindData.A.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN )) ||
             ( bHiddenFiles )) &&
            ( ! ( IsFileNameDotOrDotDot( FindData.A.cFileName )))) {

            IsDirectory = ( FindData.A.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) ? TRUE : FALSE;

            pNewNode = NewDirNode( IsDirectory );

            if ( FindData.A.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN ) {
                pNewNode->dwFlags |= IS_HIDDEN;
                }

            pNewNode->pParentDir = pParentDir;

            if ( pNewNode->pFileTimeInfo ) {
                 pNewNode->pFileTimeInfo->ftLastWriteTime  = FindData.A.ftLastWriteTime;
                 pNewNode->pFileTimeInfo->ftLastAccessTime = FindData.A.ftLastAccessTime;
                 pNewNode->pFileTimeInfo->ftCreationTime   = FindData.A.ftCreationTime;
                 }

            //
            //  In Win32/NT, there is only an AlternateFileName iff
            //  the regular filename is not FAT-compatible, either
            //  because of filename length, or invalid FAT characters.
            //
            //  ISO allows up to 30 characters (31 with the dot), but
            //  we'll also take up to 221 characters (maximum encodable
            //  length) if bAllowLongNames is specified.
            //

            if ( *FindData.A.cAlternateFileName != 0 ) {
                pNewNode->dwFlags |= CHECK_SHORTNAME;
                }

            if (( ! bDontUpcase ) || ( bRestrictToNt3xCompatibleNames )) {
                strupr( FindData.A.cFileName );
                }

            if ( ! bAllowLongNames ) {

                BOOL ShortNameExists = ( *FindData.A.cAlternateFileName != 0 );
                BOOL LongNameIs8Dot3 = IsAcceptableDosName( FindData.A.cFileName );

                if ( ShortNameExists ) {

                    //
                    //  Test that underlying operating system is not generating
                    //  short names for names that don't need short names.
                    //  There is a bug in NT 4.0 CDFS that will generate short
                    //  names unnecessarily.
                    //

                    if ( LongNameIs8Dot3 ) {
                        *FindData.A.cAlternateFileName = 0;
                        }
                    }

                else {

                    //
                    //  Test that the underlying operating system is generating
                    //  short names for unacceptable DOS filenames.  There is a
                    //  registry setting in NT that will cause NTFS to not
                    //  generate short names and we need to blow up if that is
                    //  happening.
                    //

                    if ( ! LongNameIs8Dot3 ) {

                        WarnFailedSourceOpen(
                            0,
                            "Long %sname with no 8.3 shortname provided by file system:\r\n"
                            "\"%s%s\"\r\n",
                            IsDirectory ? "directory " : "file",
                            GenerateFullNameSource( pParentDir, ReportNameBuffer.A ),
                            FindData.A.cFileName
                            );

                        continue;
                        }
                    }
                }


            pFindName  = (PCHAR)&FindData.A.cFileName;
            NameLength = EncodingNameLength( pFindName, IsDirectory );

            if (( *FindData.A.cAlternateFileName != 0 ) &&
                (( NameLength > 221 ) ||
                 (( ! bAllowLongNames ) &&
                  ( ! IsValidDosName( pFindName ))) ||
                 (( bRestrictToNt3xCompatibleNames ) &&
                  ((( IsDirectory ) &&
                    ( ! IsValidNt3xCompatibleDirectoryName( pFindName ))) ||
                   (( ! IsDirectory ) &&
                    ( ! IsValidNt3xCompatibleFileName( pFindName ))))))) {

                //
                //  Use alternate filename
                //

                if (( ! bDontUpcase ) || ( bRestrictToNt3xCompatibleNames )) {
                    strupr( FindData.A.cAlternateFileName );
                    }

                pFindName  = (PCHAR)&FindData.A.cAlternateFileName;
                NameLength = EncodingNameLength( pFindName, IsDirectory );

                printf(
                    "\r\n%60s\r\nWARNING: Using alternate %sname \"%s\" for \"%s\\%s\"\r\n",
                    "",
                    IsDirectory ? "directory " : "file",
                    FindData.A.cAlternateFileName,
                    GenerateFullName( pParentDir, ReportNameBuffer.A ),
                    FindData.A.cFileName
                    );
                fflush( stdout );

                }

            if ( NameLength > 221 ) {

                WarnFailedSourceOpen(
                    0,
                    "%sname \"%s\\%s\" is longer than 221 characters\r\n",
                    IsDirectory ? "Directory " : "File",
                    GenerateFullName( pParentDir, ReportNameBuffer.A ),
                    pFindName
                    );

                continue;
                }

            if ( strchr( pFindName, ';' )) {

                WarnFailedSourceOpen(
                    0,
                    "%sname \"%s\\%s\" contains a semicolon which has special meaning on ISO-9660 CD-ROMs\r\n",
                    IsDirectory ? "Directory " : "File",
                    GenerateFullName( pParentDir, ReportNameBuffer.A ),
                    pFindName
                    );

                continue;
                }

            if ((   bAllowLongNames                 ) &&
                ( ! bRestrictToNt3xCompatibleNames  ) &&
                ( ! bViolatesNt3xCompatibility      )) {

                if (((   IsDirectory ) && ( ! IsValidNt3xCompatibleDirectoryName( pFindName ))) ||
                    (( ! IsDirectory ) && ( ! IsValidNt3xCompatibleFileName( pFindName )))) {

                    bViolatesNt3xCompatibility = TRUE;

                    }
                }

            if ( IsDirectory || bOptimizeFileNames )
                AllocLength = NameLength + 1;   // terminator
            else
                AllocLength = NameLength - 1;   // terminator minus ";1"

            ASSERT( NameLength != 0 );
            ASSERT( NameLength < 65535 );

            pNewNode->wFileNameLength = (WORD)NameLength;
            pNewNode->pszFileName  = MyAllocNeverFree( AllocLength );

            strcpy( pNewNode->pszFileName, pFindName );

            pFirstNode = AlphabeticalInsertNode( pFirstNode, pNewNode );

            if (( bReportExceedLevels ) &&
                (( NameLengthOfParents + NameLength + Depth ) > 255 )) {

                printf( "\r\n%60s\r\nWARNING: Non-ISO directory depth exceeds 255 characters: \"%s\"\r\n",
                        "",
                        GenerateFullName( pNewNode, ReportNameBuffer.A ));
                fflush( stdout );
                }

            if ( IsDirectory ) {

                if (( bReportExceedLevels ) && ( Depth >= 8 )) {

                    printf( "\r\n%60s\r\nWARNING: Non-ISO directory depth exceeds 8 levels: \"%s\"\r\n",
                            "",
                            GenerateFullName( pNewNode, ReportNameBuffer.A ));
                    fflush( stdout );
                    }

                if (( bReportInvalidDosNames ) && ( ! IsValidDosName( pNewNode->pszFileName ))) {

                    printf( "\r\n%60s\r\nWARNING: Non-DOS directory name: \"%s\"\r\n",
                            "",
                            GenerateFullName( pNewNode, ReportNameBuffer.A ));
                    fflush( stdout );
                    }

                if (( bReportInvalidIsoNames ) && ( ! IsValidIsoDirectoryName( pNewNode->pszFileName ))) {

                    printf( "\r\n%60s\r\nWARNING: Non-ISO directory name: \"%s\"\r\n",
                            "",
                            GenerateFullName( pNewNode, ReportNameBuffer.A ));
                    fflush( stdout );
                    }

                if (( bHackI386Directory ) && ( ! pHackI386Directory )) {
                    if (( pParentDir == pRootDir ) && ( stricmp( pNewNode->pszFileName, "i386" ) == 0 )) {
                        pHackI386Directory = pNewNode;
                        }
                    }
                }

            else {      //  this is a file, not a directory

                if (( bReportInvalidDosNames ) && ( ! IsValidDosName( pNewNode->pszFileName ))) {

                    printf( "\r\n%60s\r\nWARNING: Non-DOS filename: \"%s\"\r\n",
                            "",
                            GenerateFullName( pNewNode, ReportNameBuffer.A ));
                    fflush( stdout );
                    }

                if (( bReportInvalidIsoNames ) && ( ! IsValidIsoFileName( pNewNode->pszFileName ))) {

                    printf( "\r\n%60s\r\nWARNING: Non-ISO filename: \"%s\"\r\n",
                            "",
                            GenerateFullName( pNewNode, ReportNameBuffer.A ));
                    fflush( stdout );
                    }

                dwlFileSize = ((DWORDLONG)( FindData.A.nFileSizeHigh ) << 32 )
                                          | FindData.A.nFileSizeLow;

                if ( dwlFileSize > 0xFFFFFFFF ) {
                    ErrorExit(
                        0,
                        "ERROR: File larger than 4GB: \"%s\"\r\n",
                        GenerateFullName( pNewNode, ReportNameBuffer.A )
                        );
                    }

                if (( bReportZeroLength ) && ( dwlFileSize == 0 )) {
                    printf( "\r\n%60s\r\nWARNING: File \"%s\" is 0-length.\r\n",
                            "",
                            GenerateFullName( pNewNode, ReportNameBuffer.A ));
                    fflush( stdout );
                    }

                pNewNode->dwlFileSize = dwlFileSize;

                dwTotalFileBlocks += CD_BLOCKS_FROM_SIZE( dwlFileSize );
                dwlTotalFileSizes += dwlFileSize;

                IncrementTotalNumberOfFiles();

                if ( ! bOptimizeFileNames ) {

                    //
                    //  If no dot already in filename, append trailing dot.
                    //  Note the space has already been allocated for this
                    //  via EncodingNameLength() calculation.
                    //

                    if ( ! strchr( pNewNode->pszFileName, '.' )) {
                        strcat( pNewNode->pszFileName, "." );
                        }
                    }
                }
            }
        }

    while ( FindNextFile( hFind, &FindData.A ));

    if ( GetLastError() != ERROR_NO_MORE_FILES ) {
        WarnFailedSourceOpen(
            GETLASTERROR,
            "Failure enumerating files in directory \"%s\"\r\n",
            GenerateFullNameSource( pParentDir, ReportNameBuffer.A )
            );
        }

    FindClose( hFind );

    for ( pNewNode  = pFirstNode;
          pNewNode != NULL;
          pNewNode  = pNewNode->pNextTargetFile ) {

        if ( pNewNode->dwFlags & IS_DIRECTORY ) {

            ASSERT( pNewNode->pDirectoryInfo != NULL );

            NameLength = strlen( pNewNode->pszFileName );

            memcpy( DescentBufferPointer, pNewNode->pszFileName, NameLength );

            *( DescentBufferPointer + NameLength     ) = '\\';  // append backslash
            *( DescentBufferPointer + NameLength + 1 ) = 0;     // terminate

            pNewNode->pDirectoryInfo->pFirstTargetFile =
                RecursiveDescent(
                    pNewNode,
                    DescentBufferPointer + NameLength + 1,
                    Depth + 1,
                    NameLengthOfParents + NameLength
                    );

            }
        }

    return pFirstNode;

    }


BOOL IsValidJolietFileName( LPWSTR FileName ) {

    //
    //  Only looking for invalid characters, not invalid length.
    //

    WCHAR c;

    while (( c = *FileName++ ) != 0 ) {

        if (( c  < 0x0020 ) ||      // control characters
            ( c == 0x002A ) ||      // '*' (asterisk)
            ( c == 0x002F ) ||      // '/' (slash)
            ( c == 0x003A ) ||      // ':' (colon)
            ( c == 0x003B ) ||      // ';' (semicolon)
            ( c == 0x003F ) ||      // '?' (question)
            ( c == 0x005C )) {      // '\' (backslash)

            return FALSE;

            }
        }

    return TRUE;
    }


PDIRENTRY
StartRecursiveDescentJoliet(
    VOID
    )
    {
    ULONG NameLength = lstrlenW( UnicodeRootPath );

    memcpy( DescentNameBuffer.W, UnicodeRootPath, ( NameLength + 1 ) * 2 );

    return RecursiveDescentJoliet(
                pRootDir,
                DescentNameBuffer.W + NameLength,
                1,  // depth of root directory
                1   // name length of root directory (in bytes)
                );
    }


PDIRENTRY
RecursiveDescentJoliet(
    PDIRENTRY pParentDir,
    LPWSTR    DescentBufferPointer,
    ULONG     Depth,
    ULONG     NameLengthOfParents
    )
    {
    PDIRENTRY pFirstNode, pNewNode;
    ULONG     NameLength;
    BOOL      IsDirectory;
    HANDLE    hFind;
    DWORDLONG dwlFileSize;

    IncrementTotalNumberOfDirectories();

    pFirstNode = NULL;

    *( DescentBufferPointer + 0 ) = L'*';   // append "*" to DescentNameBuffer
    *( DescentBufferPointer + 1 ) = 0;      // terminate string

    hFind = FindFirstFileW( DescentNameBuffer.W, &FindData.W );

    if ( hFind == INVALID_HANDLE_VALUE ) {
        if ( GetLastError() != ERROR_FILE_NOT_FOUND ) {
            WarnFailedSourceOpen(
                GETLASTERROR,
                "Failure enumerating files in directory \"%S\"\r\n",
                GenerateFullNameSourceW( pParentDir, ReportNameBuffer.W )
                );
            }
        return NULL;
        }

    *( DescentBufferPointer + 0 ) = 0;      // restore DescentNameBuffer

    do {

        if ((( ! ( FindData.W.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN )) ||
             ( bHiddenFiles )) &&
            ( ! ( IsFileNameDotOrDotDotW( FindData.W.cFileName )))) {

            IsDirectory = ( FindData.W.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) ? TRUE : FALSE;

            pNewNode = NewDirNode( IsDirectory );

            if ( FindData.W.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN ) {
                pNewNode->dwFlags |= IS_HIDDEN;
                }

            if ( *FindData.W.cAlternateFileName != 0 ) {
                pNewNode->dwFlags |= CHECK_SHORTNAME;
                }

            pNewNode->pParentDir = pParentDir;

            if ( pNewNode->pFileTimeInfo ) {
                 pNewNode->pFileTimeInfo->ftLastWriteTime  = FindData.W.ftLastWriteTime;
                 pNewNode->pFileTimeInfo->ftLastAccessTime = FindData.W.ftLastAccessTime;
                 pNewNode->pFileTimeInfo->ftCreationTime   = FindData.W.ftCreationTime;
                 }

            NameLength = lstrlenW( FindData.W.cFileName );

            if ( ! bEncodeOnlyUdf ) {

                if ( NameLength > 110 ) {

                    WarnFailedSourceOpen(
                        0,
                        "Unicode %sname \"%S\\%S\" is longer than 110 characters\r\n",
                        IsDirectory ? "directory " : "file",
                        GenerateFullNameW( pParentDir, ReportNameBuffer.W ),
                        FindData.W.cFileName
                        );

                    continue;
                    }

                if ( wcschr( FindData.W.cFileName, L';' )) {

                    WarnFailedSourceOpen(
                        0,
                        "Unicode %sname \"%S\\%S\" contains a semicolon which has special meaning on ISO-9660 CD-ROMS\r\n",
                        IsDirectory ? "directory " : "file",
                        GenerateFullNameW( pParentDir, ReportNameBuffer.W ),
                        FindData.W.cFileName
                        );

                    continue;
                    }
                }


            ASSERT( NameLength < 65535 );

            pNewNode->wUnicodeNameLength = (WORD)NameLength;
            pNewNode->pszUnicodeName = MyAllocNeverFree(( NameLength + 1 ) * 2 );

            lstrcpyW( pNewNode->pszUnicodeName, FindData.W.cFileName );
			//printf("[%ls]\r\n", pNewNode->pszUnicodeName);

            pFirstNode = JolietInsertNode( pFirstNode, pNewNode );

            if ( ! bEncodeOnlyUdf ) {

                if (( bReportInvalidIsoNames ) && ( NameLength > 64 )) {

                    printf( "\r\n%60s\r\nWARNING: Joliet unicode %sname exceeds 128 bytes: \"%S\"\r\n",
                            "",
                            IsDirectory ? "directory " : "file",
                            GenerateFullNameW( pNewNode, ReportNameBuffer.W ));
                    fflush( stdout );
                    }

                if (( bReportInvalidIsoNames ) &&
                    ( ! IsValidJolietFileName( FindData.W.cFileName ))) {

                    printf( "\r\n%60s\r\nWARNING: Joliet unicode %sname contains invalid characters: \"%S\"\r\n",
                            "",
                            IsDirectory ? "directory " : "file",
                            GenerateFullNameW( pNewNode, ReportNameBuffer.W ));
                    fflush( stdout );
                    }


                if (( bReportExceedLevels ) &&
                    ((( NameLengthOfParents ) + ( NameLength * 2 ) + Depth ) > 240 ))  {

                    printf( "\r\n%60s\r\nWARNING: Joliet directory depth exceeds 240 bytes: \"%S\"\r\n",
                            "",
                            GenerateFullNameW( pNewNode, ReportNameBuffer.W ));
                    fflush( stdout );
                    }
                }

            if ( ! IsDirectory ) {

                dwlFileSize = ((DWORDLONG)( FindData.W.nFileSizeHigh ) << 32 )
                                          | FindData.W.nFileSizeLow;

                if ( dwlFileSize > 0xFFFFFFFF ) {
                    ErrorExit(
                        0,
                        "ERROR: File larger than 4GB: \"%S\"\r\n",
                        GenerateFullNameW( pNewNode, ReportNameBuffer.W )
                        );
                    }

                if (( bReportZeroLength ) && ( dwlFileSize == 0 )) {
                    printf( "\r\n%60s\r\nWARNING: File \"%S\" is 0-length.\r\n",
                            "",
                            GenerateFullNameW( pNewNode, ReportNameBuffer.W ));
                    fflush( stdout );
                    }

                pNewNode->dwlFileSize = dwlFileSize;

                dwTotalFileBlocks += CD_BLOCKS_FROM_SIZE( dwlFileSize );
                dwlTotalFileSizes += dwlFileSize;

                IncrementTotalNumberOfFiles();

                }
            }
        }

    while ( FindNextFileW( hFind, &FindData.W ));

     if ( GetLastError() != ERROR_NO_MORE_FILES ) {
        WarnFailedSourceOpen(
            GETLASTERROR,
            "Failure enumerating files in directory \"%S\"\r\n",
            GenerateFullNameSourceW( pParentDir, ReportNameBuffer.W )
            );
        }

    FindClose( hFind );

    for ( pNewNode  = pFirstNode;
          pNewNode != NULL;
          pNewNode  = pNewNode->pNextTargetFile ) {

        if ( pNewNode->dwFlags & IS_DIRECTORY ) {

            ASSERT( pNewNode->pDirectoryInfo != NULL );

            NameLength = pNewNode->wUnicodeNameLength;

            ASSERT( NameLength == (ULONG)lstrlenW( pNewNode->pszUnicodeName ));

            memcpy( DescentBufferPointer, pNewNode->pszUnicodeName, NameLength * 2 );

            *( DescentBufferPointer + NameLength     ) = L'\\';  // append backslash
            *( DescentBufferPointer + NameLength + 1 ) = 0;      // terminate

            pNewNode->pDirectoryInfo->pFirstTargetFile =
                RecursiveDescentJoliet(
                    pNewNode,
                    DescentBufferPointer + NameLength + 1,
                    Depth + 1,
                    NameLengthOfParents + NameLength * 2
                    );

            }
        }

    return pFirstNode;

    }


VOID ReadElToritoBootSectorFile( PCHAR ElToritoBootSectorFileName ) {

    HANDLE Handle;
    DWORD  Actual;
    BOOL   Success;
    DWORD  HighSize = 0;

    Handle = CreateFile(
                 ElToritoBootSectorFileName,
                 GENERIC_READ,
                 FILE_SHARE_READ,
                 NULL,
                 OPEN_EXISTING,
                 FILE_FLAG_SEQUENTIAL_SCAN,
                 NULL
                 );

    if ( Handle == INVALID_HANDLE_VALUE ) {

        ErrorExit(
            GETLASTERROR,
            "ERROR: Could not open boot sector file \"%s\"\r\n",
            ElToritoBootSectorFileName
            );
        }

    ElToritoBootSectorFileSize = GetFileSize( Handle, &HighSize );

    if ( ElToritoBootSectorFileSize == 0xFFFFFFFF ) {

        ErrorExit(
            GETLASTERROR,
            "ERROR: Could not determine boot sector file size \"%s\"\r\n",
            ElToritoBootSectorFileName
            );
        }

    if ( ElToritoBootSectorFileSize == 0 ) {

        ErrorExit(
            0,
            "ERROR: Boot sector file \"%s\" size is zero\r\n",
            ElToritoBootSectorFileName
            );
        }

    if (( ElToritoBootSectorFileSize > ( 0xFFFF * 0x200 )) || ( HighSize != 0 )) {

        ErrorExit(
            0,
            "ERROR: Boot sector file \"%s\" size is too large\r\n",
            ElToritoBootSectorFileName
            );
        }

    ElToritoBootSectorFileData = MyAllocNeverFree( ElToritoBootSectorFileSize );

    Success = ReadFile(
                  Handle,
                  ElToritoBootSectorFileData,
                  ElToritoBootSectorFileSize,
                  &Actual,
                  NULL
                  );

    if ( ! Success ) {

        ErrorExit(
            GETLASTERROR,
            "ERROR: Failure reading boot sector file \"%s\"\r\n",
            ElToritoBootSectorFileName
            );

        }

    if ( Actual != ElToritoBootSectorFileSize ) {

        ErrorExit(
            0,
            "ERROR: Failure reading boot sector file \"%s\"\r\n"
            "Actual bytes (%d) not equal to requested (%d)\r\n",
            ElToritoBootSectorFileName,
            Actual,
            ElToritoBootSectorFileSize
            );

        }

    CloseHandle( Handle );

    }


VOID
ComputeAutoCrcBlockValues(
    IN OUT PUCHAR Buffer,
    IN     DWORD  ExclusiveCrc
    )
    {
    DWORD InclusiveCrc;

    CopyMemory( Buffer + ( CD_SECTORSIZE - 24 ), "ExclCRC", 8 );
    CopyMemory( Buffer + ( CD_SECTORSIZE - 12 ), "AutoCRC", 8 );

    *(UNALIGNED DWORD*)( Buffer + ( CD_SECTORSIZE - 16 )) = ExclusiveCrc;

    InclusiveCrc = Crc32( ExclusiveCrc, Buffer, ( CD_SECTORSIZE - 4 ));

    *(UNALIGNED DWORD*)( Buffer + ( CD_SECTORSIZE - 4 )) = InclusiveCrc;
    }


VOID WriteAutoCrcHeaderBlock( VOID ) {

    PUCHAR    Buffer;
    DWORDLONG dwlOffset;

    ASSERT( bEncodeAutoCrc );
    ASSERT( AutoCrcHeaderBlock != 0 );

    dwlOffset = (DWORDLONG)AutoCrcHeaderBlock * dwBlockSize;

    ASSERT( IS_SECTOR_ALIGNED( dwlOffset ));

    ASSERT( dwlOffset == dwlNextHeaderOffset );
    DEBUGCODE( dwlNextHeaderOffset = 0xFFFFFFFF ); // should be final header write

    Buffer = AllocateBuffer( CD_SECTORSIZE, TRUE );

    ComputeAutoCrcBlockValues( Buffer, HeaderCrc );

    if ( bSignImage )
        UpdateMD5_Multiple64ByteChunks( &SignatureHash, Buffer, CD_SECTORSIZE );

    GenericWrite( dwlOffset, Buffer, CD_SECTORSIZE );

    ReportHeaderProgress( dwlOffset + CD_SECTORSIZE );

    }


VOID WriteAutoCrcFinalBlock( VOID ) {

    DWORDLONG dwlOffset;
    PUCHAR    Buffer;

    ASSERT(( bEncodeAutoCrc ) || ( bSignImage ));

    AutoCrcFinalBlock = dwTotalImageBlocks - BLOCK_NUMBER_FROM_SECTOR_NUMBER( 1 );

    dwlOffset = (DWORDLONG)AutoCrcFinalBlock * dwBlockSize;

    ASSERT( IS_SECTOR_ALIGNED( dwlOffset ));

    ASSERT(( ! bSignImage ) || ( AutoCrcHeaderBlock != 0 ));

    Buffer = AllocateBuffer( CD_SECTORSIZE, TRUE );

#ifndef DVDIMAGE_ONLY

    if ( bSignImage ) {

        UCHAR     SignatureBuffer[ SIGN_SIZE ];
        DWORD     SignatureIdentifier;
        DWORDLONG BytesHashed;
        BOOL      Success;

        //
        //  Mark this block as a "SIGNATURE" block with version number of
        //  signature format used (2.0 now).  Verification programs can
        //  use this version number to determine if they are capable of
        //  verifying this image.  If the high version number remains the
        //  same, older verification programs capable of verifying the same
        //  high version number should continue to work.  If the format changes
        //  such that older verification programs that know how to verify the
        //  existing high version number won't work on the new format, the high
        //  version number should be rev'd.
        //
        //  Version 0.0 (all offsets and sizes in decimal):
        //
        //  Offset  0, (2048 - 12) bytes, all zeros (including version number field described in v1.1 below)
        //  Offset (2048 - 12),  8 bytes, "AutoCRC" with terminating NULL
        //  Offset (2048 -  4),  4 bytes, CRC-32 value INCLUDING data in this sector up to offset (2048 - 4)
        //
        //  Version 1.1 (all offsets and sizes in decimal):
        //
        //  Offset   0,         10 bytes, "SIGNATURE" with terminating NULL
        //  Offset  10,          2 bytes, don't care (usually zeros)
        //  Offset  12,          4 bytes, version number of signature sector format (ver 1.2 is encoded little endian 0x00010002)
        //  Offset  16,         64 bytes, MD5 signature (not including hash of any data in this sector)
        //  Offset  80,        420 bytes, reserved for signature extensions
        //  Offset 500,          4 bytes, block number of next signature block (linked list rooted in final sector, terminated with zero)
        //  Offset 504,          8 bytes, reserved for signature extensions
        //  Offset 512, 2048 - 524 bytes, don't care (usually zeros, could be used for serial number)
        //  Offset 2048 - 12,    8 bytes, "AutoCRC" with terminating NULL
        //  Offset 2048 -  4,    4 bytes, CRC-32 value INCLUDING data in this sector up to offset (2048 - 4)
        //
        //  Version 2.0 (all offsets and sizes in decimal):
        //
        //  Offset   0,                 10 bytes, "SIGNATURE" with terminating NULL
        //  Offset  10,                  2 bytes, don't care (usually zeros)
        //  Offset  12,                  4 bytes, version number of signature sector format (ver 2.1 is encoded little endian 0x00020001)
        //  Offset  16,                  4 bytes, sector number where hash begins (if present, hashing wraps to sector zero when reaches final sector and continues up to this sector minus 1)
        //  Offset  20,                 12 bytes, reserved
        //
        //  Offset  32, first variable length [signature] record:
        //
        //      Offset 0,  4 bytes, length of this record (multiple of 16 bytes)
        //      Offset 4,  4 bytes, identifier of this record type identifier
        //                              0x00000000 - 0x7FFFFFFF is user-defined
        //                              0x80000000 - 0xFFFFFFFF is reserved
        //                              0x80000001              is what we're using
        //      Offset 8,  4 bytes, identifier of this record
        //      Offset 12, 4 bytes, length of signature data
        //      Offset 16, N bytes, signature data
        //
        //  Algorithm:
        //
        //      Offset = 32;
        //      while (( Offset < 2020 ) && ( dword@( Offset ) != 0 )) {
        //          // signature data @( Offset + 16 ), length dword@( Offset + 12 )
        //          Offset += dword@( Offset )
        //          }
        //
        //  ...etc... up to Offset CD_SECTORSIZE-28 (2020)
        //
        //  Offset 2048 - 24,    8 bytes, "ExclCRC" with terminating NULL
        //  Offset 2048 - 16,    4 bytes, CRC-32 value up to but EXCLUDING data in this sector
        //                                  (this value has NOT been finalized with XOR 0xFFFFFFFF).
        //  Offset 2048 - 12,    8 bytes, "AutoCRC" with terminating NULL
        //  Offset 2048 -  4,    4 bytes, CRC-32 value up to and INCLUDING data in this sector
        //                                  up to offset 2044 (this value has NOT been finalized
        //                                  with XOR 0xFFFFFFFF).
        //
        //  NOTE: CRC-32 value at end of sector which INCLUDES all data in sector
        //        will need to be re-computed whenever data in the signature sector
        //        is modified.  To re-compute the CRC, use the stored CRC value at
        //        offset 2032 as the initial CRC value for the sector.
        //
        //  NOTE: To maintain compatibility with existing version of CDIMAGE and
        //        CRC.EXE, the Header CRC (starting at sector zero) should be
        //        initialized to 0xFFFFFFFF, but the FileData CRC (starting at
        //        sector just beyond Header AutoCrc sector) should be initialized
        //        to 0x00000000.

        //
        //  Finalize signature
        //

        ASSERT( sizeof( SignatureVersionText ) == 64 );

#ifdef DEBUG2

        printf( "\r\nHash prefinal: " );
        {
        unsigned j;
        for ( j = 0; j < 16; j++ )
            printf( "%02x ", SignatureHash.Byte[ j ] );
        }
        printf( "\r\n" );

#endif // DEBUG2

        UpdateMD5_64ByteChunk( &SignatureHash, SignatureVersionText );

        BytesHashed = dwlOffset + 64;

        FinalizeMD5( &SignatureHash, BytesHashed );

#ifdef DEBUG2

        printf( "Hashed bytes:  0x%X\r\n", (DWORD)BytesHashed );
        printf( "Hashed text:   %s\r\n", SignatureVersionText );
        printf( "Hash value:    " );

        {
        unsigned j;
        for ( j = 0; j < 16; j++ )
            printf( "%02x ", SignatureHash.Byte[ j ] );
        }
        printf( "\r\n\r\n" );

#endif // DEBUG2

        ZeroMemory( &SignatureBuffer, sizeof( SignatureBuffer ));
        SignatureIdentifier = 0;

        ASSERT( ImageSignatureDescription != NULL );

        Success = GenerateImageSignature(
                      &SignatureHash,
                      ImageSignatureDescription,
                      &SignatureIdentifier,
                      SignatureBuffer
                      );

        if ( Success ) {

            ASSERT(( ! bEncodeAutoCrc ) || ( dwStartingFileBlock == ( AutoCrcHeaderBlock + BLOCK_NUMBER_FROM_SECTOR_NUMBER( 1 ))));

            CopyMemory( Buffer, "SIGNATURE", 10 );
            *(DWORD*)( Buffer + 12 ) = 0x00020000;
            *(DWORD*)( Buffer + 16 ) = dwStartingFileBlock;
            *(DWORD*)( Buffer + 32 ) = ROUNDUP2(( 16 + SIGN_SIZE ), 16 );
            *(DWORD*)( Buffer + 36 ) = 0x80000001;
            *(DWORD*)( Buffer + 40 ) = SignatureIdentifier;
            *(DWORD*)( Buffer + 44 ) = SIGN_SIZE;
            CopyMemory( Buffer + 48, SignatureBuffer, SIGN_SIZE );

#ifdef DEBUG2
            {
            ULONG i;

            printf( "\r\nSignature:\r\n" );
            for ( i = 0; i < SIGN_SIZE; i++ ) {
                if (( i % 16 ) == 0 ) {
                    printf( "\r\n" );
                    }
                printf( "%02x ", SignatureBuffer[ i ] );
                }
            printf( "\r\n\r\n" );
            }
#endif // DEBUG2

            }

        else {

            bSignImage = FALSE;

            }
        }

#endif // ! DVDIMAGE_ONLY


    if ( bEncodeAutoCrc )
        ComputeAutoCrcBlockValues( Buffer, FileDataCrc );

    GenericWrite( dwlOffset, Buffer, CD_SECTORSIZE );

    }


VOID
HeaderWrite(
    IN DWORDLONG Offset,
    IN PVOID     Buffer,
    IN ULONG     Length
    )
    {
    ASSERT( ISALIGN2_64( Offset, dwBlockSize ));
    ASSERT( ISALIGN2( Length, dwBlockSize ));
    ASSERT( ISALIGN2( Buffer, dwBlockSize ));
    ASSERT(( Offset == dwlNextHeaderOffset ) || ( ! bEncodeAutoCrc ));

    if ( bEncodeAutoCrc )
        HeaderCrc = Crc32( HeaderCrc, Buffer, Length );

    if ( bSignImage )
        UpdateMD5_Multiple64ByteChunks( &SignatureHash, Buffer, Length );

    GenericWrite( Offset, Buffer, Length );

    ReportHeaderProgress( Offset + Length );

    DEBUGCODE( dwlNextHeaderOffset = Offset + Length );

    }


VOID
FileDataWrite(
    IN DWORDLONG Offset,
    IN PVOID     Buffer,
    IN ULONG     Length
    )
    {
    ASSERT( ISALIGN2_64( Offset, dwBlockSize ));
    ASSERT( ISALIGN2( Length, dwBlockSize ));
    ASSERT( ISALIGN2( Buffer, dwBlockSize ));
    ASSERT(( Offset == dwlNextFileDataOffset ) || ( ! bEncodeAutoCrc ));

    if ( bEncodeAutoCrc )
        FileDataCrc = Crc32( FileDataCrc, Buffer, Length );

    if ( bSignImage )
        UpdateMD5_Multiple64ByteChunks( &SignatureHash, Buffer, Length );

    GenericWrite( Offset, Buffer, Length );

    ReportTransferProgress( Offset + Length );

    DEBUGCODE( dwlNextFileDataOffset = Offset + Length );

    }

DWORD
PaddedFileDataWrite(
    IN DWORDLONG Offset,
    IN PVOID     Buffer,
    IN ULONG     Length
    )
{
    DWORD dwLength;

    dwLength=ROUNDUP2(Length,CD_SECTORSIZE);
    if(dwLength != Length)
        ZeroMemory((BYTE*)Buffer+Length,dwLength-Length);
    FileDataWrite(Offset,Buffer,dwLength);

    return dwLength;
}



typedef struct _SPLIT_WRITE SPLIT_WRITE, *PSPLIT_WRITE;

struct _SPLIT_WRITE {
    LONG  ReferenceCount;
    PVOID BufferToFree;
    };


VOID
SplitWriteCompletion(
    PVOID     SplitBuffer,
    DWORDLONG SplitOffset,
    ULONG     SplitLength,
    PVOID     Context
    )
    {
    PSPLIT_WRITE SplitWrite = Context;

    //
    //  ASSUMPTION: Completion routine always called from same
    //              thread, so InterlockedDecrement is not necessary.
    //

    if ( --SplitWrite->ReferenceCount == 0 ) {
        ReleaseBuffer( SplitWrite->BufferToFree );
        MyHeapFree( SplitWrite );
        }

    UNREFERENCED( SplitBuffer );
    UNREFERENCED( SplitOffset );
    UNREFERENCED( SplitLength );
    }


VOID
LargeDataSplitWrite(
    IN DWORDLONG Offset,
    IN PVOID     Buffer,
    IN ULONG     Length
    )
    {
    PSPLIT_WRITE SplitWriteContext = MyHeapAlloc( sizeof( SPLIT_WRITE ));
    ULONG SplitCount = ROUNDUP2( Length, FX_BLOCKSIZE ) / FX_BLOCKSIZE;
    ULONG SplitLength;

    SplitWriteContext->ReferenceCount = SplitCount;
    SplitWriteContext->BufferToFree   = Buffer;

    while ( SplitCount-- ) {

        SplitLength = ( Length < FX_BLOCKSIZE ) ? Length : FX_BLOCKSIZE;

        IssueWrite(
            hTargetContext,
            Buffer,
            Offset,
            SplitLength,
            SplitWriteCompletion,
            SplitWriteContext
            );

        Buffer = (PCHAR)Buffer + SplitLength;
        Offset += SplitLength;
        Length -= SplitLength;

        }

    ASSERT( Length == 0 );

    }


VOID
GenericWrite(
    IN DWORDLONG Offset,
    IN PVOID     Buffer,
    IN ULONG     Length
    )
    {
    if ( Length > FX_BLOCKSIZE ) {
        LargeDataSplitWrite( Offset, Buffer, Length );
        }
    else {
        IssueWrite( hTargetContext, Buffer, Offset, Length, NULL, NULL );
        }
    }


VOID
GenericRead(
    IN DWORDLONG dwlOffset,
    IN DWORD dwLength,
    OUT PVOID pBuffer
    )
    {
    HANDLE hFile;
    OVERLAPPED Overlapped;
    BOOL bResult;
    DWORD dwBytesRead;

//    printf("Reading %u at %I64u from the image\r\n",dwLength,dwlOffset);
    FlushWriter(hTargetContext);

    hFile=GetFileHandleFromWriteContext(hTargetContext);

    dwBytesRead             = 0;
    Overlapped.Internal     = 0;
    Overlapped.InternalHigh = 0;
    Overlapped.Offset       = (DWORD)( dwlOffset );
    Overlapped.OffsetHigh   = (DWORD)( dwlOffset >> 32 );
    Overlapped.hEvent       = AllocateManualEvent();

    bResult=ReadFile(hFile,pBuffer,dwLength,&dwBytesRead,&Overlapped);

    if ( ! bResult ) {

        if( GetLastError() == ERROR_IO_PENDING ) {

            bResult=GetOverlappedResult(hFile,&Overlapped,&dwBytesRead,TRUE);

            if ( ! bResult ) {
                ErrorExit( GETLASTERROR, "GenericRead GetOverlappedResult failed\r\n" );
                }
            }

        else {
            ErrorExit( GETLASTERROR, "GenericRead ReadFile failed\r\n" );
            }
        }

    if ( dwBytesRead != dwLength ) {
        ErrorExit( 0, "GenericRead incorrect length (requested %d, got %d)\r\n", dwLength, dwBytesRead );
        }

    RecycleManualEvent( Overlapped.hEvent );
    }


BOOL SetImageLength(LONGLONG llOffset)
{
    HANDLE hFile;
    BOOL bResult;

    hFile=GetFileHandleFromWriteContext(hTargetContext);

    bResult = SetFilePointer(hFile,(LONG) llOffset, NULL, FILE_BEGIN);

    if (bResult )
    {
        bResult=SetEndOfFile(hFile);

        if ( ! bResult )
        {
            ErrorExit( GETLASTERROR, "SetImageLength SetEndOfFile failed\r\n" );
        }
    }
    else
    {
        ErrorExit( GETLASTERROR, "SetImageLength SetFilePointer failed\r\n" );
    }

    return bResult;
}

DWORD
AllocateMetaBlocks(
    IN DWORD SizeInBytes
    )
    {
    DWORD SizeInBlocks = CD_BLOCKS_FROM_SIZE( SizeInBytes );
    DWORD BlockNumber  = dwNextMetaBlockNumber;

    ASSERT( SizeInBytes != 0 );
    ASSERT( BlockNumber != 0 );

    if (( bEncodeUdf ) && ( dwMetaSlackStartingBlock == 0 )) {

        if ((( BlockNumber                ) <= ANCHOR_SECTOR ) &&
            (( BlockNumber + SizeInBlocks ) >  ANCHOR_SECTOR )) {

            //
            //  This allocation would span the ANCHOR_SECTOR, so move
            //  the allocation beyond the ANCHOR_SECTOR.  Note the
            //  reserved ANCHOR_SECTOR is only one block in length.
            //

            DEBUGCODE( printf( "\r\nWARNING: ISO-9660 meta data spans UDF anchor sector,\r\n"
                               "         wasting %d blocks to avoid UDF anchor\r\n",
                               ANCHOR_SECTOR - BlockNumber
                             ));

            dwMetaSlackStartingBlock  = BlockNumber;
            dwMetaSlackNumberOfBlocks = ANCHOR_SECTOR - BlockNumber;
            BlockNumber               = ANCHOR_SECTOR + 1;

            }
        }

    dwNextMetaBlockNumber = BlockNumber + SizeInBlocks;

    return BlockNumber;
    }


DWORD
AllocateMetaBlocksSectorAligned(
    IN DWORD SizeInBytes
    )
    {
    DWORD SizeInBlocks = CD_BLOCKS_FROM_SIZE( ROUNDUP2( SizeInBytes, CD_SECTORSIZE ));
    DWORD BlockNumber  = dwNextMetaBlockNumber;

    ASSERT( IS_SECTOR_ALIGNED( (DWORDLONG) BlockNumber * dwBlockSize ));

    ASSERT( SizeInBytes != 0 );
    ASSERT( BlockNumber != 0 );

    if (( bEncodeUdf ) && ( dwMetaSlackStartingBlock == 0 )) {

        if ((( BlockNumber                ) <= ANCHOR_SECTOR ) &&
            (( BlockNumber + SizeInBlocks ) >  ANCHOR_SECTOR )) {

            //
            //  This allocation would span the ANCHOR_SECTOR, so move
            //  the allocation beyond the ANCHOR_SECTOR.  Note the
            //  reserved ANCHOR_SECTOR is only one block in length.
            //

            DEBUGCODE( printf( "\r\nWARNING: ISO-9660 meta data spans UDF anchor sector,\r\n"
                               "         wasting %d blocks to avoid UDF anchor\r\n",
                               ANCHOR_SECTOR - BlockNumber
                             ));

            dwMetaSlackStartingBlock  = BlockNumber;
            dwMetaSlackNumberOfBlocks = ANCHOR_SECTOR - BlockNumber;
            BlockNumber               = ANCHOR_SECTOR + 1;

            }
        }

    dwNextMetaBlockNumber = BlockNumber + SizeInBlocks;

    return BlockNumber;
    }


VOID
WriteZeroedSectors(
    IN DWORD SectorNumber,
    IN DWORD NumberOfSectors
    )
    {
    DWORD SizeInBytes = NumberOfSectors * CD_SECTORSIZE;
    PVOID Buffer      = AllocateBuffer( SizeInBytes, TRUE );

    HeaderWrite((DWORDLONG)SectorNumber * CD_SECTORSIZE, Buffer, SizeInBytes );
    }


VOID
WriteZeroedBlocks(
    IN DWORD BlockNumber,
    IN DWORD NumberOfBlocks
    )
    {
    DWORD SizeInBytes = NumberOfBlocks * dwBlockSize;
    PVOID Buffer      = AllocateBuffer( SizeInBytes, TRUE );

    HeaderWrite((DWORDLONG)BlockNumber * dwBlockSize, Buffer, SizeInBytes );
    }


#ifndef DVDIMAGE_ONLY

VOID
GenerateSignatureDescription(
    VOID
    )
    {
    DWORD ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;
    CHAR  ComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ] = "?";
    CHAR  TargetName[ MAX_PATH ] = "?";
    CHAR  SourceName[ MAX_PATH ] = "?";
    LPSTR Terminator;
    DWORD SignatureDescriptionLength;

    GetComputerName( ComputerName, &ComputerNameLength );

    GetFullPathName( pszSourceTree, MAX_PATH, SourceName, &Terminator );

    Terminator = strchr( SourceName, 0 );

    if (( Terminator > SourceName ) && ( *( Terminator - 1 ) != '\\' )) {
        *Terminator++ = '\\';
        *Terminator   = '\0';
        }

    if ( pszTargetFile )
        GetFullPathName( pszTargetFile, MAX_PATH, TargetName, &Terminator );
    else
        strcpy( TargetName, "no image file" );

    SignatureDescriptionLength = strlen( "%s on %s %s to %s [%s]" )
                               + strlen( MAJOR_VERSION_TEXT )
                               + strlen( ComputerName )
                               + strlen( SourceName )
                               + strlen( TargetName )
                               + strlen( uchVolumeLabel )
                               - 10     // "%s%s%s%s%s"
                               + 1;     // terminator

    ImageSignatureDescription = MyAllocNeverFree( SignatureDescriptionLength );

    // "CDIMAGE 2.25 on TOMMCGMIPS d:\cdfstest to g:\test.img [LABEL]"

    sprintf(
        ImageSignatureDescription,
        "%s on %s %s to %s [%s]",
        MAJOR_VERSION_TEXT,
        ComputerName,
        SourceName,
        TargetName,
        uchVolumeLabel
        );

    }


BOOL
InitSignatureStuff(
    VOID
    )
    {
    printf( "\r\nConnecting to signature server... " );
    fflush( stdout );

    GenerateSignatureDescription();

    if ( ConnectToSignatureServer( ImageSignatureDescription )) {

        printf( "\rConnected to signature server    \r\n" );
        fflush( stdout );

        return TRUE;
        }

    else {

        CHAR ErrorTextBuffer[ 256 ];

        printf(
            "\r\n"
            "WARNING: Failed to connect to signature server,\r\n"
            "         \"%s\".\r\n"
            "         (%s)\r\n"
            "\r\n"
            "         IMAGE WILL NOT BE SIGNED.\r\n"
            "\r\n",
            SignatureRpcEndpointBindingString,
            ErrorTextFromErrorCode( GetLastError(), ErrorTextBuffer )
            );

        fflush( stdout );
        return FALSE;
        }
    }


BOOL
GenerateImageSignature(
    IN  PMD5_HASH HashValue,
    IN  LPSTR     SignatureDescription,
    OUT PDWORD    SignatureIdentfier,
    OUT PUCHAR    SignatureBuffer
    )
    {
    BOOL Success;

    printf( "\rGetting signature from signature server... " );
    fflush( stdout );

    Success = GenerateSignatureFromHashValue(
                  HashValue,
                  SignatureDescription,
                  SignatureIdentfier,
                  SignatureBuffer
                  );

    if ( Success ) {

        printf( "\r                                            \r" );
        fflush( stdout );

        return TRUE;
        }

    else {

        printf(
            "\r\n"
            "WARNING: Failed to acquire signature from RPC signature server\r\n"
            "         (%s)\r\n"
            "\r\n"
            "         IMAGE WILL NOT BE SIGNED.\r\n"
            "\r\n",
            ErrorTextFromErrorCode( GetLastError(), ReportNameBuffer.A )
            );

        fflush( stdout );
        return FALSE;
        }
    }

#endif // ! DVDIMAGE_ONLY


#ifdef DONTCOMPILE

void RecursiveLinkSourceFirst( PDIRENTRY pFirst, PDIRENTRY *pChain ) {

    PDIRENTRY pFile;

    for ( pFile = pFirst; pFile; pFile = pFile->pNextTargetFile ) {

        (*pChain)->pNextSourceFile = pFile;
        *pChain = pFile;

        if ( pFile->dwFlags & IS_DIRECTORY ) {
            RecursiveLinkSourceFirst( pFile->pDirectoryInfo->pFirstTargetFile, pChain );
            }
        }
    }


void RecursiveLinkSourceAfter( PDIRENTRY pFirst, PDIRENTRY *pChain ) {

    PDIRENTRY pFile;

    for ( pFile = pFirst; pFile; pFile = pFile->pNextTargetFile ) {

        (*pChain)->pNextSourceFile = pFile;
        *pChain = pFile;

        }

    for ( pFile = pFirst; pFile; pFile = pFile->pNextTargetFile ) {

        if ( pFile->dwFlags & IS_DIRECTORY ) {
            RecursiveLinkSourceFirst( pFile->pDirectoryInfo->pFirstTargetFile, pChain );
            }
        }
    }


void LinkSourceLevel( void ) {

    PDIRENTRY pFile, pDir, pChain;
    UINT uLevel;

    pChain = pRootDir;

    for ( uLevel = 0; pStartOfLevel[ uLevel ]; uLevel++ ) {
        for ( pDir = pStartOfLevel[ uLevel ]; pDir; pDir = pDir->pDirectoryInfo->pNextTargetDir ) {
            for ( pFile = pDir->pDirectoryInfo->pFirstTargetFile; pFile; pFile = pFile->pNextTargetFile ) {

                pChain->pNextSourceFile = pFile;
                pChain = pFile;

                }
            }
        }
    }


void ComputeModifiedOrdering( void ) {

    PDIRENTRY pChain = pRootDir;

    if ( bOptimizeDepthFirst ) {
        RecursiveLinkSourceFirst( pRootDir->pDirectoryInfo->pFirstTargetFile, &pChain );
        }
    else if ( bOptimizeDepthAfter ) {
        RecursiveLinkSourceAfter( pRootDir->pDirectoryInfo->pFirstTargetFile, &pChain );
        }
    else {
        LinkSourceLevel();
        }
    }

#endif // DONTCOMPILE

DWORD
FileDataRead(
    IN DWORDLONG Offset,
    IN PVOID     Buffer,
    IN ULONG     Length
    )
{
    DWORD dwBytesRead;
    DWORD dwHigh;
    DWORD dwLow;

    dwLow=(DWORD) Offset & 0x00000000FFFFFFFF;
    dwHigh=(DWORD) (Offset >> 32);
    ASSERT(((DWORDLONG) (dwHigh << 32) | (DWORDLONG) dwLow) == Offset);

    SetFilePointer(hTargetFile,(LONG)dwLow,(PLONG)&dwHigh, FILE_BEGIN);
    if(!ReadFile(hTargetFile,Buffer,Length,&dwBytesRead,NULL))
        return 0;
    else
        return dwBytesRead;
}

VOID EnqueueUdfFiles(PTRANSFER_CONTEXT pTx, PDWORDLONG pdwlTotalSourceBytes)
{
	PDIRENTRY pDir;
	PDIRENTRY pFile;
	UINT uLevel;
	LPWSTR pszUnicodeName;
	PDIRENTRY apSpecialDirs[2];
	BOOL fVideoTsInfoPresent = FALSE;
	DWORDLONG dwlFileSize;
	INT iIndex;

	ZeroMemory(apSpecialDirs, 2 * sizeof(PDIRENTRY));

	if(bUdfVideoZone)
	{
		// enqueue VIDEO_TS files and AUDIO_TS files first

		for ( uLevel = 0; pStartOfLevel[ uLevel ]; uLevel++ )
		{
			for ( pDir = pStartOfLevel[ uLevel ]; pDir; pDir = pDir->pDirectoryInfo->pNextTargetDir )
			{
				if(0 == wcscmp(pDir->pszUnicodeName,L"VIDEO_TS"))
				{
					apSpecialDirs[0] = pDir;
				}
				else if(0 == wcscmp(pDir->pszUnicodeName,L"AUDIO_TS"))
				{
					apSpecialDirs[1] = pDir;
				}
			}
		}

		if(apSpecialDirs[0] == NULL)
		{
			ErrorExit(0, "Error: VIDEO_TS directory does not exist\n");
		}

		for(iIndex = 0; iIndex < 2; iIndex++)
		{
			if(apSpecialDirs[iIndex] == NULL)
			{
				continue;
			}

			for ( pFile = apSpecialDirs[iIndex]->pDirectoryInfo->pFirstTargetFile; pFile; pFile = pFile->pNextTargetFile )
			{
				if ( ! ( pFile->dwFlags & ( IS_DIRECTORY | IS_WRITTEN )))
				{

					dwlFileSize = pFile->dwlFileSize;

					if ( dwlFileSize > 0 )
					{

						pFile->dwFlags |= IS_WRITTEN;

						pszUnicodeName = AllocFullUnicodeName( pFile );

						if((iIndex == 0) &&
						   (0 == wcscmp(pFile->pszUnicodeName,L"VIDEO_TS.IFO")))
						{
							fVideoTsInfoPresent = TRUE;
						}

						if ( QueueOpenFile(
									  pTx->hOpenContext,
									  pszUnicodeName,
									  NULL,
									  CD_SECTORSIZE,
									  0,
									  dwlFileSize,
									  MAX_QUEUED_READS,
									  pFile
									  ) )
						{

							*pdwlTotalSourceBytes += dwlFileSize;

						}
						else
						{
							pFile->dwFlags |= NO_DIRENTRY;  // don't create directory entry
							MyHeapFree( pszUnicodeName );

							dwlTotalFileSizes  -= dwlFileSize;
							dwlTotalImageBytes -= ROUNDUP2_64( dwlFileSize, dwBlockSize );
							dwTotalImageBlocks -= CD_BLOCKS_FROM_SIZE( dwlFileSize );
						}
					}
				}
			}
		}

		if(!fVideoTsInfoPresent)
		{
			ErrorExit(0,"Error: File VIDEO_TS\\VIDEO_TS.IFO not present or is 0 length");
		}
	}


    for ( uLevel = 0; pStartOfLevel[ uLevel ]; uLevel++ )
	{
        for ( pDir = pStartOfLevel[ uLevel ]; pDir; pDir = pDir->pDirectoryInfo->pNextTargetDir )
		{
			if(bUdfVideoZone)
			{
				// Skip VIDEO_TS and AUDIO_TS directories

				if((pDir == apSpecialDirs[0]) ||
				   (pDir == apSpecialDirs[1]))
				{
					continue;
				}

			}

            for ( pFile = pDir->pDirectoryInfo->pFirstTargetFile; pFile; pFile = pFile->pNextTargetFile )
			{
                if ( ! ( pFile->dwFlags & ( IS_DIRECTORY | IS_WRITTEN )))
				{

                    dwlFileSize = pFile->dwlFileSize;

                    if ( dwlFileSize > 0 )
					{

                        pFile->dwFlags |= IS_WRITTEN;

                        pszUnicodeName = AllocFullUnicodeName( pFile );

                        if ( QueueOpenFile(
                                      pTx->hOpenContext,
                                      pszUnicodeName,
                                      NULL,
                                      CD_SECTORSIZE,
                                      0,
                                      dwlFileSize,
                                      MAX_QUEUED_READS,
                                      pFile
                                      ) )
						{

                            *pdwlTotalSourceBytes += dwlFileSize;

                        }
                        else
						{
                            pFile->dwFlags |= NO_DIRENTRY;  // don't create directory entry
                            MyHeapFree( (PVOID) pszUnicodeName );

                            dwlTotalFileSizes  -= dwlFileSize;
                            dwlTotalImageBytes -= ROUNDUP2_64( dwlFileSize, dwBlockSize );
                            dwTotalImageBlocks -= CD_BLOCKS_FROM_SIZE( dwlFileSize );
                        }
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\error.c ===
#include "precomp.h"
#pragma hdrstop

VOID
CallTerminationHandlers(
    VOID
    );


DWORD GetLastErrorFromNtStatus( DWORD NtStatus ) {

    OVERLAPPED Overlapped;

    Overlapped.Internal = NtStatus;
    Overlapped.hEvent   = NULL;

    GetOverlappedResult( NULL, &Overlapped, &Overlapped.InternalHigh, FALSE );

    return GetLastError();

    }


volatile BOOL bGlobalErrorExitInProgress;

CRITICAL_SECTION ErrorExitCritSect;


BOOL
WINAPI
MyConsoleCtrlHandler(
    DWORD dwCtrlType
    )
    {
    ErrorExit( 0, "Process terminated\r\n" );
    UNREFERENCED( dwCtrlType );
    return FALSE;
    }


void InitializeErrorHandler( void ) {
    InitializeCriticalSection( &ErrorExitCritSect );
    SetConsoleCtrlHandler( MyConsoleCtrlHandler, TRUE );
    }


void ErrorExitV( DWORD dwGLE, const char *szFormat, va_list vaArgs ) {

    CHAR Buffer[ 256 ];

    bGlobalErrorExitInProgress = TRUE;

    if ( dwGLE == GETLASTERROR )
         dwGLE = GetLastError();

    EnterCriticalSection( &ErrorExitCritSect );

    printf( "\r\n" );
    vfprintf( stdout, szFormat, vaArgs );

    if ( dwGLE )
        printf( "%s\r\n", ErrorTextFromErrorCode( dwGLE, Buffer ));

    fflush( stdout );

    CallTerminationHandlers();

#ifdef DEBUG

    if ( MyIsDebuggerPresent() )
        DebugBreak();

#endif

    ExitProcess( 1 );

    }


void __cdecl ErrorExit( DWORD dwGLE, const char *szFormat, ... ) {

    va_list vaArgs;

    bGlobalErrorExitInProgress = TRUE;

    if ( dwGLE == GETLASTERROR )
         dwGLE = GetLastError();

    va_start( vaArgs, szFormat );

    ErrorExitV( dwGLE, szFormat, vaArgs );  // never returns

    va_end( vaArgs );

    }


void __cdecl WarnFailedSourceOpen( DWORD dwGLE, const char *szFormat, ... ) {

    CHAR Buffer[ 256 ];
    va_list vaArgs;

    if ( dwGLE == GETLASTERROR )
         dwGLE = GetLastError();

    va_start( vaArgs, szFormat );

    if ( bContinueAfterFailedSourceOpen ) {

        printf( "\r\nWARNING: " );

        vfprintf( stdout, szFormat, vaArgs );

        if ( dwGLE )
            printf( "%s\r\n", ErrorTextFromErrorCode( dwGLE, Buffer ));

        printf( "(skipping file)\r\n" );

        }
    else {

        printf( "\r\nERROR: " );

        vfprintf( stdout, szFormat, vaArgs );

        ErrorExitV( dwGLE, "", vaArgs );    // never returns
        }

    va_end( vaArgs );
    }



typedef struct _TERM_HANDLER_NODE TERM_HANDLER_NODE, *PTERM_HANDLER_NODE;

struct _TERM_HANDLER_NODE {
    PTERM_HANDLER_NODE   pNextNode;
    PTERMINATION_HANDLER pHandler;
    PVOID                pContext;
    };

TERM_HANDLER_NODE TermHandlerList;

VOID
RegisterTerminationHandler(
    PTERMINATION_HANDLER pHandler,
    PVOID                pContext
    )
    {
    PTERM_HANDLER_NODE pNode = MyAllocNeverFree( sizeof( TERM_HANDLER_NODE ));

    pNode->pNextNode = TermHandlerList.pNextNode;
    pNode->pHandler  = pHandler;
    pNode->pContext  = pContext;

    TermHandlerList.pNextNode = pNode;

    }

VOID
CallTerminationHandlers(
    VOID
    )
    {
    PTERM_HANDLER_NODE pNode = TermHandlerList.pNextNode;

    while ( pNode ) {
        ( *pNode->pHandler )( pNode->pContext );
        pNode = pNode->pNextNode;
        }
    }


LPSTR
ErrorTextFromErrorCode(
    IN  DWORD ErrorCode,
    OUT LPSTR ErrorText
    )
    {
    UCHAR  Buffer[ 256 ];
    PUCHAR p, q;

    sprintf( ErrorText, ((LONG)ErrorCode > 0 ) ? "Error %d" : "Error 0x%x", ErrorCode );

    if ( FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        ErrorCode,
                        0x409,
                        (LPSTR) Buffer,
                        sizeof( Buffer ),
                        NULL )) {

        p = Buffer;                             //  source
        q = (PUCHAR) strchr( ErrorText, 0 );    //  target (append to ErrorText)

        *q++ = ':';                             //  append ": "
        *q++ = ' ';

        for (;;) {

            while ( *p > ' ' )                  //  copy word up to whitespace
                *q++ = *p++;

            while (( *p ) && ( *p <= ' ' ))     //  skip whitespace
                p++;

            if ( *p )                           //  if another word remaining
                *q++ = ' ';                     //    append space, continue
            else                                //  else
                break;                          //    break

            }

        *q = 0;                                 //  terminate string

        }

    return ErrorText;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\makefile.inc ===
$(_NTTREE)\IDW\XDiscImage.Exe: $(_OBJ_DIR)\$(TARGET_DIRECTORY)\CDImage.Exe
    Copy $? $(_NTTREE)\IDW\XDiscImage.Exe
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\heap.h ===
extern HANDLE hGlobalHeap;

void MyHeapInit( void );

void __inline MyHeapFree( PVOID pMem ) {
    ASSERT( hGlobalHeap );
    HeapFree( hGlobalHeap, 0, pMem );
    }

DWORD __inline MyHeapSize( PVOID pMem ) {
    ASSERT( hGlobalHeap );
    return HeapSize( hGlobalHeap, 0, pMem );
    }

PVOID MyHeapAlloc( DWORD dwSize );

PVOID MyHeapReAlloc( PVOID pMem, DWORD dwSize );

PVOID MyAllocNeverFree( UINT nSize );

PVOID MyAllocNeverFreeLocked( UINT nSize );

PVOID MyVirtualAlloc( DWORD dwSize );

VOID MyVirtualFree( PVOID pMem );

BOOL MyVirtualLock( PVOID pMem, DWORD dwSize );

typedef struct _HASH_AND_LENGTH HASH_AND_LENGTH, *PHASH_AND_LENGTH;
typedef struct _BNODE BNODE, *PBNODE;

struct _HASH_AND_LENGTH {
    MD5_HASH  Hash;
    DWORDLONG Length;
    };

struct _BNODE {
    PBNODE          pLeft;
    PBNODE          pRight;
    HASH_AND_LENGTH HashAndLength;
    PVOID           pContext;
    };


BOOL
LookupOrAddBnode(
    PBNODE           *ppTree,           // IN OUT
    PHASH_AND_LENGTH  pHashAndLength,   // IN
    PVOID             pContext,         // IN
    PBNODE           *ppBnode           // OUT
    );

#ifdef DEBUG
    extern UINT nMaxBtreeDepth;
#endif


typedef struct _RECYCLE_LIST_NODE RECYCLE_LIST_NODE, *PRECYCLE_LIST_NODE;
typedef struct _RECYCLE_LIST_HEAD RECYCLE_LIST_HEAD, *PRECYCLE_LIST_HEAD;

struct _RECYCLE_LIST_NODE {
    PRECYCLE_LIST_NODE NextNode;
    PVOID              Object;
    };

struct _RECYCLE_LIST_HEAD {
    PRECYCLE_LIST_NODE FirstNode;       // creator must initialize to NULL
    };

VOID
InitializeRecyclePackage(
    VOID
    );

PVOID
GetObjectFromRecycleList(
    PRECYCLE_LIST_HEAD ListHead
    );

VOID
RecycleObjectToList(
    PRECYCLE_LIST_HEAD ListHead,
    PVOID              Object
    );

HANDLE
AllocateAutoEvent(          // state guaranteed to be not signaled
    VOID
    );

VOID
RecycleAutoEvent(           // should only recycle events in not signaled state
    HANDLE hEvent
    );

HANDLE
AllocateManualEvent(        // state guaranteed to be not signaled
    VOID
    );

VOID
RecycleManualEvent(         // doesn't matter state returned -- force reset
    HANDLE hEvent
    );


BOOL
__inline
EventStateUnsignaled(
    HANDLE hEvent
    )
    {
    return ( WaitForSingleObject( hEvent, 0 ) != WAIT_OBJECT_0 );
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\iso13346.h ===
/***    ISO13346.H - ISO 13346 File System Disk Format
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1996
 *      All Rights Reserved
 *
 *      This file defines the ISO 13346 Data Structures.
 *
 *      The UDF file system uses these data structures to interpret the
 *      media's contents.
 *
 */

#pragma pack(1)



/***    ISO 13346 Part 1: General
 *
 *
 */

/***    charspec - Character Set Specification (1/7.2.1)
 *
 */

typedef struct  CHARSPEC {
    UCHAR       charspec_Type;          // Character Set Type (CHARSPEC_T_...)
    UCHAR       charspec_Info[63];      // Character Set Information
} CHARSPEC, *PCHARSPEC;

//  CHARSPEC_T_... - Values for charspec_Type Character Set Types (1/7.2.1.1)

#define CHARSPEC_T_CS0  0               // By Agreement
#define CHARSPEC_T_CS1  1               // Unicode (according to ISO 2022)
#define CHARSPEC_T_CS2  2               // 38 Glyphs
#define CHARSPEC_T_CS3  3               // 65 Glyphs
#define CHARSPEC_T_CS4  4               // 95 Glyphs
#define CHARSPEC_T_CS5  5               // 191 Glyphs
#define CHARSPEC_T_CS6  6               // Unicode or ISO 2022
#define CHARSPEC_T_CS7  7               // Unicode or ISO 2022
#define CHARSPEC_T_CS8  8               // 53 Glyphs

//  CHARSPEC_T_CS... - Values for charspec_Info, depending on charspec_Type

#define CHARSPEC_T_CS0_OSTA "OSTA Compressed Unicode"


/***    timestamp - Timestamp Structure (1/7.3)
 *
 */

typedef struct  TIMESTAMP {
    short       timestamp_Zone:12;      // Time Zone (+-1440 minutes from CUT)
    short       timestamp_Type:4;       // Timestamp Type (TIMESTAMP_T_...)
    USHORT      timestamp_Year;         // Year (1..9999)
    UCHAR       timestamp_Month;        // Month (1..12)
    UCHAR       timestamp_Day;          // Day (1..31)
    UCHAR       timestamp_Hour;         // Hour (0..23)
    UCHAR       timestamp_Minute;       // Minute (0..59)
    UCHAR       timestamp_Second;       // Second (0..59)
    UCHAR       timestamp_centiSecond;  // Centiseconds (0..99)
    UCHAR       timestamp_usec100;      // Hundreds of microseconds (0..99)
    UCHAR       timestamp_usec;         // microseconds (0..99)
} TIMESTAMP, *PTIMESTAMP;

//  TIMESTAMP_T_... - Values for timestamp_Type (1/7.3.1)

#define TIMESTAMP_T_CUT         0       // Coordinated Universal Time
#define TIMESTAMP_T_LOCAL       1       // Local Time
#define TIMESTAMP_T_AGREEMENT   2       // Time format by agreement

//  TIMESTAMP_Z_... Values for timestamp_Zone

#define TIMESTAMP_Z_MIN         (-1440) // Minimum timezone offset (minutes)
#define TIMESTAMP_Z_MAX         ( 1440) // Maximum timezone offset (minutes)
#define TIMESTAMP_Z_NONE        (-2047) // No timezone in timestamp_Zone


/****   regid - Entity Identifier (1/7.4)
 *
 */

typedef struct  REGID {
    UCHAR       regid_Flags;            // Flags (REGID_F_...)
    UCHAR       regid_Identifier[23];   // Identifier
    UCHAR       regid_Suffix[8];        // Identifier Suffix
} REGID, *PREGID;

//  REGID_F_... - Definitions for regid_Flags bits

#define REGID_F_DIRTY           (0x01)  // Information Modified
#define REGID_F_PROTECTED       (0x02)  // Changes Locked Out

//  REGID_LENGTH_... - regid field lengths

#define REGID_LENGTH_IDENT      23      // Length of regid_Identifier (bytes)
#define REGID_LENGTH_SUFFIX     8       // Length of regid_Suffix (bytes)

//  REGID_ID_... - Values for regid_Identifier[0]

#define REGID_ID_ISO13346       (0x2B)  // regid_Identifier within ISO 13346
#define REGID_ID_NOTREGISTERED  (0x2D)  // regid_Identifier is not registered


/***    Various Structures from Parts 3 and 4 moved here for compilation.
 *
 */

/***    extentad - Extent Address Descriptor (3/7.1)
 *
 */

typedef struct  EXTENTAD {
    ULONG       extentad_Len;           // Extent Length in Bytes
    ULONG       extentad_lsn;           // Extent Logical Sector Number
} EXTENTAD, *PEXTENTAD;

//  Mask for extent_Length field, aka the dumbest thing in ISO 13346.

#define EXTENTAD_LEN_MASK   (0x3fffffff)// Maximum extent length, in bytes

#define EXTENTAD_ALLOC_SHFT     30      // Extent Recording Info Shift
#define EXTENTAD_ALLOC_MASK (0xc0000000)// Extent Recording Info Mask
#define EXTENTAD_ALLOC__R_A (0x00000000)// Extent Recorded and Allocated
#define EXTENTAD_ALLOC_NR_A (0x40000000)// Extent Not Recorded but Allocated
#define EXTENTAD_ALLOC_NRNA (0x80000000)// Extent Not Recorded, not Allocated
#define EXTENTAD_ALLOC_NEXT (0xc0000000)// Extent is next extent of Alloc Descs


/***    nsr_lba - Logical Block Address (4/7.1) (lb_addr)
 *
 */

typedef struct  NSR_LBA {
    ULONG       nsr_lba_lbn;            // Logical Block Number
    USHORT      nsr_lba_PartRef;        // Partition Reference Number
} NSR_LBA, *PNSR_LBA;


/***    Short Allocation Descriptor (4/14.14.1)
 *
 */

typedef struct  SHORTAD {
    ULONG       shortad_Length;         // Extent Length
    ULONG       shortad_Start;          // Extent Logical Block Number
} SHORTAD, *PSHORTAD;


/***    Long Allocation Descriptor (4/14.14.2)
 *
 */

typedef struct  LONGAD {
    ULONG       longad_Length;          // Extent Length
    NSR_LBA     longad_Start;           // Extent Location
    UCHAR       longad_ImpUse[6];       // Implementation Use
} LONGAD, *PLONGAD;


/***    Extended Allocation Descriptor (4/14.14.3)
 *
 */

typedef struct  EXTAD {
    ULONG       extad_ExtentLen;        // Extent Length
    ULONG       extad_RecordedLen;      // Recorded Length
    ULONG       extad_InfoLen;          // Information Length
    NSR_LBA     extad_Start;            // Extent Location
    UCHAR       extad_ImpUse[2];        // Implementation Use
} EXTAD, *PEXTAD;


/***    ISO 13346 Part 2: Volume and Boot Block Recognition
 *
 *
 */


/***    vsd_generic - Generic Volume Structure Descriptor (2/9.1)
 *
 */

typedef struct  VSD_GENERIC {
    UCHAR       vsd_generic_Type;       // Structure Type
    UCHAR       vsd_generic_Ident[5];   // Standard Identifier
    UCHAR       vsd_generic_Version;    // Standard Version
    UCHAR       vsd_generic_Data[2041]; // Structure Data
} VSD_GENERIC, *PVSD_GENERIC;

//  VSD_IDENT_... - Values for vsd_generic_Ident

#define VSD_IDENT_BEA01     "BEA01"     // Begin Extended Area
#define VSD_IDENT_TEA01     "TEA01"     // Terminate Extended Area
#define VSD_IDENT_CDROM     "CDROM"     // High Sierra Group (pre-ISO 9660)
#define VSD_IDENT_CD001     "CD001"     // ISO 9660
#define VSD_IDENT_CDW01     "CDW01"     // ECMA 168
#define VSD_IDENT_CDW02     "CDW02"     // ISO 13490
#define VSD_IDENT_NSR01     "NSR01"     // ECMA 167
#define VSD_IDENT_NSR02     "NSR02"     // ISO 13346
#define VSD_IDENT_NSR03     "NSR03"     // ECMA 167 V3
#define VSD_IDENT_BOOT2     "BOOT2"     // Boot Descriptor


/***    vsd_bea01 - Begin Extended Area Descriptor (2/9.2)
 *
 */

typedef struct  VSD_BEA01 {
    UCHAR       vsd_bea01_Type;         // Structure Type
    UCHAR       vsd_bea01_Ident[5];     // Standard Identifier ('BEA01')
    UCHAR       vsd_bea01_Version;      // Standard Version
    UCHAR       vsd_bea01_Data[2041];   // Structure Data
} VSD_BEA01, *PVSD_BEA01;


/***    vsd_tea01 - Terminate Extended Area Descriptor (2/9.3)
 *
 */

typedef struct  VSD_TEA01 {
    UCHAR       vsd_tea01_Type;         // Structure Type
    UCHAR       vsd_tea01_Ident[5];     // Standard Identifier ('TEA01')
    UCHAR       vsd_tea01_Version;      // Standard Version
    UCHAR       vsd_tea01_Data[2041];   // Structure Data
} VSD_TEA01, *PVSD_TEA01;


/***    vsd_boot2 - Boot Descriptor (2/9.4)
 *
 */

typedef struct  VSD_BOOT2 {
    UCHAR       vsd_boot2_Type;         // Structure Type
    UCHAR       vsd_boot2_Ident[5];     // Standard Identifier ('BOOT2')
    UCHAR       vsd_boot2_Version;      // Standard Version
    UCHAR       vsd_boot2_Res8;         // Reserved Zero
    REGID       vsd_boot2_Architecture; // Architecture Type
    REGID       vsd_boot2_BootIdent;    // Boot Identifier
    ULONG       vsd_boot2_BootExt;      // Boot Extent Start
    ULONG       vsd_boot2_BootExtLen;   // Boot Extent Length
    ULONG       vsd_boot2_LoadAddr[2];  // Load Address
    ULONG       vsd_boot2_StartAddr[2]; // Start Address
    TIMESTAMP   vsd_boot2_timestamp;    // Creation Time
    USHORT      vsd_boot2_Flags;        // Flags (VSD_BOOT2_F_...)
    UCHAR       vsd_boot2_Res110[32];   // Reserved Zeros
    UCHAR       vsd_boot2_BootUse[1906];// Boot Use
} VSD_BOOT2, *PVSD_BOOT2;

//  VSD_BOOT2_F_... - Definitions for vsd_boot2_Flags bits

#define VSD_BOOT2_F_ERASE   (0x0001)    // Ignore previous similar BOOT2 vsds


/***    ISO 13346 Part 3: Volume Structure
 *
 *
 */

/***    destag - Descriptor Tag (3/7.1 and 4/7.2)
 *
 *      destag_Checksum = Byte sum of bytes 0-3 and 5-15 of destag.
 *
 *      destag_CRC = CRC (X**16 + X**12 + X**5 + 1)
 *
 */

typedef struct  DESTAG {
    USHORT      destag_Ident;           // Tag Identifier
    USHORT      destag_Version;         // Descriptor Version
    UCHAR       destag_Checksum;        // Tag Checksum
    UCHAR       destag_Res5;            // Reserved
    USHORT      destag_Serial;          // Tag Serial Number
    USHORT      destag_CRC;             // Descriptor CRC
    USHORT      destag_CRCLen;          // Descriptor CRC Length
    ULONG       destag_lsn;             // Tag Location (Logical Sector Number)
} DESTAG, *PDESTAG;

//  DESTAG_ID_... - Values for destag_Ident
//  Descriptor Tag Values from NSR Part 3 (3/7.2.1)

#define DESTAG_ID_NOTSPEC           0   // Format Not Specified
#define DESTAG_ID_NSR_PVD           1   // (3/10.1) Primary Volume Descriptor
#define DESTAG_ID_NSR_ANCHOR        2   // (3/10.2) Anchor Volume Desc Pointer
#define DESTAG_ID_NSR_VDP           3   // (3/10.3) Volume Descriptor Pointer
#define DESTAG_ID_NSR_IMPUSE        4   // (3/10.4) Implementation Use Vol Desc
#define DESTAG_ID_NSR_PART          5   // (3/10.5) Partition Descriptor
#define DESTAG_ID_NSR_LVOL          6   // (3/10.6) Logical Volume Descriptor
#define DESTAG_ID_NSR_UASD          7   // (3/10.8) Unallocated Space Desc
#define DESTAG_ID_NSR_TERM          8   // (3/10.9) Terminating Descriptor
#define DESTAG_ID_NSR_LVINTEG       9   // (3/10.10) Logical Vol Integrity Desc

//  DESTAG_ID_... - Values for destag_Ident, continued...
//  Descriptor Tag Values from NSR Part 4 (4/7.2.1)

#define DESTAG_ID_NSR_FSD           256 // (4/14.1) File Set Descriptor
#define DESTAG_ID_NSR_FID           257 // (4/14.4) File Identifier Descriptor
#define DESTAG_ID_NSR_ALLOC         258 // (4/14.5) Allocation Extent Desc
#define DESTAG_ID_NSR_ICBIND        259 // (4/14.7) ICB Indirect Entry
#define DESTAG_ID_NSR_ICBTRM        260 // (4/14.8) ICB Terminal Entry
#define DESTAG_ID_NSR_FILE          261 // (4/14.9) File Entry
#define DESTAG_ID_NSR_XA            262 // (4/14.10) Extended Attribute Header
#define DESTAG_ID_NSR_UASE          263 // (4/14.11) Unallocated Space Entry
#define DESTAG_ID_NSR_SBP           264 // (4/14.12) Space Bitmap Descriptor
#define DESTAG_ID_NSR_PINTEG        265 // (4/14.13) Partition Integrity
#define DESTAG_ID_NSR_EXTFILE       266 // ECMA 167 V3(4/14.17) Extended File Entry


//  DESTAG_SERIAL_... - Values for destag_Serial (3/7.2.5)

#define DESTAG_SERIAL_NONE          0   // No Serial Number specified


/***    Anchor Points (3/8.4.2.1)
 *
 */

#define ANCHOR_SECTOR   256


/***    vsd_nsr02 - NSR02 Volume Structure Descriptor (3/9.1)
 *
 */

typedef struct  VSD_NSR02 {
    UCHAR       vsd_nsr02_Type;         // Structure Type
    UCHAR       vsd_nsr02_Ident[5];     // Standard Identifier ('NSR02')
    UCHAR       vsd_nsr02_Version;      // Standard Version
    UCHAR       vsd_nsr02_Res7;         // Reserved 0 Byte
    UCHAR       vsd_nsr02_Data[2040];   // Structure Data
} VSD_NSR02, *PVSD_NSR02;


//  Values for vsd_nsr02_Type

#define VSD_NSR02_TYPE_0        0       // Reserved 0

//  Values for vsd_nsr02_Version

#define VSD_NSR02_VER           1       // Standard Version 1


/***    nsr_pvd - NSR Primary Volume Descriptor (3/10.1)
 *
 *      nsr_pvd_destag.destag_Ident = DESTAG_ID_NSR_PVD
 *
 */

typedef struct  NSR_PVD {
    DESTAG      nsr_pvd_destag;         // Descriptor Tag (NSR_PVD)
    ULONG       nsr_pvd_VolDescSeqNum;  // Volume Descriptor Sequence Number
    ULONG       nsr_pvd_Number;         // Primary Volume Descriptor Number
    UCHAR       nsr_pvd_VolumeID[32];   // Volume Identifier
    USHORT      nsr_pvd_VolSetSeq;      // Volume Set Sequence Number
    USHORT      nsr_pvd_VolSetSeqMax;   // Maximum Volume Set Sequence Number
    USHORT      nsr_pvd_Level;          // Interchange Level
    USHORT      nsr_pvd_LevelMax;       // Maximum Interchange Level
    ULONG       nsr_pvd_CharSetList;    // Character Set List (See 1/7.2.11)
    ULONG       nsr_pvd_CharSetListMax; // Maximum Character Set List
    UCHAR       nsr_pvd_VolSetID[128];  // Volume Set Identifier
    CHARSPEC    nsr_pvd_charsetDesc;    // Descriptor Character Set
    CHARSPEC    nsr_pvd_charsetExplan;  // Explanatory Character Set
    EXTENTAD    nsr_pvd_Abstract;       // Volume Abstract Location
    EXTENTAD    nsr_pvd_Copyright;      // Volume Copyright Notice Location
    REGID       nsr_pvd_Application;    // Application Identifier
    TIMESTAMP   nsr_pvd_RecordTime;     // Recording Time
    REGID       nsr_pvd_ImpUseID;       // Implementation Identifier
    UCHAR       nsr_pvd_ImpUse[64];     // Implementation Use
    ULONG       nsr_pvd_Predecessor;    // Predecessor Vol Desc Seq Location
    USHORT      nsr_pvd_Flags;          // Flags
    UCHAR       nsr_pvd_Res490[22];     // Reserved Zeros
} NSR_PVD, *PNSR_PVD;

//  NSRPVD_F_... - Definitions for nsr_pvd_Flags

#define NSR_PVD_F_COMMON_VOLID   (0x0001)// Volume ID is common across Vol Set


/***    nsr_anchor - Anchor Volume Descriptor Pointer (3/10.2)
 *
 *      nsr_anchor_destag.destag_Ident = DESTAG_ID_NSR_ANCHOR
 *
 */

typedef struct  NSR_ANCHOR {
    DESTAG      nsr_anchor_destag;      // Descriptor Tag (NSR_ANCHOR)
    EXTENTAD    nsr_anchor_Main;        // Main Vol Desc Sequence Location
    EXTENTAD    nsr_anchor_Reserve;     // Reserve Vol Desc Sequence Location
    UCHAR       nsr_anchor_Res32[480];  // Reserved Zeros
} NSR_ANCHOR, *PNSR_ANCHOR;


/***    nsr_vdp - Volume Descriptor Pointer (3/10.3)
 *
 *      nsr_vdp_destag.destag_Ident = DESTAG_ID_NSR_VDP
 *
 */

typedef struct  NSR_VDP {
    DESTAG      nsr_vdp_destag;         // Descriptor Tag (NSR_VDP)
    ULONG       nsr_vdp_VolDescSeqNum;  // Vol Desc Sequence Number
    EXTENTAD    nsr_vdp_Next;           // Next Vol Desc Sequence Location
    UCHAR       nsr_vdp_Res28[484];     // Reserved Zeros
} NSR_VDP, *PNSR_VDP;


/***    nsr_impuse - Implementation Use Volume Descriptor (3/10.4)
 *
 *      nsr_impuse_destag.destag_Ident = DESTAG_ID_NSR_IMPUSE
 *
 */

typedef struct  NSR_IMPUSE {
    DESTAG      nsr_impuse_destag;          // Descriptor Tag (NSR_IMPUSE)
    ULONG       nsr_impuse_VolDescSeqNum;   // Vol Desc Sequence Number
    REGID       nsr_impuse_ImpUseID;        // Implementation Identifier
    UCHAR       nsr_impuse_ImpUse[460];     // Implementation Use
} NSR_IMPUSE, *PNSR_IMPUSE;


/***    nsr_part - Partition Descriptor (3/10.5)
 *
 *      nsr_part_destag.destag_Ident = DESTAG_ID_NSR_PART
 *
 */

typedef struct  NSR_PART {
    DESTAG      nsr_part_destag;            // Descriptor Tag (NSR_PART)
    ULONG       nsr_part_VolDescSeqNum;     // Vol Desc Sequence Number
    USHORT      nsr_part_Flags;             // Partition Flags (NSR_PART_F_...)
    USHORT      nsr_part_Number;            // Partition Number
    REGID       nsr_part_ContentsID;        // Partition Contents ID
    UCHAR       nsr_part_ContentsUse[128];  // Partition Contents Use
    ULONG       nsr_part_AccessType;        // Access Type
    ULONG       nsr_part_Start;             // Partition Starting Location
    ULONG       nsr_part_Length;            // Partition Length (sector count)
    REGID       nsr_part_ImpUseID;          // Implementation Identifier
    UCHAR       nsr_part_ImpUse[128];       // Implementation Use
    UCHAR       nsr_part_Res356[156];       // Reserved Zeros
} NSR_PART, *PNSR_PART;


//  NSR_PART_F_... - Definitions for nsr_part_Flags

#define NSR_PART_F_ALLOCATION   (0x0001)    // Volume Space Allocated

//  Values for nsr_part_ContentsID.regid_Identifier

#define NSR_PART_CONTID_FDC01   "+FDC01"    // ISO 9293-1987
#define NSR_PART_CONTID_CD001   "+CD001"    // ISO 9660
#define NSR_PART_CONTID_CDW01   "+CDW01"    // ECMA 168
#define NSR_PART_CONTID_CDW02   "+CDW02"    // ISO 13490
#define NSR_PART_CONTID_NSR01   "+NSR01"    // ECMA 167
#define NSR_PART_CONTID_NSR02   "+NSR02"    // ISO 13346

//  Values for nsr_part_AccessType

#define NSR_PART_ACCESS_NOSPEC  0       // Partition Access Unspecified
#define NSR_PART_ACCESS_RO      1       // Read Only Access
#define NSR_PART_ACCESS_WO      2       // Write-Once Access
#define NSR_PART_ACCESS_RW_PRE  3       // Read/Write with preparation
#define NSR_PART_ACCESS_RW_OVER 4       // Read/Write, fully overwritable


/***    nsr_lvol - Logical Volume Descriptor (3/10.6)
 *
 *      nsr_lvol_destag.destag_Ident = DESTAG_ID_NSR_LVOL
 *
 *      The true length of nsr_lvol_MapTable[] is (nsr_lvol_MapTableLength).
 *
 *      The Logical Volume Contents Use field is specified here as a
 *      File Set Descriptor Sequence (FSD) address.  See (4/3.1).
 *
 */

typedef struct  NSR_LVOL {
    DESTAG      nsr_lvol_destag;            // Descriptor Tag (NSR_LVOL)
    ULONG       nsr_lvol_VolDescSeqNum;     // Vol Desc Sequence Number
    CHARSPEC    nsr_lvol_charspec;          // Descriptor Character Set
    UCHAR       nsr_lvol_VolumeID[128];     // Logical Volume ID
    ULONG       nsr_lvol_BlockSize;         // Logical Block Size (in bytes)
    REGID       nsr_lvol_DomainID;          // Domain Identifier
    LONGAD      nsr_lvol_FSD;               // Logical Volume Contents Use
    ULONG       nsr_lvol_MapTableLength;    // Map Table Length (bytes)
    ULONG       nsr_lvol_MapTableCount;     // Map Table Partition Maps Count
    REGID       nsr_lvol_ImpUseID;          // Implementaion Identifier
    UCHAR       nsr_lvol_ImpUse[128];       // Implementation Use
    EXTENTAD    nsr_lvol_Integrity;         // Integrity Sequence Extent
    UCHAR       nsr_lvol_MapTable[0];       // Partition Map Table (variant!)

//  The true length of this structure may vary!
//  The true length of nsr_lvol_MapTable is (nsr_lvol_MapTableLength).

} NSR_LVOL, *PNSR_LVOL;


/***    partmap_g - Generic Partition Map (3/10.7.1)
 *
 *      The true length of partmap_g_Map[] is (partmap_g_Length - 2).
 */

typedef struct  PARTMAPG {
    UCHAR       partmap_g_Type;         // Partition Map Type
    UCHAR       partmap_g_Length;       // Partition Map Length
    UCHAR       partmap_g_Map[0];       // Partion Mapping (variant!)

//  The true length of this structure may vary!
//  The true length of partmap_g_Map[] is (partmap_g_Length - 2).

} PARTMAPG, *PPARTMAPG;

//  Values for partmap_g_Type

#define PARTMAP_TYPE_NOTSPEC        0   // Partition Map Format Not Specified
#define PARTMAP_TYPE_NORMAL         1   // Partition Map in Volume Set (Type 1)
#define PARTMAP_TYPE_PROXY          2   // Partition Map by identifier (Type 2)
#define PARTMAP_TYPE_VIRTUAL        2   // Virtual Partition Map  (Type 2) ECMA 167 V3


/***    partmap - Normal (Type 1) Partition Map (3/10.7.2)
 *
 *      A Normal Partion Map specifies a partition number on a volume
 *      within the same volume set.
 *
 */

typedef struct  PARTMAP {
    UCHAR       partmap_Type;           // Partition Map Type = 1
    UCHAR       partmap_Length;         // Partition Map Length = 6
    USHORT      partmap_VolSetSeq;      // Partition Volume Set Sequence Number
    USHORT      partmap_Partition;      // Partition Number
} PARTMAP, *PPARTMAP;


/***    partmap_p - Proxy (Type 2) Partition Map (3/10.7.3)
 *
 *      A Proxy Partition Map is commonly not interchangeable.
 *
 */

typedef struct  PARTMAPP {
    UCHAR       partmap_p_Type;         // Partition Map Type = 1
    UCHAR       partmap_p_Length;       // Partition Map Length = 64
    UCHAR       partmap_p_PartID[62];   // Partition Identifier (Proxy)
} PARTMAPP, *PPARTMAPP;


/*** Virtual Partition Map
 *   
 *   Type 2 partition map for virtual partition
 *
 */
typedef struct PM_VIRT{
    UCHAR       Type;               // Type = 2 
    UCHAR       Length;             // Length = 64;
    USHORT      Reserved;
    REGID       PartitionTypeID;     // *UDF Virtual Partition
    USHORT      VolSeqNum;          // Volume on which the virtual partition is recorded
    USHORT      PartitionNum;       // Id of the partition;
} PARTMAPVIRT;


/***    nsr_uasd - Unallocated Space Descriptor (3/10.8)
 *
 *      nsr_uasd_destag.destag_Ident = DESTAG_ID_NSR_UASD
 *
 *      The true length of nsr_uasd_Extents is (nsr_uasd_ExtentCount * 8), and
 *      the last logical sector of nsr_uasd_Extents is zero padded.
 *
 */

typedef struct  NSR_UASD {
    DESTAG      nsr_uasd_destag;        // Descriptor Tag (NSR_UASD)
    ULONG       nsr_uasd_VolDescSeqNum; // Vol Desc Sequence Number
    ULONG       nsr_uasd_ExtentCount;   // Number of Allocation Descriptors
    EXTENTAD    nsr_uasd_Extents[0];    // Allocation Descriptors (variant!)

//  The true length of this structure may vary!
//  The true length of nsr_uasd_Extents is (nsr_uasd_ExtentCount * 8) bytes.
//  The last logical sector of nsr_uasd_Extents is zero padded.

} NSR_UASD, *PNSR_UASD;


/***    nsr_term - Terminating Descriptor (3/10.9 and 4/14.2)
 *
 *      nsr_term_destag.destag_Ident = DESTAG_ID_NSR_TERM
 *
 */

typedef struct  NSR_TERM {
    DESTAG      nsr_term_destag;        // Descriptor Tag (NSR_TERM)
    UCHAR       nsr_term_Res16[496];    // Reserved Zeros
} NSR_TERM, *PNSR_TERM;


/***    nsr_lvhd - Logical Volume Header Descriptor (4/14.15)
 *
 *      This descriptor is found in the Logical Volume Content Use
 *      field of a Logical Volume Integrity Descriptor.
 *
 *      This definition is moved to here to avoid forward reference.
 */

typedef struct  NSR_LVHD {
    ULONG       nsr_lvhd_UniqueID[2];   // Unique ID
    UCHAR       nsr_lvhd_Res8[24];      // Reserved Zeros
} NSR_LVHD, *PNSR_LVHD;


/***    nsr_integ - Logical Volume Integrity Descriptor (3/10.10)
 *
 *      nsr_integ_destag.destag_Ident = DESTAG_ID_NSR_LVINTEG
 *
 *      WARNING: WARNING: WARNING: nsr_integ is a multi-variant structure!
 *
 *      The starting address of nsr_integ_Size is not acurrate.
 *      Compensate for this nsr_integ_Size problem by adding the value of
 *      (nsr_integ_PartitionCount-1) to the ULONG ARRAY INDEX.
 *
 *      The starting address of nsr_integ_ImpUse[0] is not accurate.
 *      Compensate for this nsr_integ_ImpUse problem by adding the value of
 *      ((nsr_integ_PartitionCount-1)<<3) to the UCHAR ARRAY INDEX.
 *
 *      This descriptor is padded with zero bytes to the end of the last
 *      logical sector it occupies.
 *
 *      The Logical Volume Contents Use field is specified here as a
 *      Logical Volume Header Descriptor.  See (4/3.1) second last point.
 */

typedef struct  NSR_INTEG {
    DESTAG      nsr_integ_destag;           // Descriptor Tag (NSR_LVINTEG)
    TIMESTAMP   nsr_integ_Time;             // Recording Date
    ULONG       nsr_integ_Type;             // Integrity Type (INTEG_T_...)
    EXTENTAD    nsr_integ_Next;             // Next Integrity Extent
    NSR_LVHD    nsr_integ_LVHD;             // Logical Volume Contents Use
    ULONG       nsr_integ_PartitionCount;   // Number of Partitions
    ULONG       nsr_integ_ImpUseLength;     // Length of Implementation Use
    ULONG       nsr_integ_Free[1];          // Free Space Table

//  nsr_integ_Free has a variant length = (4*nsr_integ_PartitionCount)

    ULONG       nsr_integ_Size[1];          // Size Table

//  nsr_integ_Size has a variant starting offset due to nsr_integ_Free
//  nsr_integ_Size has a variant length = (4*nsr_integ_PartitionCount)

    UCHAR       nsr_integ_ImpUse[0];        // Implementation Use

//  nsr_integ_ImpUse has a variant starting offset due to nsr_integ_Free and
//  nsr_integ_Size.
//  nsr_integ_ImpUse has a variant length = (nsr_integ_ImpUseLength)

} NSR_INTEG, *PNSR_INTEG;

// Values for nsr_integ_Type

#define NSR_INTEG_T_OPEN        0           // Open Integrity Descriptor
#define NSR_INTEG_T_CLOSE       1           // Close Integrity Descriptor


/***    ISO 13346 Part 4: File Structure
 *
 *      See DESTAG structure in Part 3 for definitions found in (4/7.2).
 *
 */


/***    nsr_fsd - File Set Descriptor (4/14.1)
 *
 *      nsr_fsd_destag.destag_Ident = DESTAG_ID_NSR_FSD
 */

typedef struct  NSR_FSD {
    DESTAG      nsr_fsd_destag;         // Descriptor Tag (NSR_LVOL)
    TIMESTAMP   nsr_fsd_Time;           // Recording Time
    USHORT      nsr_fsd_Level;          // Interchange Level
    USHORT      nsr_fsd_LevelMax;       // Maximum Interchange Level
    ULONG       nsr_fsd_CharSetList;    // Character Set List (See 1/7.2.11)
    ULONG       nsr_fsd_CharSetListMax; // Maximum Character Set List
    ULONG       nsr_fsd_FileSet;        // File Set Number
    ULONG       nsr_fsd_FileSetDesc;    // File Set Descriptor Number
    CHARSPEC    nsr_fsd_charspecVolID;  // Volume ID Character Set
    UCHAR       nsr_fsd_VolID[128];     // Volume ID
    CHARSPEC    nsr_fsd_charspecFileSet;// File Set Character Set
    UCHAR       nsr_fsd_FileSetID[32];  // File Set ID
    UCHAR       nsr_fsd_Copyright[32];  // Copyright File Name
    UCHAR       nsr_fsd_Abstract[32];   // Abstract File Name
    LONGAD      nsr_fsd_icbRoot;        // Root Directory ICB Address
    REGID       nsr_fsd_DomainID;       // Domain Identifier
    LONGAD      nsr_fsd_NextExtent;     // Next FSD Extent
    LONGAD      nsr_fsd_StreamDirectoryICB; // StreamDirectory ICB
    UCHAR       nsr_fsd_Res480[32];     // Reserved Zeros
} NSR_FSD, *PNSR_FSD;


/***    nsr_part_h - Partition Header Descriptor (4/14.3)
 *
 *      No Descriptor Tag.
 *
 *      This descriptor is found in the nsr_part_ContentsUse field of
 *      an NSR02 Partition Descriptor.  See NSR_PART_CONTID_NSR02.
 *
 */

typedef struct  NSR_PART_H {
    SHORTAD     nsr_part_h_UASTable;    // Unallocated Space Table
    SHORTAD     nsr_part_h_UASBitmap;   // Unallocated Space Bitmap
    SHORTAD     nsr_part_h_IntegTable;  // Integrity Table
    SHORTAD     nsr_part_h_FreedTable;  // Freed Space Table
    SHORTAD     nsr_part_h_FreedBitmap; // Freed Space Bitmap
    UCHAR       nsr_part_h_Res40[88];   // Reserved Zeros
} NSR_PART_H, *PNSR_PART_H;


/***    nsr_fid - File Identifier Descriptor (4/14.4)
 *
 *      nsr_fid_destag.destag_Ident = DESTAG_ID_NSR_FID
 *
 *      WARNING: WARNING: WARNING: nsr_fid is a multi-variant structure!
 *
 *      The starting address of nsr_fid_FileID is not acurrate.
 *      Compensate for this nsr_fid_FileID problem by adding the value of
 *      (nsr_fid_ImpUseLen-1) to the UCHAR ARRAY INDEX.
 *
 *      The starting address of nsr_fid_Padding is not acurrate.
 *      Compensate for this nsr_fid_Padding problem by adding the value of
 *      (nsr_fid_ImpUseLen+nsr_fid_FileIDLen-2) to the UCHAR ARRAY INDEX.
 *
 *      The true total size of nsr_fid_s is
 *          ((38 + nsr_fid_FileIDLen + nsr_fid_ImpUseLen) + 3) & ~3)
 *
 */

typedef struct  NSR_FID {
    DESTAG      nsr_fid_destag;         // Descriptor Tag (NSR_FID)
    USHORT      nsr_fid_Version;        // File Version Number
    UCHAR       nsr_fid_Flags;          // File Flags (NSR_FID_F_...)
    UCHAR       nsr_fid_FileIDLen;      // File ID Length
    LONGAD      nsr_fid_icb;            // ICB (long) Address
    USHORT      nsr_fid_ImpUseLen;      // Implementation Use Length

    UCHAR       nsr_fid_ImpUse[1];      // Implementation Use Area

//  nsr_fid_ImpUse has a variant length = nsr_fid_ImpUseLen

    UCHAR       nsr_fid_FileID[1];      // File Identifier

//  nsr_fid_FileID has a variant starting offset due to nsr_fid_ImpUse
//  nsr_fid_FileID has a variant length = nsr_fid_FileIDLen

    UCHAR       nsr_fid_Padding[1];     // Padding

//  nsr_fid_Paddinghas a variant starting offset due to nsr_fid_ImpUse and
//  nsr_fid_FileID
//  nsr_fid_Padding has a variant length. Round up to the next ULONG boundary.

} NSR_FID, *PNSR_FID;


//  NSR_FID_F_... - Definitions for nsr_fid_Flags (Characteristics, 4/14.4.3)

#define NSR_FID_F_HIDDEN        (0x01)  // Hidden Bit
#define NSR_FID_F_DIRECTORY     (0x02)  // Directory Bit
#define NSR_FID_F_DELETED       (0x04)  // Deleted Bit
#define NSR_FID_F_PARENT        (0x08)  // Parent Directory Bit

#define NSR_FID_OFFSET_FILEID   38      // Field Offset of nsr_fid_FileID[];


/***    nsr_alloc - Allocation Extent Descriptor (4/14.5)
 *
 *      nsr_alloc_destag.destag_Ident = DESTAG_ID_NSR_ALLOC
 *
 *      This descriptor is immediately followed by AllocLen bytes
 *      of allocation descriptors, which is not part of this
 *      descriptor (so CRC calculation doesn't include it).
 *
 */

typedef struct  NSR_ALLOC {
    DESTAG      nsr_alloc_destag;       // Descriptor Tag (NSR_ALLOC)
    ULONG       nsr_alloc_Prev;         // Previous Allocation Descriptor
    ULONG       nsr_alloc_AllocLen;     // Length of Allocation Descriptors
} NSR_ALLOC, *PNSR_ALLOC;


/***    icbtag - Information Control Block Tag (4/14.6)
 *
 *      An ICBTAG is commonly preceeded by a Descriptor Tag (DESTAG).
 *
 */

typedef struct  ICBTAG {
    ULONG       icbtag_PriorDirectCount;// Prior Direct Entry Count
    USHORT      icbtag_StratType;       // Strategy Type (ICBTAG_STRAT_...)
    USHORT      icbtag_StratParm;       // Strategy Parameter (2 bytes)
    USHORT      icbtag_MaxEntries;      // Maximum Number of Entries in ICB
    UCHAR       icbtag_Res10;           // Reserved Zero
    UCHAR       icbtag_FileType;        // File Type (ICBTAG_FILE_T_...)
    NSR_LBA     icbtag_icbParent;       // Parent ICB Location
    USHORT      icbtag_Flags;           // ICB Flags
} ICBTAG, *PICBTAG;


//  ICBTAG_STRAT_T_... - ICB Strategy Types
//  BUGBUG: rickdew 7/31/95.  Weird strategies!  I'm guessing on names here.

#define ICBTAG_STRAT_NOTSPEC    0       // ICB Strategy Not Specified
#define ICBTAG_STRAT_TREE       1       // Strategy 1 (4/A.2) (Plain Tree)
#define ICBTAG_STRAT_MASTER     2       // Strategy 2 (4/A.3) (Master ICB)
#define ICBTAG_STRAT_BAL_TREE   3       // Strategy 3 (4/A.4) (Balanced Tree)
#define ICBTAG_STRAT_DIRECT     4       // Strategy 4 (4/A.5) (One Direct)

//  ICBTAG_FILE_T_... - Values for icbtag_FileType

#define ICBTAG_FILE_T_NOTSPEC    0      // Not Specified
#define ICBTAG_FILE_T_UASE       1      // Unallocated Space Entry
#define ICBTAG_FILE_T_PINTEG     2      // Partition Integrity Entry
#define ICBTAG_FILE_T_INDIRECT   3      // Indirect Entry
#define ICBTAG_FILE_T_DIRECTORY  4      // Directory
#define ICBTAG_FILE_T_FILE       5      // Ordinary File
#define ICBTAG_FILE_T_BLOCK_DEV  6      // Block Special Device
#define ICBTAG_FILE_T_CHAR_DEV   7      // Character Special Device
#define ICBTAG_FILE_T_XA         8      // Extended Attributes
#define ICBTAG_FILE_T_FIFO       9      // FIFO file
#define ICBTAG_FILE_T_C_ISSOCK  10      // Socket
#define ICBTAG_FILE_T_TERMINAL  11      // Terminal Entry
#define ICBTAG_FILE_T_PATHLINK  12      // Symbolic Link with a pathname
#define ICBTAG_FILE_T_STREAM_DIR 13     // Stream Directory
#define ICBTAG_FILE_T_VAT       248     // Virtual Allocation Table

//  ICBTAG_F_... - Values for icbtag_Flags

#define ICBTAG_F_ALLOC_MASK     (0x0007)// Mask for Allocation Descriptor Info
#define ICBTAG_F_ALLOC_SHORT          0 // Short Allocation Descriptors Used
#define ICBTAG_F_ALLOC_LONG           1 // Long Allocation Descriptors Used
#define ICBTAG_F_ALLOC_EXTENDED       2 // Extended Allocation Descriptors Used
#define ICBTAG_F_ALLOC_IMMEDIATE      3 // File Data Recorded Immediately

#define ICBTAG_F_SORTED         (0x0004)// Directory is Sorted (4/8.6.1)
#define ICBTAG_F_NO_RELOCATE    (0x0010)// Data is not relocateable
#define ICBTAG_F_ARCHIVE        (0x0020)// Archive Bit
#define ICBTAG_F_SETUID         (0x0040)// S_ISUID Bit
#define ICBTAG_F_SETGID         (0x0080)// S_ISGID Bit
#define ICBTAG_F_STICKY         (0x0100)// C_ISVTX Bit
#define ICBTAG_F_CONTIGUOUS     (0x0200)// File Data is Contiguous
#define ICBTAG_F_SYSTEM         (0x0400)// System Bit
#define ICBTAG_F_TRANSFORMED    (0x0800)// Data Transformed
#define ICBTAG_F_MULTIVERSIONS  (0x1000)// Multi-version Files in Directory


/***    icbind - Indirect ICB Entry (4/14.7)
 *
 */

typedef struct  ICBIND {
    DESTAG      icbind_destag;          // Descriptor Tag (ID_NSR_ICBIND)
    ICBTAG      icbind_icbtag;          // ICB Tag (ICBTAG_FILE_T_INDIRECT)
    LONGAD      icbind_icb;             // ICB Address
} ICBIND, *PICBIND;


/***    icbtrm - Terminal ICB Entry (4/14.8)
 *
 */

typedef struct  ICBTRM {
    DESTAG      icbtrm_destag;          // Descriptor Tag (ID_NSR_ICBTRM)
    ICBTAG      icbtrm_icbtag;          // ICB Tag (ICBTAG_FILE_T_TERMINAL)
} ICBTRM, *PICBTRM;


/***    icbfile - File ICB Entry (4/14.9)
 *
 *      WARNING: WARNING: WARNING: icbfile is a multi-variant structure!
 *
 *      The starting address of icbfile_Allocs is not acurrate.
 *      Compensate for this icbfile_Allocs problem by adding the value of
 *      (icbfile_XALength-1) to the UCHAR ARRAY INDEX.
 *
 *      icbfile_XALength is a multiple of 4.
 *
 */

typedef struct  ICBFILE {
    DESTAG      icbfile_destag;             // Descriptor Tag (ID_NSR_FILE)
    ICBTAG      icbfile_icbtag;             // ICB Tag (ICBTAG_FILE_T_FILE)
    ULONG       icbfile_UID;                // User ID of file's owner
    ULONG       icbfile_GID;                // Group ID of file's owner
    ULONG       icbfile_Permissions;        // File Permissions
    USHORT      icbfile_LinkCount;          // File hard-link count
    UCHAR       icbfile_RecordFormat;       // Record Format
    UCHAR       icbfile_RecordDisplay;      // Record Display Attributes
    ULONG       icbfile_RecordLength;       // Record Length
    ULONGLONG   icbfile_InfoLength;      // Information Length (file size)
    ULONGLONG   icbfile_BlocksRecorded;  // Logical Blocks Recorded
    TIMESTAMP   icbfile_AccessTime;         // Last-Accessed Time
    TIMESTAMP   icbfile_ModifyTime;         // Last-Modification Time
    TIMESTAMP   icbfile_AttributeTime;      // Last-Attribute-Change Time
    ULONG       icbfile_Checkpoint;         // File Checkpoint
    LONGAD      icbfile_icbXA;              // Extended Attribute ICB
    REGID       icbfile_ImpUseID;           // Implementation Use Identifier
    ULONGLONG   icbfile_UniqueID;           // Unique ID
    ULONG       icbfile_XALength;           // Length of Extended Attributes
    ULONG       icbfile_AllocLen;           // Length of Allocation Descriptors
    UCHAR       icbfile_XAs[1];             // Extended Attributes

//  icbfile_XAs has a variant length = icbfile_XALength

    UCHAR       icbfile_Allocs[0];          // Allocation Descriptors.

//  icbfile_Allocs has a variant starting offset due to icbfile_XAs.
//  icbfile_Allocs has a variant length = icbfile_AllocLen.

} ICBFILE, *PICBFILE;

/***    icbextfile - Extended File ICB Entry (4/14.17 ECMA167r3 and later)
 *
 *      WARNING: WARNING: WARNING: icbextfile is a multi-variant structure!
 *
 *      The starting address of icbfile_Allocs is not acurrate.
 *      Compensate for this icbfile_Allocs problem by adding the value of
 *      (icbfile_XALength-1) to the UCHAR ARRAY INDEX.
 *
 *      icbfile_XALength is a multiple of 4.
 *
 */

typedef struct  ICBEXTFILE {
    DESTAG      Destag;                 // Descriptor Tag (DESTAG_ID_NSR_EXT_FILE)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_FILE)
    ULONG       UID;                    // User ID of file's owner
    ULONG       GID;                    // Group ID of file's owner
    ULONG       Permissions;            // File Permissions
    USHORT      LinkCount;              // File hard-link count
    UCHAR       RecordFormat;           // Record Format
    UCHAR       RecordDisplay;          // Record Display Attributes
    ULONG       RecordLength;           // Record Length
    ULONGLONG   InfoLength;             // Information Length (file size)
    ULONGLONG   ObjectSize;             // Object Size (Sum of InfoLengths for all streams)
    
                                        // THE ABOVE FIELD IS NEW IN THE EXT FE vs BASIC
                                        // FE.  FIELDS AFTER THIS POINT ARE DISPLACED AND SHOULD
                                        // BE ACCESSED USING THE MACROS BELOW WHEN 
                                        // MANIPULATING RAW, MAPPED, FEs
                                        
    ULONGLONG   BlocksRecorded;         // Logical Blocks Recorded
    TIMESTAMP   AccessTime;             // Last-Accessed Time
    TIMESTAMP   ModifyTime;             // Last-Modification Time
    TIMESTAMP   CreationTime;           // Creation Time
    TIMESTAMP   AttributeTime;          // Last-Attribute-Change Time
    ULONG       Checkpoint;             // File Checkpoint
    ULONG       Reserved;
    LONGAD      IcbEA;                  // Extended Attribute ICB
    LONGAD      IcbStream;              // Stream Directory ICB
    REGID       ImpUseID;               // Implementation Use Identifier
    ULONGLONG   UniqueID;               // Unique ID
    ULONG       EALength;               // Length of Extended Attributes
    ULONG       AllocLength;            // Length of Allocation Descriptors
    UCHAR       EAs[1];                 // Extended Attributes

//  icbfile_EAs has a variant length = icbfile_EALength

    UCHAR       Allocs[0];              // Allocation Descriptors.

//  icbfile_Allocs has a variant starting offset due to icbfile_EAs.
//  icbfile_Allocs has a variant length = icbfile_AllocLen.

} ICBEXTFILE, *PICBEXTFILE;

//
//  Macros for accessing FEs and EXT FEs transparently.  Note that we
//  only need these for fields after the first new (in ext fe) field (which is
//  ObjectSize) and only for fields that we actually access.
//
//  All of the following macros expect a parameter of type PICBFILE
//

#define FeBlocksRecorded( F)        (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     (F)->BlocksRecorded : ((PICBEXTFILE)(F))->BlocksRecorded)
                                     
#define PFeAccessTime( F)           (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     &(F)->AccessTime : &((PICBEXTFILE)(F))->AccessTime)
                                     
#define PFeModifyTime( F)           (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     &(F)->ModifyTime : &((PICBEXTFILE)(F))->ModifyTime)
                                     
#define PFeCreationTime( F)         (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     &(F)->ModifyTime : &((PICBEXTFILE)(F))->CreationTime)
                                     
#define FeEALength( F)              (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     (F)->EALength : ((PICBEXTFILE)(F))->EALength)
                                     
#define FeAllocLength( F)           (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     (F)->AllocLength : ((PICBEXTFILE)(F))->AllocLength)

#define FeEAs( F)                   (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     (F)->EAs : ((PICBEXTFILE)(F))->EAs)

#define FeEAsFieldOffset( F)        (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     FIELD_OFFSET( ICBFILE, EAs ) : FIELD_OFFSET( ICBEXTFILE, EAs ))

#define UdfFEIsExtended( F)         ((F)->Destag.Ident == DESTAG_ID_NSR_EXT_FILE)

//  Definitions for icbfile_Permissions (4/14.9.6)

#define ICBFILE_PERM_OTH_X  (0x00000001)    // Other: Execute OK
#define ICBFILE_PERM_OTH_W  (0x00000002)    // Other: Write OK
#define ICBFILE_PERM_OTH_R  (0x00000004)    // Other: Read OK
#define ICBFILE_PERM_OTH_A  (0x00000008)    // Other: Set Attributes OK
#define ICBFILE_PERM_OTH_D  (0x00000010)    // Other: Delete OK
#define ICBFILE_PERM_GRP_X  (0x00000020)    // Group: Execute OK
#define ICBFILE_PERM_GRP_W  (0x00000040)    // Group: Write OK
#define ICBFILE_PERM_GRP_R  (0x00000080)    // Group: Read OK
#define ICBFILE_PERM_GRP_A  (0x00000100)    // Group: Set Attributes OK
#define ICBFILE_PERM_GRP_D  (0x00000200)    // Group: Delete OK
#define ICBFILE_PERM_OWN_X  (0x00000400)    // Owner: Execute OK
#define ICBFILE_PERM_OWN_W  (0x00000800)    // Owner: Write OK
#define ICBFILE_PERM_OWN_R  (0x00001000)    // Owner: Read OK
#define ICBFILE_PERM_OWN_A  (0x00002000)    // Owner: Set Attributes OK
#define ICBFILE_PERM_OWN_D  (0x00004000)    // Owner: Delete OK

//  (4/14.9.7) Record Format
//      Skipped

//  (4/14.9.8) Record Display Attributes
//      Skipped


typedef struct VATFILE
{
    USHORT      Length;
    USHORT      LengthOfImplem;
    UCHAR       LogicalVolID[128];
    ULONG       PrevVATICB;
    ULONG       NumFiles;
    ULONG       NumDirs;
    USHORT      MinUDFReadRev;
    USHORT      MinUDFWriteRev;
    USHORT      MaxUDFWriteRev;
    USHORT      Reserved;
    UCHAR       ImpUse[1];
}VATFILE,*PVATFILE;
/***    nsr_xah - Extended Attributes Header Descriptor (4/14.10.1)
 *
 */

typedef struct  NSR_XAH {
    DESTAG      nsr_xah_destag;         // Descriptor Tag (ID_NSR_XA)
    ULONG       nsr_xah_XAImp;          // Implementation Attributes Location
    ULONG       nsr_xah_XAApp;          // Application Attributes Location
} NSR_XAH, *PNSR_XAH;


// Values for Extended Attribute Type and Sub Type (gathered from 4/14.10)
#define XA_SUBTYPE_ALL          1       // Sub type used for all XA

#define XA_TYPE_CHARSET_INFO    1       // Character Set Information XA
#define XA_TYPE_ALT_PERMS       3       // Alternate Permissions XA
#define XA_TYPE_FILE_TIMES      5       // File Time XA
#define XA_TYPE_INFO_TIMES      6       // Information Times XA
#define XA_TYPE_DEVICE_SPEC     12      // Device Specification XA
#define XA_TYPE_IMPLEMENT_USE   2048    // Implementation Use XA
#define XA_TYPE_APPLICATION_USE 65536   // Application Use XA



/***    nsr_xa_g - Generic Extended Attributes Format (4/14.10.2)
 *
 */

typedef struct  NSR_XA_G {
    ULONG       nsr_xa_g_XAType;        // Extended Attribute Type
    UCHAR       nsr_xa_g_XASubType;     // Extended Attribute Sub Type
    UCHAR       nsr_xa_g_Res5[3];       // Reserved Zeros
    ULONG       nsr_xa_g_XALength;      // Extended Attribute Length
    UCHAR       nsr_xa_g_XAData[0];     // Extended Attribute Data (variant!)

//  The true length of this structure may vary!
//  nsr_xa_g_XAData has a variant length = nsr_xa_g_XALength - 12

} NSR_XA_G, *PNSR_XA_G;


//  (4/14.10.3) Character Set Information Extended Attribute Format
//      Skipped

//  (4/14.10.4) Alternate Permissions Extended Attribute Format
//      Skipped

//  (4/14.10.5) File Times Extended Attribute Format

typedef struct  NSR_XA_FILETIMES {
    ULONG       nsr_xa_filetimes_XAType;        // Extended Attribute Type
    UCHAR       nsr_xa_filetimes_XASubType;     // Extended Attribute Sub Type
    UCHAR       nsr_xa_filetimes_Res5[3];       // Reserved Zeros
    ULONG       nsr_xa_filetimes_XALength;      // Extended Attribute Length
    ULONG       nsr_xa_filetimes_DataLength;    // XAData Length
    ULONG       nsr_xa_filetimes_Existence;     // Specifies which times are recorded
    UCHAR       nsr_xa_filetimes_XAData[0];     // Extended Attribute Data (variant!)

//  The true length of this structure may vary!
//  nsr_xa_g_XAData has a variant length = DataLength

} NSR_XA_FILETIMES, *PNSR_XA_FILETIMES;


//  Definitions for nsr_xa_filetimes_Existence (4/14.10.5.6)

#define XA_FILETIMES_E_CREATION     (0x00000001)
#define XA_FILETIMES_E_DELETION     (0x00000004)
#define XA_FILETIMES_E_EFFECTIVE    (0x00000008)
#define XA_FILETIMES_E_LASTBACKUP   (0x00000020)


//  (4/14.10.6) Information Times Extended Attribute Format
//      Skipped

//  (4/14.10.7) Device Specification Extended Attribute Format
//      Skipped

//  (4/14.10.8) Implementation Use Extended Attribute Format
//      Skipped

//  (4/14.10.9) Application Use Extended Attribute Format
//      Skipped


/***    icbuase - Unallocated Space Entry (4/14.11)
 *
 *      icbuase_destag.destag_Ident = DESTAG_ID_NSR_UASE
 *      icbuase_icbtag.icbtag_FileType = ICBTAG_FILE_T_UASE
 *
 */

typedef struct  ICBUASE {
    DESTAG      icbuase_destag;         // Descriptor Tag (ID_NSR_ICBUASE)
    ICBTAG      icbuase_icbtag;         // ICB Tag (ICBTAG_FILE_T_UASE)
    ULONG       icbuase_AllocLen;       // Allocation Descriptors Length
    UCHAR       icbuase_Allocs[0];      // Allocation Descriptors (variant!)

//  The true length of this structure may vary!
//  icbuase_Allocs has a variant length = icbuase_AllocLen;

} ICBUASE, *PICBUASE;


/***    nsr_sbd - Space Bitmap Descriptor (4/14.12)
 *
 *      nsr_sbd_destag.destag_Ident = DESTAG_ID_NSR_SBD
 *
 */

typedef struct  NSR_SBD {
    DESTAG      nsr_sbd_destag;         // Descriptor Tag (DESTAG_ID_NSR_SBD)
    ULONG       nsr_sbd_BitCount;       // Number of bits in Space Bitmap
    ULONG       nsr_sbd_ByteCount;      // Number of bytes in Space Bitmap
    UCHAR       nsr_sbd_Bits[0];        // Space Bitmap (variant!)

//  The true length of this structure may vary!
//  nsr_sbd_Bits has a variant length = nsr_sbd_ByteCount;

} NSR_SBD, *PNSR_SBD;


/***    icbpinteg - Partition Integrity ICB Entry (4/14.13)
 *
 */

typedef struct  ICBPINTEG {
    DESTAG      icbpinteg_destag;       // Descriptor Tag (ID_NSR_PINTEG)
    ICBTAG      icbpinteg_icbtag;       // ICB Tag (ICBTAG_FILE_T_PINTEG)
    TIMESTAMP   icbpinteg_Recording;    // Recording Time
    UCHAR       icbpinteg_IntegType;    // Integrity Type (ICBPINTEG_T_...)
    UCHAR       icbpinteg_Res49[175];   // Reserved Zeros
    REGID       icbpinteg_ImpUseID;     // Implemetation Use Identifier
    UCHAR       icbpinteg_ImpUse[256];  // Implemetation Use Area
} ICBPINTEG, *PICBPINTEG;

//  ICBPINTEG_T_... - Values for icbpinteg_IntegType

#define ICBPINTEG_T_OPEN        0       // Open Partition Integrity Entry
#define ICBPINTEG_T_CLOSE       1       // Close Partition Integrity Entry
#define ICBPINTEG_T_STABLE      2       // Stable Partition Integrity Entry


/***    (4/14.14.1) Short Allocation Descriptor
 ***    (4/14.14.2) Long Allocation Descriptor
 ***    (4/14.14.3) Extended Allocation Descriptor
 *
 *      See SHORTAD, LONGAD, EXTAD, already defined above.
 *
 */


/***    nsr_lvhd - Logical Volume Header Descriptor (4/14.15)
 *
 *      The definition is moved to before Logical Volume Integrity
 *      Descriptor.
 *
 */


/***    nsr_path - Path Component (4/14.16)
 *
 */

typedef struct  NSR_PATH {
    UCHAR       nsr_path_Type;          // Path Component Type (NSR_PATH_T_...)
    UCHAR       nsr_path_CompLen;       // Path Component Length
    UCHAR       nsr_path_CompVer;       // Path Component Version
    UCHAR       nsr_path_Comp[0];       // Path Component Identifier (variant!)

//  nsr_path_Comp has a variant length = nsr_path_CompLen

} NSR_PATH, *PNSR_PATH;

//  NSR_PATH_T_... - Values for nsr_path_Type

#define NSR_PATH_T_RESERVED     0       // Reserved Value
#define NSR_PATH_T_OTHER_ROOT   1       // Another root directory, by agreement
#define NSR_PATH_T_ROOTDIR      2       // Root Directory ('\')
#define NSR_PATH_T_PARENTDIR    3       // Parent Directory ('..')
#define NSR_PATH_T_CURDIR       4       // Current Directory ('.')
#define NSR_PATH_T_FILE         5       // File


/***    ISO 13346 Part 5: Record Structure
 *
 *      Skipped
 *
 */


#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\heap.c ===
#include "precomp.h"
#pragma hdrstop


HANDLE hGlobalHeap;

void MyHeapInit( void ) {
    hGlobalHeap = GetProcessHeap();
    ASSERT( hGlobalHeap != NULL );
    }


PVOID MyHeapAlloc( DWORD dwSize ) {

    PVOID pMem;

    ASSERT( hGlobalHeap );

    pMem = HeapAlloc( hGlobalHeap, HEAP_ZERO_MEMORY, dwSize );

    if ( pMem == NULL ) {
        ErrorExit( 0, "Out of memory\r\n" );
        }

    return pMem;
    }


PVOID MyHeapReAlloc( PVOID pMem, DWORD dwSize ) {

    PVOID pNewMem;

    ASSERT( hGlobalHeap );

    pNewMem = HeapReAlloc( hGlobalHeap, HEAP_ZERO_MEMORY, pMem, dwSize );
    if ( pNewMem == NULL ) {
        ErrorExit( 0, "Out of memory\r\n" );
        }

    return pNewMem;
    }


PVOID MyVirtualAlloc( DWORD dwSize ) {

    PVOID pMem;

    pMem = VirtualAlloc( NULL, dwSize, MEM_COMMIT, PAGE_READWRITE );
    if ( pMem == NULL ) {
        ErrorExit( 0, "Out of memory\r\n" );
        }

    return pMem;
    }


VOID MyVirtualFree( PVOID pMem ) {

    if ( ! VirtualFree( pMem, 0, MEM_RELEASE )) {
        ErrorExit( GETLASTERROR, "Failed to free virtual memory\r\n" );
        }
    }


BOOL MyVirtualLock( PVOID pMem, DWORD dwSize ) {

    HANDLE CurrentProcess;
    DWORD  MinWorkingSet;
    DWORD  MaxWorkingSet;
    BOOL   Success;

    Success = VirtualLock( pMem, dwSize );

    if ( ! Success ) {

        //
        //  Attempt to grow working set and retry.
        //

        CurrentProcess = GetCurrentProcess();

        Success = GetProcessWorkingSetSize(
                      CurrentProcess,
                      &MinWorkingSet,
                      &MaxWorkingSet
                      );

        ASSERT( Success == TRUE );

        if ( Success ) {

            MinWorkingSet += dwSize;

            if ( MaxWorkingSet < MinWorkingSet )
                 MaxWorkingSet = MinWorkingSet;

            Success = SetProcessWorkingSetSize(
                          CurrentProcess,
                          MinWorkingSet,
                          MaxWorkingSet
                          );

            if ( Success ) {

                Success = VirtualLock( pMem, dwSize );

                }
            }
        }

    if ( ! Success ) {
        DEBUGCODE( printf( "\rFailed to lock virtual memory (GLE=%d)\r\n", GetLastError() ));
        }

    return Success;
    }



#define GRANULARITY 8
#define GROW_SIZE   0x10000


PVOID MyAllocNeverFree( UINT nSize ) {

    static PUCHAR pVirtualRemaining = NULL;             // remembered
    static UINT   nVirtualRemaining = 0;                // remembered
    static CRITICAL_SECTION MyAllocNeverFreeCritSect;   // remembered

    PUCHAR pMem;
    UINT   nGrow;

    if ( pVirtualRemaining == NULL ) {
        InitializeCriticalSection( &MyAllocNeverFreeCritSect );
        }

    EnterCriticalSection( &MyAllocNeverFreeCritSect );

    nSize = ROUNDUP2( nSize, GRANULARITY );

    if ( nSize > nVirtualRemaining ) {

        nGrow = ROUNDUP2( nSize, GROW_SIZE );

        pMem = MyVirtualAlloc( nGrow );

        if ( pMem == ( pVirtualRemaining + nVirtualRemaining )) {

            //
            //  New VM is contiguous with remaining VM.
            //

            nVirtualRemaining += nGrow;
            }
        else {

            //
            //  Wasting nVirtualRemaining bytes at end of old section.
            //

            pVirtualRemaining = pMem;
            nVirtualRemaining = nGrow;
            }
        }

    pMem = pVirtualRemaining;

    pVirtualRemaining += nSize;
    nVirtualRemaining -= nSize;

    LeaveCriticalSection( &MyAllocNeverFreeCritSect );

    return pMem;

    }


PVOID MyAllocNeverFreeLocked( UINT nSize ) {

    static PUCHAR pVirtualRemainingLocked = NULL;               // remembered
    static UINT   nVirtualRemainingLocked = 0;                  // remembered
    static CRITICAL_SECTION MyAllocNeverFreeLockedCritSect;     // remembered

    PUCHAR pMem;
    UINT   nGrow;

    if ( pVirtualRemainingLocked == NULL ) {
        InitializeCriticalSection( &MyAllocNeverFreeLockedCritSect );
        }

    EnterCriticalSection( &MyAllocNeverFreeLockedCritSect );

    nSize = ROUNDUP2( nSize, GRANULARITY );

    if ( nSize > nVirtualRemainingLocked ) {

        nGrow = ROUNDUP2( nSize, GROW_SIZE );

        pMem = MyVirtualAlloc( nGrow );

        MyVirtualLock( pMem, nGrow );

        if ( pMem == ( pVirtualRemainingLocked + nVirtualRemainingLocked )) {

            //
            //  New VM is contiguous with remaining VM.
            //

            nVirtualRemainingLocked += nGrow;
            }
        else {

            //
            //  Wasting nVirtualRemainingLocked bytes at end of old section.
            //

            pVirtualRemainingLocked = pMem;
            nVirtualRemainingLocked = nGrow;
            }
        }

    pMem = pVirtualRemainingLocked;

    pVirtualRemainingLocked += nSize;
    nVirtualRemainingLocked -= nSize;

    LeaveCriticalSection( &MyAllocNeverFreeLockedCritSect );

    return pMem;

    }





PBNODE
INLINE
NewNode(
    PHASH_AND_LENGTH pHashAndLength,
    PVOID            pContext
    )
    {
    PBNODE pNode = MyAllocNeverFreeLocked( sizeof( BNODE ));

    pNode->HashAndLength = *pHashAndLength;
    pNode->pContext      = pContext;

    return pNode;
    }


#ifdef DEBUG
    UINT nMaxBtreeDepth;
#endif


BOOL
LookupOrAddBnode(
    PBNODE           *ppTree,
    PHASH_AND_LENGTH  pHashAndLength,
    PVOID             pContext,
    PBNODE           *ppBnode
    )
    {
    PBNODE pNode = *ppTree;
    int    i;

#ifdef DEBUG
    UINT nDepth = 0;
#endif

    //
    //  Find Hash in Btree.
    //
    //  If found, set *ppBnode = the node and return TRUE.
    //
    //  If not found, add the node, set *ppBnode to the new node, return FALSE
    //

    if ( pNode == NULL ) {
        *ppTree = *ppBnode = NewNode( pHashAndLength, pContext );
        return FALSE;
        }

    for (;;) {

        DEBUGCODE( ++nDepth );

        i = memcmp( &pNode->HashAndLength, pHashAndLength, sizeof( HASH_AND_LENGTH ));

        if ( i == 0 ) {                     // found it
            *ppBnode = pNode;
            return TRUE;                    // found, not added
            }
        else if ( i > 0 ) {                 // go left
            if ( pNode->pLeft ) {
                pNode = pNode->pLeft;
                }
            else {
                *ppBnode = pNode->pLeft = NewNode( pHashAndLength, pContext );
                break;
                }
            }
        else /* ( i < 0 ) */ {              // go right
            if ( pNode->pRight ) {
                pNode = pNode->pRight;
                }
            else {
                *ppBnode = pNode->pRight = NewNode( pHashAndLength, pContext );
                break;
                }
            }
        }

    DEBUGCODE( nMaxBtreeDepth = UMAX( nMaxBtreeDepth, nDepth ));

    return FALSE;                           // did not find, added
    }



RECYCLE_LIST_HEAD EmptyNodeList;
CRITICAL_SECTION  RecycleCritSect;

#ifdef DEBUG
    BOOL RecyclePackageInitialized;
#endif


VOID
InitializeRecyclePackage(
    VOID
    )
    {
    InitializeCriticalSection( &RecycleCritSect );
    DEBUGCODE( RecyclePackageInitialized = TRUE );
    }


PVOID
GetObjectFromRecycleList(
    PRECYCLE_LIST_HEAD ListHead
    )
    {
    PRECYCLE_LIST_NODE Node;
    PVOID Object = NULL;

    ASSERT( RecyclePackageInitialized );

    EnterCriticalSection( &RecycleCritSect );

    Node = ListHead->FirstNode;

    if ( Node != NULL ) {

        ListHead->FirstNode = Node->NextNode;

        Object = Node->Object;

        DEBUGCODE( Node->Object = NULL );

        Node->NextNode = EmptyNodeList.FirstNode;
        EmptyNodeList.FirstNode = Node;

        }

    LeaveCriticalSection( &RecycleCritSect );

    return Object;
    }


VOID
RecycleObjectToList(
    PRECYCLE_LIST_HEAD ListHead,
    PVOID              Object
    )
    {
    PRECYCLE_LIST_NODE Node;

    ASSERT( RecyclePackageInitialized );

    EnterCriticalSection( &RecycleCritSect );

    Node = EmptyNodeList.FirstNode;

    if ( Node != NULL ) {
        EmptyNodeList.FirstNode = Node->NextNode;
        }
    else {
        Node = MyAllocNeverFreeLocked( sizeof( RECYCLE_LIST_NODE ));
        }

    Node->Object        = Object;
    Node->NextNode      = ListHead->FirstNode;
    ListHead->FirstNode = Node;

    LeaveCriticalSection( &RecycleCritSect );
    }


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//  AutoEventAllocator                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG
    LONG nAutoEventsCreated;
    LONG nAutoEventsAvailable;
#endif // DEBUG

RECYCLE_LIST_HEAD RecycledAutoEventList;

HANDLE
AllocateAutoEvent(
    VOID
    )
    {
    HANDLE hEvent;

    hEvent = (HANDLE) GetObjectFromRecycleList( &RecycledAutoEventList );

    if ( hEvent == NULL ) {
         hEvent = MyCreateEvent( FALSE, FALSE );
         DEBUGCODE( InterlockedIncrement( &nAutoEventsCreated ));
         }
    else {
         ASSERT( EventStateUnsignaled( hEvent ));
         DEBUGCODE( InterlockedDecrement( &nAutoEventsAvailable ));
         }

    return hEvent;
    }

VOID
RecycleAutoEvent(
    HANDLE hEvent
    )
    {
    ASSERT( EventStateUnsignaled( hEvent ));

    RecycleObjectToList( &RecycledAutoEventList, (PVOID) hEvent );

    DEBUGCODE( InterlockedIncrement( &nAutoEventsAvailable ));
    }


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//  ManualEventAllocator                                                   //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG
    LONG nManualEventsCreated;
    LONG nManualEventsAvailable;
#endif

RECYCLE_LIST_HEAD RecycledManualEventList;

HANDLE
AllocateManualEvent(
    VOID
    )
    {
    HANDLE hEvent;

    hEvent = (HANDLE) GetObjectFromRecycleList( &RecycledManualEventList );

    if ( hEvent == NULL ) {
         hEvent = MyCreateEvent( TRUE, FALSE );
         DEBUGCODE( InterlockedIncrement( &nManualEventsCreated ));
         }
    else {
         ResetEvent( hEvent );
         DEBUGCODE( InterlockedDecrement( &nManualEventsAvailable ));
         }

    return hEvent;
    }

VOID
RecycleManualEvent(
    HANDLE hEvent
    )
    {
    RecycleObjectToList( &RecycledManualEventList, (PVOID) hEvent );

    DEBUGCODE( InterlockedIncrement( &nManualEventsAvailable ));
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\misc.h ===
#define ISPOWER2( n )     ((((ULONG)(n)) & (((ULONG)(n)) - 1 )) == 0 )

#define _ISALIGN2( x, n ) ((((ULONG)(x)) & (((ULONG)(n)) - 1 )) == 0 )

#define _ROUNDUP2( x, n ) ((((ULONG)(x)) + (((ULONG)(n)) - 1 )) & ~(((ULONG)(n)) - 1 ))

#define ISPOWER2_64( n )     ((((DWORDLONG)(n)) & (((DWORDLONG)(n)) - 1 )) == 0 )

#define _ISALIGN2_64( x, n ) ((((DWORDLONG)(x)) & (((DWORDLONG)(n)) - 1 )) == 0 )

#define _ROUNDUP2_64( x, n ) ((((DWORDLONG)(x)) + (((DWORDLONG)(n)) - 1 )) & ~(((DWORDLONG)(n)) - 1 ))

#define UNREFERENCED( x ) ((x)=(x))

#define _STRINGIZE( x ) #x
#define STRINGIZE( x ) _STRINGIZE( x )

#define SWAP( type, a, b ) { type t = (a); (a) = (b); (b) = (t); }

#ifdef DEBUG
    #define ASSERT( a ) (( a ) ? 1 : Assert( #a, __FILE__, __LINE__ ))
    #define ROUNDUP2( x, n ) ( ASSERT( ISPOWER2( n )) ? _ROUNDUP2((x),(n)) : 0 )
    #define ISALIGN2( x, n ) ( ASSERT( ISPOWER2( n )) ? _ISALIGN2((x),(n)) : 0 )
    #define ROUNDUP2_64( x, n ) ( ASSERT( ISPOWER2_64( n )) ? _ROUNDUP2_64((x),(n)) : 0 )
    #define ISALIGN2_64( x, n ) ( ASSERT( ISPOWER2_64( n )) ? _ISALIGN2_64((x),(n)) : 0 )
    #define DEBUGCODE( code ) code
    #define INLINE
#else
    #define ASSERT( a )
    #define ROUNDUP2( x, n ) _ROUNDUP2((x),(n))
    #define ISALIGN2( x, n ) _ISALIGN2((x),(n))
    #define ROUNDUP2_64( x, n ) _ROUNDUP2_64((x),(n))
    #define ISALIGN2_64( x, n ) _ISALIGN2_64((x),(n))
    #define DEBUGCODE( code )
    #define INLINE __inline
#endif


#if defined(_X86_) || defined(_MIPS_) || defined(_PPC_)
    #define PAGE_SIZE   0x1000
#elif defined(_ALPHA_)
    #define PAGE_SIZE   0x2000
#else
    #error
#endif

unsigned __inline UMIN( unsigned a, unsigned b ) {
    return ( a < b ) ? a : b;
    }

unsigned __inline UMAX( unsigned a, unsigned b ) {
    return ( a > b ) ? a : b;
    }

#define MAX_NAME_LENGTH     256
#define MAX_PATH_LENGTH   65536

#define FX_BLOCKSIZE    0x10000     // 64K transfer size, buffer granularity

#ifndef STATUS_CANCELLED
#define STATUS_CANCELLED ((LONG)0xC0000120)     // from ntstatus.h
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\ntcalls.c ===
#include "precomp.h"
#pragma hdrstop

#ifndef NTSTATUS
    typedef LONG NTSTATUS;                          // from ntdef.h
#endif

#ifndef NT_SUCCESS
    #define NT_SUCCESS(Status) \
                ((NTSTATUS)(Status) >= 0)           // from ntdef.h
#endif

#ifndef IO_STATUS_BLOCK

    typedef struct _IO_STATUS_BLOCK {               // from ntioapi.h
        NTSTATUS Status;
        ULONG Information;
    } IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

#endif

#ifndef FILE_FS_SIZE_INFORMATION

    typedef struct _FILE_FS_SIZE_INFORMATION {      // from ntioapi.h
        LARGE_INTEGER TotalAllocationUnits;
        LARGE_INTEGER AvailableAllocationUnits;
        ULONG SectorsPerAllocationUnit;
        ULONG BytesPerSector;
    } FILE_FS_SIZE_INFORMATION, *PFILE_FS_SIZE_INFORMATION;

#endif // FILE_FS_SIZE_INFORMATION

#ifndef FS_INFORMATION_CLASS

    typedef enum _FSINFOCLASS {                     // from ntioapi.h
        FileFsVolumeInformation = 1,
        FileFsLabelInformation,
        FileFsSizeInformation,
        FileFsDeviceInformation,
        FileFsAttributeInformation,
        FileFsControlInformation,
        FileFsQuotaQueryInformation,
        FileFsQuotaSetInformation,
        FileFsMaximumInformation
    } FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;

#endif

typedef
NTSYSAPI
NTSTATUS
(NTAPI *NTQUERYVOLUMEINFORMATIONFILE)(
    IN  HANDLE               FileHandle,
    OUT PIO_STATUS_BLOCK     IoStatusBlock,
    OUT PVOID                FsInformation,
    IN  ULONG                Length,
    IN  FS_INFORMATION_CLASS FsInformationClass
    );

NTQUERYVOLUMEINFORMATIONFILE NtQueryVolumeInformationFile;

BOOL
MyGetFileSectorInfo(
    IN  HANDLE hFile,
    OUT PULONG pSectorSize,
    OUT PULONG pClusterSize
    )
    {
    FILE_FS_SIZE_INFORMATION FsInfo;
    IO_STATUS_BLOCK          IoStatusBlock;
    NTSTATUS                 Status;

    if ( NtQueryVolumeInformationFile == NULL ) {
        return FALSE;
        }

    Status = NtQueryVolumeInformationFile( hFile,
                                           &IoStatusBlock,
                                           &FsInfo,
                                           sizeof( FsInfo ),
                                           FileFsSizeInformation );

    if ( NT_SUCCESS( Status )) {
        *pSectorSize  = FsInfo.BytesPerSector;
        *pClusterSize = FsInfo.BytesPerSector * FsInfo.SectorsPerAllocationUnit;
        }
    else {
        *pSectorSize  = 0;
        *pClusterSize = 0;
        }

    return NT_SUCCESS( Status );
    }


typedef
BOOL
(APIENTRY *ISDEBUGGERPRESENT)(          // defined in kernel32.dll only on NT
    VOID
    );

ISDEBUGGERPRESENT IsDebuggerPrsent;

BOOL
MyIsDebuggerPresent(
    VOID
    )
    {
    return (( IsDebuggerPrsent != NULL ) ? IsDebuggerPrsent() : FALSE );
    }


BOOL
InitializeNtDllPointers(
    VOID
    )
    {
    HMODULE hKernel32 = GetModuleHandle( "KERNEL32.DLL" );
    HMODULE hNtDll    = GetModuleHandle( "NTDLL.DLL" );

    if ( hKernel32 != NULL ) {
        IsDebuggerPrsent =
            (ISDEBUGGERPRESENT)
            GetProcAddress( hKernel32, "IsDebuggerPresent" );
        }

    if ( hNtDll != NULL ) {
        NtQueryVolumeInformationFile =
            (NTQUERYVOLUMEINFORMATIONFILE)
            GetProcAddress( hNtDll, "NtQueryVolumeInformationFile" );
        }

    return (( NtQueryVolumeInformationFile != NULL ) && ( IsDebuggerPrsent != NULL ));
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\ntcalls.h ===
BOOL
InitializeNtDllPointers(
    VOID
    );

BOOL
MyGetFileSectorInfo(
    IN  HANDLE hFile,
    OUT PULONG pSectorSize,
    OUT PULONG pClusterSize
    );

BOOL
MyIsDebuggerPresent(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\open.h ===
HANDLE
CreateOpenContext(
    UINT nMaxOpenAhead
    );


BOOL
QueueOpenFile(
    HANDLE    hOpenContext,
    LPCWSTR   pszUnicodeName,
    LPCSTR    pszFileName,        // used if pszUnicodeName is NULL
    DWORD     dwSectorSize,
    DWORD     dwBufferSize,
    DWORDLONG dwFileSize,
    UINT      nMaxReadAhead,
    PVOID     pUserContext
    );


HANDLE
WaitForOpen(
    HANDLE  hOpenContext,
    LPCWSTR *pszUnicodeName,
    LPCSTR  *pszFileName,
    PVOID   *ppUserContext
    );


VOID
CloseOpenContext(
    HANDLE hOpenContext
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\open.c ===
#include "precomp.h"
#pragma hdrstop

typedef struct _OPEN_BLOCK
    OPEN_BLOCK,
    *POPEN_BLOCK;

typedef struct _OPENER_CONTEXT
    OPENER_CONTEXT,
    *POPENER_CONTEXT;

struct _OPEN_BLOCK {
    POPEN_BLOCK     pNextBlock;             // must be first member
    LPCWSTR         pszUnicodeName;
    LPCSTR          pszFileName;            // used if pszUnicodeName is NULL
    DWORD           dwBufferSize;
    DWORD           dwReadAhead;
    PVOID           pUserContext;
    HANDLE          hReadContext;
    DWORDLONG       dwlFileSize;
    };

struct _OPENER_CONTEXT {
    PVOID          FakeEmptyHeadNode;       // assumes pNext is first member
    POPEN_BLOCK    pOpenListHead;
    POPEN_BLOCK    pOpenListTail;
    HANDLE         hSemCanStartNewOpen;
    HANDLE         hSemQueuedOpens;
    HANDLE         hEventAllReadsIssued;
    HANDLE         hEventQueueEmpty;
    };


RECYCLE_LIST_HEAD RecycledOpenerContextList;

POPENER_CONTEXT
AllocateOpenerContext(
    VOID
    )
    {
    POPENER_CONTEXT pContext;

    pContext = GetObjectFromRecycleList( &RecycledOpenerContextList );

    if ( pContext == NULL ) {
         pContext = MyAllocNeverFreeLocked( sizeof( OPENER_CONTEXT ));
         }
    else {
         ZeroMemory( pContext, sizeof( OPENER_CONTEXT ));
         }

    return pContext;
    }

VOID
INLINE
RecycleOpenerContext(
    POPENER_CONTEXT pContext
    )
    {
    RecycleObjectToList( &RecycledOpenerContextList, pContext );
    }


RECYCLE_LIST_HEAD RecycledOpenBlockList;

POPEN_BLOCK
AllocateOpenBlock(
    VOID
    )
    {
    POPEN_BLOCK Block;

    Block = GetObjectFromRecycleList( &RecycledOpenBlockList );

    if ( Block == NULL ) {
         Block = MyAllocNeverFreeLocked( sizeof( OPEN_BLOCK ));
         }
    else {
         ZeroMemory( Block, sizeof( OPEN_BLOCK ));
         }

    return Block;
    }

VOID
INLINE
RecycleOpenBlock(
    POPEN_BLOCK pBlock
    )
    {
    RecycleObjectToList( &RecycledOpenBlockList, pBlock );
    }



HANDLE
CreateOpenContext(
    UINT nMaxOpenAhead
    )
    {
    POPENER_CONTEXT pContext;

    pContext                       = AllocateOpenerContext();
    pContext->pOpenListHead        = (POPEN_BLOCK) &pContext->FakeEmptyHeadNode;
    pContext->pOpenListTail        = (POPEN_BLOCK) &pContext->FakeEmptyHeadNode;
    pContext->hSemCanStartNewOpen  = MyCreateSemaphore( nMaxOpenAhead );
    pContext->hSemQueuedOpens      = MyCreateSemaphore( 0 );
    pContext->hEventQueueEmpty     = AllocateAutoEvent();
    pContext->hEventAllReadsIssued = AllocateAutoEvent();

    SetEvent( pContext->hEventAllReadsIssued );

    return (HANDLE) pContext;
    }


BOOL
QueueOpenFile(
    HANDLE    hOpenContext,
    LPCWSTR   pszUnicodeName,
    LPCSTR    pszFileName,
    DWORD     dwSectorSize,
    DWORD     dwBufferSize,
    DWORDLONG dwlFileSize,
    UINT      nMaxReadAhead,
    PVOID     pUserContext
    )
    {
    POPENER_CONTEXT pContext = (POPENER_CONTEXT) hOpenContext;
    POPEN_BLOCK     pBlock;

    pBlock                 = AllocateOpenBlock();
    pBlock->pNextBlock     = NULL;
    pBlock->pszUnicodeName = pszUnicodeName;
    pBlock->pszFileName    = pszFileName;
    pBlock->dwBufferSize   = dwBufferSize;
    pBlock->dwlFileSize    = dwlFileSize;
    pBlock->dwReadAhead    = nMaxReadAhead;
    pBlock->pUserContext   = pUserContext;

    WaitForSingleObject( pContext->hSemCanStartNewOpen,  INFINITE );
    WaitForSingleObject( pContext->hEventAllReadsIssued, INFINITE );

    if ( bGlobalErrorExitInProgress )   // don't issue new open
        return FALSE;

    pBlock->hReadContext = CreateReadContext( pszUnicodeName,
                                              pszFileName,
                                              NULL,
                                              dwSectorSize,
                                              dwBufferSize,
                                              nMaxReadAhead,
                                              pContext->hEventAllReadsIssued,
                                              0,
                                              dwlFileSize );

    if ( pBlock->hReadContext == NULL ) {

        //
        //  Failed to open file, so clean up to allow continue.
        //

        SetEvent( pContext->hEventAllReadsIssued );
        ReleaseSemaphore( pContext->hSemCanStartNewOpen, 1, NULL );
        RecycleOpenBlock( pBlock );
        return FALSE;

        }

    pContext->pOpenListTail->pNextBlock = pBlock;
    pContext->pOpenListTail             = pBlock;

    ReleaseSemaphore( pContext->hSemQueuedOpens, 1, NULL );
    return TRUE;
    }


HANDLE
WaitForOpen(
    HANDLE  hOpenContext,
    LPCWSTR *pszUnicodeName,
    LPCSTR  *pszFileName,
    PVOID   *ppUserContext
    )
    {
    POPENER_CONTEXT pContext = (POPENER_CONTEXT) hOpenContext;
    POPEN_BLOCK pBlock;

    WaitForSingleObject( pContext->hSemQueuedOpens, INFINITE );

    pBlock = pContext->pOpenListHead->pNextBlock;

    if ( pContext->pOpenListHead != (POPEN_BLOCK)&pContext->FakeEmptyHeadNode )
        RecycleOpenBlock( pContext->pOpenListHead );

    if ( pBlock == NULL ) {
        SetEvent( pContext->hEventQueueEmpty );
        return NULL;
        }

    pContext->pOpenListHead = pBlock;

    ReleaseSemaphore( pContext->hSemCanStartNewOpen, 1, NULL );

    if ( pszUnicodeName )
        *pszUnicodeName = pBlock->pszUnicodeName;

    if ( pszFileName )
        *pszFileName = pBlock->pszFileName;

    if ( ppUserContext )
        *ppUserContext = pBlock->pUserContext;

    return pBlock->hReadContext;

    }


VOID
CloseOpenContext(
    HANDLE hOpenContext
    )
    {
    POPENER_CONTEXT pContext = (POPENER_CONTEXT) hOpenContext;

    ReleaseSemaphore( pContext->hSemQueuedOpens, 1, NULL );
    WaitForSingleObject( pContext->hEventQueueEmpty, INFINITE );

    CloseHandle( pContext->hSemCanStartNewOpen );
    CloseHandle( pContext->hSemQueuedOpens );
    RecycleAutoEvent( pContext->hEventQueueEmpty );
    ResetEvent( pContext->hEventAllReadsIssued );
    RecycleAutoEvent( pContext->hEventAllReadsIssued );

    RecycleOpenerContext( pContext );
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\precomp.h ===
// turn these on for lots of debug stuff

/*
#define DEBUG
#define _DEBUG
#define UDF_DBG
*/

#define NONAMELESSUNION

#pragma warning( disable: 4001 4035 4115 4200 4201 4204 4209 4214 4514 4699)

#if defined(_M_IX86)
    #if !defined(_X86_)
        #define _X86_
    #endif
#elif defined(_M_MRX000)
    #if !defined(_MIPS_)
        #define _MIPS_
    #endif
#elif defined(_M_ALPHA)
    #if !defined(_ALPHA_)
        #define _ALPHA_
    #endif
#elif defined(_M_PPC)
    #if !defined(_PPC_)
        #define _PPC_
    #endif
#else
    #error "unrecognized platform"
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#ifndef WIN32
#define WIN32 0x0400
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif

#include <excpt.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>

#include <windef.h>
#include <winbase.h>
#include <wincon.h>
#include <winnls.h>
#include <time.h>

#include <rpc.h>

#pragma warning( disable: 4001 4035 4115 4200 4201 4204 4209 4214 4514 4699 )

#ifdef _PPC_

    //
    //  Stupid Motorola PPC compiler complains about "local variable
    //  may be used without having been initialized" when it is simply
    //  not possible in the given code path.  For PPC, we'll disable
    //  this 4701 warning.
    //

    #pragma warning( disable: 4701 )

#endif // _PPC_

#ifndef try
    #define try     __try
    #define except  __except
    #define finally __finally
    #define leave   __leave
#endif

#ifndef strupr
    #define strupr _strupr
#endif

#ifndef stricmp
    #define stricmp _stricmp
#endif

#ifndef wcsnicmp
    #define wcsnicmp _wcsnicmp
#endif

#include "misc.h"
#include "..\crc\crc.h"
#include "..\md5\md5.h"
#include "..\rpcsig\rpcsigx.h"
#include "..\rpcsig\rpcsig.h"
#include "error.h"
#include "heap.h"
#include "buffer.h"
#include "thread.h"
#include "reader.h"
#include "writer.h"
#include "open.h"
#include "sign.h"
#include "ntcalls.h"
#include "iso13346.h"
#include "cdimage.h"
#include "udfbridg.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\reader.h ===
//
//  Following codes are returned by WaitForRead
//

#define STATUS_SUCCESS     0x00000000   //  Succeeded, more data remaining
#define STATUS_END_OF_FILE 0xC0000011   //  Succeeded, but no more remaining
                                        //  Any other value is GLE error code


HANDLE
CreateReadContext(
    LPCWSTR   pUnicodeName,             // primary filename to open if hFile == NULL
    LPCSTR    pFileName,                // secondary filename to open if hFile == NULL
    HANDLE    hFile,                    // optional (OVERLAPPED)
    DWORD     dwSectorSize,             // optional (queried from system)
    DWORD     dwBufferSize,             // optional (defaults to sector size)
    DWORD     nMaxReadAhead,            // optional (defaults to no maximum)
    HANDLE    hEventAllReadsIssued,     // optional (signaled when all reads issued)
    DWORDLONG dwlInitialOffset,         // optional (defaults to begin of file)
    DWORDLONG dwlFileSize               // optional (defaults to GetFileSize())
    );


DWORD
WaitForRead(
    HANDLE hContext,                //  From CreateReadContext
    PVOID  *pBuffer,                //  Returned buffer (need to ReleaseBuffer)
    DWORD  *dwSize                  //  Valid size of data in pBuffer
    );


VOID
StopIssuingReads(                   //  Don't issue any more reads, but don't
    HANDLE hContext                 //  wait on anything (like close does).
    );


VOID
CloseReadContext(
    HANDLE hContext,                //  Cancels outstanding reads, cleans up
    BOOL   bCloseFile               //  close file handle too?
    );


HANDLE
GetFileHandleFromReadContext(       //  OVERLAPPED, NO_BUFFERING semantics
    HANDLE hContext
    );


DWORDLONG
GetFileSizeFromReadContext(
    HANDLE hContext
    );


DWORDLONG
GetFileSize64(
    IN HANDLE hFile
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\thread.c ===
#include "precomp.h"
#pragma hdrstop



typedef struct _THREAD_CONTROL {
    HANDLE          hThread;
    HANDLE          hEventStartThread;
    HANDLE          hEventThreadReady;
    THREAD_FUNCTION pUserFunction;
    LPVOID          pUserParam;
    } THREAD_CONTROL, *PTHREAD_CONTROL;


PTHREAD_CONTROL ThreadArray;
PHANDLE         WaitArray;
UINT            nThreads;


DWORD WINAPI ThreadPool( LPVOID lpvParam ) {

    PTHREAD_CONTROL pThreadControl = lpvParam;

    for (;;) {
        SetEvent( pThreadControl->hEventThreadReady );
        WaitForSingleObject( pThreadControl->hEventStartThread, INFINITE );
        pThreadControl->pUserFunction( pThreadControl->pUserParam );
        }

    }


void InitializeThreadPool( UINT nMaxThreads ) {

    DWORD dwTid;
    UINT i;

    ASSERT( nMaxThreads > 0 );

    nThreads    = nMaxThreads;
    ThreadArray = MyAllocNeverFreeLocked( nThreads * sizeof( THREAD_CONTROL ));
    WaitArray   = MyAllocNeverFreeLocked( nThreads * sizeof( HANDLE ));

    for ( i = 0; i < nThreads; i++ ) {
        ThreadArray[ i ].hEventStartThread = AllocateAutoEvent();
        ThreadArray[ i ].hEventThreadReady = AllocateAutoEvent();
        WaitArray[ i ] = ThreadArray[ i ].hEventThreadReady;
        ThreadArray[ i ].hThread = CreateThread( NULL, 0, ThreadPool, &ThreadArray[ i ], 0, &dwTid );
        if ( ThreadArray[ i ].hThread == NULL ) {
            ErrorExit( GETLASTERROR, "CreateThread failed\r\n" );
            }
        }
    }


VOID StartThread( THREAD_FUNCTION pFunction,
                  PVOID           pParam,
                  INT             nPriority ) {

    DWORD dwIndex;

    dwIndex = WaitForMultipleObjects( nThreads, WaitArray, FALSE, INFINITE )
              - WAIT_OBJECT_0;

    if ( dwIndex >= nThreads ) {
        ErrorExit( GETLASTERROR, "WaitForMultipleObjects failed\r\n" );
        }

    ThreadArray[ dwIndex ].pUserFunction = pFunction;
    ThreadArray[ dwIndex ].pUserParam    = pParam;
    SetThreadPriority( ThreadArray[ dwIndex ].hThread, nPriority );
    SetEvent( ThreadArray[ dwIndex ].hEventStartThread );

    }


#ifdef DONTCOMPILE  // let process termination clean up the thread pool

void CleanUpThreadPool( BOOL bWaitForThreads ) {

    UINT i;

    if ( bWaitForThreads ) {
        WaitForMultipleObjects( nThreads, WaitArray, TRUE, INFINITE );
        }

    for ( i = 0; i < nThreads; i++ ) {
        TerminateThread(  ThreadArray[ i ].hThread, 0 );
        CloseHandle(      ThreadArray[ i ].hThread );
        RecycleAutoEvent( ThreadArray[ i ].hEventStartThread );
        RecycleAutoEvent( ThreadArray[ i ].hEventThreadReady );
        }

    // MyHeapFree( ThreadArray );
    // MyHeapFree( WaitArray );

    nThreads = 0;
    }

#endif // DONTCOMPILE

HANDLE MyCreateEvent( BOOL bManualReset, BOOL bInitialState ) {

    //
    //  Create an unnamed event object with no security descriptor.
    //  Exit app if fails.
    //

    HANDLE hEvent = CreateEvent( NULL, bManualReset, bInitialState, NULL );

    if ( hEvent == NULL ) {
        ErrorExit( GETLASTERROR, "CreateEvent failed\r\n" );
        }

    return hEvent;
    }


HANDLE MyCreateSemaphore( LONG InitialCount ) {

    HANDLE hSem = CreateSemaphore( NULL, InitialCount, 0x7FFFFFFF, NULL );

    if ( hSem == NULL ) {
        ErrorExit( GETLASTERROR, "CreateSemaphore failed\r\n" );
        }

    return hSem;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\udfbridg.h ===
typedef struct  UDF_LVID_IMPUSE {
    REGID       riImplementID;          // Implementation ID
    ULONG       ulNumberOfFiles;
    ULONG       ulNumberOfDirs;
    USHORT      usMinUDFReadRev;
    USHORT      usMinUDFWriteRev;
    USHORT      usMaxUDFWriteRev;
} UDF_LVID_IMPUSE, *PUDF_LVID_IMPUSE;       
// this needs to be at least 46 bytes

extern TIMESTAMP GlobalNsrTimeStamp;
extern short     NsrLocalTimeBias;

VOID
MakeNsrTimeStampFromFileTime(
    OUT PTIMESTAMP pTimeStamp,
    IN  FILETIME   ftFileTime
    );

extern BOOL bEncodeUdf;
extern BOOL bEncodeOnlyUdf;
extern BOOL bUdfEmbedData;
extern BOOL bUdfSparse;
extern BOOL bUdfEmbedFID;
extern BOOL bUdfUseLongADs;
extern BOOL bUdfUseRandomExtents;
extern BOOL bUdfVideoZone;
extern BOOL bUdf8BitFileNames;

extern DWORD gdwSpaceSaved;

#define XA_LENGTH       (56)              // == 24 + 20 + 12 (XA Header Descriptor + File Times XA format + one timestamp)
#define ICBFILE_EXTENT_OFFSET   (176+(XA_LENGTH))   //176+56 = 232

void SetCurrentUDFVersion(USHORT nVer);

VOID ComputeUDFDirectorySizes( VOID );
VOID AssignUDFDirectoryBlockNumbers( VOID );
VOID ComputeUDFPartitionLength( VOID );
VOID WriteUDFAnchorAndVDS( VOID );
VOID WriteUDFDirectories( VOID );
VOID WriteBEA01Descriptor( ULONG SectorNumber );
VOID WriteTEA01Descriptor( ULONG SectorNumber );
VOID WriteNSRDescriptor( ULONG SectorNumber );


BOOL MakeFileExtent(PDIRENTRY pFile, DWORD* pdwNextFreeBlock, DWORD dwIcbBlock, HANDLE hReadContext);
DWORD GetIcbBlockCount();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\reader.c ===
#include "precomp.h"
#pragma hdrstop


//
//  Ideas:
//
//  * Mechanism to cancel outstanding and remaining reads.
//



typedef struct _READ_BLOCK
    READ_BLOCK,
    *PREAD_BLOCK;

typedef struct _READER_CONTEXT
    READER_CONTEXT,
    *PREADER_CONTEXT;

struct _READ_BLOCK {
    PREAD_BLOCK     pNextBlock;             // must be first member
    PVOID           pBuffer;
    DWORD           dwSize;
    DWORD           dwStatus;
    LPOVERLAPPED    pOverlapped;
    };

struct _READER_CONTEXT {
    HANDLE         hFile;
    LPCWSTR        pUnicodeName;
    LPCSTR         pFileName;               // used if pUnicodeName is NULL
    DWORDLONG      dwlFileSize;
    DWORD          dwBufferSize;
    DWORD          dwSectorSize;
    DWORDLONG      dwlOffset;               // offset to start reading
    PVOID          FakeEmptyHeadNode;       // assumes pNext is first member
    PREAD_BLOCK    pReadListHead;
    PREAD_BLOCK    pReadListTail;
    HANDLE         hSemCanStartNewRead;
    HANDLE         hSemQueuedReads;
    HANDLE         hEventThreadFinished;
    HANDLE         hEventAllReadsIssued;
    HANDLE         hThreadReader;
    BOOL           bStopReading;
    };


RECYCLE_LIST_HEAD RecycledReaderContextList;

PREADER_CONTEXT
AllocateReaderContext(
    VOID
    )
    {
    PREADER_CONTEXT pContext;

    pContext = GetObjectFromRecycleList( &RecycledReaderContextList );

    if ( pContext == NULL ) {
         pContext = MyAllocNeverFreeLocked( sizeof( READER_CONTEXT ));
         }
    else {
         ZeroMemory( pContext, sizeof( READER_CONTEXT ));
         }

    return pContext;
    }

VOID
INLINE
RecycleReaderContext(
    PREADER_CONTEXT pContext
    )
    {
    RecycleObjectToList( &RecycledReaderContextList, pContext );
    }


RECYCLE_LIST_HEAD RecycledReadBlockList;

PREAD_BLOCK
AllocateReadBlock(
    VOID
    )
    {
    PREAD_BLOCK Block;

    Block = GetObjectFromRecycleList( &RecycledReadBlockList );

    if ( Block == NULL ) {
         Block = MyAllocNeverFreeLocked( sizeof( READ_BLOCK ));
         }
    else {
         ZeroMemory( Block, sizeof( READ_BLOCK ));
         }

    return Block;
    }

VOID
INLINE
RecycleReadBlock(
    PREAD_BLOCK pBlock
    )
    {
    RecycleObjectToList( &RecycledReadBlockList, pBlock );
    }



VOID
ReaderThread(
    PVOID pParam
    )
    {
    PREADER_CONTEXT pContext     = pParam;
    HANDLE          hFile        = pContext->hFile;
    DWORD           dwSectorSize = pContext->dwSectorSize;
    DWORD           dwBufferSize = pContext->dwBufferSize;
    DWORDLONG       dwlOffset    = pContext->dwlOffset;
    DWORDLONG       dwlFileSize  = pContext->dwlFileSize;
    DWORDLONG       dwlRemaining = dwlFileSize - dwlOffset;
    DWORD           dwReadSize;
    DWORD           dwExpected;
    DWORD           dwActual;
    BOOL            bSuccess;
    PREAD_BLOCK     pBlock;


    while ( dwlRemaining ) {

        WaitForSingleObject( pContext->hSemCanStartNewRead, INFINITE );

        if ( pContext->bStopReading )
            break;

        if ( dwlRemaining >= dwBufferSize ) {
            dwReadSize = dwBufferSize;
            dwExpected = dwBufferSize;
            }
        else {
            dwReadSize = ROUNDUP2( dwlRemaining, dwSectorSize );
            dwExpected = (DWORD)dwlRemaining;
            }

        dwlRemaining -= dwExpected;

        pBlock                          = AllocateReadBlock();
        ASSERT(pBlock != NULL);
        pBlock->pBuffer                 = AllocateBuffer( dwReadSize, FALSE );
        ASSERT(pBlock->pBuffer != NULL);
        pBlock->pOverlapped             = AllocateOverlappedWithEvent();
        ASSERT(pBlock->pOverlapped != NULL);
        pBlock->pOverlapped->Offset     = (DWORD)( dwlOffset );
        pBlock->pOverlapped->OffsetHigh = (DWORD)( dwlOffset >> 32 );
        pBlock->dwSize                  = dwExpected;
        pBlock->dwStatus                = dwlRemaining ? 0 : STATUS_END_OF_FILE;
        ASSERT(pBlock->pOverlapped->hEvent != NULL);

#ifdef UDF_DBG
        ASSERT(dwReadSize <= 2048);
        ASSERT(dwExpected <= 2048);
#endif

        if ( bGlobalErrorExitInProgress )   // don't issue new read
        {
            return;
        }

        bSuccess = ReadFile( hFile,
                             pBlock->pBuffer,
                             dwReadSize,
                             &dwActual,
                             pBlock->pOverlapped );

        if ( bSuccess ) {

            //
            //  The read completed synchronously, so we'll fill
            //  in the overlapped structure to mimic overlapped
            //  behavior so the completion routine doesn't have
            //  to know the difference.
            //

            pBlock->pOverlapped->Internal     = 0;          // STATUS_SUCCESS
            pBlock->pOverlapped->InternalHigh = dwActual;   // actually read

            //
            //  Assume here that even though the ReadFile completed
            //  synchronously, it was kind enough to set the overlapped
            //  event to signaled state.
            //

            }

        else if ( GetLastError() != ERROR_IO_PENDING ) {
            ErrorExit( GETLASTERROR,
                       pContext->pUnicodeName ?
                            "ReadFile failed (%S, off=%I64X len=%X status=%X)\r\n" :
                            "ReadFile failed (%s, off=%I64X len=%X status=%X)\r\n",
                       pContext->pUnicodeName ?
                            (PVOID) pContext->pUnicodeName :
                            (PVOID) pContext->pFileName,
                       dwlOffset,
                       dwReadSize,
                       pBlock->pOverlapped->Internal
                     );
            }

        //
        //  Now queue this read block on the read list and bump the
        //  reader semaphore to reflect the valid size of the list
        //

        pContext->pReadListTail->pNextBlock = pBlock;
        pContext->pReadListTail             = pBlock;

        ReleaseSemaphore( pContext->hSemQueuedReads, 1, NULL );

        dwlOffset += dwReadSize;

        }

    //
    //  Finished reading file.  Queue a null read block to indicate EOF.
    //

    pContext->pReadListTail->pNextBlock = NULL;
    ReleaseSemaphore( pContext->hSemQueuedReads, 1, NULL );
    if ( pContext->hEventAllReadsIssued != NULL )
        SetEvent( pContext->hEventAllReadsIssued );
    SetEvent( pContext->hEventThreadFinished );
    }


HANDLE
CreateReadContext(
    LPCWSTR   pUnicodeName,             // primary name
    LPCSTR    pFileName,                // secondary name (if primary is NULL)
    HANDLE    hFile,                    // optional
    DWORD     dwSectorSize,             // optional
    DWORD     dwBufferSize,             // optional
    DWORD     nMaxReadAhead,            // optional
    HANDLE    hEventAllReadsIssued,     // optional
    DWORDLONG dwlInitialOffset,         // optional
    DWORDLONG dwlFileSize               // optional
    )
    {
    PREADER_CONTEXT pContext;
    DWORD dwShare;

    if(bOpenReadWrite)
        dwShare=FILE_SHARE_READ | FILE_SHARE_WRITE;
    else
        dwShare=FILE_SHARE_READ;

    if ( hFile == NULL ) {

        if ( pUnicodeName ) {

            hFile = CreateFileW( pUnicodeName,
                                 GENERIC_READ,
                                 dwShare,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED,
                                 NULL );
            }

        else {

            hFile = CreateFileA( pFileName,
                                 GENERIC_READ,
                                 dwShare,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED,
                                 NULL );

            if (( hFile == INVALID_HANDLE_VALUE ) &&
                ( GetLastError() == ERROR_FILE_NOT_FOUND )) {

                WarnFailedSourceOpen(
                    0,
                    "Could not open file \"%s\"\r\n"
                    "The specific error code (file not found) could indicate that the file was\r\n"
                    "deleted by another process after the directory scan, or it could indicate\r\n"
                    "that the filename contains some Unicode characters that do not have a\r\n"
                    "corresponding %s character mapping (try %susing -c, or use -j1 or -j2\r\n"
                    "for full Unicode names).\r\n",
                    pFileName,
                    bUseAnsiFileNames ? "ANSI" : "OEM",
                    bUseAnsiFileNames ? "not " : ""
                    );

                return NULL;
                }
            }

        if ( hFile == INVALID_HANDLE_VALUE ) {

            WarnFailedSourceOpen(
                GETLASTERROR,
                pUnicodeName ?
                    "Could not open file \"%S\"\r\n" :
                    "Could not open file \"%s\"\r\n",
                pUnicodeName ?
                    (PVOID) pUnicodeName :
                    (PVOID) pFileName
                );

            return NULL;

            }
        }

    if ( dwSectorSize == 0 ) {

        dwSectorSize = GetSectorSize( hFile, pUnicodeName, pFileName );
        ASSERT( dwSectorSize != 0 );

        }

    ASSERT( ISPOWER2( dwSectorSize ));
    ASSERT( dwSectorSize >= 512 );

    if ( dwBufferSize == 0 )
        dwBufferSize = dwSectorSize;

    ASSERT( ISALIGN2( dwBufferSize, dwSectorSize ));

    if ( nMaxReadAhead == 0 )
        nMaxReadAhead = 0x7FFF0000;

    if ( dwlFileSize == 0 )
        dwlFileSize = GetFileSize64( hFile );

    ASSERT( dwlFileSize != 0xFFFFFFFF );
    ASSERT( dwlFileSize != 0 );
    ASSERT( dwlFileSize > dwlInitialOffset );
    ASSERT( dwlFileSize == GetFileSize64(hFile));

    if ( dwlFileSize == 0 )
        return NULL;

    if(dwlFileSize != GetFileSize64(hFile))
    {

        if ( bContinueAfterFailedSourceOpen )
        {

            printf("%s: File size doesn't match orignal scanned size\r\n",
                   pFileName);
        }
        else
        {
            ErrorExit(0,
                      "%s: File size doesn't match orignal scanned size\r\n",
                      pFileName);
        }
    }

    pContext                       = AllocateReaderContext();
    pContext->hFile                = hFile;
    pContext->pUnicodeName         = pUnicodeName;
    pContext->pFileName            = pFileName;
    pContext->dwlFileSize          = dwlFileSize;
    pContext->dwlOffset            = dwlInitialOffset;
    pContext->dwBufferSize         = dwBufferSize;
    pContext->dwSectorSize         = dwSectorSize;
    pContext->pReadListHead        = (PREAD_BLOCK) &pContext->FakeEmptyHeadNode;
    pContext->pReadListTail        = (PREAD_BLOCK) &pContext->FakeEmptyHeadNode;
    pContext->hSemCanStartNewRead  = MyCreateSemaphore( nMaxReadAhead );
    pContext->hSemQueuedReads      = MyCreateSemaphore( 0 );
    pContext->hEventThreadFinished = AllocateAutoEvent();
    pContext->hEventAllReadsIssued = hEventAllReadsIssued;
    pContext->bStopReading         = FALSE;

    StartThread( ReaderThread, pContext, THREAD_PRIORITY_HIGHEST );

    return (HANDLE) pContext;
    }


DWORD
WaitForRead(
    HANDLE hContext,
    PVOID  *pBuffer,
    DWORD  *dwSize
    )
    {
    PREADER_CONTEXT pContext = (PREADER_CONTEXT) hContext;
    PREAD_BLOCK pBlock;
    DWORD dwActual;
    DWORD dwStatus;

    //
    //  Wait for ReaderThread to enqueue an active read.
    //

    WaitForSingleObject( pContext->hSemQueuedReads, INFINITE );

    //
    //  Now pReadListHead->pNextBlock is valid.  Unless pReadListHead still
    //  points to our FakeEmptyHeadNode, we can now free the old block that
    //  was at the head of the list.
    //

    pBlock = pContext->pReadListHead->pNextBlock;

    ASSERT(pBlock != NULL);
    ASSERT(pBlock->pOverlapped != NULL);
    ASSERT(pBlock->pOverlapped->hEvent != NULL);

    if ( pContext->pReadListHead != (PREAD_BLOCK)&pContext->FakeEmptyHeadNode )
        RecycleReadBlock( pContext->pReadListHead );

    pContext->pReadListHead = pBlock;

    //
    //  GetOverlappedResult will wait for the hEvent to be signaled
    //  indicating the read has been completed.
    //

    //
    //  Rather than letting GetOverlappedResult do the wait, do it
    //  ourselves and then tell GetOverlappedResult not to wait.
    //  GetOverlappedResult will not do the wait call if the i/o
    //  has already completed, so it might leave our event signaled.
    //

    ASSERT(pBlock != NULL);
    ASSERT(pBlock->pOverlapped != NULL);
    ASSERT(pBlock->pOverlapped->hEvent != NULL);

    WaitForSingleObject( pBlock->pOverlapped->hEvent, INFINITE );

    if ( ! GetOverlappedResult( NULL, pBlock->pOverlapped, &dwActual, FALSE )) {
        ErrorExit(
            GETLASTERROR,
            pContext->pUnicodeName ?
                "ReadFile/GetOverlappedResult failed (%S, off=%I64X len=%X status=%X)\r\n" :
                "ReadFile/GetOverlappedResult failed (%s, off=%I64X len=%X status=%X)\r\n",
            pContext->pUnicodeName ?
                (PVOID) pContext->pUnicodeName :
                (PVOID) pContext->pFileName,
            ((DWORDLONG)( pBlock->pOverlapped->OffsetHigh ) << 32 ) | pBlock->pOverlapped->Offset,
            ROUNDUP2( pBlock->dwSize, pContext->dwSectorSize ),
            pBlock->pOverlapped->Internal
            );
        }

    *dwSize  = dwActual;
    *pBuffer = pBlock->pBuffer;
    dwStatus = pBlock->dwStatus;

    ASSERT((  dwActual == pBlock->dwSize ) ||
           (( dwActual >= pBlock->dwSize ) && ( dwStatus != 0 )));

    //
    //  Allow the ReaderThread to begin its next read.
    //

    ReleaseSemaphore( pContext->hSemCanStartNewRead, 1, NULL );

    //
    //  No longer need this overlapped structure or associated event.
    //

    RecycleOverlappedWithEvent( pBlock->pOverlapped );

    //
    //  Leave pBlock->pBuffer active -- caller must ReleaseBuffer
    //  when done with it.
    //
    //  Also must leave pBlock at the pReadListHead postition so
    //  the ReaderThread can update its pNextBlock member.  We'll
    //  free it next time through.
    //

    // BUGBUG
//    printf("WaitForRead - Memory = %p\r\n",*pBuffer);
    return dwStatus;

    }


HANDLE
GetFileHandleFromReadContext(
    HANDLE hContext
    )
    {
    return ((PREADER_CONTEXT) hContext )->hFile;
    }


VOID
StopIssuingReads(
    HANDLE hContext
    )
    {
    ((PREADER_CONTEXT) hContext )->bStopReading = TRUE;
    }


VOID
CloseReadContext(
    HANDLE hContext,
    BOOL   bCloseFile
    )
    {
    PREADER_CONTEXT pContext = (PREADER_CONTEXT) hContext;
    PREAD_BLOCK     pBlock;
    PREAD_BLOCK     pNext;
    DWORD           dwActual;

    //
    //  Tell ReaderThread to stop issuing new reads and release
    //  ReaderThread to detect this in case it's blocked.
    //

    pContext->bStopReading = TRUE;

    ReleaseSemaphore( pContext->hSemCanStartNewRead, 1, NULL );

    //
    //  Now wait for reader thread to exit.  Once it exits, we
    //  know the ReadList is static so we can wait/close all
    //  the outstanding reads.
    //

    WaitForSingleObject( pContext->hEventThreadFinished, INFINITE );

    pBlock = pContext->pReadListHead;

    if ( pBlock == (PREAD_BLOCK)&pContext->FakeEmptyHeadNode ) {
        pBlock = pBlock->pNextBlock;
        }
    else {

        //
        //  Head node already has overlapped and event recycled,
        //  so just need to recycle the block itself.
        //

        pNext = pBlock->pNextBlock;
        RecycleReadBlock( pBlock );
        pBlock = pNext;
        }

    while ( pBlock ) {
        pNext = pBlock->pNextBlock;
        WaitForSingleObject( pBlock->pOverlapped->hEvent, INFINITE );
        GetOverlappedResult( NULL, pBlock->pOverlapped, &dwActual, FALSE );
        ReleaseBuffer( pBlock->pBuffer );
        RecycleOverlappedWithEvent( pBlock->pOverlapped );
        RecycleReadBlock( pBlock );
        pBlock = pNext;
        }

    RecycleAutoEvent( pContext->hEventThreadFinished );
    CloseHandle( pContext->hSemCanStartNewRead );
    CloseHandle( pContext->hSemQueuedReads );

    if ( bCloseFile )
        CloseHandle( pContext->hFile );

    RecycleReaderContext( pContext );

    }


DWORDLONG
GetFileSizeFromReadContext(
    HANDLE hContext
    )
    {
    return ((PREADER_CONTEXT) hContext )->dwlFileSize;
    }


DWORDLONG
GetFileSize64(
    IN HANDLE hFile
    )
    {
    DWORD dwFileSizeHigh = 0;
    DWORD dwFileSizeLow  = GetFileSize( hFile, &dwFileSizeHigh );

    if ( dwFileSizeLow == 0xFFFFFFFF ) {
        if ( GetLastError() != NO_ERROR ) {
            ErrorExit( GETLASTERROR, "GetFileSize failed\r\n" );
            }
        }

    return ((DWORDLONG)dwFileSizeHigh << 32 ) | dwFileSizeLow;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\sign.c ===
#include "precomp.h"
#pragma hdrstop

LPSTR SignatureRpcEndpointName;
LPSTR SignatureRpcEndpointBindingString;

RPC_BINDING_HANDLE SignatureRpcBindingHandle;

LPSTR SignatureDescription;

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t cBytes) {
    return((void __RPC_FAR *) malloc(cBytes));
    }

void __RPC_USER MIDL_user_free(void __RPC_FAR * p) {
    free(p);
    }


BOOL
ConnectToSignatureServer(
    LPSTR LoggingText
    )
    {
    RPC_STATUS RpcStatus;
    PCHAR p, q;

    //
    //  Connect to RPC signature server now to make sure we have
    //  sufficient permissions before wasting time reading files
    //  and writing the image.
    //
    //  If SignatureRpcEndpointName contains a '[' character, assume
    //  the entire string is a fully composed RPC binding string (the
    //  user knows what he/she is doing).  If no '[' character, look
    //  for ':' character to split server name and endpoint name.  If
    //  no ':' exists, blow up; otherwise, expect string to be of form
    //  "ServerName:EndpointName" and create a valid RPC binding string
    //  from that.
    //

    q = strchr( SignatureRpcEndpointName, '[' );
    p = strchr( SignatureRpcEndpointName, ':' );

    if ( p == NULL ) {

        //
        //  Either form should have colon in it.
        //

        ErrorExit(
            0,
            "ERROR: RPC signature server and endpoint must be specified in the form...\r\n\r\n"
            "           \"-sServerName:EndPointName\"\r\n\r\n"
            "       ...or as a fully qualified RPC binding string of the form...\r\n\r\n"
            "           \"-sProtSeq:ServerName[EndPoint,Options]\r\n\r\n"
            );
        }

    if ( q != NULL ) {

        //
        //  Assume string is valid RPC binding string, so simply point
        //  the SignatureRpcEndpointBindingString to the input string.
        //

        SignatureRpcEndpointBindingString = SignatureRpcEndpointName;

        }

    else {

        //
        //  No '[' in string, so assume it is form "Server:Endpoint".
        //
        //  Allocate memory for full binding string.  The strlen of
        //  SignatureRpcEndpointName includes the colon which will be
        //  stripped, but we'll need that extra byte for the terminator.
        //

        SignatureRpcEndpointBindingString =
                MyAllocNeverFree(
                      strlen( SignatureRpcEndpointName )
                    + strlen( "ncacn_np:%s[\\\\pipe\\\\%s]" )
                    - strlen( "%s%s" )
                    );

        //
        //  Split SignatureRpcEndpointName into server name and endpoint
        //  name (endpoint name will then be referenced through p.
        //

        *p++ = 0;

        //
        //  If server name has leading backslashes, skip over them.
        //

        while ( *SignatureRpcEndpointName == '\\' )
            SignatureRpcEndpointName++;

        //
        //  If endpoint name has leading backslashes, skip over them.
        //

        while ( *p == '\\' )
            p++;

        //
        //  If endpoint name begins with "pipe" followed by backslash,
        //  skip over it and the trailing backslashes.
        //

        if ( _strnicmp( p, "pipe\\", 5 ) == 0 ) {

            p += 5;

            while ( *p == '\\' )
                p++;

            }

        sprintf(
            SignatureRpcEndpointBindingString,
            "ncacn_np:%s[\\\\pipe\\\\%s]",
            SignatureRpcEndpointName,
            p
            );

        }

    RpcStatus = RpcBindingFromStringBinding(
                    (PUCHAR)SignatureRpcEndpointBindingString,
                    &SignatureRpcBindingHandle
                    );

    if ( RpcStatus != RPC_S_OK ) {
        ErrorExit(
            RpcStatus,
            "ERROR: Failed to create RPC binding from RPC binding string specified\r\n"
            "       \"%s\"\r\n",
            SignatureRpcEndpointBindingString
            );
        }

    RpcStatus = RpcBindingSetAuthInfo(
                    SignatureRpcBindingHandle,
                    NULL,                           // server principal name
                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,  // encrypted packets
                    RPC_C_AUTHN_WINNT,              // NTLMSSP
                    NULL,                           // current user
                    0                               // not used by RPC_C_AUTHN_WINNT
                    );

    if ( RpcStatus != RPC_S_OK ) {
        ErrorExit(
            RpcStatus,
            "ERROR: Failed to establish authentication level for RPC binding\r\n"
            );
        }

    RpcTryExcept {

        BOOL Success;

        Success = RpcSignatureServerAuthenticate(
                      SignatureRpcBindingHandle,        // [in]
                      (PUCHAR) LoggingText              // [in,  string]
                      );

        if ( Success ) {
            RpcStatus = RPC_S_OK;
            }
        else {
            RpcStatus = GetLastError();
            if ( RpcStatus == RPC_S_OK ) {
                RpcStatus = RPC_S_CALL_FAILED;
                }
            }
        }
    RpcExcept( EXCEPTION_EXECUTE_HANDLER ) {
        RpcStatus = RpcExceptionCode();
        }
    RpcEndExcept;

    SetLastError( RpcStatus );

    return ( RpcStatus == RPC_S_OK );
    }


BOOL
GenerateSignatureFromHashValue(
    IN  PMD5_HASH HashValue,
    IN  LPSTR     LoggingText,
    OUT PDWORD    SignatureId,
    OUT PUCHAR    Signature
    )
    {
    RPC_STATUS RpcStatus = RPC_S_OK;
    BOOL       Success;

    RpcTryExcept {

        Success = RpcSignatureServerGenSignature(
                      SignatureRpcBindingHandle,        // [in]
                      (PUCHAR) LoggingText,             // [in,  string]
                      (PUCHAR) HashValue,               // [in,  size_is( HASH_SIZE )]
                      (PDWORD) SignatureId,             // [out]
                      (PUCHAR) Signature                // [out, size_is( SIGN_SIZE )]
                      );

        if ( Success ) {
            RpcStatus = RPC_S_OK;
            }
        else {
            RpcStatus = GetLastError();
            if ( RpcStatus == RPC_S_OK ) {
                RpcStatus = RPC_S_CALL_FAILED;
                }
            }
        }
    RpcExcept( EXCEPTION_EXECUTE_HANDLER ) {
        RpcStatus = RpcExceptionCode();
        }
    RpcEndExcept;

    SetLastError( RpcStatus );

    return ( RpcStatus == RPC_S_OK );
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\thread.h ===
typedef VOID ( *THREAD_FUNCTION )( PVOID );

void InitializeThreadPool( UINT nMaxThreads );

VOID StartThread( THREAD_FUNCTION pFunction,
                  PVOID           pParam,
                  INT             nPriority );

void CleanUpThreadPool( BOOL bWaitForThreads );

HANDLE MyCreateEvent( BOOL bManualReset, BOOL bInitialState );

HANDLE MyCreateSemaphore( LONG InitialCount );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\sign.h ===
extern LPSTR SignatureRpcEndpointName;
extern LPSTR SignatureRpcEndpointBindingString;

BOOL
ConnectToSignatureServer(
    LPSTR LoggingText
    );

BOOL
GenerateSignatureFromHashValue(
    IN  PMD5_HASH HashValue,
    IN  LPSTR     LoggingText,
    OUT PDWORD    SignatureId,
    OUT PUCHAR    Signature
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\udfbridg.c ===
#include "precomp.h"
#include <assert.h>
#pragma hdrstop

// From UDF 1.50 2.2.7.2
#define LVINFO_LVINFO_LENGTH    36
#define LVINFO_LVIDENT_LENGTH   128
#define LVIFNO_IMPUSE_LENGTH    128

typedef struct tagLVInformation
{
    CHARSPEC LVICharset;
    UCHAR LogicalVolumeIdentifier[LVINFO_LVIDENT_LENGTH];
    UCHAR LVInfo1[LVINFO_LVINFO_LENGTH];
    UCHAR LVInfo2[LVINFO_LVINFO_LENGTH];
    UCHAR LVInfo3[LVINFO_LVINFO_LENGTH];
    REGID ImplementationID;
    UCHAR ImplementationUse[LVIFNO_IMPUSE_LENGTH];
} LVINFORMATION, *PLVINFORMATION;

DWORD NumberOfStartingZeros(BYTE* pBuffer, DWORD dwBufferLength);

void AddNewShortExtent(PICBFILE pIcb, SHORTAD* pShortAD, LPDWORD pdwNextFreeBlock);
DWORD GetNumberOfShortExtents(PICBFILE pIcbFile);
VOID GetShortExtent(PICBFILE pIcbFile, DWORD dwExtentNum, PSHORTAD pShortExt);
VOID PutShortExtent(PICBFILE pIcbFile, DWORD dwExtentNum, PSHORTAD pShortExt);
BOOL IsShortExtentSparse(PSHORTAD pShortExt);
void AddNewShortAdToExtent(DWORD dwExtentBlock, SHORTAD* pShortAd, LPDWORD pdwNextFreeBlock);

void AddNewLongExtent(PICBFILE pIcb, LONGAD* pLongAD, LPDWORD pdwNextFreeBlock);
DWORD GetNumberOfLongExtents(PICBFILE pIcbFile);
VOID GetLongExtent(PICBFILE pIcbFile, DWORD dwExtentNum, PLONGAD pLongExt);
VOID PutLongExtent(PICBFILE pIcbFile, DWORD dwExtentNum, PLONGAD pLongExt);
BOOL IsLongExtentSparse(PLONGAD pLongExt);
void AddNewLongAdToExtent(DWORD dwExtentBlock, LONGAD* pLongAd, LPDWORD pdwNextFreeBlock);

BOOL BuildSparseFileExtent(DWORD* pdwNextFreeBlock, HANDLE hReadContext, PICBFILE pIcb, PHASH_AND_LENGTH pHashAndLength, DWORDLONG dwlFileLength);
BOOL MakeAllocExtent(PICBFILE pIcb, BYTE** Buffer, DWORD* pdwBytesRead, HANDLE hReadContext, DWORD* pdwNextFreeBlock, BOOL bSparse, PHASH_AND_LENGTH pHashAndLength, DWORDLONG* pdwlFileLengthLeft);
BOOL MakeSparseExtent(PICBFILE pIcb, BYTE** Buffer, DWORD* pdwBytesRead, HANDLE hReadContext, DWORD* pdwNextFreeBlock, PHASH_AND_LENGTH pHashAndLength, DWORDLONG* pdwlFileLengthLeft);

VOID InitalizeAllocationExtentDescriptor(PNSR_ALLOC pAllocDesc, DWORD dwBlock, DWORD dwPrevBlock);
void SetRandomExtentLength(void);
void WriteICBFileEntry( PDIRENTRY pFile, DWORDLONG UniqueID );
void WriteICBExtendedFileEntry( PDIRENTRY pFile, DWORDLONG UniqueID );

#define CopyStruct(dest, src) memcpy((&(dest)), (&(src)), (sizeof (dest)))

// Use a random number as partition number to discover incorrect implementations
// which confuse partition number and partition reference number
// NOTE: Changing PARTITION_NUMBER must also change the value in WriteLvolDescriptor()
#define PARTITION_NUMBER            0x0BAD
#define VIRTUAL_PARTITION_NUMBER    0x0BAD

// each directory has one PARENTFID (..) entry
// which is 38 + 0 (".." file name is not recorded)
// bytes long, rounding up to next ULONG ==> 40
#define PARENTFID_LEN           40

//
// The maximum single extent length for UDF is 0x3FFFFFFF.
// This is because the upper two bits of the length are reserved.
// We are going to round down one sector, and use multiple extents
// if the file is >= 1GB.
//
#define UDF_MAXEXTENT           (0x40000000 - CD_SECTORSIZE)

TIMESTAMP GlobalNsrTimeStamp;    // exported via extern in cdimage.h
short     NsrLocalTimeBias;      // exported via extern in cdimage.h
DWORDLONG UniqueID = 0;
DWORD     g_dwIcbBlockCount;

DWORD   gdwSpaceSaved;
WCHAR   wchStaticUnicodeBuffer[ MAX_NAME_LENGTH ];

ULONG   ulNextBlockToUse;
ULONG   ulGapBlock = 0;
ULONG   ulMainVDSExtentStart;
ULONG   ulMainVDSExtentBlocks;
ULONG   ulLVISExtentStart;
ULONG   ulLVISExtentBlocks;
ULONG   ulReserveVDSExtentStart;
ULONG   ulReserveVDSExtentBlocks;

ULONG   ulFSDExtentBlocks;
ULONG   ulFSDExtentStart;
ULONG   ulPartitionStart;
ULONG   ulPartitionLength;              // Length of Partion in logical sectors
ULONG   ulVATICBLocation;
ULONG   ulVolumeDescSeqNum;             // Volume descriptor sequence number

BOOL    bZeroLengthIcbSaved=FALSE;
DWORD   dwZeroLengthIcb;

extern ULONG   ulAnchorSectorNumber;
extern ULONG   ulAnchorSlackSector;

UCHAR   OSTABuffer[ MAX_NAME_LENGTH * 2 ];  // Common out buffer for OSTA Compressed Unicode conversion
UCHAR   VolName[ MAX_NAME_LENGTH * 2 ];     // Common out buffer for OSTA Compressed Unicode conversion
UCHAR   dstrBuffer[ 256 ];                  // Common out buffer for dstring

#define MAX_AD_EXTENT               1000        // big enough that the extent runs out of space before the limit is hit
#define MAX_RANDOM_AD_EXTENT        10      // want this to be small enough to have extents
//#define MAX_RANDOM_AD_EXTENT        2      // want this to be small enough to have extents

ULONG g_ulMaxAdsInExtent=MAX_AD_EXTENT;

 // Do we want lots of debug output?
#ifndef UDF_DBG
BOOL bVerbose   = FALSE;
#else
BOOL bVerbose   = FALSE;
#endif

/***    UDF Data Definitions
 *
 */
/************************************************************************/
static USHORT  g_usCurrentUDFVersion = 0x00;

void SetCurrentUDFVersion(USHORT nVer)
{
	g_usCurrentUDFVersion = nVer;

	ASSERT( (   g_usCurrentUDFVersion == 0x102
		     || g_usCurrentUDFVersion == 0x150
			 || g_usCurrentUDFVersion == 0x200));

}

USHORT GetCurrentUDFVersion()
{
	ASSERT( (   g_usCurrentUDFVersion == 0x102
		     || g_usCurrentUDFVersion == 0x150
			 || g_usCurrentUDFVersion == 0x200));

	return g_usCurrentUDFVersion;
}


/***********************************************************************/

static  REGID   const   UDF_DomainID102 = {      // REGID: "*OSTA UDF Compliant"
    0x00,{0x2A, 0x4F, 0x53, 0x54, 0x41, 0x20, 0x55,
    0x44, 0x46, 0x20, 0x43, 0x6F, 0x6D, 0x70, 0x6C,
    0x69, 0x61, 0x6E, 0x74, 0x00, 0x00, 0x00, 0x00},
   {0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}     // Domain Suffix UDF 1.50
};

static  REGID   const   UDF_DomainID150 = {      // REGID: "*OSTA UDF Compliant"
    0x00,{0x2A, 0x4F, 0x53, 0x54, 0x41, 0x20, 0x55,
    0x44, 0x46, 0x20, 0x43, 0x6F, 0x6D, 0x70, 0x6C,
    0x69, 0x61, 0x6E, 0x74, 0x00, 0x00, 0x00, 0x00},
   {0x50, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}     // Domain Suffix UDF 1.50
};

static REGID   const   UDF_DomainID200 = {      // REGID: "*OSTA UDF Compliant"
    0x00,{0x2A, 0x4F, 0x53, 0x54, 0x41, 0x20, 0x55,
    0x44, 0x46, 0x20, 0x43, 0x6F, 0x6D, 0x70, 0x6C,
    0x69, 0x61, 0x6E, 0x74, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}     // Domain Suffix UDF 2.00
};
const REGID*  GetUDFDomainID()
{
	switch (GetCurrentUDFVersion())
	{
		case 0x102 : return &UDF_DomainID102;
		case 0x150 : return &UDF_DomainID150;
		case 0x200 : return &UDF_DomainID200;
		default: ASSERT(FALSE); // Unknown Version
		
	}
	return &UDF_DomainID102;
}

/***********************************************************************/


static REGID   const   CDImageID = {   // REGID: "*Microsoft CDIMAGE UDF"
    0x00,{0x2A, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73,
    0x6F, 0x66, 0x74, 0x20, 0x43, 0x44, 0x49, 0x4D,
    0x41, 0x47, 0x45, 0x20, 0x55, 0x44, 0x46, 0x00},
   {0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}     // Domain Suffix: Win NT
};

const REGID*  GetImplementationID()
{
	return &CDImageID;
}

/***********************************************************************/

typedef UCHAR REGID_SUFFIX[8];

static REGID_SUFFIX const Suffix102 = {0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}; // WinNT UDF 1.50
static REGID_SUFFIX const Suffix150 = {0x50, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}; // WinNT UDF 1.50
static REGID_SUFFIX const Suffix200 = {0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}; // WinNT UDF 2.00

const REGID_SUFFIX* GetRegIDSuffix()
{
	switch (GetCurrentUDFVersion())
	{
	case 0x102 : return &Suffix102;
	case 0x150 : return &Suffix150;
	case 0x200 : return &Suffix200;
	}
	return &Suffix102;
}
/***********************************************************************/

/***    UDF Character Set Marker (By Agreement)
 *
 *      This character set marker identifies the OSTA Compressed Unicode
 *      character set.  Code points are stored as 8-bit, 16-bit, or 32-bit
 *      quantities.  Their zero-extended values map to unicode code points.
 *
 */

CHARSPEC    const   OSTAUnicode = {
    CHARSPEC_T_CS0, {                                       // CS0 (Agreement)
              0x4f, 0x53, 0x54, 0x41, 0x20, 0x43, 0x6f,     //  'OSTA Co'
        0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64,     // 'mpressed'
        0x20, 0x55, 0x6e, 0x69, 0x63, 0x6f, 0x64, 0x65,     // ' Unicode'
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     // ' 0000000'
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     // '00000000'
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     // '00000000'
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     // '00000000'
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00      // '00000000'
    }
};

/**************************************************************************/

static REGID   const   NSR01ID = { // REGID: "+NSR01"
    0x00,{0x2B, 0x4E, 0x53, 0x52, 0x30, 0x31, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}      // Undefined Suffix
};

static REGID   const   NSR02ID = { // REGID: "+NSR02"
    0x00,{0x2B, 0x4E, 0x53, 0x52, 0x30, 0x32, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}      // Undefined Suffix
};

static REGID   const   NSR03ID = { // REGID: "+NSR03"
    0x00,{0x2B, 0x4E, 0x53, 0x52, 0x30, 0x33, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}      // Undefined Suffix
};

const REGID*  GetPartitionContentsID()
{
	switch (GetCurrentUDFVersion())
	{
		case 0x102 : //fall through
		case 0x150 : return &NSR02ID;
		case 0x200 : return &NSR03ID;
		default    : ASSERT(FALSE);
	};
	return &NSR02ID;
}

/****************************************************************************/
USHORT  GetDesTagVersion()
{
	switch (GetCurrentUDFVersion())
	{
		case 0x102 : // fallthrough
		case 0x150 : return 2;
		case 0x200 : return 3;
		default:	ASSERT(FALSE);
	}
	return 2;
}
/****************************************************************************/
UCHAR __inline ComputeChecksum( PVOID Buffer, ULONG Bytes ) {

    PUCHAR p = Buffer;
    UCHAR checksum = 0;

    while ( Bytes-- )
        checksum = (UCHAR)( checksum + *p++ );

    return checksum;
}


PUCHAR dstring(PUCHAR pSrc, ULONG cbLen, PUCHAR pBuffer)
{
    PUCHAR pb = pBuffer;
    PUSHORT pw, pwSrc;
    ULONG cbCopied, j;

    if (cbLen < 2 || cbLen > 0xff)
        return NULL;

    // compensate for 0 based index
    cbLen--;

    // copy the first byte, OSTA Compressed Unicode char width
    switch (*pb++ = *pSrc++) {
        case 8:
            for (cbCopied = 1; cbCopied < cbLen && *pSrc; cbCopied++)
                *pb++ = *pSrc++;

            // zero fill remaing bytes if any
            for (j = cbCopied; j < cbLen; j++)
                *pb++ = '\0';

            break;

        case 16:
            for (cbCopied = 1, pw = (PUSHORT)pb, pwSrc = (PUSHORT)pSrc;
               cbCopied < cbLen-1 && *pwSrc; cbCopied += 2)
                    // cbLen-1 because need at least 2 bytes to copy a 16 bit char
                *pw++ = *pwSrc++;

            // zero fill remaing bytes if any
            for (j = cbCopied, pb = (PUCHAR)pw; j < cbLen; j++)
                *pb++ = '\0';

            break;

        default:
            return NULL;
    }

    // strlen is encoded as the last byte of the field
    *pb = (UCHAR) cbCopied;

    return pBuffer;
}



#define OSTA16BitUnicodeLen( n )     ( n ) + 1

PUCHAR OSTA16BitUnicode(LPWSTR pszUnicodeName, ULONG ulUnicodeLen, PUCHAR pBuffer)
{
    PUCHAR pName = (PUCHAR)pszUnicodeName, pBuf = pBuffer;
    ULONG  ulCount = 0;

    // Reverse the byte ordering for each Unicode character.
    for(*(pBuf++) = 16;ulCount < ulUnicodeLen;ulCount += 2)
    {
      *(pBuf++) = *(pName+ulCount+1);
      *(pBuf++) = *(pName+ulCount);
    }

    return pBuffer;
}

#define OSTA8BitUnicodeLen( n )     ( n >> 1 ) + 1

PUCHAR OSTA8BitUnicode(LPWSTR pszUnicodeName, ULONG ulUnicodeLen, PUCHAR pBuffer)
{
    PUCHAR pName = (PUCHAR)pszUnicodeName, pBuf = pBuffer;
    ULONG  ulCount = 0;

    // Reverse the byte ordering for each Unicode character.
    for(*(pBuf++) = 8;ulCount < ulUnicodeLen;ulCount += 2)
    {
      *(pBuf++) = *(pName+ulCount);
    }

    return pBuffer;
}

void MakeNsrTimeStampFromFileTime( PTIMESTAMP pTimeStamp, FILETIME ftFileTime )
{
    SYSTEMTIME st;

    ASSERT( *(UNALIGNED DWORDLONG*)&(ftFileTime) != 0 );

    ZeroMemory( &st, sizeof( st ));      // in case FileTimeToSystemTime fails.

    *(UNALIGNED DWORDLONG*)&ftFileTime += LocalTimeBiasInFileTimeUnits;

    FileTimeToSystemTime( &ftFileTime, &st );

    pTimeStamp->timestamp_Type        = TIMESTAMP_T_LOCAL; // UDF 2.1.3.1
    pTimeStamp->timestamp_Zone        = NsrLocalTimeBias;
    pTimeStamp->timestamp_Year        = st.wYear;
    pTimeStamp->timestamp_Month       = (UCHAR) st.wMonth;
    pTimeStamp->timestamp_Day         = (UCHAR) st.wDay;
    pTimeStamp->timestamp_Hour        = (UCHAR) st.wHour;
    pTimeStamp->timestamp_Minute      = (UCHAR) st.wMinute;
    pTimeStamp->timestamp_Second      = (UCHAR) st.wSecond;
    pTimeStamp->timestamp_centiSecond = (UCHAR) (  st.wMilliseconds / 10 );
    pTimeStamp->timestamp_usec100     = (UCHAR) (( st.wMilliseconds % 10 ) * 10 );
    pTimeStamp->timestamp_usec        = 0;
}

/***    Allocate CD Blocks
 *
 *      Sector 256 is the UDF anchor sector.
 *              Other UDF structures and ISO 9660 meta data
 *              has to skip over this "road block".
 *
 */

#ifdef DONTCOMPILE  // tommcg -- Now use AllocateMetaBlocks in cdimage.c

 ULONG AllocateCdBlocks( ULONG n ) {

        ULONG ulNextBlock = ulNextBlockToUse;

        if ( (!bUDFBridge) || (ulNextBlock > ANCHOR_SECTOR) )   // if already after anchor point
                ulNextBlockToUse += n;
        else if ( (ulNextBlock + n) > ANCHOR_SECTOR ) {         // if the currently requested allocation crosses the anchor point

                ASSERT( ulGapBlock == 0 );
                if ( ulNextBlock < ANCHOR_SECTOR )              // this should only eliminate the == case
                        ulGapBlock = ulNextBlock;
                else
                        ASSERT( ulNextBlock == ANCHOR_SECTOR );

                ulNextBlock = ANCHOR_SECTOR + 1;
                ulNextBlockToUse = ulNextBlock + n;
                }
        else {
                ulNextBlockToUse += n;
                }


        return ulNextBlock;

        }

#endif // DONTCOMPILE


/***    Volume Recognition Sequence
 *
 *      VSR (including CD-ROM Volume Descriptor Set) shall begin at
 *      byte number 32768 of the volume space.
 *
 */

void WriteBEA01Descriptor( ULONG SectorNumber ) {

    PUCHAR pBuffer;
    PVSD_BEA01 pBEA01;

    ASSERT( SectorNumber >= 16 );       // this descriptor shall start at or after 32K

    pBuffer =  AllocateBuffer( CD_SECTORSIZE, TRUE );

    pBEA01 = (PVSD_BEA01) pBuffer;
    pBEA01->vsd_bea01_Type = 0x00;
    memcpy( pBEA01->vsd_bea01_Ident, VSD_IDENT_BEA01, 5 );
    pBEA01->vsd_bea01_Version = 0x01;

    HeaderWrite((DWORDLONG)SectorNumber * CD_SECTORSIZE, pBuffer, CD_SECTORSIZE );

    }

void WriteNSRDescriptor(ULONG SectorNumber)
{
	PUCHAR pBuffer;
    PVSD_NSR02 pNSR;

    ASSERT( SectorNumber >= 16 );       // this descriptor shall start at or after 32K

    pBuffer = AllocateBuffer( CD_SECTORSIZE, TRUE );

    pNSR = (PVSD_NSR02) pBuffer;
    pNSR->vsd_nsr02_Type = 0x00;
	switch (GetCurrentUDFVersion())
	{
		case 0x102:		memcpy( pNSR->vsd_nsr02_Ident, VSD_IDENT_NSR02, 5 ); break;
		case 0x150:		memcpy( pNSR->vsd_nsr02_Ident, VSD_IDENT_NSR02, 5 ); break;
		case 0x200:		memcpy( pNSR->vsd_nsr02_Ident, VSD_IDENT_NSR03, 5 ); break;
		default: ASSERT(FALSE);
	}
    pNSR->vsd_nsr02_Version = 0x01;

    HeaderWrite((DWORDLONG)SectorNumber * CD_SECTORSIZE, pBuffer, CD_SECTORSIZE );
}




void WriteTEA01Descriptor( ULONG SectorNumber ) {

    PUCHAR pBuffer;
    PVSD_TEA01 pTEA01;

    // this descriptor shall start at or after byte 32K
    ASSERT( ( SectorNumber * CD_SECTORSIZE ) >= 32768 );

    pBuffer = AllocateBuffer( CD_SECTORSIZE, TRUE );

    pTEA01 = (PVSD_TEA01) pBuffer;
    pTEA01->vsd_tea01_Type = 0x00;
    memcpy( pTEA01->vsd_tea01_Ident, VSD_IDENT_TEA01, 5 );
    pTEA01->vsd_tea01_Version = 0x01;

    HeaderWrite((DWORDLONG)SectorNumber * CD_SECTORSIZE, pBuffer, CD_SECTORSIZE );

    }


/***    Anchor Volume Descriptor Pointer
 *
 *      Anchor Volume Descriptor Pointer shall be recorded at sectors 256
 *      and N, where N is the last addressable sector of a volume.
 *
 */

void WriteAnchorDescriptor( ULONG SectorNumber ) {

    PUCHAR pBuffer;
    PNSR_ANCHOR pAnchor;

    // Anchor Pointer must be in sector 256
    ASSERT ( SectorNumber == ANCHOR_SECTOR || SectorNumber == ulAnchorSectorNumber );

    pBuffer = AllocateBuffer( CD_SECTORSIZE, TRUE );

    pAnchor = (PNSR_ANCHOR) pBuffer;

    pAnchor->nsr_anchor_Main.extentad_Len = ulMainVDSExtentBlocks * CD_SECTORSIZE;
    pAnchor->nsr_anchor_Main.extentad_lsn = ulMainVDSExtentStart;
    pAnchor->nsr_anchor_Reserve.extentad_Len = ulReserveVDSExtentBlocks * CD_SECTORSIZE;
    pAnchor->nsr_anchor_Reserve.extentad_lsn = ulReserveVDSExtentStart;

    // Fill in Descriptor Tag
    pAnchor->nsr_anchor_destag.destag_Ident = DESTAG_ID_NSR_ANCHOR;
    pAnchor->nsr_anchor_destag.destag_Version = GetDesTagVersion();
    pAnchor->nsr_anchor_destag.destag_CRCLen = (USHORT)( sizeof( NSR_ANCHOR ) - sizeof( DESTAG ));
    pAnchor->nsr_anchor_destag.destag_CRC =
        Crc16( 0, (PUCHAR)pAnchor+sizeof(DESTAG), pAnchor->nsr_anchor_destag.destag_CRCLen );
    pAnchor->nsr_anchor_destag.destag_lsn = SectorNumber;

    pAnchor->nsr_anchor_destag.destag_Checksum=0;
       // Fill in checksum last
    pAnchor->nsr_anchor_destag.destag_Checksum =
        ComputeChecksum( (PUCHAR)&pAnchor->nsr_anchor_destag, sizeof (DESTAG) );


    HeaderWrite((DWORDLONG)SectorNumber * CD_SECTORSIZE, pBuffer, CD_SECTORSIZE );

    }



/***    Volume Descriptor Sequence
 *
 *      Both the main and reserve VDS extents shall each have a
 *      minimum length of 16 logical sectors.
 *
 */


void WritePvdDescriptor( ULONG SectorNumber ) {

    PUCHAR pBuffer;
    PNSR_PVD pPvd;

    pBuffer = AllocateBuffer( CD_SECTORSIZE, TRUE );

    pPvd = (PNSR_PVD) pBuffer;

    ulVolumeDescSeqNum = 0;
    pPvd->nsr_pvd_VolDescSeqNum = ulVolumeDescSeqNum++;
    ASSERT( pPvd->nsr_pvd_Number == 0 );        // shall be the only PVD
    pPvd->nsr_pvd_VolSetSeq = pPvd->nsr_pvd_VolSetSeqMax = 1;   // 3/8.6
    if (dstring(OSTA16BitUnicode(wchVolumeLabel, 32, OSTABuffer), 32, dstrBuffer))
        memcpy( pPvd->nsr_pvd_VolumeID, dstrBuffer, 32 );
    pPvd->nsr_pvd_Level = 2;                    // UDF 2.2.2.1
    pPvd->nsr_pvd_LevelMax = 3;                 // UDF 2.2.2.2
    pPvd->nsr_pvd_CharSetList = 0x00000001;     // UDF 2.1.2 CS0
    pPvd->nsr_pvd_CharSetListMax = 0x00000001;  // UDF 2.1.2 CS0

    //    First 16 characters of VolSetID field shall be set to a unique value.
    //    First 8 characters should come from a CS0 hex representation
    //    of a 32-bit time value. The next 8 characters are free for
    //    implementation use.

    OSTABuffer[0] = 8;                          // Use 8 bit character
    _ultoa(ftGlobalFileTime.dwLowDateTime, (char *)&OSTABuffer[1], 16);
    strcpy((char *)&OSTABuffer[9], "MS UDFBridge");
    ZeroMemory(VolName,LVINFO_LVIDENT_LENGTH);
    if (dstring(OSTABuffer, 128, dstrBuffer))
    {
        memcpy( pPvd->nsr_pvd_VolSetID, dstrBuffer, 128 );
        memcpy(VolName,dstrBuffer,LVINFO_LVIDENT_LENGTH);
    }

    CopyStruct( pPvd->nsr_pvd_charsetDesc, OSTAUnicode );
    CopyStruct( pPvd->nsr_pvd_charsetExplan, OSTAUnicode );
    CopyStruct( pPvd->nsr_pvd_ImpUseID, *GetImplementationID());
    CopyStruct( pPvd->nsr_pvd_RecordTime, GlobalNsrTimeStamp );

    ASSERT( pPvd->nsr_pvd_Predecessor == 0 );   // this shall be the sole PVD

    // Fill in Descriptor Tag
    pPvd->nsr_pvd_destag.destag_Ident = DESTAG_ID_NSR_PVD;
    pPvd->nsr_pvd_destag.destag_Version = GetDesTagVersion();
    pPvd->nsr_pvd_destag.destag_CRCLen = (USHORT)( sizeof( NSR_PVD ) - sizeof( DESTAG ));
    pPvd->nsr_pvd_destag.destag_CRC =
        Crc16( 0, (PUCHAR)pPvd+sizeof(DESTAG), pPvd->nsr_pvd_destag.destag_CRCLen );
    pPvd->nsr_pvd_destag.destag_lsn = SectorNumber;

    pPvd->nsr_pvd_destag.destag_Checksum = 0;
    // Fill in checksum last
    pPvd->nsr_pvd_destag.destag_Checksum =
        ComputeChecksum( (PUCHAR)&pPvd->nsr_pvd_destag, sizeof (DESTAG) );


    HeaderWrite((DWORDLONG)SectorNumber * CD_SECTORSIZE, pBuffer, CD_SECTORSIZE );

    }

void WriteImpUseVolDescriptor( ULONG SectorNumber )
{

    PUCHAR pBuffer;
    PNSR_IMPUSE pImpUse;
    PREGID pRegId;
    PLVINFORMATION pLVInfo;
    PDESTAG pDestag;

    pBuffer = AllocateBuffer( CD_SECTORSIZE, TRUE );

    pImpUse = (PNSR_IMPUSE) pBuffer;

    pImpUse->nsr_impuse_VolDescSeqNum = ulVolumeDescSeqNum++;

    // Fill in the REG ID
    pRegId=&(pImpUse->nsr_impuse_ImpUseID);
    strcpy((char*)pRegId->regid_Identifier,"*UDF LV Info");
    memcpy(pRegId->regid_Suffix,*GetRegIDSuffix(),REGID_LENGTH_SUFFIX);

    // Fill in ImpUse
    pLVInfo=(PLVINFORMATION) pImpUse->nsr_impuse_ImpUse;
    memcpy(&(pLVInfo->LVICharset),&OSTAUnicode,sizeof(CHARSPEC));
    memcpy(pLVInfo->LogicalVolumeIdentifier,VolName,LVINFO_LVIDENT_LENGTH);
    pLVInfo->LVInfo1[0]=8;
    pLVInfo->LVInfo2[0]=8;
    pLVInfo->LVInfo3[0]=8;
    strcpy((char*)&(pLVInfo->LVInfo1[1]),"Microsoft");
    strcpy((char*)&(pLVInfo->LVInfo2[1]),"Sample UDF 1.50 media");
    strcpy((char*)&(pLVInfo->LVInfo3[1]),"Contact danlo or nathann");
    pRegId=&(pLVInfo->ImplementationID);
    memcpy(pRegId,GetImplementationID(),sizeof(REGID));

    // Fill in Descriptor Tag
    pDestag=&(pImpUse->nsr_impuse_destag);
    pDestag->destag_Ident = DESTAG_ID_NSR_IMPUSE;
    pDestag->destag_Version = GetDesTagVersion();
    pDestag->destag_CRCLen = (USHORT)( sizeof( NSR_IMPUSE ) - sizeof( DESTAG ));
    pDestag->destag_CRC =
        Crc16( 0, (PUCHAR)pImpUse+sizeof(DESTAG), pDestag->destag_CRCLen );
    pDestag->destag_lsn = SectorNumber;
    pDestag->destag_Checksum = 0;
    pDestag->destag_Checksum =
        ComputeChecksum( (PUCHAR)pDestag, sizeof (DESTAG) );

    // Save it
    HeaderWrite((DWORDLONG)SectorNumber * CD_SECTORSIZE, pBuffer, CD_SECTORSIZE );
}

void WriteLvolDescriptor( ULONG SectorNumber ) {

    PUCHAR pBuffer;
    PNSR_LVOL pLvol;
    ULONG ulMapTableLength = 0;
    ULONG ulMapTableCount = 0;   // shall have exactly one partition and one partition map


    PARTMAP   partMap;
    //PARTMAPVIRT partVirt;

    partMap.partmap_Type = 1;
    partMap.partmap_Length = 6;
    partMap.partmap_VolSetSeq = 1;
    partMap.partmap_Partition =PARTITION_NUMBER;



	
	ulMapTableCount = 1;
    ulMapTableLength = partMap.partmap_Length;
	


    pBuffer = AllocateBuffer( CD_SECTORSIZE, TRUE );

    pLvol = (PNSR_LVOL) pBuffer;

    pLvol->nsr_lvol_VolDescSeqNum = ulVolumeDescSeqNum++;
    CopyStruct( pLvol->nsr_lvol_charspec, OSTAUnicode );
    if (dstring(OSTA16BitUnicode(wchVolumeLabel, 32, OSTABuffer), 128, dstrBuffer))
        memcpy( pLvol->nsr_lvol_VolumeID, dstrBuffer, 128);
    pLvol->nsr_lvol_BlockSize = CD_SECTORSIZE;           // shall be 2048 bytes
    CopyStruct( pLvol->nsr_lvol_DomainID, *GetUDFDomainID() );
    pLvol->nsr_lvol_FSD.longad_Length = ulFSDExtentBlocks * CD_SECTORSIZE;
    pLvol->nsr_lvol_FSD.longad_Start.nsr_lba_lbn = ulFSDExtentStart;
    pLvol->nsr_lvol_FSD.longad_Start.nsr_lba_PartRef = 0;
    pLvol->nsr_lvol_MapTableLength = ulMapTableLength;
    pLvol->nsr_lvol_MapTableCount = ulMapTableCount;

    CopyStruct(pLvol->nsr_lvol_ImpUseID, *GetImplementationID());

    pLvol->nsr_lvol_Integrity.extentad_Len = ulLVISExtentBlocks * CD_SECTORSIZE;
    pLvol->nsr_lvol_Integrity.extentad_lsn = ulLVISExtentStart;

    memcpy( pLvol->nsr_lvol_MapTable, &partMap, sizeof(PARTMAP) );

    // Fill in Descriptor Tag
    pLvol->nsr_lvol_destag.destag_Ident = DESTAG_ID_NSR_LVOL;
    pLvol->nsr_lvol_destag.destag_Version = GetDesTagVersion();
    pLvol->nsr_lvol_destag.destag_CRCLen = (USHORT)( sizeof( NSR_LVOL ) - sizeof( DESTAG )) + (USHORT)ulMapTableLength;
    pLvol->nsr_lvol_destag.destag_CRC =
        Crc16( 0, (PUCHAR)pLvol+sizeof(DESTAG), pLvol->nsr_lvol_destag.destag_CRCLen );
    pLvol->nsr_lvol_destag.destag_lsn = SectorNumber;

   pLvol->nsr_lvol_destag.destag_Checksum = 0;

    // Fill in checksum last
    pLvol->nsr_lvol_destag.destag_Checksum =
        ComputeChecksum( (PUCHAR)&pLvol->nsr_lvol_destag, sizeof (DESTAG) );


    HeaderWrite((DWORDLONG)SectorNumber * CD_SECTORSIZE, pBuffer, CD_SECTORSIZE );

    }

void WriteLvIntegDescriptor( ULONG SectorNumber ) {

    PUCHAR pBuffer;
    PNSR_INTEG pInteg;
    PNSR_LVHD pLvhd;
    PUDF_LVID_IMPUSE pImpUse;

    ASSERT( dwlTotalNumberOfFiles       < 0x100000000 );
    ASSERT( dwlTotalNumberOfDirectories < 0x100000000 );

    pBuffer = AllocateBuffer( CD_SECTORSIZE, TRUE );

    pInteg = (PNSR_INTEG) pBuffer;

    CopyStruct( pInteg->nsr_integ_Time, GlobalNsrTimeStamp );
    pInteg->nsr_integ_Type = NSR_INTEG_T_CLOSE;
	
    ASSERT( pInteg->nsr_integ_Next.extentad_Len == 0 );

    pLvhd = &pInteg->nsr_integ_LVHD;
    *(UNALIGNED DWORDLONG*)&(pLvhd->nsr_lvhd_UniqueID) = 15 + dwlTotalNumberOfFiles + dwlTotalNumberOfDirectories;

    ASSERT(sizeof(UDF_LVID_IMPUSE) >= 46);      // this needs to be at least 46 bytes
	
	pInteg->nsr_integ_PartitionCount = 1;
	
    pInteg->nsr_integ_ImpUseLength = sizeof (UDF_LVID_IMPUSE);

    ASSERT( ulPartitionLength != 0 );

	{
		DWORD i;
		DWORD dwPartitions = pInteg->nsr_integ_PartitionCount;
		for( i = 0; i < dwPartitions;i++)
		{
			pInteg->nsr_integ_Free[i] = 0;
			pInteg->nsr_integ_Free[dwPartitions+i] = ulPartitionLength;
		}
	}

    pImpUse = ( PUDF_LVID_IMPUSE ) ( pInteg->nsr_integ_Free + (pInteg->nsr_integ_PartitionCount*2) );
    CopyStruct( pImpUse->riImplementID, *GetImplementationID() );
    pImpUse->ulNumberOfFiles	= (DWORD)dwlTotalNumberOfFiles;
    pImpUse->ulNumberOfDirs		= (DWORD)dwlTotalNumberOfDirectories;
    pImpUse->usMinUDFReadRev	=  GetCurrentUDFVersion();
    pImpUse->usMinUDFWriteRev	=  GetCurrentUDFVersion();
    pImpUse->usMaxUDFWriteRev	=  GetCurrentUDFVersion();


    // Fill in Descriptor Tag
    pInteg->nsr_integ_destag.destag_Ident = DESTAG_ID_NSR_LVINTEG;
    pInteg->nsr_integ_destag.destag_Version = GetDesTagVersion();
    pInteg->nsr_integ_destag.destag_CRCLen = (USHORT)( sizeof( NSR_INTEG ) - sizeof( DESTAG )) + (USHORT)pInteg->nsr_integ_ImpUseLength + (USHORT)((pInteg->nsr_integ_PartitionCount-1)*8); // 8bytes for each extra partition
    pInteg->nsr_integ_destag.destag_CRC =
        Crc16( 0, (PUCHAR)pInteg+sizeof(DESTAG), pInteg->nsr_integ_destag.destag_CRCLen );
    pInteg->nsr_integ_destag.destag_lsn = SectorNumber;

   pInteg->nsr_integ_destag.destag_Checksum = 0;

    // Fill in checksum last
    pInteg->nsr_integ_destag.destag_Checksum =
        ComputeChecksum( (PUCHAR)&pInteg->nsr_integ_destag, sizeof (DESTAG) );


    HeaderWrite((DWORDLONG)SectorNumber * CD_SECTORSIZE, pBuffer, CD_SECTORSIZE );

    }

void WritePartDescriptor( ULONG SectorNumber ) {

    PUCHAR pBuffer;
    PNSR_PART pPart;
    PNSR_PART_H pPartHeader;

    pBuffer = AllocateBuffer( CD_SECTORSIZE, TRUE );

    pPart = (PNSR_PART) pBuffer;

    pPart->nsr_part_VolDescSeqNum = ulVolumeDescSeqNum++;
    pPart->nsr_part_Flags = NSR_PART_F_ALLOCATION;      // volume space allocated
    pPart->nsr_part_Number = PARTITION_NUMBER;

	
	CopyStruct( pPart->nsr_part_ContentsID, *GetPartitionContentsID() );  // "+NSR02"

    pPartHeader = (PNSR_PART_H) pPart->nsr_part_ContentsUse;
    pPartHeader->nsr_part_h_UASTable.shortad_Length = 0;
    pPartHeader->nsr_part_h_UASBitmap.shortad_Length = 0;
    pPartHeader->nsr_part_h_FreedTable.shortad_Length = 0;
    pPartHeader->nsr_part_h_FreedBitmap.shortad_Length = 0;

    pPart->nsr_part_AccessType = NSR_PART_ACCESS_RO;    // Read Only Access

    ASSERT( ulPartitionLength != 0 );

    pPart->nsr_part_Start = ulPartitionStart;
    pPart->nsr_part_Length = ulPartitionLength ;

    ASSERT( ISALIGN2( pPart->nsr_part_Start, 16 ) );

    CopyStruct(pPart->nsr_part_ImpUseID, *GetImplementationID());


    // Fill in Descriptor Tag
    pPart->nsr_part_destag.destag_Ident = DESTAG_ID_NSR_PART;
    pPart->nsr_part_destag.destag_Version = GetDesTagVersion();
    pPart->nsr_part_destag.destag_CRCLen = (USHORT)( sizeof( NSR_PART ) - sizeof( DESTAG ));
    pPart->nsr_part_destag.destag_CRC =
        Crc16( 0, (PUCHAR)pPart+sizeof(DESTAG), pPart->nsr_part_destag.destag_CRCLen );
    pPart->nsr_part_destag.destag_lsn = SectorNumber;

   pPart->nsr_part_destag.destag_Checksum = 0;

    // Fill in checksum last
    pPart->nsr_part_destag.destag_Checksum =
        ComputeChecksum( (PUCHAR)&pPart->nsr_part_destag, sizeof (DESTAG) );


    HeaderWrite((DWORDLONG)SectorNumber * CD_SECTORSIZE, pBuffer, CD_SECTORSIZE );

    }


void WriteUasdDescriptor( ULONG SectorNumber ) {

    PUCHAR pBuffer;
    PNSR_UASD pUasd;

    pBuffer = AllocateBuffer( CD_SECTORSIZE, TRUE );

    pUasd = (PNSR_UASD) pBuffer;

    pUasd->nsr_uasd_VolDescSeqNum = ulVolumeDescSeqNum++;
    pUasd->nsr_uasd_ExtentCount = 0;            // No unallocated space

    // Fill in Descriptor Tag
    pUasd->nsr_uasd_destag.destag_Ident = DESTAG_ID_NSR_UASD;
    pUasd->nsr_uasd_destag.destag_Version = GetDesTagVersion();
    pUasd->nsr_uasd_destag.destag_CRCLen = (USHORT)( sizeof( NSR_UASD ) - sizeof( DESTAG ));
    pUasd->nsr_uasd_destag.destag_CRC =
        Crc16( 0, (PUCHAR)pUasd+sizeof(DESTAG), pUasd->nsr_uasd_destag.destag_CRCLen );
    pUasd->nsr_uasd_destag.destag_lsn = SectorNumber;

   pUasd->nsr_uasd_destag.destag_Checksum = 0;

    // Fill in checksum last
    pUasd->nsr_uasd_destag.destag_Checksum =
        ComputeChecksum( (PUCHAR)&pUasd->nsr_uasd_destag, sizeof (DESTAG) );


    HeaderWrite((DWORDLONG)SectorNumber * CD_SECTORSIZE, pBuffer, CD_SECTORSIZE );

    }


void WriteTermDescriptor( ULONG SectorNumber ) {

    PUCHAR pBuffer;
    PNSR_TERM pTerm;

    pBuffer = AllocateBuffer( CD_SECTORSIZE, TRUE );

    pTerm = (PNSR_TERM) pBuffer;

    // Fill in Descriptor Tag
    pTerm->nsr_term_destag.destag_Ident = DESTAG_ID_NSR_TERM;
    pTerm->nsr_term_destag.destag_Version = GetDesTagVersion();
    pTerm->nsr_term_destag.destag_CRCLen = (USHORT)( sizeof( NSR_TERM ) - sizeof( DESTAG ));
    pTerm->nsr_term_destag.destag_CRC =
        Crc16( 0, (PUCHAR)pTerm+sizeof(DESTAG), pTerm->nsr_term_destag.destag_CRCLen );
    pTerm->nsr_term_destag.destag_lsn = SectorNumber;

   pTerm->nsr_term_destag.destag_Checksum = 0;
    // Fill in checksum last
    pTerm->nsr_term_destag.destag_Checksum =
        ComputeChecksum( (PUCHAR)&pTerm->nsr_term_destag, sizeof (DESTAG) );


    HeaderWrite((DWORDLONG)SectorNumber * CD_SECTORSIZE, pBuffer, CD_SECTORSIZE );

    }


void WriteFsdDescriptor( ULONG BlockNumber ) {

    PUCHAR pBuffer;
    PNSR_FSD pFsd;

    pBuffer = AllocateBuffer( CD_SECTORSIZE, TRUE );

    pFsd = (PNSR_FSD) pBuffer;

    ASSERT( BlockNumber == 0 );         // write at the beginning of partition

    CopyStruct( pFsd->nsr_fsd_Time, GlobalNsrTimeStamp );
    pFsd->nsr_fsd_Level = 3;                    // UDF 2.3.2.1
    pFsd->nsr_fsd_LevelMax = 3;                 // UDF 2.3.2.2
    pFsd->nsr_fsd_CharSetList = 0x00000001;     // UDF 2.3.2.3
    pFsd->nsr_fsd_CharSetListMax = 0x00000001;  // UDF 2.3.2.3
    pFsd->nsr_fsd_FileSet = 1;                  // ??
    ASSERT( pFsd->nsr_fsd_FileSetDesc == 0 );
    CopyStruct( pFsd->nsr_fsd_charspecVolID, OSTAUnicode );
    if (dstring(OSTA16BitUnicode(wchVolumeLabel, 32, OSTABuffer), 128, dstrBuffer))
        memcpy( pFsd->nsr_fsd_VolID, dstrBuffer, 128);
    CopyStruct( pFsd->nsr_fsd_charspecFileSet, OSTAUnicode );
    if (dstring(OSTABuffer, 32, dstrBuffer))
        memcpy( pFsd->nsr_fsd_FileSetID, dstrBuffer, 32);
    pFsd->nsr_fsd_icbRoot.longad_Length = CD_SECTORSIZE;         // 1 direct ICB
    pFsd->nsr_fsd_icbRoot.longad_Start.nsr_lba_lbn =
        ulFSDExtentStart + ulFSDExtentBlocks;         // root ICB immediately follows FSD extent

    pFsd->nsr_fsd_icbRoot.longad_Start.nsr_lba_PartRef = 0;
    CopyStruct( pFsd->nsr_fsd_DomainID, *GetUDFDomainID() );
    ASSERT( pFsd->nsr_fsd_NextExtent.longad_Length == 0 );      // shall be the only FSD


    // Fill in Descriptor Tag
    pFsd->nsr_fsd_destag.destag_Ident = DESTAG_ID_NSR_FSD;
    pFsd->nsr_fsd_destag.destag_Version = GetDesTagVersion();
    pFsd->nsr_fsd_destag.destag_CRCLen = (USHORT)( sizeof( NSR_FSD ) - sizeof( DESTAG ));
    pFsd->nsr_fsd_destag.destag_CRC =
        Crc16( 0, (PUCHAR)pFsd+sizeof(DESTAG), pFsd->nsr_fsd_destag.destag_CRCLen );
    pFsd->nsr_fsd_destag.destag_lsn = BlockNumber;

   pFsd->nsr_fsd_destag.destag_Checksum= 0;
    // Fill in checksum last
    pFsd->nsr_fsd_destag.destag_Checksum =
        ComputeChecksum( (PUCHAR)&pFsd->nsr_fsd_destag, sizeof (DESTAG) );


    HeaderWrite((DWORDLONG)(ulPartitionStart + BlockNumber) * CD_SECTORSIZE, pBuffer, CD_SECTORSIZE );

    }


void WriteFsdTerminator( ULONG BlockNumber ) {

    PUCHAR pBuffer;
    PNSR_TERM pTerm;

    pBuffer = AllocateBuffer( CD_SECTORSIZE, TRUE );

    pTerm = (PNSR_TERM) pBuffer;

    ASSERT( BlockNumber == 1 );         // shall be immediately following FSD

    // Fill in Descriptor Tag
    pTerm->nsr_term_destag.destag_Ident = DESTAG_ID_NSR_TERM;
    pTerm->nsr_term_destag.destag_Version = GetDesTagVersion();
    pTerm->nsr_term_destag.destag_CRCLen = (USHORT)( sizeof( NSR_TERM ) - sizeof( DESTAG ));
    pTerm->nsr_term_destag.destag_CRC =
        Crc16( 0, (PUCHAR)pTerm+sizeof(DESTAG), pTerm->nsr_term_destag.destag_CRCLen );
    pTerm->nsr_term_destag.destag_lsn = BlockNumber;

   pTerm->nsr_term_destag.destag_Checksum = 0;
    // Fill in checksum last
    pTerm->nsr_term_destag.destag_Checksum =
        ComputeChecksum( (PUCHAR)&pTerm->nsr_term_destag, sizeof (DESTAG) );

    HeaderWrite((DWORDLONG)(ulPartitionStart + BlockNumber) * CD_SECTORSIZE, pBuffer, CD_SECTORSIZE );

    }


void WriteUDFAnchorAndVDS( void ) {

    ULONG SectorNumber = ANCHOR_SECTOR;         // Write anchor at sector 256

	// fix up partition length to take into account sparseness, hard links and chained extents
    ulPartitionLength = (dwTotalImageBlocks - ulPartitionStart); // + 1;

    WriteAnchorDescriptor( SectorNumber++ );
	SectorNumber++;
    // Write Main VDS
    SectorNumber = ulMainVDSExtentStart;
    WritePvdDescriptor( SectorNumber++ );
    WriteLvolDescriptor( SectorNumber++ );
    WritePartDescriptor( SectorNumber++ );
    WriteUasdDescriptor( SectorNumber++ );
    WriteImpUseVolDescriptor( SectorNumber++);
    WriteTermDescriptor( SectorNumber++ );

    if ( ( ulMainVDSExtentStart + ulMainVDSExtentBlocks ) > SectorNumber ) {

        ULONG ZeroSectors = ulMainVDSExtentStart
                          + ulMainVDSExtentBlocks
                          - SectorNumber;

        WriteZeroedSectors( SectorNumber, ZeroSectors );
        SectorNumber = ulMainVDSExtentStart + ulMainVDSExtentBlocks;
        }

    // Write Logical Volume Integrity Sequence
    ASSERT( SectorNumber == ulLVISExtentStart );
    WriteLvIntegDescriptor( SectorNumber++ );
    WriteTermDescriptor( SectorNumber++ );

    if ( ( ulLVISExtentStart + ulLVISExtentBlocks ) > SectorNumber ) {

        ULONG ZeroSectors = ulLVISExtentStart
                          + ulLVISExtentBlocks
                          - SectorNumber;

        WriteZeroedSectors( SectorNumber, ZeroSectors );
        SectorNumber = ulLVISExtentStart + ulLVISExtentBlocks;
        }

    // Write Reserve VDS
    ASSERT( SectorNumber == ulReserveVDSExtentStart );
    WritePvdDescriptor( SectorNumber++ );
    WriteLvolDescriptor( SectorNumber++ );
    WritePartDescriptor( SectorNumber++ );
	WriteUasdDescriptor( SectorNumber++ );
    WriteImpUseVolDescriptor( SectorNumber++);
    WriteTermDescriptor( SectorNumber++ );

    if ( ( ulReserveVDSExtentStart + ulReserveVDSExtentBlocks ) > SectorNumber ) {

        ULONG ZeroSectors = ulReserveVDSExtentStart
                          + ulReserveVDSExtentBlocks
                          - SectorNumber;

        WriteZeroedSectors( SectorNumber, ZeroSectors );
        SectorNumber = ulReserveVDSExtentStart + ulReserveVDSExtentBlocks;
        }

    if ( SectorNumber < ulPartitionStart ) {
        WriteZeroedSectors( SectorNumber, ulPartitionStart - SectorNumber );
        SectorNumber = ulPartitionStart;
        }


    // now partition should start here
    ASSERT( ulPartitionStart == SectorNumber);

    // partition start should be 16 sector (32K byte) aligned
    ASSERT( ISALIGN2( ulPartitionStart, 16 ) );

    ASSERT( ulFSDExtentStart == 0 );    // sector offset zero within partition

    SectorNumber = ulFSDExtentStart;
    WriteFsdDescriptor( SectorNumber++ );
    WriteFsdTerminator( SectorNumber++ );

    ASSERT( SectorNumber == ulFSDExtentStart + ulFSDExtentBlocks );

    }

/***
 *      Returns pointer to byte position to write the next FID
 *
 */
PUCHAR MakeFID(PUCHAR pBuffer, PDIRENTRY pFile, ULONG FidBlockNumber) {

    PNSR_FID pFid = (PNSR_FID) pBuffer;
    size_t cbStruct;
    ULONG dwNameLength;
    LPWSTR pszUnicodeName;

    if(!(pFile->dwFlags & IS_DIRECTORY) && (pFile->dwlFileSize == 0))
    {
        BYTE* pBuffer;
        PICBFILE pIcb;
        DWORDLONG dwlOffset;

#ifdef UDF_DBG
        printf("Zero-Length file [%S] found\r\n",pFile->pszUnicodeName);
#endif

        // zero length files didn't go through the file transfer code
        pBuffer = AllocateBuffer( CD_SECTORSIZE, TRUE );
        pIcb = (PICBFILE) pBuffer;


        // if optimization is on and another 0 length file exists, lets link'em
        if(bZeroLengthIcbSaved && bOptimizeStorage)
        {
            pFile->pUdfInfo->ulICBBlockNumber = dwZeroLengthIcb;
            dwlOffset = (DWORDLONG) pFile->pUdfInfo->ulICBBlockNumber * (DWORDLONG) CD_SECTORSIZE;

            // already there, just update ICB link count
            GenericRead(dwlOffset,CD_SECTORSIZE,pBuffer);
            pIcb->icbfile_LinkCount++;
            pFile->pUdfInfo->ulLinkCount=pIcb->icbfile_LinkCount;

            dwlTotalDupFileBytes=CD_SECTORSIZE;
            gdwSpaceSaved+=CD_SECTORSIZE;
            dwlTotalDupFiles++;

			if(bShowDuplicates)
                printf("\r\nZero-Length Duplicate file [%S] found",pFile->pszUnicodeName);
        }
        else
        {
            pIcb->icbfile_icbtag.icbtag_Flags = ICBTAG_F_ALLOC_IMMEDIATE;
            pIcb->icbfile_AllocLen = 0;
            pIcb->icbfile_BlocksRecorded = 0;
            pIcb->icbfile_LinkCount=1;

            // what is the next available sector?
            pFile->pUdfInfo->ulICBBlockNumber=dwTotalImageBlocks++;
            pFile->pUdfInfo->ulLinkCount=1;

            bZeroLengthIcbSaved=TRUE;
            dwZeroLengthIcb=pFile->pUdfInfo->ulICBBlockNumber;

            dwlOffset = (DWORDLONG) pFile->pUdfInfo->ulICBBlockNumber * (DWORDLONG) CD_SECTORSIZE;
        }

        ASSERT( pIcb->icbfile_LinkCount > 0);
        HeaderWrite(dwlOffset,pIcb,CD_SECTORSIZE);

        // this should finish up the ICBfile struct with the right times, CRC and everything

        // BUGBUG - Might have to come back to this
        WriteICBFileEntry(pFile,(DWORDLONG) -1);

        // I need to restore the block number because WriteICBFileEntry messes with it
        pFile->pUdfInfo->ulICBBlockNumber = dwZeroLengthIcb;
    }

    pFid->nsr_fid_Version = 1;          // UDF 2.3.4.1

    if ( pFile->dwFlags & IS_DIRECTORY )
        pFid->nsr_fid_Flags |= NSR_FID_F_DIRECTORY;

    if ( pFile->dwFlags & IS_HIDDEN )
        pFid->nsr_fid_Flags |= NSR_FID_F_HIDDEN;

    pszUnicodeName = pFile->pszUnicodeName;

    if ( pszUnicodeName ) {
        dwNameLength = pFile->wUnicodeNameLength * 2;
        }
    else {
        pszUnicodeName = AnsiToUnicode( pFile->pszFileName, wchStaticUnicodeBuffer );
        dwNameLength = pFile->wFileNameLength * 2;
        }

    ASSERT( pszUnicodeName != NULL );
    ASSERT( dwNameLength != 0 );
	ASSERT( (dwNameLength % 2) == 0);

//	DEBUGCODE( wprintf(L"File name = %s ",pszUnicodeName) );

    if (bUdf8BitFileNames) {
        pFid->nsr_fid_FileIDLen = (UCHAR)( OSTA8BitUnicodeLen( dwNameLength ));
    } else {
        pFid->nsr_fid_FileIDLen = (UCHAR)( OSTA16BitUnicodeLen( dwNameLength ));
    }

//	ASSERT((pFid->nsr_fid_FileIDLen % 2) == 0);

    pFid->nsr_fid_icb.longad_Length = CD_SECTORSIZE;
    if(pFile->dwFlags & IS_DIRECTORY )
        pFid->nsr_fid_icb.longad_Start.nsr_lba_lbn = pFile->pUdfInfo->ulICBBlockNumber;
    else
        pFid->nsr_fid_icb.longad_Start.nsr_lba_lbn = pFile->pUdfInfo->ulICBBlockNumber - ulPartitionStart;

	pFid->nsr_fid_icb.longad_Start.nsr_lba_PartRef = 0;

    ASSERT( pFid->nsr_fid_ImpUseLen == 0 );
    if (bUdf8BitFileNames) {
        memcpy( pBuffer+38, OSTA8BitUnicode( pszUnicodeName, dwNameLength, OSTABuffer ), pFid->nsr_fid_FileIDLen );
    } else {
        memcpy( pBuffer+38, OSTA16BitUnicode( pszUnicodeName, dwNameLength, OSTABuffer ), pFid->nsr_fid_FileIDLen );
    }

//	DEBUGCODE( wprintf(L"Recorded file name = %s", ((PBYTE) pFid->nsr_fid_ImpUse) + pFid->nsr_fid_ImpUseLen) );


    // Fill in Descriptor Tag
    pFid->nsr_fid_destag.destag_Ident = DESTAG_ID_NSR_FID;
    pFid->nsr_fid_destag.destag_Version = GetDesTagVersion();
    pFid->nsr_fid_destag.destag_CRCLen =
        (USHORT)(( cbStruct = ( ( 38 + pFid->nsr_fid_FileIDLen + 3 ) & ~3 ) ) - sizeof( DESTAG ));
    pFid->nsr_fid_destag.destag_CRC =
        Crc16( 0, (PUCHAR)pFid+sizeof(DESTAG), pFid->nsr_fid_destag.destag_CRCLen );
    pFid->nsr_fid_destag.destag_lsn = FidBlockNumber;

   pFid->nsr_fid_destag.destag_Checksum = 0;
    // Fill in checksum last
    pFid->nsr_fid_destag.destag_Checksum =
        ComputeChecksum( (PUCHAR)&pFid->nsr_fid_destag, sizeof (DESTAG) );

    return ( pBuffer + cbStruct );

    }


/***
 *      Returns pointer to byte position to write the next FID
 *
 */

PUCHAR MakeParentFID(PUCHAR pBuffer, PDIRENTRY pDir, ULONG FidBlockNumber) {

    PNSR_FID pFid = (PNSR_FID) pBuffer;

    ASSERT( pDir->dwFlags & IS_DIRECTORY );
    ASSERT( pDir->pParentDir->dwFlags & IS_DIRECTORY );

    pFid->nsr_fid_Version = 1;          // UDF 2.3.4.1
    pFid->nsr_fid_Flags = NSR_FID_F_PARENT | NSR_FID_F_DIRECTORY;
    pFid->nsr_fid_FileIDLen = 0;        // 4/14.4.4: Parent has IDLen of 0

    pFid->nsr_fid_icb.longad_Length = CD_SECTORSIZE;
    pFid->nsr_fid_icb.longad_Start.nsr_lba_lbn = pDir->pParentDir->pUdfInfo->ulICBBlockNumber;

    pFid->nsr_fid_icb.longad_Start.nsr_lba_PartRef = 0;

    ASSERT( pFid->nsr_fid_ImpUseLen == 0 );

    // Fill in Descriptor Tag
    pFid->nsr_fid_destag.destag_Ident = DESTAG_ID_NSR_FID;
    pFid->nsr_fid_destag.destag_Version = GetDesTagVersion();
    pFid->nsr_fid_destag.destag_CRCLen = (USHORT)( PARENTFID_LEN - sizeof( DESTAG ));
    pFid->nsr_fid_destag.destag_CRC =
        Crc16( 0, (PUCHAR)pFid+sizeof(DESTAG), pFid->nsr_fid_destag.destag_CRCLen );
    pFid->nsr_fid_destag.destag_lsn = FidBlockNumber;

   pFid->nsr_fid_destag.destag_Checksum = 0;
    // Fill in checksum last
    pFid->nsr_fid_destag.destag_Checksum =
        ComputeChecksum( (PUCHAR)&pFid->nsr_fid_destag, sizeof (DESTAG) );

    return ( pBuffer + PARENTFID_LEN );

    }

void GetFullPath (PDIRENTRY pFile, LPWSTR PathName)
{
   if (!pFile || pFile->pParentDir == pFile)
   {
      AnsiToUnicode(pszSourceTree, PathName);
      return;
   }

   GetFullPath(pFile->pParentDir, PathName);
   lstrcatW(PathName, L"\\");
   lstrcatW(PathName, pFile->pszUnicodeName);
}

void WriteICBFileEntry( PDIRENTRY pFile, DWORDLONG UniqueID )
{
    PUCHAR pBuffer, pMem, pStartFID;
    PDIRENTRY pSubFile;
    PICBFILE pIcb;
    SHORTAD ShortFileExtent;
    USHORT  NumExtents = 1;
    PNSR_XAH pXah;
    PNSR_XA_FILETIMES pXaTime;
    PTIMESTAMP pTimeStamp;
    ULONG      FidBlockNumber;

	if (GetCurrentUDFVersion() >= 0x200)
	{
		WriteICBExtendedFileEntry(pFile,UniqueID);
		return;
	};

    if(pFile->pUdfInfo->ulLinkCount == 0)
    {
        // ICB already written by other linked file
        return;
    }

    pBuffer = AllocateBuffer( CD_SECTORSIZE, TRUE );
    pIcb = (PICBFILE) pBuffer;

    // load ICB from image if it's a file's
    if(!(pFile->dwFlags & IS_DIRECTORY))
    {
        DWORDLONG dwlOffset;

        dwlOffset= (DWORDLONG) pFile->pUdfInfo->ulICBBlockNumber * (DWORDLONG) CD_SECTORSIZE;

        //DEBUGCODE( printf("Block # is %u\n",pFile->pUdfInfo->ulICBBlockNumber) );

        pFile->pUdfInfo->ulICBBlockNumber-=ulPartitionStart;    // adjust the ICB to fit the partition
        GenericRead(dwlOffset,CD_SECTORSIZE,pBuffer);
        ASSERT( pIcb->icbfile_LinkCount > 0);
    }

    // Fill in ICB Tag
    pIcb->icbfile_icbtag.icbtag_PriorDirectCount = 0;
    pIcb->icbfile_icbtag.icbtag_StratType  = ICBTAG_STRAT_DIRECT;
    pIcb->icbfile_icbtag.icbtag_StratParm  = 0;
    pIcb->icbfile_icbtag.icbtag_MaxEntries = 1;
    pIcb->icbfile_icbtag.icbtag_FileType = (UCHAR)((pFile->dwFlags & IS_DIRECTORY) ?
                                    ICBTAG_FILE_T_DIRECTORY : ICBTAG_FILE_T_FILE );
    ASSERT( pIcb->icbfile_icbtag.icbtag_icbParent.nsr_lba_lbn == 0 );
    ASSERT( (pIcb->icbfile_icbtag.icbtag_Flags == ICBTAG_F_ALLOC_LONG) ||
            (pIcb->icbfile_icbtag.icbtag_Flags == ICBTAG_F_ALLOC_SHORT) ||
            (pIcb->icbfile_icbtag.icbtag_Flags & ICBTAG_F_ALLOC_IMMEDIATE));

    // Fill File fields
    pIcb->icbfile_UID = pIcb->icbfile_GID = (ULONG) ( ( 1 << 32 ) - 1 );    // UDF 3.3.3.1 and .2
    pIcb->icbfile_Permissions =
      ICBFILE_PERM_OTH_X | ICBFILE_PERM_OTH_R | ICBFILE_PERM_OTH_A |
      ICBFILE_PERM_GRP_X | ICBFILE_PERM_GRP_R | ICBFILE_PERM_GRP_A |
      ICBFILE_PERM_OWN_X | ICBFILE_PERM_OWN_R | ICBFILE_PERM_OWN_A;


    ASSERT( pIcb->icbfile_RecordFormat  == 0 );          // UDF 2.3.6.1
    ASSERT( pIcb->icbfile_RecordDisplay == 0 );         // UDF 2.3.6.2
    ASSERT( pIcb->icbfile_RecordLength  == 0 );          // UDF 2.3.6.3

    *(UNALIGNED DWORDLONG*)&(pIcb->icbfile_InfoLength) = (pFile->dwFlags & IS_DIRECTORY) ?
                                                pFile->pUdfInfo->ulFIDLength :
                                                pFile->dwlFileSize;
	// file already set
	if(pFile->dwFlags & IS_DIRECTORY)
    {
        pIcb->icbfile_LinkCount = (USHORT)pFile->pUdfInfo->ulLinkCount;
		pIcb->icbfile_BlocksRecorded = CD_BLOCKS_FROM_SIZE (*(UNALIGNED DWORDLONG*)&(pIcb->icbfile_InfoLength));
    }

    //DEBUGCODE( printf("Link count = %u\n", (USHORT) pFile->pUdfInfo->ulLinkCount) );
    ASSERT( pIcb->icbfile_LinkCount > 0);


    if ( bUseGlobalTime )
	{
        CopyStruct( pIcb->icbfile_AccessTime, GlobalNsrTimeStamp );
        CopyStruct( pIcb->icbfile_ModifyTime, GlobalNsrTimeStamp );
        CopyStruct( pIcb->icbfile_AttributeTime, GlobalNsrTimeStamp );
    }
    else
	{
        ASSERT( *(UNALIGNED DWORDLONG*)&(pFile->pFileTimeInfo->ftLastWriteTime) != 0 );
        MakeNsrTimeStampFromFileTime( &(pIcb->icbfile_ModifyTime), pFile->pFileTimeInfo->ftLastWriteTime );

        // LastAccessTime may be 0 (e.g. on CDFS)
        // we don't want to encode 0 for UDF's LastAccessTime
        if ( *(UNALIGNED DWORDLONG*)&(pFile->pFileTimeInfo->ftLastAccessTime) != 0 )
            MakeNsrTimeStampFromFileTime( &(pIcb->icbfile_AccessTime), pFile->pFileTimeInfo->ftLastAccessTime );
        else
            CopyStruct( pIcb->icbfile_AccessTime, pIcb->icbfile_ModifyTime );

        CopyStruct( pIcb->icbfile_AttributeTime, pIcb->icbfile_ModifyTime );
    }

    pIcb->icbfile_Checkpoint = 1;   // ISO 4/14.0.15

    CopyStruct(pIcb->icbfile_ImpUseID, *GetImplementationID());

    if(UniqueID != (DWORDLONG) -1)
    {
        *(UNALIGNED DWORDLONG*)&(pIcb->icbfile_UniqueID) = UniqueID;
    }

    pIcb->icbfile_XALength = XA_LENGTH;

    // fill in File Creation Time in XA File Times field
    pXaTime = (PNSR_XA_FILETIMES) ( pIcb->icbfile_XAs + 24 );
    pXaTime->nsr_xa_filetimes_XAType     = 5;   // 4/14/10.5
    pXaTime->nsr_xa_filetimes_XASubType  = 1;
    pXaTime->nsr_xa_filetimes_XALength   = 32;  // length of this EA:
                                                // 20 (File Time EA format) + 12 (one timestamp)
    pXaTime->nsr_xa_filetimes_DataLength = 12;  // one timestamp
    pXaTime->nsr_xa_filetimes_Existence  = XA_FILETIMES_E_CREATION;

    pTimeStamp = (PTIMESTAMP) &(pXaTime->nsr_xa_filetimes_XAData);
    if ( bUseGlobalTime )
    {
       CopyStruct( *pTimeStamp,     GlobalNsrTimeStamp );   // Create Date
    }
    else
	{
        // ISO13346 4/14.9.12 & 4/14.9.13 stipulate that LastAccessTime
        // and LastWriteTime not be earlier than CreationTime
        FILETIME ftCreationTime = pFile->pFileTimeInfo->ftCreationTime;

        if (*(UNALIGNED DWORDLONG*)&(pFile->pFileTimeInfo->ftLastAccessTime) < *(UNALIGNED DWORDLONG*)&ftCreationTime)
            ftCreationTime = pFile->pFileTimeInfo->ftLastAccessTime;
        if (*(UNALIGNED DWORDLONG*)&(pFile->pFileTimeInfo->ftLastWriteTime) < *(UNALIGNED DWORDLONG*)&ftCreationTime)
            ftCreationTime = pFile->pFileTimeInfo->ftLastWriteTime;
        if (*(UNALIGNED DWORDLONG*)&(ftCreationTime) == 0)    // don't want to encode a 0 timestamp
            ftCreationTime = pFile->pFileTimeInfo->ftLastWriteTime;

        MakeNsrTimeStampFromFileTime( pTimeStamp,   ftCreationTime );   // Create Date
	}

    pXah = (PNSR_XAH) &(pIcb->icbfile_XAs);
    if (GetCurrentUDFVersion() < 0x200)
	{
		pXah->nsr_xah_XAImp = XA_LENGTH;            // point to the end of XA field
		pXah->nsr_xah_XAApp = XA_LENGTH;            // see UDF 3.3.4.1
    }
	else
	{
	    pXah->nsr_xah_XAImp = 0xFFFFFFFF;
		pXah->nsr_xah_XAApp = 0xFFFFFFFF;          //UDF 2.00+ 3.3.4.1
	}

    pXah->nsr_xah_destag.destag_Ident   = DESTAG_ID_NSR_XA;
    pXah->nsr_xah_destag.destag_Version = GetDesTagVersion();
    pXah->nsr_xah_destag.destag_CRCLen  = 8;
    pXah->nsr_xah_destag.destag_CRC     =
        Crc16( 0, (PUCHAR)pXah+sizeof(DESTAG), pXah->nsr_xah_destag.destag_CRCLen );
    pXah->nsr_xah_destag.destag_lsn = pFile->pUdfInfo->ulICBBlockNumber;

    pXah->nsr_xah_destag.destag_Checksum = 0;
    // Fill in checksum last
    pXah->nsr_xah_destag.destag_Checksum =
        ComputeChecksum( (PUCHAR)&pXah->nsr_xah_destag, sizeof (DESTAG) );

    if ( pFile->dwFlags & IS_DIRECTORY )
    {
      if (bVerbose)
         printf("FIDLength: [0x%lx]\r\n", pFile->pUdfInfo->ulFIDLength);

      if (bUdfEmbedFID && (pFile->pUdfInfo->ulFIDLength <= (CD_SECTORSIZE - (176+XA_LENGTH))))
      {
         FidBlockNumber = pFile->pUdfInfo->ulICBBlockNumber;

         if (bVerbose)
            printf("FIDBlockNumber: [0x%lx]\r\n", FidBlockNumber);

         pStartFID = pBuffer + 176 + XA_LENGTH;

         pMem = MakeParentFID( pStartFID, pFile, FidBlockNumber );

         for ( pSubFile = pFile->pDirectoryInfo->pFirstTargetFile; pSubFile; pSubFile = pSubFile->pNextTargetFile )
         {
             pMem = MakeFID( pMem, pSubFile, FidBlockNumber);
         }

         // We found a directory where we can embed the FIDs!
         pIcb->icbfile_icbtag.icbtag_Flags |= ICBTAG_F_ALLOC_IMMEDIATE;
         pIcb->icbfile_AllocLen = pMem - pStartFID;
         ASSERT ( ( 176 + XA_LENGTH + (USHORT)pIcb->icbfile_AllocLen ) <= CD_SECTORSIZE );

         if (bVerbose)
            printf("Embedded FIDs for: [%ls]!\r\n", pFile->pszUnicodeName);

         pIcb->icbfile_BlocksRecorded = 0;
         gdwSpaceSaved+=CD_SECTORSIZE;
      }
      else
      {
         // Directory ICB points to FID extent
         // FID extent starts the next block following the ICB
         ShortFileExtent.shortad_Length = pFile->pUdfInfo->ulFIDLength;
         ShortFileExtent.shortad_Start  = pFile->pUdfInfo->ulICBBlockNumber + 1;
         pIcb->icbfile_AllocLen = NumExtents * sizeof (SHORTAD);
         memcpy(pBuffer+176+XA_LENGTH, &ShortFileExtent, pIcb->icbfile_AllocLen);
      }
    }

    // Fill in Descriptor Tag
    pIcb->icbfile_destag.destag_Ident    = DESTAG_ID_NSR_FILE;
    pIcb->icbfile_destag.destag_Version  = GetDesTagVersion();
    pIcb->icbfile_destag.destag_CRCLen   = (USHORT)(( 176 + XA_LENGTH + (USHORT)pIcb->icbfile_AllocLen ) - sizeof( DESTAG ));
    pIcb->icbfile_destag.destag_CRC =
        Crc16( 0, (PUCHAR)pIcb+sizeof(DESTAG), pIcb->icbfile_destag.destag_CRCLen );
    pIcb->icbfile_destag.destag_lsn = pFile->pUdfInfo->ulICBBlockNumber;

    pIcb->icbfile_destag.destag_Checksum = 0;
    // Fill in checksum last
    pIcb->icbfile_destag.destag_Checksum =
        ComputeChecksum( (PUCHAR)&pIcb->icbfile_destag, sizeof (DESTAG) );

    ASSERT ( ( 176 + XA_LENGTH + (USHORT)pIcb->icbfile_AllocLen ) <= CD_SECTORSIZE );

    {
        DWORDLONG dwlICBOffset;
        dwlICBOffset = ((DWORDLONG)ulPartitionStart + (DWORDLONG) pFile->pUdfInfo->ulICBBlockNumber) * (DWORDLONG) CD_SECTORSIZE;

		if(bVerbose)
			printf("Offset is %I64u\r\n",dwlICBOffset);

        HeaderWrite(dwlICBOffset, pBuffer, CD_SECTORSIZE );
    }

}

void WriteICBExtendedFileEntry( PDIRENTRY pFile, DWORDLONG UniqueID )
{
    PUCHAR pBuffer, pMem, pStartFID;
    PDIRENTRY pSubFile;
    PICBEXTFILE pIcb;
    SHORTAD ShortFileExtent;
    USHORT  NumExtents = 1;

    ULONG      FidBlockNumber;

	ASSERT(GetCurrentUDFVersion() >= 0x200);

    if(pFile->pUdfInfo->ulLinkCount == 0)
    {
        // ICB already written by other linked file
        return;
    }

    pBuffer = AllocateBuffer( CD_SECTORSIZE, TRUE );
    pIcb = (PICBEXTFILE) pBuffer;

    // load ICB from image if it's a file's
    if(!(pFile->dwFlags & IS_DIRECTORY))
    {
        DWORDLONG dwlOffset;
		PICBFILE  pICBBuffer;

		pICBBuffer =  AllocateBuffer( CD_SECTORSIZE, TRUE );
        dwlOffset= (DWORDLONG) pFile->pUdfInfo->ulICBBlockNumber * (DWORDLONG) CD_SECTORSIZE;

        //DEBUGCODE( printf("Block # is %u\n",pFile->pUdfInfo->ulICBBlockNumber) );

        pFile->pUdfInfo->ulICBBlockNumber-=ulPartitionStart;    // adjust the ICB to fit the partition
        GenericRead(dwlOffset,CD_SECTORSIZE,pICBBuffer);
		
		// This has to be done because, part of the ICB (allocation info)
		// is written by  the thread which writes file data.
		// And that info is written as a File Entry.
		// So, we have to change it to an extended
		// Entry and rewrite that information

		CopyStruct(pIcb->Destag,pICBBuffer->icbfile_destag);
		CopyStruct(pIcb->Icbtag,pICBBuffer->icbfile_icbtag);
		pIcb->UID = pICBBuffer->icbfile_UID;
		pIcb->GID = pICBBuffer->icbfile_GID;
		pIcb->Permissions = pICBBuffer->icbfile_Permissions;
		pIcb->LinkCount = pICBBuffer->icbfile_LinkCount;
		pIcb->Permissions = pICBBuffer->icbfile_Permissions;
		// Record info should be zero so not copying
		pIcb->InfoLength = pICBBuffer->icbfile_InfoLength;
		pIcb->BlocksRecorded = pICBBuffer->icbfile_BlocksRecorded;
		//Access time etc are set later
		CopyStruct(pIcb->IcbEA,pICBBuffer->icbfile_icbXA);
		pIcb->AllocLength =  pICBBuffer->icbfile_AllocLen;
		//Implementation ID and Unique ID are set later
		memcpy(pIcb->EAs
			,pICBBuffer->icbfile_XAs+XA_LENGTH
			,pICBBuffer->icbfile_AllocLen);
		// Whew! Quite a kludge! but, has to be there till CDImage is redesigned!

		ReleaseBuffer(pICBBuffer);

        ASSERT( pIcb->LinkCount > 0);
    }

    // Fill in ICB Tag
    pIcb->Icbtag.icbtag_PriorDirectCount = 0;
    pIcb->Icbtag.icbtag_StratType  = ICBTAG_STRAT_DIRECT;
    pIcb->Icbtag.icbtag_StratParm  = 0;
    pIcb->Icbtag.icbtag_MaxEntries = 1;
    pIcb->Icbtag.icbtag_FileType = (UCHAR)((pFile->dwFlags & IS_DIRECTORY) ?
                                    ICBTAG_FILE_T_DIRECTORY : ICBTAG_FILE_T_FILE );

    ASSERT( pIcb->Icbtag.icbtag_icbParent.nsr_lba_lbn == 0 );
    ASSERT( (pIcb->Icbtag.icbtag_Flags == ICBTAG_F_ALLOC_LONG) ||
            (pIcb->Icbtag.icbtag_Flags == ICBTAG_F_ALLOC_SHORT) ||
            (pIcb->Icbtag.icbtag_Flags & ICBTAG_F_ALLOC_IMMEDIATE));

    // Fill File fields
    pIcb->UID = pIcb->GID = (ULONG) ( ( 1 << 32 ) - 1 );    // UDF 3.3.3.1 and .2
    pIcb->Permissions =
      ICBFILE_PERM_OTH_X | ICBFILE_PERM_OTH_R | ICBFILE_PERM_OTH_A |
      ICBFILE_PERM_GRP_X | ICBFILE_PERM_GRP_R | ICBFILE_PERM_GRP_A |
      ICBFILE_PERM_OWN_X | ICBFILE_PERM_OWN_R | ICBFILE_PERM_OWN_A;

    // file already set
    if(pFile->dwFlags & IS_DIRECTORY)
    {
        pIcb->LinkCount         = (USHORT)pFile->pUdfInfo->ulLinkCount;
        pIcb->BlocksRecorded    = CD_BLOCKS_FROM_SIZE (pFile->dwlFileSize);
    }

    //DEBUGCODE( printf("Link count = %u\n", (USHORT) pFile->pUdfInfo->ulLinkCount) );
    ASSERT( pIcb->LinkCount > 0);

    ASSERT( pIcb->RecordFormat  == 0 );          // UDF 2.3.6.1
    ASSERT( pIcb->RecordDisplay == 0 );         // UDF 2.3.6.2
    ASSERT( pIcb->RecordLength  == 0 );          // UDF 2.3.6.3

    *(UNALIGNED DWORDLONG*)&(pIcb->InfoLength) = (pFile->dwFlags & IS_DIRECTORY) ?
                                                pFile->pUdfInfo->ulFIDLength :
                                                pFile->dwlFileSize;
    *(UNALIGNED DWORDLONG*)&pIcb->ObjectSize = *(UNALIGNED DWORDLONG*)&(pIcb->InfoLength);

    if ( bUseGlobalTime )
	{
        CopyStruct( pIcb->AccessTime, GlobalNsrTimeStamp );
        CopyStruct( pIcb->ModifyTime, GlobalNsrTimeStamp );
        CopyStruct( pIcb->CreationTime, GlobalNsrTimeStamp );
        CopyStruct( pIcb->AttributeTime, GlobalNsrTimeStamp );
    }
    else
	{
		FILETIME ftCreationTime;
        ASSERT( *(UNALIGNED DWORDLONG*)&(pFile->pFileTimeInfo->ftLastWriteTime) != 0 );
        MakeNsrTimeStampFromFileTime( &(pIcb->ModifyTime), pFile->pFileTimeInfo->ftLastWriteTime );

        // LastAccessTime may be 0 (e.g. on CDFS)
        // we don't want to encode 0 for UDF's LastAccessTime
        if ( *(UNALIGNED DWORDLONG*)&(pFile->pFileTimeInfo->ftLastAccessTime) != 0 )
            MakeNsrTimeStampFromFileTime( &(pIcb->AccessTime), pFile->pFileTimeInfo->ftLastAccessTime );
        else
            CopyStruct( pIcb->AccessTime, pIcb->ModifyTime );

        CopyStruct( pIcb->AttributeTime, pIcb->ModifyTime );
		
		// ISO13346 4/14.9.12 & 4/14.9.13 stipulate that LastAccessTime
        // and LastWriteTime not be earlier than CreationTime
        ftCreationTime = pFile->pFileTimeInfo->ftCreationTime;

        if (*(UNALIGNED DWORDLONG*)&(pFile->pFileTimeInfo->ftLastAccessTime) < *(UNALIGNED DWORDLONG*)&ftCreationTime)
            ftCreationTime = pFile->pFileTimeInfo->ftLastAccessTime;
        if (*(UNALIGNED DWORDLONG*)&(pFile->pFileTimeInfo->ftLastWriteTime) < *(UNALIGNED DWORDLONG*)&ftCreationTime)
            ftCreationTime = pFile->pFileTimeInfo->ftLastWriteTime;
        if (*(UNALIGNED DWORDLONG*)&(ftCreationTime) == 0)    // don't want to encode a 0 timestamp
            ftCreationTime = pFile->pFileTimeInfo->ftLastWriteTime;

        MakeNsrTimeStampFromFileTime( &(pIcb->CreationTime),   ftCreationTime );
    }

    pIcb->Checkpoint = 1;   // ISO 4/14.0.15

    CopyStruct(pIcb->ImpUseID, *GetImplementationID());

    if(UniqueID != (DWORDLONG) -1)
    {
        *(UNALIGNED DWORDLONG*)&(pIcb->UniqueID) = UniqueID;
    }

    pIcb->EALength = 0;


    if ( pFile->dwFlags & IS_DIRECTORY )
    {
      if (bVerbose)
         printf("FIDLength: [0x%lx]\r\n", pFile->pUdfInfo->ulFIDLength);

      if (bUdfEmbedFID && (pFile->pUdfInfo->ulFIDLength <= (CD_SECTORSIZE - (216))))
      {
         FidBlockNumber = pFile->pUdfInfo->ulICBBlockNumber;

         if (bVerbose)
            printf("FIDBlockNumber: [0x%lx]\r\n", FidBlockNumber);

         pStartFID = pBuffer + 216 + 0;//XA_LENGTH;

         pMem = MakeParentFID( pStartFID, pFile, FidBlockNumber );

         for ( pSubFile = pFile->pDirectoryInfo->pFirstTargetFile; pSubFile; pSubFile = pSubFile->pNextTargetFile )
         {
             pMem = MakeFID( pMem, pSubFile, FidBlockNumber);
         }

         // We found a directory where we can embed the FIDs!
         pIcb->Icbtag.icbtag_Flags |= ICBTAG_F_ALLOC_IMMEDIATE;
         pIcb->AllocLength = pMem - pStartFID;
         ASSERT ( ( 216 + (USHORT)pIcb->AllocLength ) <= CD_SECTORSIZE );

         if (bVerbose)
            printf("Embedded FIDs for: [%ls]!\r\n", pFile->pszUnicodeName);

         pIcb->BlocksRecorded = 0;
         gdwSpaceSaved+=CD_SECTORSIZE;
      }
      else
      {
         // Directory ICB points to FID extent
         // FID extent starts the next block following the ICB
         ShortFileExtent.shortad_Length = pFile->pUdfInfo->ulFIDLength;
         ShortFileExtent.shortad_Start  = pFile->pUdfInfo->ulICBBlockNumber + 1;
         pIcb->AllocLength = NumExtents * sizeof (SHORTAD);
         memcpy(pBuffer+216, &ShortFileExtent, pIcb->AllocLength);
      }
    }

    // Fill in Descriptor Tag
    pIcb->Destag.destag_Ident    = DESTAG_ID_NSR_EXTFILE;
    pIcb->Destag.destag_Version  = GetDesTagVersion();
    pIcb->Destag.destag_CRCLen   = (USHORT)(( 216 + (USHORT)pIcb->AllocLength ) - sizeof( DESTAG ));
    pIcb->Destag.destag_CRC =
        Crc16( 0, (PUCHAR)pIcb+sizeof(DESTAG), pIcb->Destag.destag_CRCLen );
    pIcb->Destag.destag_lsn = pFile->pUdfInfo->ulICBBlockNumber;

    pIcb->Destag.destag_Checksum = 0;
    // Fill in checksum last
    pIcb->Destag.destag_Checksum =
        ComputeChecksum( (PUCHAR)&pIcb->Destag, sizeof (DESTAG) );

    ASSERT ( ( 216 +  (USHORT)pIcb->AllocLength ) <= CD_SECTORSIZE );

    {
        DWORDLONG dwlICBOffset;
        dwlICBOffset = ((DWORDLONG)ulPartitionStart + (DWORDLONG) pFile->pUdfInfo->ulICBBlockNumber) * (DWORDLONG) CD_SECTORSIZE;

		if(bVerbose)
			printf("Offset is %I64u\r\n",dwlICBOffset);

        HeaderWrite(dwlICBOffset, pBuffer, CD_SECTORSIZE );
    }

}


void ComputeUDFDirectorySizes( void ) {

    PDIRENTRY pDir, pFile;
    ULONG ulFIDLength;
    DWORD dwNameLength;
    UINT uLevel;

    for ( uLevel = 0; pStartOfLevel[ uLevel ]; uLevel++ ) {

        for ( pDir = pStartOfLevel[ uLevel ]; pDir; pDir = pDir->pDirectoryInfo->pNextTargetDir ) {

            // at least 1 ICB per directory
            g_dwIcbBlockCount++;

            dwNameLength = pDir->wUnicodeNameLength ?
                           pDir->wUnicodeNameLength :
                           pDir->wFileNameLength;

            ASSERT( dwNameLength != 0 );

            // each directory has one PARENTFID (..) entry
            ulFIDLength = PARENTFID_LEN;

            if ( pDir->dwFlags & IS_DIRECTORY )
                pDir->pUdfInfo->ulLinkCount = 1;        // Start from 1 for all directories

            for ( pFile = pDir->pDirectoryInfo->pFirstTargetFile; pFile; pFile = pFile->pNextTargetFile ) {

                dwNameLength = pFile->wUnicodeNameLength ?
                               pFile->wUnicodeNameLength :
                               pFile->wFileNameLength;

                ASSERT( dwNameLength != 0 );

                // each file/subdir has a FID entry
                // each FID entry is 38+Length_of_FileID bytes long
                // rounded up to the next ULONG boundary

                if (bUdf8BitFileNames) {
                    ulFIDLength += ( 38 + OSTA8BitUnicodeLen(dwNameLength * 2) + 3 ) & ~3;
                } else {
                    ulFIDLength += ( 38 + OSTA16BitUnicodeLen(dwNameLength * 2) + 3 ) & ~3;
                }

                if ( pFile->dwFlags & IS_DIRECTORY )
                {
                    pDir->pUdfInfo->ulLinkCount++;  // Increment for each subdirectories contained
                }
                else
                {
                    // at least 1 ICB per file
                    g_dwIcbBlockCount++;

                }
            }

            pDir->pUdfInfo->ulFIDLength = ulFIDLength;

            }
        }

    }

void AssignUDFDirectoryBlockNumbers( void )
{

    DWORD     dwNextBlock;
    PDIRENTRY pDir;
    UINT      uLevel;

    ASSERT( dwNextMetaBlockNumber > ANCHOR_SECTOR );

    //
    //  Implementation note:  no longer necessary to call AllocateMetaBlocks
    //  since we're guaranteed to be past the anchor sector now, so we'll
    //  use and modify the dwNextMetaBlockNumber value directly.
    //

    // Main VDS starts at next available meta block.

    ulMainVDSExtentStart  = dwNextMetaBlockNumber;
    ulMainVDSExtentBlocks = 16;         // UDF 2.2.3.1

    // Logical Volume Integrity Sequence follows Main VDS
    ulLVISExtentStart = ulMainVDSExtentStart + ulMainVDSExtentBlocks;
    ulLVISExtentBlocks = 2;            // LVID and Terminator

    // Reserve VDS starts immediately after Main VDS and LVID
    ulReserveVDSExtentStart =  ulLVISExtentStart + ulLVISExtentBlocks;
    ulReserveVDSExtentBlocks = 16;

    // FSD Extent starts at logical block 0 (within partition)
    ulFSDExtentStart = 0;
    ulFSDExtentBlocks = 2;              // FSD and FSDTerminator

    // partition starts immediately after Reserve VDS
    // partition start shall be 16 sector (32K byte) aligned
    // leaving empty sectors that will be zero-filled during WriteUDFAnchorAndVDS()
    ulPartitionStart = ulReserveVDSExtentStart + ulReserveVDSExtentBlocks;
    ulPartitionStart = ROUNDUP2( ulPartitionStart, 16 );

    // directory structures immediately follow FSD extent
    dwNextBlock = ulFSDExtentStart + ulFSDExtentBlocks;

    for ( uLevel = 0; pStartOfLevel[ uLevel ]; uLevel++ )
    {
       for ( pDir = pStartOfLevel[ uLevel ]; pDir; pDir = pDir->pDirectoryInfo->pNextTargetDir )
       {
          ASSERT( pDir->pDirectoryInfo != NULL );
          ASSERT( pDir->pUdfInfo != NULL );
          ASSERT( pDir->pUdfInfo->ulFIDLength != 0 );

          // each dir has 1 ICB and FID entries
          if ( pDir->dwFlags & IS_DIRECTORY )
          {
            pDir->pUdfInfo->ulICBBlockNumber = dwNextBlock++;
            if (!bUdfEmbedFID || (pDir->pUdfInfo->ulFIDLength > CD_SECTORSIZE-(176+XA_LENGTH)))
                dwNextBlock += CD_BLOCKS_FROM_SIZE (pDir->pUdfInfo->ulFIDLength);
          }
          else
          {
              // this is where the file icb's used to be allocated.
              ASSERT(FALSE);
          }
       }
    }


    dwNextMetaBlockNumber = ulPartitionStart + dwNextBlock;
}

void WriteSecondAnchorSector(void)
{
    ASSERT(ulAnchorSectorNumber != 0);
#ifdef UDF_DBG
    printf("Second Anchor sector = %d\r\n",ulAnchorSectorNumber);
#endif
    WriteAnchorDescriptor(ulAnchorSectorNumber);
}

void ComputeUDFPartitionLength( void )
{
    ASSERT( ulPartitionLength == 0 );
    ASSERT( ulPartitionStart  != 0 );

    ulPartitionLength = dwTotalImageBlocks - ulPartitionStart;

    // Take into account padding for second Anchor Sector at 32K boundary
    ulPartitionLength -= ulAnchorSectorNumber - ulAnchorSlackSector + 1;


    if (bVerbose)
    {
      printf("ulPartitionStart:     %d\r\n", ulPartitionStart);
      printf("dwTotalImageBlocks:   %d\r\n", dwTotalImageBlocks);
      printf("ulAnchorSectorNumber: %d\r\n", ulAnchorSectorNumber);
      printf("ulAnchdorSlackSector: %d\r\n", ulAnchorSlackSector);
      printf("ulPartitionLength:    %d\r\n", ulPartitionLength);
    }
}


void WriteUDFDirectories( void )
{

    PDIRENTRY pDir, pFile;
    PUCHAR pBuffer, pMem;
    UINT uLevel;
    DWORD dwFIDAllocation;
    DWORDLONG dwlOffset;
    ULONG FidBlockNumber;

    ASSERT(UniqueID == 0);

    dwlOffset = (DWORDLONG)( ulPartitionStart + ulFSDExtentStart + ulFSDExtentBlocks ) * CD_SECTORSIZE;

    for ( uLevel = 0; pStartOfLevel[ uLevel ]; uLevel++ )
    {
        for ( pDir = pStartOfLevel[ uLevel ]; pDir; pDir = pDir->pDirectoryInfo->pNextTargetDir )
        {
            ASSERT( pDir->pDirectoryInfo != NULL );
            ASSERT( pDir->pUdfInfo != NULL );
            ASSERT( pDir->pUdfInfo->ulFIDLength != 0 );
            //ASSERT( dwlOffset == (DWORDLONG)( ulPartitionStart + pDir->pUdfInfo->ulICBBlockNumber ) * CD_SECTORSIZE );

            // each directory has one ICB, which points to
            // the FID Extent for the directory

            if (bVerbose)
              printf("Directory ICBBlockNumber: [0x%lx]\r\n", pDir->pUdfInfo->ulICBBlockNumber);


			 WriteICBFileEntry(pDir,UniqueID++);
			
            if ( UniqueID == 1 )        // root dir must have 0
                UniqueID = 16;          // 1-15 reserved for Macintosh

            if (!bUdfEmbedFID || (pDir->pUdfInfo->ulFIDLength > CD_SECTORSIZE-176-XA_LENGTH))
            {
               dwFIDAllocation = ROUNDUP2( pDir->pUdfInfo->ulFIDLength, CD_SECTORSIZE );
               pBuffer = AllocateBuffer( dwFIDAllocation, TRUE );
               FidBlockNumber = pDir->pUdfInfo->ulICBBlockNumber + 1;
               pMem = MakeParentFID( pBuffer, pDir, FidBlockNumber );
               for ( pFile = pDir->pDirectoryInfo->pFirstTargetFile; pFile; pFile = pFile->pNextTargetFile )
               {
                   pMem = MakeFID( pMem, pFile, FidBlockNumber + (DWORD)(pMem-pBuffer)/CD_SECTORSIZE);
               }
               if (bVerbose)
                  printf("FIDBlockNumber: [0x%lx]\r\n", FidBlockNumber);
               dwlOffset = (DWORDLONG)( ulPartitionStart + FidBlockNumber ) * CD_SECTORSIZE;
               HeaderWrite( dwlOffset, pBuffer, dwFIDAllocation );
               DEBUGCODE( dwlOffset += dwFIDAllocation );
            } else {
                   FidBlockNumber = pDir->pUdfInfo->ulICBBlockNumber;
                   dwlOffset = (DWORDLONG) (ulPartitionStart + FidBlockNumber + 1) * CD_SECTORSIZE;
            }

            for ( pFile = pDir->pDirectoryInfo->pFirstTargetFile; pFile; pFile = pFile->pNextTargetFile )
            {
               if ( !( pFile->dwFlags & IS_DIRECTORY ) )
               {

                  if (bVerbose)
                    printf("File ICBBlockNumber: [0x%lx]\r\n", pFile->pUdfInfo->ulICBBlockNumber);

                  WriteICBFileEntry( pFile, UniqueID++ );
				
                  DEBUGCODE( dwlOffset += CD_SECTORSIZE );
               }
            }
        }
    }



    // UniqueID offset by 16, but root dir has Unique ID of 0
    // hence 15

    DEBUGCODE( printf("Num Dir = %I64u Num Files = %I64u Id = %I64u\n",
                      dwlTotalNumberOfDirectories,
                      dwlTotalNumberOfFiles,
                      UniqueID) );

    ASSERT( ( 15 + dwlTotalNumberOfDirectories + dwlTotalNumberOfFiles  ) == UniqueID);

    }

DWORD NumberOfStartingZeros(BYTE* pBuffer, DWORD dwBufferLength)
{
	DWORD dwCurrentPosition=0;

	if(dwBufferLength == 0)
		return 0;

	while(0 == pBuffer[dwCurrentPosition] && (dwCurrentPosition < dwBufferLength))
	{
		dwCurrentPosition++;
	}

	return dwCurrentPosition;
}

BOOL MakeFileExtent(PDIRENTRY pFile, DWORD* pdwNextFreeBlock, DWORD dwIcbBlock, HANDLE hReadContext)
{
    PICBFILE pIcb;
    DWORD dwStartingBlock;
    BOOL bResult=TRUE;
    HASH_AND_LENGTH HashAndLength;
    PSHORTAD pShortAd;

#ifdef UDF_DBG
    printf( "Make file extent - [%S]\r\n",pFile->pszUnicodeName );
#endif

	SetRandomExtentLength();

    // Max file size
    ASSERT( pFile->dwlFileSize < 0xFFFFFFFF );

    // for duplicate checking
    if(bOptimizeStorage)
    {
        if(bUdfVideoZone)
        {
            ErrorExit(0, "ERROR: Video Zone can't have symbolic links\r\n");
        }

        InitMD5( &HashAndLength.Hash );
        HashAndLength.Length = pFile->dwlFileSize;
    }

    pIcb=(PICBFILE) AllocateBuffer(CD_SECTORSIZE, TRUE);
//    printf("Got ICB memory = %p - %u\r\n",pIcb,GetCurrentThreadId());

    dwStartingBlock=*pdwNextFreeBlock;

	pIcb->icbfile_destag.destag_lsn=dwIcbBlock - ulPartitionStart;
    pFile->pUdfInfo->ulICBBlockNumber=dwIcbBlock;

    //DEBUGCODE( printf("ICB block = %u\n",dwIcbBlock) );

    if (bUdfEmbedData && (pFile->dwlFileSize <= (CD_SECTORSIZE - ICBFILE_EXTENT_OFFSET)))
    {
        BYTE* pSrcBuffer;
        BYTE* pDestBuffer;
        DWORD dwBytesRead;

        pDestBuffer =(BYTE*) pIcb;
        pDestBuffer+=ICBFILE_EXTENT_OFFSET;

        WaitForRead(hReadContext,&pSrcBuffer,&dwBytesRead);
        ASSERT(dwBytesRead <= CD_SECTORSIZE);

        CopyMemory(pDestBuffer,pSrcBuffer,dwBytesRead);

        // update hash
        if(bOptimizeStorage)
        {
            DWORD dwBytesToHash;

            // must be 64 byte chunks
            dwBytesToHash=ROUNDUP2( dwBytesRead, 64 );
            // add 0s at end
            if(dwBytesToHash != dwBytesRead)
                ZeroMemory(pSrcBuffer + dwBytesRead, dwBytesToHash - dwBytesRead);

            // make the hash
            UpdateMD5_Multiple64ByteChunks( &HashAndLength.Hash, pSrcBuffer, dwBytesToHash );
        }
        ReleaseBuffer(pSrcBuffer);
        if(dwBytesRead == pFile->dwlFileSize)
        {
            pIcb->icbfile_icbtag.icbtag_Flags = ICBTAG_F_ALLOC_IMMEDIATE;
            pIcb->icbfile_AllocLen = (DWORD)pFile->dwlFileSize;
            pIcb->icbfile_BlocksRecorded = 0;

            gdwSpaceSaved+=CD_SECTORSIZE;

            if (bVerbose)
                printf("Embedded data for: [%ls]!\r\n", pFile->pszUnicodeName);
        }
        else
        {
            ErrorExit( GETLASTERROR, "MakeFileExtent, amount read (%d) did not match file size (%I64d)\r\n", dwBytesRead,pFile->dwlFileSize);
            return FALSE;
        }
    }
    else
    {
        if(bUdfUseLongADs)
        {
            if(bUdfVideoZone)
            {
                ErrorExit(0, "ERROR: Video Zone can't have long extents\r\n");
            }

            pIcb->icbfile_icbtag.icbtag_Flags = ICBTAG_F_ALLOC_LONG;
        }
        else
        {
            pIcb->icbfile_icbtag.icbtag_Flags = ICBTAG_F_ALLOC_SHORT;
        }

        pIcb->icbfile_BlocksRecorded = 0;
        pIcb->icbfile_AllocLen=0;
        ASSERT(pIcb->icbfile_AllocLen == 0);
	    bResult=BuildSparseFileExtent(pdwNextFreeBlock,hReadContext,pIcb,&HashAndLength,pFile->dwlFileSize);
        ASSERT((pIcb->icbfile_AllocLen >= 0) && (pIcb->icbfile_AllocLen <= (CD_SECTORSIZE - ICBFILE_EXTENT_OFFSET)));
    }

    if(bResult)
    {
        DWORDLONG dwlOffset;
        PBNODE pBnode = NULL;
        BOOL bIsDuplicate=FALSE;

        if(bOptimizeStorage)
        {
            // check if it's a dup
            bIsDuplicate = LookupOrAddBnode(&pFirstBlockHashTree,
                                            &HashAndLength,
                                            pFile,
                                            &pBnode);
        }

        if(!bIsDuplicate)
        {
            // not a duplicate

            dwlOffset= (DWORDLONG) pFile->pUdfInfo->ulICBBlockNumber * (DWORDLONG) CD_SECTORSIZE;
            pFile->pUdfInfo->ulLinkCount=1;
            pIcb->icbfile_LinkCount=1;
            ASSERT(pIcb->icbfile_LinkCount > 0);

            ASSERT((pIcb->icbfile_AllocLen >= 0) && (pIcb->icbfile_AllocLen <= (CD_SECTORSIZE - ICBFILE_EXTENT_OFFSET)));
            HeaderWrite(dwlOffset,pIcb,CD_SECTORSIZE);
        }
        else
        {
            PDIRENTRY pLinkedFile;
            DWORD dwBytesSaved;

            // context is the file pointer

            pLinkedFile=(PDIRENTRY) pBnode->pContext;

            pLinkedFile->pUdfInfo->ulLinkCount++;
            pFile->pUdfInfo->ulICBBlockNumber=pLinkedFile->pUdfInfo->ulICBBlockNumber;
            pFile->pUdfInfo->ulLinkCount=0;
			
            // read icb from disk, increment link and save it out
            dwlOffset= (DWORDLONG) pLinkedFile->pUdfInfo->ulICBBlockNumber * (DWORDLONG) CD_SECTORSIZE;
            // generic read doesn't allocate memory, overwrite ICB
            GenericRead(dwlOffset,CD_SECTORSIZE,pIcb);
            ASSERT(pIcb->icbfile_LinkCount > 0);
            pIcb->icbfile_LinkCount++;

            dwBytesSaved=(DWORD)(pIcb->icbfile_BlocksRecorded + 1) * CD_SECTORSIZE;
            dwlTotalDupFileBytes+=dwBytesSaved;
            gdwSpaceSaved+=dwBytesSaved;
            dwlTotalDupFiles++;

			if(bShowDuplicates)
				printf("\r\nDuplicate file [%S] found, saved %u bytes",pFile->pszUnicodeName,(pIcb->icbfile_BlocksRecorded + 1) * CD_SECTORSIZE);

            // reset image size
            *pdwNextFreeBlock=dwStartingBlock;

            // write last so that memory will be valid
            ASSERT( pIcb->icbfile_LinkCount > 0);
            HeaderWrite(dwlOffset,pIcb,CD_SECTORSIZE);
        }
    }

    // for bridge media
    if(bEncodeUdf && !bEncodeOnlyUdf)
    {
        ASSERT((pIcb->icbfile_icbtag.icbtag_Flags & ICBTAG_F_ALLOC_MASK)== ICBTAG_F_ALLOC_SHORT);

        if((pIcb->icbfile_icbtag.icbtag_Flags & ICBTAG_F_ALLOC_MASK) != ICBTAG_F_ALLOC_SHORT)
        {
            ErrorExit(0, "Bridge media can only support short allocation descriptors\r\n");
        }

        pShortAd = (PSHORTAD) ((PBYTE) pIcb + ICBFILE_EXTENT_OFFSET);

        // BUGBUG
        pFile->dwStartingBlock = pShortAd->shortad_Start + ulPartitionStart;

		ASSERT(pFile->dwStartingBlock != 0);
    }

#ifdef UDF_DBG
	printf"Last free block = %u - partition start -%u\r\n",*pdwNextFreeBlock,ulPartitionStart);
#endif

	return bResult;
}


BOOL MakeSparseExtent(PICBFILE pIcb, BYTE** pBuffer, DWORD* pdwBytesRead, HANDLE hReadContext, DWORD* pdwNextFreeBlock, PHASH_AND_LENGTH pHashAndLength, DWORDLONG* pdwlFileLengthLeft)
{
	DWORD dwNumZeros;
	DWORD dwCurrentLength=0;
    SHORTAD ShortAd;
    LONGAD LongAd;

#ifdef UDF_DBG
	printf("Starting sparse extent\r\n");
#endif
    ASSERT(*pdwlFileLengthLeft >= *pdwBytesRead);
    dwNumZeros=NumberOfStartingZeros(*pBuffer,*pdwBytesRead);
    ASSERT((pIcb->icbfile_AllocLen >= 0) && (pIcb->icbfile_AllocLen <= (CD_SECTORSIZE - ICBFILE_EXTENT_OFFSET)));
	do
	{
        // update hash
        if(bOptimizeStorage)
        {
            DWORD dwBytesToHash;

            // must be 64 byte chunks
            dwBytesToHash=ROUNDUP2( *pdwBytesRead, 64 );
            // add 0s at end
            if(dwBytesToHash != *pdwBytesRead)
                ZeroMemory(*pBuffer + *pdwBytesRead, dwBytesToHash - *pdwBytesRead);

            // make the hash
            UpdateMD5_Multiple64ByteChunks( &(pHashAndLength->Hash), *pBuffer, dwBytesToHash );
        }

        dwCurrentLength+=dwNumZeros;
        (*pdwlFileLengthLeft)-=dwNumZeros;

        ReleaseBuffer(*pBuffer);
        if(*pdwlFileLengthLeft > 0)
        {
            DWORD dwStatus;

            ASSERT((pIcb->icbfile_AllocLen >= 0) && (pIcb->icbfile_AllocLen <= (CD_SECTORSIZE - ICBFILE_EXTENT_OFFSET)));
            dwStatus=WaitForRead(hReadContext,pBuffer,pdwBytesRead);
            ASSERT(((*pdwBytesRead < CD_SECTORSIZE) && (dwStatus != 0)) || (*pdwBytesRead == CD_SECTORSIZE));
            ASSERT(*pdwlFileLengthLeft >= *pdwBytesRead);
            ASSERT((dwStatus == 0) || ((dwStatus != 0) && (*pdwlFileLengthLeft == *pdwBytesRead)));
            dwNumZeros=NumberOfStartingZeros(*pBuffer,*pdwBytesRead);
        }
        ASSERT((pIcb->icbfile_AllocLen >= 0) && (pIcb->icbfile_AllocLen <= (CD_SECTORSIZE - ICBFILE_EXTENT_OFFSET)));
    }while(((dwCurrentLength + *pdwBytesRead) <= EXTENTAD_LEN_MASK) && (dwNumZeros == *pdwBytesRead) && (*pdwlFileLengthLeft > 0));

	gdwSpaceSaved+=dwCurrentLength;

    if(pIcb->icbfile_icbtag.icbtag_Flags & ICBTAG_F_ALLOC_LONG)
    {
        LongAd.longad_Start.nsr_lba_lbn=0;
        LongAd.longad_Start.nsr_lba_PartRef=0;      // 0 is the first partition
        LongAd.longad_Length=EXTENTAD_ALLOC_NRNA | (dwCurrentLength & EXTENTAD_LEN_MASK);
        AddNewLongExtent(pIcb,&LongAd,pdwNextFreeBlock);
    }
    else
    {
        ShortAd.shortad_Start=0;
	    ShortAd.shortad_Length=EXTENTAD_ALLOC_NRNA | (dwCurrentLength & EXTENTAD_LEN_MASK);
        AddNewShortExtent(pIcb,&ShortAd,pdwNextFreeBlock);
    }

    ASSERT((pIcb->icbfile_AllocLen >= 0) && (pIcb->icbfile_AllocLen <= (CD_SECTORSIZE - ICBFILE_EXTENT_OFFSET)));

#ifdef UDF_DBG
	printf("Done with Sparse extent\r\n");
    //printf("length = %08x Start=%u\r\n",pShortExt->shortad_Length,pShortExt->shortad_Start);
    if(*pdwBytesRead == CD_SECTORSIZE)
    {
        ASSERT((((ShortAd.shortad_Length & EXTENTAD_LEN_MASK) % CD_SECTORSIZE) == 0) ||
               (((LongAd.longad_Length & EXTENTAD_LEN_MASK) % CD_SECTORSIZE) == 0));
    }
#endif

	return TRUE;
}

BOOL MakeAllocExtent(PICBFILE pIcb, BYTE** pBuffer, DWORD* pdwBytesRead, HANDLE hReadContext, DWORD* pdwNextFreeBlock, BOOL bSparse, PHASH_AND_LENGTH pHashAndLength, DWORDLONG* pdwlFileLengthLeft)
{
	DWORD dwNumZeros=0;
	DWORD dwCurrentLength=0;
	DWORDLONG dwlOffset;
    SHORTAD ShortAd;
    LONGAD LongAd;
    ULONG ulLBN;

#ifdef UDF_DBG
	printf("Starting Alloc extent\r\n");
#endif

    ASSERT(*pdwlFileLengthLeft >= *pdwBytesRead);
    ulLBN=*pdwNextFreeBlock;

    ASSERT((pIcb->icbfile_AllocLen >= 0) && (pIcb->icbfile_AllocLen <= (CD_SECTORSIZE - ICBFILE_EXTENT_OFFSET)));
    do
    {
        // update hash
        if(bOptimizeStorage)
        {
            DWORD dwBytesToHash;

            // must be 64 byte chunks
            dwBytesToHash=ROUNDUP2( *pdwBytesRead, 64 );
            // add 0s at end
            if(dwBytesToHash != *pdwBytesRead)
                ZeroMemory(*pBuffer + *pdwBytesRead, dwBytesToHash - *pdwBytesRead);

            // make the hash
            UpdateMD5_Multiple64ByteChunks( &(pHashAndLength->Hash), *pBuffer, dwBytesToHash );
        }

        dwCurrentLength+=*pdwBytesRead;
		dwlOffset=(DWORDLONG) *pdwNextFreeBlock * (DWORDLONG) CD_SECTORSIZE;
		(*pdwNextFreeBlock)++;
        (*pdwlFileLengthLeft)-=*pdwBytesRead;

        PaddedFileDataWrite(dwlOffset,*pBuffer,*pdwBytesRead);

        if(*pdwlFileLengthLeft > 0)
        {
            DWORD dwStatus;

            ASSERT((pIcb->icbfile_AllocLen >= 0) && (pIcb->icbfile_AllocLen <= (CD_SECTORSIZE - ICBFILE_EXTENT_OFFSET)));
            dwStatus=WaitForRead(hReadContext,pBuffer,pdwBytesRead);

            ASSERT(((*pdwBytesRead < CD_SECTORSIZE) && (dwStatus != 0)) || (*pdwBytesRead == CD_SECTORSIZE));
            ASSERT(*pdwlFileLengthLeft >= *pdwBytesRead);
            ASSERT((dwStatus == 0) || ((dwStatus != 0) && (*pdwlFileLengthLeft == *pdwBytesRead)));

            dwNumZeros=NumberOfStartingZeros(*pBuffer,*pdwBytesRead);
//            printf("CurrentLength =%u, BytesRead = %u NumZeros =%u FileLengthLeft = %I64u\r\n",
//                    dwCurrentLength,*pdwBytesRead,dwNumZeros,*pdwlFileLengthLeft);
        }
        ASSERT((pIcb->icbfile_AllocLen >= 0) && (pIcb->icbfile_AllocLen <= (CD_SECTORSIZE - ICBFILE_EXTENT_OFFSET)));
    }while(((dwCurrentLength + *pdwBytesRead) <= EXTENTAD_LEN_MASK) && !((dwNumZeros == *pdwBytesRead) && bSparse) && (*pdwlFileLengthLeft > 0));

//    printf("LEAVING CurrentLength =%u BytesRead = %u NumZeros =%u FileLengthLeft = %I64u\r\n",
//            dwCurrentLength,*pdwBytesRead,dwNumZeros,*pdwlFileLengthLeft);

    // bugbug will this work?
    ASSERT(ulLBN >= ulPartitionStart);
    ulLBN-=ulPartitionStart;

    if(pIcb->icbfile_icbtag.icbtag_Flags & ICBTAG_F_ALLOC_LONG)
    {
        LongAd.longad_Start.nsr_lba_lbn=ulLBN;
        LongAd.longad_Start.nsr_lba_PartRef=0;  // 0 is the first partition
        LongAd.longad_Length=EXTENTAD_ALLOC__R_A | (dwCurrentLength & EXTENTAD_LEN_MASK);
        AddNewLongExtent(pIcb,&LongAd,pdwNextFreeBlock);
    }
    else
    {
        ShortAd.shortad_Start=ulLBN;
	    ShortAd.shortad_Length=EXTENTAD_ALLOC__R_A | (dwCurrentLength & EXTENTAD_LEN_MASK);
        AddNewShortExtent(pIcb,&ShortAd,pdwNextFreeBlock);
    }

    ASSERT((pIcb->icbfile_AllocLen >= 0) && (pIcb->icbfile_AllocLen <= (CD_SECTORSIZE - ICBFILE_EXTENT_OFFSET)));

#ifdef UDF_DBG
	printf("Done with Alloc extent\r\n");
    if(*pdwBytesRead == CD_SECTORSIZE)
    {
        ASSERT( ( ( (ShortAd.shortad_Length & EXTENTAD_LEN_MASK) % CD_SECTORSIZE) == 0) ||
                ( ( (LongAd.longad_Length & EXTENTAD_LEN_MASK) % CD_SECTORSIZE) == 0));
    }
#endif

	return TRUE;
}

BOOL BuildSparseFileExtent(DWORD* pdwNextFreeBlock, HANDLE hReadContext, PICBFILE pIcb, PHASH_AND_LENGTH pHashAndLength, DWORDLONG dwlFileLength)
{
	DWORD dwBytesRead;
	BOOL bResult;
	BYTE* pBuffer;
	DWORD dwNumZeros;
    DWORD dwStartBlock;
    DWORDLONG dwlFileLengthLeft;
    DWORD dwStatus;

    dwStartBlock=*pdwNextFreeBlock;
    dwlFileLengthLeft=dwlFileLength;

    dwStatus=WaitForRead(hReadContext,&pBuffer,&dwBytesRead);
    ASSERT(((dwBytesRead < CD_SECTORSIZE) && (dwStatus != 0)) || (dwBytesRead == CD_SECTORSIZE));
    ASSERT(pIcb->icbfile_AllocLen == 0);
	do
	{

		dwNumZeros=NumberOfStartingZeros(pBuffer,dwBytesRead);
		if((dwNumZeros == dwBytesRead) && bUdfSparse)
        {
            if(bUdfVideoZone)
            {
                ErrorExit(0, "ERROR: Sparse files can't not be present in Video Zone images\r\n");
            }

			bResult=MakeSparseExtent(pIcb,&pBuffer,&dwBytesRead,hReadContext,pdwNextFreeBlock,pHashAndLength,&dwlFileLengthLeft);
        }
		else
        {
			bResult=MakeAllocExtent(pIcb,&pBuffer,&dwBytesRead,hReadContext,pdwNextFreeBlock,bUdfSparse,pHashAndLength,&dwlFileLengthLeft);
        }

		if(!bResult)
		{
            ErrorExit( GETLASTERROR, "BuildSparseFileExtent could not make extent\r\n" );
			return FALSE;
		}
        ASSERT((pIcb->icbfile_AllocLen >= 0) && (pIcb->icbfile_AllocLen <= (CD_SECTORSIZE - ICBFILE_EXTENT_OFFSET)));
	}while(dwlFileLengthLeft > 0);

    pIcb->icbfile_BlocksRecorded = *pdwNextFreeBlock - dwStartBlock;

	return TRUE;
}

/************************* SHORTAD functions **********************************/

VOID AddNewShortExtent(PICBFILE pIcb, SHORTAD* pShortAD, LPDWORD pdwNextFreeBlock)
{
    DWORD dwExtentBlock;
    BYTE* pBuffer;
    DWORD dwOffset;
	SHORTAD NextAd;

    ASSERT((pIcb->icbfile_AllocLen >= 0) && (pIcb->icbfile_AllocLen <= (CD_SECTORSIZE - ICBFILE_EXTENT_OFFSET)));

    pBuffer=(BYTE*) pIcb;
    dwOffset=ICBFILE_EXTENT_OFFSET + pIcb->icbfile_AllocLen;

    if(bUdfVideoZone && (0 != pIcb->icbfile_AllocLen))
    {
        ErrorExit(0, "ERROR: Each file can only have one extent for Video Zone\r\n");
    }

    ZeroMemory(&NextAd,sizeof(SHORTAD));

	if(GetNumberOfShortExtents(pIcb) == 0)
	{
		NextAd.shortad_Length=0;
	}
	else
	{
        GetShortExtent(pIcb,GetNumberOfShortExtents(pIcb) - 1, &NextAd);
	}

	if((NextAd.shortad_Length & EXTENTAD_ALLOC_MASK) == EXTENTAD_ALLOC_NEXT)
	{
        if(bUdfVideoZone)
        {
            ErrorExit(0, "ERROR: Each file can only have one extent for Video Zone\r\n");
        }

		// continue extent

        dwExtentBlock=NextAd.shortad_Start + ulPartitionStart;
        AddNewShortAdToExtent(dwExtentBlock,pShortAD,pdwNextFreeBlock);
	}
	else if(((dwOffset + (sizeof(SHORTAD) * 2)) > CD_SECTORSIZE) ||
			(g_ulMaxAdsInExtent <= GetNumberOfShortExtents(pIcb)))
    {
        DWORDLONG dwlOffset;
        BYTE* pExtentBuffer;

		// new extent

        if(bUdfVideoZone)
        {
            ErrorExit(0, "ERROR: Each file can only have one extent for Video Zone\r\n");
        }

        pExtentBuffer =  AllocateBuffer( CD_SECTORSIZE, TRUE );
        dwExtentBlock=*pdwNextFreeBlock;
        (*pdwNextFreeBlock)++;

        InitalizeAllocationExtentDescriptor((PNSR_ALLOC) pExtentBuffer,dwExtentBlock - ulPartitionStart,pIcb->icbfile_destag.destag_lsn);

		NextAd.shortad_Length=(CD_SECTORSIZE & EXTENTAD_LEN_MASK) | EXTENTAD_ALLOC_NEXT;
        NextAd.shortad_Start=dwExtentBlock - ulPartitionStart;

        dwlOffset=(DWORDLONG) dwExtentBlock * (DWORDLONG) CD_SECTORSIZE;

        memcpy(pBuffer+dwOffset,&NextAd,sizeof(SHORTAD));
	    pIcb->icbfile_AllocLen+=sizeof(SHORTAD);

        HeaderWrite(dwlOffset, pExtentBuffer, CD_SECTORSIZE );

        AddNewShortAdToExtent(dwExtentBlock,pShortAD,pdwNextFreeBlock);
    }
    else
	{
 #ifdef UDF_DBG
		printf("Offset = %u, pIcb = %p\r\n",dwOffset,pIcb);
		printf("Length = %u\r\n",pShortAD->shortad_Length & EXTENTAD_LEN_MASK);
		printf("Start  = %u\r\n",pShortAD->shortad_Start);
#endif
		memcpy(pBuffer+dwOffset,pShortAD,sizeof(SHORTAD));
		pIcb->icbfile_AllocLen+=sizeof(SHORTAD);
	}
}

DWORD GetNumberOfShortExtents(PICBFILE pIcbFile)
{
    return (DWORD)((DWORD)pIcbFile->icbfile_AllocLen / (DWORD)sizeof(SHORTAD));
}

VOID GetShortExtent(PICBFILE pIcb, DWORD dwExtentNum, PSHORTAD pShortExt)
{
    BYTE* pBuffer;
    PSHORTAD pExtArray;

    ASSERT((pIcb->icbfile_AllocLen >= 0) && (pIcb->icbfile_AllocLen <= (CD_SECTORSIZE - ICBFILE_EXTENT_OFFSET)));

    pBuffer=(BYTE*)pIcb;
    pBuffer+=ICBFILE_EXTENT_OFFSET;
    pExtArray=(PSHORTAD)pBuffer;
    memcpy(pShortExt,&pExtArray[dwExtentNum],sizeof(SHORTAD));

#ifdef UDF_DBG
    if(bVerbose)
    {
        DWORD dwLength;
        dwLength=pShortExt->shortad_Length & EXTENTAD_LEN_MASK;
        IsShortExtentSparse(pShortExt);
	    printf("Extent %d: Length = %u [0x%x]\r\n", dwExtentNum+1, dwLength, dwLength);
	    printf("Extent %d: Start  = %u [0x%x]\r\n", dwExtentNum+1, pShortExt->shortad_Start, pShortExt->shortad_Start);
    }
#endif
}

VOID PutShortExtent(PICBFILE pIcb, DWORD dwExtentNum, PSHORTAD pShortExt)
{
    BYTE* pBuffer;
    PSHORTAD pExtArray;

    ASSERT((pIcb->icbfile_AllocLen >= 0) && (pIcb->icbfile_AllocLen <= (CD_SECTORSIZE - ICBFILE_EXTENT_OFFSET)));

    pBuffer=(BYTE*)pIcb;
    pBuffer+=ICBFILE_EXTENT_OFFSET;
    pExtArray=(PSHORTAD)pBuffer;
    memcpy(&pExtArray[dwExtentNum],pShortExt,sizeof(SHORTAD));

#ifdef UDF_DBG
    if(bVerbose)
    {
        DWORD dwLength;

        IsShortExtentSparse(pShortExt);
        dwLength=pShortExt->shortad_Length & EXTENTAD_LEN_MASK;
	    printf("Extent %d: Length = %u [0x%x]\r\n", dwExtentNum+1, dwLength, dwLength);
	    printf("Extent %d: Start  = %u [0x%x]\r\n", dwExtentNum+1, pShortExt->shortad_Start, pShortExt->shortad_Start);
    }
#endif
}

BOOL IsShortExtentSparse(PSHORTAD pShortExt)
{
    if((pShortExt->shortad_Length & EXTENTAD_ALLOC_MASK) == EXTENTAD_ALLOC_NRNA)
    {

        if(bVerbose)
            printf("Sparse Extent\r\n");

        return TRUE;
    }
    else
    {

        if(bVerbose)
            printf("Regular Extent\r\n");

        return FALSE;
    }
}

void AddNewShortAdToExtent(DWORD dwExtentBlock, SHORTAD* pShortAd, LPDWORD pdwNextFreeBlock)
{
    BYTE* pBuffer;
    DWORDLONG dwlOffset;
    PNSR_ALLOC pAllocDesc;
    BYTE* pShortAds;
    PSHORTAD pNextAd;
    DWORD dwNextBlock;

    pBuffer=AllocateBuffer(CD_SECTORSIZE, FALSE);

    dwlOffset=(DWORDLONG) dwExtentBlock * (DWORDLONG) CD_SECTORSIZE;

    GenericRead(dwlOffset,(DWORD) CD_SECTORSIZE, (PVOID) pBuffer);

    pAllocDesc=(PNSR_ALLOC) pBuffer;
    pShortAds=pBuffer + sizeof(NSR_ALLOC);

    pNextAd=(PSHORTAD) (pShortAds + pAllocDesc->nsr_alloc_AllocLen - sizeof(SHORTAD));

    if((pNextAd->shortad_Length & EXTENTAD_ALLOC_MASK) == EXTENTAD_ALLOC_NEXT)
	{
        dwNextBlock=pNextAd->shortad_Start + ulPartitionStart;
        ReleaseBuffer(pBuffer);

        AddNewShortAdToExtent(dwNextBlock,pShortAd,pdwNextFreeBlock);
	}
	else if(((pAllocDesc->nsr_alloc_AllocLen + sizeof(NSR_ALLOC) + (sizeof(SHORTAD) * 2)) > CD_SECTORSIZE) ||
             (g_ulMaxAdsInExtent <= (pAllocDesc->nsr_alloc_AllocLen / sizeof(SHORTAD))))
    {
        // it's full

        dwNextBlock=*pdwNextFreeBlock;
        (*pdwNextFreeBlock)++;

        pNextAd=(PSHORTAD) (pShortAds + pAllocDesc->nsr_alloc_AllocLen);
        pAllocDesc->nsr_alloc_AllocLen+=sizeof(SHORTAD);

        pNextAd->shortad_Length=(CD_SECTORSIZE & EXTENTAD_LEN_MASK) | EXTENTAD_ALLOC_NEXT;
        pNextAd->shortad_Start=dwNextBlock - ulPartitionStart;
        HeaderWrite(dwlOffset,pBuffer,CD_SECTORSIZE);

        pBuffer=AllocateBuffer(CD_SECTORSIZE, TRUE);
        InitalizeAllocationExtentDescriptor((PNSR_ALLOC) pBuffer,dwNextBlock-ulPartitionStart,dwExtentBlock-ulPartitionStart);

        dwlOffset=(DWORDLONG) dwNextBlock * (DWORDLONG) CD_SECTORSIZE;
        HeaderWrite(dwlOffset,pBuffer,CD_SECTORSIZE);

        AddNewShortAdToExtent(dwNextBlock,pShortAd,pdwNextFreeBlock);
    }
    else
    {
        CopyMemory(pShortAds + pAllocDesc->nsr_alloc_AllocLen, pShortAd, sizeof(SHORTAD));
        pAllocDesc->nsr_alloc_AllocLen+=sizeof(SHORTAD);

        HeaderWrite(dwlOffset,pBuffer,CD_SECTORSIZE);
    }
}


/************************* LONGAD functions **********************************/

VOID AddNewLongExtent(PICBFILE pIcb,LONGAD* pLongAd, LPDWORD pdwNextFreeBlock)
{
    BYTE* pBuffer;
    DWORD dwOffset;
    DWORD dwExtentBlock;
    LONGAD NextAd;

    ASSERT((pIcb->icbfile_AllocLen >= 0) && (pIcb->icbfile_AllocLen <= (CD_SECTORSIZE - ICBFILE_EXTENT_OFFSET)));

    pBuffer=(BYTE*) pIcb;
    dwOffset=ICBFILE_EXTENT_OFFSET + pIcb->icbfile_AllocLen;

    ZeroMemory(&NextAd,sizeof(LONGAD));

	if(GetNumberOfLongExtents(pIcb) == 0)
	{
		NextAd.longad_Length=0;
	}
	else
	{
	    GetLongExtent(pIcb,GetNumberOfLongExtents(pIcb) - 1, &NextAd);
	}

    if((NextAd.longad_Length & EXTENTAD_ALLOC_MASK) == EXTENTAD_ALLOC_NEXT)
	{
        dwExtentBlock=NextAd.longad_Start.nsr_lba_lbn + ulPartitionStart;

        AddNewLongAdToExtent(dwExtentBlock,pLongAd,pdwNextFreeBlock);
	}
	else if(((dwOffset + (sizeof(LONGAD) * 2)) > CD_SECTORSIZE) ||
             (g_ulMaxAdsInExtent <= GetNumberOfLongExtents(pIcb)))
    {
        DWORDLONG dwlOffset;
        BYTE* pExtentBuffer;

        dwExtentBlock=*pdwNextFreeBlock;
        (*pdwNextFreeBlock)++;

		pExtentBuffer =  AllocateBuffer( CD_SECTORSIZE, TRUE );

		InitalizeAllocationExtentDescriptor((PNSR_ALLOC) pExtentBuffer,dwExtentBlock - ulPartitionStart,pIcb->icbfile_destag.destag_lsn);

		NextAd.longad_Length=(CD_SECTORSIZE & EXTENTAD_LEN_MASK) | EXTENTAD_ALLOC_NEXT;
		NextAd.longad_Start.nsr_lba_PartRef=0; // 0 is the first partition
		NextAd.longad_Start.nsr_lba_lbn=dwExtentBlock - ulPartitionStart;

		dwlOffset=(DWORDLONG) dwExtentBlock * (DWORDLONG) CD_SECTORSIZE;

		CopyMemory(pBuffer+dwOffset,&NextAd,sizeof(LONGAD));
		pIcb->icbfile_AllocLen+=sizeof(LONGAD);

        HeaderWrite(dwlOffset, pExtentBuffer, CD_SECTORSIZE );

        AddNewLongAdToExtent(dwExtentBlock,pLongAd,pdwNextFreeBlock);
    }
    else
    {
#ifdef UDF_DBG
        printf("Offset = %u, pIcb = %p\r\n",dwOffset,pIcb);
	    printf("Length = %u\r\n",pLongAd->longad_Length & EXTENTAD_LEN_MASK);
	    printf("Start  = %u\r\n",pLongAd->longad_Start.nsr_lba_lbn);
#endif
	    memcpy(pBuffer+dwOffset,pLongAd,sizeof(LONGAD));
	    pIcb->icbfile_AllocLen+=sizeof(LONGAD);
    }
}

DWORD GetNumberOfLongExtents(PICBFILE pIcbFile)
{
    return (DWORD)((DWORD)pIcbFile->icbfile_AllocLen / (DWORD)sizeof(LONGAD));
}

VOID GetLongExtent(PICBFILE pIcb, DWORD dwExtentNum, PLONGAD pLongExt)
{
    BYTE* pBuffer;
    PLONGAD pExtArray;

    ASSERT((pIcb->icbfile_AllocLen >= 0) && (pIcb->icbfile_AllocLen <= (CD_SECTORSIZE - ICBFILE_EXTENT_OFFSET)));

    pBuffer=(BYTE*)pIcb;
    pBuffer+=ICBFILE_EXTENT_OFFSET;
    pExtArray=(PLONGAD)pBuffer;
    memcpy(pLongExt,&pExtArray[dwExtentNum],sizeof(LONGAD));

#ifdef UDF_DBG
    if(bVerbose)
    {
        DWORD dwLength;
        dwLength=pLongExt->longad_Length & EXTENTAD_LEN_MASK;
        IsLongExtentSparse(pLongExt);
	    printf("Extent %d: Length = %u [0x%x]\r\n", dwExtentNum+1, dwLength, dwLength);
	    printf("Extent %d: Start  = %u [0x%x]\r\n", dwExtentNum+1, pLongExt->longad_Start.nsr_lba_lbn, pLongExt->longad_Start.nsr_lba_lbn);
    }
#endif
}

VOID PutLongExtent(PICBFILE pIcb, DWORD dwExtentNum, PLONGAD pLongExt)
{
    BYTE* pBuffer;
    PLONGAD pExtArray;

    ASSERT((pIcb->icbfile_AllocLen >= 0) && (pIcb->icbfile_AllocLen <= (CD_SECTORSIZE - ICBFILE_EXTENT_OFFSET)));

    pBuffer=(BYTE*)pIcb;
    pBuffer+=ICBFILE_EXTENT_OFFSET;
    pExtArray=(PLONGAD)pBuffer;
    memcpy(&pExtArray[dwExtentNum],pLongExt,sizeof(LONGAD));

#ifdef UDF_DBG
    if(bVerbose)
    {
        DWORD dwLength;

        IsLongExtentSparse(pLongExt);
        dwLength=pLongExt->longad_Length & EXTENTAD_LEN_MASK;
	    printf("Extent %d: Length = %u [0x%x]\r\n", dwExtentNum+1, dwLength, dwLength);
	    printf("Extent %d: Start  = %u [0x%x]\r\n", dwExtentNum+1, pLongExt->longad_Start.nsr_lba_lbn, pLongExt->longad_Start.nsr_lba_lbn);
    }
#endif
}

BOOL IsLongExtentSparse(PLONGAD pLongExt)
{
    if((pLongExt->longad_Length & EXTENTAD_ALLOC_MASK) == EXTENTAD_ALLOC_NRNA)
    {

        if(bVerbose)
            printf("Sparse Extent\r\n");

        return TRUE;
    }
    else
    {

        if(bVerbose)
            printf("Regular Extent\r\n");

        return FALSE;
    }
}

VOID InitalizeAllocationExtentDescriptor(PNSR_ALLOC pAllocDesc, DWORD dwBlock, DWORD dwPrevBlock)
{
    ZeroMemory(pAllocDesc,sizeof(NSR_ALLOC));

    pAllocDesc->nsr_alloc_Prev=dwPrevBlock;
    pAllocDesc->nsr_alloc_destag.destag_Ident=DESTAG_ID_NSR_ALLOC;
    pAllocDesc->nsr_alloc_destag.destag_Version=GetDesTagVersion();
    pAllocDesc->nsr_alloc_destag.destag_lsn=dwBlock;
    pAllocDesc->nsr_alloc_destag.destag_CRCLen=sizeof(ULONG);
    pAllocDesc->nsr_alloc_destag.destag_CRC=
            Crc16(0,&(pAllocDesc->nsr_alloc_Prev),pAllocDesc->nsr_alloc_destag.destag_CRCLen);
    pAllocDesc->nsr_alloc_destag.destag_Checksum = 0;
       pAllocDesc->nsr_alloc_destag.destag_Checksum=
        ComputeChecksum( (PUCHAR)&(pAllocDesc->nsr_alloc_destag), sizeof (DESTAG) );

    SetRandomExtentLength();
}

void AddNewLongAdToExtent(DWORD dwExtentBlock, LONGAD* pLongAd, LPDWORD pdwNextFreeBlock)
{
    BYTE* pBuffer;
    DWORDLONG dwlOffset;
    PNSR_ALLOC pAllocDesc;
    BYTE* pLongAds;
    DWORD dwNextBlock;
    PLONGAD pNextAd;

#ifdef UDF_DBG
    printf("Getting extent at %u Next free = %u (long)\r\n",dwExtentBlock,*pdwNextFreeBlock);
#endif

    pBuffer=AllocateBuffer(CD_SECTORSIZE, FALSE);

    dwlOffset=(DWORDLONG) dwExtentBlock * (DWORDLONG) CD_SECTORSIZE;

    GenericRead(dwlOffset,(DWORD) CD_SECTORSIZE, (PVOID) pBuffer);

    pAllocDesc=(PNSR_ALLOC) pBuffer;
    pLongAds=pBuffer + sizeof(NSR_ALLOC);
    pNextAd=(PLONGAD) (pLongAds + (pAllocDesc->nsr_alloc_AllocLen - sizeof(LONGAD)));

	if((pNextAd->longad_Length & EXTENTAD_ALLOC_MASK) == EXTENTAD_ALLOC_NEXT)
	{
        dwNextBlock=pNextAd->longad_Start.nsr_lba_lbn + ulPartitionStart;
        ReleaseBuffer(pBuffer);

        ASSERT(dwNextBlock > ulPartitionStart);

        AddNewLongAdToExtent(dwNextBlock,pLongAd,pdwNextFreeBlock);
	}
	else if(((pAllocDesc->nsr_alloc_AllocLen + sizeof(NSR_ALLOC) + (sizeof(LONGAD) * 2)) > CD_SECTORSIZE) ||
             (g_ulMaxAdsInExtent <= (pAllocDesc->nsr_alloc_AllocLen / sizeof(LONGAD))))
    {
        // it's full
        ASSERT(pAllocDesc->nsr_alloc_AllocLen != 0);

        // need a new extent
        dwNextBlock=*pdwNextFreeBlock;
        (*pdwNextFreeBlock)++;

        pNextAd=(PLONGAD) (pLongAds + pAllocDesc->nsr_alloc_AllocLen);
        pAllocDesc->nsr_alloc_AllocLen+=sizeof(LONGAD);

        pNextAd->longad_Length=(CD_SECTORSIZE & EXTENTAD_LEN_MASK) | EXTENTAD_ALLOC_NEXT;
        pNextAd->longad_Start.nsr_lba_lbn=dwNextBlock - ulPartitionStart;
        pNextAd->longad_Start.nsr_lba_PartRef=0; // 0 is the first partition
        HeaderWrite(dwlOffset,pBuffer,CD_SECTORSIZE);

        pBuffer=AllocateBuffer(CD_SECTORSIZE, TRUE);
        InitalizeAllocationExtentDescriptor((PNSR_ALLOC) pBuffer,dwNextBlock-ulPartitionStart,dwExtentBlock-ulPartitionStart);

        dwlOffset=(DWORDLONG) dwNextBlock * (DWORDLONG) CD_SECTORSIZE;
        HeaderWrite(dwlOffset,pBuffer,CD_SECTORSIZE);

        ASSERT(dwNextBlock > ulPartitionStart);

        AddNewLongAdToExtent(dwNextBlock,pLongAd,pdwNextFreeBlock);
    }
    else
    {
#ifdef UDF_DBG
        printf("Extent = %u, pIcb = %p\r\n",dwExtentBlock);
	    printf("Length = %u\r\n",pLongAd->longad_Length & EXTENTAD_LEN_MASK);
	    printf("Start  = %u\r\n",pLongAd->longad_Start.nsr_lba_lbn);
#endif

        CopyMemory(pLongAds + pAllocDesc->nsr_alloc_AllocLen, pLongAd, sizeof(LONGAD));
        pAllocDesc->nsr_alloc_AllocLen+=sizeof(LONGAD);

        HeaderWrite(dwlOffset,pBuffer,CD_SECTORSIZE);
    }
}

void SetRandomExtentLength(void)
{
    if(bUdfUseRandomExtents)
    {
		// 0 is allowed, so we can have an extent that only points to another extent
        g_ulMaxAdsInExtent=(rand() % MAX_RANDOM_AD_EXTENT);
#ifdef UDF_DBG
        printf("Max ads = %d\r\n",g_ulMaxAdsInExtent);
#endif
    }
}

DWORD GetIcbBlockCount()
{
    return g_dwIcbBlockCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\rpcsig\makefile.inc ===
rpcsig_c.c rpcsig_s.c rpcsig.h: rpcsig.idl
	midl /app_config /win32 /Oi /W3 rpcsig.idl
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\writer.h ===
typedef
VOID
(*WRITE_COMPLETION)(
    PVOID     pBuffer,
    DWORDLONG dwlOffset,
    DWORD     dwSize,
    PVOID     pUserContext
    );


HANDLE
CreateWriteContext(
    LPCSTR    pFileName,            //  Filename to create (CREATE_ALWAYS)
    DWORD     dwSectorSize,         //  Optional
    DWORDLONG dwInitialSize,        //  Optional -- grow file before writing
    DWORD     nMaxActiveWrites      //  How far can we get ahead of ourself
    );


VOID
IssueWrite(
    HANDLE           hContext,      //  From CreateWriteContext
    PVOID            pBuffer,       //  From AllocateBuffer, we ReleaseBuffer
    DWORDLONG        dwlOffset,     //  Offset where write is to occur
    DWORD            dwSize,        //  Valid size of data in pBuffer
    WRITE_COMPLETION pCompletion,   //  Optional completion callback function
    PVOID            pUserContext   //  Passed to pCompletion routine
    );


VOID
FlushWriter(
    HANDLE hContext                 //  Waits for all queued writes to complete
    );


VOID
AbortWriter(                        //  stops issuing new writes, waits for
    HANDLE hContext                 //  outstanding writes to complete, sets
    );                              //  filesize to zero, then deletes file.


VOID
CloseWriteContext(
    HANDLE    hContext,             //  Flushes, sets EOF, cleans up, closes
    DWORDLONG dwlFileSize           //  Optional, sets file size
    );


LPOVERLAPPED
AllocateOverlappedWithEvent(        //  Allocate OVERLAPPED structure and
    VOID                            //  create hEvent member.
    );


VOID
RecycleOverlappedWithEvent(
    LPOVERLAPPED pOverlapped
    );


HANDLE
GetFileHandleFromWriteContext(      //  OVERLAPPED, NO_BUFFERING semantics
    HANDLE hContext
    );


VOID
QueueMaybeWrite(
    HANDLE           hContext,
    PVOID            pBuffer,
    DWORDLONG        dwlOffset,
    DWORD            dwSize,
    WRITE_COMPLETION pCompletion,
    PVOID            pUserContext,
    DWORD            dwMaxQueuedBytes
    );

VOID
FlushMaybeQueue(
    HANDLE hContext
    );

VOID
DiscardMaybeQueue(
    HANDLE hContext
    );

LPSTR
GetRootPath(
    LPCSTR pszRelativeFileName,
    LPSTR  pszRootPathBuffer
    );

LPWSTR
GetRootPathW(
    LPCWSTR pszRelativeFileName,
    LPWSTR  pszRootPathBuffer
    );

DWORD
GetSectorSizeByName(
    IN LPCSTR pszAnyPathName
    );

DWORD
GetSectorSizeByNameW(
    IN LPCWSTR pszAnyPathName
    );

DWORD
GetSectorSize(
    IN HANDLE  hFile           OPTIONAL,
    IN LPCWSTR pszAnyPathNameW OPTIONAL,
    IN LPCSTR  pszAnyPathName  OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\md5\md5.h ===
/*
 ***********************************************************************
 ** md5.h -- Header file for implementation of MD5                    **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version               **
 ** Revised (for MD5): RLR 4/27/91                                    **
 **   -- G modified to have y&~z instead of y&z                       **
 **   -- FF, GG, HH modified to add in last register done             **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3     **
 **   -- distinct additive constant for each step                     **
 **   -- round 4 added, working mod 7                                 **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

/*                                                                         */
/* This copy of md5.c modified and adapted for my purposes, tommcg 6/28/96 */
/*                                                                         */

#pragma warning( disable: 4201 4204 )

#ifdef __cplusplus
extern "C" {
#endif


#ifndef VOID
    typedef void VOID;
#endif
#ifndef UCHAR
    typedef unsigned char UCHAR;
#endif
#ifndef ULONG
    typedef unsigned long ULONG;
#endif
#ifndef ULONGLONG
    typedef unsigned __int64 ULONGLONG;
#endif
#ifndef PCVOID
    typedef const void * PCVOID;
#endif
#ifndef IN
    #define IN
#endif
#ifndef OUT
    #define OUT
#endif


typedef struct _MD5_HASH MD5_HASH, *PMD5_HASH;

struct _MD5_HASH {
    union {
        ULONG Word32[  4 ];
        UCHAR Byte  [ 16 ];
        };
    };

#define MD5_INITIAL_VALUE { 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476 }

VOID
InitMD5(
    IN OUT PMD5_HASH HashValue
    );

VOID
UpdateMD5_64ByteChunk(
    IN OUT PMD5_HASH HashValue,     // existing hash value
    IN     PCVOID    DataChunk      // ULONG-aligned pointer to 64-byte chunk
    );

VOID
UpdateMD5_Multiple64ByteChunks(     // convenience function
    IN OUT PMD5_HASH HashValue,     // existing hash value
    IN     PCVOID    DataBuffer,    // ULONG-aligned pointer to data
    IN     ULONG     DataLength     // must be multiple of 64 bytes
    );

VOID
FinalizeMD5(
    IN OUT PMD5_HASH HashValue,     // existing hash value
    IN     ULONGLONG BytesHashed    // 64-bit value
    );



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\cdimage\writer.c ===
#include "precomp.h"
#pragma hdrstop


//
//  Ideas:
//
//  * Mechanism to cancel outstanding writes, wait for outstanding writes
//    to complete, resume writing.
//
//  * Make high priority completion thread that only releases the buffer
//    (minimal necessary to allow new i/o to start), and an IDLE priority
//    cleaning up the other completion stuff.
//


typedef struct _WRITE_BLOCK
    WRITE_BLOCK,
    *PWRITE_BLOCK;

typedef struct _WRITER_CONTEXT
    WRITER_CONTEXT,
    *PWRITER_CONTEXT;

struct _WRITE_BLOCK {
    PWRITE_BLOCK        pNextBlock;         // must be first member of struct
    PVOID               pBuffer;
    DWORDLONG           dwlOffset;
    DWORD               dwValidSize;
    DWORD               dwWriteSize;
    LPOVERLAPPED        pOverlapped;
    WRITE_COMPLETION    pCompletion;
    PVOID               pUserContext;
    };

struct _WRITER_CONTEXT {
    HANDLE           hFile;
    LPCSTR           pFileName;
    DWORD            dwSectorSize;
    DWORDLONG        dwlSectorFileSize;
    DWORDLONG        dwlValidFileSize;
    DWORD            nMaxActiveWrites;
    PVOID            FakeEmptyHeadNode;      // initialize to NULL
    PWRITE_BLOCK     pQueuedWriteListHead;   // initialize to &FakeEmptyHeadNode
    PWRITE_BLOCK     pQueuedWriteListTail;   // initialize to &FakeEmptyHeadNode
    HANDLE           hSemQueuedWrites;       // initialize to zero
    HANDLE           hSemActiveWrites;       // initialize to zero
    HANDLE           hSemCanStartNewWrite;   // init to nMaxActiveWrites
    HANDLE           hEventThreadDone;
    CRITICAL_SECTION ActiveZoneCritSect;
    DWORDLONG        dwlActiveZoneLowerLimit;
    DWORDLONG        dwlActiveZoneUpperLimit;
    HANDLE           hEventActiveZoneLeave;
    LONG             nZoneWaiters;
    DWORD            nZoneEntries;
#ifdef DEBUG
    UINT             nCountSync;
    UINT             nCountAsync;
#endif
    PVOID            FakeMaybeHeadNode;      // initialize to NULL
    PWRITE_BLOCK     pMaybeWriteListHead;    // initialize to &FakeEmptyMaybeNode
    PWRITE_BLOCK     pMaybeWriteListTail;    // initialize to &FakeEmptyMaybeNode
    DWORD            dwQueuedMaybeBytes;     // initialize to zero
    BOOL             bAbortWriting;
    };


RECYCLE_LIST_HEAD RecycledWriterContextList;

PWRITER_CONTEXT
AllocateWriterContext(
    VOID
    )
    {
    PWRITER_CONTEXT pContext;

    pContext = GetObjectFromRecycleList( &RecycledWriterContextList );

    if ( pContext == NULL ) {
         pContext = MyAllocNeverFreeLocked( sizeof( WRITER_CONTEXT ));
         }
    else {
         ZeroMemory( pContext, sizeof( WRITER_CONTEXT ));
         }

    return pContext;
    }


VOID
INLINE
RecycleWriterContext(
    PWRITER_CONTEXT pContext
    )
    {
    RecycleObjectToList( &RecycledWriterContextList, pContext );
    }


RECYCLE_LIST_HEAD RecycledWriteBlockList;

PWRITE_BLOCK
AllocateWriteBlock(
    VOID
    )
    {
    PWRITE_BLOCK Block;

    Block = GetObjectFromRecycleList( &RecycledWriteBlockList );

    if ( Block == NULL ) {
         Block = MyAllocNeverFreeLocked( sizeof( WRITE_BLOCK ));
         }
    else {
         ZeroMemory( Block, sizeof( WRITE_BLOCK ));
         }

    return Block;
    }


VOID
INLINE
RecycleWriteBlock(
    PWRITE_BLOCK pBlock
    )
    {
    RecycleObjectToList( &RecycledWriteBlockList, pBlock );
    }


RECYCLE_LIST_HEAD RecycledOverlappedList;

LPOVERLAPPED
AllocateOverlappedWithEvent(
    VOID
    )
    {
    LPOVERLAPPED pOverlapped;

    pOverlapped = GetObjectFromRecycleList( &RecycledOverlappedList );

    if ( pOverlapped == NULL ) {
         pOverlapped = MyAllocNeverFreeLocked( sizeof( OVERLAPPED ));
         pOverlapped->hEvent = AllocateAutoEvent();
         }
    else {
         pOverlapped->Internal     = 0;
         pOverlapped->InternalHigh = 0;
         pOverlapped->Offset       = 0;
         pOverlapped->OffsetHigh   = 0;
         ASSERT( EventStateUnsignaled( pOverlapped->hEvent ));
         }

    return pOverlapped;
    }


VOID
RecycleOverlappedWithEvent(
    LPOVERLAPPED pOverlapped
    )
    {
    ASSERT( EventStateUnsignaled( pOverlapped->hEvent ));
    RecycleObjectToList( &RecycledOverlappedList, pOverlapped );
    }


VOID
EnterActiveZone(
    PWRITER_CONTEXT pContext,
    DWORDLONG       dwlOffset,
    DWORD           dwSize
    )
    {
    DWORDLONG dwlLower;
    DWORDLONG dwlUpper;
    DWORDLONG dwlExtent = dwlOffset + dwSize;
    BOOL      bReturn   = FALSE;

    for (;;) {

        EnterCriticalSection( &pContext->ActiveZoneCritSect );

        if ( pContext->nZoneEntries == 0 ) {
            pContext->dwlActiveZoneLowerLimit = dwlOffset;
            pContext->dwlActiveZoneUpperLimit = dwlExtent;
            pContext->nZoneEntries++;
            bReturn = TRUE;
            }
        else {

            dwlLower = pContext->dwlActiveZoneLowerLimit;
            dwlUpper = pContext->dwlActiveZoneUpperLimit;

            if (( dwlOffset >= dwlUpper ) || ( dwlExtent <= dwlLower )) {

                if ( dwlOffset < dwlLower )
                    pContext->dwlActiveZoneLowerLimit = dwlOffset;

                if ( dwlExtent > dwlUpper )
                    pContext->dwlActiveZoneUpperLimit = dwlExtent;

                pContext->nZoneEntries++;

                bReturn = TRUE;
                }
            else {
                InterlockedIncrement( &pContext->nZoneWaiters );
                }
            }

        LeaveCriticalSection( &pContext->ActiveZoneCritSect );

        if ( bReturn )
            return;

        WaitForSingleObject( pContext->hEventActiveZoneLeave, INFINITE );
        InterlockedDecrement( &pContext->nZoneWaiters );

        }
    }


VOID
LeaveActiveZone(
    PWRITER_CONTEXT pContext,
    DWORDLONG       dwlOffset,
    DWORD           dwSize
    )
    {
    DWORDLONG dwlLower;
    DWORDLONG dwlUpper;
    DWORDLONG dwlExtent = dwlOffset + dwSize;
    DWORD nZoneWaiters;

    EnterCriticalSection( &pContext->ActiveZoneCritSect );

    dwlLower = pContext->dwlActiveZoneLowerLimit;
    dwlUpper = pContext->dwlActiveZoneUpperLimit;

    if (( dwlOffset <= dwlLower ) && ( dwlExtent > dwlLower ))
        dwlLower = dwlExtent;

    if (( dwlExtent >= dwlUpper ) && ( dwlOffset < dwlUpper ))
        dwlUpper = dwlOffset;

    if ( dwlLower >= dwlUpper ) {
        pContext->dwlActiveZoneLowerLimit = 0xFFFFFFFFFFFFFFFF;
        pContext->dwlActiveZoneUpperLimit = 0;
        }

    pContext->nZoneEntries--;

    nZoneWaiters = pContext->nZoneWaiters;

    LeaveCriticalSection( &pContext->ActiveZoneCritSect );

    if ( nZoneWaiters )
        SetEvent( pContext->hEventActiveZoneLeave );

    }


VOID
WriterThread(
    PVOID pParam
    )
    {
    PWRITER_CONTEXT pContext = pParam;
    PWRITE_BLOCK    pBlock   = pContext->pQueuedWriteListHead;
    DWORD           dwActual;

    while ( pBlock ) {

        WaitForSingleObject( pContext->hSemQueuedWrites,     INFINITE );
        WaitForSingleObject( pContext->hSemCanStartNewWrite, INFINITE );

        pBlock = pBlock->pNextBlock;

        if ( pBlock ) {

            if ( pBlock->dwWriteSize > 0 ) {

                EnterActiveZone( pContext, pBlock->dwlOffset, pBlock->dwWriteSize );

                if ( bGlobalErrorExitInProgress )
                     pContext->bAbortWriting = TRUE;

                if ( pContext->bAbortWriting ) {

                    //
                    //  Don't issue new write, but allow completion thread
                    //  to continue processing blocks until they're all gone.
                    //

                    pBlock->pOverlapped->Internal = (DWORD)STATUS_CANCELLED;
                    SetEvent( pBlock->pOverlapped->hEvent );

                    }

                else {

                    if ( WriteFile( pContext->hFile,
                                    pBlock->pBuffer,
                                    pBlock->dwWriteSize,
                                    &dwActual,
                                    pBlock->pOverlapped )) {

                        //
                        //  Assume here that even though the WriteFile completed
                        //  synchronously, it was kind enough to set the
                        //  appropriate information in the overlapped structure
                        //  so that we can still call GetOverlappedResult.
                        //

                        ASSERT( pBlock->pOverlapped->Internal == 0 );
                        ASSERT( pBlock->pOverlapped->InternalHigh == dwActual );

                        DEBUGCODE( pContext->nCountSync++ );
                        }

                    else if ( GetLastError() == ERROR_IO_PENDING ) {
                        DEBUGCODE( pContext->nCountAsync++ );
                        }
                    else {
                        ErrorExit( GETLASTERROR,
                                   "WriteFile failed (%s, off=%I64X len=%X status=%X)\r\n",
                                   pContext->pFileName,
                                   pBlock->dwlOffset,
                                   pBlock->dwWriteSize,
                                   pBlock->pOverlapped->Internal
                                 );
                        }
                    }
                }
            }

        ReleaseSemaphore( pContext->hSemActiveWrites, 1, NULL );
        }

    ReleaseSemaphore( pContext->hSemActiveWrites, 1, NULL );
    }


VOID
CompletionThread(
    PVOID pParam
    )
    {
    PWRITER_CONTEXT pContext = pParam;
    PWRITE_BLOCK    pBlock   = pContext->pQueuedWriteListHead;
    PWRITE_BLOCK    pNext;
    DWORD           dwActual;

    while ( pBlock ) {

        WaitForSingleObject( pContext->hSemActiveWrites, INFINITE );

        pNext = pBlock->pNextBlock;

        if ( pBlock != (PWRITE_BLOCK)&pContext->FakeEmptyHeadNode )
            RecycleWriteBlock( pBlock );

        pBlock = pNext;

        if ( pBlock ) {

            if ( pBlock->dwWriteSize > 0 ) {

                //
                //  Wait for overlapped i/o to complete
                //

                WaitForSingleObject( pBlock->pOverlapped->hEvent, INFINITE );

                if ( bGlobalErrorExitInProgress )
                     pContext->bAbortWriting = TRUE;

                if ( ! pContext->bAbortWriting ) {

                    if ( ! GetOverlappedResult( NULL,
                                                pBlock->pOverlapped,
                                                &dwActual,
                                                FALSE )) {

                        //
                        //  Writer operation failed.
                        //

                        ErrorExit( GETLASTERROR,
                                   "WriteFile/GetOverlappedResult failed\r\n"
                                   "(%s, off=%I64X len=%X status=%X)\r\n",
                                   pContext->pFileName,
                                   pBlock->dwlOffset,
                                   pBlock->dwWriteSize,
                                   pBlock->pOverlapped->Internal
                                 );
                        }

                    ASSERT( dwActual == pBlock->dwWriteSize );
                    }

                LeaveActiveZone( pContext, pBlock->dwlOffset, pBlock->dwWriteSize );
                }

            if ( pBlock->pCompletion ) {

                //
                //  Call user-specified callback completion routine.
                //  NOTE:  If the user specified a callback completion
                //  routine, then the USER is responsible for releasing
                //  the buffer.
                //

                ( *pBlock->pCompletion )( pBlock->pBuffer,
                                          pBlock->dwlOffset,
                                          pBlock->dwValidSize,
                                          pBlock->pUserContext );
                }
            else {
                if ( pBlock->pBuffer ) {
                    ReleaseBuffer( pBlock->pBuffer );
                    }
                }

            if ( pBlock->pOverlapped )
                RecycleOverlappedWithEvent( pBlock->pOverlapped );

            ReleaseSemaphore( pContext->hSemCanStartNewWrite, 1, NULL );

            //
            //  Update file size stats
            //

            if ( pBlock->dwWriteSize > 0 ) {

                DWORDLONG dwlSize;

                dwlSize = pBlock->dwlOffset + pBlock->dwValidSize;
                if ( dwlSize > pContext->dwlValidFileSize )
                    pContext->dwlValidFileSize = dwlSize;

                dwlSize = pBlock->dwlOffset + pBlock->dwWriteSize;
                if ( dwlSize > pContext->dwlSectorFileSize )
                    pContext->dwlSectorFileSize = dwlSize;
                }
            }
        }

    SetEvent( pContext->hEventThreadDone );
    }


HANDLE
CreateWriteContext(
    LPCSTR    pFileName,
    DWORD     dwSectorSize,         //  Optional
    DWORDLONG dwlInitialSize,       //  Optional -- grow file before writing
    DWORD     nMaxActiveWrites      //  How far can we get ahead of ourself
    )
    {
    PWRITER_CONTEXT pContext;
    HANDLE          hFile;
    DWORD           dwErrorCode;
    DWORDLONG       dwlSetSize;
    DWORD           dwSetSizeLow;
    DWORD           dwSetSizeHigh;

    ASSERT( ! bScanOnly );

    hFile = CreateFile( pFileName,
                        GENERIC_READ | GENERIC_WRITE | DELETE,
                        0,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        DEBUGCODE( printf( "CreateFile( %s ) failed, GLE=%d\r\n", pFileName, GetLastError() ));
        return NULL;
        }

    //
    //  If we fail anywhere, or if the user Ctrl-C's the app, we want
    //  the in-progress target file to go away.
    //
    //  NOTE: We can only do this on local targets.  A network open will
    //  see the delete-on-close as meaning "don't bother writing this
    //  file because we're going to delete it when we close it".
    //
    //  BUGBUG:  This doesn't work consistently (too bad), so don't
    //           use it.  Just grow the file to the initial size.  If
    //           the user Ctrl-C's the app, then the file system will
    //           grind on the file writing zeroes to all the unwritten
    //           portion of the file.  If the target file is several
    //           hundred megabytes, then this can take many minutes,
    //           and can even prevent other apps from starting until
    //           the whole file is zeroed.
    //

#ifdef DONTCOMPILE
    {
    CHAR szRootPath[ MAX_PATH_LENGTH ];

    if ( GetRootPath( pFileName, szRootPath )) {
        if ( GetDriveType( szRootPath ) == DRIVE_FIXED ) {
            MyDeleteFileOnClose( hFile, TRUE );
            }
        }
    }
#endif

    if ( dwSectorSize == 0 ) {
        dwSectorSize = GetSectorSize( hFile, NULL, pFileName );
        ASSERT( dwSectorSize != 0 );
        DEBUGCODE( printf( "Queried dwSectorSize=%d\r\n", dwSectorSize ));
        }
    else {

#ifdef DEBUG

        DWORD dwSystemSectorSize = GetSectorSize( hFile, NULL, pFileName );
        ASSERT( dwSectorSize == dwSystemSectorSize );
        // ASSERT( ISALIGN2( dwSectorSize, dwSystemSectorSize )); BUGBUG
#endif

        }

    ASSERT( ISPOWER2( dwSectorSize ));
    ASSERT( dwSectorSize >= 512 );

    if ( dwlInitialSize ) {

        dwlSetSize    = ROUNDUP2_64( dwlInitialSize, dwSectorSize );
        dwSetSizeLow  = (DWORD)( dwlSetSize );
        dwSetSizeHigh = (DWORD)( dwlSetSize >> 32 );

        if (( SetFilePointer( hFile, dwSetSizeLow, (LONG*)&dwSetSizeHigh, FILE_BEGIN ) == 0xFFFFFFFF ) ||
            ( ! SetEndOfFile( hFile ))) {

            dwErrorCode = GetLastError();

            if ( dwErrorCode == ERROR_DISK_FULL ) {
                ErrorExit( 0, "Insufficient disk space for %s (need %I64d bytes)\r\n",
                              pFileName,
                              dwlSetSize );
                }
            else {
                ErrorExit( dwErrorCode, "Unable to grow file %s to %I64d bytes\r\n",
                                        pFileName,
                                        dwlSetSize );
                }

            CloseHandle( hFile );
            return NULL;
            }
        }
    else {
        dwlInitialSize = GetFileSize64( hFile );
        }

    pContext                          = AllocateWriterContext();
    pContext->hFile                   = hFile;
    pContext->pFileName               = pFileName;
    pContext->dwSectorSize            = dwSectorSize;
    pContext->dwlValidFileSize        = dwlInitialSize;
    pContext->dwlSectorFileSize       = ROUNDUP2_64( dwlInitialSize, dwSectorSize );
    pContext->nMaxActiveWrites        = nMaxActiveWrites;
    pContext->pQueuedWriteListHead    = (PWRITE_BLOCK) &pContext->FakeEmptyHeadNode;
    pContext->pQueuedWriteListTail    = (PWRITE_BLOCK) &pContext->FakeEmptyHeadNode;
    pContext->hSemQueuedWrites        = MyCreateSemaphore( 0 );
    pContext->hSemActiveWrites        = MyCreateSemaphore( 0 );
    pContext->hSemCanStartNewWrite    = MyCreateSemaphore( nMaxActiveWrites );
    pContext->hEventThreadDone        = AllocateAutoEvent();
    pContext->hEventActiveZoneLeave   = AllocateAutoEvent();
    pContext->dwlActiveZoneLowerLimit = 0xFFFFFFFFFFFFFFFF;
    pContext->dwlActiveZoneUpperLimit = 0;
    pContext->pMaybeWriteListHead     = (PWRITE_BLOCK) &pContext->FakeMaybeHeadNode;
    pContext->pMaybeWriteListTail     = (PWRITE_BLOCK) &pContext->FakeMaybeHeadNode;
    pContext->dwQueuedMaybeBytes      = 0;
    pContext->bAbortWriting           = FALSE;

    InitializeCriticalSection( &pContext->ActiveZoneCritSect );

    StartThread( WriterThread,     pContext, THREAD_PRIORITY_ABOVE_NORMAL );
    StartThread( CompletionThread, pContext, THREAD_PRIORITY_LOWEST );

    return (HANDLE) pContext;
    }


VOID
CloseWriteContext(                  //  Flushes, sets EOF, cleans up
    HANDLE    hContext,             //  (does not close file handle)
    DWORDLONG dwlFileSize           //  Optional, sets file size
    )
    {
    PWRITER_CONTEXT pContext = (PWRITER_CONTEXT) hContext;
    DWORD dwSetSizeLow;
    DWORD dwSetSizeHigh;

    ASSERT(( pContext ) || ( bScanOnly ));

    if ( pContext ) {

        ReleaseSemaphore( pContext->hSemQueuedWrites, 1, NULL );

        WaitForSingleObject( pContext->hEventThreadDone, INFINITE );

        if ( ! pContext->bAbortWriting ) {

            if ( dwlFileSize == 0 ) {
                dwlFileSize = pContext->dwlValidFileSize;
                }

            dwSetSizeLow  = (DWORD)( dwlFileSize );
            dwSetSizeHigh = (DWORD)( dwlFileSize >> 32 );

            if (( SetFilePointer( pContext->hFile, dwSetSizeLow, (LONG*)&dwSetSizeHigh, FILE_BEGIN ) == 0xFFFFFFFF ) ||
                ( ! SetEndOfFile( pContext->hFile ))) {

                ErrorExit( GETLASTERROR, "Unable to set file size on %s to %I64d bytes\r\n",
                                         pContext->pFileName,
                                         dwlFileSize );
                }
            }

        RecycleAutoEvent( pContext->hEventThreadDone );
        RecycleAutoEvent( pContext->hEventActiveZoneLeave );
        CloseHandle( pContext->hSemQueuedWrites );
        CloseHandle( pContext->hSemActiveWrites );
        CloseHandle( pContext->hSemCanStartNewWrite );

        if ( pContext->hFile != NULL ) {
            CloseHandle( pContext->hFile );
            pContext->hFile = NULL;
            }

        DEBUGCODE( printf( "nCountSync=%d, nCountAsync=%d\r\n",
                           pContext->nCountSync,
                           pContext->nCountAsync ));

        RecycleWriterContext( pContext );
        }
    }


VOID
IssueWrite(
    HANDLE           hContext,      //  From CreateWriteContext
    PVOID            pBuffer,       //  From AllocateBuffer, we ReleaseBuffer
    DWORDLONG        dwlOffset,     //  Offset where write is to occur
    DWORD            dwSize,        //  Valid size of data in pBuffer
    WRITE_COMPLETION pCompletion,   //  Optional completion callback function
    PVOID            pUserContext   //  Passed to pCompletion routine
    )
    {
    PWRITER_CONTEXT pContext = (PWRITER_CONTEXT) hContext;
    PWRITE_BLOCK    pBlock;
    DWORD           dwSectorWriteSize;

    ASSERT(( pContext ) || ( bScanOnly ));

    if ( pContext ) {

        //
        //  Assert that write offset is sector-aligned.
        //

        ASSERT( ISALIGN2_64( dwlOffset, pContext->dwSectorSize ));

        //
        //  For unbuffered writes, we must write in sector-size multiple
        //  chunks, so if the valid data size is less than a multiple of
        //  the sector size, fill in the end of the last sector with zeros.
        //

        dwSectorWriteSize = ROUNDUP2( dwSize, pContext->dwSectorSize );

        if ( dwSectorWriteSize > dwSize ) {
            ZeroMemory( (PUCHAR) pBuffer + dwSize, dwSectorWriteSize - dwSize );
            }

        pBlock               = AllocateWriteBlock();
        pBlock->pNextBlock   = NULL;
        pBlock->dwlOffset    = dwlOffset;
        pBlock->dwValidSize  = dwSize;
        pBlock->dwWriteSize  = dwSectorWriteSize;
        pBlock->pBuffer      = pBuffer;
        pBlock->pCompletion  = pCompletion;
        pBlock->pUserContext = pUserContext;
        pBlock->pOverlapped  = NULL;

        if ( pBlock->dwWriteSize > 0 ) {
            pBlock->pOverlapped = AllocateOverlappedWithEvent();
            pBlock->pOverlapped->Offset     = (DWORD)( dwlOffset );
            pBlock->pOverlapped->OffsetHigh = (DWORD)( dwlOffset >> 32 );
            }

        pContext->pQueuedWriteListTail->pNextBlock = pBlock;
        pContext->pQueuedWriteListTail             = pBlock;

        ReleaseSemaphore( pContext->hSemQueuedWrites, 1, NULL );
        }

    else {

        //
        //  Don't actually issue write, but must release the buffer or notify
        //  the user's completion routine.
        //

        if ( pCompletion ) {
            ( *pCompletion )( pBuffer, dwlOffset, dwSize, pUserContext );
            }
        else {
            if ( pBuffer ) {
                ReleaseBuffer( pBuffer );
                }
            }
        }
    }


HANDLE
GetFileHandleFromWriteContext(
    HANDLE hContext
    )
    {
    ASSERT(( hContext ) || ( bScanOnly ));
    return ( hContext ? ((PWRITER_CONTEXT) hContext )->hFile : NULL );
    }


VOID
QueueMaybeWrite(
    HANDLE           hContext,
    PVOID            pBuffer,
    DWORDLONG        dwlOffset,
    DWORD            dwSize,
    WRITE_COMPLETION pCompletion,
    PVOID            pUserContext,
    DWORD            dwMaxQueuedBytes
    )
    {
    PWRITER_CONTEXT pContext = (PWRITER_CONTEXT) hContext;
    PWRITE_BLOCK    pBlock;

    ASSERT(( pContext ) || ( bScanOnly ));

    if ( pContext ) {

        pBlock               = AllocateWriteBlock();
        pBlock->pNextBlock   = NULL;
        pBlock->dwlOffset    = dwlOffset;
        pBlock->dwWriteSize  = dwSize;
        pBlock->dwValidSize  = dwSize;
        pBlock->pBuffer      = pBuffer;
        pBlock->pCompletion  = pCompletion;
        pBlock->pUserContext = pUserContext;
        pBlock->pOverlapped  = NULL;

        pContext->pMaybeWriteListTail->pNextBlock = pBlock;
        pContext->pMaybeWriteListTail             = pBlock;
        pContext->dwQueuedMaybeBytes += ROUNDUP2( dwSize, FX_BLOCKSIZE );

        while ( pContext->dwQueuedMaybeBytes > dwMaxQueuedBytes ) {

            DEBUGCODE( printf( "\r\nQueueMaybeWrite leaking write\r\n" ));

            pBlock = pContext->pMaybeWriteListHead->pNextBlock;

            ASSERT( pBlock != NULL );
            ASSERT( pBlock != pContext->pMaybeWriteListHead );

            IssueWrite( hContext,
                        pBlock->pBuffer,
                        pBlock->dwlOffset,
                        pBlock->dwWriteSize,
                        pBlock->pCompletion,
                        pBlock->pUserContext );

            pContext->pMaybeWriteListHead->pNextBlock = pBlock->pNextBlock;

            if ( pContext->pMaybeWriteListTail == pBlock )
                pContext->pMaybeWriteListTail = pContext->pMaybeWriteListHead;

            pContext->dwQueuedMaybeBytes -= ROUNDUP2( pBlock->dwWriteSize, FX_BLOCKSIZE );

            RecycleWriteBlock( pBlock );
            }
        }

    else {

        //
        //  Don't actually issue write, but must release the buffer or notify
        //  the user's completion routine.
        //

        if ( pCompletion ) {
            ( *pCompletion )( pBuffer, dwlOffset, dwSize, pUserContext );
            }
        else {
            if ( pBuffer ) {
                ReleaseBuffer( pBuffer );
                }
            }
        }
    }



VOID
FlushMaybeQueue(
    HANDLE hContext
    )
    {
    PWRITER_CONTEXT pContext = (PWRITER_CONTEXT) hContext;
    PWRITE_BLOCK    pBlock;
    PWRITE_BLOCK    pNext;

    ASSERT(( pContext ) || ( bScanOnly ));

    if ( pContext ) {

        pBlock = pContext->pMaybeWriteListHead->pNextBlock;

        while ( pBlock != NULL ) {

            IssueWrite( hContext,
                        pBlock->pBuffer,
                        pBlock->dwlOffset,
                        pBlock->dwWriteSize,
                        pBlock->pCompletion,
                        pBlock->pUserContext );


            pNext = pBlock->pNextBlock;

            pContext->pMaybeWriteListHead->pNextBlock = pNext;

            RecycleWriteBlock( pBlock );

            pBlock = pNext;

            }

        pContext->pMaybeWriteListTail = pContext->pMaybeWriteListHead;
        pContext->dwQueuedMaybeBytes  = 0;
        }
    }


VOID
DiscardMaybeQueue(
    HANDLE hContext
    )
    {
    PWRITER_CONTEXT pContext = (PWRITER_CONTEXT) hContext;
    PWRITE_BLOCK    pBlock;
    PWRITE_BLOCK    pNext;

    ASSERT(( pContext ) || ( bScanOnly ));

    if ( pContext ) {

        pBlock = pContext->pMaybeWriteListHead->pNextBlock;

        while ( pBlock != NULL ) {

            if ( pBlock->pCompletion ) {

                //
                //  Call user-specified callback completion routine.
                //  NOTE:  If the user specified a callback completion
                //  routine, then the USER is responsible for releasing
                //  the buffer.
                //

                ( *pBlock->pCompletion )( pBlock->pBuffer,
                                          pBlock->dwlOffset,
                                          pBlock->dwWriteSize,
                                          pBlock->pUserContext );
                }
            else {
                if ( pBlock->pBuffer ) {
                    ReleaseBuffer( pBlock->pBuffer );
                    }
                }

            pNext = pBlock->pNextBlock;

            pContext->pMaybeWriteListHead->pNextBlock = pNext;

            RecycleWriteBlock( pBlock );

            pBlock = pNext;

            }

        pContext->pMaybeWriteListTail = pContext->pMaybeWriteListHead;
        pContext->dwQueuedMaybeBytes  = 0;
        }
    }



VOID
FlushCompletion(
    PVOID     pBuffer,
    DWORDLONG dwlOffset,
    DWORD     dwSize,
    PVOID     pUserContext
    )
    {
    SetEvent( (HANDLE) pUserContext );

    UNREFERENCED( pBuffer );
    UNREFERENCED( dwlOffset );
    UNREFERENCED( dwSize );
    }


VOID
FlushWriter(
    HANDLE hContext
    )
    {
    HANDLE hEvent;

    ASSERT(( hContext ) || ( bScanOnly ));

    if ( hContext ) {

        hEvent = AllocateAutoEvent();

        IssueWrite( hContext,
                    NULL,
                    0,
                    0,
                    FlushCompletion,
                    hEvent );

        WaitForSingleObject( hEvent, INFINITE );

        RecycleAutoEvent( hEvent );

        }
    }


VOID
AbortWriter(
    HANDLE hContext
    )
    {
    PWRITER_CONTEXT pContext = (PWRITER_CONTEXT) hContext;

    ASSERT(( pContext ) || ( bScanOnly ));

    if ( pContext ) {

        pContext->bAbortWriting = TRUE;

        FlushWriter( hContext );

        SetFilePointer( pContext->hFile, 0, NULL, FILE_BEGIN );
        SetEndOfFile( pContext->hFile );

//      MySetFileSize( pContext->hFile, 0 );
//      MyDeleteFileOnClose( pContext->hFile, TRUE );

        CloseHandle( pContext->hFile );
        pContext->hFile = NULL;

        DeleteFile( pContext->pFileName );
        }
    }


LPSTR
GetRootPath(
    LPCSTR pszRelativeFileName,
    LPSTR  pszRootPathBuffer
    )
    {
    CHAR szFullPath[ MAX_PATH_LENGTH ];
    LPSTR pReturn;

    try {

        *pszRootPathBuffer = 0;

        GetFullPathName( pszRelativeFileName,
                         sizeof( szFullPath ),
                         szFullPath,
                         &pReturn );

        strcat( szFullPath, "\\" );

        if ( *(UNALIGNED WORD *) szFullPath == '\\\\' ) {

            //
            //  Format is either \\server\share\..., or \\.\device\...,
            //  either of which need to find second backslash after the
            //  initial two and insert terminator after it.
            //

            *( strchr( strchr( szFullPath + 2, '\\' ) + 1, '\\' ) + 1 ) = 0;
            }

        else {

            //
            //  Only remaining format is d:\... so find first backslash
            //  and insert terminator after it.
            //

            *( strchr( szFullPath, '\\' ) + 1 ) = 0;
            }

        pReturn = strcpy( pszRootPathBuffer, szFullPath );
        }

    except( EXCEPTION_EXECUTE_HANDLER ) {
        pReturn = NULL;
        }

    return pReturn;
    }


DWORD
GetSectorSizeByName(
    IN LPCSTR pszAnyPathName
    )
    {
    CHAR  szRootPath[ MAX_PATH_LENGTH ];
    DWORD SectorsPerCluster;
    DWORD BytesPerSector;
    DWORD FreeClusters;
    DWORD TotalClusters;

    if ( GetRootPath( pszAnyPathName, szRootPath ) != NULL ) {

        if ( GetDiskFreeSpace( szRootPath,
                               &SectorsPerCluster,
                               &BytesPerSector,
                               &FreeClusters,
                               &TotalClusters )) {

            return BytesPerSector;
            }
        }

    return 0;
    }


LPWSTR
GetRootPathW(
    LPCWSTR pszRelativeFileName,
    LPWSTR  pszRootPathBuffer
    )
    {
    WCHAR    szFullPath[ MAX_PATH_LENGTH ];
    LPWSTR   pReturn;

    try {

        *pszRootPathBuffer = 0;

        GetFullPathNameW( pszRelativeFileName,
                          MAX_PATH_LENGTH - 1,
                          szFullPath,
                          &pReturn );

        //                                                                  //
        //  Form of szFullPath is now one of following, and each form       //
        //  needs to be mapped as shown:                                    //
        //                                                                  //
        //    d:\dir\file.ext                    -> d:\                     //
        //    \\server\share\dir\file.ext        -> \\server\share\         //
        //    \\.\d:\dir\file.ext                -> \\.\d:\                 //
        //    \\?\d:\dir\file.ext                -> \\?\d:\                 //
        //    \\?\UNC\server\share\dir\file.ext  -> \\?\UNC\server\share\   //
        //                                                                  //

        lstrcatW( szFullPath, (LPCWSTR) L"\\" );

        if ( *(UNALIGNED DWORD *) szFullPath == *(UNALIGNED DWORD *) L"\\\\" ) {

            //
            //  For cases...
            //
            //    \\server\share\dir\file.ext
            //    \\.\d:\dir\file.ext
            //    \\?\d:\dir\file.ext
            //
            //  ...we want to terminate the string after the second backslash
            //  after the initial "\\" (length 2).
            //
            //  For the case...
            //
            //    \\?\UNC\server\share\dir\file.ext
            //
            //  ...we want to terminate the string after the second backslash
            //  after the initial "\\?\UNC\" (length 8).
            //

            unsigned Skip = wcsnicmp( szFullPath, (LPCWSTR) L"\\\\?\\UNC\\", 8 ) ? 2 : 8;

            *( wcschr( wcschr( szFullPath + Skip, L'\\' ) + 1, L'\\' ) + 1 ) = 0;
            }

        else {

            //
            //  Only remaining format is d:\... so find first backslash
            //  and insert terminator after it.
            //

            *( wcschr( szFullPath, L'\\' ) + 1 ) = 0;
            }

        pReturn = lstrcpyW( pszRootPathBuffer, szFullPath );
        }

    except( EXCEPTION_EXECUTE_HANDLER ) {
        pReturn = NULL;
        }

    return pReturn;
    }


DWORD
GetSectorSizeByNameW(
    LPCWSTR pszAnyPathName
    )
    {
    WCHAR szRootPath[ MAX_PATH_LENGTH ];
    DWORD SectorsPerCluster;
    DWORD BytesPerSector;
    DWORD FreeClusters;
    DWORD TotalClusters;

    if ( GetRootPathW( pszAnyPathName, szRootPath ) != NULL ) {

        if ( GetDiskFreeSpaceW( szRootPath,
                                &SectorsPerCluster,
                                &BytesPerSector,
                                &FreeClusters,
                                &TotalClusters )) {

            return BytesPerSector;
            }
        }

    return 0;
    }


DWORD
GetSectorSize(
    IN HANDLE  hFile           OPTIONAL,
    IN LPCWSTR pszAnyPathNameW OPTIONAL,
    IN LPCSTR  pszAnyPathName  OPTIONAL
    )
    {
    DWORD SectorSize = 0;
    DWORD ClusterSize;

    if ( hFile != NULL )
        MyGetFileSectorInfo( hFile, &SectorSize, &ClusterSize );

    if (( SectorSize == 0 ) && ( pszAnyPathNameW != NULL )) {
        SectorSize = GetSectorSizeByNameW( pszAnyPathNameW );
        }

    if (( SectorSize == 0 ) && ( pszAnyPathName != NULL )) {
        SectorSize = GetSectorSizeByName( pszAnyPathName );
        }

    return SectorSize;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\crc\crc.c ===
const unsigned long CrcTable32[ 256 ] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D };


/*   CRC-16 polynomial is 0x10041 (this table is from original udfbridg.c) */

const unsigned short CrcTable16[ 256 ] = {
    0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
    0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
    0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
    0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
    0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
    0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
    0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
    0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
    0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
    0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
    0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
    0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
    0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
    0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
    0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
    0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
    0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
    0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
    0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
    0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
    0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
    0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
    0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
    0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
    0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
    0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
    0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
    0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
    0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
    0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
    0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
    0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
    };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\rpcsig\rpcsig.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun Apr 07 15:08:27 2002
 */
/* Compiler settings for rpcsig.idl:
    Oi, W3, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, app_config, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __rpcsig_h__
#define __rpcsig_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __RpcSignatureServerInterface_INTERFACE_DEFINED__
#define __RpcSignatureServerInterface_INTERFACE_DEFINED__

/* interface RpcSignatureServerInterface */
/* [auto_handle][version][uuid] */ 

boolean RpcSignatureServerAuthenticate( 
    /* [in] */ handle_t BindingHandle,
    /* [string][in] */ unsigned char *LoggingText);

boolean RpcSignatureServerGenSignature( 
    /* [in] */ handle_t BindingHandle,
    /* [string][in] */ unsigned char *LoggingText,
    /* [size_is][in] */ unsigned char *DataHashValue,
    /* [out] */ unsigned long *SignatureId,
    /* [size_is][out] */ unsigned char *Signature);



extern RPC_IF_HANDLE RpcSignatureServerInterface_v2_0_c_ifspec;
extern RPC_IF_HANDLE RpcSignatureServerInterface_v2_0_s_ifspec;
#endif /* __RpcSignatureServerInterface_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\crc\crc.h ===
/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//  crc.h       Code for efficiently computing CRC-32 values.              //
//                                                                         //
//              Author: Tom McGuire (tommcg)                               //
//                                                                         //
//              Original version written November, 1992.                   //
//                                                                         //
//              (C) Copyright 1992-1996, Microsoft Corporation             //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

extern const unsigned long  CrcTable32[];       // defined in crc.c
extern const unsigned short CrcTable16[];       // defined in crc.c

//
//  Crc32 implementation in 'C' for other platforms.
//

unsigned long __inline Crc32( unsigned long InitialCrc, const void *Buffer, unsigned long Bytes ) {

    unsigned long Crc = InitialCrc;
    const unsigned char *p = Buffer;
    unsigned long Count = Bytes;

    while ( Count-- )
        Crc = ( Crc >> 8 ) ^ CrcTable32[ ((unsigned char)(Crc)) ^ *p++ ];

    return Crc;
    }


unsigned short __inline Crc16( unsigned short InitialCrc, const void *Buffer, unsigned long Bytes ) {

    unsigned short Crc = InitialCrc;
    const unsigned char *p = Buffer;
    unsigned long Count = Bytes;

    while ( Count-- )
        Crc = (unsigned short)(( Crc << 8 ) ^ CrcTable16[ (unsigned char)( Crc >> 8 ) ^ *p++ ] );

    return Crc;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\md5\md5.c ===
/*
 ***********************************************************************
 ** md5.c                                                             **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                   **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

//  Portions copyright (c) 1992 Microsoft Corp.
//  All rights reserved

//
//  This copy of md5.c modified and adapted for my purposes, tommcg 6/28/96
//  Copyright (C) 1996, Microsoft Corporation.
//


#include "md5.h"
#include <stdlib.h>

#ifndef PCUCHAR
    typedef const unsigned char * PCUCHAR;
#endif
#ifndef PCULONG
    typedef const unsigned long * PCULONG;
#endif


/* Constants for Transform routine. */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21


/* ROTATE_LEFT rotates x left n bits. */

#define ROTATE_LEFT(x, n) ((x << n) | (x >> (32 - n)))

//
//  Intel and PowerPC both have a hardware rotate instruction with intrinsic
//  (inline) function for them.  Rough measurements show a 25% speed increase
//  for Intel and 10% speed increase for PowerPC when using the instrinsic
//  rotate versus the above defined shift/shift/or implemenation.
//

#if defined(_M_IX86) || defined(_M_PPC)
    #undef  ROTATE_LEFT
    #define ROTATE_LEFT(x, n) _rotl(x, n)
#endif


/* F, G and H are basic MD5 functions */
#define F(x, y, z) ((x & y) | (~x & z))
#define G(x, y, z) ((x & z) | (y & ~z))
#define H(x, y, z) (x ^ y ^ z)
#define I(x, y, z) (y ^ (x | ~z))


/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s, ac) \
   a += F(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;

#define GG(a, b, c, d, x, s, ac) \
   a += G(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;

#define HH(a, b, c, d, x, s, ac) \
   a += H(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;

#define II(a, b, c, d, x, s, ac) \
   a += I(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;


VOID
InitMD5(
    IN OUT PMD5_HASH HashValue
    )
    {
    HashValue->Word32[ 0 ] = 0x67452301;
    HashValue->Word32[ 1 ] = 0xefcdab89;
    HashValue->Word32[ 2 ] = 0x98badcfe;
    HashValue->Word32[ 3 ] = 0x10325476;
    }

VOID
UpdateMD5_64ByteChunk(
    IN OUT PMD5_HASH HashValue,         // existing hash value
    IN     PCVOID    DataChunk          // ULONG-aligned pointer to 64-byte message chunk
    )
    {
    PCULONG MessageWord32 = DataChunk;
    ULONG a = HashValue->Word32[ 0 ];
    ULONG b = HashValue->Word32[ 1 ];
    ULONG c = HashValue->Word32[ 2 ];
    ULONG d = HashValue->Word32[ 3 ];

    /* Round 1 */
    FF ( a, b, c, d, MessageWord32[  0 ], S11, 0xd76aa478 ) /* 1 */
    FF ( d, a, b, c, MessageWord32[  1 ], S12, 0xe8c7b756 ) /* 2 */
    FF ( c, d, a, b, MessageWord32[  2 ], S13, 0x242070db ) /* 3 */
    FF ( b, c, d, a, MessageWord32[  3 ], S14, 0xc1bdceee ) /* 4 */
    FF ( a, b, c, d, MessageWord32[  4 ], S11, 0xf57c0faf ) /* 5 */
    FF ( d, a, b, c, MessageWord32[  5 ], S12, 0x4787c62a ) /* 6 */
    FF ( c, d, a, b, MessageWord32[  6 ], S13, 0xa8304613 ) /* 7 */
    FF ( b, c, d, a, MessageWord32[  7 ], S14, 0xfd469501 ) /* 8 */
    FF ( a, b, c, d, MessageWord32[  8 ], S11, 0x698098d8 ) /* 9 */
    FF ( d, a, b, c, MessageWord32[  9 ], S12, 0x8b44f7af ) /* 10 */
    FF ( c, d, a, b, MessageWord32[ 10 ], S13, 0xffff5bb1 ) /* 11 */
    FF ( b, c, d, a, MessageWord32[ 11 ], S14, 0x895cd7be ) /* 12 */
    FF ( a, b, c, d, MessageWord32[ 12 ], S11, 0x6b901122 ) /* 13 */
    FF ( d, a, b, c, MessageWord32[ 13 ], S12, 0xfd987193 ) /* 14 */
    FF ( c, d, a, b, MessageWord32[ 14 ], S13, 0xa679438e ) /* 15 */
    FF ( b, c, d, a, MessageWord32[ 15 ], S14, 0x49b40821 ) /* 16 */

    /* Round 2 */
    GG ( a, b, c, d, MessageWord32[  1 ], S21, 0xf61e2562 ) /* 17 */
    GG ( d, a, b, c, MessageWord32[  6 ], S22, 0xc040b340 ) /* 18 */
    GG ( c, d, a, b, MessageWord32[ 11 ], S23, 0x265e5a51 ) /* 19 */
    GG ( b, c, d, a, MessageWord32[  0 ], S24, 0xe9b6c7aa ) /* 20 */
    GG ( a, b, c, d, MessageWord32[  5 ], S21, 0xd62f105d ) /* 21 */
    GG ( d, a, b, c, MessageWord32[ 10 ], S22, 0x02441453 ) /* 22 */
    GG ( c, d, a, b, MessageWord32[ 15 ], S23, 0xd8a1e681 ) /* 23 */
    GG ( b, c, d, a, MessageWord32[  4 ], S24, 0xe7d3fbc8 ) /* 24 */
    GG ( a, b, c, d, MessageWord32[  9 ], S21, 0x21e1cde6 ) /* 25 */
    GG ( d, a, b, c, MessageWord32[ 14 ], S22, 0xc33707d6 ) /* 26 */
    GG ( c, d, a, b, MessageWord32[  3 ], S23, 0xf4d50d87 ) /* 27 */
    GG ( b, c, d, a, MessageWord32[  8 ], S24, 0x455a14ed ) /* 28 */
    GG ( a, b, c, d, MessageWord32[ 13 ], S21, 0xa9e3e905 ) /* 29 */
    GG ( d, a, b, c, MessageWord32[  2 ], S22, 0xfcefa3f8 ) /* 30 */
    GG ( c, d, a, b, MessageWord32[  7 ], S23, 0x676f02d9 ) /* 31 */
    GG ( b, c, d, a, MessageWord32[ 12 ], S24, 0x8d2a4c8a ) /* 32 */

    /* Round 3 */
    HH ( a, b, c, d, MessageWord32[  5 ], S31, 0xfffa3942 ) /* 33 */
    HH ( d, a, b, c, MessageWord32[  8 ], S32, 0x8771f681 ) /* 34 */
    HH ( c, d, a, b, MessageWord32[ 11 ], S33, 0x6d9d6122 ) /* 35 */
    HH ( b, c, d, a, MessageWord32[ 14 ], S34, 0xfde5380c ) /* 36 */
    HH ( a, b, c, d, MessageWord32[  1 ], S31, 0xa4beea44 ) /* 37 */
    HH ( d, a, b, c, MessageWord32[  4 ], S32, 0x4bdecfa9 ) /* 38 */
    HH ( c, d, a, b, MessageWord32[  7 ], S33, 0xf6bb4b60 ) /* 39 */
    HH ( b, c, d, a, MessageWord32[ 10 ], S34, 0xbebfbc70 ) /* 40 */
    HH ( a, b, c, d, MessageWord32[ 13 ], S31, 0x289b7ec6 ) /* 41 */
    HH ( d, a, b, c, MessageWord32[  0 ], S32, 0xeaa127fa ) /* 42 */
    HH ( c, d, a, b, MessageWord32[  3 ], S33, 0xd4ef3085 ) /* 43 */
    HH ( b, c, d, a, MessageWord32[  6 ], S34, 0x04881d05 ) /* 44 */
    HH ( a, b, c, d, MessageWord32[  9 ], S31, 0xd9d4d039 ) /* 45 */
    HH ( d, a, b, c, MessageWord32[ 12 ], S32, 0xe6db99e5 ) /* 46 */
    HH ( c, d, a, b, MessageWord32[ 15 ], S33, 0x1fa27cf8 ) /* 47 */
    HH ( b, c, d, a, MessageWord32[  2 ], S34, 0xc4ac5665 ) /* 48 */

    /* Round 4 */
    II ( a, b, c, d, MessageWord32[  0 ], S41, 0xf4292244 ) /* 49 */
    II ( d, a, b, c, MessageWord32[  7 ], S42, 0x432aff97 ) /* 50 */
    II ( c, d, a, b, MessageWord32[ 14 ], S43, 0xab9423a7 ) /* 51 */
    II ( b, c, d, a, MessageWord32[  5 ], S44, 0xfc93a039 ) /* 52 */
    II ( a, b, c, d, MessageWord32[ 12 ], S41, 0x655b59c3 ) /* 53 */
    II ( d, a, b, c, MessageWord32[  3 ], S42, 0x8f0ccc92 ) /* 54 */
    II ( c, d, a, b, MessageWord32[ 10 ], S43, 0xffeff47d ) /* 55 */
    II ( b, c, d, a, MessageWord32[  1 ], S44, 0x85845dd1 ) /* 56 */
    II ( a, b, c, d, MessageWord32[  8 ], S41, 0x6fa87e4f ) /* 57 */
    II ( d, a, b, c, MessageWord32[ 15 ], S42, 0xfe2ce6e0 ) /* 58 */
    II ( c, d, a, b, MessageWord32[  6 ], S43, 0xa3014314 ) /* 59 */
    II ( b, c, d, a, MessageWord32[ 13 ], S44, 0x4e0811a1 ) /* 60 */
    II ( a, b, c, d, MessageWord32[  4 ], S41, 0xf7537e82 ) /* 61 */
    II ( d, a, b, c, MessageWord32[ 11 ], S42, 0xbd3af235 ) /* 62 */
    II ( c, d, a, b, MessageWord32[  2 ], S43, 0x2ad7d2bb ) /* 63 */
    II ( b, c, d, a, MessageWord32[  9 ], S44, 0xeb86d391 ) /* 64 */

    HashValue->Word32[ 0 ] += a;
    HashValue->Word32[ 1 ] += b;
    HashValue->Word32[ 2 ] += c;
    HashValue->Word32[ 3 ] += d;
    }


VOID
UpdateMD5_Multiple64ByteChunks(
    IN OUT PMD5_HASH HashValue,             // existing hash value
    IN     PCVOID    DataBuffer,            // ULONG-aligned pointer to data
    IN     ULONG     DataLength             // must be multiple of 64 bytes
    )
    {
    PCUCHAR DataChunk = DataBuffer;         // next 64 bytes in DataBuffer
    ULONG   Chunks    = DataLength / 64;    // number of chunks in input buffer

    while ( Chunks-- ) {
        UpdateMD5_64ByteChunk( HashValue, DataChunk );
        DataChunk += 64;                    // next 64 bytes of DataBuffer
        }
    }


VOID
FinalizeMD5(
    IN OUT PMD5_HASH HashValue,
    IN     ULONGLONG BytesHashed
    )
    {
    union {
        ULONGLONG Word64[  8 ];
        UCHAR     Byte  [ 64 ];
        } Buffer = { 0 };                       // init whole buffer to zero

    Buffer.Byte[ 0 ] = 0x80;

    Buffer.Word64[ 7 ] = ( BytesHashed * 8 );   // number of bits

    UpdateMD5_64ByteChunk( HashValue, &Buffer );

    }


#ifdef DONTCOMPILE

VOID
TestMD5(
    VOID
    )
    {
    static CHAR TestBuffer[ 64 ];
    ULONG TickCount1;
    ULONG TickCount2;
    MD5_HASH HashValue;
    ULONG i;

    ZeroMemory( &TestBuffer, sizeof( TestBuffer ));
    ZeroMemory( &HashValue, sizeof( HashValue ));

    TickCount1 = GetTickCount();

    for ( i = 0; i < 0x1000000/64; i++ )
        UpdateMD5_64ByteChunk( &HashValue, TestBuffer );

    TickCount2 = GetTickCount() - TickCount1;

    printf( "%d ticks, %d bytes/second\n",
            TickCount2,
            (ULONG)(((ULONGLONG)0x1000000 * 1000 ) / TickCount2 )
            );

    exit( 1 );
    }

#endif // DONTCOMPILE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\rpcsig\rpcsigx.h ===
#define HASH_SIZE  16   //  128 bit MD5 hash
#define SIGN_SIZE 128   // 1024 bit RSA signature
#define SIGN_BUFF 136   // RSA requires extra zero bytes beyond SIGN_SIZE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\rpcsig\rpcsig_s.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC server stubs */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun Apr 07 15:08:27 2002
 */
/* Compiler settings for rpcsig.idl:
    Oi, W3, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, app_config, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#include <string.h>
#include "rpcsig.h"

#define TYPE_FORMAT_STRING_SIZE   39                                
#define PROC_FORMAT_STRING_SIZE   57                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};

extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

/* Standard interface: RpcSignatureServerInterface, ver. 2.0,
   GUID={0x9437a860,0xcae9,0x11cf,{0x99,0xb3,0x00,0x00,0x4c,0x75,0x27,0xda}} */


extern const MIDL_SERVER_INFO RpcSignatureServerInterface_ServerInfo;

extern RPC_DISPATCH_TABLE RpcSignatureServerInterface_v2_0_DispatchTable;

static const RPC_SERVER_INTERFACE RpcSignatureServerInterface___RpcServerInterface =
    {
    sizeof(RPC_SERVER_INTERFACE),
    {{0x9437a860,0xcae9,0x11cf,{0x99,0xb3,0x00,0x00,0x4c,0x75,0x27,0xda}},{2,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &RpcSignatureServerInterface_v2_0_DispatchTable,
    0,
    0,
    0,
    &RpcSignatureServerInterface_ServerInfo,
    0x04000000
    };
RPC_IF_HANDLE RpcSignatureServerInterface_v2_0_s_ifspec = (RPC_IF_HANDLE)& RpcSignatureServerInterface___RpcServerInterface;

extern const MIDL_STUB_DESC RpcSignatureServerInterface_StubDesc;


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {
			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 10 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 12 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 14 */	0x4e,		/* FC_IN_PARAM_BASETYPE */
			0xf,		/* FC_IGNORE */
/* 16 */	
			0x4d,		/* FC_IN_PARAM */
			0x1,		/* x86 stack size = 1 */
/* 18 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */
/* 20 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x3,		/* FC_SMALL */
/* 22 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 24 */	NdrFcLong( 0x0 ),	/* 0 */
/* 28 */	NdrFcShort( 0x1 ),	/* 1 */
/* 30 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 32 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 34 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 36 */	0x4e,		/* FC_IN_PARAM_BASETYPE */
			0xf,		/* FC_IGNORE */
/* 38 */	
			0x4d,		/* FC_IN_PARAM */
			0x1,		/* x86 stack size = 1 */
/* 40 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */
/* 42 */	
			0x4d,		/* FC_IN_PARAM */
			0x1,		/* x86 stack size = 1 */
/* 44 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */
/* 46 */	
			0x51,		/* FC_OUT_PARAM */
			0x1,		/* x86 stack size = 1 */
/* 48 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */
/* 50 */	
			0x51,		/* FC_OUT_PARAM */
			0x1,		/* x86 stack size = 1 */
/* 52 */	NdrFcShort( 0x18 ),	/* Type Offset=24 */
/* 54 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x3,		/* FC_SMALL */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/*  4 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x11, 0x0,	/* FC_RP */
/*  8 */	NdrFcShort( 0x2 ),	/* Offset= 2 (10) */
/* 10 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 12 */	NdrFcShort( 0x1 ),	/* 1 */
/* 14 */	0x40,		/* Corr desc:  constant, val=16 */
			0x0,		/* 0 */
/* 16 */	NdrFcShort( 0x10 ),	/* 16 */
/* 18 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 20 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 22 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 24 */	
			0x11, 0x0,	/* FC_RP */
/* 26 */	NdrFcShort( 0x2 ),	/* Offset= 2 (28) */
/* 28 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 30 */	NdrFcShort( 0x1 ),	/* 1 */
/* 32 */	0x40,		/* Corr desc:  constant, val=128 */
			0x0,		/* 0 */
/* 34 */	NdrFcShort( 0x80 ),	/* 128 */
/* 36 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */

			0x0
        }
    };

static const unsigned short RpcSignatureServerInterface_FormatStringOffsetTable[] =
    {
    0,
    22
    };


static const MIDL_STUB_DESC RpcSignatureServerInterface_StubDesc = 
    {
    (void *)& RpcSignatureServerInterface___RpcServerInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x10001, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION RpcSignatureServerInterface_table[] =
    {
    NdrServerCall,
    NdrServerCall,
    0
    };
RPC_DISPATCH_TABLE RpcSignatureServerInterface_v2_0_DispatchTable = 
    {
    2,
    RpcSignatureServerInterface_table
    };

static const SERVER_ROUTINE RpcSignatureServerInterface_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)RpcSignatureServerAuthenticate,
    (SERVER_ROUTINE)RpcSignatureServerGenSignature
    };

static const MIDL_SERVER_INFO RpcSignatureServerInterface_ServerInfo = 
    {
    &RpcSignatureServerInterface_StubDesc,
    RpcSignatureServerInterface_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    RpcSignatureServerInterface_FormatStringOffsetTable,
    0,
    0,
    0,
    0};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\BuildDigest\BuildDigest.c ===
/*
 * main.c
 */

#define MAIN_FILE
#include <windows.h>
#include <winsockx.h>
#include <xbox.h>
#include <xonlinep.h>
#include <stdio.h>

#include "cryptcab.h"
#include "dgstfile.h"

#include "BuildDigest.rc"

static bool parse_options(int argc, char **argv);
static void init_options(void);
static void cleanup(void);


void _cdecl main(int argc, char **argv)
{
	bool	result;

	init_options();

	result = parse_options(argc, argv);
	
	cleanup();

	if (result == false)
		exit(1);
	else
		exit(0);
}


static void title(void)
{
	printf(
		"\n"
        "Microsoft (R) Xbox (R) Digest File Builder - Version " 
        VER_PRODUCTVERSION_STRING ".%u\n"
		VER_LEGALCOPYRIGHT_STR ".\n"
		"\n",
		VER_PRODUCTBUILD
	);

}

static void help(void)
{
	printf(
        "Usage:\n\n"
        "BuildDigest [-r] <path> <key> <titleid> <maj_ver> <min_ver> [@list] [files]\n"
		"\n"
		"<path> is a required parameter that specifies the path of the\n"
		"        new digest. This path must specify an existing directory\n"
		"        without a file name. The name of a digest file must be\n"
		"        %s\n"
		"\n"
		"<key> is a required parameter that specifies key to use to sign the digest\n"
		"        file. This must be expressed in the hexadecimal string format.\n"
		"\n"
		"<titleid> is a required parameter that specifies the title ID whose contents\n"
		"        for which this digest is created. This parameter must be specified in\n"
		"        hexadecimal form.\n"
		"\n"
		"<maj_ver> is a required parameter that specifies the decimal major version of\n"
		"        the title whose contents for which this digest is created\n"
		"\n"
		"<min_ver> is a required parameter that specifies the decimal minor version of\n"
		"        the title whose contents for which this digest is created\n"
		"\n"
		"The list of files to be included is specified through a combination of\n"
		"filenames (which may contain wildcards), and/or list files. Filenames\n"
		"are relative to the current directory from which this application is run.\n"
		"List files may contain file names (one name per line) that are relative\n"
		"to the directory from which this program is run.\n"
		"\n"
		"By default, wildcard matches are non-recursive. Recursive matches can be\n"
		"enabled by specifying the -r option. The -r option is global and thus\n"
		"affects all wildcard matches. For example, to create a digest that\n"
		"contains all files under the current directory hierarchy, one would do:\n"
		"\n"
		"BuildDigest -r .\\ 000102030405060708090a0b0c0d0e0f fffe0000 2 0 *.*\n"
		"\n"
		"The directory hierarchy will be preserved when the digest is created\n"
		"This allows the publisher to layout the files exactly as it should appear\n"
		"on the Xbox, and then build the corresponding digest file.\n"
		"\n"
		"This application can be used to dump an existing digest file:\n"
		"\n"
		"BuildDigest -d [-v] <path> <key>\n"
		"\n"
		"The <path> parameter specifies the directory which contains the\n"
		"%s file (fixed filename). <key> specifies the key that\n"
		"is used to sign the digest. This application will not dump the\n"
		"digest file unless the correct key is furnished.\n"
		"\n"
		"An optional -v (verify) can be specified to verify each checksum\n"
		"against the actual file. If this flag is specified, however, then\n"
		"the application must be run from the root directory from which the\n"
		"original digest was created.\n"
		"\n",
		XONLINEAUTOUPD_TARGET_MANIFEST_FILE_NAME,
		XONLINEAUTOUPD_TARGET_MANIFEST_FILE_NAME
	);
}

static void init_options(void)
{
	g_confirm_files		= false;
	g_overwrite_files	= false;
	g_set_id			= 0;
    g_disk_size         = LONG_MAX;

	g_debug_mode = false;
	g_recurse_subdirs = false;
	g_preserve_path_names = true;
	g_reserved_cfheader_space = 344;
	g_reserved_cffolder_space = 28;
	g_compression_type = COMPRESSION_TYPE_LZX;
	g_compression_memory = 15;

	init_list(&g_strip_path_list);
    init_list(&g_list_of_files_to_add);
}

static void cleanup(void)
{
	free_list(&g_strip_path_list);
    free_list(&g_list_of_files_to_add);
}


static bool parse_options(int argc, char **argv)
{
	HRESULT	hr = S_OK;
	int		argnum;
	int		cleft;
	int		cblength;
	int		cbsymmkey;
	bool	result;
	bool	fverify = FALSE;
	bool	fdump = FALSE;
	char	szdigest[MAX_PATH];
	byte	rgbsymmkey[XONLINE_KEY_LENGTH];

	DGSTFILE_HEADER	dfh;

	title();

	if (argc < 2)
	{
		help();
		return false;
	}

	argnum = 1;

	while (argnum < argc)
	{
		if ((argv[argnum][0] == '-') || (argv[argnum][0] == '/')) /* option? */
		{
			switch (argv[argnum][1])
			{
	            case '?':
	            case 'h':
	            case 'H':
	                help();
	                return false;
	                break;

				case 'r':
				case 'R':
					g_recurse_subdirs = TRUE;
					break;

				case 'd':
				case 'D':
					fdump = TRUE;
					break;

				case 'v':
				case 'V':
					fverify = TRUE;
					break;

				default:
					printf("Unknown option -%c\n", argv[argnum][1]);
					return false;
			}

			argnum++;
		}
		else
			break;
	}

	// See if we have the right number of parameters
	cleft = argc - argnum;
	if (cleft < 2)
	{
		puts("Too few arguments for BuildDigest\n");
		help();
		return false;
	}

	// Build the digest path
	cblength = strlen(argv[argnum]);
	if (cblength >= MAX_PATH)
	{
		puts("Digest path too long");
		return false;
	}
	strcpy(szdigest, argv[argnum++]);
	if (szdigest[cblength - 1] != '\\')
	szdigest[cblength++] = '\\';
	szdigest[cblength] = '\0';
	cblength += strlen(XONLINEAUTOUPD_TARGET_MANIFEST_FILE_NAME);
	if (cblength >= MAX_PATH)
	{
		puts("Digest path too long");
		return false;
	}
	strcat(szdigest, XONLINEAUTOUPD_TARGET_MANIFEST_FILE_NAME);

	// Convert the symmetric key to a byte array
	cbsymmkey = sizeof(rgbsymmkey);
	hr = ConvertSymmetricKeyToBinary(
				argv[argnum], strlen(argv[argnum]),
				rgbsymmkey, &cbsymmkey);
	if (hr != S_OK)
	{
		printf("Invalid symmetric key value %s\n", argv[argnum]);
		return false;
	}
	argnum++;
	cleft = argc - argnum;
	
	if (fdump)
	{
		// We are going to dump a manifest file
		if (cleft)
		{
			printf("Incorrect number of arguments for -d\n");
			help();
			return false;
		}

		// Call the dump API
		hr = DumpDigest(szdigest, fverify, rgbsymmkey, cbsymmkey);
		if (FAILED(hr))
		{
			printf("Failed to dump digest %s: %u (%08x)\n", 
						szdigest, hr, hr);
			return false;
		}
	}
	else
	{
		// We are creating a manifest file
		if (cleft < 4)
		{
			printf("Too few arguments to build new manifest\n");
			help();
			return false;
		}

		// OK, set up the digest file header
		dfh.wReservedSize = 0;
		dfh.wFlags = 0;
		dfh.wRating = 0;
		hr = ConvertToTitleId(argv[argnum++], &(dfh.dfi.dwTitleId));
		if (FAILED(hr))
		{
			puts("Invalid Title ID");
			return false;
		}
		if ((dfh.dfi.wTitleVersionHi = (WORD)atoi(argv[argnum++])) == 0)
		{
			puts("Invalid Version number");
			return false;
		}
		dfh.dfi.wTitleVersionLo = (WORD)atoi(argv[argnum++]);
		dfh.dfi.OfferingId = 0;

		// Delete the digest if it already exists
		DeleteFile(szdigest);

		// Get the list of files to process
		for (; argnum < argc; argnum++)
		{
            /* an @file? */
            if (argv[argnum][0] == '@')
            {
                if (input_file_list_from_file(&argv[argnum][1], &g_list_of_files_to_add) == false)
                {
                    printf("Error reading list of files from '%s'", &argv[argnum][1]);
                    return false;
                }

                continue;
            }

			result = expand_wildcard(
                &g_list_of_files_to_add,
				argv[argnum],
				g_recurse_subdirs,
				NULL
			);

			if (result == false)
				return false;
		}

		if (!g_list_of_files_to_add.flh_head)
		{
			printf("No input files specified\n");
			return false;
		}

		printf("Building digest %s with the following parameters:\n"\
				"  Title ID: %08x\n"\
				"  Title Version: %u.%u\n\n",
				szdigest, dfh.dfi.dwTitleId, 
				dfh.dfi.wTitleVersionHi,
				dfh.dfi.wTitleVersionLo);

		// Call the API to actually build the digest
		hr = CreateDigestFromFileList(
					&g_list_of_files_to_add,
					&dfh,
					szdigest,
					rgbsymmkey,
					cbsymmkey
					);
		if (FAILED(hr))
		{
			printf("Failed to create digest %s: %u (%08x)\n", 
						szdigest, hr, hr);
			return false;
		}
		else
		{
			printf("Digest %s successfully created\n\n", szdigest);
		}
	}

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\BuildContent\BuildContent.c ===
/*
 * main.c
 */

#define MAIN_FILE
#include "cabarc.h"
#include "BuildContent.rc"
#include "oldnames.h"

static bool parse_options(int argc, char **argv);
static void init_options(void);
static void cleanup(void);


void _cdecl main(int argc, char **argv)
{
	bool	result;

	init_options();

	result = parse_options(argc, argv);
	
	cleanup();

	if (result == false)
		exit(1);
	else
		exit(0);
}


static void title(void)
{
	printf(
		"\n"
        "Microsoft (R) Xbox (R) Content Builder - Version " 
        VER_PRODUCTVERSION_STRING ".%u\n"
		VER_LEGALCOPYRIGHT_STR ".\n"
		"\n",
		VER_PRODUCTBUILD
	);

}

static void help(void)
{
	printf(
        "Usage: BuildContent [-r] [-o] [-D] N <package_path> <metadata_path> [@list] [files]\n"
		"\n"
		"<package_path> is a required parameter that specifies the path of the\n"
		"        resulting package. If only a file name is specified, the default\n"
		"        is the current directory.\n"
		"\n"
		"<metadata_path> is a required parameter that specifies the name and\n"
		"        location of a file that contains the catalog-referral metadata \n"
		"        about this package. This program does not validate the metadata\n"
		"        contained in the file, and it is the content publisher's\n"
		"        responsibility to make sure the metadata is valid.\n"
		"\n"
		"The list of files to be packaged is specified through a combination of\n"
		"filenames (which may contain wildcards), and/or list files. Filenames\n"
		"are relative to the current directory from which this application is run.\n"
		"List files may contain file names (one name per line) that are relative\n"
		"to the directory from which this program is run.\n"
		"\n"
		"By default, wildcard matches are non-recursive. Recursive matches can be\n"
		"enabled by specifying the -r option. The -r option is global and thus\n"
		"affects all wildcard matches. For example, to create a package that\n"
		"contains all files under the current directory hierarchy, one would do:\n"
		"\n"
		"The -o option can be specified to indicate the package is to be for offline\n"
		"distribution. The resultant package will be an installable package signed\n"
		"with the DevKit key and can be verified using the DevKit public key. The\n"
		"symmteric key used for offline packages will be TESTTESTTESTTEST.\n"
		"\n"
		"BuildContent -r N test.xcp ..\\metadata.dat *.*\n"
		"\n"
		"The directory hierarchy will be preserved when the package is installed\n"
		"on the Xbox hard disk. This allows the content publisher to layout the\n"
		"content exactly as it should appear on the Xbox, and then build a\n"
		"package the preserves the whole layout.\n"
		"\n"
		"A debug mode can be specified using the -D option, which will output\n"
		"the raw cabinet file without the secure packaging. This allows the\n"
		"content publisher to list and extract the files to verify that the\n"
		"cabinet layout is correct. The raw cabinet file will be named\n"
		"<package_path>.cab. The raw cabinet can be accessed using the\n"
		"standard cabarc utility, or one of the following commands:\n"
		"\n"
		"List:       BuildContent L <raw_cabinet>\n"
        "Extract:    BuildContent X <raw_cabinet> [files] [output_dir]\n"
		"\n"
		"Notes\n"
		"-----\n"
		"When creating a cabinet, the plus sign (+) may be used as a filename\n"
		"to force a folder boundary;\n"
		"\n"
		"e.g. BuildContent N test.xcp ..\\info.dat *.c test.h + *.bmp + @..\\filelist\n"
        "\n"
        "The example above causes test.xcp to be created, using ..\\info.dat\n"
        "as the metadata file. test.xcp will contain 3 folders, one with *.c\n"
        "and test.h, another with *.bmp, and a third one containing all the files\n"
        "specified ina file named filelist in the parent directory.\n"
        "\n"
        "The Xbox content package format allows up to 100 folders per package.\n"
        "Do not exceed this limit or your package will not work.\n"
        "\n"
	);
}


static void init_options(void)
{
	g_confirm_files		= false;
	g_overwrite_files	= false;
	g_set_id			= 0;
    g_disk_size         = LONG_MAX;

	g_debug_mode = false;
	g_recurse_subdirs = false;
	g_preserve_path_names = true;
	g_reserved_cfheader_space = 344;
	g_reserved_cffolder_space = 28;
	g_compression_type = COMPRESSION_TYPE_LZX;
	g_compression_memory = 15;
	g_offline = false;

	init_list(&g_strip_path_list);
    init_list(&g_list_of_files_to_add);
}


static void cleanup(void)
{
	free_list(&g_strip_path_list);
    free_list(&g_list_of_files_to_add);
}


static bool parse_options(int argc, char **argv)
{
	int		argnum;
	bool	result;

	title();

	if (argc < 2)
	{
		help();
		return false;
	}

	argnum = 1;

    while ((argv[argnum][0] == '-') || (argv[argnum][0] == '/')) /* option? */
	{
		switch (argv[argnum][1])
		{
            case '?':
            case 'h':
            case 'H':
                help();
                return false;
                break;

			case 'r':
				g_recurse_subdirs = true;
				break;

			case 'o':
				g_offline = true;
				break;

			case 'D':
				g_debug_mode = true;
				break;

			default:
				printf("Unknown option -%c\n", argv[argnum][1]);
				return false;
		}

		argnum++;

		if (argnum >= argc)
		{
			printf("You need to specify a command\n");
			return false;
		}
	}

	if (argnum+1 >= argc)
	{
		printf("Insufficient parameters\n");
		return false;
	}

	switch (toupper(argv[argnum][0]))
	{
		case 'L': /* list files in cabinet */
		{
			char *cab_name;

			cab_name = argv[++argnum];

			list_cab(cab_name);
			break;
		}

		case 'N': /* add files to cabinet */
		{
			char *cab_name;

			argnum++;
			cab_name = argv[argnum++];

			if (argnum >= argc)
			{
				printf("Insufficient parameters\n");
				return false;
			}
			strcpy(g_metadata_file_path, argv[argnum++]);

			for (; argnum < argc; argnum++)
			{
                if (!strcmp(argv[argnum], FOLDER_SEPARATOR_STRING))
				{
                    (void) add_to_list(&g_list_of_files_to_add, FOLDER_SEPARATOR_STRING, NULL);
					continue;
				}

                /* an @file? */
                if (argv[argnum][0] == '@')
                {
                    if (input_file_list_from_file(&argv[argnum][1], &g_list_of_files_to_add) == false)
                    {
                        printf("Error reading list of files from '%s'", &argv[argnum][1]);
                        return false;
                    }

                    continue;
                }

				result = expand_wildcard(
                    &g_list_of_files_to_add,
					argv[argnum],
					g_recurse_subdirs,
					NULL
				);

				if (result == false)
					return false;
			}

			if (!g_list_of_files_to_add.flh_head)
			{
				printf("No files specified\n");
				return false;
			}
            create_new_cab(cab_name, &g_list_of_files_to_add);
			break;
		}

		case 'X': /* extract files from cabinet */
		{
			char *cab_name;
			cab_file_list_header list_of_files_to_extract;

			init_list(&list_of_files_to_extract);

			cab_name = argv[++argnum];
			argnum++;

			for (; argnum < argc; argnum++)
			{
				/*
				 * Destination dir?
				 */
				if (strlen(argv[argnum]) > 0)
				{
					if (argv[argnum][ strlen(argv[argnum])-1 ] == '\\')
					{
						strcpy(g_dest_dir, argv[argnum]);
						continue;
					}
				}

                if (argv[argnum][0] == '@')
                {
                    printf("Error, @files not supported for extract\n");
                    return false;
                }

				result = add_to_list(
					&list_of_files_to_extract,
                    argv[argnum],
                    NULL
				);

				if (result == false)
					return false;
			}
			
			extract_from_cab(cab_name, &list_of_files_to_extract);
			free_list(&list_of_files_to_extract);
			break;
		}

		default:
		{
			printf("Unknown command %c\n", argv[argnum][0]);
			return false;
		}
	}
	
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\common\cmdext.c ===
/*
 * cmdext.c
 */
#include "cabarc.h"
#include <conio.h>
#include "oldnames.h"

static cab_file_list_header *list_of_files_to_extract;
static bool success;


static bool extract_this_file(char *filename)
{
	if (list_of_files_to_extract->flh_head == NULL)
		return true;

	if (file_in_wildcard_list(filename, list_of_files_to_extract))
		return true;
	else
		return false;
}


static void clear_console_line(void)
{
	printf("\r                                                                               \r");
}


/*
 * Create a directory
 *
 * Name may or may not have trailing slash
 */
static bool create_dir(const byte *dirname)
{
   byte temp_dirname[MAX_PATHNAME_LENGTH];

   /*
    * Ensure strlen(DirName) > 0
    */
   if (*dirname)
   {
      /*
       * MakeDir routine doesn't want trailing slash for dir name
       */
      if (dirname[ strlen(dirname)-1 ] == SLASH_CHARACTER)
      {
         strncpy(temp_dirname, dirname, sizeof(temp_dirname));
         temp_dirname[ sizeof(temp_dirname)-1 ] = 0;

         /* Wipe out trailing slash */
         temp_dirname[ strlen(temp_dirname)-1 ] = 0;

         if (CreateDirectory(temp_dirname, NULL))
            return true;
         else
            return false;
      }

      /*
       * No trailing slash; ordinary makedir
       */
      if (CreateDirectory(dirname, NULL))
         return true;
      else
         return false;
   }
   else
   {
      return false;
   }
}


/*
 * Create the directories implied by this file name (with full path)
 *
 * Assumption:  We have already tried to write to this file name, and failed,
 *              so if we don't create any directories, report failure.
 *
 * This routine is also used to create subdirectories (e.g. "dir1/dir2/").
 */
bool create_directories_for_file(const byte *filename)
{
   char	pathname[MAX_PATHNAME_LENGTH];
   int	i;

   strcpy(pathname, filename);

   /*
    * Example: "newdir/dir2/dir3/filename"
    *
    * CreateDir(newdir/dir2/dir3)   fail
    * CreateDir(newdir/dir2)        fail
    * CreateDir(newdir)             success
    * CreateDir(newdir/dir2)        success
    * CreateDir(newdir/dir2/dir3)   success
    */

   i = strlen(pathname)-1;

   while (i > 0)
   {
      if (pathname[i] == SLASH_CHARACTER)
      {
         pathname[i] = 0;

         if (create_dir(pathname) == true)
         {
            /* Success */
            pathname[i] = SLASH_CHARACTER;

            while (1)
            {
               /* Now go backwards and create the subdirectories */
               do
               {
                  i++;
               } while (pathname[i] && pathname[i] != SLASH_CHARACTER);

               if (pathname[i] == SLASH_CHARACTER)
               {
                  pathname[i] = 0;

                  if (create_dir(pathname) == false)
                  {
                     /* Unexpected failure */
                     pathname[i] = SLASH_CHARACTER;
                     return false;
                  }

                  pathname[i] = SLASH_CHARACTER;
               }
               else
               {
                  /* Null terminator found; end of directory path */
                  return true;
               }
            }
         }

         pathname[i] = SLASH_CHARACTER;
      }

      i--;
   }

   /* Failure */
   return false;
}


static FNFDINOTIFY(fdi_ext_notification_function)
{
	switch (fdint)
	{
		case fdintCABINET_INFO: // general information about the cabinet
			return 0;

		case fdintPARTIAL_FILE: // first file in cabinet is continuation
			return 0;

		case fdintCOPY_FILE:	// file to be copied
		{
			char	destination[MAX_PATHNAME_LENGTH];
			char	*filename;
			INT_PTR	handle;
			int		c;

			/*
			 * Ignore files which have a colon in them (e.g. C:\CONFIG.SYS)
			 */
			if (strchr(pfdin->psz1, ':'))
			{
				printf("   File '%s' contains illegal character (colon) -- skipping\n", pfdin->psz1);
				return 0;
			}

			filename = pfdin->psz1;

			/*
			 * Strip out path names if we're not preserving them on extract
			 */
			if (g_preserve_path_names == false)
			{
				char	*p;

				p = strrchr(pfdin->psz1, '\\');

				if (p)
					filename = p+1;
			}

			if (extract_this_file(filename))
			{
				sprintf(
					destination, 
					"%s%s",
					g_dest_dir,
					filename
				);

				if (g_confirm_files)
				{
					printf("   -- Extract '%s'? (Yes/No/All/Quit): ", filename);

					do
					{
						c = getch();
						c = toupper(c);
					} while (c != 'Y' && c != 'N' && c != 'Q' && c != 'A');

					if (c == 'N')
					{
						clear_console_line();
						return 0;
					}
					else if (c == 'Q')
					{
						printf("q\n");
						return -1;
					}
					else if (c == 'A')
					{
						g_confirm_files = false;
					}

					clear_console_line();
				}

				/*
				 * If we're not overwriting files automatically and
				 * the file exists, ask the user
				 */
				if (g_overwrite_files == false)
				{
					if (GetFileAttributes(destination) != 0xFFFFFFFF)
					{
						/*
						 * File exists
						 */
						printf(
							"   -- File '%s' already exists; overwrite? (Yes/No/All/Quit): ", 
							destination
						);
						
						do
						{
							c = getch();
							c = toupper(c);
						} while (c != 'Y' && c != 'N' && c != 'Q' && c != 'A');
						
						if (c == 'N')
						{
							printf("n\n");
							return 0;
						}
						else if (c == 'Q')
						{
							printf("q\n");
							return -1;
						}
						else if (c == 'A')
						{
							printf("a\n");
							g_overwrite_files = true;
						}

						clear_console_line();
					}
				}

				handle = callback_file_open(
					destination,
					_O_BINARY | _O_CREAT | _O_WRONLY | _O_SEQUENTIAL,
					_S_IREAD | _S_IWRITE 
				);

				if (handle == -1)
				{
					/*
					 * It might have failed because it contained a path name for
					 * a directory (or subdirectory) which didn't exist
					 */
					if (g_preserve_path_names)
					{
						(void) create_directories_for_file(destination);

						handle = callback_file_open(
							destination,
							_O_BINARY | _O_CREAT | _O_WRONLY | _O_SEQUENTIAL,
							_S_IREAD | _S_IWRITE 
						);
					}
				}

				if (handle == -1)
				{
					printf("   -- Error opening '%s' for output\n", destination);
					success = false;
				}
				else 
				{
					printf("   extracting: %s\n", destination);
				}

				return handle;
			}
			else
			{
				return 0;
			}
		}

		case fdintCLOSE_FILE_INFO:	// close the file, set relevant info
		{
			DWORD		attrs;
			FILETIME	datetime;
			char		destination[MAX_PATHNAME_LENGTH];
			char		*filename;

			filename = pfdin->psz1;

			/*
			 * Strip out path names if we're not preserving them on extract
			 */
			if (g_preserve_path_names == false)
			{
				char *p;

				p = strrchr(pfdin->psz1, '\\');

				if (p)
					filename = p+1;
			}

			sprintf(
				destination, 
				"%s%s",
				g_dest_dir,
				filename
			);

            attrs = 0;

			if (pfdin->attribs & _A_RDONLY)
                attrs |= FILE_ATTRIBUTE_READONLY;

            if (pfdin->attribs & _A_ARCH)
                attrs |= FILE_ATTRIBUTE_ARCHIVE;

            if (pfdin->attribs & _A_HIDDEN)
                attrs |= FILE_ATTRIBUTE_HIDDEN;

            if (pfdin->attribs & _A_SYSTEM)
                attrs |= FILE_ATTRIBUTE_SYSTEM;

            if (attrs == 0)
				attrs = FILE_ATTRIBUTE_NORMAL;

			/*
			 * Set file attributes and date/time
			 */
			if (TRUE == DosDateTimeToFileTime(
				pfdin->date,
				pfdin->time,
				&datetime))
			{
				FILETIME	local_filetime;

				if (TRUE == LocalFileTimeToFileTime(
					&datetime, 
					&local_filetime))
				{
					(void) SetFileTime(
						(HANDLE) pfdin->hf,
						&local_filetime,
						NULL,
						&local_filetime
					);
				}
			}

			(void) callback_file_close(pfdin->hf);
			(void) SetFileAttributes(destination, attrs);

			return TRUE;
		}

		case fdintNEXT_CABINET:	// file continued to next cabinet

			return -1;
	}

	return 0;
}


bool extract_from_cab(char *cabname, cab_file_list_header *list)
{
	HFDI			hfdi;
	ERF				erf;
	FDICABINETINFO	fdici;
	INT_PTR			hf;
	char			*p;
	char			cabinet_name[MAX_PATHNAME_LENGTH];
	char			cabinet_path[MAX_PATHNAME_LENGTH];

	success = true;

	list_of_files_to_extract = list;

	hfdi = FDICreate(
		callback_alloc,
		callback_free,
		callback_file_open,
		callback_file_read,
		callback_file_write,
		callback_file_close,
		callback_file_seek,
		cpu80386,
		&erf
	);

	if (hfdi == NULL)
	{
		printf("FDICreate() failed: code %d [%s]\n",
			erf.erfOper, return_fdi_error_string(erf.erfOper)
		);

		return false;
	}

	/*
	 * Is this file really a cabinet?
	 */
	hf = callback_file_open(
		cabname,
		_O_BINARY | _O_RDONLY,
		0
	);

	if (hf == -1)
	{
		(void) FDIDestroy(hfdi);

		printf("Unable to open '%s' for input\n", cabname);
		return false;
	}

	if (FALSE == FDIIsCabinet(
			hfdi,
			hf,
			&fdici))
	{
		/*
		 * No, it's not a cabinet!
		 */
		callback_file_close(hf);

		printf(
			"FDIIsCabinet() failed: '%s' is not a cabinet\n",
			cabname
		);

		(void) FDIDestroy(hfdi);
		return false;
	}

	callback_file_close(hf);

	printf(
		"Extracting file(s) from cabinet '%s':\n",
		cabname
	);

	p = strrchr(cabname, '\\');

	if (p == NULL)
	{
		strcpy(cabinet_name, cabname);
		strcpy(cabinet_path, "");
	}
	else
	{
		strcpy(cabinet_name, p+1);

		strncpy(cabinet_path, cabname, (int) (p-cabname)+1);
		cabinet_path[ (int) (p-cabname)+1 ] = 0;
	}

	if (TRUE != FDICopy(
		hfdi,
		cabinet_name,
		cabinet_path,
		0,
		fdi_ext_notification_function,
		NULL,
		NULL))
	{
		printf(
			"FDICopy() failed: code %d [%s]\n",
			erf.erfOper, return_fdi_error_string(erf.erfOper)
		);

		(void) FDIDestroy(hfdi);
		return false;
	}

	printf("\n");

	if (FDIDestroy(hfdi) != TRUE)
	{
		printf(
			"FDIDestroy() failed: code %d [%s]\n",
			erf.erfOper, return_fdi_error_string(erf.erfOper)
		);

		return false;
	}

	if (success)
		printf("Operation successful\n");
	else
		printf("Operation not entirely successful\n");

	return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cdimage\rpcsig\rpcsig_c.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC client stubs */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun Apr 07 15:08:27 2002
 */
/* Compiler settings for rpcsig.idl:
    Oi, W3, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, app_config, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#include <string.h>

#include "rpcsig.h"

#define TYPE_FORMAT_STRING_SIZE   39                                
#define PROC_FORMAT_STRING_SIZE   57                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

#define GENERIC_BINDING_TABLE_SIZE   0            


/* Standard interface: RpcSignatureServerInterface, ver. 2.0,
   GUID={0x9437a860,0xcae9,0x11cf,{0x99,0xb3,0x00,0x00,0x4c,0x75,0x27,0xda}} */



static const RPC_CLIENT_INTERFACE RpcSignatureServerInterface___RpcClientInterface =
    {
    sizeof(RPC_CLIENT_INTERFACE),
    {{0x9437a860,0xcae9,0x11cf,{0x99,0xb3,0x00,0x00,0x4c,0x75,0x27,0xda}},{2,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    0,
    0,
    0,
    0,
    0,
    0x00000000
    };
RPC_IF_HANDLE RpcSignatureServerInterface_v2_0_c_ifspec = (RPC_IF_HANDLE)& RpcSignatureServerInterface___RpcClientInterface;

extern const MIDL_STUB_DESC RpcSignatureServerInterface_StubDesc;

static RPC_BINDING_HANDLE RpcSignatureServerInterface__MIDL_AutoBindHandle;


boolean RpcSignatureServerAuthenticate( 
    /* [in] */ handle_t BindingHandle,
    /* [string][in] */ unsigned char *LoggingText)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall(
                 ( PMIDL_STUB_DESC  )&RpcSignatureServerInterface_StubDesc,
                 (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                 ( unsigned char * )&BindingHandle);
    return ( boolean  )_RetVal.Simple;
    
}


boolean RpcSignatureServerGenSignature( 
    /* [in] */ handle_t BindingHandle,
    /* [string][in] */ unsigned char *LoggingText,
    /* [size_is][in] */ unsigned char *DataHashValue,
    /* [out] */ unsigned long *SignatureId,
    /* [size_is][out] */ unsigned char *Signature)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall(
                 ( PMIDL_STUB_DESC  )&RpcSignatureServerInterface_StubDesc,
                 (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[22],
                 ( unsigned char * )&BindingHandle);
    return ( boolean  )_RetVal.Simple;
    
}


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {
			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 10 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 12 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 14 */	0x4e,		/* FC_IN_PARAM_BASETYPE */
			0xf,		/* FC_IGNORE */
/* 16 */	
			0x4d,		/* FC_IN_PARAM */
			0x1,		/* x86 stack size = 1 */
/* 18 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */
/* 20 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x3,		/* FC_SMALL */
/* 22 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 24 */	NdrFcLong( 0x0 ),	/* 0 */
/* 28 */	NdrFcShort( 0x1 ),	/* 1 */
/* 30 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 32 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 34 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 36 */	0x4e,		/* FC_IN_PARAM_BASETYPE */
			0xf,		/* FC_IGNORE */
/* 38 */	
			0x4d,		/* FC_IN_PARAM */
			0x1,		/* x86 stack size = 1 */
/* 40 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */
/* 42 */	
			0x4d,		/* FC_IN_PARAM */
			0x1,		/* x86 stack size = 1 */
/* 44 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */
/* 46 */	
			0x51,		/* FC_OUT_PARAM */
			0x1,		/* x86 stack size = 1 */
/* 48 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */
/* 50 */	
			0x51,		/* FC_OUT_PARAM */
			0x1,		/* x86 stack size = 1 */
/* 52 */	NdrFcShort( 0x18 ),	/* Type Offset=24 */
/* 54 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x3,		/* FC_SMALL */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/*  4 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x11, 0x0,	/* FC_RP */
/*  8 */	NdrFcShort( 0x2 ),	/* Offset= 2 (10) */
/* 10 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 12 */	NdrFcShort( 0x1 ),	/* 1 */
/* 14 */	0x40,		/* Corr desc:  constant, val=16 */
			0x0,		/* 0 */
/* 16 */	NdrFcShort( 0x10 ),	/* 16 */
/* 18 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 20 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 22 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 24 */	
			0x11, 0x0,	/* FC_RP */
/* 26 */	NdrFcShort( 0x2 ),	/* Offset= 2 (28) */
/* 28 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 30 */	NdrFcShort( 0x1 ),	/* 1 */
/* 32 */	0x40,		/* Corr desc:  constant, val=128 */
			0x0,		/* 0 */
/* 34 */	NdrFcShort( 0x80 ),	/* 128 */
/* 36 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */

			0x0
        }
    };

static const unsigned short RpcSignatureServerInterface_FormatStringOffsetTable[] =
    {
    0,
    22
    };


static const MIDL_STUB_DESC RpcSignatureServerInterface_StubDesc = 
    {
    (void *)& RpcSignatureServerInterface___RpcClientInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    &RpcSignatureServerInterface__MIDL_AutoBindHandle,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x10001, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\cklibver\cklibver.c ===
/*
 *
 * cklibver.c
 *
 * Check library versions
 *
 */

#include <windows.h>
#include <xbeimage.h>
#include <xboxverp.h>
#include <cklibver.h>

/* These are the blanket build approvals */
static struct {
    USHORT wMinVer;
    USHORT wMaxVer;
    BOOL fExpired;
    BOOL fMaxApproved;
} rgver[] = {
    { 3911, 3999, TRUE }, // August 2001 Final libraries
    { 4039, 4099 }, // November 2001 libraries
    { 4134, 4199 }, // December 2001 libraries
    { 4242, 4299 }, // February 2002 libraries
    { VER_PRODUCTBUILD, 0 },
    { 0 }
};

/* These are the approved QFEs.  A QFE marked mandatory will reject earlier
 * versions of that lib, but not later ones */
static struct {
    LPCSTR szLibName;
    USHORT wQFEBuild;
    USHORT wQFENumber;
    BOOL fMandatory;
} rgqfe[] = {
// August01 QFEs
    { "DSOUND\0\0",   3925, 1, TRUE },
    { "DMUSIC\0\0",   3925, 1, FALSE },
    { "DSOUND\0\0",   3936, 1, FALSE },
    { "DMUSIC\0\0",   3941, 1, FALSE },
    { "D3D8\0\0\0\0", 3948, 1, TRUE },  // B#9310: fix flicker filter reset, B#9849: workaround SetRenderTarget hardware issue
    { "D3D8LTCG",     3948, 1, TRUE },  // B#9310: fix flicker filter reset, B#9849: workaround SetRenderTarget hardware issue
    { "DSOUND\0\0",   3949, 1, FALSE }, // B#10527: CWMAXMediaObject inits m_hFile
    { "XAPILIB\0",    3950, 1, TRUE },  // B#10693: verify media in XAPI init

// November01 QFEs
    { "D3D8\0\0\0\0", 4039, 2, TRUE },  // B#9882: W-Buffering fix, B#9849: workaround SetRenderTarget hardware issue
    { "D3D8LTCG",     4039, 2, TRUE },  // B#9882: W-Buffering fix, B#9849: workaround SetRenderTarget hardware issue
    { "DSOUND\0\0",   4039, 3, FALSE }, // B#10527: CWMAXMediaObject inits m_hFile
    { "XAPILIB\0",    4039, 4, TRUE },  // B#10693: verify media in XAPI init

// December01 QFEs
    { "D3D8\0\0\0\0", 4134, 2, FALSE }, // B#10377: SetOverscanColor removed, B#10330: XSASM /h fixed
    { "D3D8LTCG",     4134, 2, FALSE }, // B#10377: SetOverscanColor removed, B#10330: XSASM /h fixed
    { "DSOUND\0\0",   4134, 3, FALSE }, // B#10527: CWMAXMediaObject inits m_hFile, B#10610: fix rolloff discontinuity
    { "DSOUND\0\0",   4134, 5, FALSE }, // B#10527: CWMAXMediaObject inits m_hFile, B#10610: fix rolloff discontinuity, hack around WaitForVoiceOff
    { "DSOUND\0\0",   4134, 6, TRUE },  // WaitForVoiceOff fixes
    { "XAPILIB\0",    4134, 6, TRUE },  // B#10693: verify media in XAPI init
    { "WMVDEC\0\0",   4134, 6, FALSE }, // B#10821: WMV alloc/delete mismatch

    { NULL },
};

/* Dependencies */
static struct {
    LPCSTR szDependentName;
    USHORT wDependentNotOlderThan;
    USHORT wDependentNotNewerThan;
    LPCSTR szSupportingName;
    USHORT wMinimumSupportingVersion;
} rgdep[] = {
    { "DMUSIC\0\0", 3911, 3925, "DSOUND\0\0", 3936 },
    { NULL },
};

BOOL FAcceptableVerBuild(int iver, USHORT wVer)
{
    if(iver < 0)
        return FALSE;
    if(wVer < rgver[iver].wMinVer)
        return FALSE;
    if(rgver[iver].wMaxVer == 0)
        return TRUE;
    if(rgver[iver].fMaxApproved)
        return wVer <= rgver[iver].wMaxVer;
    return wVer < rgver[iver].wMaxVer;
}

int CheckLibraryApprovalStatus(PXBEIMAGE_LIBRARY_VERSION plibvXapi,
    PXBEIMAGE_LIBRARY_VERSION rglibv, int clibv, PLIB_ERROR_FUNCTION pfnErr)
{
    int idep;
    int iqfe;
    int iverXapi;
    int iTotal = 2;
    int i;
    BOOL fExpired;
    PXBEIMAGE_LIBRARY_VERSION plibv = rglibv;
    PXBEIMAGE_LIBRARY_VERSION plibvSup;

    /* Look at the XAPI version number and figure out which range of library
     * versions we'll consider acceptable */
    if(plibvXapi) {
        for(iverXapi = 0; rgver[iverXapi].wMinVer; ++iverXapi) {
            if(FAcceptableVerBuild(iverXapi, plibvXapi->BuildVersion)) {
                fExpired = rgver[iverXapi].fExpired;
                break;
            }
        }
        if(!rgver[iverXapi].wMinVer || plibvXapi->MajorVersion != 1 ||
                plibvXapi->MinorVersion != 0)
            iverXapi = -1;
    } else
        iverXapi = -1;

    for(; clibv--; ++plibv) {
        /* Assume approval at first based on whether XAPI was approved */
        i = iverXapi < 0 ? 0 : -1;

        /* Ensure major and minor version numbers are 1.0 */
        if(plibv->MajorVersion != 1 || plibv->MinorVersion != 0)
            i = 0;
    
        /* Check the QFE list first */
        for(iqfe = 0; i != 0 && rgqfe[iqfe].szLibName; ++iqfe) {
            if(0 == memcmp(plibv->LibraryName, rgqfe[iqfe].szLibName,
                XBEIMAGE_LIBRARY_VERSION_NAME_LENGTH) &&
                FAcceptableVerBuild(iverXapi, rgqfe[iqfe].wQFEBuild))
            {
                /* If this entry represents a mandatory QFE, we'll disallow
                 * this library if it is too old.  If the build number
                 * matches we'll mark the library as approved */
                if(rgqfe[iqfe].fMandatory && (plibv->BuildVersion <
                        rgqfe[iqfe].wQFEBuild || (plibv->BuildVersion ==
                        rgqfe[iqfe].wQFEBuild && plibv->QFEVersion <
                        rgqfe[iqfe].wQFENumber)))
                    i = 0;
                else if(plibv->BuildVersion == rgqfe[iqfe].wQFEBuild &&
                        plibv->QFEVersion == rgqfe[iqfe].wQFENumber)
                    i = 2;
            }
        }
        
        /* Check the base version list if this library isn't already
         * approved */
        if(i < 0) {
            if(iverXapi >= 0 && rgver[iverXapi].wMinVer ==
                    plibv->BuildVersion && plibv->QFEVersion == 1)
                i = 2;
    
            /* If this library hasn't been approved by now, it's unapproved */
            if(i < 0)
                i = 0;
        }
    
        /* The approval status of this library can't exceed the approval
         * stamp in the library itself */
        if(plibv->ApprovedLibrary < i)
            i = plibv->ApprovedLibrary;
    
        /* If this library is at all approved, check the dependency list
         * to make sure we have any necessary supporting libraries */
        if(i > 0) {
            for(idep = 0; rgdep[idep].szDependentName; ++idep) {
                if(0 == memcmp(plibv->LibraryName, rgdep[idep].szDependentName,
                    XBEIMAGE_LIBRARY_VERSION_NAME_LENGTH) &&
                    plibv->BuildVersion >= rgdep[idep].wDependentNotOlderThan &&
                    plibv->BuildVersion <= rgdep[idep].wDependentNotNewerThan)
                {
                    /* This library depends on something else.  Look for it */
                    for(plibvSup = rglibv + clibv; plibvSup-- > rglibv; ) {
                        if(plibvSup != plibv && 0 == memcmp(plibv->LibraryName,
                                rgdep[idep].szSupportingName,
                                XBEIMAGE_LIBRARY_VERSION_NAME_LENGTH) &&
                                FAcceptableVerBuild(iverXapi,
                                plibvSup->BuildVersion) &&
                                plibvSup->BuildVersion >=
                                rgdep[idep].wMinimumSupportingVersion)
                            break;
                    }
                    if(plibvSup < rglibv)
                        /* We needed a supporting lib but didn't find it.
                         * We'll mark this lib unsupported */
                        i = 0;
                }
            }
        }

        /* If this library is approved but XAPI is expired, we mark this
         * library as expired */
        if(i == 2 && fExpired)
            i = -1;

        /* If this library is unapproved, complain about it */
        if(i != 2 && pfnErr)
            (*pfnErr)(plibv, i);

        if(i <= 0 && !pfnErr)
            return 0;

        if(i < iTotal)
            iTotal = i;
    }

    return iTotal < 0 ? 0 : iTotal;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\common\callback.c ===
/*
 * callback.c
 */
#include "cabarc.h"
#include <errno.h>


/*
 * ----- FCI -----
 */
FNFCIALLOC(callback_fci_alloc)
{
    return callback_alloc(cb);
}

FNFCIFREE(callback_fci_free)
{
    callback_free(memory);
}

FNFCIOPEN(callback_fci_file_open)
{
    INT_PTR result;

    result = callback_file_open(pszFile, oflag, pmode);

    if (result == -1)
        *err = GetLastError();

    return result;
}

FNFCIREAD(callback_fci_file_read)
{
    unsigned int result;

    result = callback_file_read(hf, memory, cb);

    if (result != cb)
        *err = GetLastError();

    return result;
}

FNFCIWRITE(callback_fci_file_write)
{
    unsigned int result;

    result = callback_file_write(hf, memory, cb);

    if (result != cb)
        *err = GetLastError();

    return result;
}

FNFCICLOSE(callback_fci_file_close)
{
    int result;

    result = callback_file_close(hf);

    if (result == -1)
        *err = GetLastError();

    return result;
}

FNFCISEEK(callback_fci_file_seek)
{
    long result;

    result = callback_file_seek(hf, dist, seektype);

    if (result == -1)
        *err = GetLastError();

    return result;
}

FNFCIDELETE(callback_fci_file_delete)
{
    if (DeleteFile(pszFile) == FALSE)
    {
        *err = GetLastError();
        return -1;
    }
    else
    {
        return 0;
    }
}


/*
 * ----- FDI -----
 */

/*
 * Memory allocation function
 */
FNALLOC(callback_alloc)
{
	return LocalAlloc(LMEM_FIXED, cb);
}


/*
 * Memory free function
 */
FNFREE(callback_free)
{
	LocalFree(pv);
}


FNOPEN(callback_file_open)
{
	DWORD openmode, flags, readwrite_mode, fileshare;
	HANDLE handle;

	if (oflag & (_O_APPEND | _O_TEXT))
	{
		printf("Error, oflag not supported\n");
		return -1;
	}

	if (oflag & _O_RDWR)
	{
		readwrite_mode = GENERIC_READ | GENERIC_WRITE;
		fileshare = FILE_SHARE_READ | FILE_SHARE_WRITE;
	}
	else if (oflag & _O_WRONLY)
	{
		readwrite_mode = GENERIC_WRITE;
		fileshare = 0;
	}
	else /* oflag & _O_RDONLY, but _O_RDONLY is actually == 0 */
	{
		readwrite_mode = GENERIC_READ;
		fileshare = FILE_SHARE_READ;
	}

	flags = FILE_ATTRIBUTE_NORMAL;

	if (oflag & _O_RANDOM)
		flags |= FILE_FLAG_RANDOM_ACCESS;
	else if (oflag & _O_SEQUENTIAL)
		flags |= FILE_FLAG_SEQUENTIAL_SCAN;

	if (oflag & _O_CREAT)
	{
		if (oflag & _O_EXCL)
			openmode = CREATE_NEW;
		else
			openmode = CREATE_ALWAYS; /* yes, even if _O_TRUNC */
	}
	else if (oflag & _O_TRUNC)
	{
		openmode = TRUNCATE_EXISTING;
	}
	else
	{
		openmode = OPEN_EXISTING;
	}

	if (oflag & _O_TEMPORARY)
		flags |= FILE_FLAG_DELETE_ON_CLOSE;

	handle = CreateFile(
		pszFile,
		readwrite_mode,
		fileshare,
		NULL,
		openmode,
		flags,
		NULL
	);

	if (handle == INVALID_HANDLE_VALUE)
		return -1;
	else
		return (INT_PTR)handle;
}  


FNREAD(callback_file_read)
{
	DWORD bytes_read;

	(void) ReadFile((HANDLE) hf, pv, cb, &bytes_read, NULL);

	return bytes_read;
}


FNWRITE(callback_file_write)
{
	DWORD bytes_written;

	(void) WriteFile((HANDLE) hf, pv, cb, &bytes_written, NULL);

	return bytes_written;
}


FNCLOSE(callback_file_close)
{
	if (CloseHandle((HANDLE) hf) == TRUE)
		return 0;
	else
		return -1;
}


FNSEEK(callback_file_seek)
{
	switch (seektype)
	{
		case SEEK_SET:
			return SetFilePointer((HANDLE) hf, dist, NULL, FILE_BEGIN);

		case SEEK_CUR:
			return SetFilePointer((HANDLE) hf, dist, NULL, FILE_CURRENT);

		case SEEK_END:
			return SetFilePointer((HANDLE) hf, dist, NULL, FILE_END);
	}

	return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\common\cmdlist.c ===
/*
 * cmdlist.c
 */
#include "cabarc.h"


static void dos_date_to_ascii(WORD dos_date, char *ascii_date)
{
	int day, month, year;

	day		= dos_date & 31;
	month	= (dos_date >> 5) & 15;
	year	= (dos_date >> 9) + 1980;

	sprintf(
		ascii_date, 
		"%04d/%02d/%02d",
		year,
		month,
		day
	);
}


static void dos_time_to_ascii(WORD dos_time, char *ascii_time)
{
	int hour, minute, second;

	second = (dos_time & 31) << 1;
	minute = (dos_time >> 5) & 63;
	hour   = (dos_time >> 11) & 31;

	sprintf(
		ascii_time,
		"%02d:%02d:%02d",
		hour,
		minute,
		second
	);
}


static void dos_attribs_to_ascii(WORD dos_attribs, char *ascii_attribs)
{
	sprintf(
		ascii_attribs,
        "%c%c%c%c",
		dos_attribs & _A_RDONLY ? 'r' : '-',
        dos_attribs & _A_ARCH ? 'a' : '-',
		dos_attribs & _A_HIDDEN ? 'h' : '-',
		dos_attribs & _A_SYSTEM ? 's' : '-'
	);
}


static FNFDINOTIFY(notification_function)
{
	switch (fdint)
	{
		case fdintCABINET_INFO: // general information about the cabinet
			return 0;

		case fdintPARTIAL_FILE: // first file in cabinet is continuation
			return 0;

		case fdintCOPY_FILE:	// file to be copied
		{
			char ascii_date[32], ascii_time[32], ascii_attribs[32];

			dos_date_to_ascii(pfdin->date, ascii_date);
			dos_time_to_ascii(pfdin->time, ascii_time);
			dos_attribs_to_ascii(pfdin->attribs, ascii_attribs);

			printf(
				"   %-29s %8d %s %s  %s\n",
				pfdin->psz1,
				pfdin->cb,
				ascii_date,
				ascii_time,
				ascii_attribs
			);

			return 0;
		}

		case fdintCLOSE_FILE_INFO:	// close the file, set relevant info

			/* here is where we would set the file attributes provided */
			callback_file_close(pfdin->hf);

			return TRUE;

		case fdintNEXT_CABINET:	// file continued to next cabinet

			return -1;
	}

	return 0;
}


bool list_cab(char *cabname)
{
	HFDI			hfdi;
	ERF				erf;
	FDICABINETINFO	fdici;
	INT_PTR			hf;
	char			*p;
	char			cabinet_name[256];
	char			cabinet_path[256];

	hfdi = FDICreate(
		callback_alloc,
		callback_free,
		callback_file_open,
		callback_file_read,
		callback_file_write,
		callback_file_close,
		callback_file_seek,
		cpu80386,
		&erf
	);

	if (hfdi == NULL)
	{
		printf("FDICreate() failed: code %d [%s]\n",
			erf.erfOper, return_fdi_error_string(erf.erfOper)
		);

		return FALSE;
	}


	/*
	 * Is this file really a cabinet?
	 */
	hf = callback_file_open(
		cabname,
		_O_BINARY | _O_RDONLY | _O_SEQUENTIAL,
		0
	);

	if (hf == -1)
	{
		(void) FDIDestroy(hfdi);

		printf("Unable to open '%s' for input\n", cabname);
		return FALSE;
	}

	if (FALSE == FDIIsCabinet(
			hfdi,
			hf,
			&fdici))
	{
		/*
		 * No, it's not a cabinet!
		 */
		callback_file_close(hf);

		printf(
			"FDIIsCabinet() failed: '%s' is not a cabinet\n",
			cabname
		);

		(void) FDIDestroy(hfdi);
		return FALSE;
	}

	callback_file_close(hf);

	printf(
		"Listing of cabinet file '%s' (size %d):\n"
		"   %d file(s), %d folder(s), set ID %d, cabinet #%d\n"
		"\n",
		cabname,
		fdici.cbCabinet,
		fdici.cFiles,
		fdici.cFolders,
		fdici.setID,
		fdici.iCabinet
	);

	printf(
		"File name                      File size     Date      Time   Attrs\n"
		"-----------------------------  ---------- ---------- -------- -----\n"
	);

	p = strrchr(cabname, '\\');

	if (p == NULL)
	{
		strcpy(cabinet_name, cabname);
		strcpy(cabinet_path, "");
	}
	else
	{
		strcpy(cabinet_name, p+1);

		strncpy(cabinet_path, cabname, (int) (p-cabname)+1);
		cabinet_path[ (int) (p-cabname)+1 ] = 0;
	}

	if (TRUE != FDICopy(
		hfdi,
		cabinet_name,
		cabinet_path,
		0,
		notification_function,
		NULL,
		NULL))
	{
		printf(
			"FDICopy() failed: code %d [%s]\n",
			erf.erfOper, return_fdi_error_string(erf.erfOper)
		);

		(void) FDIDestroy(hfdi);
		return FALSE;
	}

	printf("\n");

	if (FDIDestroy(hfdi) != TRUE)
	{
		printf(
			"FDIDestroy() failed: code %d [%s]\n",
			erf.erfOper, return_fdi_error_string(erf.erfOper)
		);

		return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\common\dgstfile.c ===
// ---------------------------------------------------------------------------------------
// dgstfile.c
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------
// Includes
// ---------------------------------------------------------------------------------------

#include <windows.h>
#include <winsockx.h>
#include <xbox.h>
#include <xonlinep.h>
#include <sha.h>

#include <stdio.h>

#include "cryptcab.h"
#include "dgstfile.h"

// ---------------------------------------------------------------------------------------

//
// API to initialize the digest builder
//
HRESULT CreateDigest(
			DWORD			dwMaxEntries,
			DWORD			dwHeaderReservedSize,
			DWORD			dwPerFileReservedSize,
			PDGST_CONTEXT	*ppContext
			)
{
	HRESULT			hr = S_OK;
	PDGST_CONTEXT	pContext;

	RIP_ON_NOT_TRUE("CreateDigest", (ppContext != NULL));

	pContext = LocalAlloc(0, sizeof(DGST_CONTEXT) + (dwMaxEntries * sizeof(DGST_FILE_DATA)));
	if (!pContext)
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	// Set up the context
	pContext->dwHeaderReserved = dwHeaderReservedSize;
	pContext->dwPerFileReserved = dwPerFileReservedSize;
	pContext->dwEntriesAlloc = dwMaxEntries;
	pContext->dwEntriesCur = 0;
	pContext->rgdfd = (PDGST_FILE_DATA)(pContext + 1);

	*ppContext = pContext;
	
Cleanup:
	return(hr);

Error:
	if (pContext)
		LocalFree(pContext);
	goto Cleanup;
}

//
// API to Insert a file record into the digest
//
HRESULT InsertFileIntoDigest(
			PDGST_CONTEXT		pContext,
			PDGST_FILE_DATA		pdfd
			)
{
	HRESULT	hr = S_OK;
	DWORD	i;
	int		iCompare;
	PDGST_FILE_DATA	pdfdCur;

	RIP_ON_NOT_TRUE("InsertFileIntoDigest", (pContext != NULL));
	RIP_ON_NOT_TRUE("InsertFileIntoDigest", (pdfd != NULL));

	// Just do a linear search
	for (i = 0, pdfdCur = pContext->rgdfd; i < pContext->dwEntriesCur; i++, pdfdCur++)
	{
		iCompare = _stricmp(pdfdCur->szFileName, pdfd->szFileName);
		if (iCompare == 0)
		{
			// Duplicates are nto allowed. This is a collision
			hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
			goto Error;
		}
		else if (iCompare > 0)
		{
			// The list is sorted, the current list entry is greater than the insert entry
			// this is the insertion point
			break;
		}
	}

	// The current value of i marks the insertion point
	if (i >= pContext->dwEntriesAlloc)
	{
		hr = HRESULT_FROM_WIN32(ERROR_TOO_MANY_NAMES);
		goto Error;
	}

	// Shift entries back if necessary
	if (i < pContext->dwEntriesCur)
	{
		MoveMemory(pdfdCur + 1, pdfdCur, 
			((pContext->dwEntriesCur - i) * sizeof(DGST_FILE_DATA)));
	}

	CopyMemory(pdfdCur, pdfd, sizeof(DGST_FILE_DATA));
	pContext->dwEntriesCur++;
	
Cleanup:
	return(hr);

Error:
	goto Cleanup;
}

//
// API to serialze an in-memory digest to a file
//
// Note: the caller needs to fill in the wReservedSize, wFlags,
// and dfi members prior to calling this API. All other fields
// will be set automatically.
//
HRESULT SerializeDigestToFile(
			PDGST_CONTEXT		pContext,
			CHAR				*szDigestFile,
			PDGSTFILE_HEADER	pHeader,
			PBYTE				pbSymmetricKey,
			DWORD				cbSymmetricKey,
			PBYTE				pbHeaderReservedData
			)
{
	HRESULT				hr = S_OK;
	HANDLE				hFile = INVALID_HANDLE_VALUE;
	DWORD				i;
	DWORD				dwVectorOffset;
	DWORD				dwOffset = 0;
	DWORD				dwFixedSize;
	DWORD				dwNameLength;
	DWORD				dwSize;
	DWORD				*rgdwOffsets = NULL;
	PBYTE				pbBuffer = NULL;
	PDGST_FILE_DATA		pdfd;
	BYTE				rgbSignature[XCALCSIG_SIGNATURE_SIZE];

	RIP_ON_NOT_TRUE("SerializeDigestToFile", (pContext != NULL));
	RIP_ON_NOT_TRUE("SerializeDigestToFile", (pHeader != NULL));
	RIP_ON_NOT_TRUE("SerializeDigestToFile", (szDigestFile != NULL));
	RIP_ON_NOT_TRUE("SerializeDigestToFile", (pbSymmetricKey != NULL));
	RIP_ON_NOT_TRUE("SerializeDigestToFile", (cbSymmetricKey == XONLINE_KEY_LENGTH));

	RIP_ON_NOT_TRUE("SerializeDigestToFile", (pHeader->wReservedSize == 0));

	// First, create the file
	hFile = CreateFile(
				szDigestFile,
				GENERIC_READ | GENERIC_WRITE, 
				FILE_SHARE_READ, 
				NULL, 
				CREATE_ALWAYS, 
				FILE_ATTRIBUTE_NORMAL, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		printf("Cannot create digest file (%u)\n", hr);
		goto Error;
	}

	// Set up the header structure
	pHeader->bDigestVersionHi = DGSTFILE_VERSION_HI;
	pHeader->bDigestVersionLo = DGSTFILE_VERSION_LO;
	pHeader->cDigestEntries = pContext->dwEntriesCur;
	ZeroMemory(pHeader->rgbSignature, XCALCSIG_SIGNATURE_SIZE);

	// Write out the header
	if (!WriteFile(hFile, pHeader, sizeof(DGSTFILE_HEADER), &dwSize, NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		printf("Cannot write digest file header (%u)\n", hr);
		goto Error;
	}

	if (pContext->dwHeaderReserved && pbHeaderReservedData)
	{
		// Write out the reserved data
		if (!WriteFile(hFile, pbHeaderReservedData, 
					pContext->dwHeaderReserved, &dwSize, NULL))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			printf("Cannot write reserved header data (%u)\n", hr);
			goto Error;
		}
	}

	// Allocate the offset vector
	dwSize = sizeof(DWORD) * pContext->dwEntriesCur;
	rgdwOffsets = LocalAlloc(0, dwSize);
	if (!rgdwOffsets)
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	// Serialize out the data
	dwVectorOffset = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);
	dwOffset = SetFilePointer(hFile, dwSize, NULL, FILE_CURRENT);
	if (dwOffset == INVALID_SET_FILE_POINTER)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		printf("Failed preparing to write digest data (%u)\n", hr);
		goto Error;
	}

	// Note dwOffset has the current file offset

	//printf("Writing digest file ...\n");

	// Now figure out the size of each file record.
	// Note: thisonly works because we assume each file only has one section. This needs
	// to be changed if we support more sections.
	dwFixedSize = sizeof(DGST_FILE_DATA) - MAX_PATH;

	for (i = 0, pdfd = pContext->rgdfd; i < pContext->dwEntriesCur; i++, pdfd++)
	{
		// Write out the fixed portion of the file record
		if (!WriteFile(hFile, &(pdfd->dwFileSize), dwFixedSize, &dwSize, NULL))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			printf("Cannot write digest fixed data (%u)\n", hr);
			goto Error;
		}

		// Figure out the length of the file name (including NULL)
		dwNameLength = strlen(pdfd->szFileName);
		dwNameLength++;

		// Write out the string
		if (!WriteFile(hFile, pdfd->szFileName, dwNameLength, &dwSize, NULL))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			printf("Cannot write digest file data (%u)\n", hr);
			goto Error;
		}

		//printf("  Added %s to digest\n", pdfd->szFileName);

		// Save the offset
		rgdwOffsets[i] = dwOffset;
		dwSize = dwNameLength + dwFixedSize;
		dwOffset += dwSize;
		
	}

	// Write out the offset vector
	if (SetFilePointer(hFile, dwVectorOffset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		printf("Failed preparing to write offset data (%u)\n", hr);
		goto Error;
	}

	if (!WriteFile(hFile, rgdwOffsets, sizeof(DWORD) * pContext->dwEntriesCur, &dwSize, NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		printf("Cannot write to write offset data (%u)\n", hr);
		goto Error;
	}

	// Read the whole file and compute the signature
	dwSize = GetFileSize(hFile, NULL);
	if (dwSize == INVALID_FILE_SIZE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		printf("Failed preparing to compute signature (%u)\n", hr);
		goto Error;
	}
	RIP_ON_NOT_TRUE("SerializeDigestToFile", (dwSize == dwOffset));

	if (SetFilePointer(hFile, XCALCSIG_SIGNATURE_SIZE, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		printf("Failed preparing to compute signature (%u)\n", hr);
		goto Error;
	}
	dwSize -= XCALCSIG_SIGNATURE_SIZE;

	pbBuffer = LocalAlloc(0, dwSize);
	if (!pbBuffer)
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	if (!ReadFile(hFile, pbBuffer, dwSize, &i, NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		printf("Cannot verify digest data (%u)\n", hr);
		goto Error;
	}

	shaHmac(pbSymmetricKey, cbSymmetricKey, pbBuffer, dwSize, NULL, 0, rgbSignature);

	// Finally, write out the signature
	if (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		printf("Failed preparing to write signature (%u)\n", hr);
		goto Error;
	}

	if (!WriteFile(hFile, rgbSignature, XCALCSIG_SIGNATURE_SIZE, &dwSize, NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		printf("Cannot write to write offset data (%u)\n", hr);
		goto Error;
	}

Cleanup:

	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);
	
	if (FAILED(hr))
	{
		DeleteFile(szDigestFile);
	}

	if (rgdwOffsets)
		LocalFree(rgdwOffsets);
	if (pbBuffer)
		LocalFree(pbBuffer);
	
	return(hr);

Error:
	goto Cleanup;
}

//
// API to free a digest context
//
VOID FreeDigest(
			PDGST_CONTEXT	pContext
			)
{
	LocalFree(pContext);
}

//
// API to create a digest file from a file list
//
HRESULT CreateDigestFromFileList(
			cab_file_list_header	*pFileList,
			PDGSTFILE_HEADER		pdfh,
			PSTR					szDigestPath,
			PBYTE					pbSymmetricKey,
			DWORD					cbSymmetricKey
			)
{
	HRESULT			hr = S_OK;
	PDGST_CONTEXT	pDigest = NULL;
	DGST_FILE_DATA	dfd;
	DGSTFILE_HEADER	dfh;
	LARGE_INTEGER	liSize;
	HANDLE			hFile = INVALID_HANDLE_VALUE;
	PBYTE			pbBuffer= NULL;
	DWORD			cItems = 0;
	DWORD			cbSize;
	A_SHA_CTX		Sha;
	CHAR			szStrippedName[MAX_PATH];
	struct cab_file_link	*item;

	// Count how many items in the file list
	for (item = pFileList->flh_head; item; item = item->fl_next, cItems++)
		;

	// Create a digest
	hr = CreateDigest(cItems, 0, 0, &pDigest);
	if (FAILED(hr))
		goto Error;
	
	for (item = pFileList->flh_head; item; item = item->fl_next)
	{
        if (item->fl_logical_filename != NULL)
        {
            // the user already supplied a logical filename
            strcpy(szStrippedName, item->fl_logical_filename);
        }
        else
        {
        	// Get the relative path to store
            strcpy(szStrippedName, item->fl_filename);
        }

		// Fill in the digest file data for this file
		hFile = CreateFile(item->fl_filename,
					GENERIC_READ, 
					FILE_SHARE_READ,
					NULL, 
					OPEN_EXISTING, 
					FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, 
					NULL);
		if (hFile == INVALID_HANDLE_VALUE)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto Error;
		}
		// Get the file size
		if (!GetFileSizeEx(hFile, &liSize))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto Error;
		}

		// Allocate a buffer
		pbBuffer = (PBYTE)LocalAlloc(0, liSize.u.LowPart);
		if (!pbBuffer)
		{
			hr = E_OUTOFMEMORY;
			goto Error;
		}

		// Read in the entire file
		if (!ReadFile(hFile, pbBuffer, liSize.u.LowPart, &cbSize, NULL))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto Error;
		}

		// Set up the DGST_FILE_DATA struct
		strcpy(dfd.szFileName, szStrippedName);
		dfd.dwFileSize = cbSize;
		dfd.bFlags = 0;
		dfd.bReservedSize = 0;
		dfd.wSections = 1;
		dfd.rgSectionData[0].dwSectionStart = 0;
		dfd.rgSectionData[0].dwSectionSize = cbSize;

		// Run the SHA1 checksum
		A_SHAInit(&Sha);
		A_SHAUpdate(&Sha, pbBuffer, cbSize);
		A_SHAFinal(&Sha, dfd.rgSectionData[0].rgbSignature);

        // Insert this file to the digest.
        hr = InsertFileIntoDigest(pDigest, &dfd);
        if (FAILED(hr))
        	goto Error;

       	// Free the buffer
       	LocalFree(pbBuffer);
       	pbBuffer = NULL;
	}

	// OK, now serialize the digest out to the specified file
	hr = SerializeDigestToFile(pDigest, 
				szDigestPath, 
				pdfh, 
				pbSymmetricKey, cbSymmetricKey, NULL);
	if (FAILED(hr))
		goto Error;

Exit:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	if (pbBuffer)
		LocalFree(pbBuffer);

	if (pDigest)
		FreeDigest(pDigest);

	return(hr);

Error:
	goto Exit;
}

//
// API to dump a digest file
//
HRESULT DumpDigest(
			CHAR	*szDigestFile,
			BOOL	fVerify,
			PBYTE	pbSymmetricKey,
			DWORD	cbSymmetricKey
			)
{
	HRESULT				hr = S_OK;
	HANDLE				hFile = INVALID_HANDLE_VALUE;
	HANDLE				hVerify = INVALID_HANDLE_VALUE;
	DWORD				i, c;
	DWORD				dwSize;
	DWORD				*rgdwOffsets = NULL;
	PBYTE				pbBuffer = NULL;
	PBYTE				pbVerify = NULL;
	DWORD				cbMax;
	DWORD				cbVerify;
	CHAR				*szFileName;
	PDGSTFILE_HEADER	pHeader;
	PDGSTFILE_FILE_DATA	pdffd;
	BYTE				rgbSignature[XCALCSIG_SIGNATURE_SIZE];
	A_SHA_CTX			Sha;

	RIP_ON_NOT_TRUE("SerializeDigestToFile", (szDigestFile != NULL));

	// First, open the file
	hFile = CreateFile(
				szDigestFile,
				GENERIC_READ, 
				FILE_SHARE_READ, 
				NULL, 
				OPEN_EXISTING, 
				FILE_ATTRIBUTE_NORMAL, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		printf("Cannot open digest file (%u)\n", hr);
		goto Error;
	}

	// Figure out how big the file is
	dwSize = GetFileSize(hFile, NULL);
	if (dwSize == INVALID_FILE_SIZE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		printf("Failed to get file size (%u)\n", hr);
		goto Error;
	}

	// Allocate the buffer
	pbBuffer = LocalAlloc(0, dwSize);
	if (!pbBuffer)
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	// Read the whole file
	if (!ReadFile(hFile, pbBuffer, dwSize, &dwSize, NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		printf("Cannot Read digest file (%u)\n", hr);
		goto Error;
	}

	// Calculate the signature and make sure it matches
	shaHmac(pbSymmetricKey, cbSymmetricKey,
				pbBuffer + XCALCSIG_SIGNATURE_SIZE,
				dwSize - XCALCSIG_SIGNATURE_SIZE,
				NULL, 0, rgbSignature);

	if (memcmp(rgbSignature, pbBuffer, XCALCSIG_SIGNATURE_SIZE) != 0)
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		printf("File digest does not match (%u)\n", hr);
		goto Error;
	}

	// Display header info
	pHeader = (PDGSTFILE_HEADER)pbBuffer;
	printf("Digest version: %u.%02u\n", 
				pHeader->bDigestVersionHi, pHeader->bDigestVersionLo);
	printf("Digest file entries: %u\n", pHeader->cDigestEntries);
	printf("Reserved size: %u\n", pHeader->wReservedSize);
	printf("Flags: %4x\n\n", pHeader->wFlags);

	printf("Content ID: %08x\n\n", pHeader->dfi.OfferingId);

	// Find the offset vector
	rgdwOffsets = (PDWORD)(pbBuffer + (sizeof(DGSTFILE_HEADER) + pHeader->wReservedSize));

	// Find the max amount of memory needed
	for (i = 0, cbMax = 0; i < pHeader->cDigestEntries; i++)
	{
		pdffd = (PDGSTFILE_FILE_DATA)(pbBuffer + rgdwOffsets[i]);

		for (c = 0; c < pdffd->wSections; c++)
		{
			if (pdffd->rgSectionData[c].dwSectionSize > cbMax)
				cbMax = pdffd->rgSectionData[c].dwSectionSize;
		}
	}
	pbVerify = LocalAlloc(0, cbMax);
	if (!pbVerify)
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	for (i = 0; i < pHeader->cDigestEntries; i++)
	{
		// Dump each entry
		pdffd = (PDGSTFILE_FILE_DATA)(pbBuffer + rgdwOffsets[i]);
		szFileName = (CHAR *)(pdffd + 1);

		printf("File name: %s\n", szFileName);
		printf("    File Size: %u\n", pdffd->dwFileSize);
		printf("    File Flags: %08x\n", pdffd->bFlags);
		printf("    Reserved size: %u\n\n", pdffd->bReservedSize);
		printf("    Number of checksum sections: %u\n", pdffd->wSections);

		if (fVerify)
		{
			hVerify = CreateFile(
						szFileName,
						GENERIC_READ, 
						FILE_SHARE_READ, 
						NULL, 
						OPEN_EXISTING, 
						FILE_ATTRIBUTE_NORMAL, 
						NULL);
			if (hFile == INVALID_HANDLE_VALUE)
			{
				hr = HRESULT_FROM_WIN32(GetLastError());
				printf("Cannot open file %s for verify (%08x)\n", hr);
				goto Error;
			}

			// Figure out how big the file is
			dwSize = GetFileSize(hVerify, NULL);
			if (dwSize == INVALID_FILE_SIZE)
			{
				hr = HRESULT_FROM_WIN32(GetLastError());
				printf("Failed to get file size (%u)\n", hr);
				goto Error;
			}

			for (c = 0; c < pdffd->wSections; c++)
			{
				printf("    -- Section %u - Start: %u, Size: %u  ", c,
						pdffd->rgSectionData[c].dwSectionStart,
						pdffd->rgSectionData[c].dwSectionSize);

				if (SetFilePointer(hVerify, 
							pdffd->rgSectionData[c].dwSectionStart,
							NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
				{
					hr = HRESULT_FROM_WIN32(GetLastError());
					goto Error;
				}
				if (!ReadFile(hVerify, pbVerify, 
							pdffd->rgSectionData[c].dwSectionSize, 
							&cbVerify, NULL))
				{
					hr = HRESULT_FROM_WIN32(GetLastError());
					goto Error;
				}

				// Run the checksum (minus signature)
				A_SHAInit(&Sha);
				A_SHAUpdate(&Sha, pbVerify, cbVerify);
				A_SHAFinal(&Sha, rgbSignature);

				// Verify
				if (memcmp(pdffd->rgSectionData[c].rgbSignature,
							rgbSignature, XCALCSIG_SIGNATURE_SIZE) != 0)
				{
					puts("[FAILED]\n");
					hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
					goto Error;
				}
				else
				{
					puts("[OK]\n");
				}
			}
			puts("");

			CloseHandle(hVerify);
			hVerify = INVALID_HANDLE_VALUE;
		}
		else
		{
			for (c = 0; c < pdffd->wSections; c++)
			{
				printf("    -- Section %u - Start: %u, Size: %u\n", c,
						pdffd->rgSectionData[c].dwSectionStart,
						pdffd->rgSectionData[c].dwSectionSize);

				
			}
			puts("");
		}
	}

Cleanup:

	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	if (hVerify != INVALID_HANDLE_VALUE)
		CloseHandle(hVerify);

	if (pbBuffer)
		LocalFree(pbBuffer);

	if (pbVerify)
		LocalFree(pbVerify);
	
	return(hr);

Error:
	goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\common\fciutil.c ===
/*
 * fciutil.c
 *
 * Support functions for the demo programs
 */
#include "cabarc.h"


void strip_path(char *filename, char *stripped_name)
{
	char	*p;

	p = strrchr(filename, '\\');

	if (p == NULL)
		strcpy(stripped_name, filename);
	else
		strcpy(stripped_name, p+1);
}


int get_percentage(unsigned long a, unsigned long b)
{
	while (a > 10000000)
	{
		a >>= 3;
		b >>= 3;
	}

	if (b == 0)
		return 0;

	return ((a*100)/b);
}


char *return_fci_error_string(FCIERROR err)
{
	switch (err)
	{
		case FCIERR_NONE:
			return "No error";

		case FCIERR_OPEN_SRC:
			return "Failure opening file to be stored in cabinet";
		
		case FCIERR_READ_SRC:
			return "Failure reading file to be stored in cabinet";
		
		case FCIERR_ALLOC_FAIL:
			return "Insufficient memory in FCI";

		case FCIERR_TEMP_FILE:
			return "Could not create a temporary file";

		case FCIERR_BAD_COMPR_TYPE:
			return "Unknown compression type";

		case FCIERR_CAB_FILE:
			return "Could not create cabinet file";

		case FCIERR_USER_ABORT:
			return "Client requested abort";

		case FCIERR_MCI_FAIL:
			return "Failure compressing data";

		default:
			return "Unknown error";
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\common\memory.c ===
/*
 * memory.c
 */

#include "cabarc.h"


byte *mem_malloc(long size)
{
   return (malloc(size));
}


void mem_free(byte *mem)
{
   free(mem);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\common\cmdnew.c ===
/*
 * cmdnew.c
 */
#include "cabarc.h"
#include "oldnames.h"
#include "cryptcab.h"
#include "metadata.h"

#include "pubkey.c"


#define FOLDER_THRESHOLD	LONG_MAX


/*
 * File placed function called when a file has been committed
 * to a cabinet
 */
static FNFCIFILEPLACED(file_placed)
{
	return 0;
}


/*
 * Function to obtain temporary files
 */
static FNFCIGETTEMPFILE(get_temp_file)
{
    char    *psz;

    psz = _tempnam("","xx");            // Get a name
    if ((psz != NULL) && (strlen(psz) < (unsigned)cbTempName)) {
        strcpy(pszTempName,psz);        // Copy to caller's buffer
        free(psz);                      // Free temporary name buffer
        return TRUE;                    // Success
    }
    //** Failed
    if (psz) {
        free(psz);
    }

    return FALSE;
}


/*
 * Progress function
 */
static FNFCISTATUS(progress)
{
	return 0;
}


static FNFCIGETNEXTCABINET(get_next_cabinet)
{
    if (strchr(g_cabinet_template,'%') == NULL)
    {
        printf("\n"
            "When creating cabinet sets using -d, the cabinet name should contain\n"
            "a single '*' character where the cabinet number will be inserted.\n"
            "\n"
        );

	    return -1;  /* shut it down */
    }
    else
    {
        sprintf(pccab->szCab,g_cabinet_template,pccab->iCab);

	    return TRUE;
    }
}


static FNFCIGETOPENINFO(get_open_info)
{
	BY_HANDLE_FILE_INFORMATION	finfo;
	FILETIME					filetime;
	HANDLE						handle;

	handle = CreateFile(
		pszName,
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
		NULL
	);

	if (handle == INVALID_HANDLE_VALUE)
	{
        *err = GetLastError();
		return -1;
	}

	if (GetFileInformationByHandle(handle, &finfo) == FALSE)
	{
        *err = GetLastError();
		CloseHandle(handle);
		return -1;
	}

	FileTimeToLocalFileTime(
		&finfo.ftLastWriteTime,
		&filetime
	);

	FileTimeToDosDateTime(
		&filetime,
		pdate,
		ptime
	);

	// CABARCX: Force the timestamp to be 0, we have other plans
	*ptime = 0;

    *pattribs = (USHORT) finfo.dwFileAttributes &
        (FILE_ATTRIBUTE_READONLY |
         FILE_ATTRIBUTE_HIDDEN   |
         FILE_ATTRIBUTE_SYSTEM   |
         FILE_ATTRIBUTE_ARCHIVE);

	printf("  -- adding %s\n", pszName);

	return (INT_PTR)handle;
}

static FNFCIGETOPENINFO(get_open_info_quiet)
{
	BY_HANDLE_FILE_INFORMATION	finfo;
	FILETIME					filetime;
	HANDLE						handle;

	handle = CreateFile(
		pszName,
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
		NULL
	);

	if (handle == INVALID_HANDLE_VALUE)
	{
        *err = GetLastError();
		return -1;
	}

	if (GetFileInformationByHandle(handle, &finfo) == FALSE)
	{
        *err = GetLastError();
		CloseHandle(handle);
		return -1;
	}

	FileTimeToLocalFileTime(
		&finfo.ftLastWriteTime,
		&filetime
	);

	FileTimeToDosDateTime(
		&filetime,
		pdate,
		ptime
	);

	// CABARCX: Force the timestamp to be 0, we have other plans
	*ptime = 0;

    *pattribs = (USHORT) finfo.dwFileAttributes &
        (FILE_ATTRIBUTE_READONLY |
         FILE_ATTRIBUTE_HIDDEN   |
         FILE_ATTRIBUTE_SYSTEM   |
         FILE_ATTRIBUTE_ARCHIVE);

	return (INT_PTR)handle;
}

static void set_cab_parameters(PCCAB cab_parms)
{
	memset(cab_parms, 0, sizeof(CCAB));

    if ((g_disk_size != LONG_MAX) && (g_set_id == 0))
    {
        srand((unsigned)time(NULL));
        g_set_id = (LONG) rand();
    }

	cab_parms->cb = g_disk_size;
	cab_parms->cbFolderThresh = FOLDER_THRESHOLD;

	cab_parms->cbReserveCFHeader = g_reserved_cfheader_space;
	cab_parms->cbReserveCFFolder = g_reserved_cffolder_space;
	cab_parms->cbReserveCFData   = 0;

	cab_parms->iCab  = 1;
	cab_parms->iDisk = 0;
	cab_parms->setID = (USHORT) g_set_id;

	strcpy(cab_parms->szDisk, "");

    sprintf(cab_parms->szCab,g_cabinet_template,cab_parms->iCab);
}


static void get_filename_to_store_in_cab(char *filename, char *stripped_name)
{
	struct cab_file_link	*search;

	if (g_preserve_path_names)
	{
		char *p;

		/*
		 * Skip directory info (do not allow drive letters to be stored)
		 */
		p = strrchr(filename, ':');

		if (p)
			filename = p+1;

		/*
		 * Skip leading slash
		 */
		if (*filename == SLASH_CHARACTER)
			filename++;

		/*
		 * Strip prefixes defined by the user
		 */
		for (search = g_strip_path_list.flh_head; search; search = search->fl_next)
		{
			if (!strnicmp(filename, search->fl_filename, strlen(search->fl_filename)))
			{
				if (strlen(filename) > strlen(search->fl_filename))
				{
					strcpy(stripped_name, &filename[ strlen(search->fl_filename) ]);
					return;
				}
			}
		}

		/*
		 * No prefies to strip
		 */
		strcpy(stripped_name, filename);
	}
	else
	{
		strip_path(filename, stripped_name);
	}
}

bool create_new_cab(char *cabname, cab_file_list_header *files_to_add)
{
	HFCI			hfci = NULL;
	ERF				erf;
	CCAB			cab_parameters;
	struct cab_file_link *item;
	char			compression_mode[80];
    int             cab_path_length;
    char           *psz;

	HRESULT		hr = S_OK;
	HCRYPTPROV	hCrypto = 0;
	HCRYPTKEY	hKeyPublic = 0;
	HANDLE		hFile = INVALID_HANDLE_VALUE;
	BYTE		rgbSymKey[XONLINE_KEY_LENGTH];
	CHAR		szRawCab[MAX_PATHNAME_LENGTH];
	CHAR		szTempMetadata[MAX_PATHNAME_LENGTH];
	BOOL		fRet = true;
	TCOMP		tcomp;

	*szTempMetadata = '\0';
    strip_path(cabname, g_cabinet_template);

    cab_path_length = strlen(cabname) - strlen(g_cabinet_template);

    for (psz = g_cabinet_template; *psz != '\0'; psz++)
    {
        if (*psz == '*')
        {
            memmove(psz + 1, psz, strlen(psz) + 1);

            *psz++ = '%';
            *psz = 'd';

            break;
        }
    }

	set_cab_parameters(&cab_parameters);

	strncpy(
		cab_parameters.szCabPath,
		cabname,
		cab_path_length
	);

	cab_parameters.szCabPath[ cab_path_length ] = 0;

	// Initialize our crypto provider and establish public key
	hr = InitializeCrypto(
				NULL, 0,
				rgbPublicKey, sizeof(rgbPublicKey),
				&hCrypto, &hKeyPublic, NULL, 0);
	if (FAILED(hr))
	{
		printf("Unable to initialize crypto provider, error %u\n", hr);
		return(false);
	}

	hfci = FCICreate(
		&erf,
		file_placed,
        callback_fci_alloc,
        callback_fci_free,
        callback_fci_file_open,
        callback_fci_file_read,
        callback_fci_file_write,
        callback_fci_file_close,
        callback_fci_file_seek,
        callback_fci_file_delete,
		get_temp_file,
        &cab_parameters,
        NULL /* pv */
	);

	switch (g_compression_type)
	{
		default:
			strcpy(compression_mode, "UNKNOWN");
			tcomp = tcompTYPE_NONE;
			break;

		case COMPRESSION_TYPE_NONE:
			strcpy(compression_mode, "NONE");
			tcomp = tcompTYPE_NONE;
			break;

		case COMPRESSION_TYPE_MSZIP:
			strcpy(compression_mode, "MSZIP");
			tcomp = tcompTYPE_MSZIP;
			break;

		case COMPRESSION_TYPE_LZX:
			sprintf(compression_mode, "LZX:%d", g_compression_memory);
			tcomp = (TCOMP)TCOMPfromLZXWindow(g_compression_memory);
			break;
	}

	printf(
		"Creating new cabinet '%s%s' with compression '%s':\n",
		cab_parameters.szCabPath, cab_parameters.szCab,
		compression_mode
	);

	if (hfci == NULL)
	{
		printf("FCICreate() failed: code %d [%s]\n",
			erf.erfOper, return_fci_error_string(erf.erfOper)
		);

		return false;
	}

	// Create a new symmetric key
	hr = GenerateSymmetricKey(hCrypto, rgbSymKey);
	if (FAILED(hr))
	{
		printf("Unable to create package parameters, error %u\n", hr);
		goto Error;
	}

	strcpy(szRawCab, cabname);
	strcat(szRawCab, ".cab");
	for (item = files_to_add->flh_head; item; item = item->fl_next)
	{
		char	stripped_name[MAX_PATHNAME_LENGTH];

        if (!strcmp(item->fl_filename, FOLDER_SEPARATOR_STRING))
		{
			if (FALSE == FCIFlushFolder(
				hfci,
				get_next_cabinet,
                progress))
			{
				printf("FCIFlushFolder() failed: code %d [%s]\n",
					erf.erfOper, return_fci_error_string(erf.erfOper)
				);
				goto Error;
			}

			continue;
		}

		/*
		 * Don't allow a cabinet to be added to itself
         * (This won't save you if cabinet name is a template)
		 */
		if (!stricmp(cabname, item->fl_filename))
			continue;

        if (item->fl_logical_filename != NULL)
        {
            // the user already supplied a logical filename
            strcpy(stripped_name, item->fl_logical_filename);
        }
        else
        {
            /*
             * Don't store the exact path name in the cabinet file!
             */
            get_filename_to_store_in_cab(item->fl_filename, stripped_name);
        }

		if (FALSE == FCIAddFile(
			hfci,
			item->fl_filename, /* file to add */
			stripped_name, /* file name in cabinet file */
			FALSE, /* file is not executable */
			get_next_cabinet,
			progress,
			get_open_info,
            tcomp))
		{
			printf("FCIAddFile() failed: code %d [%s]\n",
				erf.erfOper, return_fci_error_string(erf.erfOper)
			);
			goto Error;
		}
	}		

	printf("\n");

	/*
	 * This will automatically flush the folder first
	 */
	if (FALSE == FCIFlushCabinet(
		hfci,
		FALSE,
		get_next_cabinet,
        progress))
	{
		printf("FCIFlushCabinet() failed: code %d [%s]\n",
			erf.erfOper, return_fci_error_string(erf.erfOper)
		);
		goto Error;
	}

    if (FCIDestroy(hfci) != TRUE)
	{
		printf("FCIDestroy() failed: code %d [%s]\n",
			erf.erfOper, return_fci_error_string(erf.erfOper)
		);
		fRet = false;
		goto Exit;
	}
	hfci = NULL;

	// If we are in debug mode, save a copy of the raw cab file
	if (g_debug_mode)
	{
		DeleteFile(szRawCab);
		if (!CopyFile(cabname, szRawCab, TRUE))
		{
			printf("Cannot output raw cabinet %s, error %u\n", 
						szRawCab, GetLastError());
			goto Abort;
		}
	}

	// Re-open the cabinet
	hFile = CreateFile(
				cabname,
				GENERIC_READ | GENERIC_WRITE, 
				FILE_SHARE_READ, 
				NULL, 
				OPEN_EXISTING, 
				FILE_ATTRIBUTE_NORMAL, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		printf("Cannot post-process cabinet %s, error %u\n", 
					cabname, GetLastError());
		goto Abort;
	}

	// Ok, now we can encrypt the cabinet
	hr = EncryptCabinetBody(hFile, hCrypto, rgbSymKey, XONLINE_KEY_LENGTH);
	if (FAILED(hr))
	{
		printf("Unable to build package (1), error %u\n", hr);
		goto Abort;
	}

	hr = EncryptCabinetHeader(hFile, hCrypto, rgbSymKey, XONLINE_KEY_LENGTH);
	if (FAILED(hr))
	{
		printf("Unable to build package (2), error %u\n", hr);
		goto Abort;
	}

	if (!g_offline)
	{
		// Now encrypt the public key and embed into the signature slot
		hr = EncloseSymmetricKey(hFile, hKeyPublic, rgbSymKey, XONLINE_KEY_LENGTH);
		if (FAILED(hr))
		{
			printf("Unable to seal package, error %u\n", hr);
			goto Abort;
		}

		// We will parse the metadata file to build the full metadata file
		// Figure out a temp filename
		strcpy(szTempMetadata, g_metadata_file_path);
		strcat(szTempMetadata, ".$$$");
		hr = BuildPackedFileFromMetadataFile(
					g_metadata_file_path, szTempMetadata);
		if (FAILED(hr))
		{
			printf("%s\n", MetadataGetErrorString());
			goto Abort;
		}
		
		// Finally, we append an encrypted version of the metadata file to the
		// end of the package
		hr = AppendEncryptedFile(hFile, szTempMetadata, 
					hCrypto, rgbSymKey, XONLINE_KEY_LENGTH);
		if (FAILED(hr))
		{
			printf("Unable to process metadata file, error %u\n", hr);
			goto Abort;
		}
	}
	else
	{
	}

		printf("Completed successfully\n");

Exit:

	if (*szTempMetadata != '\0')
		DeleteFile(szTempMetadata);

	return(fRet);

Abort:
	DeleteFile(cabname);
	if (g_debug_mode)
		DeleteFile(szRawCab);
	
Error:	
	if (hfci)
	    (void) FCIDestroy(hfci);
    fRet = false;
    goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\common\fdiutil.c ===
/*
 * fdiutil.c
 *
 * Support functions for the demo programs
 */
#include "cabarc.h"


char *return_fdi_error_string(FDIERROR err)
{
	switch (err)
	{
		case FDIERROR_NONE:
			return "No error";

		case FDIERROR_CABINET_NOT_FOUND:
			return "Cabinet not found";
			
		case FDIERROR_NOT_A_CABINET:
			return "Not a cabinet";
			
		case FDIERROR_UNKNOWN_CABINET_VERSION:
			return "Unknown cabinet version";
			
		case FDIERROR_CORRUPT_CABINET:
			return "Corrupt cabinet";
			
		case FDIERROR_ALLOC_FAIL:
			return "Memory allocation failed";
			
		case FDIERROR_BAD_COMPR_TYPE:
			return "Unknown compression type";
			
		case FDIERROR_MDI_FAIL:
			return "Failure decompressing data";
			
		case FDIERROR_TARGET_FILE:
			return "Failure writing to target file";
			
		case FDIERROR_RESERVE_MISMATCH:
			return "Cabinets in set have different RESERVE sizes";
			
		case FDIERROR_WRONG_CABINET:
			return "Cabinet returned on fdintNEXT_CABINET is incorrect";
			
		case FDIERROR_USER_ABORT:
			return "User aborted";
			
		default:
			return "Unknown error";
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\common\cryptcab.c ===
//===================================================================
//
// Copyright Microsoft Corporation. All Rights Reserved.
//
//===================================================================
#include <windows.h>
#include <winsock2.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <xbox.h>
#include <wsockntp.h>
#include <xonlinep.h>

#include <assert.h>

#include "cabarc.h"
#include "rebldcab.h"
#include "metadata.h"

#include "rsa.h"
#include "sha.h"
#include "rc4.h"

#include "devkitkeys.c"

#define XBOX_HD_SECTOR_SIZE	512

#define RIP(a)

#ifndef RtlRip
VOID RtlRip(PVOID pv1, PVOID pv2, PVOID pv3)
{
	assert(pv2);
}
#endif

//
// Define our own crypto provider
//
#define CRYPTCAB_CRYPTO_PROVIDER		"XboxOnlineContent"


#include "cabinet.h"

#include "cryptcab.h"

//
// Function to initialize the crypto facilities 
//
HRESULT InitializeCrypto(
			PBYTE		pbPrivateKey,
			DWORD		cbPrivateKey,
			PBYTE		pbPublicKey,
			DWORD		cbPublicKey,
			HCRYPTPROV 	*phCrypto,
			HCRYPTKEY	*phKeyPublic,
			HCRYPTKEY	*phKeyPrivate,
			DWORD		dwFlags
			)
{
    HRESULT 	hr = S_OK;
	HCRYPTPROV	hCrypto = 0;
	HCRYPTKEY	hKeyPrivate = 0;
	HCRYPTKEY	hKeyPublic = 0;

	// Try to open our container
    if (!CryptAcquireContext(
    			&hCrypto, 
    			CRYPTCAB_CRYPTO_PROVIDER, 
    			MS_ENHANCED_PROV, 
    			PROV_RSA_FULL, 
    			0))
	{
		hCrypto = 0;
		if ((dwFlags & CRYPTCAB_FLAG_DONT_CREATE) == 0)
		{
			// Try to create it
		    if (!CryptAcquireContext(&hCrypto,
						CRYPTCAB_CRYPTO_PROVIDER,
						MS_ENHANCED_PROV,
						PROV_RSA_FULL,
						CRYPT_NEWKEYSET))
		    {
		        hr = GetLastError();
		        hCrypto = 0;
			    goto Error;
		    }
		}
		else
		{
			hr = GetLastError();
			goto Error;
		}
	}

    // Import the private key
    if (pbPrivateKey)
    {
	    if (!CryptImportKey(hCrypto, 
	    			pbPrivateKey, 
	    			cbPrivateKey, 
	    			0, 
	    			0, 
	    			&hKeyPrivate))
	    {
	        hr = GetLastError();
		    goto Error;
	    }
	}

    // Import the public key
    if (pbPublicKey)
    {
	    if (!CryptImportKey(hCrypto, 
	    			pbPublicKey, 
	    			cbPublicKey, 
	    			0, 
	    			0, 
	    			&hKeyPublic))
	    {
	        hr = GetLastError();
		    goto Error;
	    }
	}

	// Return these handles
	*phCrypto = hCrypto;
	if (phKeyPublic)
		*phKeyPublic = hKeyPublic;
	if (phKeyPrivate)
		*phKeyPrivate = hKeyPrivate;

Exit:
    return(hr);

Error:
	if (hCrypto)
        CryptReleaseContext(hCrypto, 0);
	goto Exit;
}

//
// Function to just generate a string of random numbers
//
HRESULT GenerateRandomBytes(
			HCRYPTPROV	hCrypto,
			PBYTE		pbData,
			DWORD		cbData
			)
{
	if (!CryptGenRandom(hCrypto, cbData, pbData))
		return(HRESULT_FROM_WIN32(GetLastError()));
	return(S_OK);
}

//
// Function to generate a confounder
//
HRESULT GenerateConfounder(
			HCRYPTPROV	hCrypto,
			PBYTE		pbConfounder
			)
{
	return(GenerateRandomBytes(hCrypto, pbConfounder, RC4_CONFOUNDER_LEN));
}

//
// Function to generate a random symmetric key
//
HRESULT GenerateSymmetricKey(
			HCRYPTPROV	hCrypto,
			PBYTE		pbSymmetricKey
			)
{
	return(GenerateRandomBytes(hCrypto, pbSymmetricKey, XONLINE_KEY_LENGTH));
}

//////////////////////////////////////////////////////////////////////////
//
// SHA1 HMAC calculation
//
//////////////////////////////////////////////////////////////////////////
void shaHmac(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    )
{
#define HMAC_K_PADSIZE              64
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        A_SHAUpdate(&shaHash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    }

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    A_SHAFinal(&shaHash,HmacData);
}

/*
#define RC4_CONFOUNDER_LEN 8

typedef struct _RC4_SHA_HEADER {
    UCHAR Checksum[A_SHA_DIGEST_LEN];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA_HEADER, *PRC4_SHA_HEADER;
*/

static void rc4HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA_HEADER CryptHeader = (PRC4_SHA_HEADER) pbHeader;
    BYTE LocalKey[A_SHA_DIGEST_LEN];
    RC4_KEYSTRUCT Rc4KeyStruct;

    //
    // Create the header - the confounder & checksum
    //
    RtlZeroMemory( CryptHeader->Checksum, A_SHA_DIGEST_LEN );
    RtlCopyMemory( CryptHeader->Confounder, confounder, RC4_CONFOUNDER_LEN );

    //
    // Checksum everything but the checksum
    //
    shaHmac( pbKey, cbKey,
             CryptHeader->Confounder, RC4_CONFOUNDER_LEN,
             pbInput, cbInput,
             CryptHeader->Checksum );

    //
    // HMAC the checksum into the key
    //
    shaHmac( pbKey, cbKey,
             CryptHeader->Checksum, A_SHA_DIGEST_LEN,
             NULL, 0,
             LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    rc4_key( &Rc4KeyStruct, A_SHA_DIGEST_LEN, LocalKey );

    //
    // Encrypt everything but the checksum
    //
    rc4( &Rc4KeyStruct, RC4_CONFOUNDER_LEN, CryptHeader->Confounder );
    rc4( &Rc4KeyStruct, cbInput, pbInput );
}

static BOOL rc4HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA_HEADER CryptHeader = (PRC4_SHA_HEADER) pbHeader;
    RC4_SHA_HEADER TempHeader;
    BYTE Confounder[RC4_CONFOUNDER_LEN];
    BYTE LocalKey[A_SHA_DIGEST_LEN];
    RC4_KEYSTRUCT Rc4KeyStruct;

    RtlCopyMemory( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

    //
    // HMAC the checksum into the key
    //
    shaHmac( pbKey, cbKey,
             CryptHeader->Checksum, A_SHA_DIGEST_LEN,
             NULL, 0,
             LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    rc4_key( &Rc4KeyStruct, A_SHA_DIGEST_LEN, LocalKey );

    //
    // Decrypt confounder and data
    //
    rc4( &Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
    rc4( &Rc4KeyStruct, cbInput, pbInput );

    //
    // Now verify the checksum.
    //
    shaHmac( pbKey, cbKey,
             TempHeader.Confounder, RC4_CONFOUNDER_LEN,
             pbInput, cbInput,
             TempHeader.Checksum );

    //
    // Decrypt is successful only if checksum matches
    //
    return ( RtlEqualMemory(
                 TempHeader.Checksum,
                 CryptHeader->Checksum,
                 A_SHA_DIGEST_LEN) );
}

//
// Function the sanity check the CAB header
//
HRESULT VerifyCabHeader(
			PXONLINECONTENT_HEADER	pheader,
			PLARGE_INTEGER			pliFileSize
			)
{
	CFHEADER				*pcfheader;
	
	pcfheader = &pheader->cfheader;
	if (pcfheader->sig != sigCFHEADER)
	{
		printf("Invalid signature.\n");
		goto ErrorInvalidData;
	}

	if (pcfheader->version != verCF)
	{
		printf("Invalid CAB version.\n");
		goto ErrorInvalidData;
	}

	if (pliFileSize && (pcfheader->cbCabinet != pliFileSize->QuadPart))
	{
		printf("Invalid file size.\n");
		goto ErrorInvalidData;
	}

	if ((pcfheader->flags & cfhdrFLAGS_ALL) != cfhdrRESERVE_PRESENT)
	{
		printf("Invalid CAB flags.\n");
		goto ErrorInvalidData;
	}

	if (pcfheader->iCabinet != 0)
	{
		printf("iCabinet != 0.\n");
		goto ErrorInvalidData;
	}

	if (pheader->cfreserve.cbCFHeader != 
				 XONLINECONTENT_HEADER_RESERVE_SIZE)
	{
		printf("Invalid header reserve size.\n");
		goto ErrorInvalidData;
	}

	if (pheader->cfreserve.cbCFFolder != 
				 XONLINECONTENT_PERFOLDER_RESERVE_SIZE)
	{				 
		printf("Invalid per-folder reserve size.\n");
		goto ErrorInvalidData;
	}

	if (pcfheader->cFolders > XONLINECONTENT_MAX_CFFOLDER)
	{
		printf("Too many folders.\n");
		goto ErrorInvalidData;
	}
	
	return(S_OK);

ErrorInvalidData:
	return(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
}

//
// Function the sanity check the CFFOLDER records
//
HRESULT VerifyFolderEntries(
			PXONLINECONTENT_HEADER	pHeader,
			PCFFOLDER_HMAC			rgcffolderhmac
			)
{
	HRESULT	hr = S_OK;
	DWORD	i;

	for (i = 0; i < pHeader->cfheader.cFolders; i++)
	{
		if (rgcffolderhmac[i].cffolder.coffCabStart >= 
					(DWORD)(pHeader->cfheader.cbCabinet))
			return(ERROR_INVALID_DATA);
	}
	return(S_OK);
}

//
// Function to load a cabinet header
//
HRESULT LoadCabinetHeader(
			HANDLE					hFile,
			PXONLINECONTENT_HEADER	pheader
			)
{
	HRESULT					hr = S_OK;
	LARGE_INTEGER			liTemp;
	DWORD					cbData;

	// Read the CAB header
	liTemp.QuadPart = 0;
	if (!SetFilePointerEx(hFile, liTemp, NULL, FILE_BEGIN))
	{
		hr = GetLastError();
		printf("Cannot set file pointer %x.\n", hr);
		goto Error;
	}

	if (!ReadFile(hFile, pheader, XONLINECONTENT_FIXED_HEADER_SIZE, &cbData, NULL))
	{
		hr = GetLastError();
		printf("Read header failed with %x\n", hr);
		goto Error;
	}

	if (cbData != XONLINECONTENT_FIXED_HEADER_SIZE)
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		printf("Size mismatch.\n");
		goto Error;
	}

	if (!GetFileSizeEx(hFile, &liTemp))
	{
		hr = GetLastError();
		printf("GetFileSizeEx failed with %x\n", hr);
		goto Error;
	}

	// Validate the results
	hr = VerifyCabHeader(pheader, &liTemp);
	if (hr != S_OK)
		goto Error;

Error:
	return(hr);
}

//
// Function to sign the cabinet file header, and the signature will be verified
// with the supplied public key
//
HRESULT SignCabinetHeader(
			HANDLE		hFile,
			HCRYPTPROV	hCrypto,
			HCRYPTKEY	hKeyPublic
			)
{
	HRESULT					hr = S_OK;
	HCRYPTHASH				hHash = 0;
	BYTE					rgbSignature[2048];
	BYTE					rgbHeader[XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC];
	PBYTE					pbSignature = rgbSignature;
	LARGE_INTEGER			liTemp;
	DWORD					cbData;

	// Read the CAB header
	liTemp.QuadPart = 0;
	if (!SetFilePointerEx(hFile, liTemp, NULL, FILE_BEGIN))
	{
		hr = GetLastError();
		printf("Cannot set file pointer %x.\n", hr);
		goto Error;
	}

	if (!ReadFile(hFile, rgbHeader, 
				XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC, 
				&cbData, NULL))
	{
		hr = GetLastError();
		printf("Read header failed with %x\n", hr);
		goto Error;
	}

	if (cbData != XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC)
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		printf("Size mismatch.\n");
		goto Error;
	}

	// Create hash
	if (!CryptCreateHash(hCrypto, CALG_SHA1, 0, 0, &hHash))
	{
		hr = GetLastError();
		printf("Cannot create hash %x.\n", hr);
		goto Error;
	}

	if (!CryptHashData(hHash, rgbHeader, 
				XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC, 0))
	{
		hr = GetLastError();
		printf("Cannot hash data %x.\n", hr);
		goto Error;
	}

	// Get the hash size
	if (!CryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, NULL, &cbData))
	{
		hr = GetLastError();
		printf("Cannot sign hash %x.\n", hr);
		goto Error;
	}

	if (cbData > sizeof(rgbSignature))
	{
		// Allocate new buffer
		pbSignature = LocalAlloc(LMEM_FIXED, cbData);
		if (!pbSignature)
		{
			hr = E_OUTOFMEMORY;
			printf("Cannot allocate signing buffer %x.\n", hr);
			goto Error;
		}
	}

	// Sign the hash
	if (!CryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, pbSignature, &cbData))
	{
		hr = GetLastError();
		printf("Cannot sign hash %x.\n", hr);
		goto Error;
	}

	if (cbData != XONLINECONTENT_PK_SIGNATURE_SIZE)
	{
		hr = ERROR_INVALID_DATA;
		printf("Unexpected signature size (expected: %u, got %u)\n", 
					XONLINECONTENT_PK_SIGNATURE_SIZE, cbData);
		goto Error;
	}

	// Close the hash
	CryptDestroyHash(hHash);
	hHash = 0;

	//
	// Verify that the public key properly verifies the signature
	//

	// Create hash
	if (!CryptCreateHash(hCrypto, CALG_SHA1, 0, 0, &hHash))
	{
		hr = GetLastError();
		printf("Cannot create hash %x.\n", hr);
		goto Error;
	}

	if (!CryptHashData(hHash, rgbHeader, 
				XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC, 0))
	{
		hr = GetLastError();
		printf("Cannot hash data %x.\n", hr);
		goto Error;
	}

	// Verify the signature with the public key
	if (!CryptVerifySignature(hHash, pbSignature, cbData, hKeyPublic, NULL, 0))
	{
		hr = GetLastError();
		printf("Hash and signature do not match up %x.\n", hr);
		goto Error;
	}

	// Close the hash
	CryptDestroyHash(hHash);
	hHash = 0;
	
	// Write out the signature
	liTemp.QuadPart = XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC_AND_CHECKPOINT;
	if (!SetFilePointerEx(hFile, liTemp, NULL, FILE_BEGIN))
	{
		hr = GetLastError();
		printf("Cannot set file pointer %x.\n", hr);
		goto Error;
	}

	if (!WriteFile(hFile, pbSignature, 
				XONLINECONTENT_PK_SIGNATURE_SIZE, &cbData, NULL) ||
		(cbData != XONLINECONTENT_PK_SIGNATURE_SIZE))
	{
		hr = GetLastError();
		printf("Cannot write header, %x.\n", hr);
		goto Error;
	}

Exit:
	if (hHash)
		CryptDestroyHash(hHash);

	return(hr);

Error:
	goto Exit;
}

#if 0
//
// Function to sign the cabinet file header using the DevKit private key, and the 
// signature will be verified with the DevKit public key
//
HRESULT SignCabinetHeaderDevKit(
			HANDLE		hFile
			)
{
	HRESULT					hr = S_OK;
	BYTE					rgbHash[XC_DIGEST_LEN];
	BYTE					rgbSignature[2048];
	BYTE					rgbWorkspace[2048];
	BYTE					rgbHeader[XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC];
	PBYTE					pbSignature = rgbSignature;
	LARGE_INTEGER			liTemp;
	DWORD					cbData;

	// Read the CAB header
	liTemp.QuadPart = 0;
	if (!SetFilePointerEx(hFile, liTemp, NULL, FILE_BEGIN))
	{
		hr = GetLastError();
		printf("Cannot set file pointer %x.\n", hr);
		goto Error;
	}

	if (!ReadFile(hFile, rgbHeader, 
				XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC, 
				&cbData, NULL))
	{
		hr = GetLastError();
		printf("Read header failed with %x\n", hr);
		goto Error;
	}

	if (cbData != XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC)
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		printf("Size mismatch.\n");
		goto Error;
	}

	// Sign the digest
	XCCalcDigest(rgbHeader, 
				XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC, rgbHash);
	XCSignDigest(rgbHash, ImgbPrivateKeyData, rgbSignature);				

	//
	// Verify that the public key properly verifies the signature
	//
	if (!XCVerifyDigest(rgbSignature, ImgbPublicKeyData, 
				rgbWorkspace, rgbHash))
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		printf("Failed to verify signed digest.\n");
		goto Error;
	}

	// Write out the signature
	liTemp.QuadPart = XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC_AND_CHECKPOINT;
	if (!SetFilePointerEx(hFile, liTemp, NULL, FILE_BEGIN))
	{
		hr = GetLastError();
		printf("Cannot set file pointer %x.\n", hr);
		goto Error;
	}

	if (!WriteFile(hFile, pbSignature, 
				XONLINECONTENT_PK_SIGNATURE_SIZE, &cbData, NULL) ||
		(cbData != XONLINECONTENT_PK_SIGNATURE_SIZE))
	{
		hr = GetLastError();
		printf("Cannot write header, %x.\n", hr);
		goto Error;
	}

Exit:
	return(hr);

Error:
	goto Exit;
}

#endif

//
// Function to verify encrypted data and compare it with original
//
BOOL VerifyEncryptedData(
			PBYTE				pbSymmetricKey,
			DWORD				cbSymmetricKey,
			PBYTE				pbEncrypted,
			PBYTE				pbReference,
			DWORD				cbData,
			PRC4_SHA_HEADER	pheader
			)
{
	if (!rc4HmacDecrypt(pbSymmetricKey, cbSymmetricKey,
				pbEncrypted, cbData, (PUCHAR)pheader))
		return(FALSE);

	if (memcmp(pbEncrypted, pbReference, cbData) != 0)
		return(FALSE);
	return(TRUE);
}

//
// Generic function to load a block from disk, encrypt, and write
// back to disk
//
HRESULT EncryptDiskBlock(
			HANDLE				hFile,
			HCRYPTPROV			hCrypto,
			DWORD				dwOffset,
			PBYTE				pbData,
			DWORD				cbData,
			PBYTE				pbSymmetricKey,
			DWORD				cbSymmetricKey,
			PBYTE				pbReference,
			PRC4_SHA_HEADER		pheader
			)
{
	HRESULT					hr = S_OK;
	BYTE					rgbConfounder[RC4_CONFOUNDER_LEN];
	RC4_SHA_HEADER			rc4sha1Header;
	LARGE_INTEGER			liTemp;
	DWORD					cbDone;

	// Now load the data
	liTemp.QuadPart = dwOffset;
	if (!SetFilePointerEx(hFile, liTemp, NULL, FILE_BEGIN))
	{
		hr = GetLastError();
		printf("Cannot set file pointer %x.\n", hr);
		goto Error;
	}

	if (!ReadFile(hFile, pbData, cbData, &cbDone, NULL) ||
		(cbData != cbDone))
	{
		hr = GetLastError();
		printf("Cannot read data, %x.\n", hr);
		goto Error;
	}

	// Save a copy in the reference buffer
	if (pbReference)
		CopyMemory(pbReference, pbData, cbData);

	// Encrypt the data
	GenerateConfounder(hCrypto, rgbConfounder);
	rc4HmacEncrypt(
				rgbConfounder, 
				pbSymmetricKey,
				cbSymmetricKey,
				pbData, 
				cbData,
				(PBYTE)&rc4sha1Header);

	// Store the Hmac checksum in the header
	CopyMemory(pheader, &rc4sha1Header, sizeof(RC4_SHA_HEADER));

	// Write out the encrypted data
	if (!SetFilePointerEx(hFile, liTemp, NULL, FILE_BEGIN))
	{
		hr = GetLastError();
		printf("Cannot set file pointer %x.\n", hr);
		goto Error;
	}

	if (!WriteFile(hFile, pbData, cbData, &cbDone, NULL) ||
		(cbDone != cbData))
	{
		hr = GetLastError();
		printf("Cannot write data, %x.\n", hr);
		goto Error;
	}

	// Verify that the data decrypts back to the onriginal
	if (pbReference)
	{
		if (!VerifyEncryptedData(pbSymmetricKey, cbSymmetricKey,
					pbData, pbReference, cbData, &rc4sha1Header))
		{
			hr = ERROR_INVALID_DATA;
			printf("Decrypted and original don't match, %x.\n", hr);
			goto Error;
		}
	}

Exit:
	return(hr);

Error:
	goto Exit;
}			

//
// Function to encrypt a Xbox content cabinet file using the specified
// symmetric key.
//
// The cabinet file must be created in the correct Xbox content format
// with apporpriate space reservations for hashes and signatures.
//
HRESULT EncryptCabinetBody(
			HANDLE		hFile,
			HCRYPTPROV	hCrypto,
			PBYTE		pbSymmetricKey,
			DWORD		cbSymmetricKey
			)
{
	HRESULT					hr;
	XONLINECONTENT_HEADER	header;
	CFFOLDER_HMAC			rgcffolderhmac[XONLINECONTENT_MAX_CFFOLDER];
	DWORD					cbSize[XONLINECONTENT_MAX_CFFOLDER];
	BYTE					rgbConfounder[RC4_CONFOUNDER_LEN];
	RC4_SHA_HEADER			rc4sha1Header;
	LARGE_INTEGER			liTemp;
	PBYTE					pbData = NULL;
	PBYTE					pbReference = NULL;
	DWORD					cbData;
	DWORD					cbMaxChunk;
	DWORD					cFolders;
	DWORD					i;

	// Read the CAB header
	liTemp.QuadPart = 0;
	if (!SetFilePointerEx(hFile, liTemp, NULL, FILE_BEGIN))
	{
		hr = GetLastError();
		printf("Cannot set file pointer %x.\n", hr);
		goto Error;
	}

	if (!ReadFile(hFile, &header, sizeof(XONLINECONTENT_HEADER), &cbData, NULL))
	{
		hr = GetLastError();
		printf("Read header failed with %x\n", hr);
		goto Error;
	}

	if (cbData != sizeof(XONLINECONTENT_HEADER))
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		printf("Size mismatch.\n");
		goto Error;
	}

	if (!GetFileSizeEx(hFile, &liTemp))
	{
		hr = GetLastError();
		printf("GetFileSizeEx failed with %x\n", hr);
		goto Error;
	}

	// Validate the results
	hr = VerifyCabHeader(&header, &liTemp);
	if (hr != S_OK)
		goto Error;

	// Now read the CFFOLDER_HMAC entries
	liTemp.QuadPart = XONLINECONTENT_COMPLETE_HEADER_SIZE;
	if (!SetFilePointerEx(hFile, liTemp, NULL, FILE_BEGIN))
	{
		hr = GetLastError();
		printf("Cannot set file pointer %x.\n", hr);
		goto Error;
	}

	if (!ReadFile(hFile, rgcffolderhmac, 
				(sizeof(CFFOLDER_HMAC) * header.cfheader.cFolders),
				&cbData, NULL))
	{
		hr = GetLastError();
		printf("Cannot read CFFOLDER entries %x.\n", hr);
		goto Error;
	}

	// Find the largest chunk we will have to encrypt
	cFolders = header.cfheader.cFolders;
	cbMaxChunk = rgcffolderhmac[0].cffolder.coffCabStart - 
					header.cfheader.coffFiles;
	if ((sizeof(CFFOLDER_HMAC) * cFolders) > cbMaxChunk)
		cbMaxChunk = sizeof(CFFOLDER_HMAC) * cFolders;

	for (i = 0; i < cFolders; i++)
	{
		if (i == (cFolders - 1))
			cbSize[i] = header.cfheader.cbCabinet;
		else
			cbSize[i] = rgcffolderhmac[i + 1].cffolder.coffCabStart;

		cbSize[i] -= rgcffolderhmac[i].cffolder.coffCabStart;

		if (cbSize[i] > cbMaxChunk)
			cbMaxChunk = cbSize[i];
	}

	// Allocate the buffer
	pbData = LocalAlloc(LMEM_FIXED, cbMaxChunk);
	if (!pbData)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		printf("Cannot allocate memory %x.\n", hr);
		goto Error;
	}

	pbReference = LocalAlloc(LMEM_FIXED, cbMaxChunk);
	if (!pbReference)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		printf("Cannot allocate memory %x.\n", hr);
		goto Error;
	}

	// Encrypt all the blocks
	for (i = 0; i < cFolders; i++)
	{
		hr = EncryptDiskBlock(hFile, 
					hCrypto,
					rgcffolderhmac[i].cffolder.coffCabStart,
					pbData,
					cbSize[i],
					pbSymmetricKey,
					cbSymmetricKey,
					pbReference,
					&(rgcffolderhmac[i].hmac));
		if (hr != S_OK)
		{
			printf("Cannot encrypt folder %u data %x.\n", i, hr);
			goto Error;
		}
	}

	cbSize[0] = rgcffolderhmac[0].cffolder.coffCabStart - 
					header.cfheader.coffFiles;
	hr = EncryptDiskBlock(hFile, 
				hCrypto,
				header.cfheader.coffFiles,
				pbData,
				cbSize[0],
				pbSymmetricKey,
				cbSymmetricKey,
				pbReference,
				&(header.digestFiles));
	if (hr != S_OK)
	{
		printf("Cannot encrypt CFFILE entries %x.\n", hr);
		goto Error;
	}

	// Save a copy in the reference buffer
	cbData = sizeof(CFFOLDER_HMAC) * cFolders;
	CopyMemory(pbReference, rgcffolderhmac, cbData);

	// OK, now we encrypt the CFFOLDER entries
	GenerateConfounder(hCrypto, rgbConfounder);
	rc4HmacEncrypt(
				rgbConfounder, 
				pbSymmetricKey,
				cbSymmetricKey,
				(PBYTE)rgcffolderhmac, 
				cbData,
				(PBYTE)&rc4sha1Header);

	// Store the Hmac checksum in the header
	CopyMemory(&(header.digestFolders), 
				&rc4sha1Header, sizeof(RC4_SHA_HEADER));
				
	// Write out the encrypted CFFOLDER entries
	liTemp.QuadPart = XONLINECONTENT_COMPLETE_HEADER_SIZE;
	if (!SetFilePointerEx(hFile, liTemp, NULL, FILE_BEGIN))
	{
		hr = GetLastError();
		printf("Cannot set file pointer %x.\n", hr);
		goto Error;
	}

	cbSize[0] = cbData;
	if (!WriteFile(hFile, rgcffolderhmac, cbSize[0], &cbData, NULL) ||
		(cbSize[0] != cbData))
	{
		hr = GetLastError();
		printf("Cannot write CFFOLDER entries, %x.\n", hr);
		goto Error;
	}

	// Verify that the data decrypts back to the onriginal
	if (!VerifyEncryptedData(pbSymmetricKey, cbSymmetricKey,
				(PBYTE)rgcffolderhmac, pbReference, cbData, &rc4sha1Header))
	{
		hr = ERROR_INVALID_DATA;
		printf("Decrypted and original don't match, %x.\n", hr);
		goto Error;
	}

	// Write out the updated header with the new hashes
	liTemp.QuadPart = 0;
	if (!SetFilePointerEx(hFile, liTemp, NULL, FILE_BEGIN))
	{
		hr = GetLastError();
		printf("Cannot set file pointer %x.\n", hr);
		goto Error;
	}

	if (!WriteFile(hFile, &header, 
				XONLINECONTENT_FIXED_HEADER_SIZE, &cbData, NULL) ||
		(cbData != XONLINECONTENT_FIXED_HEADER_SIZE))
	{
		hr = GetLastError();
		printf("Cannot write header, %x.\n", hr);
		goto Error;
	}

Exit:
	if (pbData)
		LocalFree(pbData);
	if (pbReference)
		LocalFree(pbReference);

	return(hr);

Error:
	goto Exit;
}

//
// Function to encrypt the header portion of the CAB file. This should
// be the last step following placing the digital signature in the slot
//
HRESULT EncryptCabinetHeader(
			HANDLE		hFile,
			HCRYPTPROV	hCrypto,
			PBYTE		pbSymmetricKey,
			DWORD		cbSymmetricKey
			)
{
	HRESULT					hr = S_OK;
	BYTE					rgbReference[XONLINECONTENT_FIXED_HEADER_SIZE];
	BYTE					rgbConfounder[RC4_CONFOUNDER_LEN];
	XONLINECONTENT_HEADER	header;
	LARGE_INTEGER			liTemp;
	RC4_SHA_HEADER			rc4sha1Header;
	DWORD					dwCheckpoint = 0;
	DWORD					cbData;

	// Read the CAB header
	hr = LoadCabinetHeader(hFile, &header);
	if (hr != S_OK)
	{
		printf("Cannot load cabinet header %x.\n", hr);
		goto Error;
	}

	// Save a copy in the reference buffer
	CopyMemory(rgbReference, &header, XONLINECONTENT_FIXED_HEADER_SIZE);

	// OK, now we encrypt the CFFOLDER entries
	GenerateConfounder(hCrypto, rgbConfounder);
	rc4HmacEncrypt(
				rgbConfounder, 
				pbSymmetricKey,
				cbSymmetricKey,
				(PBYTE)&header,
				XONLINECONTENT_FIXED_HEADER_SIZE,
				(PBYTE)&rc4sha1Header);

	// Write out the encrypted header
	liTemp.QuadPart = 0;
	if (!SetFilePointerEx(hFile, liTemp, NULL, FILE_BEGIN))
	{
		hr = GetLastError();
		printf("Cannot set file pointer %x.\n", hr);
		goto Error;
	}

	if (!WriteFile(hFile, &header, 
				XONLINECONTENT_FIXED_HEADER_SIZE, &cbData, NULL) ||
		(cbData != XONLINECONTENT_FIXED_HEADER_SIZE))
	{
		hr = GetLastError();
		printf("Cannot write header, %x.\n", hr);
		goto Error;
	}

	// Write out the final HMAC
	if (!WriteFile(hFile, &rc4sha1Header, 
				sizeof(RC4_SHA_HEADER), &cbData, NULL) ||
		(cbData != sizeof(RC4_SHA_HEADER)))
	{
		hr = GetLastError();
		printf("Cannot write header HMAC, %x.\n", hr);
		goto Error;
	}

	// Generate some confounding bytes as the checkpoint
	GenerateRandomBytes(hCrypto, (PBYTE)&dwCheckpoint, sizeof(DWORD));

	// Write out the checkpoint
	if (!WriteFile(hFile, &dwCheckpoint, 
				sizeof(DWORD), &cbData, NULL) ||
		(cbData != sizeof(DWORD)))
	{
		hr = GetLastError();
		printf("Cannot write checkpoint, %x.\n", hr);
		goto Error;
	}

	// Verify that the data decrypts back to the onriginal
	if (!VerifyEncryptedData(pbSymmetricKey, cbSymmetricKey,
				(PBYTE)&header, rgbReference, 
				XONLINECONTENT_FIXED_HEADER_SIZE, &rc4sha1Header))
	{
		hr = ERROR_INVALID_DATA;
		printf("Decrypted and original don't match, %x.\n", hr);
		goto Error;
	}

Exit:
	return(hr);

Error:
	goto Exit;
}

//
// Generic function to load a block from disk, decrypt, and write
// back to disk
//
HRESULT DecryptDiskBlock(
			HANDLE				hFile,
			HCRYPTPROV			hCrypto,
			DWORD				dwOffset,
			PBYTE				pbData,
			DWORD				cbData,
			PBYTE				pbSymmetricKey,
			DWORD				cbSymmetricKey,
			PRC4_SHA_HEADER		pVerifyHeader
			)
{
	HRESULT					hr = S_OK;
	LARGE_INTEGER			liTemp;
	DWORD					cbDone;

	// Now load the data
	liTemp.QuadPart = dwOffset;
	if (!SetFilePointerEx(hFile, liTemp, NULL, FILE_BEGIN))
	{
		hr = GetLastError();
		printf("Cannot set file pointer %x.\n", hr);
		goto Error;
	}

	if (!ReadFile(hFile, pbData, cbData, &cbData, NULL))
	{
		hr = GetLastError();
		printf("Cannot read data, %x.\n", hr);
		goto Error;
	}

	// Decrypt the data
	if (!rc4HmacDecrypt(
				pbSymmetricKey,
				cbSymmetricKey,
				pbData, 
				cbData,
				(PBYTE)pVerifyHeader))
	{
		hr = ERROR_INVALID_DATA;
		printf("Decrypted data does not match HMAC\n");
		goto Error;
	}

	// Write out the decrypted data
	if (!SetFilePointerEx(hFile, liTemp, NULL, FILE_BEGIN))
	{
		hr = GetLastError();
		printf("Cannot set file pointer %x.\n", hr);
		goto Error;
	}

	if (!WriteFile(hFile, pbData, cbData, &cbDone, NULL))
	{
		hr = GetLastError();
		printf("Cannot write data, %x.\n", hr);
		goto Error;
	}
	if (cbDone != cbData)
	{
		hr = ERROR_WRITE_FAULT;
		goto Error;
	}

Exit:
	return(hr);

Error:
	goto Exit;
}			
//
// Function to decrypt the header portion of the package file. The
// symmetric key provided should be the key retrieved from the signature
// slot of the same package. The decryption is done in-place.
//
HRESULT DecryptPackageHeader(
			HANDLE		hFile,
			HCRYPTPROV	hCrypto,
			PBYTE		pbSymmetricKey,
			DWORD		cbSymmetricKey,
			PXONLINECONTENT_HEADER	pHeader
			)
{
	HRESULT					hr = S_OK;
	BYTE					rgbHeader[XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC];
	PXONLINECONTENT_HEADER	pCabHeader;
	PRC4_SHA_HEADER			pRc4Header;
	LARGE_INTEGER			liTemp;
	DWORD					cbData;

	// Read the encrypted package header
	liTemp.QuadPart = 0;
	if (!SetFilePointerEx(hFile, liTemp, &liTemp, FILE_BEGIN))
	{
		hr = GetLastError();
		goto Error;
	}

	if (!ReadFile(hFile, rgbHeader, 
				XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC,
				&cbData, NULL))
	{
		hr = GetLastError();
		goto Error;
	}
	if (cbData != XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC)
	{
		hr = ERROR_READ_FAULT;
		goto Error;
	}

	// Overlay the data structures
	pCabHeader = (PXONLINECONTENT_HEADER)rgbHeader;
	pRc4Header = (PRC4_SHA_HEADER)(pCabHeader + 1);

	// Decrypt
	if (!rc4HmacDecrypt(
				pbSymmetricKey,
				cbSymmetricKey,
				rgbHeader,
				XONLINECONTENT_FIXED_HEADER_SIZE,
				(PBYTE)pRc4Header))
	{
		// Dont match, this is an error
		hr = ERROR_INVALID_DATA;
		goto Error;
	}

	// Write out the decrypted package header (and zero out the
	// HMAC slot)
	liTemp.QuadPart = 0;
	if (!SetFilePointerEx(hFile, liTemp, &liTemp, FILE_BEGIN))
	{
		hr = GetLastError();
		goto Error;
	}

	ZeroMemory(rgbHeader + XONLINECONTENT_FIXED_HEADER_SIZE, 
				sizeof(RC4_SHA_HEADER));
	if (!WriteFile(hFile, rgbHeader, 
				XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC,
				&cbData, NULL))
	{
		hr = GetLastError();
		goto Error;
	}
	if (cbData != XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC)
	{
		hr = ERROR_WRITE_FAULT;
		goto Error;
	}

	// That's it, copy the header out
	memcpy(pHeader, pCabHeader, sizeof(XONLINECONTENT_HEADER));

Exit:
	return(hr);

Error:
	goto Exit;
}

//
// Function to Decrypt a Xbox content package body using the specified
// symmetric key. Decryption is done in-place
//
HRESULT DecryptPackageBody(
			HANDLE					hFile,
			HCRYPTPROV				hCrypto,
			PXONLINECONTENT_HEADER	pHeader,
			PBYTE					pbSymmetricKey,
			DWORD					cbSymmetricKey
			)
{
	HRESULT					hr;
	CFFOLDER_HMAC			rgcffolderhmac[XONLINECONTENT_MAX_CFFOLDER];
	DWORD					cbSize[XONLINECONTENT_MAX_CFFOLDER];
	LARGE_INTEGER			liTemp;
	PBYTE					pbData = NULL;
	DWORD					cbData;
	DWORD					cbMaxChunk;
	DWORD					cFolders;
	DWORD					i;

	if (!GetFileSizeEx(hFile, &liTemp))
	{
		hr = GetLastError();
		printf("GetFileSizeEx failed with %x\n", hr);
		goto Error;
	}

	// Validate the results
	hr = VerifyCabHeader(pHeader, &liTemp);
	if (hr != S_OK)
		goto Error;

	// Now read the CFFOLDER_HMAC entries
	liTemp.QuadPart = XONLINECONTENT_COMPLETE_HEADER_SIZE;
	if (!SetFilePointerEx(hFile, liTemp, NULL, FILE_BEGIN))
	{
		hr = GetLastError();
		printf("Cannot set file pointer %x.\n", hr);
		goto Error;
	}
	cbSize[0] = sizeof(CFFOLDER_HMAC) * pHeader->cfheader.cFolders;
	if (!ReadFile(hFile, rgcffolderhmac, cbSize[0], &cbData, NULL))
	{
		hr = GetLastError();
		printf("Cannot read CFFOLDER entries %x.\n", hr);
		goto Error;
	}
	if (cbSize[0] != cbData)
	{
		hr = ERROR_READ_FAULT;
		goto Error;
	}

	// OK, now we decrypt the CFFOLDER entries
	if (!rc4HmacDecrypt(
				pbSymmetricKey,
				cbSymmetricKey,
				(PBYTE)rgcffolderhmac, 
				cbData,
				(PBYTE)&pHeader->digestFolders))
	{
		hr = ERROR_INVALID_DATA;
		printf("CFFOLDER entries HMAC mismatch %x.\n", hr);
		goto Error;
	}

	// Verify that the folder entries make sense
	hr = VerifyFolderEntries(pHeader, rgcffolderhmac);
	if (hr != S_OK)
	{
		printf("Invalid CFFOLDER entries.\n");
		goto Error;
	}
				
	// Write out the decrypted CFFOLDER entries
	liTemp.QuadPart = XONLINECONTENT_COMPLETE_HEADER_SIZE;
	if (!SetFilePointerEx(hFile, liTemp, NULL, FILE_BEGIN))
	{
		hr = GetLastError();
		printf("Cannot set file pointer %x.\n", hr);
		goto Error;
	}

	i = cbData;
	if (!WriteFile(hFile, rgcffolderhmac, i, &cbData, NULL))
	{
		hr = GetLastError();
		printf("Cannot write CFFOLDER entries, %x.\n", hr);
		goto Error;
	}
	if (i != cbData)
	{
		hr = ERROR_WRITE_FAULT;
		goto Error;
	}

	// Find the largest chunk we will have to decrypt
	cFolders = pHeader->cfheader.cFolders;
	cbMaxChunk = rgcffolderhmac[0].cffolder.coffCabStart - 
					pHeader->cfheader.coffFiles;

	for (i = 0; i < cFolders; i++)
	{
		if (i == (cFolders - 1))
			cbSize[i] = pHeader->cfheader.cbCabinet;
		else
			cbSize[i] = rgcffolderhmac[i + 1].cffolder.coffCabStart;

		cbSize[i] -= rgcffolderhmac[i].cffolder.coffCabStart;

		if (cbSize[i] > cbMaxChunk)
			cbMaxChunk = cbSize[i];
	}

	// Allocate the buffer
	pbData = LocalAlloc(LMEM_FIXED, cbMaxChunk);
	if (!pbData)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		printf("Cannot allocate memory %x.\n", hr);
		goto Error;
	}

	// Now decrypt the CFFILE entries
	i = rgcffolderhmac[0].cffolder.coffCabStart - 
					pHeader->cfheader.coffFiles;
	hr = DecryptDiskBlock(hFile, 
				hCrypto,
				pHeader->cfheader.coffFiles,
				pbData,
				i,
				pbSymmetricKey,
				cbSymmetricKey,
				&(pHeader->digestFiles));
	if (hr != S_OK)
	{
		printf("Cannot decrypt CFFILE entries %x.\n", hr);
		goto Error;
	}

	// Encrypt all the blocks
	for (i = 0; i < cFolders; i++)
	{
		hr = DecryptDiskBlock(hFile, 
					hCrypto,
					rgcffolderhmac[i].cffolder.coffCabStart,
					pbData,
					cbSize[i],
					pbSymmetricKey,
					cbSymmetricKey,
					&(rgcffolderhmac[i].hmac));
		if (hr != S_OK)
		{
			printf("Cannot decrypt folder %u data %x.\n", i, hr);
			goto Error;
		}
	}

Exit:
	if (pbData)
		LocalFree(pbData);

	return(hr);

Error:
	goto Exit;
}

//
// Function to encrypt a symmetric key with a supplied public key and place
// the encrypted contents into the signature slot of the package
//
HRESULT EncloseSymmetricKey(
			HANDLE		hFile,
			HCRYPTKEY	hKeyPublic,
			BYTE		*pbSymmetricKey,
			DWORD		cbSymmetricKey
			)
{
	HRESULT			hr = S_OK;
	BYTE			rgbSignature[XONLINECONTENT_PK_SIGNATURE_SIZE];
	DWORD			cbData;
	LARGE_INTEGER	liTemp;

	// Encrypt key
	cbData = cbSymmetricKey;
	memcpy(rgbSignature, pbSymmetricKey, cbData);
	if (!CryptEncrypt(hKeyPublic, 0, TRUE, 0, 
				rgbSignature, &cbData, XONLINECONTENT_PK_SIGNATURE_SIZE))
	{
		hr = GetLastError();
		goto Error;
	}

	// Write out the encrypted key
	liTemp.QuadPart = XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC_AND_CHECKPOINT;
	if (!SetFilePointerEx(hFile, liTemp, NULL, FILE_BEGIN))
	{
		hr = GetLastError();
		goto Error;
	}

	if (!WriteFile(hFile, rgbSignature,
				XONLINECONTENT_PK_SIGNATURE_SIZE, &cbData, NULL) ||
		(cbData != XONLINECONTENT_PK_SIGNATURE_SIZE))
	{
		hr = GetLastError();
		goto Error;
	}

Exit:
	return(hr);

Error:
	goto Exit;
}

//
// Function to retrieve a symmetric key previously encrypted with a
// public key, whose corresponding private key is supplied.
//
HRESULT RetrieveSymmetricKey(
			HANDLE		hFile,
			HCRYPTKEY	hKeyPrivate,
			BYTE		*pbSymmetricKey,
			DWORD		cbSymmetricKey
			)
{
	HRESULT			hr = S_OK;
	BYTE			rgbSignature[XONLINECONTENT_PK_SIGNATURE_SIZE];
	DWORD			cbData;
	LARGE_INTEGER	liTemp;

	// Read the encrypted key
	liTemp.QuadPart = XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC_AND_CHECKPOINT;
	if (!SetFilePointerEx(hFile, liTemp, NULL, FILE_BEGIN))
	{
		hr = GetLastError();
		goto Error;
	}

	if (!ReadFile(hFile, rgbSignature,
				XONLINECONTENT_PK_SIGNATURE_SIZE, &cbData, NULL))
	{
		hr = GetLastError();
		goto Error;
	}
	if (cbData != XONLINECONTENT_PK_SIGNATURE_SIZE)
	{
		hr = ERROR_READ_FAULT;
		goto Error;
	}

	// Decrypt key
	cbData = XONLINECONTENT_PK_SIGNATURE_SIZE;
	if (!CryptDecrypt(hKeyPrivate, 0, TRUE, 0, 
				rgbSignature, &cbData))
	{
		hr = GetLastError();
		goto Error;
	}

	// Make sure size is correct
	if (cbData != cbSymmetricKey)
	{
		hr = ERROR_INVALID_DATA;
		goto Error;
	}

	// Copy the data over
	memcpy(pbSymmetricKey, rgbSignature, cbSymmetricKey);

	// Zero out the signature slot for good measure
	liTemp.QuadPart = XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC_AND_CHECKPOINT;
	if (!SetFilePointerEx(hFile, liTemp, NULL, FILE_BEGIN))
	{
		hr = GetLastError();
		goto Error;
	}

	ZeroMemory(rgbSignature, XONLINECONTENT_PK_SIGNATURE_SIZE);
	if (!WriteFile(hFile, rgbSignature,
				XONLINECONTENT_PK_SIGNATURE_SIZE, &cbData, NULL))
	{
		hr = GetLastError();
		goto Error;
	}
	if (cbData != XONLINECONTENT_PK_SIGNATURE_SIZE)
	{
		hr = ERROR_WRITE_FAULT;
		goto Error;
	}

Exit:
	return(hr);

Error:
	goto Exit;
}

//
// Function to append a file (by name) to the end of an open file (by handle).
// The appended contents can be optionally encrypted if a symmetric key is provided
//
HRESULT AppendEncryptedFile(
			HANDLE				hFile,
			CHAR				*szFileToAppend,
			HCRYPTPROV			hCrypto,
			PBYTE				pbSymmetricKey,
			DWORD				cbSymmetricKey
			)
{
	HRESULT			hr = S_OK;
	LARGE_INTEGER	liSize;
	LARGE_INTEGER	liOffset;
	HANDLE			hAppend = INVALID_HANDLE_VALUE;
	PBYTE			pbBuffer = NULL;
	DWORD			cbSize;
	BYTE			rgbConfounder[RC4_CONFOUNDER_LEN];
	RC4_SHA_HEADER	Header;

	// Seek to the end of file
	if (!GetFileSizeEx(hFile, &liOffset))
		goto Error;

	// Save some space for the encrypted header if the symmetric key
	// is provided
	if (pbSymmetricKey)
	{
		liOffset.QuadPart += sizeof(RC4_SHA_HEADER);
	}
	if (!SetFilePointerEx(hFile, liOffset, &liOffset, FILE_BEGIN))
		goto Error;

	// Open the file to append
	hAppend = CreateFile(
				szFileToAppend,
				GENERIC_READ, 
				FILE_SHARE_READ, 
				NULL, 
				OPEN_EXISTING, 
				FILE_ATTRIBUTE_NORMAL, 
				NULL);
	if (hAppend == INVALID_HANDLE_VALUE)
		goto Error;

	if (!GetFileSizeEx(hAppend, &liSize))
		goto Error;

	// Allocate a buffer large enough for the entire file
	pbBuffer = (PBYTE)LocalAlloc(0, liSize.u.LowPart);
	if (!pbBuffer)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		goto Error;
	}

	// Do a copy
	if (!ReadFile(hAppend, pbBuffer, liSize.u.LowPart, &cbSize, NULL))
		goto Error;

	// Let's see if we need to encrypt the file as well ...
	if (pbSymmetricKey)
	{
		// Encrypt the CFFILE entries
		GenerateConfounder(hCrypto, rgbConfounder);
		rc4HmacEncrypt(
					rgbConfounder, 
					pbSymmetricKey,
					cbSymmetricKey,
					pbBuffer, 
					cbSize,
					(PBYTE)&Header);
	}
	
	if (cbSize != liSize.u.LowPart)
	{
		SetLastError(ERROR_INVALID_DATA);
		goto Error;
	}
		
	if (!WriteFile(hFile, pbBuffer, cbSize, &cbSize, NULL))
		goto Error;

	// Write out the encryption header if necessary
	if (pbSymmetricKey)
	{
		liOffset.QuadPart -= sizeof(RC4_SHA_HEADER);
		if (!SetFilePointerEx(hFile, liOffset, &liOffset, FILE_BEGIN))
			goto Error;

		if (!WriteFile(hFile, &Header, sizeof(RC4_SHA_HEADER), &cbSize, NULL))
			goto Error;

		if (cbSize != sizeof(RC4_SHA_HEADER))
		{
			SetLastError(ERROR_INVALID_DATA);
			goto Error;
		}
	}

Exit:
	if (pbBuffer)
		LocalFree(pbBuffer);
	if (hAppend != INVALID_HANDLE_VALUE)
		CloseHandle(hAppend);
	return(hr);

Error:
	hr = GetLastError();
	goto Exit;
}

//
// Function to detach a file form the end of a package that was previously appended
// using AppendEncryptedFile. The file will be saved in the specified file path,
// and its contents can be optionally decrypted if a symmetric key is provided.
//
// The package header is required to perform this operation.
//
// On success, the caller may optionally obtain a handle to the detached file, if
// this is the case, the caller is responsible for closing the obtained file handle
// when done.
//
HRESULT DetachEncryptedFile(
			HANDLE					hFile,
			CHAR					*szDestinationFile,
			PXONLINECONTENT_HEADER	pHeader,
			HCRYPTPROV				hCrypto,
			PBYTE					pbSymmetricKey,
			DWORD					cbSymmetricKey,
			HANDLE					*phDetachedFile
			)
{
	HRESULT			hr = S_OK;
	LARGE_INTEGER	liSize;
	LARGE_INTEGER	liOffset;
	HANDLE			hDetach = INVALID_HANDLE_VALUE;
	PBYTE			pbBuffer = NULL;
	DWORD			cbSize;
	DWORD			cbData;
	RC4_SHA_HEADER	Header;

	// Figure out the incision point and the size of the file
	if (!GetFileSizeEx(hFile, &liSize))
		goto Error;

	cbSize = pHeader->cfheader.cbCabinet;
	liOffset.QuadPart = cbSize;
	
	if (liSize.QuadPart <= liOffset.QuadPart)
	{
		SetLastError(ERROR_INVALID_DATA);
		goto Error;
	}
	cbSize = (DWORD)(liSize.QuadPart - liOffset.QuadPart);
	if (cbSize <= sizeof(Header))
	{
		SetLastError(ERROR_INVALID_DATA);
		goto Error;
	}

	// Set the file pointer to the starting position
	if (!SetFilePointerEx(hFile, liOffset, NULL, FILE_BEGIN))
		goto Error;

	// Read in the encrypted header if decryption is needed
	if (pbSymmetricKey)
	{
		if (!ReadFile(hFile, &Header, sizeof(Header), &cbData, NULL))
			goto Error;
		if (cbData != sizeof(Header))
		{
			SetLastError(ERROR_READ_FAULT);
			goto Error;
		}

		// Decrement the file size
		cbSize -= cbData;
	}

	// Open the file to detach into
	hDetach = CreateFile(
				szDestinationFile,
				GENERIC_READ | GENERIC_WRITE, 
				FILE_SHARE_READ, 
				NULL, 
				CREATE_ALWAYS, 
				FILE_ATTRIBUTE_NORMAL, 
				NULL);
	if (hDetach == INVALID_HANDLE_VALUE)
		goto Error;

	// Allocate a buffer large enough for the entire file
	pbBuffer = (PBYTE)LocalAlloc(0, cbSize);
	if (!pbBuffer)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		goto Error;
	}

	// Do a copy
	if (!ReadFile(hFile, pbBuffer, cbSize, &cbData, NULL))
		goto Error;
	if (cbData != cbSize)
	{
		SetLastError(ERROR_READ_FAULT);
		goto Error;
	}

	// Let's see if we need to decrypt the file as well ...
	if (pbSymmetricKey)
	{
		if (!rc4HmacDecrypt(
					pbSymmetricKey,
					cbSymmetricKey,
					pbBuffer, 
					cbSize,
					(PBYTE)&Header))
		{
			SetLastError(ERROR_INVALID_DATA);
			goto Error;
		}
	}

	// Write it out
	if (!WriteFile(hDetach, pbBuffer, cbSize, &cbData, NULL))
		goto Error;
	if (cbSize != cbData)
	{
		SetLastError(ERROR_WRITE_FAULT);
		goto Error;
	}

	// Chop off the original file
	if (!SetFilePointerEx(hFile, liOffset, NULL, FILE_BEGIN))
		goto Error;
	if (!SetEndOfFile(hFile))
		goto Error;

	// Return the handle if requested
	if (phDetachedFile)
	{
		*phDetachedFile = hDetach;
		hDetach = INVALID_HANDLE_VALUE;
	}

Exit:
	if (pbBuffer)
		LocalFree(pbBuffer);
	if (hDetach != INVALID_HANDLE_VALUE)
		CloseHandle(hDetach);
	return(hr);

Error:
	hr = GetLastError();
	goto Exit;
}

//
// Function to create a manifest file and save it to a file named
// XONLINECONTENT_MANIFEST_FILE_NAME. The manifest file will then 
// be signed using the current symmetric key. If this file exists, 
// this function will fail.
//
HRESULT CreateNewManifestFile(
			HCRYPTPROV	hCrypto,
			PBYTE		pbKey,
			CHAR		*szPath
			)
{
	HRESULT			hr = S_OK;
	HANDLE			hFile;
	char			rgbBuffer[450];
	DWORD			cbBuffer;
	DWORD			cbDone;

	hFile = CreateFile(
				szPath?szPath:XONLINECONTENT_MANIFEST_FILE_NAME, 
				GENERIC_READ | GENERIC_WRITE, 
				FILE_SHARE_READ, 
				NULL, 
				CREATE_NEW, 
				FILE_ATTRIBUTE_NORMAL, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hr = GetLastError();
		goto Exit;
	}

	// 
	// BUGBUG: Generate random junk for the manifest file for now
	// Fill in the rigt data once we define it
	//
	cbBuffer = sizeof(rgbBuffer);
	GenerateRandomBytes(hCrypto, 
				rgbBuffer + A_SHA_DIGEST_LEN, cbBuffer - A_SHA_DIGEST_LEN);

	// Do an HMAC using the supplied key over the random data, place the
	// HMAC signature at the beginning of the file
    shaHmac( pbKey, XONLINE_KEY_LENGTH,
             rgbBuffer + A_SHA_DIGEST_LEN, cbBuffer - A_SHA_DIGEST_LEN,
             NULL, 0,
             rgbBuffer );

	if (!WriteFile(hFile, rgbBuffer, cbBuffer, &cbDone, NULL) ||
		(cbBuffer != cbDone))
	{
		hr = GetLastError();
		goto Exit;
	}
					
Exit:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	return(hr);
}

//
// Function to convert a hex string to a ULONGLONG
//
HRESULT HexStringToUlonglong(
			PSTR		szHexValue,
			DWORD		cbHexValue,
			ULONGLONG	*pullValue
			)
{
	ULONGLONG	ull = 0;
	DWORD 		i, c, len;

	len = cbHexValue?cbHexValue:strlen(szHexValue);
	if (len <= 16)
	{
		for (i = 0; i < len; i++)
		{
			c = szHexValue[(len - 1) - i];
			if ((c >= '0') && (c <= '9'))
				c = c - '0';
			else if ((c >= 'a') && ( c <= 'f'))
				c = (c - 'a') + 10;
			else if ((c >= 'A') && ( c <= 'F'))
				c = (c - 'A') + 10;
			else
				goto Error;
				
			ull |= (c << (i * 4));
		}

		*pullValue = ull;
		return(S_OK);
	}

Error:	
	return(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
}

//
// Function to determine if a directory name is a valid title ID.
// If so, then the directory name will be converted to the Title ID 
// value. Otherwise, this function will return ERROR_INVALID_DATA.
//
HRESULT ConvertToTitleId(
			PSTR	szTitleId,
			DWORD	*pdwTitleId
			)
{
	HRESULT		hr;
	ULONGLONG	ull;
	hr = HexStringToUlonglong(szTitleId, 8, &ull);
	*pdwTitleId = (DWORD)ull;
	return(hr);
}

//
// Helper function to convert a symmetric key to a hex string
// representation
//
HRESULT ConvertSymmetricKeyToString(
			PBYTE		pbSymmetricKey,
			DWORD		cbSymmetricKey,
			CHAR		*szSymmetricKey,
			DWORD		*pcchSymmetricKey
			)
{
	if (cbSymmetricKey != XONLINE_KEY_LENGTH)
		return(ERROR_INVALID_DATA);
	if (((cbSymmetricKey * 2) + 3) > *pcchSymmetricKey)
	{
		*pcchSymmetricKey = (cbSymmetricKey * 2) + 3;
		return(ERROR_INSUFFICIENT_BUFFER);
	}

	*pcchSymmetricKey = sprintf(szSymmetricKey, 
				"0x%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X",
				pbSymmetricKey[0], pbSymmetricKey[1], pbSymmetricKey[2], pbSymmetricKey[3], 
				pbSymmetricKey[4], pbSymmetricKey[5], pbSymmetricKey[6], pbSymmetricKey[7], 
				pbSymmetricKey[8], pbSymmetricKey[9], pbSymmetricKey[10], pbSymmetricKey[11], 
				pbSymmetricKey[12], pbSymmetricKey[13], pbSymmetricKey[14], pbSymmetricKey[15]);
	return(S_OK);				
}

static BOOL xtob(
			CHAR	*szX,
			BYTE	*pb
			)
{
	DWORD	i;

	*pb = 0;
	for (i = 0; i < 2; i++)
	{
		if ((*szX >= '0') && (*szX <= '9'))
			*pb += (*szX - '0');
		else if ((*szX >= 'A') && (*szX <= 'F'))
			*pb += (*szX + 10 - 'A');
		else if ((*szX >= 'a') && (*szX <= 'f'))
			*pb += (*szX + 10 - 'a');
		else 
			return(FALSE);

		szX++;
		if (!i)
			(*pb) <<= 4;
	}

	return(TRUE);
}

//
// Helper function to convert a symmetric key from a hex string
// to its binary representation
//
HRESULT ConvertSymmetricKeyToBinary(
			CHAR		*szSymmetricKey,
			DWORD		cchSymmetricKey,
			PBYTE		pbSymmetricKey,
			DWORD		*pcbSymmetricKey
			)
{
	DWORD	i;

	if (cchSymmetricKey != (XONLINE_KEY_LENGTH * 2))
		return(ERROR_INVALID_DATA);
	if ((cchSymmetricKey / 2) > *pcbSymmetricKey)
	{
		*pcbSymmetricKey = cchSymmetricKey / 2;
		return(ERROR_INSUFFICIENT_BUFFER);
	}

	for (i = 0; i < XONLINE_KEY_LENGTH; i++)
	{
		if (!xtob(szSymmetricKey + (i*2), pbSymmetricKey + i))
			return(ERROR_INVALID_DATA);
	}

	*pcbSymmetricKey = i;
	return(S_OK);				
}

//
// Function to create a symmetric key and save it to a named file.
// If this file exists, this function will fail.
//
HRESULT ExportSymmetricKey(
			HCRYPTPROV	hCrypto,
			CHAR		*szFileName,
			PBYTE		pbSymmetricKey,
			DWORD		cbSymmetricKey
			)
{
	HRESULT			hr = S_OK;
	HANDLE			hFile;
	char			rgbBuffer[4096];
	DWORD			cbBuffer;
	DWORD			cbDone;

	if (cbSymmetricKey != XONLINE_KEY_LENGTH)
		return(ERROR_INVALID_DATA);

	hFile = CreateFile(
				szFileName, 
				GENERIC_READ | GENERIC_WRITE, 
				FILE_SHARE_READ, 
				NULL, 
				CREATE_ALWAYS, 
				FILE_ATTRIBUTE_NORMAL, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hr = GetLastError();
		goto Exit;
	}

	cbBuffer = sprintf(rgbBuffer, 
				"\n"\
				"// 0x%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X\n"\
				"\n"\
				"const unsigned char rgbSymmetricKey[] = {\n"\
				"\t0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X,\n"\
				"\t0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X\n"\
				"};\n"\
				"\n",
				pbSymmetricKey[0], pbSymmetricKey[1], pbSymmetricKey[2], pbSymmetricKey[3], 
				pbSymmetricKey[4], pbSymmetricKey[5], pbSymmetricKey[6], pbSymmetricKey[7], 
				pbSymmetricKey[8], pbSymmetricKey[9], pbSymmetricKey[10], pbSymmetricKey[11], 
				pbSymmetricKey[12], pbSymmetricKey[13], pbSymmetricKey[14], pbSymmetricKey[15],
				pbSymmetricKey[0], pbSymmetricKey[1], pbSymmetricKey[2], pbSymmetricKey[3], 
				pbSymmetricKey[4], pbSymmetricKey[5], pbSymmetricKey[6], pbSymmetricKey[7], 
				pbSymmetricKey[8], pbSymmetricKey[9], pbSymmetricKey[10], pbSymmetricKey[11], 
				pbSymmetricKey[12], pbSymmetricKey[13], pbSymmetricKey[14], pbSymmetricKey[15]);

	if (!WriteFile(hFile, rgbBuffer, cbBuffer, &cbDone, NULL) ||
		(cbBuffer != cbDone))
	{
		hr = GetLastError();
		goto Exit;
	}
					
Exit:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	return(hr);
}

//
// Function to import a symmetric key from the named file. 
// If this file does not exist or is malformed, this function 
// fails
//
HRESULT ImportSymmetricKey(
			CHAR	*szFileName,
			PBYTE	pbSymmetricKey,
			DWORD	cbSymmetricKey
			)
{
	HRESULT			hr = S_OK;
	HANDLE			hFile;
	char			rgbBuffer[1024];
	DWORD			cbDone;
	DWORD			cItems;

	hFile = CreateFile(
				szFileName, 
				GENERIC_READ, 
				FILE_SHARE_READ, 
				NULL, 
				OPEN_EXISTING, 
				FILE_ATTRIBUTE_NORMAL, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hr = GetLastError();
		goto Exit;
	}

	if (!ReadFile(hFile, rgbBuffer, sizeof(rgbBuffer), &cbDone, NULL))
	{
		hr = GetLastError();
		goto Exit;
	}

	// File should be small!
	if (cbDone >= sizeof(rgbBuffer))
	{
		hr = ERROR_INVALID_DATA;
		goto Exit;
	}

	rgbBuffer[cbDone] = '\0';

	cItems = sscanf(rgbBuffer, 	
				"\n"\
				"const unsigned char rgbSymmetricKey[] = {\n"\
				"\t%i, %i, %i, %i, %i, %i, %i, %i,\n"\
				"\t%i, %i, %i, %i, %i, %i, %i, %i\n"\
				"};\n",
				&pbSymmetricKey[0], &pbSymmetricKey[1], 
				&pbSymmetricKey[2], &pbSymmetricKey[3], 
				&pbSymmetricKey[4], &pbSymmetricKey[5], 
				&pbSymmetricKey[6], &pbSymmetricKey[7], 
				&pbSymmetricKey[8], &pbSymmetricKey[9], 
				&pbSymmetricKey[10], &pbSymmetricKey[11], 
				&pbSymmetricKey[12], &pbSymmetricKey[13], 
				&pbSymmetricKey[14], &pbSymmetricKey[15]);
	if (cItems != cbSymmetricKey)
	{
		hr = ERROR_INVALID_DATA;
		goto Exit;
	}

Exit:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	return(hr);
}

//
// Function to read key information from a binary file
//
HRESULT ReadPrivatePublicKeyFile(
			PSTR	szFilename,
			PBYTE	*ppbKey,
			DWORD	*pcbKey
			)
{
	HRESULT			hr = S_OK;
	HANDLE			hFile;
	char			rgbBuffer[1024];
	DWORD			cbDone;
	DWORD			cItems;
	LARGE_INTEGER	liFileSize;
	PBYTE			pbKey = NULL;

	hFile = CreateFile(
				szFilename, 
				GENERIC_READ, 
				FILE_SHARE_READ, 
				NULL, 
				OPEN_EXISTING, 
				FILE_ATTRIBUTE_NORMAL, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hr = GetLastError();
		goto Exit;
	}

	if (!GetFileSizeEx(hFile, &liFileSize))
	{
		hr = GetLastError();
		goto Exit;
	}

	pbKey = LocalAlloc(LMEM_FIXED, liFileSize.u.LowPart);
	if (!pbKey)
	{
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	if (!ReadFile(hFile, pbKey, liFileSize.u.LowPart, &cbDone, NULL))
	{
		hr = GetLastError();
		goto Exit;
	}

	if (liFileSize.u.LowPart != cbDone)
	{
		hr = ERROR_INVALID_DATA;
		goto Exit;
	}

	*pcbKey = cbDone;
	*ppbKey = pbKey;

Exit:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	if (hr != S_OK && pbKey)
		LocalFree(pbKey);

	return(hr);
}

//
// Munge a public key exported by Crypto into a format that
// can directly be used by XcVerifyPKCS1Signature (i.e. Xbox 
// client). The exported blob must not have a password.
//
// Note: the caller must LocalFree the munged key when done.
//
typedef struct
{
    BSAFE_PUB_KEY   pkheader;
    BYTE            rgbKey[1];

} PUBLIC_KEY_OVERLAY, *PPUBLIC_KEY_OVERLAY;

HRESULT MungePublicKey(
            PBYTE pbKey, 
            DWORD cbKey,
            PBYTE *ppbMungedKey, 
            DWORD *pcbMungedKey
            )
{
	PPUBLIC_KEY_OVERLAY ppkoOld, ppkoNew;
	DWORD               cbOriginal;
	DWORD			    cbTmpLen;

    *ppbMungedKey = NULL;
    *pcbMungedKey = 0;

    // Overlay the struct over theunmunged key
    ppkoOld = (PPUBLIC_KEY_OVERLAY)pbKey;

	// Fix up the munged data exported by the Crypto API
	ppkoOld->pkheader.magic = ppkoOld->pkheader.bitlen;
	ppkoOld->pkheader.bitlen = ppkoOld->pkheader.datalen;
	ppkoOld->pkheader.datalen = ((ppkoOld->pkheader.bitlen + 7) >> 3) - 1;
    
    // Make sure the size is correct
    cbOriginal = ppkoOld->pkheader.datalen;
    if ((cbOriginal + sizeof(BSAFE_PUB_KEY)) != cbKey)
        return(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

    // Calculate the new size
    cbTmpLen = (sizeof(DWORD) * 2) -
               (((ppkoOld->pkheader.bitlen + 7) / 8) % (sizeof(DWORD) * 2));
    if ((sizeof(DWORD) * 2) != cbTmpLen)
        cbTmpLen += sizeof(DWORD) * 2;
	
	ppkoOld->pkheader.keylen = 
	            (ppkoOld->pkheader.bitlen >> 3) + cbTmpLen;

	ppkoNew = (PPUBLIC_KEY_OVERLAY)LocalAlloc(0, 
	            ppkoOld->pkheader.keylen + sizeof(BSAFE_PUB_KEY));
    if (!ppkoNew)
        return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

    // Copy the header over
    CopyMemory(&(ppkoNew->pkheader), &(ppkoOld->pkheader), sizeof(BSAFE_PUB_KEY));

    // Copy the rest
    CopyMemory(ppkoNew->rgbKey, ppkoOld->rgbKey, cbOriginal);

    // Pad any required trailing zeroes
    ZeroMemory(ppkoNew->rgbKey + cbOriginal, cbTmpLen);

    *ppbMungedKey = (PBYTE)ppkoNew;
    *pcbMungedKey = ppkoOld->pkheader.keylen + sizeof(BSAFE_PUB_KEY);

    return(S_OK);
}

//
// Function to rebuild a package received from a publisher. This consists of
// the following steps:
//
// - Make a copy of the original package
// - Extract and decrypt symmetric key from package
// - Extract and decrypt pusblisher-supplied metadata file from package
// - Verify and decrypt package and write out raw cabinet file
// - Re-encrypt package with new symmetric key
// - Export new symmetric key to a file
//
#define REBUILD_REBUILD_EXTENSION	".new"
#define REBUILD_METADATA_EXTENSION	".xbx"
#define REBUILD_SQL_QUERY_EXTENSION	".sql"
#define REBUILD_CABINET_EXTENSION	".cab"
#define REBUILD_SYMMKEY_FILENAME	"symmkey.c"
#define REBUILD_TEMPFILE_NAME		"tempfile.$$$"

#define REBUILD_CONTENT_SECTION		"Metadata"
#define REBUILD_AUTO_SECTION		"All"
#define REBUILD_RATING_KEY			"Rating"
#define REBUILD_PACKAGE_SIZE_KEY	"PackageSize"
#define REBUILD_INSTALL_SIZE_KEY	"InstallSize"
#define REBUILD_SYMMETRIC_KEY		"SymmetricKey"
#define REBUILD_INVALID_VALUE		(0x7fffffff)

HRESULT RebuildContentPackage(
			CHAR		*szFilePath,
			DWORD		OfferingId,
			DWORD		dwTitleId,
			WORD		wVerHi,
			WORD		wVerLo,
			PBYTE		pbPrivateKey,
			DWORD		cbPrivateKey
			)
{
	HRESULT		hr = S_OK;
	HANDLE		hFile = INVALID_HANDLE_VALUE;
	HCRYPTPROV	hCrypto = 0;
	HCRYPTKEY	hKeyPrivate = 0;
	BYTE		rgbSymKey[XONLINE_KEY_LENGTH];
	BYTE		rgbBuffer[512];
	DWORD		cbSymKey;
	CHAR		szTempName[MAX_PATH];
	CHAR		szTempName2[MAX_PATH];
	DWORD		cbFilePath;
	DWORD		dwRating = 0;
	DWORD		cbDone;
	LARGE_INTEGER	liPackageSize;
	LARGE_INTEGER	liInstallSize;

	XONLINECONTENT_HEADER	Header;
	DGSTFILE_IDENTIFIER		dfi;

	// Initialize the crypto provider
	hr = InitializeCrypto(
				pbPrivateKey, cbPrivateKey,
				NULL, 0,
				&hCrypto, NULL, &hKeyPrivate, 0);
	if (hr != S_OK)
		goto Error;

	// Make a copy of the input file
	cbFilePath = strlen(szFilePath);
	if (cbFilePath + 5 >= MAX_PATH)
		return(ERROR_INVALID_NAME);

	strcpy(szTempName, szFilePath);
	strcat(szTempName, REBUILD_CABINET_EXTENSION);

	if (!CopyFile(szFilePath, szTempName, FALSE))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		printf("Cannot make copy of original package (%u)\n", hr);
		goto Error;
	}

	// Now we can party on the new file
	hFile = CreateFile(
				szTempName,
				GENERIC_READ | GENERIC_WRITE, 
				FILE_SHARE_READ, 
				NULL, 
				OPEN_EXISTING, 
				FILE_ATTRIBUTE_NORMAL, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		printf("Cannot open package %s (%u)\n", szTempName, hr);
		goto Error;
	}

	printf("Extracting ...\n");

	// First extract the symmetric key
	cbSymKey = XONLINE_KEY_LENGTH;
	hr = RetrieveSymmetricKey(hFile, hKeyPrivate, rgbSymKey, cbSymKey);
	if (hr != S_OK)
		goto Error;

	// Load the package header and decrypt it
	hr = DecryptPackageHeader(hFile, hCrypto, rgbSymKey, cbSymKey, &Header);
	if (hr != S_OK)
		goto Error;

	// Then detach the metatdata file and save it off
	strcpy(szTempName, szFilePath);
	strcat(szTempName, REBUILD_METADATA_EXTENSION);
	hr = DetachEncryptedFile(hFile, szTempName, 
				&Header, hCrypto, rgbSymKey, cbSymKey, NULL);
	if (hr != S_OK)
		goto Error;

#if 0
	// Now load the rating value from the metadata file
	dwRating = GetPrivateProfileInt(
				REBUILD_CONTENT_SECTION,
				REBUILD_RATING_KEY,
				REBUILD_INVALID_VALUE,
				szTempName);
	if (dwRating == REBUILD_INVALID_VALUE)
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		printf("Cannot rebuild package because the rating of this package is not specified\n");
		goto Error;
	}
	if (dwRating > 0xffff)
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		printf("Invalid content rating encountered (%u, %x)\n", dwRating, dwRating);
		goto Error;
	}

	printf(" * Content Rating is set to %u (%x)\n", dwRating, dwRating);
#endif	

	// Decrypt the rest of the package
	hr = DecryptPackageBody(hFile, hCrypto, &Header, rgbSymKey, cbSymKey);
	if (hr != S_OK)
		goto Error;

	CloseHandle(hFile);
	hFile = INVALID_HANDLE_VALUE;

	// New we generate a new symmetric key
	GenerateSymmetricKey(hCrypto, rgbSymKey);

	printf("Rebuilding ...\n");

	// Rebild the content package with a digest signed with the new key
	dfi.OfferingId = OfferingId;
	dfi.dwTitleId = dwTitleId;
	dfi.wTitleVersionHi = wVerHi;
	dfi.wTitleVersionLo = wVerLo;
	strcpy(szTempName, szFilePath);
	strcat(szTempName, REBUILD_CABINET_EXTENSION);
	strcpy(szTempName2, szFilePath);
	strcat(szTempName2, REBUILD_REBUILD_EXTENSION);
	hr = RebuildCabinetWithDigest(szTempName, szTempName2,
				Header.cfheader.cFiles, REBUILD_TEMPFILE_NAME, 
				XONLINECONTENT_MANIFEST_FILE_NAME,
				&dfi, rgbSymKey, cbSymKey,
				&liPackageSize, &liInstallSize);
	if (FAILED(hr))
	{
		printf("Failed to rebuild cabinet file %s (%u)\n", szTempName2, hr);
		goto Error;
	}

	// Now save a copy of the output cabinet
	DeleteFile(szTempName);
	if (!CopyFile(szTempName2, szTempName, TRUE))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		printf("Cannot make copy of output cabinet (%u)\n", hr);
		goto Error;
	}
	
	hFile = CreateFile(
				szTempName2,
				GENERIC_READ | GENERIC_WRITE, 
				FILE_SHARE_READ, 
				NULL, 
				OPEN_EXISTING, 
				FILE_ATTRIBUTE_NORMAL, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		printf("Cannot open package %s (%u)\n", szTempName2, hr);
		goto Error;
	}

	printf("Encrypting ...\n");
	
	// Now we encrypt the package with the new symmetric key
	hr = EncryptCabinetBody(hFile, hCrypto, rgbSymKey, cbSymKey);
	if (hr != S_OK)
	{
		printf("Unable to re-encrypt package body (%x)\n", hr);
		goto Error;
	}

	hr = EncryptCabinetHeader(hFile, hCrypto, rgbSymKey, cbSymKey);
	if (hr != S_OK)
	{
		printf("Unable to re-encrypt package header (%x)\n", hr);
		goto Error;
	}

	// Finally export the symmetric key to a file
	hr = ExportSymmetricKey(hCrypto, 
				REBUILD_SYMMKEY_FILENAME, rgbSymKey, cbSymKey);
	if (hr != S_OK)
	{
		printf("Unable to export symmetric key (%x)\n", hr);
		goto Error;
	}

	printf("Exporting computed metadata ...\n");

	// Now append some computed values to the metadata file
	strcpy(szTempName, szFilePath);
	strcat(szTempName, REBUILD_METADATA_EXTENSION);

	// Export symmetric Key
	cbDone = (XONLINE_KEY_LENGTH * 2) + 3;
	hr = ConvertSymmetricKeyToString(
				rgbSymKey, cbSymKey, rgbBuffer, &cbDone);
	if (SUCCEEDED(hr))
	{
		if (!WritePrivateProfileString(
					REBUILD_AUTO_SECTION,
					REBUILD_SYMMETRIC_KEY,
					rgbBuffer, szTempName))
			hr = HRESULT_FROM_WIN32(GetLastError());
	}
	if (FAILED(hr))				
	{
		printf("Unable to export symmetric key (%x)\n", hr);
		goto Error;
	}

	// Export package size
	sprintf(rgbBuffer, "%I64u", liPackageSize.QuadPart);
	if (!WritePrivateProfileString(
					REBUILD_AUTO_SECTION,
					REBUILD_PACKAGE_SIZE_KEY,
					rgbBuffer, szTempName))
	{
		printf("Unable to export package size (%u)\n", GetLastError());
		goto Error;
	}

	// Export install size
	sprintf(rgbBuffer, "%I64u", liInstallSize.QuadPart / XBOX_CLUSTER_SIZE);
	if (!WritePrivateProfileString(
					REBUILD_AUTO_SECTION,
					REBUILD_INSTALL_SIZE_KEY,
					rgbBuffer, szTempName))
	{
		printf("Unable to export install size (%u)\n", GetLastError());
		goto Error;
	}

	// Now try to generate SQL queries for this package
	printf("Generating SQL command script ...\n");

	strcpy(szTempName2, szFilePath);
	strcat(szTempName2, REBUILD_SQL_QUERY_EXTENSION);

	hr = GenerateQueriesFromMetadataFile(
				dwTitleId, OfferingId, szTempName, szTempName2);
	if (FAILED(hr))
	{
		printf("%s\n", MetadataGetErrorString());
		goto Error;
	}

Exit:

	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	return(hr);

Error:
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\inc\cabarc.h ===
/*
 * cabarc.h
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <fcntl.h>
#include <limits.h>
#include <io.h>
#include <sys/stat.h>
#include <time.h>

#include "typedefs.h"
#include "cablist.h"
#include "os.h"
#include "vars.h"

#include <fdi.h>
#include <fci.h>

#include "proto.h"

#define FOLDER_SEPARATOR_STRING "+"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\inc\cablist.h ===
/*
 * cablist.h
 *
 * List handling routines
 */

#ifndef _CAB_LIST_H

#define _CAB_LIST_H

/*
 * List element
 */
struct cab_file_link
{
   struct cab_file_link *fl_next;

   /*
    * Logical filename to use (may be NULL).
    * Used if reading a file list from a file (-l option).
    */
   byte *                fl_logical_filename;

   /* physical filename, variable length... */
   byte                  fl_filename[1];
};


/*
 * List header
 */
typedef struct
{
   struct cab_file_link *flh_head;
   struct cab_file_link *flh_tail;
} cab_file_list_header;

#endif /* _CAB_LIST_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\common\wildcard.c ===
/*
 * wildcard.c
 *
 * Wildcard related routines.
 */
#include "cabarc.h"


bool wildcards_in_string(const byte *wildcard)
{
	while (*wildcard)
	{
		if (*wildcard == '*' || *wildcard == '?')
			return true;

		wildcard++;
	}

	return false;
}


/*
 * Returns whether <string> is matched by <wildcard>
 */
bool wildcard_match(const byte *string, const byte *wildcard)
{
	if (strrchr(string, '\\') != NULL)
	{
		string = strrchr(string, '\\')+1;
	}

	while (*string)
	{
		if (*wildcard != '*')
		{
			if (toupper(*wildcard) != toupper(*string) && *wildcard != '?')
			{
				return false;
			}

			wildcard++;
		}
		else if (*string == '.')
		{
			wildcard++;

			if (*wildcard == 0)
				return true;

			wildcard++;
		}

		string++;
	}

	return true;
}


bool expand_wildcard(
   cab_file_list_header *list_header,
   const byte           *wildcard,
   bool                 recurse_subdirs,
   bool                 (*qualifier_function)(const byte *filename)
)
{
	WIN32_FIND_DATA   fd;
	HANDLE            handle;
	byte              wild_str[MAX_FILENAME_LENGTH];
	byte              search_path[MAX_FILENAME_LENGTH];
	byte              search_str[MAX_FILENAME_LENGTH];
	byte              temp_name[MAX_FILENAME_LENGTH];
	byte              *name;
	bool              done;
	bool              found_files;
	cab_file_list_header recurse_subdir_list;
	struct cab_file_link *recurse_link;

	if (wildcards_in_string(wildcard) == false)
	{
		if (qualifier_function)
		{
			if ((*qualifier_function)(wildcard) == false)
				return true;
		}

        return (add_to_list(list_header, wildcard, NULL));
   }

	/*
	 * Get the path component of the search
	 *
	 * e.g. if wildcard == "\elroy\diamond\layout\*.c"
	 *      then search_path should equal "\elroy\diamond\layout\"
	 *      and wild_str should equal "*.c"
	 */
	strcpy(search_path, wildcard);

	if ((name = strrchr(search_path, SLASH_CHARACTER)) != NULL)
	{
		/* There are slashes in the name */
		strcpy(wild_str, name+1);
		*(name+1) = 0;
	}
	else
	{
		strcpy(wild_str, search_path);
		*search_path = 0;
	}

	found_files = false;

	init_list(&recurse_subdir_list);

	if (recurse_subdirs)
	{
		recurse_link = NULL;

		sprintf(search_str, "%s*.*", search_path); 

		/* Recurse into subdirectories and get all subdir names */
		do
		{
			handle = FindFirstFile(search_str, &fd);

			if (handle == INVALID_HANDLE_VALUE)
				done = true;
			else
				done = false;

			while (done == false)
			{
				if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				{
					char	new_dir[MAX_PATHNAME_LENGTH];

					if (fd.cFileName[0] != '.') /* . and .. */
					{
						sprintf(new_dir, "%s%s", search_path, fd.cFileName);
                        (void) add_to_list(&recurse_subdir_list, new_dir, NULL);
					}
				}

				if (FindNextFile(handle, &fd) == FALSE)
					done = TRUE;
				else
					done = FALSE;
			}

			if (handle != INVALID_HANDLE_VALUE)
				FindClose(handle);

			if (recurse_link == NULL)
				recurse_link = recurse_subdir_list.flh_head;
			else
				recurse_link = recurse_link->fl_next;

			if (recurse_link)
			{
				sprintf(search_path, "%s\\", recurse_link->fl_filename);
				sprintf(search_str, "%s\\*.*", recurse_link->fl_filename);
			}
		} while (recurse_link);
	}

	strcpy(search_str, wildcard);
	recurse_link = NULL;


	strcpy(search_path, wildcard);

	if ((name = strrchr(search_path, SLASH_CHARACTER)) != NULL)
	{
		/* There are slashes in the name */
		*(name+1) = 0;
	}
	else
	{
		*search_path = 0;
	}

	do
	{
		handle = FindFirstFile(search_str, &fd);

		if (handle == INVALID_HANDLE_VALUE)
			done = true;
		else
			done = false;

		while (done == false)
		{
			if (fd.cFileName[0] != '.') /* . and .. */
			{
				/*
				 * Don't add directories to the file list
				 */
				if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
				{
					/* Full name */
					sprintf(temp_name, "%s%s", search_path, fd.cFileName);
         
					found_files = true;

					/*
					 * If a qualifier function was supplied, this allows the
					 * caller to exclude certain files at the last minute.
					 *
					 * For example, if testing archives, and *.* is supplied
					 * for the archive name, the qualifier function can be
					 * used to ensure that only files ending in .cab are
					 * returned.
					 */
					if (qualifier_function)
					{
						if ((*qualifier_function)(temp_name) == false)
							continue;
					}

                    (void) add_to_list(list_header, temp_name, NULL);
				}
			}

			if (FindNextFile(handle, &fd) == FALSE)
				done = TRUE;
			else
				done = FALSE;
		}

		if (handle != INVALID_HANDLE_VALUE)
		{
			FindClose(handle);
		}

		if (recurse_link == NULL)
			recurse_link = recurse_subdir_list.flh_head;
		else
			recurse_link = recurse_link->fl_next;

		if (recurse_link)
		{
			sprintf(search_str, "%s\\%s", recurse_link->fl_filename, wild_str);
			sprintf(search_path, "%s\\", recurse_link->fl_filename);
		}

	} while (recurse_link);

	free_list(&recurse_subdir_list);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\common\lists.c ===
/*
 * lists.c
 *
 * List handling routines
 */
#include "cabarc.h"
#include "oldnames.h"


void init_list(cab_file_list_header *header)
{
	memset(header, 0, sizeof(*header));
}


bool add_to_list(
   cab_file_list_header *header,
   const byte *filename,
   const byte *logical_filename // may be NULL
)
{
   struct cab_file_link *new_link;
   long                  alloc_size;

   alloc_size = sizeof(struct cab_file_link) + strlen(filename) + 1;

   // allocate space for the logical filename if it is present
   if (logical_filename != NULL)
      alloc_size += (strlen(logical_filename)+1);

   new_link = (struct cab_file_link *) mem_malloc(alloc_size);

   if (new_link == NULL)
      return false;

   memset(new_link, 0, sizeof(struct cab_file_link));

   strcpy(new_link->fl_filename, filename);

   if (logical_filename != NULL)
   {
      // logical filename points to memory right after filename
      new_link->fl_logical_filename = &new_link->fl_filename[strlen(filename)+1];
      strcpy(new_link->fl_logical_filename, logical_filename);
   }

   new_link->fl_next = NULL;

   if (header->flh_tail)
   {
      header->flh_tail->fl_next = new_link;
      header->flh_tail = new_link;
   }
   else
   {
      header->flh_head = header->flh_tail = new_link;
   }

   return true;
}


void free_list(cab_file_list_header *header)
{
   struct cab_file_link *search;
   struct cab_file_link *next;

   for (search = header->flh_head; search; search = next)
   {
      next = search->fl_next;

      mem_free((byte *) search);
   }

   header->flh_head = NULL;
   header->flh_tail = NULL;
}


/*
 * If require_extract_match is true, then the whole path and filename
 * must match; otherwise, only the filename part needs to match
 */
struct cab_file_link *filename_in_list(
   const byte *filename,
   const cab_file_list_header *header,
   bool require_exact_match
)
{
   struct cab_file_link *search;
   const byte           *p;

   if (require_exact_match == false)
   {
      if ((p = strrchr(filename, SLASH_CHARACTER)) == NULL)
      {
         p = filename;
      }
      else
      {
         p++;
      }
   }

   for (search = header->flh_head; search; search = search->fl_next)
   {
      if (require_exact_match)
      {
         if (!stricmp(search->fl_filename, filename))
            return (search);
      }
      else
      {
         const byte *q;

         if ((q = strrchr(search->fl_filename, SLASH_CHARACTER)) == NULL)
         {
            q = search->fl_filename;
         }
         else
         {
            q++;
         }

         if (!stricmp(p, q))
         {
            return (search);
         }
      }
   }

   return NULL;
}


bool file_in_wildcard_list(
   const byte *filename,
   const cab_file_list_header *header
)
{
   struct cab_file_link *search;

   for (search = header->flh_head; search; search = search->fl_next)
   {
      if (wildcard_match(filename, search->fl_filename))
         return (true);
   }

   return false;
}


static void strip_trailing_whitespace(byte *line)
{
    int i;

    for (i = strlen(line)-1; i >= 0; i--)
    {
        if (!isspace(line[i]))
            break;

        line[i] = 0;
    }
}


/*
 * Read a list of files from a text file, and add to list.
 * Expand any wildcards
 */
bool input_file_list_from_file(
    const byte *filename,
    cab_file_list_header *header
)
{
    FILE *  handle;
    byte    line[MAX_PATHNAME_LENGTH+8];

    handle = fopen(filename, "r");

    if (handle == NULL)
        return false;

    while (1)
    {
        byte *logical_filename;
        byte *physical_filename;
        byte *p, *q;

        if (fgets(line, sizeof(line), handle) == NULL)
            break;

        // remove trailing newline and any trailing spaces
        strip_trailing_whitespace(line);

        // ignore blank lines
        if (strlen(line) == 0)
            continue;

        // no logical filename yet
        logical_filename = NULL;

        // handle quotes around the physical filename
        if (line[0] == '\"')
        {
            // find matching quote
            p = strchr(&line[1], '\"');

            if (p == NULL)
            {
                // no matching quote; error!
                printf(
                    "No matching quote in file '%s' line:\n%s\n",
                    filename, line
                );

                fclose(handle);
                return false;
            }

            physical_filename = &line[1];
            *p++ = 0; // null terminate physical filename

            // skip over space
            while (isspace(*p))
                p++;
        }
        else
        {
            // no quote for physical filename
            physical_filename = &line[0];

            p = strchr(line, ' '); // find a space

            if (p != NULL)
            {
                // there's a space, which means a logical filename follows
                *p++ = 0; // null terminate string

                // skip over space
                while (isspace(*p))
                    p++;
            }
        }

        if (p != NULL)
        {
            // logical filename follows?
            if (*p != 0)
            {
                // not end of string

                // is logical filename in quotes?
                if (*p == '\"')
                {
                    q = strchr(p+1, '\"');

                    if (q == NULL)
                    {
                        // no matching quote; error!
                        printf(
                            "No matching quote in file '%s' line:\n%s\n",
                            filename, line
                        );

                        fclose(handle);
                        return false;
                    }

                    logical_filename = p+1;
                    *q = 0; // null terminate string
                }
                else
                {
                    // logical filename is not in quotes
                    logical_filename = p;
                }
            }
        }

        if ((strlen(physical_filename) >= MAX_PATHNAME_LENGTH) ||
             ((logical_filename != NULL) &&
             (strlen(logical_filename) >= MAX_PATHNAME_LENGTH)))
        {
            printf("Filenames cannot be more than %d characters in length, line:\n", MAX_PATHNAME_LENGTH);
            printf("%s\n", line);
            fclose(handle);
            return false;
        }

        // if the filename contains wildcards, expand them
        if (wildcards_in_string(physical_filename))
        {
            // logical filenames are not allowed if there are wildcards
            if (logical_filename != NULL)
            {
                printf(
                    "Logical filenames are not allowed if wildcards are used, line:\n%s\n",
                    line
                );

                fclose(handle);
                return false;
            }

            if (false == expand_wildcard(
                header,
                physical_filename,
                g_recurse_subdirs,
                NULL
            ))
            {
                printf("Error expanding wildcard '%s'\n", physical_filename);
                fclose(handle);
                return false;
            }
        }
        else
        {
            if (add_to_list(header, physical_filename, logical_filename) == false)
                return false;
        }
    }

    fclose(handle);
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\common\rebldcab.c ===
// ---------------------------------------------------------------------------------------
// rebldcab.c
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------
// Includes
// ---------------------------------------------------------------------------------------

#include <windows.h>
#include <winsockx.h>
#include <xbox.h>
#include <xonlinep.h>

#include <stdio.h>
#include <string.h>

#include <fci.h>
#include <fdi.h>
#include <sha.h>

#include "cryptcab.h"
#include "rebldcab.h"


//
// File insertion callbacks
//

/*
 * File placed function called when a file has been committed
 * to a cabinet
 */
FNFCIFILEPLACED(RebldFilePlacedCallback)
{
	return 0;
}


/*
 * Function to obtain temporary files
 */
FNFCIGETTEMPFILE(RebldGetTempFileCallback)
{
    char    *psz;

    psz = _tempnam("","xx");            // Get a name
    if ((psz != NULL) && (strlen(psz) < (unsigned)cbTempName)) {
        strcpy(pszTempName,psz);        // Copy to caller's buffer
        free(psz);                      // Free temporary name buffer
        return TRUE;                    // Success
    }
    //** Failed
    if (psz) {
        free(psz);
    }

    return FALSE;
}

/*
 * Progress function
 */
FNFCISTATUS(RebldProgressCallback)
{
	return 0;
}


FNFCIGETNEXTCABINET(RebldGetNextCabinetCallback)
{
	RIP_ON_NOT_TRUE("RebldGetNextCabinetCallback", FALSE);
	return -1;
}


FNFCIGETOPENINFO(RebldGetOpenInfoCallback)
{
	BY_HANDLE_FILE_INFORMATION	finfo;
	FILETIME						filetime;
	HANDLE						handle;
	PREBLDCBK_CONTEXT			pContext = (PREBLDCBK_CONTEXT)pv;

	handle = CreateFile(
		pszName,
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
		NULL
	);

	if (handle == INVALID_HANDLE_VALUE)
	{
        *err = GetLastError();
		return -1;
	}

	if (GetFileInformationByHandle(handle, &finfo) == FALSE)
	{
        *err = GetLastError();
		CloseHandle(handle);
		return -1;
	}

	FileTimeToLocalFileTime(
		&finfo.ftLastWriteTime,
		&filetime
	);

	FileTimeToDosDateTime(
		&filetime,
		pdate,
		ptime
	);

	// CABARCX: Force the timestamp to be 0, we have other plans
	*ptime = 0;

    *pattribs = (USHORT) finfo.dwFileAttributes &
        (FILE_ATTRIBUTE_READONLY |
         FILE_ATTRIBUTE_HIDDEN   |
         FILE_ATTRIBUTE_SYSTEM   |
         FILE_ATTRIBUTE_ARCHIVE);

	// printf("  -- adding %s as %s\n", pszName, pContext->szFullName);

	return (INT_PTR)handle;
}

//
// Extraction callbacks
//
FNFDINOTIFY(RebldNewFileNotifyCallback)
{
	HRESULT				hr;
	int					ret = TRUE;
	DWORD				attrs;
	DWORD				dwSize;
	FILETIME				datetime;
	CHAR				*filename;
	INT_PTR				handle;
	BYTE				rgbSignature[XCALCSIG_SIGNATURE_SIZE];
	DGST_FILE_DATA		dfd;
	PREBLDCBK_CONTEXT	pContext = (PREBLDCBK_CONTEXT)(pfdin->pv);

	switch (fdint)
	{
		case fdintCABINET_INFO: // general information about the cabinet
			return 0;

		case fdintNEXT_CABINET:	// file continued to next cabinet
			return -1;

		case fdintPARTIAL_FILE: // first file in cabinet is continuation
			return 0;

		case fdintCOPY_FILE:	// file to be copied

			/*
			 * Ignore files which have a colon in them (e.g. C:\CONFIG.SYS)
			 */
			if (strchr(pfdin->psz1, ':'))
			{
				printf("   File '%s' contains illegal character (colon) -- skipping\n", pfdin->psz1);
				return 0;
			}

			filename = pfdin->psz1;
			handle = callback_file_open(
				pContext->szTempFile,
				_O_BINARY | _O_CREAT | _O_RDWR | _O_SEQUENTIAL,
				_S_IREAD | _S_IWRITE 
			);

			if (handle == -1)
			{
				printf("   -- Error opening '%s' for output\n", filename);
			}
			else 
			{
				//printf("   processing: %s\n", filename);
			}

			return handle;

		case fdintCLOSE_FILE_INFO:	// close the file, set relevant info

			filename = pfdin->psz1;
			attrs = 0;
			
			if (pfdin->attribs & _A_RDONLY)
			    attrs |= FILE_ATTRIBUTE_READONLY;

			if (pfdin->attribs & _A_ARCH)
			    attrs |= FILE_ATTRIBUTE_ARCHIVE;

			if (pfdin->attribs & _A_HIDDEN)
			    attrs |= FILE_ATTRIBUTE_HIDDEN;

			if (pfdin->attribs & _A_SYSTEM)
			    attrs |= FILE_ATTRIBUTE_SYSTEM;

			if (attrs == 0)
				attrs = FILE_ATTRIBUTE_NORMAL;

			/*
			 * Set file attributes and date/time
			 */
			if (TRUE == DosDateTimeToFileTime(
				pfdin->date,
				pfdin->time,
				&datetime))
			{
				FILETIME	local_filetime;

				if (TRUE == LocalFileTimeToFileTime(
					&datetime, 
					&local_filetime))
				{
					(void) SetFileTime(
						(HANDLE) pfdin->hf,
						&local_filetime,
						NULL,
						&local_filetime
					);
				}
			}

			// Before we close the file, we will compute the SHA1
			if (callback_file_seek(pfdin->hf, 0, SEEK_SET) != -1)
			{
				LARGE_INTEGER	liFileSize;
				PBYTE			pbBuffer;
				A_SHA_CTX		Sha;

				ret = -1;
				if (GetFileSizeEx((HANDLE)pfdin->hf, &liFileSize) == TRUE)
				{
					RIP_ON_NOT_TRUE("RebldNewFileNotifyCallback", (liFileSize.u.HighPart == 0));
					dwSize = liFileSize.u.LowPart;
					 pbBuffer = LocalAlloc(0, dwSize);
					 if (pbBuffer)
				 	{
				 		if (callback_file_read(pfdin->hf, pbBuffer, dwSize) == dwSize)
				 		{
				 			A_SHAInit(&Sha);
				 			A_SHAUpdate(&Sha, pbBuffer, dwSize);
				 			A_SHAFinal(&Sha, rgbSignature);
				 			ret = TRUE;
				 		}
				 		LocalFree(pbBuffer);
				 	}

				 	// Add this to the expected install size, in terms of clusters
				 	liFileSize.QuadPart += (XBOX_CLUSTER_SIZE - 1);
				 	liFileSize.QuadPart /= XBOX_CLUSTER_SIZE;
				 	liFileSize.QuadPart *= XBOX_CLUSTER_SIZE;
				 	pContext->InstallSize += liFileSize.QuadPart;
				}
			}

			// In any case we will need to close the file
			(void) callback_file_close(pfdin->hf);

			// Continue processing only if ret is still TRUE
			if (ret == TRUE)
			{
				(void) SetFileAttributes(pContext->szTempFile, attrs);

				// Now we insert this file into the new cabinet
				ret = -1;
				strcpy(pContext->szFullName, filename);
				if (FCIAddFile(pContext->hfci, pContext->szTempFile,
							filename, FALSE,
							RebldGetNextCabinetCallback,
							RebldProgressCallback,
							RebldGetOpenInfoCallback,
							TCOMPfromLZXWindow(15)) == TRUE)
				{
					// Insert the file information into the digest hash
					dfd.dwFileSize = dwSize;
					dfd.bFlags = 0;
					dfd.bReservedSize = 0;
					dfd.wSections = 1;
					dfd.rgSectionData[0].dwSectionStart = 0;
					dfd.rgSectionData[0].dwSectionSize = dwSize;
					CopyMemory(dfd.rgSectionData[0].rgbSignature, 
								rgbSignature, XCALCSIG_SIGNATURE_SIZE);

					strcpy(dfd.szFileName, filename);
					hr = InsertFileIntoDigest(pContext->pdc, &dfd);
					if (SUCCEEDED(hr))
						ret = TRUE;
				}
			}

			DeleteFile(pContext->szTempFile);

			return ret;
	}

	return 0;
}

//
// Decryption callback, this is mostly for tracking folder changes
//
FNFDIDECRYPT(RebldDecryptCallback)
{
	PREBLDCBK_CONTEXT	pContext = (PREBLDCBK_CONTEXT)(pfdid->pvUser);

	// Only handle new folder event
	if (pfdid->fdidt == fdidtNEW_FOLDER)
	{
		// This is where the old cabinet jumps to a new folder, follow
		// suite for the new cabinet
		if (!FCIFlushFolder(
					pContext->hfci,
					RebldGetNextCabinetCallback,
					RebldProgressCallback))
			return(-1);
	}
	return TRUE;
}

//
// Function to rebuild a cabinet file and insert a digest file
//
HRESULT RebuildCabinetWithDigest(
			char *szOldCabinet,
			char *szNewCabinet,
			DWORD cFiles, 
			char *szTempFile,
			char *szDigestFileName,
			PDGSTFILE_IDENTIFIER pdfi,
			PBYTE pbSymmetricKey,
			DWORD cbSymmetricKey,
			LARGE_INTEGER *pliPackageSize,
			LARGE_INTEGER *pliInstallSize
			)
{
	HRESULT	hr = S_OK;
	HFCI	hfci = NULL;
	HFDI	hfdi = NULL;
	BOOL	fRet;
	ERF		erf;
	CHAR	*p;
	CCAB	CabParams;
	CHAR	szCabinetName[MAX_PATHNAME_LENGTH];
	CHAR	szCabinetPath[MAX_PATHNAME_LENGTH];
	REBLDCBK_CONTEXT	Context;
	DGSTFILE_HEADER		Header;
	HANDLE				hFile;

	// Set up the context
	RIP_ON_NOT_TRUE("RebuildCabinetWithDigest", 
				(cbSymmetricKey == XONLINE_KEY_LENGTH));
	CopyMemory(Context.rgbSymmetricKey, pbSymmetricKey, cbSymmetricKey);	
	strcpy(Context.szTempFile, szTempFile);
	Context.InstallSize = 0;

	// Initialize the digest builder
	hr = CreateDigest(cFiles, 0, 0, &(Context.pdc));
	if (FAILED(hr))
		goto Error;

	// Create the FCI and FDI interfaces
	hfdi = FDICreate(
		callback_alloc,
		callback_free,
		callback_file_open,
		callback_file_read,
		callback_file_write,
		callback_file_close,
		callback_file_seek,
		cpu80386,
		&erf);
	if (hfdi == NULL)
	{
		printf("FDICreate() failed: code %d [%s]\n",
			erf.erfOper, return_fdi_error_string(erf.erfOper));
		hr = HRESULT_FROM_WIN32(erf.erfOper);
		goto Error;
	}

	// Setup CAB parameters
	ZeroMemory(&CabParams, sizeof(CCAB));
	CabParams.cb = LONG_MAX;
	CabParams.cbFolderThresh = LONG_MAX;
	CabParams.cbReserveCFHeader = 344;
	CabParams.cbReserveCFFolder = 28;
	CabParams.cbReserveCFData = 0;
	CabParams.iCab = 1;
	CabParams.iDisk = 0;
	CabParams.setID = 0;
	strcpy(CabParams.szDisk, "");
	strcpy(CabParams.szCab, szNewCabinet);

	hfci = FCICreate(
		&erf,
		RebldFilePlacedCallback,
		callback_fci_alloc,
		callback_fci_free,
		callback_fci_file_open,
		callback_fci_file_read,
		callback_fci_file_write,
		callback_fci_file_close,
		callback_fci_file_seek,
		callback_fci_file_delete,
		RebldGetTempFileCallback,
		&CabParams,
		&Context);
	if (hfci == NULL)
	{
		printf("FCICreate() failed: code %d [%s]\n",
			erf.erfOper, return_fci_error_string(erf.erfOper));
		hr = HRESULT_FROM_WIN32(erf.erfOper);
		goto Error;
	}

	Context.hfci = hfci;

	p = strrchr(szOldCabinet, '\\');
	if (p == NULL)
	{
		strcpy(szCabinetName, szOldCabinet);
		strcpy(szCabinetPath, "");
	}
	else
	{
		strcpy(szCabinetName, p+1);
		strncpy(szCabinetPath, szOldCabinet, (int) (p-szOldCabinet)+1);
		szCabinetPath[ (int) (p-szOldCabinet)+1 ] = 0;
	}

	if (TRUE != FDICopy(
		hfdi,
		szCabinetName,
		szCabinetPath,
		0,
		RebldNewFileNotifyCallback,
		RebldDecryptCallback,
		&Context))
	{
		printf("FDICopy() failed: code %u\n", GetLastError());
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// Alright now build the digest file
	Header.wReservedSize = 0;
	Header.wRating = 0;
	Header.wFlags = 0;

	// Special case: if all fields in dfi are zero, this means
	// the package can be shared
	if (!pdfi->OfferingId && !pdfi->dwTitleId && 
		!pdfi->wTitleVersionHi && !pdfi->wTitleVersionLo)
	{
		printf(" * No title and offering ID, marking content as shared\n");
		Header.wFlags |= DGSTFILE_HEADER_FLAG_SHARED;
	}
	
	CopyMemory(&(Header.dfi), pdfi, sizeof(DGSTFILE_IDENTIFIER));
	hr = SerializeDigestToFile(Context.pdc, szTempFile, &Header,
				pbSymmetricKey, cbSymmetricKey, NULL);
	if (FAILED(hr))
		goto Error;

	FreeDigest(Context.pdc);

#if 0
	// Verify digest	
	hr = DumpDigest(szTempFile, pbSymmetricKey, cbSymmetricKey);
	if (FAILED(hr))
		goto Error;
#endif

	// Now insert the digest into the cabinet, keep it in a separate
	// folder to minimize resume costs
	if (!FCIFlushFolder(
				hfci,
				RebldGetNextCabinetCallback,
				RebldProgressCallback))
	{
		printf("FCIFlushFolder() failed: code %u\n", GetLastError());
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}
	
	strcpy(Context.szFullName, szDigestFileName);
	if (!FCIAddFile(
		hfci,
		szTempFile,
		szDigestFileName,
		FALSE,
		RebldGetNextCabinetCallback,
		RebldProgressCallback,
		RebldGetOpenInfoCallback,
		TCOMPfromLZXWindow(15)))
	{
		printf("FCIAddFile() failed: code %u\n", GetLastError());
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	if (!FCIFlushCabinet(hfci, FALSE, RebldGetNextCabinetCallback,
				RebldProgressCallback))
	{
		printf("FCIFlushCabinet() failed: code %u\n", GetLastError());
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

Cleanup:

	if (hfdi != NULL)
		FDIDestroy(hfdi);
	if (hfci != NULL)
		FCIDestroy(hfci);

	DeleteFile(szTempFile);
	DeleteFile(szDigestFileName);
	
	if (FAILED(hr))
		DeleteFile(szNewCabinet);
	else
	{
		// Get the accurate package size
		hFile = CreateFile(
					szNewCabinet,
					GENERIC_READ, 
					FILE_SHARE_READ, 
					NULL, 
					OPEN_EXISTING, 
					FILE_ATTRIBUTE_NORMAL, 
					NULL);
		if (hFile == INVALID_HANDLE_VALUE)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			printf("Cannot open package %s (%u)\n", szNewCabinet, hr);
			goto Error;
		}

		if (!GetFileSizeEx(hFile, pliPackageSize))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			printf("Cannot get size of package %s (%u)\n", szNewCabinet, hr);
			goto Error;
		}

		CloseHandle(hFile);
		
		// Set the calculated Install size
		pliInstallSize->QuadPart = Context.InstallSize;
	}

	return(hr);

Error:
	goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\common\metadata.c ===
//===================================================================
//
// Copyright Microsoft Corporation. All Rights Reserved.
//
//===================================================================
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>

#include "metadata.h"

#define MAX_DATA_SIZE		64000
#define MAX_BINTEXT_SIZE	8000

//
// Define an enumerated type for conputed fields. These must correspond to 
// entries in g_rgmdPropertyDescriptions below
//
typedef enum
{
	mciTitleId = 0,
	mciOfferId,
	mciRating,
	mciCancelable,
	mciLocationRank,
	mciOfferLocations,
	mciMax

} MD_COMPUTED_INDEX;

//
// Define all the supported properties. Please see MD_COMPUTED_INDEX above before 
// changing
//
MD_DESCRIPTION g_rgmdPropertyDescriptions[] =
{
	// Computed fields
	{
		"TitleID", "i_title_id", mdtInt32, 0, MD_DESCRIPTION_FLAG_COMPUTED, mqmTitleOffers,
		"Title ID (computed value)", NULL
	},
	{
		"OfferID", "i_offer_id", mdtInt32, 0, MD_DESCRIPTION_FLAG_COMPUTED, 
		mqmOffers | mqmTitleOffers | mqmOfferDescriptions | mqmOfferDescriptionDetails | mqmOfferLocations,
		"Offer ID (computed value)", NULL
	},
	{
		"Rating", "i_ESRB_id", mdtInt32, 0, MD_DESCRIPTION_FLAG_COMPUTED, mqmOffers,
		"Content Rating (computed value)", NULL
	},
	{
		"Cancelable", "b_cancelable", mdtBool, 0, MD_DESCRIPTION_FLAG_COMPUTED, mqmOffers,
		"Cancelable (computed value)", NULL
	},
	{
		"LocationRank", "i_location_rank", mdtInt32, 0, MD_DESCRIPTION_FLAG_COMPUTED, mqmOfferLocations,
		"Offer location Rank (computed value)", NULL
	},
	{
		"OfferLocations", "vc_XRL", mdtString, 4000, MD_DESCRIPTION_FLAG_COMPUTED, mqmOfferLocations,
		"Offer location XRL (computed value)", NULL
	},
	{
		"PackageSize", "i_package_size", mdtInt32, 0, 
		MD_DESCRIPTION_FLAG_COMPUTED | MD_DESCRIPTION_FLAG_FORCE_LOAD, mqmOffers,
		"Package Size (computed value)", NULL
	},
	{
		"InstallSize", "i_install_size", mdtInt32, 0, 
		MD_DESCRIPTION_FLAG_COMPUTED | MD_DESCRIPTION_FLAG_FORCE_LOAD, mqmOffers,
		"Install Size (computed value)", NULL
	},
	{
		"SymmetricKey", "vb_sym_key", mdtBinary, 16, 
		MD_DESCRIPTION_FLAG_COMPUTED | MD_DESCRIPTION_FLAG_FORCE_LOAD, mqmOffers,
		"Package Key (computed value)", NULL
	},

	// Publisher fields
	{	
		"BitFlags", "i_bitfilter", mdtInt32, 0, MD_DESCRIPTION_FLAG_REQUIRED, mqmOffers,
		"Bit flags (publisher-defined)", NULL
	},
	{	
		"OfferingType", "i_offer_type_id", mdtInt32, 0, 0, mqmOffers,
		"Type of offering (Bitmask: Content=1; subscription=2)", NULL
	},
	{	
		"OfferFrequency", "i_offer_frequency_id", mdtInt32, 0, 0, mqmOffers,
		"Offer frequency (non-terminating=0; monthly=1; yearly=2)", NULL
	},
	{	
		"ActivationDate", "sd_start_date", mdtDate, 0, 0, mqmOffers,
		"Offering Activation Date (mm/dd/yyyy)", NULL
	},
	{	
		"EndDate", "sd_end_date", mdtDate, 0, 0, mqmOffers,
		"Offering End/Expiry Date (mm/dd/yyyy)", NULL
	},
	{	
		"FriendlyName", "vc_friendly_name", mdtString, 150, 0, mqmOffers,
		"Offering End/Expiry Date (mm/dd/yyyy)", NULL
	},
	{	
		"EnumerationData", "vb_enum_blob", mdtBinaryFromFile, MAX_BINTEXT_SIZE, 
		MD_DESCRIPTION_FLAG_INDEXED | MD_DESCRIPTION_FLAG_REQUIRED, mqmOfferDescriptions,
		"Descriptive data returned by enumeration request (up to 8192 bytes)", NULL
	},
	{	
		"DetailsData", "vb_details_blob", mdtBinaryFromFile, MAX_DATA_SIZE, 
		MD_DESCRIPTION_FLAG_INDEXED | MD_DESCRIPTION_FLAG_MULTIPART | MD_DESCRIPTION_FLAG_REQUIRED, 
		mqmOfferDescriptionDetails,
		"Details returned by get details request (up to 65536 bytes)", NULL
	}	
};

const DWORD g_cmdPropertyDescriptions = sizeof(g_rgmdPropertyDescriptions) / sizeof(MD_DESCRIPTION);

//
// Error reporting string
//
static CHAR	g_szError[512];

//
// API to retrieve the last error string
//
PSTR MetadataGetErrorString()
{
	return(g_szError);
}

//
// Helper functions
//

//
// Validation routines. Strings MUST be NULL-terminated
//
BOOL ValidateInt(PSTR szInt, ULONGLONG qwLimit, ULONGLONG *pqwValue)
{
	DWORD		cbInt = strlen(szInt);
	ULONGLONG	qwValue = 0;
	BOOL		fHex = FALSE;
	DWORD		i;
	CHAR		ch;

	// Handle Hex values
	if ((cbInt > 2) && (*szInt == '0') && ((szInt[1] == 'x') || szInt[1] == 'X'))
	{
		fHex =  TRUE;
		cbInt -= 2;
		szInt += 2;
	}

	for (i = 0; i < cbInt; i++)
	{
		qwValue *= (fHex?0x10:10);
		ch = *szInt++;
		if ((ch < '0') || (ch > '9'))
		{
			if (!fHex)
				return(FALSE);

			if ((ch >= 'a') && (ch <= 'f'))
				ch = ch - 'a' + 10 + '0';
			else if ((ch >= 'A') && (ch <= 'F'))
				ch = ch - 'A' + 10 + '0';
			else
				return(FALSE);
		}
		
		qwValue += (ch - '0');

		if (qwValue >= qwLimit)
			return(FALSE);
	}

	if (pqwValue)
		*pqwValue = qwValue;

	return(TRUE);
}

BOOL ValidateBool(PSTR szBool)
{
	// Either True, false, or any 32-bit value (0=FALSE)
	if (!_stricmp(szBool, "true") || !_stricmp(szBool, "false") ||
		ValidateInt(szBool, 100000000, NULL))
		return(TRUE);
	return(FALSE);
}

BOOL ValidateDate(PSTR szDate)
{
	CHAR		szTemp[12];
	CHAR		*pS1, *pS2;
	ULONGLONG	qwMonth, qwDay, qwYear;

	if (strlen(szDate) > 10)
		return(FALSE);
	strcpy(szTemp, szDate);
	pS1 = strchr(szTemp, '/');
	if (!pS1)
		return(FALSE);
	*pS1++ = '\0';
	pS2 = strchr(pS1, '/');
	if (!pS2)
		return(FALSE);
	*pS2++ = '\0';
	if (!ValidateInt(szTemp, 13, &qwMonth) || !qwMonth)
		return(FALSE);
	if (!ValidateInt(pS1, 32, &qwDay) || !qwDay)
		return(FALSE);
	if (!ValidateInt(pS2, 10000, &qwYear) || !qwYear)
		return(FALSE);
	if ((qwMonth == 2) && (qwDay > 28))
	{
		if (((qwYear % 4) != 0) || (qwDay > 29))
			return(FALSE);
	}
	if (qwDay == 31)
	{
		switch (qwMonth)
		{
		case 4: case 6: case 9: case 11:
			return(FALSE);
		}
	}
	return(TRUE);
}

BOOL ValidateBinaryText(PSTR szBlob, DWORD dwMaxSize)
{
	CHAR ch;
	
	if ((dwMaxSize != 0) && ((strlen(szBlob)>>1) > dwMaxSize))
		return(FALSE);

	while (*szBlob)
	{
		ch = *szBlob++;
		if (((ch < '0') || (ch > '9')) &&
			((ch < 'a') || (ch > 'f')) &&
			((ch < 'A') || (ch > 'F')))
			return(FALSE);
	}

	return(TRUE);
}

//
// Some conversion routines
//
#define TO_HEX_DIGIT(x) (((x) >= 10)?(x)-10+'A':(x)+'0')

HRESULT ConvertToBinaryText(PBYTE pbBlob, DWORD cbBlob, PSTR szBinText, DWORD *pchBinText)
{
	DWORD	cbLen = *pchBinText;

	*pchBinText = (cbBlob << 1) + 3;
	if (cbLen < *pchBinText)
		return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

	*szBinText++ = '0';
	*szBinText++ = 'x';
	while (cbBlob--)
	{
		*szBinText++ = TO_HEX_DIGIT((*pbBlob >> 4) & 0xf);
		*szBinText++ = TO_HEX_DIGIT(*pbBlob & 0xf);
		pbBlob++;
	}
	*szBinText = '\0';
	return(S_OK);
}

// ================================================================
// Part 1: Read publisher metadata file and convert to a buffer
//

//
// Publisher metadata file format:
// 
// The publisher metadata file format is a standard .ini file. 
// The file will contain two main sections: [All] and [Indexed]
// The [All] section contains properties that are common for all
// versions (i.e. all languages) of the offered content. Properties
// are expressed in a property=value pair under the section.
//

//
// API to read and parse a publisher-supplied metadata file, and 
// build a consolidated, packed metadata file for submission. The
// packed metadata file will be written out to the specified file
// name
//
HRESULT BuildPackedFileFromMetadataFile(
			PSTR	szMetadataFileName,
			PSTR	szOutputFileName
			)
{
	HRESULT	hr = S_OK;
	HANDLE	hFrom = INVALID_HANDLE_VALUE;
	BYTE	rgbData[MAX_DATA_SIZE];
	BYTE	rgbProps[MAX_DATA_SIZE];
	BYTE	rgbFile[MAX_DATA_SIZE];
	CHAR	szKey[MAX_PATH];
	DWORD	cbData;
	DWORD	cbProps;
	DWORD	cbFile;
	DWORD	cbText;
	PBYTE	pbData = rgbData;
	PBYTE	pbProps;
	PBYTE	pbEnd;
	PBYTE	pbPropEnd;
	PBYTE	pbValueEnd;
	BOOL	fIsDecInt;
	BOOL	fError;

	DWORD	dwCurSection = 0;
	DWORD	dwOrder;
	DWORD	i, j;

	PMD_DESCRIPTION	pmd;
	LARGE_INTEGER	liSize;

	// Load all sections of the metadata file into memory
	cbData = GetPrivateProfileSectionNamesA(
				rgbData, MAX_DATA_SIZE, szMetadataFileName);
	if (cbData <= 2)
	{
		// Well, we read nothing, return error
		sprintf(g_szError, "Unable to read metadata file %s (or file is empty)\n", 
					szMetadataFileName);
		goto InvalidData;
	}

	// Delete the target file, it it exists
	DeleteFile(szOutputFileName);

	// Now parse each section and process the information
	while (cbData)
	{
		// leading NULL means end of names
		if (*pbData == '\0')
			break;

		// Parse the next section name
		fIsDecInt = TRUE;
		for (pbEnd = pbData;
				(cbData > 0) && (*pbEnd != '\0');
				pbEnd++, cbData--)
		{				
			if ((*pbEnd < '0') || (*pbEnd > '9'))
				fIsDecInt = FALSE;
		}
		if (!cbData)
		{
			// String is not terminated!
			sprintf(g_szError, "Invalid data\n");
			goto InvalidData;
		}

		// Process this section
		if (dwCurSection == 0)
		{
			// The first section must be [All]
			if (_stricmp(pbData, MD_COMMON_SECTION_NAME) != 0)
			{
				sprintf(g_szError, "The first section of the metadata file must be [%s]\n",
							MD_COMMON_SECTION_NAME);
				goto InvalidData;
			}
		}
		else
		{
			// Subsequent section names must be a valid decimal integer
			// (maps to description index)
			if (!fIsDecInt)
			{
				sprintf(g_szError, "Section names must be decimal integers (e.g. 12)\n");
				goto InvalidData;
			}

			// Clear the required fields
			for (i = 0; i < g_cmdPropertyDescriptions; i++)
				if (g_rgmdPropertyDescriptions[i].dwFlags & MD_DESCRIPTION_FLAG_INDEXED)
				{
					MD_CLEAR_VALUE_SET(g_rgmdPropertyDescriptions + i);
				}
		}

		printf("Processing section %s ...\n", pbData);

		// Now process the property-value pairs in this section
		pbProps = rgbProps;
		cbProps = GetPrivateProfileSectionA(
					pbData, pbProps, MAX_DATA_SIZE, szMetadataFileName);
		if (cbProps <= 2)
		{
			// Well, we read nothing, return error
			sprintf(g_szError, "Unable to read metadata in section %s\n", pbData);
			goto InvalidData;
		}

		// Parse out the property name and value
		while (cbProps)
		{
			// leading NULL means end of names
			if (*pbProps == '\0')
				break;

			// Parse the next section name
			for (pbPropEnd = pbProps;
					(cbProps > 0) && (*pbPropEnd != '=');
					pbPropEnd++, cbProps--)
				;
			if (cbProps < 3)
			{
				// String is not terminated!
				sprintf(g_szError, "Invalid data\n");
				goto InvalidData;
			}
			*pbPropEnd = '\0';

			// Parse the value to make sure it terminates
			for (cbProps--, pbValueEnd = pbPropEnd + 1;
					(cbProps > 0) && (*pbValueEnd != '\0');
					pbValueEnd++, cbProps--)
				;
			if (!cbProps)
			{
				// String is not terminated!
				sprintf(g_szError, "Invalid data\n");
				goto InvalidData;
			}

			// Process this property
			for (i = 0, pmd = g_rgmdPropertyDescriptions; 
					i < g_cmdPropertyDescriptions; i++, pmd++)
			{
				if (!_stricmp(pbProps, pmd->szPropertyName))
				{
					// Match! Make sure the property is in the right section
					if (dwCurSection == 0)
					{
						// Make sure the property is not indexed
						if (pmd->dwFlags & MD_DESCRIPTION_FLAG_INDEXED)
						{
							sprintf(g_szError, "Indexed property %s cannot be specified in [All] section.\n",
									pmd->szPropertyName);
							goto InvalidData;
						}
					}
					else
					{
						// Make sure the property is indexed
						if ((pmd->dwFlags & MD_DESCRIPTION_FLAG_INDEXED) == 0)
						{
							sprintf(g_szError, "Non-indexed property %s cannot be specified in Indexed section.\n",
									pmd->szPropertyName);
							goto InvalidData;
						}
					}

					// Make sure the property is not computed
					if (pmd->dwFlags & MD_DESCRIPTION_FLAG_COMPUTED)
					{
						sprintf(g_szError, "Unsupported property %s\n", pmd->szPropertyName);
						goto InvalidData;
					}

					printf("    %s = %s\n", pbProps, pbPropEnd + 1);

					// Validate the data
					switch (pmd->mdt)
					{
					case mdtBool:
						if (!ValidateBool(pbPropEnd + 1))
						{
							sprintf(g_szError, "Invalid boolean value for property %s (%s)\n",
									pbProps, pbPropEnd + 1);
							goto InvalidData;
						}
						break;

					case mdtInt8:
						if (!ValidateInt(pbPropEnd + 1, 0x100, NULL))
						{
							sprintf(g_szError, "Invalid 8-bit value for property %s (%s)\n",
									pbProps, pbPropEnd + 1);
							goto InvalidData;
						}
						break;
						
					case mdtInt16:
						if (!ValidateInt(pbPropEnd + 1, 0x10000, NULL))
						{
							sprintf(g_szError, "Invalid 16-bit value for property %s (%s)\n",
									pbProps, pbPropEnd + 1);
							goto InvalidData;
						}
						break;

					case mdtInt32:
						if (!ValidateInt(pbPropEnd + 1, 0x100000000, NULL))
						{
							sprintf(g_szError, "Invalid 32-bit value for property %s (%s)\n",
									pbProps, pbPropEnd + 1);
							goto InvalidData;
						}
						break;

					case mdtDate:
						if (!ValidateDate(pbPropEnd + 1))
						{
							sprintf(g_szError, "Invalid Date value for property %s (%s)\n",
									pbProps, pbPropEnd + 1);
							goto InvalidData;
						}
						break;

					case mdtString:
						if ((pmd->cbMaxSize > 0) && 
							(strlen(pbPropEnd + 1) > pmd->cbMaxSize))
						{
							sprintf(g_szError, "String value too long for property %s (Max is %u characters)\n",
									pbProps, pmd->cbMaxSize);
							goto InvalidData;
						}
						break;

					case mdtBinary:
						if (!ValidateBinaryText(pbPropEnd + 1, pmd->cbMaxSize))
						{
							sprintf(g_szError, "Invalid Hex binary value for property %s\n", pbProps);
							goto InvalidData;
						}
						break;

					case mdtBinaryFromFile:
						// The value is actually the file name
						hFrom = CreateFile(
									pbPropEnd + 1, 
									GENERIC_READ, 
									FILE_SHARE_READ, 
									NULL, 
									OPEN_EXISTING, 
									FILE_ATTRIBUTE_NORMAL, 
									NULL);
						if (hFrom == INVALID_HANDLE_VALUE)
						{
							sprintf(g_szError, "Unable to open binary data file %s for property %s\n",
										pbPropEnd + 1, pbProps);
							hr = HRESULT_FROM_WIN32(GetLastError());
							goto Error;
						}

						if (!GetFileSizeEx(hFrom, &liSize))
						{
							sprintf(g_szError, "Unable to get size of binary data file %s for property %s\n",
										pbPropEnd + 1, pbProps);
							hr = HRESULT_FROM_WIN32(GetLastError());
							goto Error;
						}

						if (liSize.QuadPart > pmd->cbMaxSize)
						{
							sprintf(g_szError, "Binary value too long for property %s (Max is %u characters)\n",
									pbProps, pmd->cbMaxSize);
							goto InvalidData;
						}
						dwOrder = 0;

						do
						{
							// Read in 8k chunks
							if (!ReadFile(hFrom, rgbFile, MAX_BINTEXT_SIZE, &cbFile, NULL))
							{
								sprintf(g_szError, "Unable to load binary data from file %s for property %s\n",
											pbPropEnd + 1, pbProps);
								hr = HRESULT_FROM_WIN32(GetLastError());
								goto Error;
							}

							if (cbFile)
							{
								// Convert to binary text
								cbText = (MAX_BINTEXT_SIZE << 1) + 3;
								ConvertToBinaryText(rgbFile, cbFile, rgbFile + MAX_BINTEXT_SIZE, &cbText);
								
								// Write it out
								if (pmd->dwFlags & MD_DESCRIPTION_FLAG_MULTIPART)
									sprintf(szKey, "%s.%u", pbProps, dwOrder);
								else
								{
									if (dwOrder > 0)
									{
										sprintf(g_szError, "Internal error: multipart required on simple property %s\n", pbProps);
										goto InvalidData;
									}
									sprintf(szKey, "%s", pbProps);
								}
								if (!WritePrivateProfileStringA(
											pbData, szKey, rgbFile + MAX_BINTEXT_SIZE, szOutputFileName))
								{
									sprintf(g_szError, "Unable to write binary data for property %s\n", pbProps);
									hr = HRESULT_FROM_WIN32(GetLastError());
									goto Error;
								}

								dwOrder++;
							}
							
						} while (cbFile);

						CloseHandle(hFrom);
						hFrom = INVALID_HANDLE_VALUE;
						
						break;
					}

					// Write out the data (except for mdtBinaryFromFile)
					if (pmd->mdt != mdtBinaryFromFile)
					{
						if (!WritePrivateProfileStringA(
									pbData, pbProps, pbPropEnd + 1, szOutputFileName))
						{
							sprintf(g_szError, "Unable to write data for property %s\n", pbProps);
							hr = HRESULT_FROM_WIN32(GetLastError());
							goto Error;
						}
					}

					// Mark the property as "set"
					if (MD_IS_VALUE_SET(pmd))
					{
						printf("Warning: property %s already set, overwriting with newer value\n", pbProps);
					}
					MD_MARK_VALUE_SET(pmd);

					break;
				}
			}

			if (i == g_cmdPropertyDescriptions)
			{
				sprintf(g_szError, "Unsupported property %s\n", pbProps);
				goto InvalidData;
			}

			// Skip to next property
			pbProps = pbValueEnd + 1;
		}

		// Validation: make sure all required fields are provided
		fError = FALSE;
		for (i = 0; i < g_cmdPropertyDescriptions; i++)
			if ((g_rgmdPropertyDescriptions[i].dwFlags & MD_DESCRIPTION_FLAG_REQUIRED) &&
				!(g_rgmdPropertyDescriptions[i].dwFlags & MD_DESCRIPTION_FLAG_VALUE_SET))
			{
				if ((!dwCurSection && !(g_rgmdPropertyDescriptions[i].dwFlags & MD_DESCRIPTION_FLAG_INDEXED)) ||
					(dwCurSection && (g_rgmdPropertyDescriptions[i].dwFlags & MD_DESCRIPTION_FLAG_INDEXED)))
				{
					if (!fError)
						printf("ERROR: The following required properties were not specified for [%s]:\n", pbData);
					fError = TRUE;
					printf("    %s\n", g_rgmdPropertyDescriptions[i].szPropertyName);
				}
			}
		if (fError)
			goto InvalidData;

		// Process the next section
		dwCurSection++;
		pbData = pbEnd + 1;		
	}

	// There needs to be at least 2 sections
	if (dwCurSection < 2)
	{
		sprintf(g_szError, "ERROR: There needs to be at least two sections\n");
		goto InvalidData;
	}

Exit:

	if (hFrom != INVALID_HANDLE_VALUE)
		CloseHandle(hFrom);

	// Delete the intermediate file if failed
	if (FAILED(hr))
		DeleteFile(szOutputFileName);

	return(hr);

Error:
	goto Exit;

InvalidData:
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	goto Error;
}

// ==========================================================
// Query builder functions
//
CHAR	g_szData[MAX_DATA_SIZE << 1];
CHAR	g_szValues[MAX_DATA_SIZE << 1];
CHAR	g_szQuery[MAX_DATA_SIZE << 1];

HRESULT BuildQueryHandler(
			PVOID	pvmq,
			DWORD	dwDescriptionIndex,
			PSTR	szMetadataFile,
			FILE	*fOut
			)
{
	HRESULT	hr = S_OK;
	CHAR	szColumns[MAX_BINTEXT_SIZE];
	CHAR	szPropertyName[MAX_PATH];
	DWORD	cbData = 0;
	DWORD	cbColumns = 0;
	DWORD	cbValues = 0;
	DWORD	cbQuery = 0;
	DWORD	cColumns = 0;
	DWORD	cOrder = 0;
	DWORD	i;
	CHAR	chDefault = '\0';
	CHAR	szQuote[2] = { '\0', '\0' };
	BOOL	fDone = TRUE;
	BOOL	fSet;
	BOOL	fMultipart;
	BOOL	fContainsMultipart = FALSE;

	PMD_DESCRIPTION	pmd;
	PMD_QUERY		pmq;

	pmq = (PMD_QUERY)pvmq;

	do
	{
		// Initialize
		cColumns = 0;
		cbColumns = 0;
		cbValues = 0;
		fContainsMultipart = FALSE;

		for (i = 0, pmd = g_rgmdPropertyDescriptions; 
				i < g_cmdPropertyDescriptions; 
				i++, pmd++)
		{
			// Determine if it is a multipart property
			fMultipart = ((pmd->dwFlags & MD_DESCRIPTION_FLAG_MULTIPART) != 0);
		
			// Only select properties that are marked for this query
			if (pmd->dwQuerySet & pmq->mqm)
			{
				// If the field is computed, then look up the default value
				fSet = FALSE;
				if ((pmd->dwFlags & MD_DESCRIPTION_FLAG_COMPUTED) &&
					!(pmd->dwFlags & MD_DESCRIPTION_FLAG_FORCE_LOAD))
				{
					if (!pmd->pmddDefault)
					{
						sprintf(g_szError, "Internal error: Computed value %s without default\n", 
									pmd->szPropertyName);
						goto InvalidData;
					}

					// Use the default value (must be a string)
					strcpy(g_szData, pmd->pmddDefault->sz);
					cbData = pmd->pmddDefault->cch;
				}
				else
				{
					// Figure out the property name
					if (pmd->dwFlags & MD_DESCRIPTION_FLAG_INDEXED)
					{
						sprintf(g_szQuery, "%u", dwDescriptionIndex);

						if (fMultipart)
							sprintf(szPropertyName, "%s.%u", pmd->szPropertyName, cOrder);
						else
							strcpy(szPropertyName, pmd->szPropertyName);
					}
					else
					{
						strcpy(g_szQuery, MD_COMMON_SECTION_NAME);
						strcpy(szPropertyName, pmd->szPropertyName);
					}

					// Read the property from the metadata file
					*g_szData = '\0';
					cbData = GetPrivateProfileStringA(
								g_szQuery,
								szPropertyName,
								&chDefault,
								g_szData,
								MAX_DATA_SIZE,
								szMetadataFile);
					if (!cbData || (*g_szData == '\0'))
					{
						// Field is not present, we will ignore this if the
						// field is not required
						if (pmd->dwFlags & MD_DESCRIPTION_FLAG_REQUIRED)
						{
							// If the query is multipart and if the order is greater than 0,
							// then we got all the data
							if (fMultipart && cOrder)
							{
								// We are done!
								fDone = TRUE;
								cColumns = 0;
								break;
							}
							
							sprintf(g_szError, "Required field %s invalid or not found\n", 
										pmd->szPropertyName);
							goto InvalidData;
						}

						continue;
					}
				}

				// Insert the column-value pair in the buffer
				if (fMultipart)
					fContainsMultipart = TRUE;
				if (((cbColumns + strlen(pmd->szColumnName) + 6) > MAX_DATA_SIZE) ||
					((cbValues + cbData + 6) > MAX_DATA_SIZE))
				{
					sprintf(g_szError, "Internal error: Column/value data too large\n");
					goto InvalidData;
				}

				// Certain data types require single quotes, add if appropriate
				if ((pmd->mdt == mdtDate) || (pmd->mdt == mdtString))
					szQuote[0] = '\'';
				else
					szQuote[0] = '\0';

				cbColumns += sprintf(szColumns + cbColumns, "\n    %s,", pmd->szColumnName);
				cbValues += sprintf(g_szValues + cbValues, "\n    %s%s%s,", 
							szQuote, g_szData, szQuote);
				cColumns++;
			}
		} // for

		// Generate the query
		if (cColumns)
		{
			if (pmq->fIndexed)
			{
				// Need to indicate the description index
				cbColumns += sprintf(szColumns + cbColumns, "\n    i_description_index,");
				cbValues += sprintf(g_szValues + cbValues, "\n    %u,", dwDescriptionIndex);
				cColumns++;
			}
			
			if (fContainsMultipart)
			{
				// Tack on the order field
				cbColumns += sprintf(szColumns + cbColumns, "\n    i_order");
				cbValues += sprintf(g_szValues + cbValues, "\n    %u", cOrder++);
				cColumns++;
				fDone = FALSE;
			}
			else
			{
				// Remove annoying trailing comma
				szColumns[--cbColumns] = '\0';
				g_szValues[--cbValues] = '\0';
			}

			// Format and write out the query
			sprintf(g_szQuery, "insert into %s (%s)\nvalues (%s)\n\n", 
						pmq->szTableName, szColumns, g_szValues);
			if (fprintf(fOut, g_szQuery) <= 0)
			{
				sprintf(g_szError, "Error writing query for %s to file\n", pmq->szTableName);
				hr = HRESULT_FROM_WIN32(GetLastError());
				goto Error;
			}
		}
		else if (!fDone)
		{
			printf("No columns found, skipping query for %s\n", pmq->szTableName);
		}

	} while (!fDone);

Exit:
	return(hr);

Error:
	goto Exit;

InvalidData:
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	goto Error;
}

//
// Define the list of queries
//
MD_QUERY g_rgmqQueries[] =
{
	{ 
		mqmOffers, 
		"t_offers", 
		FALSE, 
		BuildQueryHandler 
	},
	{ 
		mqmTitleOffers, 
		"t_title_offers", 
		FALSE, 
		BuildQueryHandler 
	},
	{
		mqmOfferDescriptions, 
		"t_offer_descriptions", 
		TRUE, 
		BuildQueryHandler 
	},
	{
		mqmOfferDescriptionDetails, 
		"t_offer_description_details", 
		TRUE, 
		BuildQueryHandler 
	},
	{
		mqmOfferLocations, 
		"t_offer_locations", 
		FALSE, 
		BuildQueryHandler 
	}
};

const DWORD g_cmqQueries = sizeof(g_rgmqQueries) / sizeof(MD_QUERY);

//
// API to generate SQL queries from the metadata file
//
#define MAX_INDICES		256

HRESULT GenerateQueriesFromMetadataFile(
			DWORD	dwTitleId,
			DWORD	dwOfferId,
			PSTR	szMetadataFileName,
			PSTR	szQueryFileName
			)
{
	HRESULT	hr = S_OK;
	MD_DATA	rgData[mciMax];
	CHAR	szData[MAX_DATA_SIZE];
	CHAR	szTitleId[10];
	CHAR	szOfferId[10];
	CHAR	szOfferLocations[MAX_PATH];
	DWORD	rgdwDescriptionIndices[MAX_INDICES];
	DWORD	cbData;
	DWORD	dwCurSection = 0;
	DWORD	dwIndex;
	CHAR	*pbData;
	CHAR	*pbEnd;
	DWORD	i, j;
	BOOL	fDupe;
	FILE	*fOut = NULL;

	ULONGLONG	qwValue;
	PMD_QUERY	pmq;

	const PSTR	szRating = "0";
	const PSTR	szCancellable = "0";
	const PSTR	szRank = "0";

	const PSTR	szDownloadIP = "131.107.228.145:80";

	// Set up the default values
	rgData[mciTitleId].sz = szTitleId;
	rgData[mciTitleId].cch = sprintf(szTitleId, "0x%08x", dwTitleId);
	rgData[mciOfferId].sz = szOfferId;
	rgData[mciOfferId].cch = sprintf(szOfferId, "0x%08x", dwOfferId);
	rgData[mciRating].sz = szRating;
	rgData[mciRating].cch = strlen(szRating);
	rgData[mciCancelable].sz = szCancellable;
	rgData[mciCancelable].cch = strlen(szCancellable);
	rgData[mciLocationRank].sz = szRank;
	rgData[mciLocationRank].cch = strlen(szRank);
	rgData[mciOfferLocations].sz = szOfferLocations;
	rgData[mciOfferLocations].cch = 
			sprintf(szOfferLocations, "%s/content/%08x/%08x.xcp", 
						szDownloadIP, dwTitleId, dwOfferId);

	// set the default values
	for (i = 0 ; i < mciMax; i++)
	{
		assert(g_rgmdPropertyDescriptions[i].dwFlags & MD_DESCRIPTION_FLAG_COMPUTED);
		g_rgmdPropertyDescriptions[i].pmddDefault = rgData + i;
	}

	// Load all the section names form the metadata file
	cbData = GetPrivateProfileSectionNamesA(
				szData, MAX_DATA_SIZE, szMetadataFileName);
	if (cbData <= 2)
	{
		// Well, we read nothing, return error
		sprintf(g_szError, "Unable to read metadata file %s (or file is empty)\n", 
					szMetadataFileName);
		goto InvalidData;
	}

	// Delete the target file, it it exists
	DeleteFile(szQueryFileName);

	// Create the query file
	fOut = fopen(szQueryFileName, "w");
	if (!fOut)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		sprintf(g_szError, "Error creating query file %s (%08x)\n",
					szQueryFileName, hr);
		goto Error;
	}

	// Now parse each section and process the information
	pbData = szData;
	while (cbData)
	{
		// leading NULL means end of names
		if (*pbData == '\0')
			break;

		// Parse the next section name
		for (pbEnd = pbData;
				(cbData > 0) && (*pbEnd != '\0');
				pbEnd++, cbData--)
			;
		if (!cbData)
		{
			// String is not terminated!
			sprintf(g_szError, "Invalid data\n");
			goto InvalidData;
		}

		// Process this section
		if (dwCurSection == 0)
		{
			// The first section must be [All]
			if (_stricmp(pbData, MD_COMMON_SECTION_NAME) != 0)
			{
				sprintf(g_szError, "The first section of the metadata file must be [%s]\n", 
							MD_COMMON_SECTION_NAME);
				goto InvalidData;
			}
			dwCurSection++;
		}
		else
		{
			// Subsequent section names must be a valid decimal integer
			// (maps to description index)
			if (!ValidateInt(pbData, 0x100000000, &qwValue))
			{
				sprintf(g_szError, "Section names must be decimal integers (e.g. 12)\n");
				goto InvalidData;
			}

			dwIndex = (DWORD)qwValue;
			fDupe = FALSE;
			if (dwCurSection > 1)
			{
				for (i = 0; i < dwCurSection - 1; i++)
					if (rgdwDescriptionIndices[i] == dwIndex)
					{
						printf("Warning: duplicate description index %u, ignoring second definition\n", dwIndex);
						fDupe = TRUE;
						break;
					}
			}
			if (!fDupe)
			{
				rgdwDescriptionIndices[dwCurSection - 1] = dwIndex;
				dwCurSection++;
			}
		}

		// Next section
		pbData = pbEnd + 1;
	}

	// There needs to be at least 2 sections
	if (dwCurSection < 2)
	{
		sprintf(g_szError, "ERROR: There needs to be at least two sections\n");
		goto InvalidData;
	}
	
	// Loop through our list of queries and generate them
	for (i = 0, pmq = g_rgmqQueries; i < g_cmqQueries; i++, pmq++)
	{
		// Handle it differently depending on whether the query
		// is indexed
		if (pmq->fIndexed)
		{
			// Loop through the description indices
			for (j = 1; j < dwCurSection; j++)
			{
				printf("  * Building indexed Query for %s, description index %u\n",
							pmq->szTableName, rgdwDescriptionIndices[j-1]);
				hr = pmq->pfnBuildQuery((PVOID)pmq, 
						rgdwDescriptionIndices[j-1], szMetadataFileName, fOut);
				if (FAILED(hr))
					break;
			}
		}
		else
		{
			printf("Building Query for %s\n", pmq->szTableName);
			hr = pmq->pfnBuildQuery((PVOID)pmq, 0, szMetadataFileName, fOut);
		}

		if (FAILED(hr))
			goto Error;
	}

Exit:
	if (fOut != NULL);
		fclose(fOut);

	if (FAILED(hr))
		DeleteFile(szQueryFileName);

	return(hr);

Error:
	goto Exit;

InvalidData:
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	goto Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\inc\cryptcab.h ===
//===================================================================
//
// Copyright Microsoft Corporation. All Rights Reserved.
//
//===================================================================

#ifndef __CRYPTCAB_H__
#define __CRYPTCAB_H__

#include <wincrypt.h>
#include <cabinet.h>

#include "xcabinet.h"
#include "cabarc.h"

#ifndef RIP_ON_NOT_TRUE
#if DBG
#define RIP_ON_NOT_TRUE(s, c)
#else
#define RIP_ON_NOT_TRUE(s, c)
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Well-known symmetric key length
//
#define XONLINE_KEY_LENGTH							16

//
// Function to initialize the crypto facilities 
//
HRESULT InitializeCrypto(
			PBYTE		pbPrivateKey,
			DWORD		cbPrivateKey,
			PBYTE		pbPublicKey,
			DWORD		cbPublicKey,
			HCRYPTPROV 	*phCrypto,
			HCRYPTKEY	*phKeyPublic,
			HCRYPTKEY	*phKeyPrivate,
			DWORD		dwFlags
			);

#define CRYPTCAB_FLAG_DONT_CREATE		(0x00000001)			

//
// Function to just generate a string of random numbers
//
HRESULT GenerateRandomBytes(
			HCRYPTPROV	hCrypto,
			PBYTE		pbData,
			DWORD		cbData
			);

//
// Function to generate a confounder
//
HRESULT GenerateConfounder(
			HCRYPTPROV	hCrypto,
			PBYTE		pbConfounder
			);

//
// Function to generate a random symmetric key
//
HRESULT GenerateSymmetricKey(
			HCRYPTPROV	hCrypto,
			PBYTE		pbSymmetricKey
			);

//////////////////////////////////////////////////////////////////////////
//
// SHA1 HMAC calculation
//
//////////////////////////////////////////////////////////////////////////
void shaHmac(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    );

/*
#define RC4_CONFOUNDER_LEN 8

typedef struct _RC4_SHA_HEADER {
    UCHAR Checksum[A_SHA_DIGEST_LEN];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA_HEADER, *PRC4_SHA_HEADER;
*/

static void rc4HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    );

static BOOL rc4HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    );

//
// Function to sign the cabinet file header, and the signature will be verified
// with the supplied public key
//
HRESULT SignCabinetHeader(
			HANDLE		hFile,
			HCRYPTPROV	hCrypto,
			HCRYPTKEY	hKeyPublic
			);

//
// Function to sign the cabinet file header using the DevKit private key, and the 
// signature will be verified with the DevKit public key
//
HRESULT SignCabinetHeaderDevKit(
			HANDLE		hFile
			);

//
// Function to encrypt a Xbox content cabinet file using the specified
// symmetric key.
//
// The cabinet file must be created in the correct Xbox content format
// with apporpriate space reservations for hashes and signatures.
//
HRESULT EncryptCabinetBody(
			HANDLE		hFile,
			HCRYPTPROV	hCrypto,
			PBYTE		pbSymmetricKey,
			DWORD		cbSymmetricKey
			);

//
// Function to encrypt the header portion of the CAB file. This should
// be the last step following placing the digital signature in the slot
//
HRESULT EncryptCabinetHeader(
			HANDLE		hFile,
			HCRYPTPROV	hCrypto,
			PBYTE		pbSymmetricKey,
			DWORD		cbSymmetricKey
			);

//
// Function to encrypt a symmetric key with a supplied public key and place
// the encrypted contents into the signature slot of the package
//
HRESULT EncloseSymmetricKey(
			HANDLE		hFile,
			HCRYPTKEY	hKeyPublic,
			BYTE		*pbSymmetricKey,
			DWORD		cbSymmetricKey
			);

//
// Function to retrieve a symmetric key previously encrypted with a
// public key, whose corresponding private key is supplied.
//
HRESULT RetrieveSymmetricKey(
			HANDLE		hFile,
			HCRYPTKEY	hKeyPrivate,
			BYTE		*pbSymmetricKey,
			DWORD		cbSymmetricKey
			);
			
//
// Function to append a file (by name) to the end of an open file (by handle).
// The appended contents can be optionally encrypted if a symmetric key is provided
//
HRESULT AppendEncryptedFile(
			HANDLE				hFile,
			CHAR				*szFileToAppend,
			HCRYPTPROV			hCrypto,
			PBYTE				pbSymmetricKey,
			DWORD				cbSymmetricKey
			);

//
// Function to create a manifest file and save it to a file named
// XONLINECONTENT_MANIFEST_FILE_NAME. The manifest file will then 
// be signed using the current symmetric key. If this file exists, 
// this function will fail.
//
HRESULT CreateNewManifestFile(
			HCRYPTPROV	hCrypto,
			PBYTE		pbKey,
			CHAR		*szPath
			);

//
// Function to determine if a directory name is a valid title ID.
// If so, then the directory name will be converted to the Title ID 
// value. Otherwise, this function will return ERROR_INVALID_DATA.
//
HRESULT ConvertToTitleId(
			PSTR	szTitleId,
			DWORD	*pdwTitleId
			);

//
// Helper function to convert a symmetric key from a hex string
// to its binary representation
//
HRESULT ConvertSymmetricKeyToBinary(
			CHAR		*szSymmetricKey,
			DWORD		cchSymmetricKey,
			PBYTE		pbSymmetricKey,
			DWORD		*pcbSymmetricKey
			);

//
// Function to create a symmetric key and save it to a named file.
// If this file exists, this function will fail.
//
HRESULT ExportSymmetricKey(
			HCRYPTPROV	hCrypto,
			CHAR		*szFileName,
			PBYTE		pbSymmetricKey,
			DWORD		cbSymmetricKey
			);
			
//
// Function to import a symmetric key from the named file. 
// If this file does not exist or is malformed, this function 
// fails
//
HRESULT ImportSymmetricKey(
			CHAR	*szFileName,
			PBYTE	pbSymmetricKey,
			DWORD	cbSymmetricKey
			);

//
// Function to read key information from a binary file
//
HRESULT ReadPrivatePublicKeyFile(
			PSTR	szFilename,
			PBYTE	*ppbKey,
			DWORD	*pcbKey
			);

//
// Munge a public key exported by Crypto into a format that
// can directly be used by XcVerifyPKCS1Signature (i.e. Xbox 
// client). The exported blob must not have a password.
//
HRESULT MungePublicKey(
            PBYTE pbKey, 
            DWORD cbKey,
            PBYTE *ppbMungedKey, 
            DWORD *pcbMungedKey
            );

//
// Function to rebuild a package received from a publisher. This consists of
// the following steps:
//
// - Make a copy of the original package
// - Extract and decrypt symmetric key from package
// - Extract and decrypt pusblisher-supplied metadata file from package
// - Verify and decrypt package and write out raw cabinet file
// - Re-encrypt package with new symmetric key
// - Export new symmetric key to a file
//
HRESULT RebuildContentPackage(
			CHAR		*szFilePath,
			DWORD		OfferingId,
			DWORD		dwTitleId,
			WORD		wVerHi,
			WORD		wVerLo,
			PBYTE		pbPrivateKey,
			DWORD		cbPrivateKey
			);

#ifdef __cplusplus
}
#endif

#endif  //__CRYPTCAB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\inc\devkitkeys.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    keydata.cpp

Abstract:

    This module contains the key data used to sign an Xbox executable image.

--*/

UCHAR ImgbPrivateKeyData[] = {
    0x52,0x53,0x41,0x32,0x08,0x01,0x00,0x00,
    0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x01,0x00,0x01,0x00,0x9B,0x83,0xD4,0xD5,
    0xDE,0x16,0x25,0x8E,0xE5,0x15,0xF2,0x18,
    0x9D,0x19,0x1C,0xF8,0xFE,0x91,0xA5,0x83,
    0xAE,0xA5,0xA8,0x95,0x3F,0x01,0xB2,0xC9,
    0x34,0xFB,0xC7,0x51,0x2D,0xAC,0xFF,0x38,
    0xE6,0xB6,0x7B,0x08,0x4A,0xDF,0x98,0xA3,
    0xFD,0x31,0x81,0xBF,0xAA,0xD1,0x62,0x58,
    0xC0,0x6C,0x8F,0x8E,0xCD,0x96,0xCE,0x6D,
    0x03,0x44,0x59,0x93,0xCE,0xEA,0x8D,0xF4,
    0xD4,0x6F,0x6F,0x34,0x5D,0x50,0xF1,0xAE,
    0x99,0x7F,0x1D,0x92,0x15,0xF3,0x6B,0xDB,
    0xF9,0x95,0x8B,0x3F,0x54,0xAD,0x37,0xB5,
    0x4F,0x0A,0x58,0x7B,0x48,0xA2,0x9F,0x9E,
    0xA3,0x16,0xC8,0xBD,0x37,0xDA,0x9A,0x37,
    0xE6,0x3F,0x10,0x1B,0xA8,0x4F,0xA3,0x14,
    0xFA,0xBE,0x12,0xFB,0xD7,0x19,0x4C,0xED,
    0xAD,0xA2,0x95,0x8F,0x39,0x8C,0xC4,0x69,
    0x0F,0x7D,0xB8,0x84,0x0A,0x99,0x5C,0x53,
    0x2F,0xDE,0xF2,0x1B,0xC5,0x1D,0x4C,0x43,
    0x3C,0x97,0xA7,0xBA,0x8F,0xC3,0x22,0x67,
    0x39,0xC2,0x62,0x74,0x3A,0x0C,0xB5,0x57,
    0x01,0x3A,0x67,0xC6,0xDE,0x0C,0x0B,0xF6,
    0x08,0x01,0x64,0xDB,0xBD,0x81,0xE4,0xDC,
    0x09,0x2E,0xD0,0xF1,0xD0,0xD6,0x1E,0xBA,
    0x38,0x36,0xF4,0x4A,0xDD,0xCA,0x39,0xEB,
    0x76,0xCF,0x95,0xDC,0x48,0x4C,0xF2,0x43,
    0x8C,0xD9,0x44,0x26,0x7A,0x9E,0xEB,0x99,
    0xA3,0xD8,0xFB,0x30,0xA8,0x14,0x42,0x82,
    0x8D,0xB4,0x31,0xB3,0x1A,0xD5,0x2B,0xF6,
    0x32,0xBC,0x62,0xC0,0xFE,0x81,0x20,0x49,
    0xE7,0xF7,0x58,0x2F,0x2D,0xA6,0x1B,0x41,
    0x62,0xC7,0xE0,0x32,0x02,0x5D,0x82,0xEC,
    0xA3,0xE4,0x6C,0x9B,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0xCD,0xE1,0xAD,0xFB,
    0x97,0x2B,0x02,0xF8,0xC9,0xB4,0xFF,0xF7,
    0x81,0x6C,0xC1,0x91,0x11,0xB8,0x44,0x5A,
    0xF9,0x18,0x6C,0x20,0xB5,0xBC,0xA9,0x17,
    0xD7,0x21,0x76,0x50,0x65,0xA0,0xB5,0x7B,
    0x70,0x57,0x19,0x3C,0xA0,0x03,0x59,0x27,
    0x5D,0xBA,0xE1,0x66,0xEE,0xAF,0xB1,0xFE,
    0x59,0xCE,0x9A,0x80,0x96,0xA8,0x8A,0x0A,
    0x96,0x05,0x92,0x1D,0x43,0xF9,0xB5,0x10,
    0x22,0xE8,0xB7,0xFC,0x93,0x40,0x85,0x63,
    0xF9,0x96,0xEC,0x24,0xE8,0xDE,0xAC,0x65,
    0x17,0xA7,0xD7,0x6C,0xFB,0x0A,0x6E,0x0C,
    0xFA,0xCC,0xF3,0xB1,0xC9,0x13,0x6A,0xB0,
    0x99,0x10,0x1B,0x69,0x7B,0xB0,0x1E,0x36,
    0x9E,0xDD,0x67,0xD4,0xD2,0xE3,0xB1,0x11,
    0xE7,0xEB,0x8C,0x14,0x6F,0xCC,0xCE,0x71,
    0xA5,0x29,0xA2,0xCE,0x00,0x00,0x00,0x00,
    0x07,0xB3,0xF5,0x5E,0x12,0x32,0x0D,0x07,
    0x28,0x09,0x10,0xCB,0x78,0xFD,0xDA,0x92,
    0xB3,0xCB,0x54,0xBF,0x66,0x5F,0x0E,0xCB,
    0x0B,0x66,0x94,0xDA,0x03,0xCB,0xBA,0x05,
    0xA5,0xE6,0x4B,0xBD,0x28,0xC8,0x12,0xB1,
    0x6C,0x6B,0x2A,0x9D,0x86,0xE1,0x57,0xAC,
    0xC1,0x8F,0x1B,0xF7,0x26,0x39,0x3E,0x44,
    0x9E,0x53,0x12,0x25,0x88,0x0A,0x3F,0xE0,
    0xF7,0xA5,0xB8,0xCD,0xF7,0xE3,0x63,0xA8,
    0xF3,0xBD,0x78,0xFE,0x5C,0xB2,0x73,0x84,
    0xE3,0x25,0x9A,0x28,0xE2,0x35,0x55,0xC3,
    0x4B,0xD4,0x17,0x96,0xBE,0xC8,0xC6,0x26,
    0x40,0x2C,0xEC,0x2E,0x54,0x28,0x0E,0xBC,
    0x6B,0xE0,0x0F,0x58,0xB7,0xAB,0x93,0x84,
    0x78,0x47,0x53,0x06,0xD1,0x84,0xBE,0x79,
    0x35,0x13,0xA6,0x75,0x76,0xCF,0x8E,0xC0,
    0x00,0x00,0x00,0x00,0x95,0xAE,0xEA,0x78,
    0x33,0xBB,0x54,0x92,0x45,0xE4,0xA6,0xD1,
    0xFA,0x5E,0xE0,0x94,0x1E,0xAC,0xFA,0x4D,
    0x06,0x48,0xEE,0x92,0x4F,0x19,0x2A,0xD3,
    0xE6,0x45,0x75,0x4E,0x24,0x6B,0xDB,0x18,
    0xF0,0xD0,0x42,0xEA,0x8E,0x2D,0x3F,0xC8,
    0x40,0xB1,0x30,0x59,0x0B,0x3C,0x94,0x6A,
    0x91,0xD8,0x3C,0xDC,0xC5,0xE7,0x84,0xB1,
    0x1D,0x01,0x38,0x62,0x38,0x0E,0x23,0x1E,
    0xCF,0x69,0x7C,0xAD,0xC5,0xA3,0xE2,0x97,
    0x57,0x72,0x65,0x66,0xD2,0x76,0x74,0x58,
    0x1C,0x58,0x6D,0x70,0x18,0x43,0x8D,0x83,
    0x45,0x29,0x23,0xC6,0xA0,0xB8,0x06,0x96,
    0x0E,0xCA,0x2B,0x16,0xF4,0x62,0x48,0x77,
    0x0B,0x1A,0x89,0xA8,0x41,0xB8,0xD6,0xFF,
    0x3A,0x76,0x4B,0xF4,0x2D,0x52,0x96,0xF8,
    0xC6,0x69,0xA9,0x31,0x00,0x00,0x00,0x00,
    0xB3,0xC9,0x4D,0xCE,0x69,0xEF,0x44,0x70,
    0x7E,0x77,0x52,0x14,0x0E,0x71,0x52,0xED,
    0x48,0x6D,0x2C,0xFA,0x77,0x6A,0xA0,0x78,
    0xC8,0x05,0x24,0xB7,0xD3,0x00,0x2E,0x44,
    0x36,0x73,0xE1,0x87,0x1A,0x75,0x4D,0x7F,
    0x62,0xA4,0x0D,0xB2,0x6C,0xB9,0x07,0x5E,
    0xF7,0x9E,0x21,0x42,0xDD,0xC9,0xA2,0x6A,
    0x62,0x96,0xD6,0x4B,0xF2,0x25,0x87,0x75,
    0x4B,0xE4,0x21,0x5F,0x59,0xCD,0x76,0x40,
    0x6D,0x35,0xC1,0xBD,0x6A,0x12,0xED,0x12,
    0x89,0xB5,0xA8,0x58,0xF4,0x15,0x95,0x47,
    0x84,0xFA,0xF1,0xD8,0xE2,0x85,0x9C,0x52,
    0x81,0xDD,0x0B,0x64,0x48,0xF0,0xFC,0x1F,
    0x9A,0x31,0x12,0xA1,0x08,0xD8,0x0C,0xF9,
    0x64,0xAE,0x36,0x04,0x2E,0x1D,0xCE,0xBD,
    0x3F,0xFC,0xEE,0x62,0xB2,0x8B,0x4E,0x4C,
    0x00,0x00,0x00,0x00,0xA3,0x67,0xDF,0xAE,
    0xF0,0x4B,0x5F,0xF5,0x46,0xB1,0x67,0x39,
    0x24,0x29,0xD6,0xE2,0xDF,0x78,0xB1,0x05,
    0x63,0x3F,0x03,0xB0,0xEF,0x01,0x14,0xD8,
    0x42,0x69,0x4D,0x1D,0x87,0xB2,0x4C,0x3B,
    0x21,0xD6,0xA2,0xA1,0xBD,0x5E,0xCB,0xB2,
    0x97,0xBB,0x23,0xD8,0xB6,0x0B,0x68,0x94,
    0x25,0x6F,0x2B,0xFD,0xAD,0x6F,0x33,0x58,
    0xB1,0x77,0x1E,0x77,0x0D,0xF3,0xFC,0xCE,
    0x32,0x58,0x9A,0x15,0xC7,0xCE,0x29,0x5A,
    0x8A,0x0F,0x94,0xF9,0xBD,0x3C,0xAC,0x45,
    0xC3,0x6E,0x3C,0x72,0x95,0x2D,0xDD,0x16,
    0x30,0x5F,0x9D,0xD7,0x1C,0x76,0xA2,0x6C,
    0xCE,0xF0,0x7B,0x35,0xDC,0xD4,0x7E,0xEF,
    0x8E,0x01,0x53,0xE8,0x43,0xF8,0x18,0xDF,
    0xBD,0x25,0x6C,0xBC,0x5E,0x42,0x5D,0xA1,
    0x75,0xC9,0x76,0x7E,0x00,0x00,0x00,0x00,
    0xA9,0x91,0x2B,0xBF,0x27,0x08,0x55,0xC3,
    0xDE,0xC9,0x11,0xF1,0x37,0xCC,0xAA,0xC9,
    0x81,0xC8,0x1D,0xD1,0x12,0xA4,0xB0,0xD6,
    0x65,0xAB,0xBB,0x92,0xD5,0x37,0x6F,0x70,
    0x8C,0xAC,0x30,0xF7,0xA7,0x79,0x10,0xEC,
    0x46,0xA3,0x08,0x2A,0xC4,0x9A,0xD0,0x49,
    0x3A,0x77,0x23,0xF2,0x86,0xEF,0x82,0xE5,
    0xE5,0x7B,0x50,0xED,0xD5,0x43,0xA7,0x33,
    0xED,0xD7,0xA4,0x7A,0xB6,0x35,0x60,0x9D,
    0xB9,0xAD,0x93,0xB4,0xD6,0x3C,0x3D,0xCE,
    0xDF,0x43,0x00,0xC2,0xFC,0xE1,0x5A,0x98,
    0x3A,0x07,0x7B,0xCE,0xA1,0x2F,0xEE,0x01,
    0x70,0x83,0x8B,0xC1,0x3F,0xB7,0x79,0x5E,
    0x3D,0x2F,0xBD,0x9F,0x7D,0xD9,0xBE,0x66,
    0xE2,0x32,0xD4,0x92,0x3D,0xD5,0xE1,0x9F,
    0xE7,0x2F,0x22,0x52,0xCA,0xD1,0xFB,0xBC,
    0x6F,0x80,0x82,0x34,0x1D,0x13,0x07,0x39,
    0x24,0xC7,0x83,0x7D,0x61,0x9A,0x73,0x84,
    0x6B,0x30,0x79,0x10,0xE6,0x1F,0xC7,0xC1,
    0x0F,0x22,0x09,0xAA,0x15,0xB7,0x00,0x1D,
    0x6E,0x1A,0x93,0x4D,0x34,0xC7,0x1B,0x75,
    0x56,0xAF,0x48,0x14,0x6D,0x66,0x9A,0xB6,
    0x8E,0x69,0xFA,0x67,0x95,0x78,0xEC,0xE6,
    0x9E,0xAF,0x43,0xA0,0x3D,0x43,0x6F,0xD1,
    0x49,0x4F,0x35,0x6A,0x9C,0x83,0xB3,0x03,
    0x50,0x40,0x2C,0x4A,0x63,0x2B,0x15,0x43,
    0x6C,0x1E,0xDD,0x9D,0x61,0xA3,0x04,0xBB,
    0x87,0xB6,0x35,0x1A,0x32,0x48,0x0F,0x87,
    0xF3,0xE9,0x32,0x38,0x8B,0x7A,0x5F,0x74,
    0x87,0x47,0x5A,0xEE,0x65,0x5C,0xBC,0x9F,
    0xAF,0xB5,0x88,0xA6,0x77,0x5B,0xA5,0x3A,
    0xB7,0xDB,0x54,0xB4,0xF5,0x78,0x32,0x1E,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00
};

UCHAR ImgbPublicKeyData[] = {
    0x52,0x53,0x41,0x31,0x08,0x01,0x00,0x00,
    0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x01,0x00,0x01,0x00,0x9B,0x83,0xD4,0xD5,
    0xDE,0x16,0x25,0x8E,0xE5,0x15,0xF2,0x18,
    0x9D,0x19,0x1C,0xF8,0xFE,0x91,0xA5,0x83,
    0xAE,0xA5,0xA8,0x95,0x3F,0x01,0xB2,0xC9,
    0x34,0xFB,0xC7,0x51,0x2D,0xAC,0xFF,0x38,
    0xE6,0xB6,0x7B,0x08,0x4A,0xDF,0x98,0xA3,
    0xFD,0x31,0x81,0xBF,0xAA,0xD1,0x62,0x58,
    0xC0,0x6C,0x8F,0x8E,0xCD,0x96,0xCE,0x6D,
    0x03,0x44,0x59,0x93,0xCE,0xEA,0x8D,0xF4,
    0xD4,0x6F,0x6F,0x34,0x5D,0x50,0xF1,0xAE,
    0x99,0x7F,0x1D,0x92,0x15,0xF3,0x6B,0xDB,
    0xF9,0x95,0x8B,0x3F,0x54,0xAD,0x37,0xB5,
    0x4F,0x0A,0x58,0x7B,0x48,0xA2,0x9F,0x9E,
    0xA3,0x16,0xC8,0xBD,0x37,0xDA,0x9A,0x37,
    0xE6,0x3F,0x10,0x1B,0xA8,0x4F,0xA3,0x14,
    0xFA,0xBE,0x12,0xFB,0xD7,0x19,0x4C,0xED,
    0xAD,0xA2,0x95,0x8F,0x39,0x8C,0xC4,0x69,
    0x0F,0x7D,0xB8,0x84,0x0A,0x99,0x5C,0x53,
    0x2F,0xDE,0xF2,0x1B,0xC5,0x1D,0x4C,0x43,
    0x3C,0x97,0xA7,0xBA,0x8F,0xC3,0x22,0x67,
    0x39,0xC2,0x62,0x74,0x3A,0x0C,0xB5,0x57,
    0x01,0x3A,0x67,0xC6,0xDE,0x0C,0x0B,0xF6,
    0x08,0x01,0x64,0xDB,0xBD,0x81,0xE4,0xDC,
    0x09,0x2E,0xD0,0xF1,0xD0,0xD6,0x1E,0xBA,
    0x38,0x36,0xF4,0x4A,0xDD,0xCA,0x39,0xEB,
    0x76,0xCF,0x95,0xDC,0x48,0x4C,0xF2,0x43,
    0x8C,0xD9,0x44,0x26,0x7A,0x9E,0xEB,0x99,
    0xA3,0xD8,0xFB,0x30,0xA8,0x14,0x42,0x82,
    0x8D,0xB4,0x31,0xB3,0x1A,0xD5,0x2B,0xF6,
    0x32,0xBC,0x62,0xC0,0xFE,0x81,0x20,0x49,
    0xE7,0xF7,0x58,0x2F,0x2D,0xA6,0x1B,0x41,
    0x62,0xC7,0xE0,0x32,0x02,0x5D,0x82,0xEC,
    0xA3,0xE4,0x6C,0x9B,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\inc\os.h ===
/*
 * os.h
 */

/* directory separator character */
#define SLASH_CHARACTER '\\'

/* including path names */
#define MAX_FILENAME_LENGTH 256
#define MAX_PATHNAME_LENGTH 256
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\inc\oldnames.h ===
/***    oldnames.h - Conversion of non-standard C runtime names
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1993-1994
 *      All Rights Reserved.
 *
 *      History:
 *          01-Sep-1998 v-sbrend  Initial version
 */

#ifndef INCLUDED_OLDNAMES
#define INCLUDED_OLDNAMES 1

//
// If this isn't a 16-bit generation define some of the older C
// runtime routines as their ANSI counterparts.  This must be included
// after the header file that defines the non-standard routine.
//
// This will alleviate the need to link with oldnames.lib
//

#ifndef BIT16

#define stricmp     _stricmp
#define strnicmp    _strnicmp
#define strdup      _strdup
#define lseek       _lseek
#define read        _read
#define write       _write
#define open        _open
#define close       _close
#define getch       _getch

#endif  // BIT16



#endif  // INCLUDED_OLDNAMES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\inc\metadata.h ===
//===================================================================
//
// Copyright Microsoft Corporation. All Rights Reserved.
//
//===================================================================

#ifndef __METADATA_H__
#define __METADATA_H__

// ==================================================
// Metadata manager
//

//
// Define the section name for the common section
//
#define MD_COMMON_SECTION_NAME		"all"

//
// Define the supported metadata types
//
typedef enum
{
	mdtBool = 0,
	mdtInt8,
	mdtInt16,
	mdtInt32,
	mdtString,
	mdtDate,
	mdtBinary,
	mdtBinaryFromFile,
	mdtMax

} MD_DATA_TYPE;

//
// Define a union for metadata values
//
typedef union
{
	BOOL		f;		// Bool
	BYTE		b;		// Int8
	WORD		w;		// Int16
	DWORD		dw;		// Int32
	struct
	{
		PSTR	sz;		// String
		DWORD	cch;	// Length
	};
	FILETIME	ft;		// Date
	struct 				// Binary data
	{
		PBYTE	pb;		// Data
		DWORD	cb;		// Length
	};

} MD_DATA, *PMD_DATA;

//
// Define a structure for property-schema-description mapping
//
typedef struct
{
	
	PSTR			szPropertyName;	// Name
	PSTR			szColumnName;	// SQL column name
	MD_DATA_TYPE	mdt;			// Data type
	DWORD			cbMaxSize;		// Max size (variable types only)
	DWORD			dwFlags;		// Flags
	DWORD			dwQuerySet;		// Set of queries containing this prop
	PSTR			szDescription;	// Descriptive text
	PMD_DATA		pmddDefault;	// Optional default value

} MD_DESCRIPTION, *PMD_DESCRIPTION;

//
// Define the supported flags for metadat entries
//
// MD_DESCRIPTION_FLAG_INDEXED - The property supports Description
// 		index, which means multiple entries of this property can
//		be found in the metadata file, one for each description index
//
// MD_DESCRIPTION_FLAG_REQUIRED - This property is required
//
// MD_DESCRIPTION_FLAG_FORCE_LOAD - The value must be loaded from the
//		metadata file.
//
// MD_DESCRIPTION_FLAG_MULTIPART - The value contains binary informaiton
//		that has to be broken into 8k chunks.
//
// MD_DESCRIPTION_FLAG_VALUE_SET - Run-time flag indicating that this
//		value was provided by the user data
//
// MD_DESCRIPTION_FLAG_COMPUTED - The property is computed and cannot
//		be set by the publisher metadata
//
#define MD_DESCRIPTION_FLAG_INDEXED			((DWORD)0x00000001)
#define MD_DESCRIPTION_FLAG_REQUIRED		((DWORD)0x00000002)
#define MD_DESCRIPTION_FLAG_FORCE_LOAD		((DWORD)0x00000004)
#define MD_DESCRIPTION_FLAG_MULTIPART		((DWORD)0x00000008)
#define MD_DESCRIPTION_FLAG_VALUE_SET		((DWORD)0x40000000)
#define MD_DESCRIPTION_FLAG_COMPUTED		((DWORD)0x80000000)

#define MD_MARK_VALUE_SET(pmd)	((pmd)->dwFlags |= MD_DESCRIPTION_FLAG_VALUE_SET)
#define MD_CLEAR_VALUE_SET(pmd)	((pmd)->dwFlags &= ~MD_DESCRIPTION_FLAG_VALUE_SET)
#define MD_IS_VALUE_SET(pmd)	(((pmd)->dwFlags & MD_DESCRIPTION_FLAG_VALUE_SET) != 0)

//
// Define what a property index looks like. This value indices back into
// the rgmdPropertyDescriptions array above
//
typedef DWORD MD_PROPERTY_DESCRIPTION_INDEX;

//
// Define what a description index is like
//
typedef DWORD MD_DESCRIPTION_INDEX;

//
// Define a structure for a metadata item
//
typedef struct
{
	MD_PROPERTY_DESCRIPTION_INDEX	mpdi;	// Property
	MD_DESCRIPTION_INDEX			mdi;	// Index (language, etc) 
	MD_DATA							mdd;	// Data

} MD_PROPERTY, *PMD_PROPERTY;

// ==================================================
// Query Generator
//

//
// Define the list of SQL queries that need to be generated
//
typedef enum
{
	mqmOffers = 0x1,
	mqmTitleOffers = 0x2,
	mqmOfferDescriptions = 0x4,
	mqmOfferDescriptionDetails = 0x8,
	mqmOfferLocations = 0x10

} MD_QUERY_MASK;

//
// Define a function prototype to build a query
//
typedef HRESULT (*PFN_BUILD_QUERY)(PVOID, DWORD, PSTR, FILE *);

//
// Define the structure representing a SQL Query
//
typedef struct
{
	MD_QUERY_MASK		mqm;
	PSTR				szTableName;
	BOOL				fIndexed;
	PFN_BUILD_QUERY		pfnBuildQuery;

} MD_QUERY, *PMD_QUERY;

// ====================================================================
// Metadata APIs
//

//
// API to retrieve the last error string
//
PSTR MetadataGetErrorString();

//
// API to read and parse a publisher-supplied metadata file, and 
// build a consolidated, packed metadata file for submission. The
// packed metadata file will be written out to the specified file
// name
//
HRESULT BuildPackedFileFromMetadataFile(
			PSTR	szMetadataFileName,
			PSTR	szOutputFileName
			);

//
// API to generate SQL queries from the metadata file
//
HRESULT GenerateQueriesFromMetadataFile(
			DWORD	dwTitleId,
			DWORD	dwOfferId,
			PSTR	szMetadataFileName,
			PSTR	szQueryFileName
			);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\inc\privkey.c ===
BYTE rgbPrivateKey[] =
{
	0x07, 0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 
	0x52, 0x53, 0x41, 0x32, 0x00, 0x08, 0x00, 0x00, 
	0x01, 0x00, 0x01, 0x00, 0xe7, 0x74, 0xac, 0x08, 
	0xdf, 0x33, 0xc7, 0xb4, 0x30, 0xf7, 0x98, 0x58, 
	0x03, 0x87, 0x92, 0x3e, 0xa6, 0x2b, 0x05, 0x61, 
	0x9c, 0x15, 0xc0, 0x64, 0x0f, 0x01, 0xcd, 0x69, 
	0xcf, 0x93, 0x2e, 0xc9, 0xb8, 0xf4, 0xb7, 0x70, 
	0xb5, 0x33, 0x43, 0x9e, 0x6a, 0x88, 0x4f, 0x14, 
	0x3c, 0x21, 0xcb, 0x6c, 0x91, 0xf4, 0x12, 0x80, 
	0xbe, 0xea, 0xe7, 0xb3, 0x08, 0x05, 0xff, 0x43, 
	0x97, 0xd9, 0x51, 0xee, 0x26, 0x97, 0x71, 0x87, 
	0x39, 0x0a, 0x44, 0xb6, 0xff, 0x14, 0xfc, 0x1d, 
	0x94, 0x48, 0x33, 0xe1, 0xa6, 0xc0, 0xf9, 0xf0, 
	0x67, 0xbc, 0x1c, 0xe6, 0x7e, 0xe2, 0x90, 0xa9, 
	0x61, 0x8a, 0xd5, 0xb0, 0x15, 0xbb, 0xa5, 0xce, 
	0x18, 0x73, 0x6d, 0xfa, 0xbe, 0x76, 0xeb, 0xf8, 
	0x78, 0xe2, 0x5f, 0x59, 0xea, 0x3c, 0x02, 0x0c, 
	0x3f, 0x1a, 0xc3, 0xa3, 0x00, 0x85, 0x7b, 0x29, 
	0x4d, 0x9f, 0x3a, 0xdd, 0x52, 0x1b, 0xce, 0x84, 
	0x48, 0x04, 0x6e, 0x72, 0xad, 0x74, 0x9c, 0x95, 
	0xc0, 0x4b, 0xab, 0xa6, 0x0c, 0x44, 0xd2, 0xde, 
	0x70, 0xa1, 0xfa, 0xdb, 0x3c, 0x97, 0xe5, 0xdc, 
	0x38, 0xa5, 0xac, 0x2b, 0xc5, 0xdf, 0xdc, 0xf6, 
	0x2a, 0xcc, 0x58, 0x7a, 0x19, 0x21, 0xfc, 0x95, 
	0x97, 0xdc, 0x4c, 0x4d, 0xf0, 0xbd, 0x42, 0xf7, 
	0x4b, 0x91, 0x1b, 0xb6, 0xbc, 0x30, 0x13, 0x0b, 
	0xcf, 0xd0, 0x1b, 0xbb, 0x25, 0xd4, 0x13, 0x77, 
	0x16, 0x83, 0x26, 0x54, 0xa6, 0x67, 0xaa, 0x40, 
	0x47, 0xe0, 0x11, 0x54, 0xc9, 0x68, 0x8a, 0xb2, 
	0x50, 0xd0, 0x51, 0x9d, 0xe5, 0x45, 0xc4, 0x95, 
	0xc8, 0x45, 0x2c, 0xae, 0x08, 0x7f, 0x4d, 0xd1, 
	0x6f, 0x34, 0xd2, 0xf1, 0x87, 0x4c, 0x16, 0x97, 
	0x0c, 0xfc, 0xcf, 0xd1, 0xb9, 0x1e, 0x7b, 0x4b, 
	0xa4, 0x02, 0xfd, 0xc6, 0xff, 0x2b, 0xf9, 0xc3, 
	0xee, 0xde, 0x12, 0xd7, 0x8f, 0x2c, 0x3f, 0xd5, 
	0x79, 0x4c, 0xb3, 0x6b, 0x48, 0x5b, 0x86, 0x1d, 
	0x1b, 0x39, 0x26, 0x0d, 0x60, 0x53, 0x2e, 0x1f, 
	0x06, 0x21, 0xc6, 0x12, 0x8b, 0xe7, 0x28, 0x10, 
	0xdc, 0xf4, 0xd0, 0x9c, 0xc7, 0xf1, 0xb4, 0x9a, 
	0xe9, 0x14, 0x14, 0x6e, 0x88, 0x61, 0xbc, 0xe6, 
	0x3d, 0x67, 0x11, 0xb7, 0x5e, 0x29, 0x6f, 0xde, 
	0xb0, 0x87, 0xda, 0x4b, 0x78, 0xa1, 0xac, 0x9c, 
	0x95, 0xd9, 0x70, 0x2d, 0x53, 0xc1, 0x9a, 0x3c, 
	0xe2, 0x7d, 0x76, 0x6d, 0x82, 0xd8, 0x60, 0xd1, 
	0xc4, 0xd2, 0xe4, 0x59, 0x73, 0xf8, 0xc9, 0xa8, 
	0x36, 0x84, 0x40, 0x7d, 0x66, 0x5a, 0x90, 0x74, 
	0x4f, 0x99, 0x89, 0xe4, 0x2d, 0x2e, 0x92, 0x74, 
	0x2f, 0x22, 0x27, 0xc0, 0x92, 0xd5, 0xfe, 0xf4, 
	0x3a, 0x57, 0xea, 0x05, 0x61, 0x5d, 0x74, 0xdd, 
	0xdf, 0x24, 0xc5, 0xa5, 0x4e, 0xe4, 0xf6, 0x7c, 
	0x17, 0xe6, 0x4c, 0xfe, 0x29, 0x8e, 0x39, 0xe5, 
	0x7a, 0x7a, 0x65, 0x72, 0x5f, 0x80, 0x4a, 0x61, 
	0x24, 0xf9, 0x51, 0x61, 0x49, 0xc9, 0xf3, 0xb4, 
	0xab, 0x40, 0xf1, 0xae, 0x31, 0x54, 0x57, 0xc8, 
	0xe0, 0xb9, 0x2e, 0xb2, 0x3d, 0xb7, 0xe6, 0x59, 
	0x9a, 0xc6, 0x50, 0x8a, 0x55, 0x3c, 0xb2, 0x0c, 
	0xc2, 0x3a, 0xe7, 0x19, 0x6d, 0x62, 0xa3, 0x3a, 
	0xae, 0xf4, 0x77, 0xfe, 0x6e, 0x26, 0xb3, 0x82, 
	0x09, 0xb7, 0x14, 0x8b, 0xf6, 0x00, 0x34, 0x72, 
	0x16, 0xbb, 0xc9, 0x0a, 0xba, 0x40, 0x8e, 0x3b, 
	0xec, 0xc1, 0x91, 0x1b, 0x91, 0x45, 0xea, 0x5b, 
	0x7c, 0x3d, 0x83, 0x5d, 0x75, 0x33, 0x55, 0xaa, 
	0x33, 0x9c, 0xc1, 0x9b, 0x7d, 0x1f, 0xcc, 0xc0, 
	0x26, 0xdd, 0xb8, 0x4c, 0x94, 0x69, 0x87, 0xb1, 
	0xb5, 0x47, 0x74, 0xe2, 0x8e, 0xc4, 0x18, 0x89, 
	0x70, 0xcb, 0x1d, 0x83, 0x28, 0xac, 0xdd, 0xa7, 
	0x32, 0xdb, 0x82, 0xd8, 0xf3, 0x0d, 0xc7, 0x59, 
	0x0c, 0x81, 0x40, 0x22, 0xa7, 0x13, 0x9c, 0x50, 
	0x88, 0x2b, 0x2b, 0xe4, 0x96, 0x5b, 0x52, 0xfe, 
	0x8d, 0xcf, 0x21, 0x5e, 0x78, 0xba, 0x69, 0xd7, 
	0x68, 0x86, 0x17, 0xc8, 0x26, 0x08, 0xda, 0x10, 
	0xf9, 0xa3, 0xa7, 0x6e, 0x03, 0x73, 0xd4, 0xa5, 
	0x09, 0x9c, 0x0e, 0xa9, 0x12, 0x1f, 0xc5, 0xa0, 
	0xde, 0xd7, 0xa9, 0x22, 0x17, 0xd6, 0xf2, 0xb6, 
	0xde, 0xdb, 0xe9, 0x42, 0x7c, 0x28, 0x18, 0xa2, 
	0xd5, 0x2c, 0xc9, 0x78, 0xe2, 0x1c, 0x0d, 0xd1, 
	0x74, 0x80, 0x1a, 0xa3, 0xce, 0x0e, 0x83, 0x49, 
	0xaf, 0x79, 0x01, 0x69, 0x24, 0x83, 0xd5, 0x40, 
	0xcc, 0x2b, 0x38, 0x70, 0xd9, 0xbc, 0x2d, 0x93, 
	0x95, 0xf8, 0x74, 0x69, 0x29, 0xc1, 0x2b, 0x0d, 
	0x88, 0xc6, 0xe8, 0x5c, 0x78, 0x2b, 0x23, 0x3d, 
	0xbd, 0x28, 0x76, 0xdc, 0x15, 0xd6, 0xc0, 0xb6, 
	0x35, 0xc6, 0x4d, 0xd7, 0x19, 0xdc, 0xf0, 0x87, 
	0xb5, 0x80, 0x3a, 0xd8, 0x11, 0xdf, 0xe2, 0x9a, 
	0x93, 0x98, 0x5c, 0x05, 0x44, 0x3a, 0x9e, 0x2c, 
	0xdd, 0xab, 0x27, 0x65, 0xff, 0xe1, 0x37, 0x0b, 
	0x5e, 0x75, 0x47, 0x50, 0xcc, 0x06, 0x5c, 0x85, 
	0x04, 0x27, 0xf8, 0x10, 0xaa, 0xd2, 0x1c, 0x57, 
	0x93, 0xf1, 0x44, 0x58, 0x97, 0xd9, 0xcd, 0x20, 
	0xbe, 0x8c, 0xb8, 0xc8, 0x39, 0x14, 0x46, 0xef, 
	0x80, 0x88, 0x77, 0xf0, 0xec, 0xac, 0xea, 0x63, 
	0x93, 0x0c, 0x57, 0x43, 0x4e, 0x48, 0x2f, 0x27, 
	0xaf, 0x82, 0x3b, 0x66, 0xb4, 0x49, 0x6d, 0xf6, 
	0x4d, 0xad, 0xe9, 0x69, 0xc7, 0x04, 0xd9, 0x4d, 
	0x34, 0xd6, 0xf9, 0x4d, 0x6b, 0xf5, 0xc0, 0x5d, 
	0x49, 0xd6, 0x17, 0x69, 0xc6, 0xcf, 0x30, 0x10, 
	0x8b, 0xe4, 0xa8, 0xa9, 0x63, 0xbf, 0x1c, 0x4b, 
	0xf8, 0xad, 0x5e, 0x40, 0x07, 0xab, 0xaa, 0x1e, 
	0x60, 0x27, 0xe9, 0xce, 0x30, 0x52, 0xaf, 0xfc, 
	0xaf, 0x95, 0xda, 0xa1, 0xfc, 0xeb, 0xc3, 0x84, 
	0x2f, 0x1f, 0xea, 0x74, 0xf5, 0xd1, 0x80, 0x68, 
	0x9e, 0xda, 0x74, 0x7a, 0x80, 0x74, 0xbc, 0x76, 
	0xfb, 0x5f, 0x77, 0x6b, 0x10, 0x31, 0x39, 0x5c, 
	0xe1, 0x9c, 0xce, 0x23, 0x2f, 0xd7, 0x6d, 0x7d, 
	0xe9, 0x14, 0x41, 0x80, 0x49, 0x26, 0xc3, 0x5a, 
	0x14, 0x9b, 0xcc, 0x95, 0x77, 0x3b, 0xcc, 0x5c, 
	0xad, 0xf1, 0x2a, 0x8c, 0x94, 0x1d, 0xb0, 0x9e, 
	0x4c, 0x89, 0xd6, 0x4c, 0x71, 0x51, 0x59, 0x7d, 
	0x8a, 0x7b, 0xd2, 0xae, 0x81, 0xc4, 0x62, 0x78, 
	0x37, 0xaf, 0xab, 0xea, 0x33, 0x89, 0x80, 0x11, 
	0x05, 0xb9, 0x77, 0xca, 0x7c, 0xdc, 0x30, 0x54, 
	0x8a, 0x6c, 0xbe, 0x7b, 0xbf, 0x3b, 0x02, 0xc2, 
	0xee, 0x2c, 0x3f, 0xee, 0x6f, 0xc3, 0xf1, 0xb8, 
	0xf4, 0xa2, 0xc3, 0x32, 0xf8, 0x0b, 0x57, 0xb8, 
	0x27, 0x88, 0xd2, 0x28, 0xe1, 0xfd, 0x5e, 0x28, 
	0xa6, 0x96, 0x5e, 0x2f, 0x39, 0xe7, 0xc1, 0xf8, 
	0xc8, 0xa2, 0x88, 0x36, 0x29, 0xb2, 0xbd, 0x9f, 
	0x6d, 0x7c, 0x53, 0x98, 0x15, 0x1e, 0xc1, 0x65, 
	0x9b, 0xe7, 0xc8, 0x2d, 0xd4, 0x87, 0x38, 0xc3, 
	0x06, 0xf3, 0x36, 0x1b, 0x82, 0xf9, 0xdb, 0x55, 
	0xa0, 0x54, 0x90, 0xf5, 0x2c, 0x14, 0x84, 0x98, 
	0xbb, 0xee, 0x58, 0xda, 0x6e, 0x5e, 0xda, 0xd7, 
	0x5b, 0x9b, 0x8e, 0x67, 0x71, 0x91, 0x7e, 0x00, 
	0x02, 0x9c, 0xe2, 0x38, 0x22, 0x2f, 0x4f, 0xc6, 
	0x5a, 0x92, 0x6b, 0xcb, 0xb1, 0x43, 0xbe, 0x9f, 
	0x8a, 0xf4, 0x7a, 0xd5, 0x93, 0xa8, 0xdb, 0x00, 
	0x06, 0x76, 0xb5, 0x7f, 0x5b, 0x79, 0x52, 0x61, 
	0xdc, 0x79, 0xe5, 0x84, 0x3a, 0x3c, 0xbf, 0x58, 
	0xfe, 0x1c, 0x7c, 0x44, 0x03, 0x3c, 0x05, 0xf5, 
	0x60, 0x46, 0xdb, 0x45, 0x5f, 0x07, 0x6b, 0xc8, 
	0xea, 0x00, 0x36, 0xb2, 0xd2, 0xc7, 0x4f, 0x7d, 
	0x8b, 0x72, 0x55, 0xa2, 0x2e, 0xf3, 0xff, 0x25, 
	0xc0, 0x66, 0x67, 0x57, 0x9d, 0xfc, 0xb7, 0x55, 
	0xf1, 0x22, 0x71, 0x79, 0x23, 0x66, 0x28, 0xfb, 
	0x9a, 0xf6, 0x20, 0xf9, 0x31, 0x0d, 0x09, 0x20, 
	0xc5, 0xb5, 0x10, 0xd9, 0x97, 0x59, 0x79, 0x14, 
	0x50, 0x7e, 0x1e, 0x66, 0xcd, 0x39, 0xeb, 0x91, 
	0xd2, 0xa5, 0x63, 0xa4, 0x34, 0xec, 0x08, 0x18, 
	0xa4, 0x7d, 0x06, 0x96, 0x04, 0xa1, 0x91, 0xd7, 
	0x43, 0x12, 0xa1, 0x6e, 0xee, 0x83, 0xfc, 0xe9, 
	0x2a, 0x26, 0xd2, 0xbb, 0x93, 0xad, 0x82, 0x63, 
	0x8c, 0x89, 0x0b, 0x4f, 0x7f, 0xae, 0xf8, 0x1e, 
	0x26, 0x26, 0x57, 0xff, 0x4a, 0xab, 0x20, 0x9d, 
	0x00, 0xb6, 0x90, 0xd4, 0x82, 0x57, 0x9c, 0x4a, 
	0xa7, 0x33, 0x03, 0x45, 0x32, 0x86, 0x74, 0x5f, 
	0xd3, 0x60, 0x88, 0xca, 0x69, 0xd8, 0x0f, 0x4a, 
	0x9b, 0x8e, 0x6c, 0x4f
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\inc\typedefs.h ===
/*
 * typedefs.h
 */
#ifndef _TYPEDEFS_H

#define _TYPEDEFS_H

typedef unsigned char	byte;
typedef unsigned short	ushort;
typedef unsigned long	ulong;

typedef enum
{
	false = 0,
	true = 1
} bool;

typedef enum
{
	COMPRESSION_TYPE_NONE,
	COMPRESSION_TYPE_MSZIP,
	COMPRESSION_TYPE_LZX
} t_compression_type;

#endif /* _TYPEDEFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\inc\pubkey.c ===
BYTE rgbPublicKey[] =
{
	0x06, 0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 
	0x52, 0x53, 0x41, 0x31, 0x00, 0x08, 0x00, 0x00, 
	0x01, 0x00, 0x01, 0x00, 0xe7, 0x74, 0xac, 0x08, 
	0xdf, 0x33, 0xc7, 0xb4, 0x30, 0xf7, 0x98, 0x58, 
	0x03, 0x87, 0x92, 0x3e, 0xa6, 0x2b, 0x05, 0x61, 
	0x9c, 0x15, 0xc0, 0x64, 0x0f, 0x01, 0xcd, 0x69, 
	0xcf, 0x93, 0x2e, 0xc9, 0xb8, 0xf4, 0xb7, 0x70, 
	0xb5, 0x33, 0x43, 0x9e, 0x6a, 0x88, 0x4f, 0x14, 
	0x3c, 0x21, 0xcb, 0x6c, 0x91, 0xf4, 0x12, 0x80, 
	0xbe, 0xea, 0xe7, 0xb3, 0x08, 0x05, 0xff, 0x43, 
	0x97, 0xd9, 0x51, 0xee, 0x26, 0x97, 0x71, 0x87, 
	0x39, 0x0a, 0x44, 0xb6, 0xff, 0x14, 0xfc, 0x1d, 
	0x94, 0x48, 0x33, 0xe1, 0xa6, 0xc0, 0xf9, 0xf0, 
	0x67, 0xbc, 0x1c, 0xe6, 0x7e, 0xe2, 0x90, 0xa9, 
	0x61, 0x8a, 0xd5, 0xb0, 0x15, 0xbb, 0xa5, 0xce, 
	0x18, 0x73, 0x6d, 0xfa, 0xbe, 0x76, 0xeb, 0xf8, 
	0x78, 0xe2, 0x5f, 0x59, 0xea, 0x3c, 0x02, 0x0c, 
	0x3f, 0x1a, 0xc3, 0xa3, 0x00, 0x85, 0x7b, 0x29, 
	0x4d, 0x9f, 0x3a, 0xdd, 0x52, 0x1b, 0xce, 0x84, 
	0x48, 0x04, 0x6e, 0x72, 0xad, 0x74, 0x9c, 0x95, 
	0xc0, 0x4b, 0xab, 0xa6, 0x0c, 0x44, 0xd2, 0xde, 
	0x70, 0xa1, 0xfa, 0xdb, 0x3c, 0x97, 0xe5, 0xdc, 
	0x38, 0xa5, 0xac, 0x2b, 0xc5, 0xdf, 0xdc, 0xf6, 
	0x2a, 0xcc, 0x58, 0x7a, 0x19, 0x21, 0xfc, 0x95, 
	0x97, 0xdc, 0x4c, 0x4d, 0xf0, 0xbd, 0x42, 0xf7, 
	0x4b, 0x91, 0x1b, 0xb6, 0xbc, 0x30, 0x13, 0x0b, 
	0xcf, 0xd0, 0x1b, 0xbb, 0x25, 0xd4, 0x13, 0x77, 
	0x16, 0x83, 0x26, 0x54, 0xa6, 0x67, 0xaa, 0x40, 
	0x47, 0xe0, 0x11, 0x54, 0xc9, 0x68, 0x8a, 0xb2, 
	0x50, 0xd0, 0x51, 0x9d, 0xe5, 0x45, 0xc4, 0x95, 
	0xc8, 0x45, 0x2c, 0xae, 0x08, 0x7f, 0x4d, 0xd1, 
	0x6f, 0x34, 0xd2, 0xf1, 0x87, 0x4c, 0x16, 0x97, 
	0x0c, 0xfc, 0xcf, 0xd1, 0xb9, 0x1e, 0x7b, 0x4b, 
	0xa4, 0x02, 0xfd, 0xc6, 0xff, 0x2b, 0xf9, 0xc3, 
	0xee, 0xde, 0x12, 0xd7, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00 
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\inc\vars.h ===
/* 
 * vars.h
 */

#ifdef MAIN_FILE
#	define EXT
#else
#	define EXT extern
#endif


EXT char				g_dest_dir[MAX_PATHNAME_LENGTH];
EXT long				g_set_id;
EXT cab_file_list_header	g_strip_path_list;
EXT cab_file_list_header    g_list_of_files_to_add;
EXT bool				g_confirm_files;
EXT bool				g_overwrite_files;
EXT bool				g_recurse_subdirs;
EXT bool                g_offline;
EXT bool				g_preserve_path_names;
EXT t_compression_type	g_compression_type;
EXT long				g_compression_memory;
EXT long				g_reserved_cfheader_space;
EXT long				g_reserved_cffolder_space;
EXT long                g_disk_size;
EXT char                g_cabinet_template[MAX_PATHNAME_LENGTH];
EXT char                g_metadata_file_path[MAX_PATHNAME_LENGTH];
EXT bool                g_debug_mode;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\keydump\keydump.c ===
#include <windows.h>
#include <stdio.h>

void _cdecl main(int argc, char **argv)
{
	HANDLE	hFile;
	BYTE	rgbBuffer[4096];
	PBYTE	pBuffer;
	DWORD	cbData;
	DWORD	i = 0;

	hFile = CreateFile(argv[1], 
				GENERIC_READ, 
				FILE_SHARE_READ, 
				NULL,
				OPEN_EXISTING, 
				0, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		fprintf(stderr, "Cannot open file %s\n", argv[1]);
		return;
	}

	while (ReadFile(hFile, rgbBuffer, sizeof(rgbBuffer), &cbData, NULL))
	{
		if (!cbData)
			break;

		pBuffer = rgbBuffer;
		while (cbData--)
		{
			if (!(i++ & 0x7))
				fprintf(stdout, "\n\t");
			fprintf(stdout, "0x%02x, ", *pBuffer++);
		}
	}
	fprintf(stdout, "\n");
}

/*
void main(int argc, char **argv)
{
	int				n, i = 0;
	unsigned char	szBuffer[4096];
	unsigned char	*pBuffer;

	while ((n = fread(szBuffer, 1, sizeof(szBuffer), stdin)) != 0)
	{
		pBuffer = szBuffer;
		while (n--)
		{
			if (!(i++ & 0x7))
				fprintf(stdout, "\n\t");
			fprintf(stdout, "0x%02x, ", *pBuffer++);
		}
	}
	fprintf(stdout, "\n");
}
*/

/*
void main(int argc, char **argv)
{
	int	i, j = 0;

	while ((i = fgetc(stdin)) != EOF)
	{
		if (!(j++ & 0x7))
			fprintf(stdout, "\n\t");
		fprintf(stdout, "0x%02x, ", i & 0xff);
	}
	fprintf(stdout, "\n");
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\RebuildContent\rebuild.c ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "cryptcab.h"

#include "privkey.c"

void PrintUsage()
{
	puts("RebuildContent - Xbox content package rebuilder tool\n");
	puts("Usage:");
	puts("  RebuildContent <Content Path> <Content ID> <Title ID> [<VerHi> <VerLo>]\n");
	puts("<Content Path> - Name and location of content package to rebuild");
	puts("<Content ID> - Hexadecimal Content ID assigned to this package");
	puts("<Title ID> - Optional, Hexadecimal Title ID for which this package is built");
	puts("<VerHi> - Optional, Major version of title after application of patch");
	puts("<VerLo> - Optional, Minor version of title after application of patch\n");
	puts("Notes:");
	puts("This application takes a publisher-supplied content package");
	puts("and extracts all the metadata info and repackages it using a");
	puts("new symmetric key.\n");
	puts("This tool rebuilds content packages for both title content and");
	puts("security updates. If the package is title content, then VerHi,");
	puts("and VerLo must be omitted. For security updates, Title ID");
	puts("VerHi and VerLo must be supplied, and non-zero\n");
	puts("On success, the specified update will be rebuilt into a new file, and");
	puts("the following files will be generated:\n");
	puts("<Content Path>.new - the rebuilt update package.");
	puts("<Content Path>.cab - the raw cabinet file in the original package.");
	puts("<Content Path>.xbx - the metadata file submitted with the package.");
	puts("symmkey.c - the new symmetric key exported as a C file.\n");
	puts("These files are generated in the directory from which this");
	puts("application is launched.\n");
}

int _cdecl main(
			int argc,
			char** argv
			)
{
	HRESULT		hr = S_OK;
	DWORD		dwTitleId = 0;
	DWORD		OfferingId;
	WORD		wVerHi = 0;
	WORD		wVerLo = 0;
	
	if ((argc != 4) && (argc != 6))
		PrintUsage();
	else
	{
		// Parse the Content ID
		if (sscanf(argv[2], "%x", &OfferingId) != 1)
		{
			PrintUsage();
			return(1);
		}
		if (sscanf(argv[3], "%x", &dwTitleId) != 1)
		{
			PrintUsage();
			return(1);
		}
		if (dwTitleId == 0)
		{
			puts("Title ID must be a non-zero hexadecimal value\n");
			PrintUsage();
			return(1);
		}

		if (argc == 6)
		{
			// Convert the other values
			wVerHi = (WORD)atoi(argv[4]);
			wVerLo = (WORD)atoi(argv[5]);
		}
		
		printf("Rebuilding content package %s with the following parameters:\n"
				"    Content ID: 0x%08X\n"
				"    Title ID: 0x%08X\n",
				argv[1], OfferingId, dwTitleId);
		if (argc == 6)
		{
			printf("    Update version: %u.%u\n\n", wVerHi, wVerLo);
		}
		else
			puts("");
		
		hr = RebuildContentPackage(
					argv[1], OfferingId, dwTitleId, wVerHi, wVerLo,
					rgbPrivateKey, sizeof(rgbPrivateKey));
		if (hr == S_OK)
		{
			printf("\nContent package %s successfully processed and rebuilt\n", argv[1]);
		}
		else
		{
			printf("\nFailed to rebuild content package %s. (Error: %u)\n", argv[1], hr);
		}
	}

	return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\inc\rebldcab.h ===
// ---------------------------------------------------------------------------------------
// rebldcab.h
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef __REBLDCAB_H__
#define __REBLDCAB_H__

// ---------------------------------------------------------------------------------------
// Includes
// ---------------------------------------------------------------------------------------

#include <xcrypt.h>

#include "dgstfile.h"

// ---------------------------------------------------------------------------------------

//
// Define a callback context for rebuild processing
//
typedef struct 
{
	HFCI				hfci;
	BYTE				rgbSymmetricKey[XONLINE_KEY_LENGTH];

	// Digest generation stuff
	PDGST_CONTEXT		pdc;

	// Name of temp file
	CHAR				szTempFile[MAX_PATHNAME_LENGTH];

	// File name to be stored in CAB for insert
	CHAR				szFullName[MAX_PATHNAME_LENGTH];

	// Install size of the package. This factors in the fact that
	// files must be an integer number of blocks.
	ULONGLONG			InstallSize;	

} REBLDCBK_CONTEXT, *PREBLDCBK_CONTEXT;


//
// Function to rebuild a cabinet file and insert a digest file
//
HRESULT RebuildCabinetWithDigest(
			char *szOldCabinet,
			char *szNewCabinet,
			DWORD cFiles,
			char *szTempFile,
			char *szDigestFileName,
			PDGSTFILE_IDENTIFIER pdfi,
			PBYTE pbSymmetricKey,
			DWORD cbSymmetricKey,
			LARGE_INTEGER *pliPackageSize,
			LARGE_INTEGER *pliInstallSize
			);

// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\inc\proto.h ===
/*
 * proto.h
 */

/* lists.c */
void init_list(cab_file_list_header *header);

bool concatenate_and_free_list(
   cab_file_list_header *dest_list,
   cab_file_list_header *source_list
);

bool add_to_list(
   cab_file_list_header *header,
   const byte *filename,
   const byte *logical_filename
);

void free_list(cab_file_list_header *header);

struct cab_file_link *filename_in_list(
   const byte *filename,
   const cab_file_list_header *header,
   bool require_exact_match
);

bool file_in_wildcard_list(
   const byte *filename,
   const cab_file_list_header *header
);

bool input_file_list_from_file(
    const byte *filename,
    cab_file_list_header *header
);


/* memory.c */
byte *mem_malloc(long size);
void mem_free(byte *mem);


/* wildcard.c */
bool wildcards_in_string(const byte *wildcard);

bool wildcard_match(const byte *string, const byte *wildcard);

bool expand_wildcard(
   cab_file_list_header *list_header,
   const byte           *wildcard,
   bool                 recurse_subdirs,
   bool                 (*qualifier_function)(const byte *filename)
);


/* fdiutil.c */
char *return_fdi_error_string(FDIERROR err);


/* fciutil.c */
void strip_path(char *filename, char *stripped_name);
int get_percentage(unsigned long a, unsigned long b);
char *return_fci_error_string(FCIERROR err);


/* cmdlist.c */
bool list_cab(char *cabname);


/* cmdext.c */
bool create_directories_for_file(const byte *filename);
bool extract_from_cab(char *cabname, cab_file_list_header *list);


/* cmdnew.c */
bool create_new_cab(char *cabname, cab_file_list_header *files_to_add);


/* callback.c */
FNFCIALLOC(callback_fci_alloc);
FNFCIFREE(callback_fci_free);
FNFCIOPEN(callback_fci_file_open);
FNFCICLOSE(callback_fci_file_close);
FNFCIREAD(callback_fci_file_read);
FNFCIWRITE(callback_fci_file_write);
FNFCISEEK(callback_fci_file_seek);
FNFCIDELETE(callback_fci_file_delete);

FNALLOC(callback_alloc);
FNFREE(callback_free);
FNOPEN(callback_file_open);
FNCLOSE(callback_file_close);
FNREAD(callback_file_read);
FNWRITE(callback_file_write);
FNSEEK(callback_file_seek);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\content\SignContent\signcontent.c ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "cryptcab.h"

#include "privkey.c"
#include "pubkey.c"

void PrintUsage()
{
	puts("SignContent - Xbox content package signing tool\n");
	puts("Usage:");
	puts("  SignContent <package_path>\n");
	puts("<package_path> - Name and location of package to sign\n");
}

int _cdecl main(
			int argc,
			char** argv
			)
{
	HRESULT		hr = S_OK;
	HANDLE		hFile = INVALID_HANDLE_VALUE;
	HCRYPTPROV	hCrypto = 0;
	HCRYPTKEY	hKeyPublic = 0;

	if (argc != 2)
	{
		PrintUsage();
		goto Exit;
	}

	// Initialize the crypto provider
	hr = InitializeCrypto(
				rgbPrivateKey, sizeof(rgbPrivateKey),
				rgbPublicKey, sizeof(rgbPublicKey),
				&hCrypto, &hKeyPublic, NULL, 0);
	if (hr != S_OK)
	{
		printf("Filaed to initialize crypto (%u)\n", hr);
		goto Exit;
	}

	// Open the pacakge
	hFile = CreateFile(
				argv[1],
				GENERIC_READ | GENERIC_WRITE, 
				FILE_SHARE_READ, 
				NULL, 
				OPEN_EXISTING, 
				FILE_ATTRIBUTE_NORMAL, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hr = GetLastError();
		printf("Cannot open package %s (%u)\n", argv[1], hr);
		goto Exit;
	}

	// Just sign the package with the DevKit key
	// hr = SignCabinetHeaderDevKit(hFile);
	hr = SignCabinetHeader(hFile, hCrypto, hKeyPublic);
	if (hr == S_OK)
	{
		printf("Content package %s successfully signed.\n", argv[1]);
	}
	else
	{
		printf("Failed to sign content package %s. (Error: %u)\n", argv[1], hr);
	}

Exit:

	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\crt32.inc ===
LINKER_FLAGS=-ignore:4006
LIBRARIAN_FLAGS=-ignore:4006
MSC_WARNING_LEVEL=/W3 /WX


CRTBASE=$(BASEDIR)\private\sdktools\crt

INCLUDES=$(CRTBASE)\crtw32\h;$(BASEDIR)\private\ntos\inc

386_STDCALL=0

USER_C_FLAGS=$(USER_C_FLAGS) /Zc:wchar_t

!if $(FREEBUILD)
DEBUG_CDEFINE = -DNDEBUG -D_XBSTRICT
D=
STRICT = -D_XBSTRICT
CRT_OPT=/Oxs
!else
DEBUG_CDEFINE = -D_DEBUG -D_RTC
D=d
CRT_OPT=/Od
STRICT =
!endif

TARGETTYPE=LIBRARY
TARGETPATH=obj

!if "$(CRTLIBTYPE)" == "MT"

TARGETNAMESUFFIX=mt
TARGETTYPE=LIBRARY
MTOPTION=-D_MT -D_BUILD_FOR_MT
ASM_DEFINES1=-D_WIN32
C_DEFINES1=$(DEBUG_CDEFINE)
386_OPTIMIZATION=$(CRT_OPT)

!elseif "$(CRTLIBTYPE)" == "ST"

TARGETNAMESUFFIX=
TARGETTYPE=LIBRARY
MTOPTION=
ASM_DEFINES1=-D_WIN32
C_DEFINES1=$(DEBUG_CDEFINE)
386_OPTIMIZATION=$(CRT_OPT)

!elseif "$(CRTLIBTYPE)" == "NT"

TARGETNAMESUFFIX=nt
TARGETTYPE=LIBRARY
MTOPTION=
LIBC_DEFINES=-DNDEBUG
C_DEFINES1=-D_NTSUBSET_ -D_NTSYSTEM_
ASM_DEFINES1=-D_NTSUBSET_ -D_NTSYSTEM_ -D_WIN32

!else
!ERROR Unsupported Library CRTLIBTYPE: $(CRTLIBTYPE)
!endif

#C_DEFINES1 = $(C_DEFINES1) -DNT_BUILD -D_CRTBLD -DWINHEAP -D_XBOX -DNOKERNELAPIINLINES
C_DEFINES1 = $(C_DEFINES1) $(STRICT) -DNT_BUILD -D_CRTBLD -DWINHEAP -D_XBOX -DNOKERNELAPIINLINES -DNOSBHEAP
ASM_DEFINES1 = $(ASM_DEFINES1) -DNT_BUILD -D_CRTBLD -D_XBOX

NOT_UNICODE = 1

# Standard MBCS build

MBCS_DEFINES=-D_MBCS -D_MB_MAP_DIRECT -D_KANJI

C_DEFINES=$(C_DEFINES1) $(MTOPTION) $(MBCS_DEFINES)
ASM_DEFINES=$(ASM_DEFINES1) $(MTOPTION) $(MBCS_DEFINES)
USE_NATIVE_EH=1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\awxapi\direct.c ===
/*
 *
 * direct.c
 *
 * XAPI a/w conversion
 *
 * Copyright (C) 2000 Microsoft Corporation
 *
 */

#include <ocharint.h>
#include <oscalls.h>

BOOL
__crtCreateDirectory(
    IN LPCTSTR lpPathName,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
	OCHAR szPathName[MAX_PATH];

	szPathName[0] = 0;
	tcstoocs(szPathName, lpPathName, OSZ_LEN(szPathName));
	szPathName[OSZ_LEN(szPathName) - 1] = 0;
	return CreateDirectory(szPathName, lpSecurityAttributes);
}

BOOL
__crtRemoveDirectory(
    IN LPCTSTR lpPathName
    )
{
	OCHAR szPathName[MAX_PATH];

	szPathName[0] = 0;
	tcstoocs(szPathName, lpPathName, OSZ_LEN(szPathName));
	szPathName[OSZ_LEN(szPathName) - 1] = 0;
	return RemoveDirectory(szPathName);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\awxapi\filecrea.c ===
/*
 *
 * filecrea.c
 *
 * XAPI a/w conversion
 *
 * Copyright (C) 2000 Microsoft Corporation
 *
 */

#include <ocharint.h>
#include <oscalls.h>

HANDLE
__crtCreateFile(
    IN LPCTSTR lpFileName,
    IN DWORD dwDesiredAccess,
    IN DWORD dwShareMode,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    IN DWORD dwCreationDisposition,
    IN DWORD dwFlagsAndAttributes,
    IN HANDLE hTemplateFile
    )
{
	OCHAR szPathName[MAX_PATH];

	szPathName[0] = 0;
	tcstoocs(szPathName, lpFileName, OSZ_LEN(szPathName));
	szPathName[OSZ_LEN(szPathName) - 1] = 0;
	return CreateFile(
		szPathName,
		dwDesiredAccess,
		dwShareMode,
		lpSecurityAttributes,
		dwCreationDisposition,
		dwFlagsAndAttributes,
		hTemplateFile
		);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\awxapi\fileatt.c ===
/*
 *
 * fileatt.c
 *
 * XAPI a/w conversion
 *
 * Copyright (C) 2000 Microsoft Corporation
 *
 */

#include <ocharint.h>
#include <oscalls.h>

DWORD
__crtGetFileAttributes(
    IN LPCTSTR lpFileName
    )
{
	OCHAR szPathName[MAX_PATH];

	szPathName[0] = 0;
	tcstoocs(szPathName, lpFileName, OSZ_LEN(szPathName));
	szPathName[OSZ_LEN(szPathName) - 1] = 0;
	return GetFileAttributes(szPathName);
}

BOOL
__crtSetFileAttributes(
    IN LPCTSTR lpFileName,
    IN DWORD dwFileAttributes
    )
{
	OCHAR szPathName[MAX_PATH];

	szPathName[0] = 0;
	tcstoocs(szPathName, lpFileName, OSZ_LEN(szPathName));
	szPathName[OSZ_LEN(szPathName) - 1] = 0;
	return SetFileAttributes(szPathName, dwFileAttributes);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\awxapi\filedel.c ===
/*
 *
 * filedel.c
 *
 * XAPI a/w conversion
 *
 * Copyright (C) 2000 Microsoft Corporation
 *
 */

#include <ocharint.h>
#include <oscalls.h>

BOOL
__crtDeleteFile(
    IN LPCTSTR lpFileName
    )
{
	OCHAR szPathName[MAX_PATH];

	szPathName[0] = 0;
	tcstoocs(szPathName, lpFileName, OSZ_LEN(szPathName));
	szPathName[OSZ_LEN(szPathName) - 1] = 0;
	return DeleteFile(szPathName);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\awxapi\find.c ===
/*
 *
 * direct.c
 *
 * XAPI a/w conversion
 *
 * Copyright (C) 2000 Microsoft Corporation
 *
 */

#include <ocharint.h>
#include <oscalls.h>

typedef struct _WIN32_FIND_DATAT {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    TCHAR cFileName[ MAX_PATH ];
    TCHAR cAlternateFileName[ 14 ];
} WIN32_FIND_DATAT, *PWIN32_FIND_DATAT, *LPWIN32_FIND_DATAT;

static void ConvertWFD(PWIN32_FIND_DATAT pwfdOut, PWIN32_FIND_DATA pwfdIn)
{
	memcpy(pwfdOut, pwfdIn, (int)&(((PWIN32_FIND_DATA)NULL)->cFileName[0]));
	pwfdOut->cFileName[0] = 0;
	ocstotcs(pwfdOut->cFileName, pwfdIn->cFileName,
		TSZ_LEN(pwfdOut->cFileName));
	pwfdOut->cFileName[TSZ_LEN(pwfdOut->cFileName)-1] = 0;
	pwfdOut->cAlternateFileName[0] = 0;
	ocstotcs(pwfdOut->cAlternateFileName, pwfdIn->cAlternateFileName,
		TSZ_LEN(pwfdOut->cAlternateFileName));
	pwfdOut->cAlternateFileName[TSZ_LEN(pwfdOut->cAlternateFileName)-1] = 0;
}

HANDLE
__crtFindFirstFile(
    IN LPCTSTR lpFileName,
    OUT LPWIN32_FIND_DATAT lpFindFileData
    )
{
	OCHAR szPathName[MAX_PATH];
	WIN32_FIND_DATA wfd;
	HANDLE hRet;

	szPathName[0] = 0;
	tcstoocs(szPathName, lpFileName, OSZ_LEN(szPathName));
	szPathName[OSZ_LEN(szPathName) - 1] = 0;
	hRet = FindFirstFile(szPathName, &wfd);
	if(hRet != INVALID_HANDLE_VALUE)
		ConvertWFD(lpFindFileData, &wfd);
	return hRet;
}

BOOL
__crtFindNextFile(
    IN HANDLE hFindFile,
    OUT LPWIN32_FIND_DATAT lpFindFileData
    )
{
	WIN32_FIND_DATA wfd;
	BOOL fRet;

	fRet = FindNextFile(hFindFile, &wfd);
	if(fRet)
		ConvertWFD(lpFindFileData, &wfd);
	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\awxapi\sources.inc ===
MAJORCOMP=crt
MINORCOMP=awxapi

TARGETNAME=awxapi

!INCLUDE ..\..\crt32.inc

SOURCES=\
    ..\direct.c \
    ..\fileatt.c \
    ..\filecrea.c \
    ..\filedel.c \
    ..\filemove.c \
    ..\find.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\awxapi\filemove.c ===
/*
 *
 * filemove.c
 *
 * XAPI a/w conversion
 *
 * Copyright (C) 2000 Microsoft Corporation
 *
 */

#include <ocharint.h>
#include <oscalls.h>

BOOL
__crtMoveFile(
    IN LPCTSTR lpExistingFileName,
    IN LPCTSTR lpNewFileName
    )
{
	OCHAR szEPathName[MAX_PATH];
	OCHAR szNPathName[MAX_PATH];

	szEPathName[0] = 0;
	tcstoocs(szEPathName, lpExistingFileName, OSZ_LEN(szEPathName));
	szEPathName[OSZ_LEN(szEPathName) - 1] = 0;
	szNPathName[0] = 0;
	tcstoocs(szNPathName, lpNewFileName, OSZ_LEN(szNPathName));
	szNPathName[OSZ_LEN(szNPathName) - 1] = 0;
	return MoveFile(szEPathName, szNPathName);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\atof.c ===
/***
*atof.c - convert char string to floating point number
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts a character string into a floating point number.
*
*Revision History:
*       09-09-87  RKW   written
*       04-13-87  JCR   added const to declaration
*       11-09-87  BCM   different interface under ifdef MTHREAD
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-24-88  PHG   Merged DLL and normal versions
*       08-18-88  PHG   now calls isspace to process all kinds of whitespce
*       10-04-88  JCR   386: Removed 'far' keyword
*       11-20-89  JCR   atof() is always _cdecl in 386 (not pascal)
*       03-05-90  GJF   Fixed calling type, added #include <cruntime.h>,
*                       removed #include <register.h>, removed some redundant
*                       prototypes, removed some leftover 16-bit support and
*                       fixed the copyright. Also, cleaned up the formatting
*                       a bit.
*       07-20-90  SBM   Compiles cleanly with -W3 (added/removed appropriate
*                       #includes)
*       08-01-90  SBM   Renamed <struct.h> to <fltintrn.h>
*       09-27-90  GJF   New-style function declarator.
*       10-21-92  GJF   Made char-to-int conversion unsigned.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       12-15-98  GJF   Changes for 64-bit size_t.
*
*******************************************************************************/

#include <stdlib.h>
#include <math.h>
#include <cruntime.h>
#include <fltintrn.h>
#include <string.h>
#include <ctype.h>

/***
*double atof(nptr) - convert string to floating point number
*
*Purpose:
*       atof recognizes an optional string of whitespace, then
*       an optional sign, then a string of digits optionally
*       containing a decimal point, then an optional e or E followed
*       by an optionally signed integer, and converts all this to
*       to a floating point number.  The first unrecognized
*       character ends the string.
*
*Entry:
*       nptr - pointer to string to convert
*
*Exit:
*       returns floating point value of character representation
*
*Exceptions:
*
*******************************************************************************/

double __cdecl atof(
        REG1 const char *nptr
        )
{

#ifdef  _MT
        struct _flt fltstruct;      /* temporary structure */
#endif

        /* scan past leading space/tab characters */

        while ( isspace((int)(unsigned char)*nptr) )
                nptr++;

        /* let _fltin routine do the rest of the work */

#ifdef  _MT
        return( *(double *)&(_fltin2( &fltstruct, nptr, (int)strlen(nptr), 0, 0 )->
        dval) );
#else
        return( *(double *)&(_fltin( nptr, (int)strlen(nptr), 0, 0 )->dval) );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\fcvt.c ===
/***
*fcvt.c - convert floating point value to string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Converts a floating point value to a string.
*
*Revision History:
*	09-09-83  RKW	written
*	09-14-84  DFW	fixed problems with buffer overflow and
*			streamlined the code
*	11-09-87  BCM	different interface under ifdef MTHREAD
*	11-19-87  WAJ	fcvt now uses emulator data area for buffer
*	12-11-87  JCR	Added "_LOAD_DS" to declaration
*	05-24-88  PHG	Merged DLL and normal versions
*	10-04-88  JCR	386: Removed 'far' keyword
*	10-20-88  JCR	Changed 'DOUBLE' to 'double' for 386
*	03-02-90  GJF	Added #include <cruntime.h>. Removed some (now) useless
*			preprocessor directives. Also, fixed copyright.
*	03-06-90  GJF	Fixed calling type, removed some leftover 16-bit
*			support.
*	03-23-90  GJF	Made _fpcvt() _CALLTYPE4 and removed prototype for
*			_fptostr() (now in struct.h).
*	08-01-90  SBM	Renamed <struct.h> to <fltintrn.h>
*	09-27-90  GJF	New-style function declarators.
*	01-21-91  GJF	ANSI naming.
*	10-03-91  JCR	Fixed mthread buffer allocation
*	02-16-93  GJF	Changed for new _getptd().
*	04-06-93  SKS	Replace _CRTAPI* with _cdecl
*	08-05-94  JWM	Insure that _ecvt returns no more than ndigits.
*	09-06-94  CFW   Remove Cruiser support.
*	09-06-94  CFW	Replace MTHREAD with _MT.
*	01-10-95  CFW	Debug CRT allocs.
*	09-05-00  GB    Changed the defination of fltout functions. Use DOUBLE 
*	                instead of double
*
*******************************************************************************/

#include <cruntime.h>
#include <fltintrn.h>
#include <cvt.h>
#include <mtdll.h>
#include <stdlib.h>
#include <dbgint.h>

/*
 * The static character array buf[CVTBUFSIZE] is used by the _fpcvt routine
 * (the workhorse for _ecvt and _fcvt) for storage of its output.  The routine
 * gcvt expects the user to have set up their own storage.  CVTBUFSIZE is set
 * large enough to accomodate the largest double precision number plus 40
 * decimal places (even though you only have 16 digits of accuracy in a
 * double precision IEEE number, the user may ask for more to effect 0
 * padding; but there has to be a limit somewhere).
 */

/*
 * define a maximum size for the conversion buffer.  It should be at least
 * as long as the number of digits in the largest double precision value
 * (?.?e308 in IEEE arithmetic).  We will use the same size buffer as is
 * used in the printf support routine (_output)
 */

#ifdef	_MT
char * __cdecl _fpcvt(STRFLT, int, int *, int *);
#else
static char * __cdecl _fpcvt(STRFLT, int, int *, int *);
static char buf[CVTBUFSIZE];
#endif

/***
*char *_fcvt(value, ndec, decpr, sign) - convert floating point to char string
*
*Purpose:
*	_fcvt like _ecvt converts the value to a null terminated
*	string of ASCII digits, and returns a pointer to the
*	result.  The routine prepares data for Fortran F-format
*	output with the number of digits following the decimal
*	point specified by ndec.  The position of the decimal
*	point relative to the beginning of the string is returned
*	indirectly through decpt.  The correct digit for Fortran
*	F-format is rounded.
*	NOTE - to avoid the possibility of generating floating
*	point instructions in this code we fool the compiler
*	about the type of the 'value' parameter using a struct.
*	This is OK since all we do is pass it off as a
*	parameter.
*
*Entry:
*	double value - number to be converted
*	int ndec - number of digits after decimal point
*
*Exit:
*	returns pointer to the character string representation of value.
*	also, the output is written into the static char array buf.
*	int *decpt - pointer to int with pos. of dec. point
*	int *sign - pointer to int with sign (0 = pos, non-0 = neg)
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl _fcvt (
	double value,
	int ndec,
	int *decpt,
	int *sign
	)
{
	REG1 STRFLT pflt;
    DOUBLE *pdvalue = (DOUBLE *)&value;

#ifdef	_MT
	struct _strflt strfltstruct;
	char resultstring[21];

	/* ok to take address of stack struct here; fltout2 knows to use ss */
	pflt = _fltout2( *pdvalue, &strfltstruct, resultstring );


#else
	pflt = _fltout( *pdvalue );
#endif

	return( _fpcvt( pflt, pflt->decpt + ndec, decpt, sign ) );
}


/***
*char *_ecvt( value, ndigit, decpt, sign ) - convert floating point to string
*
*Purpose:
*	_ecvt converts value to a null terminated string of
*	ASCII digits, and returns a pointer to the result.
*	The position of the decimal point relative to the
*	begining of the string is stored indirectly through
*	decpt, where negative means to the left of the returned
*	digits.  If the sign of the result is negative, the
*	word pointed to by sign is non zero, otherwise it is
*	zero.  The low order digit is rounded.
*
*Entry:
*	double value - number to be converted
*	int ndigit - number of digits after decimal point
*
*Exit:
*	returns pointer to the character representation of value.
*	also the output is written into the statuc char array buf.
*	int *decpt - pointer to int with position of decimal point
*	int *sign - pointer to int with sign in it (0 = pos, non-0 = neg)
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl _ecvt (
	double value,
	int ndigit,
	int *decpt,
	int *sign
	)
{

	char *retbuf;
    DOUBLE *pdvalue = (DOUBLE *)&value;

#ifdef	_MT
	REG1 STRFLT pflt;

	struct _strflt strfltstruct;	    /* temporary buffers */
	char resultstring[21];

	/* ok to take address of stack struct here; fltout2 knows to use ss */
	pflt = _fltout2( *pdvalue, &strfltstruct, resultstring );

	retbuf = _fpcvt( pflt, ndigit, decpt, sign );

#else
	retbuf = _fpcvt( _fltout(*pdvalue), ndigit, decpt, sign );
#endif

	/* _fptostr() occasionally returns an extra character in the buffer ... */

	if (retbuf[ndigit])
		retbuf[ndigit] = '\0';
	return( retbuf );
}


/***
*char *_fpcvt() - gets final string and sets decpt and sign	[STATIC]
*
*Purpose:
*	This is a small common routine used by [ef]cvt.  It calls fptostr
*	to get the final string and sets the decpt and sign indicators.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

#ifdef	_MT
char * __cdecl _fpcvt (
#else
static char * __cdecl _fpcvt (
#endif
	REG2 STRFLT pflt,
	REG3 int digits,
	int *decpt,
	int *sign
	)
{

#ifdef	_MT

	/* use a per-thread buffer */

	char *buf;

	_ptiddata ptd;

	ptd = _getptd();
	if ( ptd->_cvtbuf == NULL )
		if ( (ptd->_cvtbuf = _malloc_crt(CVTBUFSIZE)) == NULL )
			return(NULL);
	buf = ptd->_cvtbuf;

#endif	/* _MT */


	/* make sure we don't overflow the buffer size.  If the user asks for
	 * more digits than the buffer can handle, truncate it to the maximum
	 * size allowed in the buffer.	The maximum size is CVTBUFSIZE - 2
	 * since we useone character for overflow and one for the terminating
	 * null character.
	 */

	_fptostr(buf, (digits > CVTBUFSIZE - 2) ? CVTBUFSIZE - 2 : digits, pflt);

	/* set the sign flag and decimal point position */

	*sign = (pflt->sign == '-') ? 1 : 0;
	*decpt = pflt->decpt;
	return(buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\gcvt.c ===
/***
*gcvt.c - convert floating point number to character string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Converts floating point number into character string representation.
*
*Revision History:
*	09-09-93  RKW	written
*	11-09-87  BCM	different interface under ifdef MTHREAD
*	12-11-87  JCR	Added "_LOAD_DS" to declaration
*	05-24-88  PHG	Merged DLL and normal versions
*	10-20-88  JCR	Changed 'DOUBLE' to 'double' for 386
*	06-27-89  PHG	Changed "ndec" to "ndec-1" to correct significant
*			digits in exponential format (C6 bug #2124)
*	03-05-90  GJF	Fixed calling type, added #include <cruntime.h>,
*			removed #include <register.h>, removed redundant
*			prototypes, removed some leftover 16-bit support and
*			fixed the copyright. Also, cleaned up the formatting
*			a bit.
*	07-20-90  SBM	Compiles cleanly with -W3 (added/removed appropriate
*			#includes)
*	08-01-90  SBM	Renamed <struct.h> to <fltintrn.h>
*	09-27-90  GJF	New-style function declarators.
*	01-21-91  GJF	ANSI naming.
*	08-13-92  SKS	An old bug that was fixed in C 6.0 but that did not
*			make it into C 7.0, an off by 1 error when switching
*			from fixed point to scientific notation
*	04-06-93  SKS	Replace _CRTAPI* with _cdecl
*	09-06-94  CFW	Replace MTHREAD with _MT.
*	12-21-95  JWM	Replaced '.' with *__decimal_point; includes nlsint.h.
*	09-05-00  GB    Changed the defination of fltout functions. Use DOUBLE 
*	                instead of double
*
*******************************************************************************/

#include <cruntime.h>
#include <fltintrn.h>
#include <internal.h>
#include <nlsint.h>

/***
*double _gcvt(value, ndec, buffer) - convert floating point value to char
*	string
*
*Purpose:
*	_gcvt converts the value to a null terminated ASCII string
*	buf.  It attempts to produce ndigit significant digits
*	in Fortran F format if possible, ortherwise E format,
*	ready for printing.  Trailing zeros may be suppressed.
*	No error checking or overflow protection is provided.
*	NOTE - to avoid the possibility of generating floating
*	point instructions in this code we fool the compiler
*	about the type of the 'value' parameter using a struct.
*	This is OK since all we do is pass it off as a
*	parameter.
*
*Entry:
*	value - double - number to be converted
*	ndec - int - number of significant digits
*	buf - char * - buffer to place result
*
*Exit:
*	result is written into buffer; it will be overwritten if it has
*	not been made big enough.
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl _gcvt (
	double value,
	int ndec,
	char *buf
	)
{

#ifdef	_MT
	struct _strflt strfltstruct;	/* temporary buffers */
	char   resultstring[21];
#endif

	STRFLT string;
	int    magnitude;
	char   *rc;
    DOUBLE *pdvalue = (DOUBLE *)&value;

	REG1 char *str;
	REG2 char *stop;

	/* get the magnitude of the number */

#ifdef	_MT
	string = _fltout2( *pdvalue, &strfltstruct, resultstring );
#else
	string = _fltout( *pdvalue );
#endif

	magnitude = string->decpt - 1;

	/* output the result according to the Fortran G format as outlined in
	   Fortran language specification */

	if ( magnitude < -1  ||  magnitude > ndec-1 )
		/* then  Ew.d  d = ndec */
		rc = str = _cftoe( &value, buf, ndec-1, 0);
	else
		/* Fw.d  where d = ndec-string->decpt */
		rc = str = _cftof( &value, buf, ndec-string->decpt );

	while (*str && *str != *__decimal_point)
		str++;

	if (*str++) {
		while (*str && *str != 'e')
			str++;

		stop = str--;

		while (*str == '0')
			str--;

		while (*++str = *stop++)
			;
	}

	return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\isctype.c ===
/***
*isctype.c - support is* ctype functions/macros for two-byte multibyte chars
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _isctype.c - support is* ctype functions/macros for
*       two-byte multibyte chars.
*
*Revision History:
*       10-11-91  ETC   Created.
*       12-08-91  ETC   Updated api; added multhread lock; check char masks.
*       04-06-92  KRS   Fix logic error in return value.
*       08-07-92  GJF   _CALLTYPE4 (bogus usage) -> _CRTAPI1 (legit).
*       01-19-93  CFW   Change C1_* to new names, call new APIs.
*       03-04-93  CFW   Removed CTRL-Z.
*       04-01-93  CFW   Remove EOF test (handled by array), return masked.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-27-93  GJF   Merged NT SDK and Cuda versions.
*       11-09-93  CFW   Add code page for __crtxxx().
*       04-18-93  CFW   Pass lcid to _GetStringType.
*       09-06-94  CFW   Remove _INTL switch.
*       01-07-95  CFW   Mac merge cleanup.
*       04-01-96  BWT   POSIX work.
*       06-21-96  GJF   Replaced defined(_WIN32) with !defined(_MAC).
*       03-16-97  RDK   Added error flag to __crtGetStringTypeA.
*       07-20-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       05-17-99  PML   Remove all Macintosh support.
*       10-25-99  GB    VS7#5695 Added a _chvalidator for debug version
*       02-27-01  PML   Turn on _chvalidator in /ML builds (vs7#213380)
*
*******************************************************************************/

#include <stdio.h>
#include <cruntime.h>
#include <ctype.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <awint.h>
#include <dbgint.h>

#ifdef _XBOX
#undef _MT
#endif

#if     !defined(_NTSUBSET_) && !defined(_POSIX_)

#ifndef _XBOX
/*
 *  Use GetCharType() API so check that character type masks agree between
 *  ctype.h and winnls.h
 */
#if     _UPPER   != C1_UPPER || /*IFSTRIP=IGN*/ \
        _LOWER   != C1_LOWER || \
        _DIGIT   != C1_DIGIT || \
        _SPACE   != C1_SPACE || \
        _PUNCT   != C1_PUNCT || \
        _CONTROL != C1_CNTRL
#error Character type masks do not agree in ctype and winnls
#endif
#endif // XBOX


/***
* __chvalidator
*
* Purpose:
*       This function is called by character testing functions in debug
*       versions. This function test for validation of c as character.
*       For improvement in performance, it is not used in non-debug 
*       version.  It is available in the static single-thread non-debug
*       build, though, just in case C code that includes ctype.h is compiled
*       /D_DEBUG /ML.
*       
*******************************************************************************/

#if !defined(_MT) || defined(_DEBUG)
int __cdecl _chvalidator(
        int c,
        int mask
        )
{
        _ASSERTE((unsigned)(c + 1) <= 256);
        return ( _pctype[c] & mask);
}
#endif  /* !_MT || _DEBUG */

#if defined(_MT) && defined(_DEBUG)
int __cdecl _chvalidator_mt(
        pthreadlocinfo p,
        int c,
        int mask
        )
{
        _ASSERTE((unsigned)(c + 1) <= 256);
        return (p->pctype[c] & mask);
}

#endif  /* _MT && _DEBUG */

/***
*_isctype - support is* ctype functions/macros for two-byte multibyte chars
*
*Purpose:
*       This function is called by the is* ctype functions/macros
*       (e.g. isalpha()) when their argument is a two-byte multibyte char.
*       Returns true or false depending on whether the argument satisfies
*       the character class property encoded by the mask.
*
*Entry:
*       int c - the multibyte character whose type is to be tested
*       unsigned int mask - the mask used by the is* functions/macros
*                  corresponding to each character class property
*
*       The leadbyte and the trailbyte should be packed into the int c as:
*
*       H.......|.......|.......|.......L
*           0       0   leadbyte trailbyte
*
*Exit:
*       Returns non-zero if c is of the character class.
*       Returns 0 if c is not of the character class.
*
*Exceptions:
*       Returns 0 on any error.
*
*******************************************************************************/

int __cdecl _isctype (
        int c,
        int mask
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __isctype_mt(ptloci, c, mask);
}

int __cdecl __isctype_mt (
        pthreadlocinfo ptloci,
        int c,
        int mask
        )
{
#endif
        int size;
        unsigned short chartype;
        char buffer[3];

        /* c valid between -1 and 255 */
        if ( ((unsigned)(c + 1)) <= 256 )
#ifdef  _MT
            return ptloci->pctype[c] & mask;
#else
            return _pctype[c] & mask;
#endif

#ifndef _XBOX
#ifdef  _MT
        if ( __isleadbyte_mt(ptloci, c >> 8 & 0xff) )
#else
        if ( isleadbyte(c >> 8 & 0xff) )
#endif
        {
            buffer[0] = (c >> 8 & 0xff); /* put lead-byte at start of str */
            buffer[1] = (char)c;
            buffer[2] = 0;
            size = 2;
        } else {
            buffer[0] = (char)c;
            buffer[1] = 0;
            size = 1;
        }

        if ( 0 == __crtGetStringTypeA( CT_CTYPE1,
                                       buffer,
                                       size,
                                       &chartype,
#ifdef  _MT
                                       ptloci->lc_codepage,
                                       ptloci->lc_handle[LC_CTYPE],
#else
                                       __lc_codepage,
                                       __lc_handle[LC_CTYPE],
#endif
                                       TRUE) )
        {
            return 0;
        }

        return (int)(chartype & mask);
#else // XBOX
        return 0;
#endif
}

#else   /* !_NTSUBSET_ && !_POSIX_ */

int __cdecl _isctype (
        int c,
        int mask
        )
{
        return 0;
}

#endif  /* !_NTSUBSET_ && !_POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\mbstowcs.c ===
/***
*mbstowcs.c - Convert multibyte char string to wide char string.
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert a multibyte char string into the equivalent wide char string.
*
*Revision History:
*       08-24-90  KRS   Module created.
*       03-20-91  KRS   Ported from 16-bit tree.
*       10-16-91  ETC   Locale support under _INTL switch.
*       12-09-91  ETC   Updated nlsapi; added multithread.
*       08-20-92  KRS   Activated NLSAPI support.
*       08-31-92  SRW   Allow INTL definition to be conditional for building ntcrt.lib
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       02-09-93  CFW   Always stuff WC 0 at end of output string of room (non _INTL).
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       05-03-93  CFW   Return pointer == NULL, return size, plus massive cleanup.
*       06-01-93  CFW   Minor optimization and beautify.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-21-93  CFW   Avoid cast bug.
*       09-27-93  GJF   Merged NT SDK and Cuda.
*       10-22-93  CFW   Test for invalid MB chars using global preset flag.
*       01-14-94  SRW   if _NTSUBSET_ defined call Rtl functions
*       02-03-94  GJF   Merged in Steve Wood's latest change (affects
*                       _NTSUBSET_ build only).
*       02-07-94  CFW   POSIXify.
*       08-03-94  CFW   Bug #15300; fix MBToWC workaround for small buffer.
*       09-06-94  CFW   Remove _INTL switch.
*       10-18-94  BWT   Fix build warning for call to RtlMultiByteToUnicodeN
*       12-21-94  CFW   Remove invalid MB chars NT 3.1 hack.
*       01-07-95  CFW   Mac merge cleanup.
*       02-06-95  CFW   assert -> _ASSERTE.
*       04-19-95  CFW   Rearrange & fix non-Win32 version.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       04-01-96  BWT   POSIX work.
*       05-26-96  BWT   Return the word count, not the byte count for 
*                       _NTSUBSET_/POSIX case.
*       06-25-96  GJF   Removed DLL_FOR_WIN32S. Replaced defined(_WIN32) with
*                       !defined(_MAC). Polished the format a bit.
*       07-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       12-15-98  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#if     defined(_NTSUBSET_) || defined(_POSIX_)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <internal.h>
#include <locale.h>
#include <setlocal.h>
#include <errno.h>
#include <cruntime.h>
#include <stdlib.h>
#include <string.h>
#include <mtdll.h>
#include <dbgint.h>
#include <stdio.h>

#ifdef _XBOX
#undef _MT
#endif

/***
*size_t mbstowcs() - Convert multibyte char string to wide char string.
*
*Purpose:
*       Convert a multi-byte char string into the equivalent wide char string,
*       according to the LC_CTYPE category of the current locale.
*       [ANSI].
*
*Entry:
*       wchar_t *pwcs = pointer to destination wide character string buffer
*       const char *s = pointer to source multibyte character string
*       size_t      n = maximum number of wide characters to store
*
*Exit:
*       If s != NULL, returns:  number of words modified (<=n)
*               (size_t)-1 (if invalid mbcs)
*
*Exceptions:
*       Returns (size_t)-1 if s is NULL or invalid mbcs character encountered
*
*******************************************************************************/

size_t __cdecl mbstowcs
(
        wchar_t  *pwcs,
        const char *s,
        size_t n
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __mbstowcs_mt(ptloci, pwcs, s, n);
}

size_t __cdecl __mbstowcs_mt (
        pthreadlocinfo ptloci,
        wchar_t  *pwcs,
        const char *s,
        size_t n
        )
{
#endif
        size_t count = 0;

        if (pwcs && n == 0)
            /* dest string exists, but 0 bytes converted */
            return (size_t) 0;

        _ASSERTE(s != NULL);

#ifdef  _WIN64
        /* n must fit into an int for MultiByteToWideChar */
        if ( n > INT_MAX )
            return (size_t)-1;
#endif

#ifndef _XBOX
#if     !defined(_NTSUBSET_) && !defined(_POSIX_)

        /* if destination string exists, fill it in */
        if (pwcs)
        {
#ifdef  _MT
            if (ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE)
#else
            if (__lc_handle[LC_CTYPE] == _CLOCALEHANDLE)
#endif
            {
                /* C locale: easy and fast */
                while (count < n)
                {
                    *pwcs = (wchar_t) ((unsigned char)s[count]);
                    if (!s[count])
                        return count;
                    count++;
                    pwcs++;
                }
                return count;

            } else {
                int bytecnt, charcnt;
                unsigned char *p;

                /* Assume that the buffer is large enough */
#ifdef  _MT
                if ( (count = MultiByteToWideChar( ptloci->lc_codepage,
#else
                if ( (count = MultiByteToWideChar( __lc_codepage,
#endif
                                                   MB_PRECOMPOSED | 
                                                    MB_ERR_INVALID_CHARS,
                                                   s, 
                                                   -1, 
                                                   pwcs, 
                                                   (int)n )) != 0 )
                    return count - 1; /* don't count NUL */

                if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                {
                    errno = EILSEQ;
                    return (size_t)-1;
                }

                /* User-supplied buffer not large enough. */

                /* How many bytes are in n characters of the string? */
                charcnt = (int)n;
                for (p = (unsigned char *)s; (charcnt-- && *p); p++)
                {
#ifdef  _MT
                    if (__isleadbyte_mt(ptloci, *p))
#else
                    if (isleadbyte(*p))
#endif
                        p++;
                }
                bytecnt = ((int) ((char *)p - (char *)s));

#ifdef  _MT
                if ( (count = MultiByteToWideChar( ptloci->lc_codepage, 
#else
                if ( (count = MultiByteToWideChar( __lc_codepage, 
#endif
                                                   MB_PRECOMPOSED,
                                                   s, 
                                                   bytecnt, 
                                                   pwcs, 
                                                   (int)n )) == 0 )
                {
                    errno = EILSEQ;
                    return (size_t)-1;
                }

                return count; /* no NUL in string */
            }
        }
        else { /* pwcs == NULL, get size only, s must be NUL-terminated */
#ifdef  _MT
            if (ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE)
#else
            if (__lc_handle[LC_CTYPE] == _CLOCALEHANDLE)
#endif
                return strlen(s);

            else {
#ifdef  _MT
                if ( (count = MultiByteToWideChar( ptloci->lc_codepage, 
#else
                if ( (count = MultiByteToWideChar( __lc_codepage, 
#endif
                                                   MB_PRECOMPOSED | 
                                                    MB_ERR_INVALID_CHARS,
                                                   s, 
                                                   -1, 
                                                   NULL, 
                                                   0 )) == 0 )
                {
                    errno = EILSEQ;
                    return (size_t)-1;
                }

                return count - 1;
            }
        }

#else /* _NTSUBSET_/_POSIX_ */

        if (pwcs) {

            NTSTATUS Status;
            int size;

            size = _mbstrlen(s);
            Status = RtlMultiByteToUnicodeN(pwcs,
                                            (ULONG) ( n * sizeof( *pwcs ) ),
                                            (PULONG)&size,
                                            (char *)s,
                                            size+1 );
            if (!NT_SUCCESS(Status)) {
                errno = EILSEQ;
                size = -1;
            } else {
                size = size / sizeof(*pwcs);
                if (pwcs[size-1] == L'\0') {
                    size -= 1;
                }
            }
            return size;

        } else { /* pwcs == NULL, get size only, s must be NUL-terminated */
            return strlen(s);
        }

#endif  /* _NTSUBSET_/_POSIX_ */
#else // XBOX
        /* if destination string exists, fill it in */
        if (pwcs)
        {
            /* C locale: easy and fast */
            while (count < n)
            {
                *pwcs = (wchar_t) ((unsigned char)s[count]);
                if (!s[count])
                    return count;
                count++;
                pwcs++;
            }
            return count;

        } else { /* pwcs == NULL, get size only, s must be NUL-terminated */
            return strlen(s);
        }
#endif // XBOX
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\iswctype.c ===
/***
*iswctype.c - support isw* wctype functions/macros for wide characters
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines iswctype - support isw* wctype functions/macros for
*       wide characters (esp. > 255).
*
*Revision History:
*       10-11-91  ETC   Created.
*       12-08-91  ETC   Updated api; check type masks.
*       04-06-92  KRS   Change to match ISO proposal.  Fix logic error.
*       08-07-92  GJF   _CALLTYPE4 (bogus usage) -> _CRTAPI1 (legit).
*       08-20-92  KRS   Activated NLS support.
*       08-22-92  SRW   Allow INTL definition to be conditional for building ntcrt.lib
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       09-03-92  GJF   Merged last 4 changes.
*       01-15-93  CFW   Put #ifdef _INTL around wint_t d def to avoid warnings
*       02-12-93  CFW   Return d not c, remove CTRL-Z.
*       02-17-93  CFW   Include locale.h.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       05-05-93  CFW   Change name from is_wctype to iswctype as per ISO.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       06-26-93  CFW   Support is_wctype forever.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-27-93  GJF   Merged NT SDK and Cuda.
*       11-09-93  CFW   Add code page for __crtxxx().
*       12-01-93  GJF   Build is_wctype for Dolphin as well as NT.
*       02-07-94  CFW   POSIXify.
*       04-18-93  CFW   Pass lcid to _GetStringType.
*       04-01-96  BWT   POSIX work.
*       01-26-97  GJF   Deleted test which forced error for all wide chars >
*                       255 in the C locale.
*       08-24-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       09-06-00  GB    Always use pwctype for first 256 characters.
*
*******************************************************************************/

#include <cruntime.h>
#include <ctype.h>
#include <stdio.h>
#include <locale.h>
#include <setlocal.h>
#include <awint.h>
#include <mtdll.h>

#ifdef _XBOX
#undef _MT
#endif

#ifndef _XBOX
/*
 *  Use GetStringTypeW() API so check that character type masks agree between
 *  ctype.h and winnls.h
 */
#if !defined(_NTSUBSET_) && !defined(_POSIX_)
#if     _UPPER != C1_UPPER  || /*IFSTRIP=IGN*/ \
        _LOWER != C1_LOWER  || \
        _DIGIT != C1_DIGIT  || \
        _SPACE != C1_SPACE  || \
        _PUNCT != C1_PUNCT  || \
        _CONTROL != C1_CNTRL
#error Character type masks do not agree in ctype and winnls
#endif
#endif
#endif // XBOX

/***
*iswctype - support isw* wctype functions/macros.
*
*Purpose:
*       This function is called by the isw* wctype functions/macros
*       (e.g. iswalpha()) when their argument is a wide character > 255.
*       It is also a standard ITSCJ (proposed) ISO routine and can be called
*       by the user, even for characters < 256.
*       Returns true or false depending on whether the argument satisfies
*       the character class property encoded by the mask.  Returns 0 if the
*       argument is WEOF.
*
*       NOTE: The isw* functions are neither locale nor codepage dependent.
*
*Entry:
*       wchar_t c    - the wide character whose type is to be tested
*       wchar_t mask - the mask used by the isw* functions/macros
*                       corresponding to each character class property
*
*Exit:
*       Returns non-zero if c is of the character class.
*       Returns 0 if c is not of the character class.
*
*Exceptions:
*       Returns 0 on any error.
*
*******************************************************************************/

int __cdecl iswctype (
        wchar_t c,
        wctype_t mask
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci;

        if (c < 256)
            return (int)(mask&_pwctype[c]);
        else if (c == WEOF)
            return 0;
        ptloci = _getptd()->ptlocinfo;
        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __iswctype_mt(ptloci, c, mask);
}

int __cdecl __iswctype_mt (
        pthreadlocinfo ptloci,
        wchar_t c,
        wctype_t mask
        )
{
#endif
        wint_t d;

        if ( c == WEOF )
            d = 0;
        else if ( c < 256 )
            d = _pwctype[c];
        else
        {
#ifdef _XBOX
            // XBUG -- programmatically evaluate J chars
            d = 0;
#else // XBOX
#if     !defined(_NTSUBSET_) && !defined(_POSIX_)
            if ( __crtGetStringTypeW( CT_CTYPE1,
                                      &c,
                                      1,
                                      &d,
#ifdef  _MT
                                      ptloci->lc_codepage,
                                      ptloci->lc_handle[LC_CTYPE] ) == 0 )
#else
                                      __lc_codepage,
                                      __lc_handle[LC_CTYPE] ) == 0 )
#endif
#endif
                d = 0;
#endif // XBOX
        }

        return (int)(d & mask);
}


/***
*is_wctype - support obsolete name
*
*Purpose:
*       Name changed from is_wctype to iswctype. is_wctype must be supported.
*
*Entry:
*       wchar_t c    - the wide character whose type is to be tested
*       wchar_t mask - the mask used by the isw* functions/macros
*                       corresponding to each character class property
*
*Exit:
*       Returns non-zero if c is of the character class.
*       Returns 0 if c is not of the character class.
*
*Exceptions:
*       Returns 0 on any error.
*
*******************************************************************************/
int __cdecl is_wctype (
        wchar_t c,
        wctype_t mask
        )
{
        return iswctype(c, mask);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\atox.c ===
/***
*atox.c - atoi and atol conversion
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts a character string into an int or long.
*
*Revision History:
*       06-05-89  PHG   Module created, based on asm version
*       03-05-90  GJF   Fixed calling type, added #include <cruntime.h> and
*                       cleaned up the formatting a bit. Also, fixed the
*                       copyright.
*       09-27-90  GJF   New-style function declarators.
*       10-21-92  GJF   Fixed conversions of char to int.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       01-19-96  BWT   Add __int64 version.
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       05-23-00  GB    Added Unicode function.
*       08-16-00  GB    Added multilingual support to unicode wtox fundtions.
*       11-01-00  PML   Fix _NTSUBSET_ build.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <ctype.h>
#include <mtdll.h>
#include <tchar.h>
#ifdef _MBCS
#undef _MBCS
#endif

#ifdef _XBOX
#undef _MT
#endif

#ifndef _UNICODE
#define _tchartodigit(c)    ((c) >= '0' && (c) <= '9' ? (c) - '0' : -1)
#else
int _wchartodigit(wchar_t);
#define _tchartodigit(c)    _wchartodigit((wchar_t)(c))
#endif

/***
*long atol(char *nptr) - Convert string to long
*
*Purpose:
*       Converts ASCII string pointed to by nptr to binary.
*       Overflow is not detected.
*
*Entry:
*       nptr = ptr to string to convert
*
*Exit:
*       return long int value of the string
*
*Exceptions:
*       None - overflow is not detected.
*
*******************************************************************************/

long __cdecl _tstol(
        const _TCHAR *nptr
        )
{
        int c;              /* current char */
        long total;         /* current total */
        int sign;           /* if '-', then negative, otherwise positive */
#if defined( _MT) && !defined(_UNICODE)
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        /* skip whitespace */
        while ( __isspace_mt(ptloci, (int)(_TUCHAR)*nptr) )
#else
        while ( _istspace((int)(_TUCHAR)*nptr) )
#endif
            ++nptr;

        c = (int)(_TUCHAR)*nptr++;
        sign = c;           /* save sign indication */
        if (c == _T('-') || c == _T('+'))
            c = (int)(_TUCHAR)*nptr++;    /* skip sign */

        total = 0;

        while ( (c = _tchartodigit(c)) != -1 ) {
            total = 10 * total + c;     /* accumulate digit */
            c = (_TUCHAR)*nptr++;    /* get next char */
        }

        if (sign == '-')
            return -total;
        else
            return total;   /* return result, negated if necessary */
}


/***
*int atoi(char *nptr) - Convert string to long
*
*Purpose:
*       Converts ASCII string pointed to by nptr to binary.
*       Overflow is not detected.  Because of this, we can just use
*       atol().
*
*Entry:
*       nptr = ptr to string to convert
*
*Exit:
*       return int value of the string
*
*Exceptions:
*       None - overflow is not detected.
*
*******************************************************************************/

int __cdecl _tstoi(
        const _TCHAR *nptr
        )
{
        return (int)_tstol(nptr);
}

#ifndef _NO_INT64

__int64 __cdecl _tstoi64(
        const _TCHAR *nptr
        )
{
        int c;              /* current char */
        __int64 total;      /* current total */
        int sign;           /* if '-', then negative, otherwise positive */
#if  defined(_MT) && !defined(_UNICODE)
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        /* skip whitespace */
        while ( __isspace_mt(ptloci, (int)(_TUCHAR)*nptr) )
#else
        while ( _istspace((int)(_TUCHAR)*nptr) )
#endif
            ++nptr;

        c = (int)(_TUCHAR)*nptr++;
        sign = c;           /* save sign indication */
        if (c == _T('-') || c == _T('+'))
            c = (int)(_TUCHAR)*nptr++;    /* skip sign */

        total = 0;

        while ( (c = _tchartodigit(c)) != -1 ) {
            total = 10 * total + c;     /* accumulate digit */
            c = (_TUCHAR)*nptr++;    /* get next char */
        }

        if (sign == _T('-'))
            return -total;
        else
            return total;   /* return result, negated if necessary */
}

#endif /* _NO_INT64 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\mbtowc.c ===
/***
*mbtowc.c - Convert multibyte char to wide char.
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert a multibyte character into the equivalent wide character.
*
*Revision History:
*       03-19-90  KRS   Module created.
*       12-20-90  KRS   Put some intl stuff here for now...
*       03-18-91  KRS   Fixed bogus cast involving wchar_t.  Fix copyright.
*       03-20-91  KRS   Ported from 16-bit tree.
*       07-22-91  KRS   C700 3525: Check for s==0 before calling mblen.
*       07-23-91  KRS   Hard-coded for "C" locale to avoid bogus interim #'s.
*       10-15-91  ETC   Locale support under _INTL (finally!).
*       12-09-91  ETC   Updated nlsapi; added multithread.
*       08-20-92  KRS   Activated NLSAPI support.
*       08-31-92  SRW   Allow INTL definition to be conditional for building ntcrt.lib
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       04-26-93  CFW   Remove unused variable.
*       05-04-93  CFW   Kinder, gentler error handling.
*       06-01-93  CFW   Re-write; verify valid MB char, proper error return,
*                       optimize, fix bugs.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-28-93  GJF   Merged NT SDK and Cuda versions. Also, replace MTHREAD
*                       with _MT.
*       10-22-93  CFW   Test for invalid MB chars using global preset flag.
*       01-14-94  SRW   if _NTSUBSET_ defined call Rtl functions
*       02-03-94  GJF   Merged in Steve Wood's latest change (affects
*                       _NTSUBSET_ build only).
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Remove _INTL switch.
*       10-18-94  BWT   Fix build warning for call to RtlMultiByteToUnicodeN
*       12-21-94  CFW   Remove invalid MB chars NT 3.1 hack.
*       01-07-95  CFW   Mac merge cleanup.
*       02-06-95  CFW   assert -> _ASSERTE.
*       04-19-95  CFW   Rearrange & fix non-Win32 version.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       04-01-96  BWT   POSIX work.
*       06-25-96  GJF   Removed DLL_FOR_WIN32S. Replaced defined(_WIN32) with
*                       !defined(_MAC). Polished the format a bit.
*       07-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       04-07-99  GJF   Replace MT with _MT.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#if     defined(_NTSUBSET_) || defined(_POSIX_)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <cruntime.h>
#include <stdlib.h>
#include <mtdll.h>
#include <errno.h>
#include <dbgint.h>
#include <ctype.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

#ifdef _XBOX
#undef _MT
#endif

/***
*int mbtowc() - Convert multibyte char to wide character.
*
*Purpose:
*       Convert a multi-byte character into the equivalent wide character,
*       according to the LC_CTYPE category of the current locale.
*       [ANSI].
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*              Non-C locale support now available under _INTL switch.
*Entry:
*       wchar_t  *pwc = pointer to destination wide character
*       const char *s = pointer to multibyte character
*       size_t      n = maximum length of multibyte character to consider
*
*Exit:
*       If s = NULL, returns 0, indicating we only use state-independent
*       character encodings.
*       If s != NULL, returns:  0 (if *s = null char)
*                               -1 (if the next n or fewer bytes not valid mbc)
*                               number of bytes comprising converted mbc
*
*Exceptions:
*
*******************************************************************************/

int __cdecl mbtowc(
        wchar_t  *pwc,
        const char *s,
        size_t n
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __mbtowc_mt(ptloci, pwc, s, n);
}

int __cdecl __mbtowc_mt (
        pthreadlocinfo ptloci,
        wchar_t  *pwc,
        const char *s,
        size_t n
        )
{
        _ASSERTE (ptloci->mb_cur_max == 1 || ptloci->mb_cur_max == 2);
#else
        _ASSERTE (MB_CUR_MAX == 1 || MB_CUR_MAX == 2);
#endif
        if ( !s || n == 0 )
            /* indicate do not have state-dependent encodings,
               handle zero length string */
            return 0;

        if ( !*s )
        {
            /* handle NULL char */
            if (pwc)
                *pwc = 0;
            return 0;
        }

#ifndef _XBOX
#if     !defined(_NTSUBSET_) && !defined (_POSIX_)

#ifdef  _MT
        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#else
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#endif
        {
            if (pwc)
                *pwc = (wchar_t)(unsigned char)*s;
            return sizeof(char);
        }

#ifdef  _MT
        if ( __isleadbyte_mt(ptloci, (unsigned char)*s) )
        {
            /* multi-byte char */

            if ( (ptloci->mb_cur_max <= 1) || ((int)n < ptloci->mb_cur_max) ||
                 (MultiByteToWideChar( ptloci->lc_codepage, 
                                       MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                                       s, 
                                       ptloci->mb_cur_max, 
                                       pwc, 
                                       (pwc) ? 1 : 0 ) == 0) )
            {
                /* validate high byte of mbcs char */
                if ( (n < (size_t)ptloci->mb_cur_max) || (!*(s + 1)) )
                {
                    errno = EILSEQ;
                    return -1;
                }
            }
            return ptloci->mb_cur_max;
        }
#else
        if ( isleadbyte((unsigned char)*s) )
        {
            /* multi-byte char */

            if ( (MB_CUR_MAX <= 1) || ((int)n < MB_CUR_MAX) ||
                 (MultiByteToWideChar( __lc_codepage, 
                                      MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                                      s, 
                                      MB_CUR_MAX, 
                                      pwc, 
                                      (pwc) ? 1 : 0 ) == 0) )
            {
                /* validate high byte of mbcs char */
                if ( (n < (size_t)MB_CUR_MAX) || (!*(s + 1)) )
                {
                    errno = EILSEQ;
                    return -1;
                }
            }
            return MB_CUR_MAX;
        }
#endif
        else {
            /* single byte char */

#ifdef  _MT
            if ( MultiByteToWideChar( ptloci->lc_codepage, 
#else
            if ( MultiByteToWideChar( __lc_codepage, 
#endif
                                      MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                                      s, 
                                      1, 
                                      pwc, 
                                      (pwc) ? 1 : 0 ) == 0 )
            {
                errno = EILSEQ;
                return -1;
            }
            return sizeof(char);
        }

#else   /* _NTSUBSET_ */

        {
            NTSTATUS Status;
            int size;

            Status = RtlMultiByteToUnicodeN(pwc,
                                            (pwc) ? sizeof( *pwc ) : 0,
                                            (PULONG)&size,
                                            (char *) s,
                                            (ULONG) n);
            if (!NT_SUCCESS(Status)) {
                errno = EILSEQ;
                size = -1;
            } else
                size = mblen(s, n);

            return size;
        }

#endif  /* _NTSUBSET_/_POSIX_ */
#else // XBOX
        /* stuck the "C" locale again */
        if (pwc)
            *pwc = (wchar_t)(unsigned char)*s;
        return sizeof(char);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\mblen.c ===
/***
*mblen.c - length of multibyte character
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Return the number of bytes contained in a multibyte character.
*
*Revision History:
*       03-19-90  KRS   Module created.
*       12-20-90  KRS   Include ctype.h.
*       03-20-91  KRS   Ported from 16-bit tree.
*       12-09-91  ETC   Updated comments; move __mb_cur_max to nlsdata1.c;
*                       add multithread.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       06-01-93  CFW   Re-write; verify valid MB char, proper error return,
*                       optimize, correct conversion bug.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-27-93  GJF   Merged NT SDK and Cuda versions.
*       10-22-93  CFW   Test for invalid MB chars using global preset flag.
*       01-14-94  SRW   if _NTSUBSET_ defined call Rtl functions
*       09-06-94  CFW   Remove _INTL switch.
*       12-21-94  CFW   Remove invalid MB chars NT 3.1 hack.
*       01-07-95  CFW   Mac merge cleanup.
*       02-06-95  CFW   assert -> _ASSERTE.
*       04-01-96  BWT   POSIX work.
*       06-25-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also, 
*                       polished format a bit.
*       02-27-98  RKP   Added 64 bit support.
*       07-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#if     defined(_NTSUBSET_) || defined(_POSIX_)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <internal.h>
#include <locale.h>
#include <setlocal.h>
#include <cruntime.h>
#include <stdlib.h>
#include <ctype.h>
#include <mtdll.h>
#include <dbgint.h>

#ifdef _XBOX
#undef _MT
#endif

/***
*int mblen() - length of multibyte character
*
*Purpose:
*       Return the number of bytes contained in a multibyte character.
*       [ANSI].
*
*Entry:
*       const char *s = pointer to multibyte character
*       size_t      n = maximum length of multibyte character to consider
*
*Exit:
*       If s = NULL, returns 0, indicating we use (only) state-independent
*       character encodings.
*
*       If s != NULL, returns:   0  (if *s = null char),
*                               -1  (if the next n or fewer bytes not valid 
*                                   mbc),
*                               number of bytes contained in multibyte char
*
*Exceptions:
*
*******************************************************************************/

int __cdecl mblen
        (
        const char * s,
        size_t n
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        _ASSERTE (ptloci->mb_cur_max == 1 || ptloci->mb_cur_max == 2);
#else
        _ASSERTE (MB_CUR_MAX == 1 || MB_CUR_MAX == 2);
#endif

        if ( !s || !(*s) || (n == 0) )
            /* indicate do not have state-dependent encodings,
               empty string length is 0 */
            return 0;

#if     !defined(_NTSUBSET_) && !defined(_POSIX_)

#ifdef  _MT
        if ( __isleadbyte_mt(ptloci, (unsigned char)*s) )
#else
        if ( isleadbyte((unsigned char)*s) )
#endif
        {
            /* multi-byte char */

#ifndef _XBOX
            /* verify valid MB char */
#ifdef  _MT
            if ( ptloci->mb_cur_max <= 1 || 
                 (int)n < ptloci->mb_cur_max ||
                 MultiByteToWideChar( ptloci->lc_codepage,
                                      MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                                      s,
                                      ptloci->mb_cur_max,
                                      NULL,
                                      0 ) == 0 )
#else
            if ( MB_CUR_MAX <= 1 || 
                 (int)n < MB_CUR_MAX ||
                 MultiByteToWideChar( __lc_codepage, 
                                      MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                                      s, 
                                      MB_CUR_MAX, 
                                      NULL, 
                                      0 ) == 0 )
#endif
#else // XBOX
            /* validate high byte of mbcs char */
            if ((n<(size_t)MB_CUR_MAX) || (!*(s+1)))
#endif // XBOX
                /* bad MB char */
                return -1;
            else
#ifdef  _MT
                return ptloci->mb_cur_max;
#else
                return MB_CUR_MAX;
#endif
        }
        else {
            /* single byte char */

#ifndef _XBOX
            /* verify valid SB char */
#ifdef  _MT
            if ( MultiByteToWideChar( __lc_codepage,
#else
            if ( MultiByteToWideChar( __lc_codepage,
#endif
                                      MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                                      s, 
                                      1, 
                                      NULL, 
                                      0 ) == 0 )
                return -1;
#endif // XBOX
            return sizeof(char);
        }

#else   /* _NTSUBSET_ */

        {
            char *s1 = (char *)s;

            RtlAnsiCharToUnicodeChar( &s1 );
            return (int)(s1 - s);
        }

#endif  /* _NTSUBSET_ */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\sources.inc ===
MAJORCOMP=crt
MINORCOMP=convert

TARGETNAME=convert

!INCLUDE ..\..\crt32.inc

SOURCES=\
        ..\_ctype.c   \
        ..\_fptostr.c \
        ..\_mbslen.c  \
        ..\_wctype.c  \
        ..\atof.c     \
        ..\atox.c     \
        ..\fcvt.c     \
        ..\gcvt.c     \
        ..\isctype.c  \
        ..\iswctype.c \
        ..\mblen.c    \
        ..\mbstowcs.c \
        ..\mbtowc.c   \
        ..\strtod.c   \
        ..\strtol.c   \
        ..\strtoq.c   \
        ..\swab.c     \
        ..\tolower.c  \
        ..\toupper.c  \
        ..\towlower.c \
        ..\towupper.c \
        ..\wchtodig.c \
        ..\wcstod.c   \
        ..\wcstol.c   \
        ..\wcstoq.c   \
        ..\wcstombs.c \
        ..\wctomb.c   \
        ..\wtof.c     \
        ..\wtox.c     \
        ..\xtoa.c     \
        ..\xtow.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\strtod.c ===
/***
*strtod.c - convert string to floating point number
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert character string to floating point number
*
*Revision History:
*       09-09-83  RKW   Module created
*       08-19-85  TDC   changed to strtod
*       04-13-87  JCR   Added "const" to declaration
*       04-20-87  BCM   Added checks for negative overflow and for underflow
*       11-09-87  BCM   different interface under ifdef MTHREAD
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       02-22-88  JCR   Added cast to nptr to get rid of cl const warning
*       05-24-88  PHG   Merged DLL and normal versions
*       08-24-88  PHG   No digits found => *endptr = nptr [ANSI]
*                       Revised test order so invalid detection works always
*       10-20-88  JCR   Changed 'DOUBLE' to 'double' for 386
*       11-20-89  JCR   atof() is always _cdecl in 386 (not pascal)
*       03-05-90  GJF   Fixed calling type, added #include <cruntime.h>,
*                       removed #include <register.h>, removed redundant
*                       prototypes, removed some leftover 16-bit support and
*                       fixed the copyright. Also, cleaned up the formatting
*                       a bit.
*       07-23-90  SBM   Compiles cleanly with -W3 (added/removed appropriate
*                       #includes)
*       08-01-90  SBM   Renamed <struct.h> to <fltintrn.h>
*       09-27-90  GJF   New-style function declarators.
*       10-21-92  GJF   Made char-to-int conversion unsigned.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       12-15-98  GJF   Changes for 64-bit size_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <fltintrn.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <math.h>

/***
*double strtod(nptr, endptr) - convert string to double
*
*Purpose:
*       strtod recognizes an optional string of tabs and spaces,
*       then an optional sign, then a string of digits optionally
*       containing a decimal point, then an optional e or E followed
*       by an optionally signed integer, and converts all this to
*       to a floating point number.  The first unrecognized
*       character ends the string, and is pointed to by endptr.
*
*Entry:
*       nptr - pointer to string to convert
*
*Exit:
*       returns value of character string
*       char **endptr - if not NULL, points to character which stopped
*                       the scan
*
*Exceptions:
*
*******************************************************************************/

double __cdecl strtod (
        const char *nptr,
        REG2 char **endptr
        )
{

#ifdef  _MT
        struct _flt answerstruct;
#endif

        FLT      answer;
        double       tmp;
        unsigned int flags;
        REG1 char *ptr = (char *) nptr;

        /* scan past leading space/tab characters */

        while ( isspace((int)(unsigned char)*ptr) )
                ptr++;

        /* let _fltin routine do the rest of the work */

#ifdef  _MT
        /* ok to take address of stack variable here; fltin2 knows to use ss */
        answer = _fltin2( &answerstruct, ptr, (int)strlen(ptr), 0, 0);
#else
        answer = _fltin(ptr, (int)strlen(ptr), 0, 0);
#endif

        if ( endptr != NULL )
                *endptr = (char *) ptr + answer->nbytes;

        flags = answer->flags;
        if ( flags & (512 | 64)) {
                /* no digits found or invalid format:
                   ANSI says return 0.0, and *endptr = nptr */
                tmp = 0.0;
                if ( endptr != NULL )
                        *endptr = (char *) nptr;
        }
        else if ( flags & (128 | 1) ) {
                if ( *ptr == '-' )
                        tmp = -HUGE_VAL;        /* negative overflow */
                else
                        tmp = HUGE_VAL;         /* positive overflow */
                errno = ERANGE;
        }
        else if ( flags & 256 ) {
                tmp = 0.0;                      /* underflow */
                errno = ERANGE;
        }
        else
                tmp = answer->dval;

        return(tmp);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\testconv.c ===
/* incomplete test suite for convert functions

   Current functions tested:
	all isxxxxx functions
	toupper
	tolower
	atoi
	atol
	strtol
	strtoul
	swab
	itoa
	ltoa
	ultoa
*/

#include <stdlib.h>
#include <stdio.h>
#include <limits.h>
#include <errno.h>

fail(int n)
{
    printf("Test #%d failed.\n", n);
}

main()
{
    char s[512];
    char t[512];
    char *p;

    /* test isxxxx functions */
    if (!iscntrl(0x7))	fail(1);
    if (iscntrl('c'))	fail(2);
    if (!isdigit('0'))	fail(3);
    if (isdigit('A'))	fail(4);
    if (!isgraph(';'))	fail(5);
    if (isgraph(' '))	fail(6);
    if (!islower('f'))	fail(7);
    if (islower('F'))	fail(8);
    if (!isprint('S'))	fail(9);
    if (isprint('\v'))	fail(10);
    if (!ispunct('.'))	fail(11);
    if (ispunct('A'))	fail(12);
    if (!isspace('\v')) fail(13);
    if (isspace('D'))	fail(14);
    if (!isupper('D'))	fail(15);
    if (isupper('z'))	fail(16);
    if (!isxdigit('D')) fail(17);
    if (isxdigit('G'))	fail(18);
    if (!isalnum('7'))	fail(19);
    if (isalnum(';'))	fail(20);
    if (!isalpha('j'))	fail(21);
    if (isalpha('$'))	fail(22);
    if (!isascii(0x3))	fail(23);
    if (isascii(234))	fail(24);
    if (!iscsym('d'))	fail(25);
    if (iscsym('$'))	fail(26);
    if (!iscsymf('A'))	fail(27);
    if (iscsymf('5'))	fail(28);


    /* test toupper and tolower */
    if (tolower('C') != 'c')	fail(29);
    if (tolower('d') != 'd')	fail(30);
    if (tolower('$') != '$')	fail(31);
    if (toupper('q') != 'Q')	fail(32);
    if (toupper('A') != 'A')	fail(33);
    if (toupper(';') != ';')	fail(34);


    /* test atol/atoi */
    if (atol("-123") != -123)	  fail(35);
    if (atoi("32767") != 32767)   fail(36);
    if (atoi("-32767") != -32767) fail(36);
    if (atol("0") != 0) 	  fail(37);
    if (atol("2147483647") != 2147483647)     fail(38);
    if (atol("-2147483647") != -2147483647)   fail(39);
    if (atol("123456") != 123456) fail(40);
    if (atol("-123456") != -123456) fail(41);

    /* test strtol */
    if (strtol("-123", NULL, 10) != -123)   fail(42);
    if (strtol(" 2147483646", NULL, 10) != 2147483646)	 fail(43);
    if (strtol("-2147483646$$", NULL, 10) != -2147483646)   fail(44);
    if (strtol("  2147483648x", NULL, 10) != LONG_MAX) fail(45);
    if (strtol(" -2147483648", NULL, 10) != LONG_MIN) fail(46);
    if (strtol("0", NULL, 10) != 0) fail(47);
    if (strtol("981235b", NULL, 10) != 981235) fail(48);
    if (strtol(" -1234567a", NULL, 10) != -1234567) fail(49);
    if (strtol("FFDE", NULL, 16) != 0xFFDE) fail(50);
    if (strtol("7FFFFFFE", NULL, 16) != 0x7FFFFFFE) fail(51);
    if (strtol("-0x45", NULL, 16) != -0x45) fail(52);
    if (strtol("23478", NULL, 8) != 02347) fail(53);
    if (strtol("  -0x123D", NULL, 0) != -0x123d) fail(54);
    if (strtol(" 01238", NULL, 0) != 0123) fail(55);
    if (strtol(" -678899", NULL, 0) != -678899) fail(56);

    errno = 0;
    strtol("2147483647", NULL, 10);
    if (errno != 0)	fail(57);
    errno = 0;
    strtol("2147483648", NULL, 10);
    if (errno != ERANGE)    fail(58);
    errno = 0;
    strtol("63234283743", NULL, 10);
    if (errno != ERANGE)    fail(59);
    strcpy(s, "   8983");
    strtol(s, &p, 8);
    if (s != p)     fail(60);
    strcpy(s, "12345678901234567890XX");
    strtol(s, &p, 0);
    if (p != s+20)  fail(61);
    strcpy(s, "  111");
    strtol(s, &p, 1);
    if (p != s)     fail(62);

    errno = 0;
    if (strtoul("4294967295", NULL, 10) != ULONG_MAX)	fail(63);
    if (errno != 0)	fail(64);
    errno = 0;
    strtoul("4294967296", NULL, 10);
    if (errno != ERANGE)    fail(65);
    errno = 0;
    strtoul("63234283743", NULL, 10);
    if (errno != ERANGE)    fail(66);

    /* test swab */
    strcpy(s, "abcdefghijklmn");
    swab(s, t, 14);
    if (strcmp(t, "badcfehgjilknm") != 0)	fail(67);
    strcpy(t, s);
    swab(s, t, 7);
    if (strcmp(t, "badcfeghijklmn") != 0)	fail(68);
    strcpy(t, s);
    swab(s, t, -5);
    if (strcmp(s, t) != 0)			fail(69);

    /* test itoa/ltoa/ultoa */
    if (strcmp(itoa(345, s, 10), "345") != 0)	fail(70);
    if (strcmp(itoa(-345, s, 10), "-345") != 0) fail(71);
    if (strcmp(itoa(33, s, 36), "x") != 0)	fail(72);
    if (strcmp(itoa(65535U, s, 16), "ffff") != 0) fail(73);
    if (strcmp(ltoa(123457, s, 10), "123457") != 0) fail(74);
    if (strcmp(ltoa(-123457, s, 10), "-123457") != 0) fail(75);
    if (strcmp(ltoa(076512L, s, 8), "76512") != 0) fail(76);
    if (strcmp(ltoa(-1L, s, 10), "-1") != 0)	fail(77);
    if (strcmp(ltoa(-1L, s, 16), "ffffffff") != 0) fail(78);
    if (strcmp(ultoa(-1L, s, 10), "4294967295") != 0) fail(79);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\swab.c ===
/***
*swab.c - block copy, while swapping even/odd bytes
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This module contains the routine _swab() which swaps the odd/even
*	bytes of words during a block copy.
*
*Revision History:
*	06-02-89  PHG	module created, based on asm version
*	03-06-90  GJF	Fixed calling type, added #include <cruntime.h> and
*			fixed copyright. Also, cleaned up the formatting a
*			bit.
*	09-27-90  GJF	New-style function declarators.
*	01-21-91  GJF	ANSI naming.
*	04-06-93  SKS	Replace _CRTAPI* with _cdecl
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>

/***
*void _swab(srcptr, dstptr, nbytes) - swap ODD/EVEN bytes during word move
*
*Purpose:
*	This routine copys a block of words and swaps the odd and even
*	bytes.	nbytes must be > 0, otherwise nothing is copied.  If
*	nbytes is odd, then only (nbytes-1) bytes are copied.
*
*Entry:
*	srcptr = pointer to the source block
*	dstptr = pointer to the destination block
*	nbytes = number of bytes to swap
*
*Returns:
*	None.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _swab (
	char *src,
	char *dest,
	int nbytes
	)
{
	char b1, b2;

	while (nbytes > 1) {
		b1 = *src++;
		b2 = *src++;
		*dest++ = b2;
		*dest++ = b1;
		nbytes -= 2;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\strtoq.c ===
/***
*strtoq.c - Contains C runtimes strtoq and strtouq
*
*   Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*   Copyright (c) 1992, Digital Equipment Corporation.
*
*Purpose:
*       strtoi64 - convert ascii string to __int64 (signed) integer
*       strtoui64 - convert ascii string to __int64 (unsigned) integer
*
*Revision History:
*   06-05-89  PHG   Module created, based on strtol.asm
*   03-06-90  GJF   Fixed calling type, added #include <cruntime.h>
*                   and fixed the copyright. Also, cleaned up the
*                   formatting a bit.
*   03-07-90  GJF   Fixed compiler warnings (added const qualifier to
*                   an arg type and local var type).
*   03-23-90  GJF   Made strtoxl() _CALLTYPE4.
*   08-13-90  SBM   Compiles cleanly with -W3
*   09-27-90  GJF   New-style function declarators.
*   10-24-91  GJF   Had to cast LONG_MAX to unsigned long in expr. to
*                   mollify MIPS compiler.
*   10-21-92  GJF   Made char-to-int conversions unsigned.
*   08-28-93  TVB   Created strtoq.c directly from strtol.c.
*   10-25-93  GJF   Copied from NT SDK tree (\\orville\razzle\src\crt32).
*                   Replaced _CRTAPI* with __cdecl. Build only for NT
*                   SDK. Function names violate ANSI. Types and function-
*                   ality will be superceded by __int64 support.
*   02-11-00  GB    Added _strtoi64 and _strtoui64 (__int64 versions for
*                   strtol and strtoul)
*   06-02-00  GB    Fixed the bug for IA64_MIN value.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <limits.h>
#include <errno.h>
#include <ctype.h>
#include <mtdll.h>

#ifdef _XBOX
#undef _MT
#endif

/***
*strtoi64, strtoui64(nptr,endptr,ibase) - Convert ascii string to __int64 un/signed
*    int.
*
*Purpose:
*    Convert an ascii string to a 64-bit __int64 value.  The base
*    used for the caculations is supplied by the caller.  The base
*    must be in the range 0, 2-36.  If a base of 0 is supplied, the
*    ascii string must be examined to determine the base of the
*    number:
*        (a) First char = '0', second char = 'x' or 'X',
*            use base 16.
*        (b) First char = '0', use base 8
*        (c) First char in range '1' - '9', use base 10.
*
*    If the 'endptr' value is non-NULL, then strtoq/strtouq places
*    a pointer to the terminating character in this value.
*    See ANSI standard for details
*
*Entry:
*    nptr == NEAR/FAR pointer to the start of string.
*    endptr == NEAR/FAR pointer to the end of the string.
*    ibase == integer base to use for the calculations.
*
*    string format: [whitespace] [sign] [0] [x] [digits/letters]
*
*Exit:
*    Good return:
*        result
*
*    Overflow return:
*        strtoi64 -- _I64_MAX or _I64_MIN
*        strtoui64 -- _UI64_MAX
*        strtoi64/strtoui64 -- errno == ERANGE
*
*    No digits or bad base return:
*        0
*        endptr = nptr*
*
*Exceptions:
*    None.
*******************************************************************************/

/* flag values */
#define FL_UNSIGNED   1       /* strtouq called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */

static unsigned __int64 __cdecl strtoxq (
    const char *nptr,
    const char **endptr,
    int ibase,
    int flags
    )
{
    const char *p;
    char c;
    unsigned __int64 number;
    unsigned digval;
    unsigned __int64 maxval;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();
#endif

    p = nptr;            /* p is our scanning pointer */
    number = 0;            /* start with zero */

    c = *p++;            /* read char */
#ifdef  _MT
    while ( __isspace_mt(ptloci, (int)(unsigned char)c) )
#else
    while ( isspace((int)(unsigned char)c) )
#endif
        c = *p++;        /* skip whitespace */

    if (c == '-') {
        flags |= FL_NEG;    /* remember minus sign */
        c = *p++;
    }
    else if (c == '+')
        c = *p++;        /* skip sign */

    if (ibase < 0 || ibase == 1 || ibase > 36) {
        /* bad base! */
        if (endptr)
            /* store beginning of string in endptr */
            *endptr = nptr;
        return 0L;        /* return 0 */
    }
    else if (ibase == 0) {
        /* determine base free-lance, based on first two chars of
           string */
        if (c != '0')
            ibase = 10;
        else if (*p == 'x' || *p == 'X')
            ibase = 16;
        else
            ibase = 8;
    }

    if (ibase == 16) {
        /* we might have 0x in front of number; remove if there */
        if (c == '0' && (*p == 'x' || *p == 'X')) {
            ++p;
            c = *p++;    /* advance past prefix */
        }
    }

    /* if our number exceeds this, we will overflow on multiply */
    maxval = _UI64_MAX / ibase;


    for (;;) {    /* exit in middle of loop */
        /* convert c to value */
        if ( isdigit((int)(unsigned char)c) )
            digval = c - '0';
        else if ( isalpha((int)(unsigned char)c) )
            digval = toupper(c) - 'A' + 10;
        else
            break;
        if (digval >= (unsigned)ibase)
            break;        /* exit loop if bad digit found */

        /* record the fact we have read one digit */
        flags |= FL_READDIGIT;

        /* we now need to compute number = number * base + digval,
           but we need to know if overflow occured.  This requires
           a tricky pre-check. */

        if (number < maxval || (number == maxval &&
        (unsigned __int64)digval <= _UI64_MAX % ibase)) {
            /* we won't overflow, go ahead and multiply */
            number = number * ibase + digval;
        }
        else {
            /* we would have overflowed -- set the overflow flag */
            flags |= FL_OVERFLOW;
        }

        c = *p++;        /* read next digit */
    }

    --p;                /* point to place that stopped scan */

    if (!(flags & FL_READDIGIT)) {
        /* no number there; return 0 and point to beginning of
           string */
        if (endptr)
            /* store beginning of string in endptr later on */
            p = nptr;
        number = 0L;        /* return 0 */
    }
    else if ( (flags & FL_OVERFLOW) ||
              ( !(flags & FL_UNSIGNED) &&
                ( ( (flags & FL_NEG) && (number > -_I64_MIN) ) ||
                  ( !(flags & FL_NEG) && (number > _I64_MAX) ) ) ) )
    {
        /* overflow or signed overflow occurred */
        errno = ERANGE;
        if ( flags & FL_UNSIGNED )
            number = _UI64_MAX;
        else if ( flags & FL_NEG )
            number = _I64_MIN;
        else
            number = _I64_MAX;
    }
    if (endptr != NULL)
        /* store pointer to char that stopped the scan */
        *endptr = p;

    if (flags & FL_NEG)
        /* negate result if there was a neg sign */
        number = (unsigned __int64)(-(__int64)number);

    return number;            /* done. */
}

__int64 _CRTIMP __cdecl _strtoi64(
    const char *nptr,
    char **endptr,
    int ibase
    )
{
    return (__int64) strtoxq(nptr, endptr, ibase, 0);
}
unsigned __int64 _CRTIMP __cdecl _strtoui64 (
    const char *nptr,
    char **endptr,
    int ibase
    )
{
    return strtoxq(nptr, endptr, ibase, FL_UNSIGNED);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\strtol.c ===
/***
*strtol.c - Contains C runtimes strtol and strtoul
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       strtol - convert ascii string to long signed integer
*       strtoul - convert ascii string to long unsigned integer
*
*Revision History:
*       06-05-89  PHG   Module created, based on strtol.asm
*       03-06-90  GJF   Fixed calling type, added #include <cruntime.h>
*                       and fixed the copyright. Also, cleaned up the
*                       formatting a bit.
*       03-07-90  GJF   Fixed compiler warnings (added const qualifier to
*                       an arg type and local var type).
*       03-23-90  GJF   Made strtoxl() _CALLTYPE4.
*       08-13-90  SBM   Compiles cleanly with -W3
*       09-27-90  GJF   New-style function declarators.
*       10-24-91  GJF   Had to cast LONG_MAX to unsigned long in expr. to
*                       mollify MIPS compiler.
*       10-21-92  GJF   Made char-to-int conversions unsigned.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       04-21-93  GJF   Removed assumption that LONG_MIN == -LONG_MAX.
*       05-10-93  GJF   Fixed error check.
*       05-20-93  GJF   Nothing like taking ugly code and making prettier...
*                       and wrong. Fixed bug introduced on 5-10.
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct. Also, replaced isdigit, isalpha and toupper
*                       macros with __ascii_isdigit, __ascii_isalpha and
*                       __ascii_towupper macros.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <limits.h>
#include <errno.h>
#include <ctype.h>
#include <mtdll.h>

#ifdef _XBOX
#undef _MT
#endif


/***
*strtol, strtoul(nptr,endptr,ibase) - Convert ascii string to long un/signed
*       int.
*
*Purpose:
*       Convert an ascii string to a long 32-bit value.  The base
*       used for the caculations is supplied by the caller.  The base
*       must be in the range 0, 2-36.  If a base of 0 is supplied, the
*       ascii string must be examined to determine the base of the
*       number:
*               (a) First char = '0', second char = 'x' or 'X',
*                   use base 16.
*               (b) First char = '0', use base 8
*               (c) First char in range '1' - '9', use base 10.
*
*       If the 'endptr' value is non-NULL, then strtol/strtoul places
*       a pointer to the terminating character in this value.
*       See ANSI standard for details
*
*Entry:
*       nptr == NEAR/FAR pointer to the start of string.
*       endptr == NEAR/FAR pointer to the end of the string.
*       ibase == integer base to use for the calculations.
*
*       string format: [whitespace] [sign] [0] [x] [digits/letters]
*
*Exit:
*       Good return:
*               result
*
*       Overflow return:
*               strtol -- LONG_MAX or LONG_MIN
*               strtoul -- ULONG_MAX
*               strtol/strtoul -- errno == ERANGE
*
*       No digits or bad base return:
*               0
*               endptr = nptr*
*
*Exceptions:
*       None.
*******************************************************************************/

/* flag values */
#define FL_UNSIGNED   1       /* strtoul called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */


static unsigned long __cdecl strtoxl (
        const char *nptr,
        const char **endptr,
        int ibase,
        int flags
        )
{
        const char *p;
        char c;
        unsigned long number;
        unsigned digval;
        unsigned long maxval;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();
#endif

        p = nptr;                       /* p is our scanning pointer */
        number = 0;                     /* start with zero */

        c = *p++;                       /* read char */
#ifdef  _MT
        while ( __isspace_mt(ptloci, (int)(unsigned char)c) )
#else
        while ( isspace((int)(unsigned char)c) )
#endif
                c = *p++;               /* skip whitespace */

        if (c == '-') {
                flags |= FL_NEG;        /* remember minus sign */
                c = *p++;
        }
        else if (c == '+')
                c = *p++;               /* skip sign */

        if (ibase < 0 || ibase == 1 || ibase > 36) {
                /* bad base! */
                if (endptr)
                        /* store beginning of string in endptr */
                        *endptr = nptr;
                return 0L;              /* return 0 */
        }
        else if (ibase == 0) {
                /* determine base free-lance, based on first two chars of
                   string */
                if (c != '0')
                        ibase = 10;
                else if (*p == 'x' || *p == 'X')
                        ibase = 16;
                else
                        ibase = 8;
        }

        if (ibase == 16) {
                /* we might have 0x in front of number; remove if there */
                if (c == '0' && (*p == 'x' || *p == 'X')) {
                        ++p;
                        c = *p++;       /* advance past prefix */
                }
        }

        /* if our number exceeds this, we will overflow on multiply */
        maxval = ULONG_MAX / ibase;


        for (;;) {      /* exit in middle of loop */
                /* convert c to value */
                if ( __ascii_isdigit((int)(unsigned char)c) )
                        digval = c - '0';
                else if ( __ascii_isalpha((int)(unsigned char)c) )
                        digval = __ascii_toupper(c) - 'A' + 10;
                else
                        break;
                if (digval >= (unsigned)ibase)
                        break;          /* exit loop if bad digit found */

                /* record the fact we have read one digit */
                flags |= FL_READDIGIT;

                /* we now need to compute number = number * base + digval,
                   but we need to know if overflow occured.  This requires
                   a tricky pre-check. */

                if (number < maxval || (number == maxval &&
                (unsigned long)digval <= ULONG_MAX % ibase)) {
                        /* we won't overflow, go ahead and multiply */
                        number = number * ibase + digval;
                }
                else {
                        /* we would have overflowed -- set the overflow flag */
                        flags |= FL_OVERFLOW;
                }

                c = *p++;               /* read next digit */
        }

        --p;                            /* point to place that stopped scan */

        if (!(flags & FL_READDIGIT)) {
                /* no number there; return 0 and point to beginning of
                   string */
                if (endptr)
                        /* store beginning of string in endptr later on */
                        p = nptr;
                number = 0L;            /* return 0 */
        }
        else if ( (flags & FL_OVERFLOW) ||
                  ( !(flags & FL_UNSIGNED) &&
                    ( ( (flags & FL_NEG) && (number > -LONG_MIN) ) ||
                      ( !(flags & FL_NEG) && (number > LONG_MAX) ) ) ) )
        {
                /* overflow or signed overflow occurred */
                errno = ERANGE;
                if ( flags & FL_UNSIGNED )
                        number = ULONG_MAX;
                else if ( flags & FL_NEG )
                        number = (unsigned long)(-LONG_MIN);
                else
                        number = LONG_MAX;
        }

        if (endptr != NULL)
                /* store pointer to char that stopped the scan */
                *endptr = p;

        if (flags & FL_NEG)
                /* negate result if there was a neg sign */
                number = (unsigned long)(-(long)number);

        return number;                  /* done. */
}

long __cdecl strtol (
        const char *nptr,
        char **endptr,
        int ibase
        )
{
        return (long) strtoxl(nptr, endptr, ibase, 0);
}

unsigned long __cdecl strtoul (
        const char *nptr,
        char **endptr,
        int ibase
        )
{
        return strtoxl(nptr, endptr, ibase, FL_UNSIGNED);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\tolower.c ===
/***
*tolower.c - convert character to lower case
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines function versions of _tolower() and tolower().
*
*Revision History:
*       11-09-84  DFW   created
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       02-23-89  GJF   Added function version of _tolower and cleaned up.
*       03-26-89  GJF   Migrated to 386 tree
*       03-06-90  GJF   Fixed calling type, added #include <cruntime.h> and
*                       fixed copyright.
*       09-27-90  GJF   New-style function declarators.
*       10-11-91  ETC   Locale support for tolower under _INTL switch.
*       12-10-91  ETC   Updated nlsapi; added multithread.
*       12-17-92  KRS   Updated and optimized for latest NLSAPI.  Bug-fixes.
*       01-19-93  CFW   Fixed typo.
*       03-25-93  CFW   _tolower now defined when _INTL.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       06-01-93  CFW   Simplify "C" locale test.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Change buffer to unsigned char to fix nasty cast bug.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-28-93  GJF   Merged NT SDK and Cuda versions.
*       11-09-93  CFW   Add code page for __crtxxx().
*       09-06-94  CFW   Remove _INTL switch.
*       10-17-94  GJF   Sped up for C locale. Also, added _tolower_lk.
*       01-07-95  CFW   Mac merge cleanup.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       04-01-96  BWT   POSIX work.
*       06-25-96  GJF   Removed DLL_FOR_WIN32S. Replaced defined(_WIN32) with
*                       !defined(_MAC). Polished the format a bit.
*       03-17-97  RDK   Added error flag to __crtLCMapStringA.
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       05-17-99  PML   Remove all Macintosh support.
*       09-03-00  GB    Modified for increased performance.
*       04-03-01  PML   Reverse lead/trail bytes in composed char (vs7#232853)
*
*******************************************************************************/

#include <cruntime.h>
#include <ctype.h>
#include <stddef.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <awint.h>

/* remove macro defintions of _tolower() and tolower()
 */
#undef  _tolower
#undef  tolower

/* define function-like macro equivalent to _tolower()
 */
#define mklower(c)  ( (c)-'A'+'a' )

/***
*int _tolower(c) - convert character to lower case
*
*Purpose:
*       _tolower() is simply a function version of the macro of the same name.
*
*Entry:
*       c - int value of character to be converted
*
*Exit:
*       returns int value of lower case representation of c
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tolower (
        int c
        )
{
        return(mklower(c));
}

/***
*int tolower(c) - convert character to lower case
*
*Purpose:
*       tolower() is simply a function version of the macro of the same name.
*
*Entry:
*       c - int value of character to be converted
*
*Exit:
*       if c is an upper case letter, returns int value of lower case
*       representation of c. otherwise, it returns c.
*
*Exceptions:
*
*******************************************************************************/


int __cdecl tolower (
        int c
        )
{
#if     !defined(_XBOX) && !defined (_NTSUBSET_) && !defined(_POSIX_)

#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __tolower_mt(ptloci, c);
}

/***
*int __tolower_mt(c) - convert character to lower case
*
*Purpose:
*       Multi-thread function only!
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __tolower_mt (
        pthreadlocinfo ptloci,
        int c
        )
{

#endif  /* _MT */

        int size;
        unsigned char inbuffer[3];
        unsigned char outbuffer[3];

#ifndef  _MT
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE ||
             (__lc_clike && (unsigned) c <= 0x7f))
            return __ascii_tolower(c);
#else
        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE ||
             (ptloci->lc_clike && (unsigned)c <= 0x7f) )
            return __ascii_tolower(c);
#endif

        /* if checking case of c does not require API call, do it */
        if ( (unsigned)c < 256 )
        {
#ifdef  _MT
            if ( !__isupper_mt(ptloci, c) )
#else
            if ( !isupper(c) )
#endif
            {
                return c;
            }
        }

        /* convert int c to multibyte string */
#ifdef  _MT
        if ( __isleadbyte_mt(ptloci, c >> 8 & 0xff) )
#else
        if ( isleadbyte(c >> 8 & 0xff) )
#endif
        {
            inbuffer[0] = (c >> 8 & 0xff); /* put lead-byte at start of str */
            inbuffer[1] = (unsigned char)c;
            inbuffer[2] = 0;
            size = 2;
        } else {
            inbuffer[0] = (unsigned char)c;
            inbuffer[1] = 0;
            size = 1;
        }

        /* convert to lowercase */
#ifdef  _MT
        if ( 0 == (size = __crtLCMapStringA( ptloci->lc_handle[LC_CTYPE],
#else
        if ( 0 == (size = __crtLCMapStringA( __lc_handle[LC_CTYPE],
#endif
                                             LCMAP_LOWERCASE,
                                             inbuffer, 
                                             size, 
                                             outbuffer, 
                                             3, 
#ifdef  _MT
                                             ptloci->lc_codepage,
#else
                                             __lc_codepage,
#endif
                                             TRUE)) )
        {
            return c;
        }

        /* construct integer return value */
        if (size == 1)
            return ((int)outbuffer[0]);
        else
            return ((int)outbuffer[1] | ((int)outbuffer[0] << 8));

#else

        return(isupper(c) ? mklower(c) : c);

#if defined(_MT) && !defined(_XBOX)
}

int __cdecl __tolower_mt (
        pthreadlocinfo ptloci,
        int c
        )
{
    return _tolower(c);
#endif // _MT

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\toupper.c ===
/***
*toupper.c - convert character to uppercase
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines function versions of _toupper() and toupper().
*
*Revision History:
*       11-09-84  DFW   created
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       02-23-89  GJF   Added function version of _toupper and cleaned up.
*       03-26-89  GJF   Migrated to 386 tree
*       03-06-90  GJF   Fixed calling type, added #include <cruntime.h> and
*                       fixed copyright.
*       09-27-90  GJF   New-style function declarators.
*       10-11-91  ETC   Locale support for toupper under _INTL switch.
*       12-10-91  ETC   Updated nlsapi; added multithread.
*       12-17-92  KRS   Updated and optimized for latest NLSAPI.  Bug-fixes.
*       01-19-93  CFW   Fixed typo.
*       03-25-93  CFW   _toupper now defined when _INTL.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       06-01-93  CFW   Simplify "C" locale test.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Change buffer to unsigned char to fix nasty cast bug.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-28-93  GJF   Merged NT SDK and Cuda versions.
*       11-09-93  CFW   Add code page for __crtxxx().
*       01-14-94  SRW   if _NTSUBSET_ defined call Rtl functions
*       09-06-94  CFW   Remove _INTL switch.
*       10-18-94  BWT   Fix build warning in NTSUBSET section.
*       10-17-94  GJF   Sped up for C locale. Added _toupper_lk. Also,
*                       cleaned up silly pre-processor conditionals.
*       01-07-95  CFW   Mac merge cleanup.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       04-01-96  BWT   POSIX work.
*       06-25-96  GJF   Removed DLL_FOR_WIN32S. Replaced defined(_WIN32) with
*                       !defined(_MAC). Polished the format a bit.
*       03-17-97  RDK   Added error flag to __crtLCMapStringA.
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       05-17-99  PML   Remove all Macintosh support.
*       09-03-00  GB    Modified for increased performance.
*       04-03-01  PML   Reverse lead/trail bytes in composed char (vs7#232853)
*
*******************************************************************************/

#if     defined(_NTSUBSET_) || defined(_POSIX_)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <cruntime.h>
#include <ctype.h>
#include <stddef.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <awint.h>

/* remove macro definitions of _toupper() and toupper()
 */
#undef  _toupper
#undef  toupper

/* define function-like macro equivalent to _toupper()
 */
#define mkupper(c)  ( (c)-'a'+'A' )

/***
*int _toupper(c) - convert character to uppercase
*
*Purpose:
*       _toupper() is simply a function version of the macro of the same name.
*
*Entry:
*       c - int value of character to be converted
*
*Exit:
*       returns int value of uppercase representation of c
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _toupper (
        int c
        )
{
        return(mkupper(c));
}


/***
*int toupper(c) - convert character to uppercase
*
*Purpose:
*       toupper() is simply a function version of the macro of the same name.
*
*Entry:
*       c - int value of character to be converted
*
*Exit:
*       if c is a lower case letter, returns int value of uppercase
*       representation of c. otherwise, it returns c.
*
*Exceptions:
*
*******************************************************************************/


int __cdecl toupper (
    int c
    )
{
#if     !defined(_XBOX) && !defined(_NTSUBSET_) && !defined(_POSIX_)

#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __toupper_mt(ptloci, c);
}


/***
*int __toupper_mt(ptloci, c) - convert character to uppercase
*
*Purpose:
*       Multi-thread function! Non-locking version of toupper.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/


int __cdecl __toupper_mt (
        pthreadlocinfo ptloci,
        int c
        )
{

#endif  /* _MT */

        int size;
        unsigned char inbuffer[3];
        unsigned char outbuffer[3];

#ifndef _MT
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE ||
             (__lc_clike && (unsigned)c <= 0x7f))
            return __ascii_toupper(c);
#else
        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE ||
             (ptloci->lc_clike && (unsigned)c <= 0x7f))
            return __ascii_toupper(c);
#endif

        /* if checking case of c does not require API call, do it */
        if ( (unsigned)c < 256 ) {
#ifdef  _MT
            if ( !__islower_mt(ptloci, c) )
#else
            if ( !islower(c) )
#endif
            {
                return c;
            }
        }

        /* convert int c to multibyte string */
#ifdef  _MT
        if ( __isleadbyte_mt(ptloci, c >> 8 & 0xff) ) {
#else
        if ( isleadbyte(c >> 8 & 0xff) ) {
#endif
            inbuffer[0] = (c >> 8 & 0xff); /* put lead-byte at start of str */
            inbuffer[1] = (unsigned char)c;
            inbuffer[2] = 0;
            size = 2;
        } else {
            inbuffer[0] = (unsigned char)c;
            inbuffer[1] = 0;
            size = 1;
        }

        /* convert wide char to lowercase */
#ifdef  _MT
        if ( 0 == (size = __crtLCMapStringA( ptloci->lc_handle[LC_CTYPE], 
#else
        if ( 0 == (size = __crtLCMapStringA( __lc_handle[LC_CTYPE], 
#endif
                                             LCMAP_UPPERCASE,
                                             inbuffer, 
                                             size, 
                                             outbuffer, 
                                             3, 
#ifdef  _MT
                                             ptloci->lc_codepage,
#else
                                             __lc_codepage,
#endif
                                             TRUE)) ) 
        {
            return c;
        }

        /* construct integer return value */
        if (size == 1)
            return ((int)outbuffer[0]);
        else
            return ((int)outbuffer[1] | ((int)outbuffer[0] << 8));

#elif   defined(_NTSUBSET_) || defined(_POSIX_)

        {
            NTSTATUS Status;
            char *s = (char *) &c;
            WCHAR Unicode;
            ULONG UnicodeSize;
            ULONG MultiSize;
            UCHAR MultiByte[2];

            Unicode = RtlAnsiCharToUnicodeChar( &s );
            Status = RtlUpcaseUnicodeToMultiByteN( MultiByte,
                                                   sizeof( MultiByte ),
                                                   &MultiSize,
                                                   &Unicode,
                                                   sizeof( Unicode )
                                                 );
            if (!NT_SUCCESS( Status ))
                return c;
            else
            if (MultiSize == 1)
                return ((int)MultiByte[0]);
            else
                return ((int)MultiByte[1] | ((int)MultiByte[0] << 8));

        }

#else  /* _NTSUBSET_ || _POSIX_ */

        return(islower(c) ? mkupper(c) : c);

#endif  /* _NTSUBSET_ || _POSIX_ */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\towlower.c ===
/***
*towlower.c - convert wide character to lower case
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines towlower().
*
*Revision History:
*       10-11-91  ETC   Created.
*       12-10-91  ETC   Updated nlsapi; added multithread.
*       04-06-92  KRS   Make work without _INTL also.
*       01-19-93  CFW   Changed LCMapString to LCMapStringW.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       06-11-93  CFW   Fix error handling bug.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-29-93  GJF   Merged NT SDK and Cuda versions.
*       11-09-93  CFW   Add code page for __crtxxx().
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Remove _INTL switch.
*       10-25-94  GJF   Sped up for C locale. Also, added _towlower_lk.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       04-01-96  BWT   POSIX work.
*       06-25-96  GJF   Removed DLL_FOR_WIN32S and cleaned up the format a
*                       wee bit.
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*
*******************************************************************************/

#include <cruntime.h>
#include <ctype.h>
#include <stdio.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <awint.h>

#ifdef _XBOX
#undef _MT
#endif

/***
*wchar_t towlower(c) - convert wide character to lower case
*
*Purpose:
*       towlower() returns the lowercase equivalent of its argument
*
*Entry:
*       c - wchar_t value of character to be converted
*
*Exit:
*       if c is an upper case letter, returns wchar_t value of lower case
*       representation of c. otherwise, it returns c.
*
*Exceptions:
*
*******************************************************************************/

wchar_t __cdecl towlower (
        wchar_t c
        )
{
#if     !defined(_NTSUBSET_) && !defined(_POSIX_)

#ifdef  _MT

        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( c == WEOF )
            return c;

        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
            return __ascii_towlower(c);

        return __towlower_mt(ptloci, c);
}

/***
*wchar_t __towlower_mt(ptloci, c) - convert wide character to lower case
*
*Purpose:
*       Multi-thread function only! Non-locking version of towlower.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

wchar_t __cdecl __towlower_mt (
        pthreadlocinfo ptloci,
        wchar_t c
        )
{

#endif  /* _MT */

        wchar_t widechar;

        if (c == WEOF)
            return c;

#ifndef _MT
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
            return __ascii_towlower(c);
#endif

        /* if checking case of c does not require API call, do it */
        if ( c < 256 ) {
#ifdef  _MT
            if ( !__iswupper_mt(ptloci, c) ) {
#else
            if ( !iswupper(c) ) {
#endif
                return c;
            }
        }

#ifndef _XBOX
        /* convert wide char to lowercase */
#ifdef  _MT
        if ( 0 == __crtLCMapStringW( ptloci->lc_handle[LC_CTYPE], 
#else
        if ( 0 == __crtLCMapStringW( __lc_handle[LC_CTYPE], 
#endif
                                     LCMAP_LOWERCASE,
                                     (LPCWSTR)&c, 
                                     1, 
                                     (LPWSTR)&widechar, 
                                     1, 
#ifdef  _MT
                                     ptloci->lc_codepage ) )
#else
                                     __lc_codepage ) )
#endif
        {
            return c;
        }

        return widechar;

#else // XBOX

        return c;

#endif // XBOX

#else   /* _NTSUBSET_/_POSIX_ */

        return (iswupper(c) ? (c + (wchar_t)(L'a' - L'A')) : c);

#endif  /* _NTSUBSET_/_POSIX_ */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\towupper.c ===
/***
*towupper.c - convert wide character to upper case
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines towupper().
*
*Revision History:
*       10-11-91  ETC   Created.
*       12-10-91  ETC   Updated nlsapi; added multithread.
*       04-06-92  KRS   Make work without _INTL also.
*       01-19-93  CFW   Changed LCMapString to LCMapStringW.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       06-11-93  CFW   Fix error handling bug.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-29-93  GJF   Merged NT SDK and Cuda versions.
*       11-09-93  CFW   Add code page for __crtxxx().
*       01-14-94  SRW   if _NTSUBSET_ defined call Rtl functions
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Remove _INTL switch.
*       10-25-94  GJF   Sped up for C locale. Added _towupper_lk. Also,
*                       cleaned up silly pre-processor conditionals.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       04-01-96  BWT   POSIX work.
*       06-25-96  GJF   Removed DLL_FOR_WIN32S and cleaned up the format a
*                       wee bit.
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*
*******************************************************************************/

#if     defined(_NTSUBSET_) || defined(_POSIX_)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <cruntime.h>
#include <ctype.h>
#include <stdio.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <awint.h>

#ifdef _XBOX
#undef _MT
#endif

/***
*wchar_t towupper(c) - convert wide character to upper case
*
*Purpose:
*       towupper() returns the uppercase equivalent of its argument
*
*Entry:
*       c - wchar_t value of character to be converted
*
*Exit:
*       if c is a lower case letter, returns wchar_t value of upper case
*       representation of c. otherwise, it returns c.
*
*Exceptions:
*
*******************************************************************************/

wchar_t __cdecl towupper (
        wchar_t c
        )
{
#if     !defined(_NTSUBSET_) && !defined(_POSIX_)

#ifdef  _MT

        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
            return __ascii_towupper(c);

        return __towupper_mt(ptloci, c);
}

/***
*wchar_t __towupper_mt(ptloci, c) - convert wide character to upper case
*
*Purpose:
*       Multi-thread function only! Non-locking version of towupper.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

wchar_t __cdecl __towupper_mt (
        pthreadlocinfo ptloci,
        wchar_t c
        )
{

#endif  /* _MT */

        wchar_t widechar;

        if (c == WEOF)
            return c;

#ifndef _MT
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
            return __ascii_towupper(c);
#endif

        /* if checking case of c does not require API call, do it */
        if ( c < 256 ) {
#ifdef  _MT
            if ( !__iswlower_mt(ptloci, c) ) {
#else
            if ( !iswlower(c) ) {
#endif
                return c;
            }
        }

#ifndef _XBOX
        /* convert wide char to uppercase */
#ifdef  _MT
        if ( 0 == __crtLCMapStringW( ptloci->lc_handle[LC_CTYPE], 
#else
        if ( 0 == __crtLCMapStringW( __lc_handle[LC_CTYPE], 
#endif
                                     LCMAP_UPPERCASE,
                                     (LPCWSTR)&c, 
                                     1, 
                                     (LPWSTR)&widechar, 
                                     1, 
#ifdef  _MT
                                     ptloci->lc_codepage ) )
#else
                                     __lc_codepage ) )
#endif
        {
            return c;
        }

        return widechar;

#else // XBOX

        return c;

#endif // XBOX

#else   /* _NTSUBSET_/_POSIX_ */

        return RtlUpcaseUnicodeChar( c );

#endif  /* _NTSUBSET_/_POSIX_ */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\wcstombs.c ===
/***
*wcstombs.c - Convert wide char string to multibyte char string.
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert a wide char string into the equivalent multibyte char string.
*
*Revision History:
*       08-24-90  KRS   Module created.
*       01-14-91  KRS   Added _WINSTATIC for Windows DLL.  Fix wctomb() call.
*       03-18-91  KRS   Fix check for NUL.
*       03-20-91  KRS   Ported from 16-bit tree.
*       10-16-91  ETC   Locale support under _INTL switch.
*       12-09-91  ETC   Updated nlsapi; added multithread.
*       08-20-92  KRS   Activated NLSAPI support.
*       08-22-92  SRW   Allow INTL definition to be conditional for building ntcrt.lib
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       01-06-93  CFW   Added (count < n) to outer loop - avoid bad wctomb calls
*       01-07-93  KRS   Major code cleanup.  Fix error return, comments.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       05-03-93  CFW   Return pointer == NULL, return size, plus massive cleanup.
*       06-01-93  CFW   Minor optimization and beautify.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-28-93  GJF   Merged NT SDK and Cuda versions.
*       01-14-94  SRW   if _NTSUBSET_ defined call Rtl functions
*       02-07-94  CFW   POSIXify.
*       08-03-94  CFW   Optimize for SBCS.
*       09-06-94  CFW   Remove _INTL switch.
*       11-22-94  CFW   WideCharToMultiByte will compare past NULL.
*       01-07-95  CFW   Mac merge cleanup.
*       02-06-95  CFW   assert -> _ASSERTE.
*       03-13-95  CFW   Fix wcsncnt counting.
*       04-19-95  CFW   Rearrange & fix non-Win32 version.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       12-07-95  SKS   Fix misspelling of _NTSUBSET_ (final _ was missing)
*       04-01-96  BWT   POSIX work.
*       06-25-96  GJF   Removed DLL_FOR_WIN32S. Replaced defined(_WIN32) with
*                       !defined(_MAC). Polished the format a bit.
*       02-27-98  RKP   Added 64 bit support.
*       06-23-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       08-27-98  GJF   Introduced __wcstombs_mt.
*       12-15-98  GJF   Changes for 64-bit size_t.
*       04-28-99  GJF   Changed dwFlags arg value to 0 in WideCharToMultiByte
*                       calls to avoid problems with codepage 1258 on NT 5.0.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#if     defined(_NTSUBSET_) || defined(_POSIX_)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <cruntime.h>
#include <stdlib.h>
#include <limits.h>
#include <internal.h>
#include <mtdll.h>
#include <dbgint.h>
#include <errno.h>
#include <locale.h>
#include <setlocal.h>

#ifdef _XBOX
#undef _MT
#endif

/***
*int __cdecl wcsncnt - count wide characters in a string, up to n.
*
*Purpose:
*       Internal local support function. Counts characters in string including NULL.
*       If NULL not found in n chars, then return n.
*
*Entry:
*       const wchar_t *string   - start of string
*       size_t n                - character count
*
*Exit:
*       returns number of wide characters from start of string to
*       NULL (inclusive), up to n.
*
*Exceptions:
*
*******************************************************************************/

static size_t __cdecl wcsncnt (
        const wchar_t *string,
        size_t cnt
        )
{
        size_t n = cnt+1;
        wchar_t *cp = (wchar_t *)string;

        while (--n && *cp)
            cp++;

        if (n && !*cp)
            return cp - string + 1;
        return cnt;
}

/***
*size_t wcstombs() - Convert wide char string to multibyte char string.
*
*Purpose:
*       Convert a wide char string into the equivalent multibyte char string,
*       according to the LC_CTYPE category of the current locale.
*       [ANSI].
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*              Non-C locale support now available under _INTL switch.
*Entry:
*       char *s            = pointer to destination multibyte char string
*       const wchar_t *pwc = pointer to source wide character string
*       size_t           n = maximum number of bytes to store in s
*
*Exit:
*       If s != NULL, returns    (size_t)-1 (if a wchar cannot be converted)
*       Otherwise:       Number of bytes modified (<=n), not including
*                    the terminating NUL, if any.
*
*Exceptions:
*       Returns (size_t)-1 if s is NULL or invalid mb character encountered.
*
*******************************************************************************/

size_t __cdecl wcstombs (
        char * s,
        const wchar_t * pwcs,
        size_t n
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __wcstombs_mt(ptloci, s, pwcs, n);
}

size_t __cdecl __wcstombs_mt (
        pthreadlocinfo ptloci,
        char * s,
        const wchar_t * pwcs,
        size_t n
        )
{
#endif
        size_t count = 0;
        int i, retval;
        char buffer[MB_LEN_MAX];
        BOOL defused = 0;

        if (s && n == 0)
            /* dest string exists, but 0 bytes converted */
            return (size_t) 0;

        _ASSERTE(pwcs != NULL);

#ifdef  _WIN64
        /* n must fit into an int for WideCharToMultiByte */
        if ( n > INT_MAX )
            return (size_t)-1;
#endif

#if     !defined( _NTSUBSET_ ) && !defined(_POSIX_)

        /* if destination string exists, fill it in */
        if (s)
        {
#ifdef  _MT
            if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#else
            if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#endif
            {
                /* C locale: easy and fast */
                while(count < n)
                {
                    if (*pwcs > 255)  /* validate high byte */
                    {
                        errno = EILSEQ;
                        return (size_t)-1;  /* error */
                    }
                    s[count] = (char) *pwcs;
                    if (*pwcs++ == L'\0')
                        return count;
                    count++;
                }
                return count;
            } else {

                if (1 == MB_CUR_MAX)
                {
                    /* If SBCS, one wchar_t maps to one char */

                    /* WideCharToMultiByte will compare past NULL - reset n */
                    if (n > 0)
                        n = wcsncnt(pwcs, n);

#ifdef  _MT
                    if ( ((count = WideCharToMultiByte( ptloci->lc_codepage,
#else
                    if ( ((count = WideCharToMultiByte( __lc_codepage,
#endif
                                                        0,
                                                        pwcs, 
                                                        (int)n, 
                                                        s,
                                                        (int)n, 
                                                        NULL, 
                                                        &defused )) != 0) &&
                         (!defused) )
                    {
                        if (*(s + count - 1) == '\0')
                            count--; /* don't count NUL */

                        return count;
                    }

                    errno = EILSEQ;
                    return (size_t)-1;
                }
                else {

                    /* If MBCS, wchar_t to char mapping unknown */

                    /* Assume that usually the buffer is large enough */
#ifdef  _MT
                    if ( ((count = WideCharToMultiByte( ptloci->lc_codepage,
#else
                    if ( ((count = WideCharToMultiByte( __lc_codepage,
#endif
                                                        0,
                                                        pwcs, 
                                                        -1,
                                                        s, 
                                                        (int)n, 
                                                        NULL, 
                                                        &defused )) != 0) &&
                         (!defused) )
                    {
                        return count - 1; /* don't count NUL */
                    }

                    if (defused || GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                    {
                        errno = EILSEQ;
                        return (size_t)-1;
                    }

                    /* buffer not large enough, must do char by char */
                    while (count < n)
                    {
#ifdef  _MT
                        if ( ((retval = WideCharToMultiByte( ptloci->lc_codepage, 
#else
                        if ( ((retval = WideCharToMultiByte( __lc_codepage, 
#endif
                                                             0,
                                                             pwcs, 
                                                             1, 
                                                             buffer,
                                                             MB_CUR_MAX, 
                                                             NULL, 
                                                             &defused )) == 0)
                             || defused )
                        {
                            errno = EILSEQ;
                            return (size_t)-1;
                        }

                        if (count + retval > n)
                            return count;

                        for (i = 0; i < retval; i++, count++) /* store character */
                            if((s[count] = buffer[i])=='\0')
                                return count;

                        pwcs++;
                    }

                    return count;
                }
            }
        }
        else { /* s == NULL, get size only, pwcs must be NUL-terminated */
#ifdef  _MT
            if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#else
            if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#endif
                return wcslen(pwcs);
            else {
#ifdef  _MT
                if ( ((count = WideCharToMultiByte( ptloci->lc_codepage,
#else
                if ( ((count = WideCharToMultiByte( __lc_codepage,
#endif
                                                    0,
                                                    pwcs,
                                                    -1,
                                                    NULL,
                                                    0,
                                                    NULL,
                                                    &defused )) == 0) ||
                     (defused) )
                {
                    errno = EILSEQ;
                    return (size_t)-1;
                }

                return count - 1;
            }
        }

#else /* _NTSUBSET_/_POSIX_ */

        /* if destination string exists, fill it in */
        if (s)
        {
            NTSTATUS Status;

            Status = RtlUnicodeToMultiByteN( s, 
                                             (ULONG) n, 
                                             (PULONG)&count, 
                                             (wchar_t *)pwcs, 
                                             (wcslen(pwcs) + 1) *
                                                sizeof(WCHAR) );

            if (NT_SUCCESS(Status))
            {
                return count - 1; /* don't count NUL */
            } else {
                errno = EILSEQ;
                count = (size_t)-1;
            }
        } else { /* s == NULL, get size only, pwcs must be NUL-terminated */
            NTSTATUS Status;

            Status = RtlUnicodeToMultiByteSize( (PULONG)&count, 
                                                (wchar_t *)pwcs, 
                                                (wcslen(pwcs) + 1) * 
                                                    sizeof(WCHAR) );

            if (NT_SUCCESS(Status))
            {
                return count - 1; /* don't count NUL */
            } else {
                errno = EILSEQ;
                count = (size_t)-1;
            }
        }
        return count;

#endif  /* _NTSUBSET_/_POSIX_ */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\wchtodig.c ===
/***
*wchtodig.c - Contains _wchartodigit function
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       _wchartodigit - convert wchar_t character to digit
*
*Revision History:
*       08-01-00  GB    Module Created
*
*******************************************************************************/

#include <wchar.h>

/***
*_wchartodigit(wchar_t) converts unicode character to it's corrosponding digit
*
*Purpose:
*   Convert unicode character to it's corrosponding digit
*
*Entry:
*   ch char to convert
*
*Exit:
*   good result: int 0-9
*
*   bad result: -1
*
*Exceptions:
*
*******************************************************************************/

int _wchartodigit(wchar_t ch)
{
#define DIGIT_RANGE_TEST(zero)  \
    if (ch < zero)              \
        return -1;              \
    if (ch < zero + 10)         \
    {                           \
        return ch - zero;       \
    }

    DIGIT_RANGE_TEST(0x0030)        // 0030;DIGIT ZERO
    if (ch < 0xFF10)                // FF10;FULLWIDTH DIGIT ZERO
    {
        DIGIT_RANGE_TEST(0x0660)    // 0660;ARABIC-INDIC DIGIT ZERO
        DIGIT_RANGE_TEST(0x06F0)    // 06F0;EXTENDED ARABIC-INDIC DIGIT ZERO
        DIGIT_RANGE_TEST(0x0966)    // 0966;DEVANAGARI DIGIT ZERO
        DIGIT_RANGE_TEST(0x09E6)    // 09E6;BENGALI DIGIT ZERO
        DIGIT_RANGE_TEST(0x0A66)    // 0A66;GURMUKHI DIGIT ZERO
        DIGIT_RANGE_TEST(0x0AE6)    // 0AE6;GUJARATI DIGIT ZERO
        DIGIT_RANGE_TEST(0x0B66)    // 0B66;ORIYA DIGIT ZERO
        DIGIT_RANGE_TEST(0x0C66)    // 0C66;TELUGU DIGIT ZERO
        DIGIT_RANGE_TEST(0x0CE6)    // 0CE6;KANNADA DIGIT ZERO
        DIGIT_RANGE_TEST(0x0D66)    // 0D66;MALAYALAM DIGIT ZERO
        DIGIT_RANGE_TEST(0x0E50)    // 0E50;THAI DIGIT ZERO
        DIGIT_RANGE_TEST(0x0ED0)    // 0ED0;LAO DIGIT ZERO
        DIGIT_RANGE_TEST(0x0F20)    // 0F20;TIBETAN DIGIT ZERO
        DIGIT_RANGE_TEST(0x1040)    // 1040;MYANMAR DIGIT ZERO
        DIGIT_RANGE_TEST(0x17E0)    // 17E0;KHMER DIGIT ZERO
        DIGIT_RANGE_TEST(0x1810)    // 1810;MONGOLIAN DIGIT ZERO


        return -1;
    }
#undef DIGIT_RANGE_TEST

                                    // FF10;FULLWIDTH DIGIT ZERO
    if (ch < 0xFF10 + 10) 
    { 
        return ch - 0xFF10; 
    }
    return -1;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\wcstol.c ===
/***
*wcstol.c - Contains C runtimes wcstol and wcstoul
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       wcstol - convert wchar_t string to long signed integer
*       wcstoul - convert wchar_t string to long unsigned integer
*
*Revision History:
*       06-15-92  KRS   Module created, based on strtol.c
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       04-21-93  GJF   Removed assumption that LONG_MIN == -LONG_MAX.
*       05-10-93  GJF   Fixed error check.
*       05-20-93  GJF   Nothing like taking ugly code and making prettier...
*                       and wrong. Fixed bug introduced on 5-10.
*       02-07-94  CFW   POSIXify.
*       04-01-96  BWT   POSIX work.
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct. Also, replaced iswdigit, iswalpha and towupper
*                       macros with __ascii_iswdigit, __ascii_iswalpha and
*                       __ascii_towupper macros.
*       02-03-99  GJF   Added range check to make sure args to __ascii_isw*
*                       macros are not too big.
*       08-01-00  GB    Added multilangual support
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <limits.h>
#include <errno.h>
#include <ctype.h>
#include <mtdll.h>

#ifdef _XBOX
#undef _MT
#endif

int _wchartodigit(wchar_t);

/***
*wcstol, wcstoul(nptr,endptr,ibase) - Convert ascii string to long un/signed
*       int.
*
*Purpose:
*       Convert an ascii string to a long 32-bit value.  The base
*       used for the caculations is supplied by the caller.  The base
*       must be in the range 0, 2-36.  If a base of 0 is supplied, the
*       ascii string must be examined to determine the base of the
*       number:
*           (a) First char = '0', second char = 'x' or 'X',
*               use base 16.
*           (b) First char = '0', use base 8
*           (c) First char in range '1' - '9', use base 10.
*
*       If the 'endptr' value is non-NULL, then wcstol/wcstoul places
*       a pointer to the terminating character in this value.
*       See ANSI standard for details
*
*Entry:
*       nptr == NEAR/FAR pointer to the start of string.
*       endptr == NEAR/FAR pointer to the end of the string.
*       ibase == integer base to use for the calculations.
*
*       string format: [whitespace] [sign] [0] [x] [digits/letters]
*
*Exit:
*       Good return:
*           result
*
*       Overflow return:
*           wcstol -- LONG_MAX or LONG_MIN
*           wcstoul -- ULONG_MAX
*           wcstol/wcstoul -- errno == ERANGE
*
*       No digits or bad base return:
*           0
*           endptr = nptr*
*
*Exceptions:
*       None.
*
*******************************************************************************/

/* flag values */
#define FL_UNSIGNED   1       /* wcstoul called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */


static unsigned long __cdecl wcstoxl (
        const wchar_t *nptr,
        const wchar_t **endptr,
        int ibase,
        int flags
        )
{
        const wchar_t *p;
        wchar_t c;
        unsigned long number;
        unsigned digval;
        unsigned long maxval;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();
#endif

        p = nptr;           /* p is our scanning pointer */
        number = 0;         /* start with zero */

        c = *p++;           /* read char */

#ifdef  _MT
        while ( __iswspace_mt(ptloci, c) )
#else
        while ( iswspace(c) )
#endif
            c = *p++;       /* skip whitespace */

        if (c == '-') {
            flags |= FL_NEG;    /* remember minus sign */
            c = *p++;
        }
        else if (c == '+')
            c = *p++;       /* skip sign */

        if (ibase < 0 || ibase == 1 || ibase > 36) {
            /* bad base! */
            if (endptr)
                /* store beginning of string in endptr */
                *endptr = nptr;
            return 0L;      /* return 0 */
        }
        else if (ibase == 0) {
            /* determine base free-lance, based on first two chars of
               string */
            if (_wchartodigit(c) != 0)
                ibase = 10;
            else if (*p == L'x' || *p == L'X')
                ibase = 16;
            else
                ibase = 8;
        }

        if (ibase == 16) {
            /* we might have 0x in front of number; remove if there */
            if (_wchartodigit(c) == 0 && (*p == L'x' || *p == L'X')) {
                ++p;
                c = *p++;   /* advance past prefix */
            }
        }

        /* if our number exceeds this, we will overflow on multiply */
        maxval = ULONG_MAX / ibase;


        for (;;) {  /* exit in middle of loop */

            /* convert c to value */
            if ( (digval = _wchartodigit(c)) != -1 )
                ;
            else if ( __ascii_iswalpha(c))
                digval = __ascii_towupper(c) - L'A' + 10;
            else
                break;

            if (digval >= (unsigned)ibase)
                break;      /* exit loop if bad digit found */

            /* record the fact we have read one digit */
            flags |= FL_READDIGIT;

            /* we now need to compute number = number * base + digval,
               but we need to know if overflow occured.  This requires
               a tricky pre-check. */

            if (number < maxval || (number == maxval &&
            (unsigned long)digval <= ULONG_MAX % ibase)) {
                /* we won't overflow, go ahead and multiply */
                number = number * ibase + digval;
            }
            else {
                /* we would have overflowed -- set the overflow flag */
                flags |= FL_OVERFLOW;
            }

            c = *p++;       /* read next digit */
        }

        --p;                /* point to place that stopped scan */

        if (!(flags & FL_READDIGIT)) {
            /* no number there; return 0 and point to beginning of
               string */
            if (endptr)
                /* store beginning of string in endptr later on */
                p = nptr;
            number = 0L;        /* return 0 */
        }
        else if ( (flags & FL_OVERFLOW) ||
              ( !(flags & FL_UNSIGNED) &&
                ( ( (flags & FL_NEG) && (number > -LONG_MIN) ) ||
                  ( !(flags & FL_NEG) && (number > LONG_MAX) ) ) ) )
        {
            /* overflow or signed overflow occurred */
            errno = ERANGE;
            if ( flags & FL_UNSIGNED )
                number = ULONG_MAX;
            else if ( flags & FL_NEG )
                number = (unsigned long)(-LONG_MIN);
            else
                number = LONG_MAX;
        }

        if (endptr != NULL)
            /* store pointer to char that stopped the scan */
            *endptr = p;

        if (flags & FL_NEG)
            /* negate result if there was a neg sign */
            number = (unsigned long)(-(long)number);

        return number;          /* done. */
}

long __cdecl wcstol (
        const wchar_t *nptr,
        wchar_t **endptr,
        int ibase
        )
{
        return (long) wcstoxl(nptr, endptr, ibase, 0);
}

unsigned long __cdecl wcstoul (
        const wchar_t *nptr,
        wchar_t **endptr,
        int ibase
        )
{
        return wcstoxl(nptr, endptr, ibase, FL_UNSIGNED);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\wcstod.c ===
/***
*wcstod.c - convert wide char string to floating point number
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert character string to floating point number
*
*Revision History:
*       06-15-92  KRS   Created from strtod.c.
*       11-06-92  KRS   Fix bugs in wctomb() loop.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       01-10-95  CFW   Debug CRT allocs.
*       04-01-96  BWT   POSIX work.
*       02-19-01  GB    added _alloca and Check for return value of _malloc_crt
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <math.h>
#include <dbgint.h>
#include <stdlib.h>
#include <malloc.h>
#include <fltintrn.h>

/***
*double wcstod(nptr, endptr) - convert wide string to double
*
*Purpose:
*       wcstod recognizes an optional string of tabs and spaces,
*       then an optional sign, then a string of digits optionally
*       containing a decimal point, then an optional e or E followed
*       by an optionally signed integer, and converts all this to
*       to a floating point number.  The first unrecognized
*       character ends the string, and is pointed to by endptr.
*
*Entry:
*       nptr - pointer to wide string to convert
*
*Exit:
*       returns value of wide character string
*       wchar_t **endptr - if not NULL, points to character which stopped
*               the scan
*
*Exceptions:
*
*******************************************************************************/

double __cdecl wcstod (
        const wchar_t *nptr,
        REG2 wchar_t **endptr
        )
{

#ifdef  _MT
        struct _flt answerstruct;
#endif

        FLT  answer;
        double       tmp;
        unsigned int flags;
        REG1 wchar_t *ptr = (wchar_t *) nptr;
        char * cptr;
        int malloc_flag = 0;
        int retval, len;
        int clen = 0;

        /* scan past leading space/tab characters */

        while (iswspace(*ptr))
            ptr++;

        __try{
            cptr = (char *)_alloca((wcslen(ptr)+1) * sizeof(wchar_t));
        }
        __except(1){ //EXCEPTION_EXECUTE_HANDLER
            _resetstkoflw();
            if ((cptr = (char *)_malloc_crt((wcslen(ptr)+1) * sizeof(wchar_t))) == NULL)
            {
                errno = ENOMEM;
                return 0.0;
            }
            malloc_flag = 1;
        }
        // UNDONE: check for errors
        for (len = 0; ptr[len]; len++)
            {
            if ((retval = wctomb(cptr+len,ptr[len]))<=0)
            break;
            clen += retval;
            }
        cptr[clen++] = '\0';

        /* let _fltin routine do the rest of the work */

#ifdef  _MT
        /* ok to take address of stack variable here; fltin2 knows to use ss */
        answer = _fltin2( &answerstruct, cptr, clen, 0, 0);
#else
        answer = _fltin(cptr, clen, 0, 0);
#endif

        if (malloc_flag)
            _free_crt(cptr);


        if ( endptr != NULL )
            *endptr = (wchar_t *) ptr + answer->nbytes;
            /* UNDONE: assumes no multi-byte chars in string */

        flags = answer->flags;
        if ( flags & (512 | 64)) {
            /* no digits found or invalid format:
               ANSI says return 0.0, and *endptr = nptr */
            tmp = 0.0;
            if ( endptr != NULL )
                *endptr = (wchar_t *) nptr;
        }
        else if ( flags & (128 | 1) ) {
            if ( *ptr == '-' )
                tmp = -HUGE_VAL;    /* negative overflow */
            else
                tmp = HUGE_VAL;     /* positive overflow */
            errno = ERANGE;
        }
        else if ( flags & 256 ) {
            tmp = 0.0;          /* underflow */
            errno = ERANGE;
        }
        else
            tmp = answer->dval;

        return(tmp);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\wcstoq.c ===
/***
*wcstoq.c - Contains C runtimes wcstoi64 and wcstoui64
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	wcstoi64 - convert ascii string to signed __int64 integer
*	wcstoui64- convert ascii string to unsigned __int64 integer
*
*Revision History:
*   02-11-00  GB    Module created, based on strtoq.c
*   06-02-00  GB    Fixed the bug for IA64_MIN value.
*   08-01-00  GB    Added multilangual support
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <limits.h>
#include <errno.h>
#include <ctype.h>
#include <mtdll.h>

#ifdef _XBOX
#undef _MT
#endif

int _wchartodigit(wchar_t ch);

/***
*wcstoq, wcstouq(nptr,endptr,ibase) - Convert ascii string to un/signed	__int64.
*
*Purpose:
*	Convert an ascii string to a 64-bit __int64 value.  The base
*	used for the caculations is supplied by the caller.  The base
*	must be in the range 0, 2-36.  If a base of 0 is supplied, the
*	ascii string must be examined to determine the base of the
*	number:
*		(a) First wchar_t = '0', second wchar_t = 'x' or 'X',
*		    use base 16.
*		(b) First wchar_t = '0', use base 8
*		(c) First wchar_t in range '1' - '9', use base 10.
*
*	If the 'endptr' value is non-NULL, then wcstoq/wcstouq places
*	a pointer to the terminating character in this value.
*	See ANSI standard for details
*
*Entry:
*	nptr == NEAR/FAR pointer to the start of string.
*	endptr == NEAR/FAR pointer to the end of the string.
*	ibase == integer base to use for the calculations.
*
*	string format: [whitespace] [sign] [0] [x] [digits/letters]
*
*Exit:
*	Good return:
*		result
*
*	Overflow return:
*		wcstoq -- _I64_MAX or _I64_MIN
*		wcstouq -- _UI64_MAX
*		wcstoq/wcstouq -- errno == ERANGE
*
*	No digits or bad base return:
*		0
*		endptr = nptr*
*
*Exceptions:
*	None.
*******************************************************************************/

/* flag values */
#define FL_UNSIGNED   1       /* wcstouq called */
#define FL_NEG	      2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */

static unsigned __int64 __cdecl wcstoxq (
	const wchar_t *nptr,
	const wchar_t **endptr,
	int ibase,
	int flags
	)
{
	const wchar_t *p;
	wchar_t c;
	unsigned __int64 number;
	unsigned digval;
	unsigned __int64 maxval;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();
#endif

	p = nptr;			/* p is our scanning pointer */
	number = 0;			/* start with zero */

	c = *p++;			/* read wchar_t */
#ifdef  _MT
    while ( __iswspace_mt(ptloci, c) )
#else
    while ( iswspace(c) )
#endif
		c = *p++;		/* skip whitespace */

	if (c == '-') {
		flags |= FL_NEG;	/* remember minus sign */
		c = *p++;
	}
	else if (c == '+')
		c = *p++;		/* skip sign */

	if (ibase < 0 || ibase == 1 || ibase > 36) {
		/* bad base! */
		if (endptr)
			/* store beginning of string in endptr */
			*endptr = nptr;
		return 0L;		/* return 0 */
	}
	else if (ibase == 0) {
		/* determine base free-lance, based on first two chars of
		   string */
		if (_wchartodigit(c) != 0)
			ibase = 10;
		else if (*p == 'x' || *p == 'X')
			ibase = 16;
		else
			ibase = 8;
	}

	if (ibase == 16) {
		/* we might have 0x in front of number; remove if there */
	if (_wchartodigit(c) == 0 && (*p == L'x' || *p == L'X')) {
			++p;
			c = *p++;	/* advance past prefix */
		}
	}

	/* if our number exceeds this, we will overflow on multiply */
	maxval = _UI64_MAX / ibase;


	for (;;) {	/* exit in middle of loop */
		/* convert c to value */
		if ( (digval = _wchartodigit(c)) != -1 )
 			;
		else if ( __ascii_iswalpha(c) )
			digval = toupper(c) - 'A' + 10;
		else
			break;
		if (digval >= (unsigned)ibase)
			break;		/* exit loop if bad digit found */

		/* record the fact we have read one digit */
		flags |= FL_READDIGIT;

		/* we now need to compute number = number * base + digval,
		   but we need to know if overflow occured.  This requires
		   a tricky pre-check. */

		if (number < maxval || (number == maxval &&
		(unsigned __int64)digval <= _UI64_MAX % ibase)) {
			/* we won't overflow, go ahead and multiply */
			number = number * ibase + digval;
		}
		else {
			/* we would have overflowed -- set the overflow flag */
			flags |= FL_OVERFLOW;
		}

		c = *p++;		/* read next digit */
	}

	--p;				/* point to place that stopped scan */

	if (!(flags & FL_READDIGIT)) {
		/* no number there; return 0 and point to beginning of
		   string */
		if (endptr)
			/* store beginning of string in endptr later on */
			p = nptr;
		number = 0L;		/* return 0 */
	}
    else if ( (flags & FL_OVERFLOW) ||
              ( !(flags & FL_UNSIGNED) &&
                ( ( (flags & FL_NEG) && (number > -_I64_MIN) ) ||
                  ( !(flags & FL_NEG) && (number > _I64_MAX) ) ) ) )
    {
        /* overflow or signed overflow occurred */
        errno = ERANGE;
        if ( flags & FL_UNSIGNED )
            number = _UI64_MAX;
        else if ( flags & FL_NEG )
            number = (_I64_MIN);
        else
            number = _I64_MAX;
    }

	if (endptr != NULL)
		/* store pointer to wchar_t that stopped the scan */
		*endptr = p;

	if (flags & FL_NEG)
		/* negate result if there was a neg sign */
		number = (unsigned __int64)(-(__int64)number);

	return number;			/* done. */
}


__int64 _CRTIMP __cdecl _wcstoi64(
    const wchar_t *nptr,
    wchar_t **endptr,
    int ibase
    )
{
    return (__int64) wcstoxq(nptr, endptr, ibase, 0);
}
unsigned __int64 _CRTIMP __cdecl _wcstoui64 (
	const wchar_t *nptr,
	wchar_t **endptr,
	int ibase
	)
{
	return wcstoxq(nptr, endptr, ibase, FL_UNSIGNED);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\wtof.c ===
/***
*wtof.c - convert wchar_t string to floating point number
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts a wide character string into a floating point number.
*
*Revision History:
*       05-18-00  GB    written.
*       08-29-00  GB    Fixed buffer overrun.
*       02-19-01  GB    added _alloca and Check for return value of _malloc_crt
*
*******************************************************************************/
#ifndef _POSIX_

#ifndef _UNICODE
#define _UNICODE
#endif

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <dbgint.h>
#include <errno.h>
#include <malloc.h>
/***
*double wtof(ptr) - convert wide char string to floating point number
*
*Purpose:
*       atof recognizes an optional string of whitespace, then
*       an optional sign, then a string of digits optionally
*       containing a decimal point, then an optional e or E followed
*       by an optionally signed integer, and converts all this to
*       to a floating point number.  The first unrecognized
*       character ends the string.
*
*Entry:
*       ptr - pointer to wide char string to convert
*
*Exit:
*       returns floating point value of wide character representation
*
*Exceptions:
*
*******************************************************************************/
double __cdecl _wtof(
        const wchar_t *ptr
        )
{
    char *cptr;
    int malloc_flag = 0;
    size_t len;
    double retval;
    while (iswspace(*ptr))
        ptr++;
    
    len = wcstombs(NULL, ptr, 0);
    __try{
        cptr = (char *)_alloca((len+1) * sizeof(wchar_t));
    }
    __except(1){    //EXCEPTION_EXECUTE_HANDLER
        _resetstkoflw();
        if ((cptr = (char *)_malloc_crt((len+1) * sizeof(wchar_t))) == NULL)
        {
            errno = ENOMEM;
            return 0.0;
        }
        malloc_flag = 1;
    }
    // UNDONE: check for errors
    // Add one to len so as to null terminate cptr.
    wcstombs(cptr, ptr, len+1);
    retval = atof(cptr);
    if (malloc_flag)
        _free_crt(cptr);

    return retval;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\wctomb.c ===
/***
*wctomb.c - Convert wide character to multibyte character.
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert a wide character into the equivalent multibyte character.
*
*Revision History:
*       03-19-90  KRS   Module created.
*       12-20-90  KRS   Include ctype.h.
*       01-14-91  KRS   Fix argument error: wchar is pass-by-value.
*       03-20-91  KRS   Ported from 16-bit tree.
*       07-23-91  KRS   Hard-coded for "C" locale to avoid bogus interim #'s.
*       10-15-91  ETC   Locale support under _INTL (finally!).
*       12-09-91  ETC   Updated nlsapi; added multithread.
*       08-20-92  KRS   Activated NLSAPI support.
*       08-22-92  SRW   Allow INTL definition to be conditional for building ntcrt.lib
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       05-04-93  CFW   Kinder, gentler error handling.
*       06-01-93  CFW   Minor optimization and beautify.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-28-93  GJF   Merged NT SDK and Cuda versions.
*       01-14-94  SRW   if _NTSUBSET_ defined call Rtl functions
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Remove _INTL switch.
*       01-07-95  CFW   Mac merge cleanup.
*       04-19-95  CFW   Rearrange & fix non-Win32 version.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       12-07-95  SKS   Fix misspelling of _NTSUBSET_ (final _ was missing)
*       04-01-96  BWT   POSIX work.
*       06-25-96  GJF   Removed DLL_FOR_WIN32S. Replaced defined(_WIN32) with
*                       !defined(_MAC). Polished the format a bit.
*       07-22-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       04-28-99  GJF   Changed dwFlags arg value to 0 in WideCharToMultiByte
*                       calls to avoid problems with codepage 1258 on NT 5.0.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#if     defined(_NTSUBSET_) || defined(_POSIX_)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <cruntime.h>
#include <stdlib.h>
#include <mtdll.h>
#include <errno.h>
#include <locale.h>
#include <setlocal.h>

#ifdef _XBOX
#undef _MT
#endif

/***
*int wctomb() - Convert wide character to multibyte character.
*
*Purpose:
*       Convert a wide character into the equivalent multi-byte character,
*       according to the LC_CTYPE category of the current locale.
*       [ANSI].
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*              Non-C locale support now available under _INTL switch.
*Entry:
*       char *s          = pointer to multibyte character
*       wchar_t wchar        = source wide character
*
*Exit:
*       If s = NULL, returns 0, indicating we only use state-independent
*       character encodings.
*       If s != NULL, returns:
*                   -1 (if error) or number of bytes comprising
*                   converted mbc
*
*Exceptions:
*
*******************************************************************************/

int __cdecl wctomb (
        char *s,
        wchar_t wchar
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __wctomb_mt(ptloci, s, wchar);
}

int __cdecl __wctomb_mt (
        pthreadlocinfo ptloci,
        char *s,
        wchar_t wchar
        )
{
#endif
        if ( !s )
            /* indicate do not have state-dependent encodings */
            return 0;

#ifndef _XBOX
#if     defined(_NTSUBSET_) || defined(_POSIX_)

        {
            NTSTATUS Status;
            int size;

            Status = RtlUnicodeToMultiByteN( s, 
                                             MB_CUR_MAX, 
                                             (PULONG)&size, 
                                             &wchar, 
                                             sizeof( wchar )
                                             );

            if (!NT_SUCCESS(Status))
            {
                errno = EILSEQ;
                size = -1;
            }
            return size;
        }

#else   /* _NTSUBSET_/_POSIX_ */

#ifdef  _MT
        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#else
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#endif
        {
            if ( wchar > 255 )  /* validate high byte */
            {
                errno = EILSEQ;
                return -1;
            }

            *s = (char) wchar;
            return sizeof(char);
        }
        else
        {
            int size;
            BOOL defused = 0;

#ifdef  _MT
            if ( ((size = WideCharToMultiByte( ptloci->lc_codepage,
#else
            if ( ((size = WideCharToMultiByte( __lc_codepage,
#endif
                                               0,
                                               &wchar,
                                               1,
                                               s,
#ifdef  _MT
                                               ptloci->mb_cur_max,
#else
                                               MB_CUR_MAX,
#endif
                                               NULL,
                                               &defused) ) == 0) || 
                 (defused) )
            {
                errno = EILSEQ;
                return -1;
            }

            return size;
        }

#endif  /* ! _NTSUBSET_/_POSIX_ */
#else // XBOX
        if ( wchar > 255 )  /* validate high byte */
        {
            errno = EILSEQ;
            return -1;
        }

        *s = (char) wchar;
        return sizeof(char);
#endif // XBOX
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\wtox.c ===
/***
*wtox.c - _wtoi and _wtol conversion
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts a wide character string into an int or long.
*
*Revision History:
*       09-10-93  CFW   Module created, based on ASCII version.
*       10-07-93  CFW   Optimize WideCharToMultiByte, use NULL default char.
*       02-07-94  CFW   POSIXify.
*       03-13-95  CFW   Use -1 for length since NT compares past NULLS.
*       01-19-96  BWT   Add __int64 versions.
*       05-13-96  BWT   Fix _NTSUBSET_ version
*       11-03-76  JWM   Fix buffer-size bug in __int64 version.
*       05-23-00  GB    Using ascii version with tchar macros for UNICODE
*                       version.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE
#define _UNICODE
#endif

#include <wchar.h>
#include "atox.c"
#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\xtoa.c ===
/***
*xtoa.c - convert integers/longs to ASCII string
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       The module has code to convert integers/longs to ASCII strings.  See
*
*Revision History:
*       06-06-89  PHG   Module created, based on asm version
*       03-06-90  GJF   Fixed calling type, added #include <cruntime.h> and
*                       fixed copyright.
*       03-23-90  GJF   Made xtoa() _CALLTYPE4.
*       09-27-90  GJF   New-style function declarators.
*       01-21-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       01-19-96  BWT   Add __int64 versions.
*       09-22-97  GJF   Added negation handling to x64toa.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <limits.h>

/***
*char *_itoa, *_ltoa, *_ultoa(val, buf, radix) - convert binary int to ASCII
*       string
*
*Purpose:
*       Converts an int to a character string.
*
*Entry:
*       val - number to be converted (int, long or unsigned long)
*       int radix - base to convert into
*       char *buf - ptr to buffer to place result
*
*Exit:
*       fills in space pointed to by buf with string result
*       returns a pointer to this buffer
*
*Exceptions:
*
*******************************************************************************/

/* helper routine that does the main job. */

static void __cdecl xtoa (
        unsigned long val,
        char *buf,
        unsigned radix,
        int is_neg
        )
{
        char *p;                /* pointer to traverse string */
        char *firstdig;         /* pointer to first digit */
        char temp;              /* temp char */
        unsigned digval;        /* value of digit */

        p = buf;

        if (is_neg) {
            /* negative, so output '-' and negate */
            *p++ = '-';
            val = (unsigned long)(-(long)val);
        }

        firstdig = p;           /* save pointer to first digit */

        do {
            digval = (unsigned) (val % radix);
            val /= radix;       /* get next digit */

            /* convert to ascii and store */
            if (digval > 9)
                *p++ = (char) (digval - 10 + 'a');  /* a letter */
            else
                *p++ = (char) (digval + '0');       /* a digit */
        } while (val > 0);

        /* We now have the digit of the number in the buffer, but in reverse
           order.  Thus we reverse them now. */

        *p-- = '\0';            /* terminate string; p points to last digit */

        do {
            temp = *p;
            *p = *firstdig;
            *firstdig = temp;   /* swap *p and *firstdig */
            --p;
            ++firstdig;         /* advance to next two digits */
        } while (firstdig < p); /* repeat until halfway */
}

/* Actual functions just call conversion helper with neg flag set correctly,
   and return pointer to buffer. */

char * __cdecl _itoa (
        int val,
        char *buf,
        int radix
        )
{
        if (radix == 10 && val < 0)
            xtoa((unsigned long)val, buf, radix, 1);
        else
            xtoa((unsigned long)(unsigned int)val, buf, radix, 0);
        return buf;
}

char * __cdecl _ltoa (
        long val,
        char *buf,
        int radix
        )
{
        xtoa((unsigned long)val, buf, radix, (radix == 10 && val < 0));
        return buf;
}

char * __cdecl _ultoa (
        unsigned long val,
        char *buf,
        int radix
        )
{
        xtoa(val, buf, radix, 0);
        return buf;
}

#ifndef _NO_INT64

static void __stdcall x64toa (      /* stdcall is faster and smaller... Might as well use it for the helper. */
        unsigned __int64 val,
        char *buf,
        unsigned radix,
        int is_neg
        )
{
        char *p;                /* pointer to traverse string */
        char *firstdig;         /* pointer to first digit */
        char temp;              /* temp char */
        unsigned digval;        /* value of digit */

        p = buf;

        if ( is_neg )
        {
            *p++ = '-';         /* negative, so output '-' and negate */
            val = (unsigned __int64)(-(__int64)val);
        }

        firstdig = p;           /* save pointer to first digit */

        do {
            digval = (unsigned) (val % radix);
            val /= radix;       /* get next digit */

            /* convert to ascii and store */
            if (digval > 9)
                *p++ = (char) (digval - 10 + 'a');  /* a letter */
            else
                *p++ = (char) (digval + '0');       /* a digit */
        } while (val > 0);

        /* We now have the digit of the number in the buffer, but in reverse
           order.  Thus we reverse them now. */

        *p-- = '\0';            /* terminate string; p points to last digit */

        do {
            temp = *p;
            *p = *firstdig;
            *firstdig = temp;   /* swap *p and *firstdig */
            --p;
            ++firstdig;         /* advance to next two digits */
        } while (firstdig < p); /* repeat until halfway */
}

/* Actual functions just call conversion helper with neg flag set correctly,
   and return pointer to buffer. */

char * __cdecl _i64toa (
        __int64 val,
        char *buf,
        int radix
        )
{
        x64toa((unsigned __int64)val, buf, radix, (radix == 10 && val < 0));
        return buf;
}

char * __cdecl _ui64toa (
        unsigned __int64 val,
        char *buf,
        int radix
        )
{
        x64toa(val, buf, radix, 0);
        return buf;
}

#endif /* _NO_INT64 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\_fptostr.c ===
/***
*_fptostr.c - workhorse routine for converting floating point to string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Workhorse routine for fcvt, ecvt.
*
*Revision History:
*	09-17-84  DFW	created
*	03-05-90  GJF	Fixed calling type, added #include <cruntime.h>,
*			removed #include <register.h>, fixed copyright. Also,
*			cleaned up the formatting a bit.
*	07-20-90  SBM	Compiles cleanly with -W3 (added #include <string.h>)
*	08-01-90  SBM	Renamed <struct.h> to <fltintrn.h>
*	09-27-90  GJF	New-style function declarator.
*	06-11-92  GDP	Bug fix: Shorten string if leadig (overflow) digit is 1
*	10-09-92  GDP	Backed out last fix for ecvt (printf regressed)
*	04-06-93  SKS	Replace _CRTAPI* with _cdecl
*	04-27-94  CFW	Replace modified GDP 06-11-92 fix.
*	08-05-94  JWM	Backed out CFW's fix for ecvt (printf regression!).
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <fltintrn.h>

/***
*void _fptostr(buf, digits, pflt) - workhorse floating point conversion
*
*Purpose:
*	This is the workhorse routine for fcvt, ecvt. Here is where
*	all the digits are put into a buffer and the rounding is
*	performed and indicators of the decimal point position are set. Note,
*	this must not change the mantissa field of pflt since routines which
*	use this routine rely on this being unchanged.
*
*Entry:
*	char *buf - the buffer in which the digits are to be put
*	int digits - the number of digits which are to go into the buffer
*	STRFLT pflt - a pointer to a structure containing information on the
*		floating point value, including a string containing the
*		non-zero significant digits of the mantissa.
*
*Exit:
*	Changes the contents of the buffer and also may increment the decpt
*	field of the structure pointer to by the 'pflt' parameter if overflow
*	occurs during rounding (e.g. 9.999999... gets rounded to 10.000...).
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _fptostr (
	char *buf,
	REG4 int digits,
	REG3 STRFLT pflt
	)
{
	REG1 char *pbuf = buf;
	REG2 char *mantissa = pflt->mantissa;

	/* initialize the first digit in the buffer to '0' (NOTE - NOT '\0')
	 * and set the pointer to the second digit of the buffer.  The first
	 * digit is used to handle overflow on rounding (e.g. 9.9999...
	 * becomes 10.000...) which requires a carry into the first digit.
	 */

	*pbuf++ = '0';

	/* Copy the digits of the value into the buffer (with 0 padding)
	 * and insert the terminating null character.
	 */

	while (digits > 0) {
		*pbuf++ = (*mantissa) ? *mantissa++ : (char)'0';
		digits--;
	}
        *pbuf = '\0';

	/* do any rounding which may be needed.  Note - if digits < 0 don't
	 * do any rounding since in this case, the rounding occurs in  a digit
	 * which will not be output beause of the precision requested
	 */

	if (digits >= 0 && *mantissa >= '5') {
		pbuf--;
		while (*pbuf == '9')
			*pbuf-- = '0';
		*pbuf += 1;
	}

	if (*buf == '1') {
		/* the rounding caused overflow into the leading digit (e.g.
		 * 9.999.. went to 10.000...), so increment the decpt position
		 * by 1
		 */
		pflt->decpt++;
	}
	else {
		/* move the entire string to the left one digit to remove the
		 * unused overflow digit.
		 */
		memmove(buf, buf+1, strlen(buf+1)+1);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\_ctype.c ===
/***
*_ctype.c - function versions of ctype macros
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This files provides function versions of the character
*       classification and conversion macros in ctype.h.
*
*Revision History:
*       06-05-89  PHG   Module created
*       03-05-90  GJF   Fixed calling type, #include <cruntime.h>, fixed
*                       copyright.
*       09-27-90  GJF   New-style function declarators.
*       01-16-91  GJF   ANSI naming.
*       02-03-92  GJF   Got rid of #undef/#include-s, the MIPS compiler didn't
*                       like 'em.
*       08-07-92  GJF   Fixed function calling type macros.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       07-16-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*
*******************************************************************************/

/***
*ctype - Function versions of ctype macros
*
*Purpose:
*       Function versions of the macros in ctype.h.  In order to define
*       these, we use a trick -- we undefine the macro so we can use the
*       name in the function declaration, then re-include the file so
*       we can use the macro in the definition part.
*
*       Functions defined:
*           isalpha     isupper     islower
*           isdigit     isxdigit    isspace
*           ispunct     isalnum     isprint
*           isgraph     isctrl      __isascii
*           __toascii   __iscsym    __iscsymf
*
*Entry:
*       int c = character to be tested
*Exit:
*       returns non-zero = character is of the requested type
*                  0 = character is NOT of the requested type
*
*Exceptions:
*       None.
*
*******************************************************************************/

#include <cruntime.h>
#include <ctype.h>
#include <mtdll.h>

#ifdef _XBOX
#undef _MT
#endif

int (__cdecl isalpha) (
        int c
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __isalpha_mt(ptloci, c);
#else
        return isalpha(c);
#endif
}

int (__cdecl isupper) (
        int c
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __isupper_mt(ptloci, c);
#else
        return isupper(c);
#endif
}

int (__cdecl islower) (
        int c
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __islower_mt(ptloci, c);
#else
        return islower(c);
#endif
}

int (__cdecl isdigit) (
        int c
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __isdigit_mt(ptloci, c);
#else
        return isdigit(c);
#endif
}

int (__cdecl isxdigit) (
        int c
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __isxdigit_mt(ptloci, c);
#else
        return isxdigit(c);
#endif
}

int (__cdecl isspace) (
        int c
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __isspace_mt(ptloci, c);
#else
        return isspace(c);
#endif
}

int (__cdecl ispunct) (
        int c
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __ispunct_mt(ptloci, c);
#else
        return ispunct(c);
#endif
}

int (__cdecl isalnum) (
        int c
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __isalnum_mt(ptloci, c);
#else
        return isalnum(c);
#endif
}

int (__cdecl isprint) (
        int c
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __isprint_mt(ptloci, c);
#else
        return isprint(c);
#endif
}

int (__cdecl isgraph) (
        int c
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __isgraph_mt(ptloci, c);
#else
        return isgraph(c);
#endif
}

int (__cdecl iscntrl) (
        int c
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return __iscntrl_mt(ptloci, c);
#else
        return iscntrl(c);
#endif
}

int (__cdecl __isascii) (
        int c
        )
{
        return __isascii(c);
}

int (__cdecl __toascii) (
        int c
        )
{
        return __toascii(c);
}

int (__cdecl __iscsymf) (
        int c
        )
{
        return __iscsymf(c);
}

int (__cdecl __iscsym) (
        int c
        )
{
        return __iscsym(c);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\direct\drivemap.c ===
/***
*drivemap.c - _getdrives
*
*	Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _getdrives()
*
*Revision History:
*	08-22-91  BWM	Wrote module.
*	04-06-93  SKS	Replace _CRTAPI* with _cdecl
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <oscalls.h>
#include <direct.h>

#if !defined(_WIN32)
#error ERROR - ONLY WIN32 TARGET SUPPORTED!
#endif

/***
*void _getdrivemap(void) - Get bit map of all available drives
*
*Purpose:
*
*Entry:
*
*Exit:
*	drive map with drive A in bit 0, B in 1, etc.
*
*Exceptions:
*
*******************************************************************************/

unsigned long __cdecl _getdrives()
{
#ifdef _XBOX
    RIP("_getdrives() not supported on Xbox");
    return 0x03FFFFFF;
#else  // _XBOX
    return (GetLogicalDrives());
#endif // XBOX
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\xtow.c ===
/***
*xtow.c - convert integers/longs to wide char string
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       The module has code to convert integers/longs to wide char strings.
*
*Revision History:
*       09-10-93  CFW   Module created, based on ASCII version.
*       02-07-94  CFW   POSIXify.
*       01-19-96  BWT   Add __int64 versions.
*       05-13-96  BWT   Fix _NTSUBSET_ version
*       08-21-98  GJF   Bryan's _NTSUBSET_ version is the correct
*                       implementation.
*
*******************************************************************************/

#ifndef _POSIX_

#include <windows.h>
#include <stdlib.h>

#define INT_SIZE_LENGTH   20
#define LONG_SIZE_LENGTH  40

#define I64_SIZE_LENGTH     80

/***
*wchar_t *_itow, *_ltow, *_ultow(val, buf, radix) - convert binary int to wide
*       char string
*
*Purpose:
*       Converts an int to a wide character string.
*
*Entry:
*       val - number to be converted (int, long or unsigned long)
*       int radix - base to convert into
*       wchar_t *buf - ptr to buffer to place result
*
*Exit:
*       calls ASCII version to convert, converts ASCII to wide char into buf
*       returns a pointer to this buffer
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl _itow (
        int val,
        wchar_t *buf,
        int radix
        )
{
        char astring[INT_SIZE_LENGTH];

        _itoa (val, astring, radix);
        mbstowcs(buf, astring, INT_SIZE_LENGTH);
        return (buf);
}

wchar_t * __cdecl _ltow (
        long val,
        wchar_t *buf,
        int radix
        )
{
        char astring[LONG_SIZE_LENGTH];

        _ltoa (val, astring, radix);
        mbstowcs(buf, astring, LONG_SIZE_LENGTH);
        return (buf);
}

wchar_t * __cdecl _ultow (
        unsigned long val,
        wchar_t *buf,
        int radix
        )
{
        char astring[LONG_SIZE_LENGTH];

        _ultoa (val, astring, radix);
        mbstowcs(buf, astring, LONG_SIZE_LENGTH);
        return (buf);
}

#ifndef _NO_INT64

wchar_t * __cdecl _i64tow (
        __int64 val,
        wchar_t *buf,
        int radix
        )
{
        char astring[I64_SIZE_LENGTH];

        _i64toa (val, astring, radix);
        mbstowcs(buf, astring, I64_SIZE_LENGTH);
        return (buf);
}

wchar_t * __cdecl _ui64tow (
        unsigned __int64 val,
        wchar_t *buf,
        int radix
        )
{
        char astring[I64_SIZE_LENGTH];

        _ui64toa (val, astring, radix);
        mbstowcs(buf, astring, I64_SIZE_LENGTH);
        return (buf);
}

#endif /* _NO_INT64 */

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\_mbslen.c ===
/***
*_mbslen.c - Return number of multibyte characters in a multibyte string
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Return number of multibyte characters in a multibyte string
*       excluding the terminal null.  Locale-dependent.
*
*Revision History:
*       10-01-91  ETC   Created.
*       12-08-91  ETC   Add multithread lock.
*       12-18-92  CFW   Ported to Cuda tree, changed _CALLTYPE1 to _CRTAPI1.
*       04-29-93  CFW   Change to const char *s.
*       06-01-93  CFW   Test for bad MB chars.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       06-03-93  CFW   Change name to avoid conflict with mbstring function.
*                       Change return type to size_t.
*       08-19-93  CFW   Disallow skipping LB:NULL combos.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       10-22-93  CFW   Test for invalid MB chars using global preset flag.
*       01-14-94  SRW   if _NTSUBSET_ defined call Rtl functions
*       09-06-94  CFW   Remove _INTL switch.
*       12-21-94  CFW   Remove invalid MB chars NT 3.1 hack.
*       02-06-95  CFW   assert -> _ASSERTE.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       04-01-96  BWT   POSIX work.
*       06-21-96  GJF   Purged DLL_FOR_WIN32S. Polished format a bit.
*       07-16-96  SKS   Added missing call to _unlock_locale()
*       02-27-98  RKP	Added 64 bit support.
*       07-22-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*
*******************************************************************************/

#if     defined(_NTSUBSET_) || defined(_POSIX_)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif
#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <ctype.h>
#include <mtdll.h>
#include <locale.h>
#include <setlocal.h>
#include <dbgint.h>

#ifdef _XBOX
#undef _MT
#endif

/***
*_mbstrlen - Return number of multibyte characters in a multibyte string
*
*Purpose:
*       Return number of multibyte characters in a multibyte string
*       excluding the terminal null.  Locale-dependent.
*
*Entry:
*       char *s = string
*
*Exit:
*       Returns the number of multibyte characters in the string, or
*       (size_t)-1 if the string contains an invalid multibyte character.
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl _mbstrlen(
        const char *s
        )
{
        size_t n;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();
#endif

        _ASSERTE (MB_CUR_MAX == 1 || MB_CUR_MAX == 2);

#ifdef  _MT
        if ( ptloci->mb_cur_max == 1 )
#else
        if ( MB_CUR_MAX == 1 )
#endif
            /* handle single byte character sets */
            return (int)strlen(s);

#if     !defined(_NTSUBSET_) && !defined(_POSIX_)

        /* verify all valid MB chars */
#ifdef  _MT
        if ( MultiByteToWideChar( ptloci->lc_codepage,
#else
        if ( MultiByteToWideChar( __lc_codepage,
#endif
#ifdef _XBOX
                                  0,
#else
                                  MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
#endif
                                  s, 
                                  -1, 
                                  NULL, 
                                  0 ) == 0 ) 
        {
            /* bad MB char */
            return (size_t)-1;
        }

        /* count MB chars */
        for (n = 0; *s; n++, s++) {
#ifdef  _MT
            if ( __isleadbyte_mt(ptloci, (unsigned char)*s) ) {
#else
            if ( isleadbyte((unsigned char)*s) ) {
#endif
                if (*++s == '\0')
                    break;
            }
        }

#else

        {
            char *s1 = (char *)s;


            while (RtlAnsiCharToUnicodeChar( &s1 ) != UNICODE_NULL)
                ;

            n = s1 - s;
        }

#endif

        return(n);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\direct\drivfree.c ===
/***
*drivfree.c - Get the size of a disk
*
*	Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file has _getdiskfree()
*
*Revision History:
*	08-21-91  PHG	Module created for Win32
*	10-24-91  GJF	Added LPDWORD casts to make MIPS compiler happy.
*			ASSUMES THAT sizeof(unsigned) == sizeof(DWORD).
*	04-06-93  SKS	Replace _CRTAPI* with _cdecl
*	01-27-95  GJF	Removed explicit handling for case where the default
*			drive is specified and the current directory is a
*			UNC path Also, cleaned up a bit.
*	01-31-95  GJF	Further cleanup, as suggested by Richard Shupak.
*
*******************************************************************************/

#include <cruntime.h>
#include <direct.h>
#include <oscalls.h>

/***
*int _getdiskfree(drivenum, diskfree)  - get size of a specified disk
*
*Purpose:
*	Gets the size of the current or specified disk drive
*
*Entry:
*	int drivenum - 0 for current drive, or drive 1-26
*
*Exit:
*	returns 0 if succeeds
*	returns system error code on error.
*
*Exceptions:
*
*******************************************************************************/

#ifndef _WIN32
#error ERROR - ONLY WIN32 TARGET SUPPORTED!
#endif

unsigned __cdecl _getdiskfree (
	unsigned uDrive,
	struct _diskfree_t * pdf
	)
{
	char   Root[4];
	char * pRoot;

	if ( uDrive == 0 ) {
	    pRoot = NULL;
	}
	else if ( uDrive > 26 ) {
	    return ( ERROR_INVALID_PARAMETER );
	}
	else {
	    pRoot = &Root[0];
	    Root[0] = (char)uDrive + (char)('A' - 1);
	    Root[1] = ':';
	    Root[2] = '\\';
	    Root[3] = '\0';
	}


	if ( !GetDiskFreeSpace( pRoot,
				(LPDWORD)&(pdf->sectors_per_cluster),
				(LPDWORD)&(pdf->bytes_per_sector),
				(LPDWORD)&(pdf->avail_clusters),
				(LPDWORD)&(pdf->total_clusters)) )
	{
	    return ( (unsigned)GetLastError() );
	}
	return ( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\convert\_wctype.c ===
/***
*_wctype.c - function versions of wctype macros
*
*	Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file provides function versions of the wide character
*	classification and conversion macros in ctype.h.
*
*Revision History:
*	10-11-91  ETC	Created from _ctype.c
*	12-08-91  ETC	Surround with #ifdef _INTL
*	04-06-92  KRS	Remove _INTL rwitches again
*	10-26-92  GJF	Cleaned up a bit.
*	04-06-93  SKS	Replace _CRTAPI* with _cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

/***
*wctype - Function versions of wctype macros
*
*Purpose:
*	Function versions of the wide char macros in ctype.h,
*	including isleadbyte and iswascii.  In order to define
*	these, we use a trick -- we undefine the macro so we can use the
*	name in the function declaration, then re-include the file so
*	we can use the macro in the definition part.
*
*	Functions defined:
*	    iswalpha	iswupper     iswlower
*	    iswdigit	iswxdigit    iswspace
*	    iswpunct	iswalnum     iswprint
*	    iswgraph	iswctrl	     iswascii
*	    			     isleadbyte
*
*Entry:
*	wchar_t c = character to be tested
*Exit:
*	returns non-zero = character is of the requested type
*		   0 = character is NOT of the requested type
*
*Exceptions:
*	None.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <ctype.h>

int (__cdecl isleadbyte) (
	int c
	)
{
	return isleadbyte(c);
}

int (__cdecl iswalpha) (
	wchar_t c
	)
{
	return iswalpha(c);
}

int (__cdecl iswupper) (
	wchar_t c
	)
{
	return iswupper(c);
}

int (__cdecl iswlower) (
	wchar_t c
	)
{
	return iswlower(c);
}

int (__cdecl iswdigit) (
	wchar_t c
	)
{
	return iswdigit(c);
}

int (__cdecl iswxdigit) (
	wchar_t c
	)
{
	return iswxdigit(c);
}

int (__cdecl iswspace) (
	wchar_t c
	)
{
	return iswspace(c);
}

int (__cdecl iswpunct) (
	wchar_t c
	)
{
	return iswpunct(c);
}

int (__cdecl iswalnum) (
	wchar_t c
	)
{
	return iswalnum(c);
}

int (__cdecl iswprint) (
	wchar_t c
	)
{
	return iswprint(c);
}

int (__cdecl iswgraph) (
	wchar_t c
	)
{
	return iswgraph(c);
}

int (__cdecl iswcntrl) (
	wchar_t c
	)
{
	return iswcntrl(c);
}

int (__cdecl iswascii) (
	wchar_t c
	)
{
	return iswascii(c);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\direct\findfi64.c ===
/***
*findfi64.c - C find file functions
*
*	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines _findfirsti64() and _findnexti64().
*
*Revision History:
*	12-28-94  GJF	Module created.
*
*******************************************************************************/

#define _USE_INT64  1

#include "findfile.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\direct\seterrm.c ===
/***
*seterrm.c - Set mode for handling critical errors
*
*	Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines signal() and raise().
*
*Revision History:
*	08-21-92  BWM	Wrote for Win32.
*	09-29-93  GJF	Resurrected for compatibility with NT SDK (which had
*			the function). Replaced _CALLTYPE1 with __cdecl and
*			removed Cruiser support.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>

/***
*void _seterrormode(mode) - set the critical error mode
*
*Purpose:
*
*Entry:
*   int mode - error mode:
*
*		0 means system displays a prompt asking user how to
*		respond to the error. Choices differ depending on the
*		error but may include Abort, Retry, Ignore, and Fail.
*
*		1 means the call system call causing the error will fail
*		and return an error indicating the cause.
*
*Exit:
*   none
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _seterrormode(int mode)
{
	SetErrorMode(mode);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\direct\findf64.c ===
/***
*findf64.c - C find file functions
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _findfirst64(), _findnext64(), and _findclose64().
*
*Revision History:
*       05-28-98  GJF   Created
*       05-03-99  PML   Update for 64-bit merge - long -> intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <errno.h>
#include <io.h>
#include <time.h>
#include <ctime.h>
#include <string.h>
#include <internal.h>
#include <tchar.h>
#ifdef _XBOX
#include <ochar.h>
#endif // XBOX

#ifndef _WIN32
#error ERROR - ONLY WIN32 TARGET SUPPORTED!
#endif

__time64_t __cdecl __time64_t_from_ft(FILETIME * pft);

/***
*long _findfirst(wildspec, finddata) - Find first matching file
*
*Purpose:
*       Finds the first file matching a given wild card filespec and
*       returns data about the file.
*
*Entry:
*       char * wild - file spec optionally containing wild cards
*
*       struct _finddata64_t * finddata - structure to receive file data
*
*Exit:
*       Good return:
*       Unique handle identifying the group of files matching the spec
*
*       Error return:
*       Returns -1 and errno is set to error value
*
*Exceptions:
*       None.
*
*******************************************************************************/

intptr_t __cdecl _tfindfirst64(
        const _TSCHAR * szWild,
        struct _tfinddata64_t * pfd
        )
{
        WIN32_FIND_DATA wfd;
        HANDLE          hFile;
        DWORD           err;

        if ((hFile = FindFirstFile(szWild, &wfd)) == INVALID_HANDLE_VALUE) {
            err = GetLastError();
            switch (err) {
                case ERROR_NO_MORE_FILES:
                case ERROR_FILE_NOT_FOUND:
                case ERROR_PATH_NOT_FOUND:
                    errno = ENOENT;
                    break;

                case ERROR_NOT_ENOUGH_MEMORY:
                    errno = ENOMEM;
                    break;

                default:
                    errno = EINVAL;
                    break;
            }
            return (-1);
        }

        pfd->attrib       = (wfd.dwFileAttributes == FILE_ATTRIBUTE_NORMAL)
                            ? 0 : wfd.dwFileAttributes;
        pfd->time_create  = __time64_t_from_ft(&wfd.ftCreationTime);
        pfd->time_access  = __time64_t_from_ft(&wfd.ftLastAccessTime);
        pfd->time_write   = __time64_t_from_ft(&wfd.ftLastWriteTime);
        pfd->size         = ((__int64)(wfd.nFileSizeHigh)) * (0x100000000i64) +
                            (__int64)(wfd.nFileSizeLow);

        _tcscpy(pfd->name, wfd.cFileName);

        return ((intptr_t)hFile);
}

/***
*int _findnext(hfind, finddata) - Find next matching file
*
*Purpose:
*       Finds the next file matching a given wild card filespec and
*       returns data about the file.
*
*Entry:
*       hfind - handle from _findfirst
*
*       struct _finddata64_t * finddata - structure to receive file data
*
*Exit:
*       Good return:
*       0 if file found
*       -1 if error or file not found
*       errno set
*
*Exceptions:
*       None.
*
*******************************************************************************/

int __cdecl _tfindnext64(intptr_t hFile, struct _tfinddata64_t * pfd)
{
        WIN32_FIND_DATA wfd;
        DWORD           err;

        if (!FindNextFile((HANDLE)hFile, &wfd)) {
            err = GetLastError();
            switch (err) {
                case ERROR_NO_MORE_FILES:
                case ERROR_FILE_NOT_FOUND:
                case ERROR_PATH_NOT_FOUND:
                    errno = ENOENT;
                    break;

                case ERROR_NOT_ENOUGH_MEMORY:
                    errno = ENOMEM;
                    break;

                default:
                    errno = EINVAL;
                    break;
            }
            return (-1);
        }

        pfd->attrib       = (wfd.dwFileAttributes == FILE_ATTRIBUTE_NORMAL)
                            ? 0 : wfd.dwFileAttributes;
        pfd->time_create  = __time64_t_from_ft(&wfd.ftCreationTime);
        pfd->time_access  = __time64_t_from_ft(&wfd.ftLastAccessTime);
        pfd->time_write   = __time64_t_from_ft(&wfd.ftLastWriteTime);
        pfd->size         = ((__int64)(wfd.nFileSizeHigh)) * (0x100000000i64) +
                            (__int64)(wfd.nFileSizeLow);

        _tcscpy(pfd->name, wfd.cFileName);

        return (0);
}

#if     !defined(_UNICODE) && !defined(_USE_INT64)

/***
*time64_t __time64_t_from_ft(ft) - convert Win32 file time to Xenix time
*
*Purpose:
*       converts a Win32 file time value to Xenix time_t
*
*       Note: We cannot directly use the ft value. In Win32, the file times
*       returned by the API are ambiguous. In Windows NT, they are UTC. In
*       Win32S, and probably also Win32C, they are local time values. Thus,
*       the value in ft must be converted to a local time value (by an API)
*       before we can use it.
*
*Entry:
*       int yr, mo, dy -        date
*       int hr, mn, sc -        time
*
*Exit:
*       returns Xenix time value
*
*Exceptions:
*
*******************************************************************************/

__time64_t __cdecl __time64_t_from_ft(FILETIME * pft)
{
        SYSTEMTIME st;
        FILETIME lft;

        /* 0 FILETIME returns a -1 time_t */

        if (!pft->dwLowDateTime && !pft->dwHighDateTime) {
            return ((__time64_t)-1);
        }

        /*
         * Convert to a broken down local time value
         */
        if ( !FileTimeToLocalFileTime(pft, &lft) ||
             !FileTimeToSystemTime(&lft, &st) )
        {
            return ((__time64_t)-1);
        }

        return ( __loctotime64_t(st.wYear,
                                 st.wMonth,
                                 st.wDay,
                                 st.wHour,
                                 st.wMinute,
                                 st.wSecond,
                                 -1) );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\direct\slbeep.c ===
/***
*slbeep.c - Sleep and beep
*
*	Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _sleep() and _beep()
*
*Revision History:
*	08-22-91  BWM	Wrote module.
*	09-29-93  GJF	Resurrected for compatibility with NT SDK (which had
*			the function). Replaced _CALLTYPE1 with __cdecl and
*			removed Cruiser support.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <stdlib.h>

/***
*void _sleep(duration) - Length of sleep
*
*Purpose:
*
*Entry:
*	unsigned long duration - length of sleep in milliseconds or
*	one of the following special values:
*
*	    _SLEEP_MINIMUM - Sends a yield message without any delay
*	    _SLEEP_FOREVER - Never return
*
*Exit:
*	None
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _sleep(unsigned long dwDuration)
{

    if (dwDuration == 0) {
	dwDuration++;
    }
    Sleep(dwDuration);

}

#ifndef _XBOX

/***
*void _beep(frequency, duration) - Length of sleep
*
*Purpose:
*
*Entry:
*	unsigned frequency - frequency in hertz
*	unsigned duration - length of beep in milliseconds
*
*Exit:
*	None
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _beep(unsigned dwFrequency, unsigned dwDuration)
{
    Beep(dwFrequency, dwDuration);
}

#endif // XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\direct\sources.inc ===
MAJORCOMP=crt
MINORCOMP=direct

TARGETNAME=direct

!INCLUDE ..\..\crt32.inc

# drivfree is gone
# seterrm is gone

SOURCES=\
        ..\drivemap.c \
        ..\findf64.c  \
        ..\findfile.c \
        ..\findfi64.c \
        ..\slbeep.c   \
        ..\wfindfil.c \
        ..\wfndf64.c  \
        ..\wfndfi64.c

i386_SOURCES=\
        ..\i386\enable.asm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\direct\findcom.c ===
/***
*findcom.c - C find file functions
*
*	Copyright (c) 1991-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines _findfirst(), _findnext(), and _findclose().
*
*Revision History:
*	08-21-91  BWM	Wrote Win32 versions.
*	09-13-91  BWM	Changed handle type to long.
*	08-18-92  SKS	Add a call to FileTimeToLocalFileTime
*			as a temporary fix until _dtoxtime takes UTC
*	08-26-92  SKS	creation and last access time should be same as the
*			last write time if ctime/atime are not available.
*	01-08-93  SKS	Remove change I made 8-26-92.  Previous behavior
*			was deemed "by design" and preferable.
*	03-30-93  GJF	Replaced reference to _dtoxtime with __gmtotime_t. Also
*			made _timet_from_ft a static function.
*	04-06-93  SKS	Replace _CRTAPI* with _cdecl
*	07-21-93  GJF	Repaced use of _gmtotime_t by __loctotime_t.
*	11-01-93  CFW	Enable Unicode variant.
*	12-28-94  GJF	Added _[w]findfirsti64, _[w]findnexti64.
*       09-25-95  GJF   __loctotime_t now takes a DST flag, pass -1 in this
*                       slot to indicate DST status is unknown.
*	10-06-95  SKS	Add "const" to "char *" in prototypes for *findfirst().
*			Prepend missing underscores to func names in comments.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <errno.h>
#include <io.h>
#include <time.h>
#include <ctime.h>
#include <string.h>
#include <internal.h>
#include <tchar.h>

#ifndef _WIN32
#error ERROR - ONLY WIN32 TARGET SUPPORTED!
#endif

time_t __cdecl __timet_from_ft(FILETIME * pft);

/***
*int _findclose(hfind) - Release resources of find
*
*Purpose:
*	Releases resources of a group of files found by _findfirst and
*	_findnext
*
*Entry:
*	hfind - handle from _findfirst
*
*Exit:
*	Good return:
*	0 if success
*	-1 if fail, errno set
*
*Exceptions:
*	None.
*
*******************************************************************************/

int __cdecl _findclose(long hFile)
{
    if (!FindClose((HANDLE)hFile)) {
	errno = EINVAL;
	return (-1);
    }
    return (0);
}


/***
*time_t _fttotimet(ft) - convert Win32 file time to Xenix time
*
*Purpose:
*	converts a Win32 file time value to Xenix time_t
*
*	Note: We cannot directly use the ft value. In Win32, the file times
*	returned by the API are ambiguous. In Windows NT, they are UTC. In
*	Win32S, and probably also Win32C, they are local time values. Thus,
*	the value in ft must be converted to a local time value (by an API)
*	before we can use it.
*
*Entry:
*	int yr, mo, dy -	date
*	int hr, mn, sc -	time
*
*Exit:
*	returns Xenix time value
*
*Exceptions:
*
*******************************************************************************/

time_t __cdecl __timet_from_ft(FILETIME * pft)
{
    SYSTEMTIME st;
    FILETIME lft;

    /* 0 FILETIME returns a -1 time_t */

    if (!pft->dwLowDateTime && !pft->dwHighDateTime) {
	return (-1L);
    }

    /*
     * Convert to a broken down local time value
     */
    if ( !FileTimeToLocalFileTime(pft, &lft) ||
	 !FileTimeToSystemTime(&lft, &st) )
    {
	return (-1L);
    }

    return ( __loctotime_t(st.wYear,
			   st.wMonth,
			   st.wDay,
			   st.wHour,
			   st.wMinute,
			   st.wSecond,
                           -1) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\direct\findfile.c ===
/***
*findfile.c - C find file functions
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _findfirst(), _findnext(), and _findclose().
*
*Revision History:
*       08-21-91  BWM   Wrote Win32 versions.
*       09-13-91  BWM   Changed handle type to long.
*       08-18-92  SKS   Add a call to FileTimeToLocalFileTime
*                       as a temporary fix until _dtoxtime takes UTC
*       08-26-92  SKS   creation and last access time should be same as the
*                       last write time if ctime/atime are not available.
*       01-08-93  SKS   Remove change I made 8-26-92.  Previous behavior
*                       was deemed "by design" and preferable.
*       03-30-93  GJF   Replaced reference to _dtoxtime with __gmtotime_t. Also
*                       made _timet_from_ft a static function.
*       04-06-93  SKS   Replace _CRTAPI* with _cdecl
*       07-21-93  GJF   Repaced use of _gmtotime_t by __loctotime_t.
*       11-01-93  CFW   Enable Unicode variant.
*       12-28-94  GJF   Added _[w]findfirsti64, _[w]findnexti64.
*       09-25-95  GJF   __loctotime_t now takes a DST flag, pass -1 in this
*                       slot to indicate DST status is unknown.
*       10-06-95  SKS   Add "const" to "char *" in prototypes for *findfirst().
*                       Prepend missing underscores to func names in comments.
*       11-13-97  RKP   Change longs to INT_PTR for 64 bit support.
*       04-27-99  PML   Change INT_PTR to intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <errno.h>
#include <io.h>
#include <time.h>
#include <ctime.h>
#include <string.h>
#include <internal.h>
#include <tchar.h>
#ifdef _XBOX
#include <ochar.h>
#endif

#ifndef _WIN32
#error ERROR - ONLY WIN32 TARGET SUPPORTED!
#endif

time_t __cdecl __timet_from_ft(FILETIME * pft);

/***
*intptr_t _findfirst(wildspec, finddata) - Find first matching file
*
*Purpose:
*       Finds the first file matching a given wild card filespec and
*       returns data about the file.
*
*Entry:
*       char * wild - file spec optionally containing wild cards
*
*       struct _finddata_t * finddata - structure to receive file data
*
*Exit:
*       Good return:
*       Unique handle identifying the group of files matching the spec
*
*       Error return:
*       Returns -1 and errno is set to error value
*
*Exceptions:
*       None.
*
*******************************************************************************/

#ifdef  _USE_INT64

intptr_t __cdecl _tfindfirsti64(
        const _TSCHAR * szWild,
        struct _tfinddatai64_t * pfd
        )

#else   /* ndef _USE_INT64 */

intptr_t __cdecl _tfindfirst(
        const _TSCHAR * szWild,
        struct _tfinddata_t * pfd
        )

#endif  /* _USE_INT64 */

{
    WIN32_FIND_DATA wfd;
    HANDLE          hFile;
    DWORD           err;

    if ((hFile = FindFirstFile(szWild, &wfd)) == INVALID_HANDLE_VALUE) {
        err = GetLastError();
        switch (err) {
            case ERROR_NO_MORE_FILES:
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
                errno = ENOENT;
                break;

            case ERROR_NOT_ENOUGH_MEMORY:
                errno = ENOMEM;
                break;

            default:
                errno = EINVAL;
                break;
        }
        return (-1);
    }

    pfd->attrib       = (wfd.dwFileAttributes == FILE_ATTRIBUTE_NORMAL)
                      ? 0 : wfd.dwFileAttributes;
    pfd->time_create  = __timet_from_ft(&wfd.ftCreationTime);
    pfd->time_access  = __timet_from_ft(&wfd.ftLastAccessTime);
    pfd->time_write   = __timet_from_ft(&wfd.ftLastWriteTime);

#ifdef  _USE_INT64
    pfd->size         = ((__int64)(wfd.nFileSizeHigh)) * (0x100000000i64) +
                        (__int64)(wfd.nFileSizeLow);
#else   /* ndef _USE_INT64 */
    pfd->size         = wfd.nFileSizeLow;
#endif  /* ndef _USE_INT64 */

    _tcscpy(pfd->name, wfd.cFileName);

    return ((intptr_t)hFile);
}

/***
*int _findnext(hfind, finddata) - Find next matching file
*
*Purpose:
*       Finds the next file matching a given wild card filespec and
*       returns data about the file.
*
*Entry:
*       hfind - handle from _findfirst
*
*       struct _finddata_t * finddata - structure to receive file data
*
*Exit:
*       Good return:
*       0 if file found
*       -1 if error or file not found
*       errno set
*
*Exceptions:
*       None.
*
*******************************************************************************/

#ifdef  _USE_INT64

int __cdecl _tfindnexti64(intptr_t hFile, struct _tfinddatai64_t * pfd)

#else   /* ndef _USE_INT64 */

int __cdecl _tfindnext(intptr_t hFile, struct _tfinddata_t * pfd)

#endif  /* _USE_INT64 */

{
    WIN32_FIND_DATA wfd;
    DWORD           err;

    if (!FindNextFile((HANDLE)hFile, &wfd)) {
        err = GetLastError();
        switch (err) {
            case ERROR_NO_MORE_FILES:
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
                errno = ENOENT;
                break;

            case ERROR_NOT_ENOUGH_MEMORY:
                errno = ENOMEM;
                break;

            default:
                errno = EINVAL;
                break;
        }
        return (-1);
    }

    pfd->attrib       = (wfd.dwFileAttributes == FILE_ATTRIBUTE_NORMAL)
                      ? 0 : wfd.dwFileAttributes;
    pfd->time_create  = __timet_from_ft(&wfd.ftCreationTime);
    pfd->time_access  = __timet_from_ft(&wfd.ftLastAccessTime);
    pfd->time_write   = __timet_from_ft(&wfd.ftLastWriteTime);

#ifdef  _USE_INT64
    pfd->size         = ((__int64)(wfd.nFileSizeHigh)) * (0x100000000i64) +
                        (__int64)(wfd.nFileSizeLow);
#else   /* ndef _USE_INT64 */
    pfd->size         = wfd.nFileSizeLow;
#endif  /* ndef _USE_INT64 */

    _tcscpy(pfd->name, wfd.cFileName);

    return (0);
}

#if     !defined(_UNICODE) && !defined(_USE_INT64)

/***
*int _findclose(hfind) - Release resources of find
*
*Purpose:
*       Releases resources of a group of files found by _findfirst and
*       _findnext
*
*Entry:
*       hfind - handle from _findfirst
*
*Exit:
*       Good return:
*       0 if success
*       -1 if fail, errno set
*
*Exceptions:
*       None.
*
*******************************************************************************/

int __cdecl _findclose(intptr_t hFile)
{
    if (!FindClose((HANDLE)hFile)) {
        errno = EINVAL;
        return (-1);
    }
    return (0);
}


/***
*time_t _fttotimet(ft) - convert Win32 file time to Xenix time
*
*Purpose:
*       converts a Win32 file time value to Xenix time_t
*
*       Note: We cannot directly use the ft value. In Win32, the file times
*       returned by the API are ambiguous. In Windows NT, they are UTC. In
*       Win32S, and probably also Win32C, they are local time values. Thus,
*       the value in ft must be converted to a local time value (by an API)
*       before we can use it.
*
*Entry:
*       int yr, mo, dy -        date
*       int hr, mn, sc -        time
*
*Exit:
*       returns Xenix time value
*
*Exceptions:
*
*******************************************************************************/

time_t __cdecl __timet_from_ft(FILETIME * pft)
{
    SYSTEMTIME st;
    FILETIME lft;

    /* 0 FILETIME returns a -1 time_t */

    if (!pft->dwLowDateTime && !pft->dwHighDateTime) {
        return (-1L);
    }

    /*
     * Convert to a broken down local time value
     */
    if ( !FileTimeToLocalFileTime(pft, &lft) ||
         !FileTimeToSystemTime(&lft, &st) )
    {
        return (-1L);
    }

    return ( __loctotime_t(st.wYear,
                           st.wMonth,
                           st.wDay,
                           st.wHour,
                           st.wMinute,
                           st.wSecond,
                           -1) );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\direct\wfindfil.c ===
/***
*wfindfile.c - C find file functions (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines _wfindfirst(), _wfindnext(), and _wfindclose().
*
*Revision History:
*	10-29-93  CFW	Module created.
*
*******************************************************************************/

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "findfile.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\direct\wfndf64.c ===
/***
*wfndf64.c - C find file functions (wchar_t version)
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _wfindfirst64() and _wfindnext64().
*
*Revision History:
*       05-29-98  GJF   Created.
*
*******************************************************************************/

#define WPRFLAG     1

#ifndef _UNICODE    /* CRT flag */
#define _UNICODE    1
#endif

#ifndef UNICODE     /* NT flag */
#define UNICODE     1
#endif

#undef  _MBCS        /* UNICODE not _MBCS */

#define _USE_INT64  1

#include "findf64.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\direct\i386\enable.asm ===
page	,132
	title	enable - enable/disable interrupts
;***
;enable.asm - contains _enable() and _disable() routines
;
;	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;
;Revision History:
;	06-15-93  GJF	Module created.
;	10-25-93  GJF	Added ifndef to ensure this is not part of the NT
;			SDK build.
;
;*******************************************************************************

ifndef	_NTSDK

	.xlist
	include cruntime.inc
	.list

page
;***
;void _enable(void)  - enables interrupts
;void _disable(void) - disables interrupts
;
;Purpose:
;	The _enable() functions executes a "sti" instruction. The _disable()
;	function executes a "cli" instruction.
;
;Entry:
;
;Exit:
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************


	CODESEG

	public	_enable, _disable

_enable	proc

	sti
	ret

_enable	endp

	align	4

_disable proc

	cli
	ret

_disable endp

endif	; _NTSDK

	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\access.c ===
/***
*access.c - access function
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has the _access() function which checks on file accessability.
*
*Revision History:
*       06-06-89  PHG   Module created, based on asm version
*       11-10-89  JCR   Replaced DOS32QUERYFILEMODE with DOS32QUERYPATHINFO
*       03-07-90  GJF   Made calling type _CALLTYPE2 (for now), added #include
*                       <cruntime.h>, fixed copyright and fixed compiler
*                       warnings. Also, cleaned up the formatting a bit.
*       03-30-90  GJF   Now _CALLTYPE1.
*       07-24-90  SBM   Removed '32' from API names
*       09-27-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-16-91  GJF   ANSI naming.
*       04-09-91  PNT   Added _MAC_ conditional
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Rip out Cruiser, enable wide char.
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format a bit.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <io.h>
#include <oscalls.h>
#include <stdlib.h>
#include <errno.h>
#include <msdos.h>
#include <internal.h>
#include <tchar.h>
#ifdef _XBOX
#include <ochar.h>
#endif

/***
*int _access(path, amode) - check whether file can be accessed under mode
*
*Purpose:
*       Checks to see if the specified file exists and can be accessed
*       in the given mode.
*
*Entry:
*       _TSCHAR *path - pathname
*       int amode -     access mode
*                       (0 = exist only, 2 = write, 4 = read, 6 = read/write)
*
*Exit:
*       returns 0 if file has given mode
*       returns -1 and sets errno if file does not have given mode or
*       does not exist
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _taccess (
        const _TSCHAR *path,
        int amode
        )
{
        DWORD attr;

        attr = GetFileAttributes((LPTSTR)path);
        if (attr  == 0xffffffff) {
                /* error occured -- map error code and return */
                _dosmaperr(GetLastError());
                return -1;
        }

        /* no error; see if returned premission settings OK */
        if ( (attr & FILE_ATTRIBUTE_READONLY) && (amode & 2) ) {
                /* no write permission on file, return error */
                errno = EACCES;
                _doserrno = E_access;
                return -1;
        }
        else
                /* file exists and has requested permission setting */
                return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\direct\wfndfi64.c ===
/***
*wfndfi64.c - C find file functions (wchar_t version)
*
*	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines _wfindfirsti64() and _wfindnexti64().
*
*Revision History:
*	12-28-94  GJF	Module created.
*
*******************************************************************************/

#define WPRFLAG     1

#ifndef _UNICODE    /* CRT flag */
#define _UNICODE    1
#endif

#ifndef UNICODE	    /* NT flag */
#define UNICODE     1
#endif

#undef _MBCS	    /* UNICODE not _MBCS */

#define _USE_INT64  1

#include "findfile.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\dosmap.c ===
/***
*dosmap.c - Maps OS errors to errno values
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       _dosmaperr: Maps OS errors to errno values
*
*Revision History:
*       06-06-89  PHG   Module created, based on asm version
*       06-16-89  PHG   Changed name to _dosmaperr
*       08-22-89  JCR   ERROR_INVALID_DRIVE (15) now maps to ENOENT not EXDEV
*       03-07-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and fixed copyright. Also, cleaned up the
*                       formatting a bit.
*       09-27-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       04-26-91  SRW   Added ERROR_LOCK_VIOLATION translation to EACCES
*       08-15-91  GJF   Multi-thread support for Win32.
*       03-31-92  GJF   Added more error codes (Win32 only) and removed OS/2
*                       specific nomenclature.
*       07-29-92  GJF   Added ERROR_FILE_EXISTS to table for Win32. It gets
*                       mapped it to EEXIST.
*       09-14-92  SRW   Added ERROR_BAD_PATHNAME table for Win32. It gets
*                       mapped it to ENOENT.
*       10-02-92  GJF   Map ERROR_INVALID_PARAMETER to EINVAL (rather than
*                       EACCES). Added ERROR_NOT_LOCKED and mapped it to
*                       EACCES. Added ERROR_DIR_NOT_EMPTY and mapped it to
*                       ENOTEMPTY.
*       02-16-93  GJF   Changed for new _getptd().
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       01-06-94  GJF   Dumped obsolete Cruiser support, revised errentry
*                       struct definition and added mapping for infamous
*                       ERROR_NOT_ENOUGH_QUOTA (non-swappable memory pages)
*                       which might result from a CreateThread call.
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       05-24-95  CFW   Map dupFNErr to EEXIST rather than EACCESS.
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format a bit.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <errno.h>
#include <oscalls.h>
#include <stdlib.h>
#include <internal.h>
#include <mtdll.h>

/* This is the error table that defines the mapping between OS error
   codes and errno values */

struct errentry {
        unsigned long oscode;           /* OS return value */
        int errnocode;  /* System V error code */
};

static struct errentry errtable[] = {
        {  ERROR_INVALID_FUNCTION,       EINVAL    },  /* 1 */
        {  ERROR_FILE_NOT_FOUND,         ENOENT    },  /* 2 */
        {  ERROR_PATH_NOT_FOUND,         ENOENT    },  /* 3 */
        {  ERROR_TOO_MANY_OPEN_FILES,    EMFILE    },  /* 4 */
        {  ERROR_ACCESS_DENIED,          EACCES    },  /* 5 */
        {  ERROR_INVALID_HANDLE,         EBADF     },  /* 6 */
        {  ERROR_ARENA_TRASHED,          ENOMEM    },  /* 7 */
        {  ERROR_NOT_ENOUGH_MEMORY,      ENOMEM    },  /* 8 */
        {  ERROR_INVALID_BLOCK,          ENOMEM    },  /* 9 */
        {  ERROR_BAD_ENVIRONMENT,        E2BIG     },  /* 10 */
        {  ERROR_BAD_FORMAT,             ENOEXEC   },  /* 11 */
        {  ERROR_INVALID_ACCESS,         EINVAL    },  /* 12 */
        {  ERROR_INVALID_DATA,           EINVAL    },  /* 13 */
        {  ERROR_INVALID_DRIVE,          ENOENT    },  /* 15 */
        {  ERROR_CURRENT_DIRECTORY,      EACCES    },  /* 16 */
        {  ERROR_NOT_SAME_DEVICE,        EXDEV     },  /* 17 */
        {  ERROR_NO_MORE_FILES,          ENOENT    },  /* 18 */
        {  ERROR_LOCK_VIOLATION,         EACCES    },  /* 33 */
        {  ERROR_BAD_NETPATH,            ENOENT    },  /* 53 */
        {  ERROR_NETWORK_ACCESS_DENIED,  EACCES    },  /* 65 */
        {  ERROR_BAD_NET_NAME,           ENOENT    },  /* 67 */
        {  ERROR_FILE_EXISTS,            EEXIST    },  /* 80 */
        {  ERROR_CANNOT_MAKE,            EACCES    },  /* 82 */
        {  ERROR_FAIL_I24,               EACCES    },  /* 83 */
        {  ERROR_INVALID_PARAMETER,      EINVAL    },  /* 87 */
        {  ERROR_NO_PROC_SLOTS,          EAGAIN    },  /* 89 */
        {  ERROR_DRIVE_LOCKED,           EACCES    },  /* 108 */
        {  ERROR_BROKEN_PIPE,            EPIPE     },  /* 109 */
        {  ERROR_DISK_FULL,              ENOSPC    },  /* 112 */
        {  ERROR_INVALID_TARGET_HANDLE,  EBADF     },  /* 114 */
        {  ERROR_INVALID_HANDLE,         EINVAL    },  /* 124 */
        {  ERROR_WAIT_NO_CHILDREN,       ECHILD    },  /* 128 */
        {  ERROR_CHILD_NOT_COMPLETE,     ECHILD    },  /* 129 */
        {  ERROR_DIRECT_ACCESS_HANDLE,   EBADF     },  /* 130 */
        {  ERROR_NEGATIVE_SEEK,          EINVAL    },  /* 131 */
        {  ERROR_SEEK_ON_DEVICE,         EACCES    },  /* 132 */
        {  ERROR_DIR_NOT_EMPTY,          ENOTEMPTY },  /* 145 */
        {  ERROR_NOT_LOCKED,             EACCES    },  /* 158 */
        {  ERROR_BAD_PATHNAME,           ENOENT    },  /* 161 */
        {  ERROR_MAX_THRDS_REACHED,      EAGAIN    },  /* 164 */
        {  ERROR_LOCK_FAILED,            EACCES    },  /* 167 */
        {  ERROR_ALREADY_EXISTS,         EEXIST    },  /* 183 */
        {  ERROR_FILENAME_EXCED_RANGE,   ENOENT    },  /* 206 */
        {  ERROR_NESTING_NOT_ALLOWED,    EAGAIN    },  /* 215 */
        {  ERROR_NOT_ENOUGH_QUOTA,       ENOMEM    }    /* 1816 */
};

/* size of the table */
#define ERRTABLESIZE (sizeof(errtable)/sizeof(errtable[0]))

/* The following two constants must be the minimum and maximum
   values in the (contiguous) range of Exec Failure errors. */
#define MIN_EXEC_ERROR ERROR_INVALID_STARTING_CODESEG
#define MAX_EXEC_ERROR ERROR_INFLOOP_IN_RELOC_CHAIN

/* These are the low and high value in the range of errors that are
   access violations */
#define MIN_EACCES_RANGE ERROR_WRITE_PROTECT
#define MAX_EACCES_RANGE ERROR_SHARING_BUFFER_EXCEEDED


/***
*void _dosmaperr(oserrno) - Map function number
*
*Purpose:
*       This function takes an OS error number, and maps it to the
*       corresponding errno value (based on UNIX System V values). The
*       OS error number is stored in _doserrno (and the mapped value is
*       stored in errno)
*
*Entry:
*       ULONG oserrno = OS error value
*
*Exit:
*       sets _doserrno and errno.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _dosmaperr (
        unsigned long oserrno
        )
{
        int i;

        _doserrno = oserrno;        /* set _doserrno */

        /* check the table for the OS error code */
        for (i = 0; i < ERRTABLESIZE; ++i) {
                if (oserrno == errtable[i].oscode) {
                        errno = errtable[i].errnocode;
                        return;
                }
        }

        /* The error code wasn't in the table.  We check for a range of */
        /* EACCES errors or exec failure errors (ENOEXEC).  Otherwise   */
        /* EINVAL is returned.                                          */

        if (oserrno >= MIN_EACCES_RANGE && oserrno <= MAX_EACCES_RANGE)
                errno = EACCES;
        else if (oserrno >= MIN_EXEC_ERROR && oserrno <= MAX_EXEC_ERROR)
                errno = ENOEXEC;
        else
                errno = EINVAL;
}

#ifdef  _MT

/***
*int * _errno()                 - return pointer to thread's errno
*unsigned long * __doserrno()   - return pointer to thread's _doserrno
*
*Purpose:
*       _errno() returns a pointer to the _terrno field in the current
*       thread's _tiddata structure.
*       __doserrno returns a pointer to the _tdoserrno field in the current
*       thread's _tiddata structure
*
*Entry:
*       None.
*
*Exit:
*       See above.
*
*Exceptions:
*
*******************************************************************************/

int * __cdecl _errno(
        void
        )
{
        return ( &(_getptd()->_terrno) );
}

unsigned long * __cdecl __doserrno(
        void
        )
{
        return ( &(_getptd()->_tdoserrno) );
}

#endif  /* _MT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\fullpath.c ===
/***
*fullpath.c -
*
*       Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
*
*Purpose: contains the function _fullpath which makes an absolute path out
*       of a relative path. i.e.  ..\pop\..\main.c => c:\src\main.c if the
*       current directory is c:\src\src
*
*Revision History:
*       12-21-87  WAJ   Initial version
*       01-08-88  WAJ   now treats / as an \
*       06-22-88  WAJ   now handles network paths  ie \\sl\users
*       01-31-89  SKS/JCR Renamed _canonic to _fullpath
*       04-03-89  WAJ   Now returns "d:\dir" for "."
*       05-09-89  SKS   Do not change the case of arguments
*       11-30-89  JCR   Preserve errno setting from _getdcwd() call on errors
*       03-07-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h>, removed #include <register.h> and fixed
*                       the copyright.
*       04-25-90  JCR   Fixed an incorrect errno setting
*       06-14-90  SBM   Fixed bugs in which case of user provided drive letter
*                       was not always preserved, and c:\foo\\bar did not
*                       generate an error
*       08-10-90  SBM   Compiles cleanly with -W3
*       08-28-90  SBM   Fixed bug in which UNC names were being rejected
*       09-27-90  GJF   New-style function declarator.
*       01-18-91  GJF   ANSI naming.
*       11-30-92  KRS   Ported _MBCS code from 16-bit tree.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-26-93  SKS   Add check for drive validity
*       08-03-93  KRS   Change to use _ismbstrail instead of isdbcscode.
*       09-27-93  CFW   Avoid cast bug.
*       12-07-93  CFW   Wide char enable.
*       01-26-94  CFW   Remove unused isdbcscode function.
*       11-08-94  GJF   Revised to use GetFullPathName.
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       03-28-96  GJF   Free malloc-ed buffer if GetFullPathName fails. 
*                       Detab-ed. Also, cleaned up the ill-formatted Mac
*                       version a bit and renamed isdbcscode to __isdbcscode.
*       07-01-96  GJF   Replaced defined(_WIN32) by !defined(_MAC).
*       12-15-98  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <stdio.h>
#include <direct.h>
#include <errno.h>
#include <stdlib.h>
#include <internal.h>
#include <tchar.h>
#ifdef _XBOX
#include <oscalls.h>
#else  // _XBOX
#include <windows.h>
#endif // _XBOX

/***
*_TSCHAR *_fullpath( _TSCHAR *buf, const _TSCHAR *path, maxlen );
*
*Purpose:
*
*       _fullpath - combines the current directory with path to form
*       an absolute path. i.e. _fullpath takes care of .\ and ..\
*       in the path.
*
*       The result is placed in buf. If the length of the result
*       is greater than maxlen NULL is returned, otherwise
*       the address of buf is returned.
*
*       If buf is NULL then a buffer is malloc'ed and maxlen is
*       ignored. If there are no errors then the address of this
*       buffer is returned.
*
*       If path specifies a drive, the curent directory of this
*       drive is combined with path. If the drive is not valid
*       and _fullpath needs the current directory of this drive
*       then NULL is returned.  If the current directory of this
*       non existant drive is not needed then a proper value is
*       returned.
*       For example:  path = "z:\\pop" does not need z:'s current
*       directory but path = "z:pop" does.
*
*
*
*Entry:
*       _TSCHAR *buf  - pointer to a buffer maintained by the user;
*       _TSCHAR *path - path to "add" to the current directory
*       int maxlen - length of the buffer pointed to by buf
*
*Exit:
*       Returns pointer to the buffer containing the absolute path
*       (same as buf if non-NULL; otherwise, malloc is
*       used to allocate a buffer)
*
*Exceptions:
*
*******************************************************************************/


_TSCHAR * __cdecl _tfullpath (
        _TSCHAR *UserBuf,
        const _TSCHAR *path,
        size_t maxlen
        )
{
#ifndef _XBOX
        _TSCHAR *buf;
        _TSCHAR *pfname;
        unsigned long count;


        if ( !path || !*path )  /* no work to do */
            return( _tgetcwd( UserBuf, (int)maxlen ) );

        /* allocate buffer if necessary */

        if ( !UserBuf )
            if ( !(buf = malloc(_MAX_PATH * sizeof(_TSCHAR))) ) {
                errno = ENOMEM;
                return( NULL );
            }
            else
                maxlen = _MAX_PATH;
        else
            buf = UserBuf;

        count = GetFullPathName ( path,
                                  (int)maxlen,
                                  buf,
                                  &pfname );

        if ( count >= maxlen ) {
            if ( !UserBuf )
                free(buf);
            errno = ERANGE;
            return( NULL );
        }
        else if ( count == 0 ) {
            if ( !UserBuf )
                free(buf);
            _dosmaperr( GetLastError() );
            return( NULL );
        }

        return( buf );
#else // XBOX
    RIP("_tfullpath() not supported on Xbox");
    return NULL;
#endif // XBOX
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\chdir.c ===
/***
*chdir.c - change directory
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has the _chdir() function - change current directory.
*
*Revision History:
*       06-06-89  PHG   Module created, based on asm version
*       03-07-90  GJF   Made calling type _CALLTYPE2 (for now), added #include
*                       <cruntime.h>, fixed copyright and fixed compiler
*                       warnings. Also, cleaned up the formatting a bit.
*       03-30-90  GJF   Now _CALLTYPE1.
*       07-24-90  SBM   Removed '32' from API names
*       09-27-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-16-91  GJF   ANSI naming.
*       05-19-92  GJF   Revised to support the 'current directory' environment
*                       variables of Win32/NT.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-24-93  CFW   Rip out Cruiser.
*       11-24-93  CFW   No longer store current drive in CRT env strings.
*       12-01-93  CFW   Set OS drive letter variables.
*       12-07-93  CFW   Wide char enable.
*       01-25-95  GJF   New current directory can be a UNC path!
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format a bit.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <oscalls.h>
#include <mtdll.h>
#include <internal.h>
#include <direct.h>
#include <stdlib.h>
#include <tchar.h>
#ifdef _XBOX
#include <errno.h>
#endif // XBOX

/***
*int _chdir(path) - change current directory
*
*Purpose:
*       Changes the current working directory to that given in path.
*
*Entry:
*       _TSCHAR *path - directory to change to
*
*Exit:
*       returns 0 if successful,
*       returns -1 and sets errno if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tchdir (
        const _TSCHAR *path
        )
{
#ifndef _XBOX
        _TSCHAR env_var[4];
        _TSCHAR abspath[MAX_PATH+1];

        if ( SetCurrentDirectory((LPTSTR)path) )
        {
            /*
             * If the new current directory path is NOT a UNC path, we must
             * update the OS environment variable specifying the current
             * directory for what is now current drive. To do this, get the
             * full current directory, build the environment variable string
             * and call SetEnvironmentVariable(). We need to do this because
             * SetCurrentDirectory does not (i.e., does not update the
             * current-directory-on-drive environment variables) and other
             * functions (fullpath, spawn, etc) need them to be set.
             *
             * If associated with a 'drive', the current directory should
             * have the form of the example below:
             *
             *  D:\nt\private\mytests
             *
             * so that the environment variable should be of the form:
             *
             *  =D:=D:\nt\private\mytests
             *
             */
            if ( GetCurrentDirectory(MAX_PATH+1, (LPTSTR)abspath) != 0 )
            {
                /*
                 * check if it is a UNC name, just return if is
                 */
                if ( ((abspath[0] == _T('\\')) || (abspath[0] == _T('/'))) &&
                     (abspath[0] == abspath[1]) )
                    return 0;

                env_var[0] = _T('=');
                env_var[1] = (_TSCHAR) _totupper((_TUCHAR)abspath[0]);
                env_var[2] = _T(':');
                env_var[3] = _T('\0');

                if ( SetEnvironmentVariable(env_var, abspath) )
                    return 0;
            }
        }

        _dosmaperr(GetLastError());
        return -1;
#else // XBOX
        RIP("_tchdir() not supported on Xbox");
        errno = EINVAL;
        _doserrno = 0;
        return -1;
#endif // XBOX
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\drive.c ===
/***
*drive.c - get and change current drive
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has the _getdrive() and _chdrive() functions
*
*Revision History:
*       06-06-89  PHG   Module created, based on asm version
*       03-07-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and fixed copyright. Also, cleaned up
*                       the formatting a bit.
*       07-24-90  SBM   Removed '32' from API names
*       09-27-90  GJF   New-style function declarators.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       05-10-91  GJF   Fixed off-by-1 error in Win32 version and updated the
*                       function descriptions a bit [_WIN32_].
*       05-19-92  GJF   Revised to use the 'current directory' environment
*                       variables of Win32/NT.
*       06-09-92  GJF   Use _putenv instead of Win32 API call. Also, defer
*                       adding env var until after the successful call to
*                       change the dir/drive.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-24-93  CFW   Rip out Cruiser.
*       11-24-93  CFW   No longer store current drive in CRT env strings.
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format a bit.
*       12-17-97  GJF   Exception-safe locking.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <oscalls.h>
#include <mtdll.h>
#include <internal.h>
#include <msdos.h>
#include <errno.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>


/***
*int _getdrive() - get current drive (1=A:, 2=B:, etc.)
*
*Purpose:
*       Returns the current disk drive
*
*Entry:
*       No parameters.
*
*Exit:
*       returns 1 for A:, 2 for B:, 3 for C:, etc.
*       returns 0 if current drive cannot be determined.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _getdrive (
        void
        )
{
#ifndef _XBOX
        ULONG drivenum;
        UCHAR curdirstr[_MAX_PATH];

        drivenum = 0;
        if (GetCurrentDirectory(sizeof(curdirstr), curdirstr))
                if (curdirstr[1] == ':')
                        drivenum = toupper(curdirstr[0]) - 64;

        return drivenum;
#else // XBOX
        RIP("_getdrive() not supported on Xbox");
        return 0;
#endif // XBOX
}


/***
*int _chdrive(int drive) - set the current drive (1=A:, 2=B:, etc.)
*
*Purpose:
*       Allows the user to change the current disk drive
*
*Entry:
*       drive - the number of drive which should become the current drive
*
*Exit:
*       returns 0 if successful, else -1
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _chdrive (
        int drive
        )
{
#ifndef _XBOX
        int retval;
        char  newdrive[3];

        if (drive < 1 || drive > 31) {
            errno = EACCES;
            _doserrno = ERROR_INVALID_DRIVE;
            return -1;
        }

#ifdef  _MT
        _mlock( _ENV_LOCK );
        __try {
#endif

        newdrive[0] = (char)('A' + (char)drive - (char)1);
        newdrive[1] = ':';
        newdrive[2] = '\0';

        /*
         * Set new drive. If current directory on new drive exists, it
         * will become the cwd. Otherwise defaults to root directory.
         */

        if ( SetCurrentDirectory((LPSTR)newdrive) )
            retval = 0;
        else {
            _dosmaperr(GetLastError());
            retval = -1;
        }

#ifdef  _MT
        }
        __finally {
            _munlock( _ENV_LOCK );
        }
#endif

        return retval;
#else // XBOX
        RIP("_chdrive() not supported on Xbox");
        errno = EINVAL;
        _doserrno = 0;
        return -1;
#endif // XBOX
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\chmod.c ===
/***
*chmod.c - change file attributes
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _chmod() - change file attributes
*
*Revision History:
*       06-06-89  PHG   Module created, based on asm version
*       11-10-89  JCR   Replaced DOS32QUERYFILEMODE with DOS32QUERYPATHINFO
*       03-07-90  GJF   Made calling type _CALLTYPE2 (for now), added #include
*                       <cruntime.h>, fixed copyright and fixed compiler
*                       warnings. Also, cleaned up the formatting a bit.
*       03-30-90  GJF   Now _CALLTYPE1.
*       07-24-90  SBM   Removed '32' from API names
*       09-27-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-16-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-01-93  CFW   Enable Unicode variant, rip out Cruiser.
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format a bit.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <io.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <tchar.h>
#ifdef _XBOX
#include <ochar.h>
#endif

/***
*int _chmod(path, mode) - change file mode
*
*Purpose:
*       Changes file mode permission setting to that specified in
*       mode.  The only XENIX mode bit supported is user write.
*
*Entry:
*       _TSCHAR *path - file name
*       int mode - mode to change to
*
*Exit:
*       returns 0 if successful
*       returns -1 and sets errno if not successful
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tchmod (
        const _TSCHAR *path,
        int mode
        )
{
        DWORD attr;

        attr = GetFileAttributes((LPTSTR)path);
        if (attr  == 0xffffffff) {
                /* error occured -- map error code and return */
                _dosmaperr(GetLastError());
                return -1;
        }

        if (mode & _S_IWRITE) {
                /* clear read only bit */
                attr &= ~FILE_ATTRIBUTE_READONLY;
        }
        else {
                /* set read only bit */
                attr |= FILE_ATTRIBUTE_READONLY;
        }

        /* set new attribute */
        if (!SetFileAttributes((LPTSTR)path, attr)) {
                /* error occured -- map error code and return */
                _dosmaperr(GetLastError());
                return -1;
        }

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\getcwd.c ===
/***
*getcwd.c - get current working directory
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*       contains functions _getcwd, _getdcwd and _getcdrv for getting the
*       current working directory.  getcwd gets the c.w.d. for the default disk
*       drive, whereas _getdcwd allows one to get the c.w.d. for whatever disk
*       drive is specified. _getcdrv gets the current drive.
*
*Revision History:
*       09-09-83  RKW   created
*       05-??-84  DCW   added conditional compilation to handle case of library
*                       where SS != DS (can't take address of a stack variable).
*       09-??-84  DCW   changed comparison of path length to maxlen to take the
*                       terminating null character into account.
*       11-28-84  DCW   changed to return errno values compatibly with the
*                       System 3 version.
*       05-19-86  SKS   adapted for OS/2
*       11-19-86  SKS   if pnbuf==NULL, maxlen is ignored;
*                       eliminated use of intermediate buffer "buf[]"; added
*                       entry point "_getdcwd()" which takes a drive number.
*       12-03-86  SKS   if pnbuf==NULL, maxlen is the minimum allocation size
*       02-05-87  BCM   fixed comparison in _getdcwd,
*                       (unsigned)(len+3) > (int)(maxlen), to handle maxlen < 0,
*                       since implicit cast to (unsigned) was occurring.
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       12-21-87  WAJ   Added _getcdrv()
*       06-22-88  WAJ   _getcdrv() is now made for all OS/2 libs
*       10-03-88  JCR   386: Change DOS calls to SYS calls
*       10-04-88  JCR   386: Removed 'far' keyword
*       10-10-88  GJF   Made API names match DOSCALLS.H
*       01-31-89  JCR   Remove _getcdrv(), which has been renamed _getdrive()
*       04-12-89  JCR   Use new OS/2 system calls
*       05-25-89  JCR   386 OS/2 calls use '_syscall' calling convention
*       11-27-89  JCR   Corrected ERRNO values
*       12-12-89  JCR   Fixed bogus syscall introduced in previous fix (oops)
*       03-07-90  GJF   Replaced _LOAD_DS by _CALLTYPE1, added #include
*                       <cruntime.h>, removed #include <register.h>, removed
*                       some leftover 16-bit support and fixed the copyright.
*                       Also, cleaned up the formatting a bit.
*       07-24-90  SBM   Compiles cleanly with -W3 (removed unreferenced
*                       variable), removed redundant includes, removed
*                       '32' from API names
*       08-10-90  SBM   Compiles cleanly with -W3 with new build of compiler
*       09-27-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-16-91  GJF   ANSI naming.
*       08-21-91  JCR   Test DOSQUERYCURRENTDIR call for error return (bug fix)
*       04-23-92  GJF   Fixed initialization of DriveVar[].
*       04-28-92  GJF   Revised Win32 version.
*       12-09-92  PLM   Removed _getdcwd (Mac version only)
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*                       Change _ValidDrive to _validdrive
*       04-19-93  SKS   Move _validdrive to this module
*       04-26-93  SKS   Set _doserrno on invalid drive
*       05-26-93  SKS   Change _getdcwd to call GetFullPathName() instead of
*                       reading a current directory environment variable.
*       09-30-93  GJF   Removed #include <error.h> (thereby getting rid of a
*                       bunch of compiler warnings). Also, MTHREAD -> _MT.
*       11-01-93  CFW   Enable Unicode variant.
*       12-21-93  CFW   Fix API failure error handling.
*       01-04-94  CFW   Fix API failure error handling correctly.
*       08-11-94  GJF   Revised _validdrive() to use GetDriveType (suggestion
*                       from Richard Shupak).
*       08-18-94  GJF   Revised _validdrive() logic slightly per suggestion
*                       of Richard Shupak.
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format a bit.
*       12-17-97  GJF   Exception-safe locking.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <mtdll.h>
#include <msdos.h>
#include <errno.h>
#include <malloc.h>
#include <oscalls.h>
#include <stdlib.h>
#include <internal.h>
#include <direct.h>
#include <tchar.h>


/***
*_TSCHAR *_getcwd(pnbuf, maxlen) - get current working directory of default drive
*
*Purpose:
*       _getcwd gets the current working directory for the user,
*       placing it in the buffer pointed to by pnbuf.  It returns
*       the length of the string put in the buffer.  If the length
*       of the string exceeds the length of the buffer, maxlen,
*       then NULL is returned.  If pnbuf = NULL, maxlen is ignored.
*       An entry point "_getdcwd()" is defined with takes the above
*       parameters, plus a drive number.  "_getcwd()" is implemented
*       as a call to "_getcwd()" with the default drive (0).
*
*       If pnbuf = NULL, maxlen is ignored, and a buffer is automatically
*       allocated using malloc() -- a pointer to which is returned by
*       _getcwd().
*
*       side effects: no global data is used or affected
*
*Entry:
*       _TSCHAR *pnbuf = pointer to a buffer maintained by the user;
*       int maxlen = length of the buffer pointed to by pnbuf;
*
*Exit:
*       Returns pointer to the buffer containing the c.w.d. name
*       (same as pnbuf if non-NULL; otherwise, malloc is
*       used to allocate a buffer)
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _tgetcwd (
        _TSCHAR *pnbuf,
        int maxlen
        )
{
        _TSCHAR *retval;

#ifdef  _MT
        _mlock( _ENV_LOCK );
        __try {
#endif

#ifdef WPRFLAG
        retval = _wgetdcwd_lk(0, pnbuf, maxlen);
#else
        retval = _getdcwd_lk(0, pnbuf, maxlen);
#endif

#ifdef  _MT
        }
        __finally {
            _munlock( _ENV_LOCK );
        }
#endif

        return retval;
}


/***
*_TSCHAR *_getdcwd(drive, pnbuf, maxlen) - get c.w.d. for given drive
*
*Purpose:
*       _getdcwd gets the current working directory for the user,
*       placing it in the buffer pointed to by pnbuf.  It returns
*       the length of the string put in the buffer.  If the length
*       of the string exceeds the length of the buffer, maxlen,
*       then NULL is returned.  If pnbuf = NULL, maxlen is ignored,
*       and a buffer is automatically allocated using malloc() --
*       a pointer to which is returned by _getdcwd().
*
*       side effects: no global data is used or affected
*
*Entry:
*       int drive   - number of the drive being inquired about
*                     0 = default, 1 = 'a:', 2 = 'b:', etc.
*       _TSCHAR *pnbuf - pointer to a buffer maintained by the user;
*       int maxlen  - length of the buffer pointed to by pnbuf;
*
*Exit:
*       Returns pointer to the buffer containing the c.w.d. name
*       (same as pnbuf if non-NULL; otherwise, malloc is
*       used to allocate a buffer)
*
*Exceptions:
*
*******************************************************************************/


#ifdef  _MT

_TSCHAR * __cdecl _tgetdcwd (
        int drive,
        _TSCHAR *pnbuf,
        int maxlen
        )
{
        _TSCHAR *retval;

#ifdef  _MT
        _mlock( _ENV_LOCK );
        __try {
#endif

#ifdef  WPRFLAG
        retval = _wgetdcwd_lk(drive, pnbuf, maxlen);
#else
        retval = _getdcwd_lk(drive, pnbuf, maxlen);
#endif

#ifdef  _MT
        }
        _finally {
            _munlock( _ENV_LOCK );
        }
#endif

        return retval;
}

#ifdef  WPRFLAG
wchar_t * __cdecl _wgetdcwd_lk (
#else
char * __cdecl _getdcwd_lk (
#endif
        int drive,
        _TSCHAR *pnbuf,
        int maxlen
        )
#else

_TSCHAR * __cdecl _tgetdcwd (
        int drive,
        _TSCHAR *pnbuf,
        int maxlen
        )
#endif

{
#ifndef _XBOX
        _TSCHAR *p;
        _TSCHAR dirbuf[_MAX_PATH];
        _TSCHAR drvstr[4];
        int len;
        _TSCHAR *pname; /* only used as argument to GetFullPathName */

        /*
         * GetCurrentDirectory only works for the default drive in Win32
         */
        if ( drive != 0 ) {
            /*
             * Not the default drive - make sure it's valid.
             */
            if ( !_validdrive(drive) ) {
                _doserrno = ERROR_INVALID_DRIVE;
                errno = EACCES;
                return NULL;
            }

            /*
             * Get the current directory string on that drive and its length
             */
            drvstr[0] = _T('A') - 1 + drive;
            drvstr[1] = _T(':');
            drvstr[2] = _T('.');
            drvstr[3] = _T('\0');
            len = GetFullPathName( drvstr, 
                                   sizeof(dirbuf) / sizeof(_TSCHAR), 
                                   dirbuf, 
                                   &pname );

        } else {

            /*
             * Get the current directory string and its length
             */
            len = GetCurrentDirectory( sizeof(dirbuf) / sizeof(_TSCHAR), 
                                       (LPTSTR)dirbuf );
        }

        /* API call failed, or buffer not large enough */
        if ( len == 0 || ++len > sizeof(dirbuf)/sizeof(_TSCHAR) )
            return NULL;

        /*
         * Set up the buffer.
         */
        if ( (p = pnbuf) == NULL ) {
            /*
             * Allocate a buffer for the user.
             */
            if ( (p = (_TSCHAR *)malloc(__max(len, maxlen) * sizeof(_TSCHAR)))
                 == NULL ) 
            {
                errno = ENOMEM;
                return NULL;
            }
        }
        else if ( len > maxlen ) {
            /*
             * Won't fit in the user-supplied buffer!
             */
            errno = ERANGE; /* Won't fit in user buffer */
            return NULL;
        }

        /*
         * Place the current directory string into the user buffer
         */

        return _tcscpy(p, dirbuf);
#else // XBOX
    RIP("_tgetdcwd() not supported on Xbox");
    return NULL;
#endif // XBOX
}

#ifndef WPRFLAG

/***
*int _validdrive( unsigned drive ) -
*
*Purpose: returns non zero if drive is a valid drive number.
*
*Entry: drive = 0 => default drive, 1 => a:, 2 => b: ...
*
*Exit:  0 => drive does not exist.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _validdrive (
    unsigned drive
    )
{
#ifndef _XBOX
        unsigned retcode;
        char drvstr[4];

        if ( drive == 0 )
            return 1;

        drvstr[0] = 'A' + drive - 1;
        drvstr[1] = ':';
        drvstr[2] = '\\';
        drvstr[3] = '\0';

        if ( ((retcode = GetDriveType( drvstr )) == DRIVE_UNKNOWN) ||
             (retcode == DRIVE_NO_ROOT_DIR) )
            return 0;

        return 1;
#else // XBOX
    RIP("_validdrive() not supported on Xbox");
    return 0;
#endif // XBOX
}

#endif  /* WPRFLAG */

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\mterrno.c ===
/***
*mterrno.c - provide function versions of errno & _doserrno for LIBC.LIB
*
*	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Sometimes users want to compile code (such as for use in a library)
*	for both single-thread and multi-thread applications.  Currently the
*	one major stumbling block to doing this is the fact that errno &
*	_doserrno are defined in different ways in LIBC.LIB and LIBCMT.LIB.
*	Code that should otherwise be usable with both LIBC.LIB and LIBCMT.LIB
*	but which accesses errno and/or _doserrno is not usable with both.
*	By providing the function versions of errno & _doserrno in LIBC.LIB,
*	users can compile their code for both LIBCMT.LIB and LIBC.LIB.
*	Note that this does not magically make single-thread code safe in a
*	multi-threaded environment, it merely makes it easier to use the
*	same code with LIBC.LIB and LIBCMT.LIB.
*
*Revision History:
*	03-26-94  SKS	Original version.
*
*******************************************************************************/

#ifndef _MT

/* Get the definitions of the function versions of errno/_doserrno */

#define _MT
#include <stdlib.h>
#undef _MT

/* undo the macros that convert the variable names to function calls */

#undef errno
#undef _doserrno

/* declare the variables - must match the definitions in <STDLIB.H> */

extern int errno;			/* XENIX style error number */
extern unsigned long _doserrno; 	/* OS system error value */


/***
*int * _errno() 		- return pointer to thread's errno
*unsigned long * __doserrno()	- return pointer to thread's _doserrno
*
*Purpose:
*	_errno() returns a pointer to the global variable errno
*	__doserrno returns a pointer to the global variable _doserrno
*
*Entry:
*	None.
*
*Exit:
*	See above.
*
*Exceptions:
*
*******************************************************************************/

int * __cdecl _errno(
	void
	)
{
	return & errno;
}

unsigned long * __cdecl __doserrno(
	void
	)
{
	return & _doserrno;
}

#endif	/* !_MT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\getpid.c ===
/***
*getpid.c - get current process id
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _getpid() - get current process id
*
*Revision History:
*       06-06-89  PHG   Module created, based on asm version
*       10-27-89  JCR   Added new Dos32GetThreadInfo code (under DCR757 switch)
*       11-17-89  JCR   Enabled DOS32GETTHREADINFO code (DCR757)
*       03-07-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and fixed copyright. Also, cleaned up the
*                       formatting a bit.
*       07-02-90  GJF   Removed pre-DCR757 stuff.
*       08-08-90  GJF   Changed API prefix from DOS32 to DOS
*       10-03-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-28-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Remove Cruiser support.
*       02-06-92  CFW   assert.h removed. (Mac version only)
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format a bit.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <oscalls.h>

/***
*int _getpid() - get current process id
*
*Purpose:
*       Returns the current process id for the calling process.
*
*Entry:
*       None.
*
*Exit:
*       Returns the current process id.
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _getpid (
        void
        )
{
#ifdef _XBOX
        RIP("_getpid() not supported on Xbox");
        return 1;
#else
        return GetCurrentProcessId();
#endif // XBOX
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\mkdir.c ===
/***
*mkdir.c - make directory
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines function _mkdir() - make a directory
*
*Revision History:
*       06-06-89  PHG   Module created, based on asm version
*       03-07-90  GJF   Made calling type _CALLTYPE2 (for now), added #include
*                       <cruntime.h>, fixed compiler warnings and fixed the
*                       copyright. Also, cleaned up the formatting a bit.
*       03-30-90  GJF   Now _CALLTYPE1.
*       07-24-90  SBM   Removed '32' from API names
*       09-27-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-16-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-01-93  CFW   Enable Unicode variant, rip out Cruiser.
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format a bit.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <direct.h>
#include <tchar.h>
#ifdef _XBOX
#include <ochar.h>
#endif

/***
*int _mkdir(path) - make a directory
*
*Purpose:
*       creates a new directory with the specified name
*
*Entry:
*       _TSCHAR *path - name of new directory
*
*Exit:
*       returns 0 if successful
*       returns -1 and sets errno if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tmkdir (
        const _TSCHAR *path
        )
{
        ULONG dosretval;

        /* ask OS to create directory */

        if (!CreateDirectory((LPTSTR)path, (LPSECURITY_ATTRIBUTES)NULL))
            dosretval = GetLastError();
        else
            dosretval = 0;

        if (dosretval) {
            /* error occured -- map error code and return */
            _dosmaperr(dosretval);
            return -1;
        }

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\sources.inc ===
MAJORCOMP=crt
MINORCOMP=dos

TARGETNAME=dos

!INCLUDE ..\..\crt32.inc

SOURCES=\
        ..\access.c    \
        ..\chmod.c     \
        ..\chdir.c     \
        ..\dosmap.c    \
        ..\drive.c     \
        ..\fullpath.c  \
        ..\getcwd.c    \
        ..\getpid.c    \
        ..\mkdir.c     \
        ..\rename.c    \
        ..\rmdir.c     \
        ..\stat.c      \
        ..\unlink.c    \
        ..\mterrno.c   \
        ..\stat64.c    \
        ..\stati64.c   \
        ..\waccess.c   \
        ..\wchdir.c    \
        ..\wchmod.c    \
        ..\wfullpat.c  \
        ..\wgetcwd.c   \
        ..\wmkdir.c    \
        ..\wrename.c   \
        ..\wrmdir.c    \
        ..\wstat.c     \
        ..\wstat64.c   \
        ..\wstati64.c  \
        ..\wunlink.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\rmdir.c ===
/***
*rmdir.c - remove directory
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _rmdir() - remove a directory
*
*Revision History:
*       06-06-89  PHG   Module created, based on asm version
*       03-07-90  GJF   Made calling type _CALLTYPE2 (for now), added #include
*                       <cruntime.h>, fixed compiler warnings and fixed the
*                       copyright. Also, cleaned up the formatting a bit.
*       03-30-90  GJF   Now _CALLTYPE1.
*       07-24-90  SBM   Removed '32' from API names
*       09-27-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-16-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-01-93  CFW   Enable Unicode variant, rip out Cruiser.
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format a bit.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <direct.h>
#include <tchar.h>
#ifdef _XBOX
#include <ochar.h>
#endif

/***
*int _rmdir(path) - remove a directory
*
*Purpose:
*       deletes the directory speicifed by path.  The directory must
*       be empty, and it must not be the current working directory or
*       the root directory.
*
*Entry:
*       _TSCHAR *path - directory to remove
*
*Exit:
*       returns 0 if successful
*       returns -1 and sets errno if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _trmdir (
        const _TSCHAR *path
        )
{
        ULONG dosretval;

        /* ask OS to remove directory */

        if (!RemoveDirectory((LPTSTR)path))
            dosretval = GetLastError();
        else
            dosretval = 0;

        if (dosretval) {
            /* error occured -- map error code and return */
            _dosmaperr(dosretval);
            return -1;
        }

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\stat.c ===
/***
*stat.c - get file status
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _stat() - get file status
*
*Revision History:
*       03-??-84  RLB   Module created
*       05-??-84  DCW   Some cleanup and addition of register variables
*       05-17-86  SKS   Ported to OS/2
*       11-19-86  SKS   Better check for root directory; KANJI support
*       05-22-87  SKS   Cleaned up declarations and include files
*       11-18-87  SKS   Make _dtoxmode a static near procedure
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       12-21-87  WAJ   stat no longer uses chdir to figure out if it has been
*                       passed a root directory in the MTHREAD case.
*       01-05-88  WAJ   now uses _MAX_PATH (defined in stdlib.h)
*       06-22-88  SKS   find Hidden and System files, not just normal ones
*       06-22-88  SKS   Always use better algorithm to detect root dirs
*       06-29-88  WAJ   When looking for root dir makes sure it exists
*       09-28-88  JCR   Use new 386 dostypes.h structures
*       10-03-88  JCR   386: Change DOS calls to SYS calls
*       10-04-88  JCR   386: Removed 'far' keyword
*       10-10-88  GJF   Made API names match DOSCALLS.H
*       11-24-88  GJF   ".cmd" should be considered executable, not ".bat"
*       01-31-89  JCR   _canonic() is now _fullpath() and args reversed
*       04-12-89  JCR   New syscall interace
*       05-25-89  JCR   386 OS/2 calls use '_syscall' calling convention
*       03-07-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h>, removed #include <register.h> and
*                       removed some leftover 16-bit support. Also, fixed
*                       the copyright.
*       04-02-90  GJF   Made _ValidDrive() and _dtoxmode() _CALLTYPE1. Removed
*                       #include <dos.h>.
*       07-23-90  SBM   Compiles cleanly with -W3 (added/removed appropriate
*                       includes), removed '32' from API names
*       08-10-90  SBM   Compiles cleanly with -W3 with new build of compiler
*       09-03-90  SBM   Removed EXT macro
*       09-27-90  GJF   New-style function declarators.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       12-28-90  SRW   Added cast of void * to char * for Mips C Compiler
*       01-18-91  GJF   ANSI naming.
*       01-28-91  GJF   Fixed call to DOSFINDFIRST (removed last arg).
*       02-28-91  SRW   Fixed bug in _dtoxtime calls [_WIN32_]
*       03-05-91  MHL   Fixed stat to not use _ValidDrive for stat of root
*       05-19-92  SKS   .BAT is a valid "executable" extension for NT, as
*                       well as CMD.  Also, File Creation and File Last Access
*                       timestamps may be 0 on some file systems (e.g. FAT)
*                       in which case the File Last Write time should be used.
*       05-29-92  SKS   Files with SYSTEM bit set should NOT be marked
*                       READ-ONLY; these two attributes are independent.
*       08-18-92  SKS   Add a call to FileTimeToLocalFileTime
*                       as a temporary fix until _dtoxtime takes UTC
*       11-20-92  SKS   _doserrno must always be set whenever errno is.
*       11-30-92  KRS   Port _MBCS support from 16-bit tree.
*       03-29-93  GJF   Converted from using _dtoxtime() to __gmtotime_t().
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*                       Change _ValidDrive to _validdrive
*       04-07-93  GJF   Changed first arg type to const char *.
*       04-18-93  SKS   Move _validdrive to getcwd.c and make it static
*       07-21-93  GJF   Converted from using __gmtotime_t to __loctotime_t
*                       (amounts to reversing the change of 03-29-93).
*       12-16-93  CFW   Enable Unicode variant.
*       12-28-94  GJF   Added _stati64 and _wstati64.
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       03-27-95  SKS   loctotime_t uses absolute years (not year-1900)!
*       09-25-95  GJF   __loctotime_t now takes a DST flag, pass -1 in this
*                       slot to indicate DST is undetermined.
*       11-29-95  SKS   Add support for calls such as stat("//server/share/")
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format.
*       05-17-99  PML   Remove all Macintosh support.
*       10-27-99  GB    Remove #inlcude <dostypes.h>
*
*******************************************************************************/

#include <cruntime.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <ctype.h>
#include <msdos.h>
#include <oscalls.h>
#include <string.h>
#include <internal.h>
#include <stdlib.h>
#include <direct.h>
#include <mbstring.h>
#include <tchar.h>
#ifdef _XBOX
#include <ochar.h>
#endif


#define ISSLASH(a)  ((a) == _T('\\') || (a) == _T('/'))


#ifdef  _UNICODE
#define __tdtoxmode __wdtoxmode
#else   /* ndef _UNICODE */
#define __tdtoxmode __dtoxmode
#endif  /* _UNICODE */


/*
 * Local routine which returns true if the argument is a UNC name
 * specifying the root name of a share, such as '\\server\share\'.
 */

static int IsRootUNCName(const _TSCHAR *path);


/***
*unsigned __tdtoxmode(attr, name) -
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

#ifdef  _USE_INT64

extern unsigned short __cdecl __tdtoxmode(int, const _TSCHAR *);

#else   /* ndef _USE_INT64 */

unsigned short __cdecl __tdtoxmode (
        int attr,
        const _TSCHAR *name
        )
{
        REG1 unsigned short uxmode;
        unsigned dosmode;
        REG2 const _TSCHAR *p;

        dosmode = attr & 0xff;
        if ((p = name)[1] == _T(':'))
            p += 2;

        /* check to see if this is a directory - note we must make a special
        * check for the root, which DOS thinks is not a directory
        */

        uxmode = (unsigned short)
                 (((ISSLASH(*p) && !p[1]) || (dosmode & A_D) || !*p)
                 ? _S_IFDIR|_S_IEXEC : _S_IFREG);

        /* If attribute byte does not have read-only bit, it is read-write */

        uxmode |= (dosmode & A_RO) ? _S_IREAD : (_S_IREAD|_S_IWRITE);

        /* see if file appears to be executable - check extension of name */

        if (p = _tcsrchr(name, _T('.'))) {
            if ( !_tcsicmp(p, _T(".exe")) ||
                 !_tcsicmp(p, _T(".cmd")) ||
                 !_tcsicmp(p, _T(".bat")) ||
                 !_tcsicmp(p, _T(".com")) )
                uxmode |= _S_IEXEC;
        }

        /* propagate user read/write/execute bits to group/other fields */

        uxmode |= (uxmode & 0700) >> 3;
        uxmode |= (uxmode & 0700) >> 6;

        return(uxmode);
}

#endif  /* _USE_INT64 */

/***
*int _stat(name, buf) - get file status info
*
*Purpose:
*       _stat obtains information about the file and stores it in the 
*       structure pointed to by buf.
*
*       Note: We cannot directly use the file time stamps returned in the
*       WIN32_FIND_DATA structure. The values are supposedly in system time
*       and system time is ambiguously defined (it is UTC for Windows NT, local
*       time for Win32S and probably local time for Win32C). Therefore, these
*       values must be converted to local time before than can be used.
*
*Entry:
*       _TSCHAR *name -    pathname of given file
*       struct _stat *buffer - pointer to buffer to store info in
*
*Exit:
*       fills in structure pointed to by buffer
*       returns 0 if successful
*       returns -1 and sets errno if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

#ifdef  _USE_INT64

int __cdecl _tstati64 (
        REG1 const _TSCHAR *name,
        REG2 struct _stati64 *buf
        )

#else   /* ndef _USE_INT64 */

int __cdecl _tstat (
        REG1 const _TSCHAR *name,
        REG2 struct _stat *buf
        )

#endif  /* _USE_INT64 */

{
        _TSCHAR *  path;
        _TSCHAR    pathbuf[ _MAX_PATH ];
        int drive;          /* A: = 1, B: = 2, etc. */
        HANDLE findhandle;
        WIN32_FIND_DATA findbuf;

        /* Don't allow wildcards to be interpreted by system */

#ifdef  _UNICODE
        if (wcspbrk(name, L"?*")) {
#else
        if (_mbspbrk(name, "?*")) {
#endif
            errno = ENOENT;
            _doserrno = E_nofile;
            return(-1);
        }

        /* Try to get disk from name.  If none, get current disk.  */

        if (name[1] == _T(':')){
            if ( *name && !name[2] ){
                errno = ENOENT;             /* return an error if name is   */
                _doserrno = E_nofile;       /* just drive letter then colon */
                return( -1 );
            }
            drive = _totlower(*name) - _T('a') + 1;
        }
        else
#ifdef _XBOX
            drive = 0;
#else // XBOX
            drive = _getdrive();
#endif // XBOX

        /* Call Find Match File */
        findhandle = FindFirstFile((_TSCHAR *)name, &findbuf);
        if ( findhandle == INVALID_HANDLE_VALUE ) {
#ifndef _XBOX
#ifdef  _UNICODE
            if ( !( wcspbrk(name, L"./\\") &&
#else
            if ( !( _mbspbrk(name, "./\\") &&
#endif
                 (path = _tfullpath( pathbuf, name, _MAX_PATH )) &&
                 /* root dir. ('C:\') or UNC root dir. ('\\server\share\') */
                 ((_tcslen( path ) == 3) || IsRootUNCName(path)) &&
                 (GetDriveType( path ) > 1) ) ) 
            {
#endif // XBOX
                errno = ENOENT;
                _doserrno = E_nofile;
                return( -1 );
#ifndef _XBOX
            }

            /*
             * Root directories (such as C:\ or \\server\share\ are fabricated.
             */

            findbuf.dwFileAttributes = A_D;
            findbuf.nFileSizeHigh = 0;
            findbuf.nFileSizeLow = 0;
            findbuf.cFileName[0] = _T('\0');

            buf->st_mtime = __loctotime_t(1980,1,1,0,0,0, -1);
            buf->st_atime = buf->st_mtime;
            buf->st_ctime = buf->st_mtime;
#endif // XBOX
        }
        else {
            SYSTEMTIME SystemTime;
            FILETIME LocalFTime;

            if ( !FileTimeToLocalFileTime( &findbuf.ftLastWriteTime, 
                                           &LocalFTime )            ||
                 !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
            {
                _dosmaperr( GetLastError() );
                FindClose( findhandle );
                return( -1 );
            }

            buf->st_mtime = __loctotime_t( SystemTime.wYear,
                                           SystemTime.wMonth,
                                           SystemTime.wDay,
                                           SystemTime.wHour,
                                           SystemTime.wMinute,
                                           SystemTime.wSecond,
                                           -1 );

            if ( findbuf.ftLastAccessTime.dwLowDateTime ||
                 findbuf.ftLastAccessTime.dwHighDateTime )
            {
                if ( !FileTimeToLocalFileTime( &findbuf.ftLastAccessTime,
                                               &LocalFTime )                ||
                     !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
                {
                    _dosmaperr( GetLastError() );
                    FindClose( findhandle );
                    return( -1 );
                }

                buf->st_atime = __loctotime_t( SystemTime.wYear,
                                               SystemTime.wMonth,
                                               SystemTime.wDay,
                                               SystemTime.wHour,
                                               SystemTime.wMinute,
                                               SystemTime.wSecond,
                                               -1 );
            } else
                buf->st_atime = buf->st_mtime ;

            if ( findbuf.ftCreationTime.dwLowDateTime ||
                 findbuf.ftCreationTime.dwHighDateTime )
            {
                if ( !FileTimeToLocalFileTime( &findbuf.ftCreationTime,
                                               &LocalFTime )                ||
                     !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
                {
                    _dosmaperr( GetLastError() );
                    FindClose( findhandle );
                    return( -1 );
                }

                buf->st_ctime = __loctotime_t( SystemTime.wYear,
                                               SystemTime.wMonth,
                                               SystemTime.wDay,
                                               SystemTime.wHour,
                                               SystemTime.wMinute,
                                               SystemTime.wSecond,
                                               -1 );
            } else
                buf->st_ctime = buf->st_mtime ;

            FindClose(findhandle);
        }

        /* Fill in buf */

        buf->st_mode = __tdtoxmode(findbuf.dwFileAttributes, name);
        buf->st_nlink = 1;

#ifdef  _USE_INT64
        buf->st_size = ((__int64)(findbuf.nFileSizeHigh)) * (0x100000000i64) +
                        (__int64)(findbuf.nFileSizeLow);
#else   /* ndef _USE_INT64 */
        buf->st_size = findbuf.nFileSizeLow;
#endif  /* _USE_INT64 */

        /* now set the common fields */

        buf->st_uid = buf->st_gid = buf->st_ino = 0;

        buf->st_rdev = buf->st_dev = (_dev_t)(drive - 1); /* A=0, B=1, etc. */

        return(0);
}


/*
 * IsRootUNCName - returns TRUE if the argument is a UNC name specifying
 *      a root share.  That is, if it is of the form \\server\share\.
 *      This routine will also return true if the argument is of the
 *      form \\server\share (no trailing slash) but Win32 currently
 *      does not like that form.
 *
 *      Forward slashes ('/') may be used instead of backslashes ('\').
 */

static int IsRootUNCName(const _TSCHAR *path)
{
        /*
         * If a root UNC name, path will start with 2 (but not 3) slashes
         */

        if ( ( _tcslen ( path ) >= 5 ) /* minimum string is "//x/y" */
             && ISSLASH(path[0]) && ISSLASH(path[1]))
        {
            const _TSCHAR * p = path + 2 ;

            /*
             * find the slash between the server name and share name
             */
            while ( * ++ p )
                if ( ISSLASH(*p) )
                    break ;

            if ( *p && p[1] )
            {
                /*
                 * is there a further slash?
                 */
                while ( * ++ p )
                    if ( ISSLASH(*p) )
                        break ;

                /*
                 * just final slash (or no final slash)
                 */
                if ( !*p || !p[1])
                    return 1;
            }
        }

        return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\stat64.c ===
/***
*stat64.c - get file status
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _stat64() - get file status
*
*Revision History:
*       06-02-98  GJF   Created.
*       11-10-99  GB    Made changes so as to take care of DST.
*
*******************************************************************************/

#include <cruntime.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <ctype.h>
#include <msdos.h>
#include <oscalls.h>
#include <string.h>
#include <internal.h>
#include <stdlib.h>
#include <direct.h>
#include <mbstring.h>
#include <tchar.h>
#ifdef _XBOX
#include <ochar.h>
#endif


#define ISSLASH(a)  ((a) == _T('\\') || (a) == _T('/'))


/*
 * Number of 100 nanosecond units from 1/1/1601 to 1/1/1970
 */
#define EPOCH_BIAS  116444736000000000i64


#ifdef  _UNICODE
#define __tdtoxmode __wdtoxmode
#else   /* ndef _UNICODE */
#define __tdtoxmode __dtoxmode
#endif  /* _UNICODE */


/*
 * Local routine which returns true if the argument is a UNC name
 * specifying the root name of a share, such as '\\server\share\'.
 */

static int IsRootUNCName(const _TSCHAR *path);

extern unsigned short __cdecl __tdtoxmode(int, const _TSCHAR *);


/***
*int _stat64(name, buf) - get file status info
*
*Purpose:
*       _stat64 obtains information about the file and stores it in the
*       structure pointed to by buf.
*
*       Note: Unlike _stat, _stat64 uses the UTC time values returned in
*       WIN32_FIND_DATA struct. This means the time values will always be
*       correct on NTFS, but may be wrong on FAT file systems for file times
*       whose DST state is different from the current DST state (this an NT
*       bug).
*
*Entry:
*       _TSCHAR *name -    pathname of given file
*       struct _stat *buffer - pointer to buffer to store info in
*
*Exit:
*       fills in structure pointed to by buffer
*       returns 0 if successful
*       returns -1 and sets errno if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tstat64 (
        REG1 const _TSCHAR *name,
        REG2 struct __stat64 *buf
        )
{
        _TSCHAR *  path;
        _TSCHAR    pathbuf[ _MAX_PATH ];
        int drive;          /* A: = 1, B: = 2, etc. */
        HANDLE findhandle;
        WIN32_FIND_DATA findbuf;

        /* Don't allow wildcards to be interpreted by system */

#ifdef  _UNICODE
        if (wcspbrk(name, L"?*")) {
#else
        if (_mbspbrk(name, "?*")) {
#endif
            errno = ENOENT;
            _doserrno = E_nofile;
            return(-1);
        }

        /* Try to get disk from name.  If none, get current disk.  */

        if (name[1] == _T(':')){
            if ( *name && !name[2] ){
                errno = ENOENT;             /* return an error if name is   */
                _doserrno = E_nofile;       /* just drive letter then colon */
                return( -1 );
            }
            drive = _totlower(*name) - _T('a') + 1;
        }
        else
#ifdef _XBOX
            drive = 0;
#else // XBOX
            drive = _getdrive();
#endif // XBOX

        /* Call Find Match File */
        findhandle = FindFirstFile((_TSCHAR *)name, &findbuf);
        if ( findhandle == INVALID_HANDLE_VALUE ) {
#ifndef _XBOX
#ifdef  _UNICODE
            if ( !( wcspbrk(name, L"./\\") &&
#else
            if ( !( _mbspbrk(name, "./\\") &&
#endif
                 (path = _tfullpath( pathbuf, name, _MAX_PATH )) &&
                 /* root dir. ('C:\') or UNC root dir. ('\\server\share\') */
                 ((_tcslen( path ) == 3) || IsRootUNCName(path)) &&
                 (GetDriveType( path ) > 1) ) ) 
            {
#endif // XBOX
                errno = ENOENT;
                _doserrno = E_nofile;
                return( -1 );
#ifndef _XBOX
            }

            /*
             * Root directories (such as C:\ or \\server\share\ are fabricated.
             */

            findbuf.dwFileAttributes = A_D;
            findbuf.nFileSizeHigh = 0;
            findbuf.nFileSizeLow = 0;
            findbuf.cFileName[0] = _T('\0');

            buf->st_mtime = __loctotime64_t(1980,1,1,0,0,0, -1);
            buf->st_atime = buf->st_mtime;
            buf->st_ctime = buf->st_mtime;
#endif // XBOX
        }
        else {
            SYSTEMTIME SystemTime;
            FILETIME LocalFTime;

            if ( !FileTimeToLocalFileTime( &findbuf.ftLastWriteTime, 
                                           &LocalFTime )            ||
                 !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
            {
                _dosmaperr( GetLastError() );
                FindClose( findhandle );
                return( -1 );
            }

            buf->st_mtime = __loctotime64_t( SystemTime.wYear,
                                           SystemTime.wMonth,
                                           SystemTime.wDay,
                                           SystemTime.wHour,
                                           SystemTime.wMinute,
                                           SystemTime.wSecond,
                                           -1 );

            if ( findbuf.ftLastAccessTime.dwLowDateTime ||
                 findbuf.ftLastAccessTime.dwHighDateTime )
            {
                if ( !FileTimeToLocalFileTime( &findbuf.ftLastAccessTime,
                                               &LocalFTime )                ||
                     !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
                {
                    _dosmaperr( GetLastError() );
                    FindClose( findhandle );
                    return( -1 );
                }

                buf->st_atime = __loctotime64_t( SystemTime.wYear,
                                               SystemTime.wMonth,
                                               SystemTime.wDay,
                                               SystemTime.wHour,
                                               SystemTime.wMinute,
                                               SystemTime.wSecond,
                                               -1 );
            } else
                buf->st_atime = buf->st_mtime ;

            if ( findbuf.ftCreationTime.dwLowDateTime ||
                 findbuf.ftCreationTime.dwHighDateTime )
            {
                if ( !FileTimeToLocalFileTime( &findbuf.ftCreationTime,
                                               &LocalFTime )                ||
                     !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
                {
                    _dosmaperr( GetLastError() );
                    FindClose( findhandle );
                    return( -1 );
                }

                buf->st_ctime = __loctotime64_t( SystemTime.wYear,
                                               SystemTime.wMonth,
                                               SystemTime.wDay,
                                               SystemTime.wHour,
                                               SystemTime.wMinute,
                                               SystemTime.wSecond,
                                               -1 );
            } else
                buf->st_ctime = buf->st_mtime ;

            FindClose(findhandle);
        }

        /* Fill in buf */

        buf->st_mode = __tdtoxmode(findbuf.dwFileAttributes, name);
        buf->st_nlink = 1;
        buf->st_size = ((__int64)(findbuf.nFileSizeHigh)) * (0x100000000i64) +
                        (__int64)(findbuf.nFileSizeLow);

        /* now set the common fields */

        buf->st_uid = buf->st_gid = buf->st_ino = 0;

        buf->st_rdev = buf->st_dev = (_dev_t)(drive - 1); /* A=0, B=1, etc. */

        return(0);
}


/*
 * IsRootUNCName - returns TRUE if the argument is a UNC name specifying
 *      a root share.  That is, if it is of the form \\server\share\.
 *      This routine will also return true if the argument is of the
 *      form \\server\share (no trailing slash) but Win32 currently
 *      does not like that form.
 *
 *      Forward slashes ('/') may be used instead of backslashes ('\').
 */

static int IsRootUNCName(const _TSCHAR *path)
{
        /*
         * If a root UNC name, path will start with 2 (but not 3) slashes
         */

        if ( ( _tcslen ( path ) >= 5 ) /* minimum string is "//x/y" */
             && ISSLASH(path[0]) && ISSLASH(path[1]))
        {
            const _TSCHAR * p = path + 2 ;

            /*
             * find the slash between the server name and share name
             */
            while ( * ++ p )
                if ( ISSLASH(*p) )
                    break ;

            if ( *p && p[1] )
            {
                /*
                 * is there a further slash?
                 */
                while ( * ++ p )
                    if ( ISSLASH(*p) )
                        break ;

                /*
                 * just final slash (or no final slash)
                 */
                if ( !*p || !p[1])
                    return 1;
            }
        }

        return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\rename.c ===
/***
*rename.c - rename file
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines rename() - rename a file
*
*Revision History:
*       06-06-89  PHG   Module created, based on asm version
*       03-07-90  GJF   Made calling type _CALLTYPE2 (for now), added #include
*                       <cruntime.h>, fixed compiler warnings and fixed the
*                       copyright. Also, cleaned up the formatting a bit.
*       03-30-90  GJF   Now _CALLTYPE1.
*       07-24-90  SBM   Removed '32' from API names
*       09-27-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-01-93  CFW   Enable Unicode variant, rip out Cruiser.
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format a bit.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <io.h>
#include <tchar.h>
#ifdef _XBOX
#include <ochar.h>
#endif

/***
*int rename(oldname, newname) - rename a file
*
*Purpose:
*       Renames a file to a new name -- no file with new name must
*       currently exist.
*
*Entry:
*       _TSCHAR *oldname -      name of file to rename
*       _TSCHAR *newname -      new name for file
*
*Exit:
*       returns 0 if successful
*       returns not 0 and sets errno if not successful
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _trename (
        const _TSCHAR *oldname,
        const _TSCHAR *newname
        )
{
        ULONG dosretval;

        /* ask OS to move file */

        if (!MoveFile((LPTSTR)oldname, (LPTSTR)newname))
            dosretval = GetLastError();
        else
            dosretval = 0;

        if (dosretval) {
            /* error occured -- map error code and return */
            _dosmaperr(dosretval);
            return -1;
        }

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\stati64.c ===
/***
*stati64.c - get file status
*
*	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines _stati64() - get file status
*
*Revision History:
*	12-28-94  GJF	Module created.
*
*******************************************************************************/

#define _USE_INT64  1

#include "stat.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\wchdir.c ===
/***
*wchdir.c - change directory (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file has the _wchdir() function - change current directory.
*
*Revision History:
*	12-08-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "chdir.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\unlink.c ===
/***
*unlink.c - unlink a file
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines unlink() - unlink a file
*
*Revision History:
*       06-06-89  PHG   Module created, based on asm version
*       03-07-90  GJF   Made calling type _CALLTYPE2 (for now), added #include
*                       <cruntime.h>, fixed compiler warnings and fixed the
*                       copyright. Also, cleaned up the formatting a bit.
*       07-24-90  SBM   Removed '32' from API names
*       09-27-90  GJF   New-style function declarators.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-16-91  GJF   ANSI naming.
*       04-10-91  PNT   Added _MAC_ conditional
*       03-16-92  PLM   MAC verison ccreated from OS/2 version
*       04-10-91  PNT   Added _MAC_ conditional (Mac version only)
*       11-02-92  PLM   Added directory test and extracted code for remove() (Mac version only)
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-01-93  CFW   Enable Unicode variant, rip out Cruiser.
*       02-08-95  JWM   Spliced _WIN32 & Mac versions.
*       07-01-96  GJF   Replaced defined(_WIN32) with !defined(_MAC). Also,
*                       detab-ed and cleaned up the format a bit.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <io.h>
#include <tchar.h>
#ifdef _XBOX
#include <ochar.h>
#endif

/***
*int _unlink(path) - unlink(delete) the given file
*
*Purpose:
*       This version deletes the given file because there is no
*       distinction between a linked file and non-linked file.
*
*       NOTE: remove() is an alternative entry point to the _unlink()
*       routine* interface is identical.
*
*Entry:
*       _TSCHAR *path - file to unlink/delete
*
*Exit:
*       returns 0 if successful
*       returns -1 and sets errno if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tremove (
        const _TSCHAR *path
        )
{
        ULONG dosretval;

        if (!DeleteFile((LPTSTR)path))
            dosretval = GetLastError();
        else
            dosretval = 0;

        if (dosretval) {
            /* error occured -- map error code and return */
            _dosmaperr(dosretval);
            return -1;
        }

        return 0;
}

int __cdecl _tunlink (
        const _TSCHAR *path
        )
{
        /* remove is synonym for unlink */
        return _tremove(path);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\wchmod.c ===
/***
*wchmod.c - change file attributes (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines _wchmod() - change file attributes
*
*Revision History:
*	10-29-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "chmod.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\waccess.c ===
/***
*waccess.c - access function (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file has the _waccess() function which checks on file accessability.
*
*Revision History:
*	10-29-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "access.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\wfullpat.c ===
/***
*wfullpath.c - (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose: contains the function _wfullpath which makes an absolute path out
*	of a relative path. i.e.  ..\pop\..\main.c => c:\src\main.c if the
*	current directory is c:\src\src
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "fullpath.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\wrename.c ===
/***
*wrename.c - rename file (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines wrename() - rename a file
*
*Revision History:
*	10-29-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "rename.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\wmkdir.c ===
/***
*wmkdir.c - make directory (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines function _wmkdir() - make a directory
*
*Revision History:
*	10-29-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "mkdir.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\wgetcwd.c ===
/***
*wgetcwd.c - get current working directory (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*	contains functions _getcwd, _getdcwd and _getcdrv for getting the
*	current working directory.  getcwd gets the c.w.d. for the default disk
*	drive, whereas _getdcwd allows one to get the c.w.d. for whatever disk
*	drive is specified. _getcdrv gets the current drive.
*
*Revision History:
*	10-29-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "getcwd.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\wrmdir.c ===
/***
*wrmdir.c - remove directory (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wrmdir() - remove a directory
*
*Revision History:
*	10-29-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "rmdir.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\wstat64.c ===
/***
*wstat64.c - get file status (wchar_t version)
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wstat64() - get file status
*
*Revision History:
*       06-02-98  GJF   Created.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE    /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE     /* NT flag */
#define UNICODE 1
#endif

#undef  _MBCS       /* UNICODE not _MBCS */

#include "stat64.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\wstati64.c ===
/***
*wstati64.c - get file status (wchar_t version)
*
*	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wstati64() - get file status
*
*Revision History:
*	12-28-94  GJF	Module created.
*
*******************************************************************************/

#define WPRFLAG     1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE    1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE     1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#define _USE_INT64  1

#include "stat.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\wunlink.c ===
/***
*wunlink.c - unlink a file (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines wunlink() - unlink a file
*
*Revision History:
*	10-29-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "unlink.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\dos\wstat.c ===
/***
*wstat.c - get file status (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wstat() - get file status
*
*Revision History:
*	10-29-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "stat.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\csysex.cpp ===
/***
*csysex.cpp - Implementation CException class for NT kernel mode
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Implementation of kernel mode default exception
*
*       Entry points:
*           CException
*
*Revision History:
*       04-21-95  DAK   Module created
*
****/

#if defined(_NTSUBSET_)

#include <csysex.hxx>

class type_info {
    public: virtual ~type_info() { }
};

type_info Dummy;

//
//  Convert system exceptions to a C++ exception.
//
extern "C" void _cdecl SystemExceptionTranslator( unsigned int uiWhat,
                                       struct _EXCEPTION_POINTERS * pexcept ) throw (...)
{
    throw CException( uiWhat ) ;
}

#endif     // _NT_SUBSET_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\ehvccctr.cpp ===
/***
*ehvccctr.cpp - EH-aware version of copy constructor iterator helper function
*
*       Copyright (c) 2000-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       These functions are called when constructing and destructing arrays of
*       objects.  Their purpose is to assure that constructed elements get
*       destructed if the constructor for one of the elements throws.
*
*       Must be compiled using "-d1Binl" to be able to specify __thiscall
*       at the user level
*
*Revision History:
*       04-27-00  JJS   File created
*
****/

#include <cruntime.h>
#include <eh.h>

#if defined (_M_IX86)
#define CALLTYPE __thiscall
#else
#define CALLTYPE __stdcall
#endif

#ifdef _WIN32

void __stdcall __ArrayUnwind(
    void*       ptr,                // Pointer to array to destruct
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pDtor)(void*)    // The destructor to call
);


void __stdcall __ehvec_copy_ctor(
    void*       dst,                // Pointer to destination array
    void*       src,                // Pointer to source array
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pCopyCtor)(void*,void*),   // Constructor to call
    void(CALLTYPE *pDtor)(void*)    // Destructor to call should exception be thrown
){
    int i;      // Count of elements constructed
    int success = 0;

    __try
    {
        // Construct the elements of the array
        for( i = 0;  i < count;  i++ )
        {
            (*pCopyCtor)( dst, src );
            dst = (char*)dst + size;
            src = (char*)src + size;
        }
        success = 1;
    }
    __finally
    {
        if (!success)
            __ArrayUnwind(dst, size, i, pDtor);
    }
}

#else

void __stdcall __ehvec_copy_ctor(
    void*       dst,                // Pointer to destination array
    void*       src,                // Pointer to source array
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pCopyCtor)(void*, void*),   // Constructor to call
    void(CALLTYPE *pDtor)(void*)    // Destructor to call should exception be thrown
){
    int i;  // Count of elements constructed

    try
    {
        // Construct the elements of the array
        for( i = 0;  i < count;  i++ )
        {
            (*pCopyCtor)( dst, src );
            dst = (char*)dst + size;
            src = (char*)src + size;
        }
    }
    catch(...)
    {
        // If a constructor throws, unwind the portion of the array thus
        // far constructed.
        for( i--;  i >= 0;  i-- )
        {
            dst = (char*)dst - size;
            try {
                (*pDtor)(dst);
            } 
            catch(...) {
                // If the destructor threw during the unwind, quit
                terminate();
            }
        }

        // Propagate the exception to surrounding frames
        throw;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\ehvecdtr.cpp ===
/***
*ehvecdtr.cxx - EH-aware version of destructor iterator helper function
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       These functions are called when constructing and destructing arrays of
*       objects.  Their purpose is to assure that constructed elements get
*       destructed if the constructor for one of the elements throws.
*       
*       Must be compiled using "-d1Binl" to be able to specify __thiscall
*       at the user level
*
*Revision History:
*       10-11-93  JDR   Module created
*       05-09-94  BES   Module adapted for CRT source conventions
*       05-13-94  SKS   Remove _CRTIMP modifier
*       10-10-94  CFW   Fix EH/SEH exception handling.
*       10-17-94  BWT   Disable code for PPC.
*       11-09-94  CFW   Back out 10-10-94 change.
*       02-08-95  JWM   Mac merge.
*       04-14-95  JWM   Re-fix EH/SEH exception handling.
*       04-17-95  JWM   Restore non-WIN32 behavior.
*       04-27-95  JWM   EH_ABORT_FRAME_UNWIND_PART now #ifdef ALLOW_UNWIND_ABORT.
*       05-17-99  PML   Remove all Macintosh support.
*       05-20-99  PML   Turn off __thiscall for IA64.
*       07-12-99  RDL   Image relative fixes under CC_P7_SOFT25.
*       03-15-00  PML   Remove CC_P7_SOFT25, which is now on permanently.
*
****/

#ifdef _WIN32
#if defined(_NTSUBSET_)
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>       // STATUS_UNHANDLED_EXCEPTION
#include <ntos.h>
#include <ex.h>             // ExRaiseException
}
#endif
#endif

#include <cruntime.h>
#include <ehdata.h>
#include <eh.h>

#if defined (_M_IX86)
#define CALLTYPE __thiscall
#else
#define CALLTYPE __stdcall
#endif

#ifdef _WIN32

void __stdcall __ArrayUnwind(
    void*       ptr,                // Pointer to array to destruct
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pDtor)(void*)    // The destructor to call
);


void __stdcall __ehvec_dtor(
    void*       ptr,                // Pointer to array to destruct
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pDtor)(void*)    // The destructor to call
){
    int success = 0;

    // Advance pointer past end of array
    ptr = (char*)ptr + size*count;

    __try
    {
        // Destruct elements
        while ( --count >= 0 )
        {
            ptr = (char*)ptr - size;
            (*pDtor)(ptr);
        }
        success = 1;
    }
    __finally
    {
        if (!success)
            __ArrayUnwind(ptr, size, count, pDtor);
    }
}

static int ArrayUnwindFilter(EXCEPTION_POINTERS* pExPtrs)
{
    EHExceptionRecord *pExcept = (EHExceptionRecord*)pExPtrs->ExceptionRecord;

    switch(PER_CODE(pExcept))
    {
        case EH_EXCEPTION_NUMBER:
            terminate();
#ifdef ALLOW_UNWIND_ABORT
        case EH_ABORT_FRAME_UNWIND_PART:
            return EXCEPTION_EXECUTE_HANDLER;
#endif
        default:
            return EXCEPTION_CONTINUE_SEARCH;
    }
}

void __stdcall __ArrayUnwind(
    void*       ptr,                // Pointer to array to destruct
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pDtor)(void*)    // The destructor to call
){
    // 'unwind' rest of array

    __try
    {
        while ( --count >= 0 )
        {
            ptr = (char*) ptr - size;
            (*pDtor)(ptr);
        }
    }
    __except( ArrayUnwindFilter(exception_info()) )
    {
    }
}

#else

void __stdcall __ehvec_dtor(
    void*       ptr,                // Pointer to array to destruct
    unsigned    size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pDtor)(void*)    // The destructor to call
){
    // Advance pointer past end of array
    ptr = (char*)ptr + size*count;

    try
    {
        // Destruct elements
        while   ( --count >= 0 )
        {
            ptr = (char*)ptr - size;
            (*pDtor)(ptr);
        }
    }
    catch(...)
    {
        // If a destructor throws an exception, unwind the rest of this
        // array
        while ( --count >= 0 )
        {
            ptr = (char*) ptr - size;
            try {
                (*pDtor)(ptr);
            }
            catch(...)  {
                // If any destructor throws during unwind, terminate
                terminate();
            }
        }

        // After array is unwound, rethrow the exception so a user's handler
        // can handle it.
        throw;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\ehvecctr.cpp ===
/***
*ehvecctr.cpp - EH-aware version of constructor iterator helper function
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       These functions are called when constructing and destructing arrays of
*       objects.  Their purpose is to assure that constructed elements get
*       destructed if the constructor for one of the elements throws.
*
*       Must be compiled using "-d1Binl" to be able to specify __thiscall
*       at the user level
*
*Revision History:
*       10-11-93  JDR   Module created
*       05-09-94  BES   Module adapted for CRT source conventions
*       05-13-94  SKS   Remove _CRTIMP modifier
*       10-10-94  CFW   Fix EH/SEH exception handling.
*       10-17-94  BWT   Disable code for PPC.
*       11-09-94  CFW   Back out 10-10-94 change.
*       02-08-95  JWM   Mac merge.
*       04-14-95  JWM   Re-fix EH/SEH exception handling.
*       04-17-95  JWM   Restore non-WIN32 behavior.
*       05-17-99  PML   Remove all Macintosh support.
*       05-20-99  PML   Turn off __thiscall for IA64.
*       07-12-99  RDL   Image relative fixes under CC_P7_SOFT25.
*       03-15-00  PML   Remove CC_P7_SOFT25, which is now on permanently.
*
****/

#include <cruntime.h>
#include <eh.h>

#if defined (_M_IX86)
#define CALLTYPE __thiscall
#else
#define CALLTYPE __stdcall
#endif

#ifdef _WIN32

void __stdcall __ArrayUnwind(
    void*       ptr,                // Pointer to array to destruct
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pDtor)(void*)    // The destructor to call
);


void __stdcall __ehvec_ctor(
    void*       ptr,                // Pointer to array to destruct
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pCtor)(void*),   // Constructor to call
    void(CALLTYPE *pDtor)(void*)    // Destructor to call should exception be thrown
){
    int i;      // Count of elements constructed
    int success = 0;

    __try
    {
        // Construct the elements of the array
        for( i = 0;  i < count;  i++ )
        {
            (*pCtor)( ptr );
            ptr = (char*)ptr + size;
        }
        success = 1;
    }
    __finally
    {
        if (!success)
            __ArrayUnwind(ptr, size, i, pDtor);
    }
}

#else

void __stdcall __ehvec_ctor(
    void*       ptr,                // Pointer to array to destruct
    unsigned    size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pCtor)(void*),   // Constructor to call
    void(CALLTYPE *pDtor)(void*)    // Destructor to call should exception be thrown
){
    int i;  // Count of elements constructed

    try
    {
        // Construct the elements of the array
        for( i = 0;  i < count;  i++ )
        {
            (*pCtor)( ptr );
            ptr = (char*)ptr + size;
        }
    }
    catch(...)
    {
        // If a constructor throws, unwind the portion of the array thus
        // far constructed.
        for( i--;  i >= 0;  i-- )
        {
            ptr = (char*)ptr - size;
            try {
                (*pDtor)(ptr);
            } 
            catch(...) {
                // If the destructor threw during the unwind, quit
                terminate();
            }
        }

        // Propagate the exception to surrounding frames
        throw;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\ehvcccvb.cpp ===
/***
*ehvcccvb.cpp - EH copy-ctor iterator helper function for class w/ virtual bases
*
*       Copyright (c) 2000-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       These functions are called when constructing and destructing arrays of
*       objects.  Their purpose is to assure that constructed elements get
*       destructed if the constructor for one of the elements throws.
*
*       Must be compiled using "-d1Binl" to be able to specify __thiscall
*       at the user level
*
*Revision History:
*       04-27-00  JJS   File created
*
****/

#include <cruntime.h>
#include <eh.h>

#if defined (_M_IX86)
#define CALLTYPE __thiscall
#else
#define CALLTYPE __stdcall
#endif

#ifdef _WIN32

void __stdcall __ArrayUnwind(
    void*       ptr,                // Pointer to array to destruct
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pDtor)(void*)    // The destructor to call
);


void __stdcall __ehvec_copy_ctor_vb(
    void*       dst,                // Pointer to destination array
    void*       src,                // Pointer to source array
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pCopyCtor)(void*,void*),   // Constructor to call
    void(CALLTYPE *pDtor)(void*)    // Destructor to call should exception be thrown
){
    int i;      // Count of elements constructed
    int success = 0;

    __try
    {
        // Construct the elements of the array
        for( i = 0;  i < count;  i++ )
        {
#pragma warning(disable:4191)

            (*(void(CALLTYPE*)(void*,void*,int))pCopyCtor)( dst, src, 1 );

#pragma warning(default:4191)

            dst = (char*)dst + size;
            src = (char*)src + size;
        }
        success = 1;
    }
    __finally
    {
        if (!success)
            __ArrayUnwind(dst, size, i, pDtor);
    }
}

#else

void __stdcall __ehvec_copy_ctor_vb(
    void*       dst,                // Pointer to destination array
    void*       src,                // Pointer to source array
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pCopyCtor)(void*, void*),   // Constructor to call
    void(CALLTYPE *pDtor)(void*)    // Destructor to call should exception be thrown
){
    int i;  // Count of elements constructed

    try
    {
        // Construct the elements of the array
        for( i = 0;  i < count;  i++ )
        {
            (*pCopyCtor)( dst, src );
            dst = (char*)dst + size;
            src = (char*)src + size;
        }
    }
    catch(...)
    {
        // If a constructor throws, unwind the portion of the array thus
        // far constructed.
        for( i--;  i >= 0;  i-- )
        {
            dst = (char*)dst - size;
            try {
#pragma warning(disable:4191)

            (*(void(CALLTYPE*)(void*,void*,int))pCopyCtor)( dst, src, 1 );

#pragma warning(default:4191)
            } 
            catch(...) {
                // If the destructor threw during the unwind, quit
                terminate();
            }
        }

        // Propagate the exception to surrounding frames
        throw;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\ehveccvb.cpp ===
/***
*ehveccvb.cpp - EH c-tor iterator helper function for class w/ virtual bases
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       EH-aware version of constructor iterator helper function for class
*       with virtual bases
*       
*       These functions are called when constructing and destructing arrays of
*       objects.  Their purpose is to assure that constructed elements get
*       destructed if the constructor for one of the elements throws.
*
*       These functions are called when constructing and destructing arrays of
*       objects.  Their purpose is to assure that constructed elements get
*       destructed if the constructor for one of the elements throws.
*       
*       Must be compiled using "-d1Binl" to be able to specify __thiscall
*       at the user level
*
*Revision History:
*       10-11-93  JDR   Module created
*       05-09-94  BES   Module adapted for CRT source conventions
*       05-13-94  SKS   Remove _CRTIMP modifier
*       10-10-94  CFW   Fix EH/SEH exception handling.
*       10-17-94  BWT   Disable code for PPC.
*       11-09-94  CFW   Back out 10-10-94 change.
*       02-08-95  JWM   Mac merge.
*       04-14-95  JWM   Re-fix EH/SEH exception handling.
*       04-17-95  JWM   Restore non-WIN32 behavior.
*       06-22-95  JWM   Remove bogus throw from __ehvec_ctor_vb()..
*       05-17-99  PML   Remove all Macintosh support.
*       05-20-99  PML   Turn off __thiscall for IA64.
*       07-12-99  RDL   Image relative fixes under CC_P7_SOFT25.
*       03-15-00  PML   Remove CC_P7_SOFT25, which is now on permanently.
*
****/

#include <cruntime.h>
#include <eh.h>

#if defined (_M_IX86)
#define CALLTYPE __thiscall
#else
#define CALLTYPE __stdcall
#endif

#ifdef _WIN32

void __stdcall __ArrayUnwind(
    void*       ptr,                // Pointer to array to destruct
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pDtor)(void*)    // The destructor to call
);


void __stdcall __ehvec_ctor_vb(
    void*       ptr,                // Pointer to array to destruct
    size_t      size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pCtor)(void*),   // Constructor to call
    void(CALLTYPE *pDtor)(void*)    // Destructor to call should exception be thrown
){
    int i;  // Count of elements constructed
    int success = 0;

    __try
    {
        // Construct the elements of the array
        for( i = 0;  i < count;  i++ )
        {

#pragma warning(disable:4191)

            (*(void(CALLTYPE*)(void*,int))pCtor)( ptr, 1 );

#pragma warning(default:4191)

            ptr = (char*)ptr + size;
        }
        success = 1;
    }
    __finally
    {
        if (!success)
            __ArrayUnwind(ptr, size, i, pDtor);
    }
}

#else

void __stdcall __ehvec_ctor_vb(
    void*       ptr,                // Pointer to array to destruct
    unsigned    size,               // Size of each element (including padding)
    int         count,              // Number of elements in the array
    void(CALLTYPE *pCtor)(void*),   // Constructor to call
    void(CALLTYPE *pDtor)(void*)    // Destructor to call should exception be thrown
){
    int i;  // Count of elements constructed

    try
    {
        // Construct the elements of the array
        for( i = 0;  i < count;  i++ )
        {
            (*(void(CALLTYPE*)(void*,int))pCtor)( ptr, 1 );
            ptr = (char*)ptr + size;
        }
    }
    catch(...)
    {
        // If a constructor throws, unwind the portion of the array thus
        // far constructed.
        for( i--;  i >= 0;  i-- )
        {
            ptr = (char*)ptr - size;
            try {
                (*pDtor)(ptr);
            } 
            catch(...) {
                // If the destructor threw during the unwind, quit
                terminate();
            }
        }

        // Propagate the exception to surrounding frames
        throw;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\hooks.cpp ===
/***
*hooks.cxx - global (per-thread) variables and functions for EH callbacks
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       global (per-thread) variables for assorted callbacks, and
*       the functions that do those callbacks.
*
*       Entry Points:
*
*       * terminate()
*       * unexpected()
*       * _inconsistency()
*
*       External Names: (only for single-threaded version)
*
*       * __pSETranslator
*       * __pTerminate
*       * __pUnexpected
*       * __pInconsistency
*
*Revision History:
*       05-25-93  BS    Module created
*       10-17-94  BWT   Disable code for PPC.
*       02-08-95  JWM   Mac merge.
*       04-13-95  DAK   Add Kernel EH support
*       05-17-99  PML   Remove all Macintosh support.
*       10-22-99  PML   Add EHTRACE support
*       06-20-00  PML   Get rid of unnecessary __try/__finallys.
*
****/

#include <stddef.h>
#include <stdlib.h>
#include <excpt.h>

# if defined(_NTSUBSET_) || defined(_XBOX)

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>       // STATUS_UNHANDLED_EXCEPTION
#include <ntos.h>
}

# endif /* _NTSUBSET_ */

#include <windows.h>
#include <mtdll.h>
#include <eh.h>
#include <ehhooks.h>
#include <ehassert.h>
#ifdef _XBOX
#include <xdbg.h>
#endif

#pragma hdrstop

/////////////////////////////////////////////////////////////////////////////
//
// The global variables:
//

#ifndef _MT
_se_translator_function __pSETranslator = NULL;
terminate_function      __pTerminate    = NULL;
unexpected_function     __pUnexpected   = &terminate;
#endif // !_MT

_inconsistency_function __pInconsistency= &terminate;

/////////////////////////////////////////////////////////////////////////////
//
// terminate - call the terminate handler (presumably we went south).
//              THIS MUST NEVER RETURN!
//
// Open issues:
//      * How do we guarantee that the whole process has stopped, and not just
//        the current thread?
//

_CRTIMP void __cdecl terminate(void)
{
        EHTRACE_ENTER_MSG("No exit");

        //
        // Let the user wrap things up their way.
        //
        if ( __pTerminate ) {
            __try {
                __pTerminate();
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                //
                // Intercept ANY exception from the terminate handler
                //
            }
        }

        //
        // If the terminate handler returned, faulted, or otherwise failed to
        // halt the process/thread, we'll do it.
        //
#ifdef _XBOX
        RIP("Unhandled CRT exception");
#endif
# if defined(_NTSUBSET_) || defined(_XBOX)
        KeBugCheck( (ULONG) STATUS_UNHANDLED_EXCEPTION );
# else
        abort();
# endif
}

/////////////////////////////////////////////////////////////////////////////
//
// unexpected - call the unexpected handler (presumably we went south, or nearly).
//              THIS MUST NEVER RETURN!
//
// Open issues:
//      * How do we guarantee that the whole process has stopped, and not just
//        the current thread?
//

void __cdecl unexpected(void)
{
        EHTRACE_ENTER;

        //
        // Let the user wrap things up their way.
        //
        if ( __pUnexpected )
            __pUnexpected();

        //
        // If the unexpected handler returned, we'll give the terminate handler a chance.
        //
        terminate();
}

/////////////////////////////////////////////////////////////////////////////
//
// _inconsistency - call the inconsistency handler (Run-time processing error!)
//                THIS MUST NEVER RETURN!
//
// Open issues:
//      * How do we guarantee that the whole process has stopped, and not just
//        the current thread?
//

void __cdecl _inconsistency(void)
{
        EHTRACE_ENTER;

        //
        // Let the user wrap things up their way.
        //
        if ( __pInconsistency )
            __try {
                __pInconsistency();
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                //
                // Intercept ANY exception from the terminate handler
                //
            }

        //
        // If the inconsistency handler returned, faulted, or otherwise
        // failed to halt the process/thread, we'll do it.
        //
        terminate();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\oldexcpt.cpp ===
/***
*oldexcpt.cpp - defines C++ standard exception classes
*
*       Copyright (c) 1994-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Implementation of C++ standard exception classes, as specified in
*       [lib.header.exception] (section 17.3.2 of 5/27/94 WP):
*
*        exception (formerly xmsg)
*          logic
*            domain
*          runtime
*            range
*            alloc
*
*Revision History:
*       04-27-94  BES   Module created.
*       10-17-94  BWT   Disable code for PPC.
*       02-15-95  JWM   Minor cleanups related to Olympus bug 3716
*       07-02-95  JWM   Now generally ANSI-compliant; excess baggage removed.
*       01-05-99  GJF   Changes for 64-bit size_t.
*
*******************************************************************************/

#include <stdlib.h>
#include <string.h>
#include <eh.h>
#include "./oldexcpt.h"

////////////////////////////////////////////////////////////////////////////////
//
// Implementation of class "exception"
//

//
// Default constructor - initialize to blank
//
exception::exception ()
{
        _m_what = NULL;
        _m_doFree = 0;
}

//
// Standard constructor: initialize with copy of string
//
exception::exception ( const __exString& what )
{
        _m_what = new char[(unsigned int)strlen(what)+1];
        if ( _m_what != NULL )
            strcpy( (char*)_m_what, what );
        _m_doFree = 1;
}

//
// Copy constructor
//
exception::exception ( const exception & that )
{
        _m_doFree = that._m_doFree;
        if (_m_doFree)
        {
            _m_what = new char[(unsigned int)strlen(that._m_what) + 1];
            if (_m_what != NULL)
                strcpy( (char*)_m_what, that._m_what );
        }
        else
           _m_what = that._m_what;
}

//
// Assignment operator: destruct, then copy-construct
//
exception& exception::operator=( const exception& that )
{
        if (this != &that)
        {
            this->exception::~exception();
            this->exception::exception(that);
        }
        return *this;
}

//
// Destructor: free the storage used by the message string if it was
// dynamicly allocated
//
exception::~exception()
{
        if (_m_doFree)
            delete[] (char*)_m_what;
}


//
// exception::what
//  Returns the message string of the exception.
//  Default implementation of this method returns the stored string if there
//  is one, otherwise returns a standard string.
//
__exString exception::what() const
{
        if ( _m_what != NULL )
            return _m_what;
        else
            return "Unknown exception";
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\frame.cpp ===
/***
*frame.cxx - The frame handler and everything associated with it.
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       The frame handler and everything associated with it.
*
*       Entry points:
*       _CxxFrameHandler   - the frame handler.
*
*       Open issues:
*         Handling re-throw from dynamicly nested scope.
*         Fault-tolerance (checking for data structure validity).
*
*Revision History:
*       05-20-93  BS    Module created
*       03-03-94  TL    Added Mips specific code
*       06-19-94  AD    Added Alpha specific code (Al Dosser)
*       10-17-94  BWT   Disable code for PPC.
*       11-23-94  JWM   Removed obsolete 'hash' check in TypeMatch().
*       11-29-94  JWM   AdjustPointer() now adds in pdisp, not vdisp.
*       01-13-95  JWM   Added _NLG_Destination struct; dwCode set for catch
*                       blocks & local destructors.
*       02-09-95  JWM   Mac merge.
*       02-10-95  JWM   UnhandledExceptionFilter() now called if exception
*                       raised during stack unwind.
*       03-22-95  PML   Add const for read-only compiler-gen'd structs
*       04-14-95  JWM   Re-fix EH/SEH exception handling.
*       04-17-95  JWM   FrameUnwindFilter() must be #ifdef _WIN32.
*       04-21-95  JWM   _NLG_Destination moved to exsup3.asm (_M_X86 only).
*       04-21-95  TGL   Added Mips fixes.
*       04-27-95  JWM   EH_ABORT_FRAME_UNWIND_PART now #ifdef 
*                       ALLOW_UNWIND_ABORT.
*       05-19-95  DAK   Don't initialize the kernel handler
*       06-07-95  JWM   Various NLG additions.
*       06-14-95  JWM   Unneeded LastError calls removed.
*       06-19-95  JWM   NLG no longer uses per-thread data (X86 only).
*       09-26-95  AMP   PowerMac avoids re-throws to same catch clause
*       08-06-95  JWM   Typo fixed (Orion #6509); Alpha-specific.
*       04-18-97  JWM   In __InternalCxxFrameHandler(), 'recursive' changed to
*                       BOOLEAN.
*       06-01-97  TGL   Added P7 specific code
*       08-22-97  TGL   More P7 fixes
*       11-14-98  JWM   Merge with P7 sources.
*       02-11-99  TGL   EH: correct catch in exe calling dll.
*       05-17-99  PML   Remove all Macintosh support.
*       07-12-99  RDL   Image relative fixes under CC_P7_SOFT25.
*       10-17-99  PML   Update EH state before each unwind action, instead of
*                       once at end (vs7#5419)
*       10-19-99  TGL   More P7/Win64 fixes
*       10-22-99  PML   Add EHTRACE support
*       12-10-99  GB    Add Uncaught exception Support by adding a new function
*                       __uncaught_exception();
*       02-15-99  PML   Can't put __try/__finally around call to
*                       _UnwindNestedFrames (vs7#79460)
*       03-03-00  GB    made __DestructExceptionObject export from dll.
*       03-21-00  KBF   Check for C++ exception in __CxxExceptionFilter
*       03-22-00  PML   Remove CC_P7_SOFT25, which is now on permanently.
*       03-28-00  GB    Check for no buildobj in __CxxExceptionFilter.
*       04-06-00  GB    Added more functions for com+ eh support.
*       04-19-00  GB    ComPlus EH bug fixes.
*       05-23-00  GB    Don't catch BreakPoint generated Exceptions.
*       05-30-00  GB    ComPlus EH bug fixes.
*       06-08-00  RDL   VS#111429: IA64 workaround for AV while handling throw.
*       06-21-00  GB    Fix the difference in order of destruction and
*                       construction depending on inlining.
*       07-26-00  GB    Fixed multiple destruction problem in COM+ eh.
*       08-23-00  GB    Fixed problem in BuildCatchObject when called from 
*                       __CxxExceptionFilter.
*       02-23-01  PML   Add __CxxCallUnwindDtor COM+ wrapper (vs7#217108)
*       04-09-01  GB    Add uncaught_exception support for COM+ C++ App.
*       04-13-01  GB    Fixed problems with Seh and catch(...). (vc7#236286)
*
****/

#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>

#if defined(_NTSUBSET_)
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>   // STATUS_UNHANDLED_EXCEPTION
#include <ntos.h>
#include <ex.h>         // ExRaiseException
}
#endif // defined(_NTSUBSET_)

#include <windows.h>
#include <internal.h>
#include <mtdll.h>      // CRT internal header file
#include <ehassert.h>   // This project's versions of standard assert macros
#include <ehdata.h>     // Declarations of all types used for EH
#include <ehstate.h>    // Declarations of state management stuff
#include <eh.h>         // User-visible routines for eh
#include <ehhooks.h>    // Declarations of hook variables and callbacks
#include <trnsctrl.h>   // Routines to handle transfer of control (trnsctrl.asm)
#if defined(_M_IA64) /*IFSTRIP=IGN*/
#include <kxia64.h>
#include <ia64inst.h>
#endif

#pragma hdrstop         // PCH is created from here

////////////////////////////////////////////////////////////////////////////////
//
// Intel x86-specific definitions
//
#if defined(_M_IX86)
#define __GetRangeOfTrysToCheck(a, b, c, d, e, f, g) \
                                _GetRangeOfTrysToCheck(b, c, d, e, f)
#define __FrameUnwindToEmptyState(a, b, c) \
                                __FrameUnwindToState(a, b, c, EH_EMPTY_STATE);
#define __CallSETranslator(a, b, c, d, e, f, g, h) \
                                _CallSETranslator(a, b, c, d, e, f, g)
#define __GetUnwindState(a, b, c) \
                                GetCurrentState(a, b, c)
#define __OffsetToAddress(a, b, c) \
                                OffsetToAddress(a, b)
#define __GetAddress(a, b) \
                                (a)
#define REAL_FP(a, b) \
                                (a)
#define __ResetException(a)

////////////////////////////////////////////////////////////////////////////////
//
// MIPS-specific definitions
//
#elif defined(_M_MRX000)
#define __GetRangeOfTrysToCheck(a, b, c, d, e, f, g) \
                                _GetRangeOfTrysToCheck(a, b, c, d, e, f)
#define __FrameUnwindToEmptyState(a, b, c) \
                                __FrameUnwindToState(a, b, c, EH_EMPTY_STATE);
#define __CallSETranslator(a, b, c, d, e, f, g, h) \
                                _CallSETranslator(a, b, c, d, e, f, g, h)
#define __GetUnwindState(a, b, c) \
                                GetCurrentState(a, b, c)
#define __OffsetToAddress(a, b, c) \
                                _OffsetToAddress(a, b, c)
#define __GetAddress(a, b) \
                                (a)
#define REAL_FP(a, b) \
                                (a)
#define SetState(a, b, c, d)
#define __ResetException(a)
#define VER41_C2(p)             (HT_ADJECTIVES(TBME_CATCH(FUNC_TRYBLOCK(*p, 0), 0)) & 0x20)

#ifdef _MT
#define pExitContext            (*((CONTEXT **)&(_getptd()->_pExitContext)))
#else
static CONTEXT                  *pExitContext = NULL;   // context to assist the return to the continuation point
#endif  // _MT

////////////////////////////////////////////////////////////////////////////////
//
// P7 specific definitions
//
#elif defined(_M_IA64) /*IFSTRIP=IGN*/
#define __GetRangeOfTrysToCheck(a, b, c, d, e, f, g) \
                                _GetRangeOfTrysToCheck(a, b, c, d, e, f, g)
#define __CallSETranslator(a, b, c, d, e, f, g, h) \
                                _CallSETranslator(a, b, c, d, e, f, g)
#define __GetUnwindState(a, b, c) \
                                GetCurrentState(a, b, c)
#define __OffsetToAddress(a, b, c) \
                                OffsetToAddress(a, b)
#define __GetAddress(a, b) \
                                (void*)(a)
#define REAL_FP(a, b) \
                                (a)
#define __ResetException(a)
#ifdef _MT
#define pExitContext            (*((CONTEXT **)&(_getptd()->_pExitContext)))
#else
static CONTEXT                  *pExitContext = NULL;   // context to assist the return to the continuation point
#endif  // _MT

// The throw site
#undef CT_PTD
#define CT_PTD(ct)              (CT_PTD_IB(ct, _GetThrowImageBase()))
#undef CT_COPYFUNC
#define CT_COPYFUNC(ct)         ((ct).copyFunction? CT_COPYFUNC_IB(ct, _GetThrowImageBase()):NULL)

#undef THROW_FORWARDCOMPAT 
#define THROW_FORWARDCOMPAT(ti) ((ti).pForwardCompat? THROW_FORWARDCOMPAT_IB(ti, _GetThrowImageBase()):NULL) 
#undef THROW_COUNT
#define THROW_COUNT(ti)         THROW_COUNT_IB(ti, _GetThrowImageBase())
#undef THROW_CTLIST
#define THROW_CTLIST(ti)        THROW_CTLIST_IB(ti, _GetThrowImageBase())

// The catch site
#undef HT_HANDLER
#define HT_HANDLER(ht)          (HT_HANDLER_IB(ht, _GetImageBase()))
#undef UWE_ACTION
#define UWE_ACTION(uwe)         ((uwe).action? UWE_ACTION_IB(uwe, _GetImageBase()):NULL)

#undef FUNC_UNWIND
#define FUNC_UNWIND(fi,st)      (FUNC_PUNWINDMAP(fi,_GetImageBase())[st])
#undef TBME_CATCH
#define TBME_CATCH(hm,n)        (TBME_PLIST(hm,_GetImageBase())[n])
#undef TBME_PCATCH
#define TBME_PCATCH(hm,n)       (&(TBME_PLIST(hm,_GetImageBase())[n]))
#undef HT_PTD
#define HT_PTD(ht)              ((TypeDescriptor*)((ht).dispType? HT_PTD_IB(ht,_GetImageBase()):NULL))

#undef abnormal_termination
#define abnormal_termination()  FALSE

////////////////////////////////////////////////////////////////////////////////
//
// DEC Alpha-specific definitions
//
#elif defined(_M_ALPHA)
#define __GetRangeOfTrysToCheck(a, b, c, d, e, f, g) \
                                _GetRangeOfTrysToCheck(b, c, d, e, f)
#define __FrameUnwindToEmptyState(a, b, c) \
                                __FrameUnwindToState(a, b, c, EH_EMPTY_STATE);
#define __CallSETranslator(a, b, c, d, e, f, g, h) \
                                _CallSETranslator(a, b, c, d, e, f, g)
#define __GetUnwindState(a, b, c) \
                                GetCurrentState(a, b, c)
#define __OffsetToAddress(a, b, c) \
                                OffsetToAddress(a, b)
#define __GetAddress(a, b) \
                                (a)
#define __ResetException(a)

////////////////////////////////////////////////////////////////////////////////
//
// PowerPC for Windows/NT-specific definitions
//
#elif defined(_M_PPC)
#define _POWERPC
#define __GetRangeOfTrysToCheck(a, b, c, d, e, f, g) \
                                _GetRangeOfTrysToCheck(b, c, d, e, f)
#define _MoveContext(a, b)  \
                                RtlMoveMemory(a, b, sizeof(CONTEXT));
#define __CallSETranslator(a, b, c, d, e, f, g, h) \
                                _CallSETranslator(a, b, c, d, e, f, g)
#define __GetUnwindState(a, b, c) \
                                GetUnwindState(a, b, c)
#define __OffsetToAddress(a, b, c) \
                                OffsetToAddress(a, b)
#define __GetAddress(a, b) \
                                (a)
#define REAL_FP(a, b) \
                                (a)
#define __ResetException(a)
extern "C" CONTEXT *            _GetUnwindContext(VOID);
#ifdef _MT
#define pExitContext            (*((CONTEXT **)&(_getptd()->_pExitContext)))
#else
static CONTEXT                  *pExitContext = NULL;   // context to assist the return to the continuation point
#endif  // _MT

////////////////////////////////////////////////////////////////////////////////
//
// Unknown platform
//
#else
#error Unrecognized platform
#endif

extern "C" {
typedef struct {
    unsigned long dwSig;
    unsigned long uoffDestination;
    unsigned long dwCode;
    unsigned long uoffFramePointer;
} _NLG_INFO;

extern _NLG_INFO _NLG_Destination;
}

////////////////////////////////////////////////////////////////////////////////
//
// Forward declaration of local functions:
//

// M00TODO: all these parameters should be declared const

// The local unwinder must be external (see __CxxLongjmpUnwind in trnsctrl.cpp)

extern "C" void __FrameUnwindToState(
    EHRegistrationNode *,
    DispatcherContext *,
    FuncInfo *,
    __ehstate_t
);

static void FindHandler(
    EHExceptionRecord *,
    EHRegistrationNode *,
    CONTEXT *,
    DispatcherContext *,
    FuncInfo *,
    BOOLEAN,
    int,
    EHRegistrationNode*
);

static void CatchIt(
    EHExceptionRecord *,
    EHRegistrationNode *,
    CONTEXT *,
    DispatcherContext *,
    FuncInfo *,
    HandlerType *,
    CatchableType *,
    TryBlockMapEntry *,
    int,
    EHRegistrationNode *,
    BOOLEAN
);

static void * CallCatchBlock(
    EHExceptionRecord *,
    EHRegistrationNode *,
    CONTEXT *,
    FuncInfo *,
    void *,
    int,
    unsigned long
#if defined(_M_IA64)
    ,FRAMEINFO *
#endif
);

static void BuildCatchObject(
    EHExceptionRecord *,
    void *,
    HandlerType *,
    CatchableType *
);

static __inline int TypeMatch(
    HandlerType *,
    CatchableType *,
    ThrowInfo *
);

static void * AdjustPointer(
    void *,
    const PMD&
);

static void FindHandlerForForeignException(
    EHExceptionRecord *,
    EHRegistrationNode *, CONTEXT *,
    DispatcherContext *,
    FuncInfo *,
    __ehstate_t,
    int,
    EHRegistrationNode *
);

static int FrameUnwindFilter(
    EXCEPTION_POINTERS *
);

static int ExFilterRethrow(
    EXCEPTION_POINTERS *
);

extern "C" void _CRTIMP __DestructExceptionObject(
    EHExceptionRecord *,
    BOOLEAN
);


//
// Make sure the terminate wrapper is dragged in:
//
static void *pMyUnhandledExceptionFilter =
#if defined(_NTSUBSET_)
        0;
#else
        &__CxxUnhandledExceptionFilter;
#endif

//
// This describes the most recently handled exception, in case of a rethrow:
//
#ifdef _MT
#define _pCurrentException      (*((EHExceptionRecord **)&(_getptd()->_curexception)))
#define _pCurrentExContext      (*((CONTEXT **)&(_getptd()->_curcontext)))
#define __ProcessingThrow       _getptd()->_ProcessingThrow
#else
EHExceptionRecord               *_pCurrentException = NULL;
CONTEXT                         *_pCurrentExContext = NULL;
int __ProcessingThrow = 0;
#endif


////////////////////////////////////////////////////////////////////////////////
//
// __InternalCxxFrameHandler - the frame handler for all functions with C++ EH
// information.
//
// If exception is handled, this doesn't return; otherwise, it returns
// ExceptionContinueSearch.
//
// Note that this is called three ways:
//     From __CxxFrameHandler: primary usage, called to inspect whole function.
//         CatchDepth == 0, pMarkerRN == NULL
//     From CatchGuardHandler: If an exception occurred within a catch, this is
//         called to check for try blocks within that catch only, and does not
//         handle unwinds.
//     From TranslatorGuardHandler: Called to handle the translation of a
//         non-C++ EH exception.  Context considered is that of parent.

extern "C" EXCEPTION_DISPOSITION __cdecl __InternalCxxFrameHandler(
    EHExceptionRecord  *pExcept,        // Information for this exception
    EHRegistrationNode *pRN,            // Dynamic information for this frame
    CONTEXT *pContext,                  // Context info
    DispatcherContext *pDC,             // Context within subject frame
    FuncInfo *pFuncInfo,                // Static information for this frame
    int CatchDepth,                     // How deeply nested are we?
    EHRegistrationNode *pMarkerRN,      // Marker node for when checking inside
                                        //  catch block
    BOOLEAN recursive                   // Are we handling a translation?
) {
    EHTRACE_ENTER_FMT2("%s, pRN = 0x%p",
                       IS_UNWINDING(PER_FLAGS(pExcept)) ? "Unwinding" : "Searching",
                       pRN);

#if defined(_M_ALPHA)
    // On Alpha - these values synthesized from DispatcherContext

    pFuncInfo = (FuncInfo *)(pDC ->FunctionEntry->HandlerData);
    pRN = (EHRegistrationNode *)VIRTUAL_FP(pDC);
#endif // defined(_M_ALPHA)

    DASSERT(FUNC_MAGICNUM(*pFuncInfo) == EH_MAGIC_NUMBER1);

#if defined(_M_ALPHA)
    // A special case to support gotos out of nested catch handlers
    // and setjmp/longjmp.
    //
    // See __CxxEHGoto in alpha\trnsctrl.cxx for details.
    //
    if (IS_TARGET_UNWIND(PER_FLAGS(pExcept))) {
        if (PER_CODE(pExcept) == STATUS_UNWIND && PER_NPARAMS(pExcept) == 1) {
            __ehstate_t target_state =
              (__ehstate_t)((PEXCEPTION_RECORD)(pExcept))->ExceptionInformation[0];

            DASSERT(target_state >= EH_EMPTY_STATE
              && target_state < FUNC_MAXSTATE(*pFuncInfo));

            __FrameUnwindToState(pRN, pDC, pFuncInfo, target_state);
            EHTRACE_HANDLER_EXIT(ExceptionContinueSearch);
            return ExceptionContinueSearch;
        } else {
            EHTRACE_HANDLER_EXIT(ExceptionContinueSearch);
            return ExceptionContinueSearch;
        }
    }
#endif // defined(_M_ALPHA)

    if (IS_UNWINDING(PER_FLAGS(pExcept)))
    {
        // We're at the unwinding stage of things.  Don't care about the
        // exception itself.  (Check this first because it's easier)

#if defined(_POWERPC)
        if (FUNC_MAXSTATE(*pFuncInfo) != 0)
#else
        if (FUNC_MAXSTATE(*pFuncInfo) != 0 && CatchDepth == 0)
#endif
        {
            // Only unwind if there's something to unwind
            // AND we're being called through the primary RN.

#if defined(_M_MRX000) || defined(_POWERPC) || defined(_M_IA64) /*IFSTRIP=IGN*/
            // If we are exiting to the continuation point, we don't want to
            // use the unwind map again. Unwinding continues until the
            // dispatcher finds the target frame, at which point the dispatcher
            // will jump to the continuation point
            //
            // Don't unwind the target frame if the unwind was initiated by
            // UnwindNestedFrames

            if (_GetUnwindContext() != NULL
              && IS_TARGET_UNWIND(PER_FLAGS(pExcept))) {

#if defined (_POWERPC)
                // Virtually unwind the target frame to recover the value of r2.
                // We must take care to not unwind a glue sequence that may have
                // been used to reach the target frame.  This is done by giving
                // stack limit values that will regard any stack pointer as bad.

                CONTEXT TocContext;
                PRUNTIME_FUNCTION FunctionEntry;
                BOOLEAN InFunction;
                ULONG EstablisherFrame;

                _MoveContext(&TocContext, pContext);
                FunctionEntry = RtlLookupFunctionEntry(pDC->ControlPc);
                RtlVirtualUnwind(pDC->ControlPc, FunctionEntry, &TocContext,
                  &InFunction, &EstablisherFrame, NULL, 0xffffffff, 0);
                pContext->Gpr2 = TocContext.Gpr2;
#endif // defined (_POWERPC)

                // Save the target context to be used in 'CatchIt' to jump to
                // the continuation point.
                DASSERT(pExitContext != NULL);
                _MoveContext(pExitContext, pContext);

                // This is how we give control back to _UnwindNestedFrames
                _MoveContext(pContext, _GetUnwindContext());

                EHTRACE_HANDLER_EXIT(ExceptionContinueSearch);
                return ExceptionContinueSearch;
            }
#endif // defined(_M_MRX000) || defined(_POWERPC) || defined(_M_IA64)

#if defined(_M_IA64)
            else if (IS_TARGET_UNWIND(PER_FLAGS(pExcept)) && PER_CODE(pExcept) == STATUS_LONGJUMP) {
                    __ehstate_t target_state = _StateFromIp(pFuncInfo, pDC, pContext->StIIP);

                    DASSERT(target_state >= EH_EMPTY_STATE
                            && target_state < FUNC_MAXSTATE(*pFuncInfo));

                    __FrameUnwindToState(pRN, pDC, pFuncInfo, target_state);
                    EHTRACE_HANDLER_EXIT(ExceptionContinueSearch);
                    return ExceptionContinueSearch;
            }
#endif // defined(_M_IA64)
            __FrameUnwindToEmptyState(pRN, pDC, pFuncInfo);
        }

        EHTRACE_HANDLER_EXIT(ExceptionContinueSearch);
        return ExceptionContinueSearch;     // I don't think this value matters

    } else if (FUNC_NTRYBLOCKS(*pFuncInfo) != 0) {

        // NT is looking for handlers.  We've got handlers.
        // Let's check this puppy out.  Do we recognize it?

        int (__cdecl *pfn)(...);
          

        if (PER_CODE(pExcept) == EH_EXCEPTION_NUMBER
          && PER_MAGICNUM(pExcept) > EH_MAGIC_NUMBER1
          && (pfn = THROW_FORWARDCOMPAT(*PER_PTHROW(pExcept))) != NULL) {

            // Forward compatibility:  The thrown object appears to have been
            // created by a newer version of our compiler.  Let that version's
            // frame handler do the work (if one was specified).

#if defined(DEBUG)
            if (_ValidateExecute((FARPROC)pfn)) {
#endif
                EXCEPTION_DISPOSITION result =
                    (EXCEPTION_DISPOSITION)pfn(pExcept, pRN, pContext, pDC,
                                               pFuncInfo, CatchDepth,
                                               pMarkerRN, recursive);
                EHTRACE_HANDLER_EXIT(result);
                return result;
#if defined(DEBUG)
            } else {
                _inconsistency(); // Does not return; TKB
            }
#endif

        } else {

            // Anything else: we'll handle it here.
            FindHandler(pExcept, pRN, pContext, pDC, pFuncInfo, recursive,
              CatchDepth, pMarkerRN);
        }

        // If it returned, we didn't have any matches.

        } // NT was looking for a handler

    // We had nothing to do with it or it was rethrown.  Keep searching.
    EHTRACE_HANDLER_EXIT(ExceptionContinueSearch);
    return ExceptionContinueSearch;

} // InternalCxxFrameHandler


////////////////////////////////////////////////////////////////////////////////
//
// FindHandler - find a matching handler on this frame, using all means
// available.
//
// Description:
//     If the exception thrown was an MSC++ EH, search handlers for match.
//     Otherwise, if we haven't already recursed, try to translate.
//     If we have recursed (ie we're handling the translator's exception), and
//         it isn't a typed exception, call _inconsistency.
//
// Returns:
//      Returns iff exception was not handled.
//
// Assumptions:
//      Only called if there are handlers in this function.

static void FindHandler(
    EHExceptionRecord *pExcept,         // Information for this (logical)
                                        //   exception
    EHRegistrationNode *pRN,            // Dynamic information for subject frame
    CONTEXT *pContext,                  // Context info
    DispatcherContext *pDC,             // Context within subject frame
    FuncInfo *pFuncInfo,                // Static information for subject frame
    BOOLEAN recursive,                  // TRUE if we're handling the
                                        //   translation
    int CatchDepth,                     // Level of nested catch that is being
                                        //   checked
    EHRegistrationNode *pMarkerRN       // Extra marker RN for nested catch 
                                        //   handling
)
{
    EHTRACE_ENTER;

    BOOLEAN IsRethrow = FALSE;

    // Get the current state (machine-dependent)
#if defined(_M_IA64) /*IFSTRIP=IGN*/
    __ehstate_t curState = _StateFromControlPc(pFuncInfo, pDC);
#else
    __ehstate_t curState = GetCurrentState(pRN, pDC, pFuncInfo);
#endif
    DASSERT(curState >= EH_EMPTY_STATE && curState < FUNC_MAXSTATE(*pFuncInfo));

    // Check if it's a re-throw.  Use the exception we stashed away if it is.
    if (PER_IS_MSVC_EH(pExcept) && PER_PTHROW(pExcept) == NULL) {

        if (_pCurrentException == NULL) {
            // Oops!  User re-threw a non-existant exception!  Let it propogate.
            EHTRACE_EXIT;
            return;
        }

        pExcept = _pCurrentException;
        pContext = _pCurrentExContext;
        IsRethrow = TRUE;

        DASSERT(_ValidateRead(pExcept));
        DASSERT(!PER_IS_MSVC_EH(pExcept) || PER_PTHROW(pExcept) != NULL);
    }

    if (PER_IS_MSVC_EH(pExcept)) {
        // Looks like it's ours.  Let's see if we have a match:
        //
        // First, determine range of try blocks to consider:
        // Only try blocks which are at the current catch depth are of interest.

        unsigned curTry;
        unsigned end;

#if defined(_M_MRX000)
        DASSERT(VER41_C2(pFuncInfo));
#endif
        TryBlockMapEntry *pEntry = __GetRangeOfTrysToCheck(pRN, pFuncInfo,
          CatchDepth, curState, &curTry, &end, pDC);

        // Scan the try blocks in the function:
        for (; curTry < end; curTry++, pEntry++) {
            HandlerType *pCatch;
#if defined(_M_IA64)
            __int32 const *ppCatchable;
#elif defined(_WIN64)
            CatchableType * UNALIGNED const *ppCatchable;
#else
            CatchableType * const *ppCatchable;
#endif
            CatchableType *pCatchable;
            int catches;
            int catchables;

            if (TBME_LOW(*pEntry) > curState || curState > TBME_HIGH(*pEntry)) {
                continue;
            }

            // Try block was in scope for current state.  Scan catches for this
            // try:
            pCatch  = TBME_PCATCH(*pEntry, 0);
            for (catches = TBME_NCATCHES(*pEntry); catches > 0; catches--,
              pCatch++) {

                // Scan all types that thrown object can be converted to:
                ppCatchable = THROW_CTLIST(*PER_PTHROW(pExcept));
                for (catchables = THROW_COUNT(*PER_PTHROW(pExcept));
                  catchables > 0; catchables--, ppCatchable++) {

#if defined(_M_IA64)
                    pCatchable = (CatchableType *)(_GetThrowImageBase() + *ppCatchable);
#else
                    pCatchable = *ppCatchable;
#endif

                    if (!TypeMatch(pCatch, pCatchable, PER_PTHROW(pExcept))) {
                        continue;
                    }

                    // OK.  We finally found a match.  Activate the catch.  If
                    // control gets back here, the catch did a re-throw, so
                    // keep searching.

#if defined(_M_MRX000)
                    PVOID pRealFrame = _OffsetToAddress(0, pRN, FUNC_FRAMENEST(*pFuncInfo));
                    UNWINDHELP(pRealFrame, FUNC_DISPUNWINDHELP(*pFuncInfo),0) = curTry;
#elif defined(_M_IA64) /*IFSTRIP=IGN*/
                    SetUnwindTryBlock(pRN, pDC, pFuncInfo, /*curTry*/ curState);
#endif // defined(_M_MRX000)


                    CatchIt(pExcept, pRN, pContext, pDC, pFuncInfo, pCatch,
                      pCatchable, pEntry, CatchDepth, pMarkerRN, IsRethrow);
#if defined(_M_IA64) /*IFSTRIP=IGN*/
                    goto EndOfTryScan;
#else
                    goto NextTryBlock;
#endif

                } // Scan posible conversions
            } // Scan catch clauses
#if !defined(_M_IA64) /*IFSTRIP=IGN*/
NextTryBlock: ;
#endif
#if defined(_M_IA64) /*IFSTRIP=IGN*/
//            if( GetUnwindTryBlock(pRN, pDC, pFuncInfo) >= 0 )
//                curTry = GetUnwindTryBlock(pRN, pDC, pFuncInfo);
#endif
        } // Scan try blocks

#if defined(_M_IA64) /*IFSTRIP=IGN*/
EndOfTryScan:
#endif
        if (recursive) {
            // A translation was provided, but this frame didn't catch it.
            // Destruct the translated object before returning; if destruction
            // raises an exception, issue _inconsistency.
            __DestructExceptionObject(pExcept, TRUE);
        }

    } // It was a C++ EH exception
    else {
        // Not ours.  But maybe someone told us how to make it ours.
        if (!recursive) {
            FindHandlerForForeignException(pExcept, pRN, pContext, pDC,
              pFuncInfo, curState, CatchDepth, pMarkerRN);
        } else {
            // We're recursive, and the exception wasn't a C++ EH!
            // Translator threw something uninteligable.  We're outa here!

            // M00REVIEW: Two choices here actually: we could let the new
            // exception take over.

            terminate();
        }
    } // It wasn't our exception

    EHTRACE_EXIT;
}


////////////////////////////////////////////////////////////////////////////////
//
// FindHandlerForForeignException - We've got an exception which wasn't ours.
//     Try to translate it into C++ EH, and also check for match with ellipsis.
//
// Description:
//     If an SE-to-EH translator has been installed, call it.  The translator
//     must throw the appropriate typed exception or return.  If the translator
//     throws, we invoke FindHandler again as the exception filter.
//
// Returns:
//     Returns if exception was not fully handled.
//     No return value.
//
// Assumptions:
//     Only called if there are handlers in this function.

static void FindHandlerForForeignException(
    EHExceptionRecord *pExcept,         // Information for this (logical)
                                        //   exception
    EHRegistrationNode *pRN,            // Dynamic information for subject frame
    CONTEXT *pContext,                  // Context info
    DispatcherContext *pDC,             // Context within subject frame
    FuncInfo *pFuncInfo,                // Static information for subject frame
    __ehstate_t curState,               // Current state
    int CatchDepth,                     // Level of nested catch that is being
                                        //   checked
    EHRegistrationNode *pMarkerRN       // Extra marker RN for nested catch
                                        //   handling
)
{
    EHTRACE_ENTER;

    unsigned curTry;
    unsigned end;
    TryBlockMapEntry *pEntry;
    // We don't want to touch BreakPoint generated Exception.
    if (PER_CODE(pExcept) == STATUS_BREAKPOINT) {
        EHTRACE_EXIT;
        return;
    }

    if (__pSETranslator != NULL) {

        // Call the translator.  If the translator knows what to
        // make of it, it will throw an appropriate C++ exception.
        // We intercept it and use it (recursively) for this
        // frame.  Don't recurse more than once.

#if defined(_M_MRX000)
        ULONG TDTransOffset = 0;

#ifdef _MT
        struct _tiddata DummyStruct;
        TDTransOffset = (char*)&DummyStruct._translator - (char*)&DummyStruct;
#endif
#endif // defined(_M_MRX000)

        if (__CallSETranslator(pExcept, pRN, pContext, pDC, pFuncInfo,
          CatchDepth, pMarkerRN, TDTransOffset)) {
            EHTRACE_EXIT;
            return;
        }
    }

    // Didn't have a translator, or the translator returned normally (i.e.
    // didn't translate it).  Still need to check for match with ellipsis:
    pEntry = __GetRangeOfTrysToCheck(pRN, pFuncInfo, CatchDepth, curState,
      &curTry, &end, pDC);

    // Scan the try blocks in the function:
    for (; curTry < end; curTry++, pEntry++) {

        // If the try-block was in scope *and* the last catch in that try is an
        // ellipsis (no other can be)
        if (curState < TBME_LOW(*pEntry) || curState > TBME_HIGH(*pEntry)
          || !HT_IS_TYPE_ELLIPSIS(TBME_CATCH(*pEntry, TBME_NCATCHES(*pEntry) - 1))) {
            continue;
        }

        // Found an ellipsis.  Handle exception.

#if defined(_M_MRX000)
       DASSERT(VER41_C2(pFuncInfo));
       PVOID pRealFrame = _OffsetToAddress(0, pRN, FUNC_FRAMENEST(*pFuncInfo));
       UNWINDHELP(pRealFrame, FUNC_DISPUNWINDHELP(*pFuncInfo), 0) = curTry;
#elif defined(_M_IA64) /*IFSTRIP=IGN*/
       SetUnwindTryBlock(pRN, pDC, pFuncInfo, /*curTry*/ curState);
#endif // defined(_M_MRX000)

        CatchIt(pExcept, pRN, pContext, pDC, pFuncInfo,
          TBME_PCATCH(*pEntry, TBME_NCATCHES(*pEntry) - 1), NULL, pEntry,
          CatchDepth, pMarkerRN, TRUE);

        // If it returns, handler re-threw.  Keep searching.

    } // Search for try

    EHTRACE_EXIT;

    // If we got here, that means we didn't have anything to do with the
    // exception.  Continue search.
}


////////////////////////////////////////////////////////////////////////////////
//
// TypeMatch - Check if the catch type matches the given throw conversion.
//
// Returns:
//     TRUE if the catch can catch using this throw conversion, FALSE otherwise.

static __inline int TypeMatch(
    HandlerType *pCatch,                // Type of the 'catch' clause
    CatchableType *pCatchable,          // Type conversion under consideration
    ThrowInfo *pThrow                   // General information about the thrown
                                        //   type.
) {
    // First, check for match with ellipsis:
    if (HT_IS_TYPE_ELLIPSIS(*pCatch)) {
        return TRUE;
    }

    // Not ellipsis; the basic types match if it's the same record *or* the
    // names are identical.
    if (HT_PTD(*pCatch) != CT_PTD(*pCatchable)
      && strcmp(HT_NAME(*pCatch), CT_NAME(*pCatchable)) != 0) {
        return FALSE;
    }

    // Basic types match.  The actual conversion is valid if:
    //   caught by ref if ref required *and*
    //   the qualifiers are compatible *and*
    //   the alignments match *and*
    //   the volatility matches

    return (!CT_BYREFONLY(*pCatchable) || HT_ISREFERENCE(*pCatch))
      && (!THROW_ISCONST(*pThrow) || HT_ISCONST(*pCatch))
#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64) /*IFSTRIP=IGN*/
      && (!THROW_ISUNALIGNED(*pThrow) || HT_ISUNALIGNED(*pCatch))
#endif
      && (!THROW_ISVOLATILE(*pThrow) || HT_ISVOLATILE(*pCatch));
}


////////////////////////////////////////////////////////////////////////////////
//
// FrameUnwindFilter - Allows possibility of continuing through SEH during
//   unwind.
//

static int FrameUnwindFilter(
    EXCEPTION_POINTERS *pExPtrs
) {
    EHTRACE_ENTER;

    EHExceptionRecord *pExcept = (EHExceptionRecord *)pExPtrs->ExceptionRecord;

    switch (PER_CODE(pExcept)) {
    case EH_EXCEPTION_NUMBER:
        __ProcessingThrow = 0;
        terminate();

#ifdef ALLOW_UNWIND_ABORT
    case EH_ABORT_FRAME_UNWIND_PART:
        EHTRACE_EXIT;
        return EXCEPTION_EXECUTE_HANDLER;
#endif

    default:
        EHTRACE_EXIT;
        return EXCEPTION_CONTINUE_SEARCH;
    }
}


////////////////////////////////////////////////////////////////////////////////
//
// __FrameUnwindToState - Unwind this frame until specified state is reached.
//
// Returns:
//     No return value.
//
// Side Effects:
//     All objects on frame which go out of scope as a result of the unwind are
//       destructed.
//     Registration node is updated to reflect new state.
//
// Usage:
//      This function is called both to do full-frame unwind during the unwind
//      phase (targetState = -1), and to do partial unwinding when the current
//      frame has an appropriate catch.

extern "C" void __FrameUnwindToState (
    EHRegistrationNode *pRN,            // Registration node for subject
                                        //   function
    DispatcherContext *pDC,             // Context within subject frame
    FuncInfo *pFuncInfo,                // Static information for subject
                                        //   function
    __ehstate_t targetState             // State to unwind to
) {
    EHTRACE_ENTER;

    __ehstate_t curState = __GetUnwindState(pRN, pDC, pFuncInfo);
    __ProcessingThrow++;
    __try {
#if defined(_M_MRX000)
    // The MIPS unwind-map may have a shortcut by using EH_EMPTY_STATE

    while (curState != EH_EMPTY_STATE && curState != targetState)
#elif defined(_M_IA64)
    while (curState != EH_EMPTY_STATE && curState > targetState)
#else
    while (curState != targetState)
#endif
    {
        DASSERT((curState > EH_EMPTY_STATE)
          && (curState < FUNC_MAXSTATE(*pFuncInfo)));

        // Get state after next unwind action
        __ehstate_t nxtState = UWE_TOSTATE(FUNC_UNWIND(*pFuncInfo, curState));

        __try {
            // Call the unwind action (if one exists):

#if defined(_M_MRX000)
            // If this is nested function (catch block), the real frame where
            // all locals are stored is the outermost function's frame.

            PVOID pRealFrame =
              _OffsetToAddress(0, pRN, FUNC_FRAMENEST(*pFuncInfo));

            if (UWE_ACTION(FUNC_UNWIND(*pFuncInfo, curState)) != NULL
              && !UNWINDHELP(pRealFrame, FUNC_DISPUNWINDHELP(*pFuncInfo),
              curState)) {
                UNWINDHELP(pRealFrame, FUNC_DISPUNWINDHELP(*pFuncInfo),
                  curState) = TRUE;
#else // !defined(_M_MRX000)
            if (UWE_ACTION(FUNC_UNWIND(*pFuncInfo, curState)) != NULL) {
#endif
                // Before calling unwind action, adjust state as if it were
                // already completed:
                SetState(pRN, pDC, pFuncInfo, nxtState);

                EHTRACE_FMT2("Unwind from state %d to state %d", curState, nxtState);
                _CallSettingFrame(__GetAddress(UWE_ACTION(FUNC_UNWIND(*pFuncInfo, curState)), pDC),
                  REAL_FP(pRN, pFuncInfo), 0x103);
            }

        } __except(EHTRACE_EXCEPT(FrameUnwindFilter(exception_info()))) {
        }

        curState = nxtState;
    }
    } __finally {
        if (__ProcessingThrow > 0) {
            __ProcessingThrow--;
        }
    }


    // Now that we're done, set the frame to reflect the final state.

#if defined(_M_MRX000)
    DASSERT(curState == EH_EMPTY_STATE || curState == targetState);
#elif defined(_M_IA64)
    DASSERT(curState == EH_EMPTY_STATE || curState <= targetState);
#else
    DASSERT(curState == targetState);
#endif

    EHTRACE_FMT2("Move from state %d to state %d", __GetUnwindState(pRN, pDC, pFuncInfo), curState);
    SetState(pRN, pDC, pFuncInfo, curState);

    EHTRACE_EXIT;
}


////////////////////////////////////////////////////////////////////////////////
//
// CatchIt - A handler has been found for the thrown type.  Do the work to
//   transfer control.
//
// Description:
//     Builds the catch object
//     Unwinds the stack to the point of the try
//     Calls the address of the handler (funclet) with the frame set up for that
//       function but without resetting the stack.
//     Handler funclet returns address to continue execution, or NULL if the
//       handler re-threw ("throw;" lexically in handler)
//     If the handler throws an EH exception whose exception info is NULL, then
//       it's a re-throw from a dynamicly enclosed scope.
//
// M00REVIEW: It is still an open question whether the catch object is built
//          before or after the local unwind.
//
// Returns:
//     No return value.  Returns iff handler re-throws.
static void CatchIt(
    EHExceptionRecord *pExcept,         // The exception thrown
    EHRegistrationNode *pRN,            // Dynamic info of function with catch
    CONTEXT *pContext,                  // Context info
    DispatcherContext *pDC,             // Context within subject frame
    FuncInfo *pFuncInfo,                // Static info of function with catch
    HandlerType *pCatch,                // The catch clause selected
    CatchableType *pConv,               // The rules for making the conversion
    TryBlockMapEntry *pEntry,           // Description of the try block
    int CatchDepth,                     // How many catches are we nested in?
    EHRegistrationNode *pMarkerRN,      // Special node if nested in catch
    BOOLEAN IsRethrow                   // Is this a rethrow ?
) {
    EHTRACE_ENTER_FMT1("Catching object @ 0x%p", PER_PEXCEPTOBJ(pExcept));

    void *continuationAddress;
    EHRegistrationNode *pEstablisher = pRN;

#if defined(_M_MRX000) || defined(_POWERPC) || defined(_M_IA64)/*IFSTRIP=IGN*/
    FRAMEINFO FrameInfo;
    FRAMEINFO *pFrameInfo;
    CONTEXT ExitContext;
#endif // defined(_M_MRX000) || defined(_POWERPC) || defined(_M_IA64)

#if defined(_POWERPC)
    int dummy;

    pEstablisher = _GetEstablisherFrame(pDC, &dummy);
#elif defined(_M_IA64) /*IFSTRIP=IGN*/
    PVOID pExceptionObjectDestroyed = NULL;
    EHRegistrationNode EstablisherFramePointers;
    pEstablisher = _GetEstablisherFrame(pRN, pDC, pFuncInfo, &EstablisherFramePointers);
#endif // defined(_POWERPC)

    // Copy the thrown object into a buffer in the handler's stack frame,
    // unless the catch was by elipsis (no conversion) OR the catch was by
    // type without an actual 'catch object'.

    if (pConv != NULL) {
        BuildCatchObject(pExcept, pEstablisher, pCatch, pConv);
    }

    // Unwind stack objects to the entry of the try that caught this exception.

#if defined(_M_MRX000) || defined(_POWERPC) || defined(_M_IA64)/*IFSTRIP=IGN*/
    pExitContext = &ExitContext;
    _UnwindNestedFrames(pRN, pExcept, pContext);
#if defined(_M_IA64) /*IFSTRIP=IGN*/
    if( _pCurrentException != NULL && _ExecutionInCatch(pDC, pFuncInfo) && ! IsRethrow) {
        __DestructExceptionObject(_pCurrentException, TRUE);
        pExceptionObjectDestroyed = PER_PEXCEPTOBJ(_pCurrentException);
    }
#endif
#elif defined(_M_ALPHA)
    // Alpha specific - this calls a special version of RtlUnwind which
    // walks the stack performing unwind actions but which does NOT
    // restore the context to the target frame's routine. Instead it
    // just returns.
    _UnwindNestedFrames(pRN, pExcept);

#else
    if (pMarkerRN == NULL) {
        _UnwindNestedFrames(pRN, pExcept);
    } else {
        _UnwindNestedFrames(pMarkerRN, pExcept);
    }
#endif

#if defined(_M_IA64) /*IFSTRIP=IGN*/
    // Create FrameInfo before we attempt to unwind with __FrameUnwindToState()
    // pExitContext must be setup in advance just in case a DTOR throws a new exception. VS7:#202440
    pFrameInfo = _CreateFrameInfo(&FrameInfo, pDC, pExitContext, -2, pExceptionObjectDestroyed, pExcept);
#endif
    __FrameUnwindToState(pEstablisher, pDC, pFuncInfo, TBME_LOW(*pEntry));

    // Call the catch.  Separated out because it introduces a new registration
    // node.

#if defined(_M_MRX000)
    pFrameInfo = _CreateFrameInfo(&FrameInfo, pDC, pRN, pExitContext);
#elif defined(_M_IA64) /*IFSTRIP=IGN*/
    UNWINDSTATE(pEstablisher->MemoryStackFp, FUNC_DISPUNWINDHELP(*pFuncInfo)) = GetCurrentState(pEstablisher,pDC,pFuncInfo);
    if(IsRethrow) {
        pFrameInfo->isRethrow = TRUE;
    }
    else if( pExcept != NULL && pExceptionObjectDestroyed == NULL ) {
        pFrameInfo->pExceptionObjectToBeDestroyed = PER_PEXCEPTOBJ(pExcept);
    }
#elif defined(_POWERPC)
    pFrameInfo = _CreateFrameInfo(&FrameInfo, pDC, pEstablisher, pExitContext,
      (FUNC_UNWIND(*pFuncInfo, TBME_LOW(*pEntry))).toState);
#elif defined(_M_ALPHA)
    SetState(pRN, pDC, pFuncInfo,
      (FUNC_UNWIND(*pFuncInfo, TBME_LOW(*pEntry))).toState);
#else
    EHTRACE_FMT2("Move from state %d to state %d", __GetUnwindState(pRN, pDC, pFuncInfo), TBME_HIGH(*pEntry) + 1);
    SetState(pRN, pDC, pFuncInfo, TBME_HIGH(*pEntry) + 1);
#endif

    continuationAddress = CallCatchBlock(pExcept, pEstablisher, pContext,
      pFuncInfo, __GetAddress(HT_HANDLER(*pCatch), pDC), CatchDepth, 0x100
#if defined(_M_IA64) /*IFSTRIP=IGN*/
      , pFrameInfo
#endif
      );

    // Transfer control to the continuation address.  If no continuation then
    // it's a re-throw, so return.

    if (continuationAddress != NULL) {

#if defined(_M_MRX000) || defined(_POWERPC) || defined(_M_IA64) /*IFSTRIP=IGN*/

        // Exit gracefully to the continuation adddress.
        //
        // We are done, but we have to blow away the stack below the frame where
        // the try-block resides.  In addition, we have to resore a bunch of
        // other registers besides SP as well.  Leave that task up to
        // _JumpToContinuation.
        //
        // The code that is commented out below worked well until we hit the
        // scenario of:
        //
        //      void foo()
        //      {
        //              try {
        //                      bar();
        //              }
        //              catch(int) {
        //              }
        //      }
        //
        //      void bar()
        //      {
        //              __try {
        //                      throw 1;
        //              }
        //              __finally {
        //              }
        //      }
        //
        // In the above example, RtlUnwind would call the __finally's handler
        // twice.  Once for the original unwind through the call to
        // _UnwindNestedFrames, then here where all we want is to get to the
        // continuation point.
        //
        // ExitContext was saved during the original unwind when we detected the
        // target of the unwind in __InternalCxxFrameHandler.

#if defined(_M_MRX000)
        DASSERT(VER41_C2(pFuncInfo));
        PVOID pRealFrame = _OffsetToAddress(0, pRN, FUNC_FRAMENEST(*pFuncInfo));
        UNWINDHELP(pRealFrame, FUNC_DISPUNWINDHELP(*pFuncInfo), 0) = -1;
#elif defined(_M_IA64) /*IFSTRIP=IGN*/
        UNWINDHELP(pEstablisher->MemoryStackFp, FUNC_DISPUNWINDHELP(*pFuncInfo)) = -2;
        FRAMEINFO * pContFrameInfo = _FindFrameInfo(continuationAddress, pFrameInfo);
        if( pContFrameInfo != NULL && !pContFrameInfo->isRethrow 
            && pContFrameInfo->pExceptionObjectToBeDestroyed
            && !_IsExceptionObjectDestroyed(pContFrameInfo->pExceptionObjectToBeDestroyed,pFrameInfo)
        ) {
            __DestructExceptionObject(pContFrameInfo->pExcept, TRUE);
        }
#endif // defined(_M_MRX000)

        __ResetException(pExcept);
        pExitContext = NULL;
#if defined(_WIN64)
        _JumpToContinuation((unsigned __int64)continuationAddress,
#else
        _JumpToContinuation((ULONG)continuationAddress,
#endif
            _FindAndUnlinkFrame(continuationAddress, pFrameInfo)
#if defined(_M_IA64)
            ,pExcept
#endif
        );

#else // !(defined(_M_MRX000) || defined(_POWERPC)) || defined(_M_IA64)
        _JumpToContinuation(continuationAddress, pRN);
#endif
        // No return.

#if defined(_POWERPC)
    } else {
        _FindAndUnlinkFrame(NULL, pFrameInfo);
#elif defined(_M_IA64) /*IFSTRIP=IGN*/
    } else {
        _UnlinkFrame(pFrameInfo);
#endif
    }

    EHTRACE_EXIT;
}


////////////////////////////////////////////////////////////////////////////////
//
// CallCatchBlock - continuation of CatchIt.
//
// This is seperated from CatchIt because it needs to introduce an SEH/EH frame
//   in case the catch block throws.  This frame cannot be added until unwind of
//   nested frames has been completed (otherwise this frame would be the first
//   to go).

static void *CallCatchBlock(
    EHExceptionRecord *pExcept,         // The exception thrown
    EHRegistrationNode *pRN,            // Dynamic info of function with catch
    CONTEXT *pContext,                  // Context info
    FuncInfo *pFuncInfo,                // Static info of function with catch
    void *handlerAddress,               // Code address of handler
    int CatchDepth,                     // How deeply nested in catch blocks
                                        //   are we?
    unsigned long NLGCode               // NLG destination code
#if defined(_M_IA64) /*IFSTRIP=IGN*/
    ,
    FRAMEINFO   *pFrameInfo
#endif
) {
    EHTRACE_ENTER;

    // Address where execution resumes after exception handling completed.
    // Initialized to non-NULL (value doesn't matter) to distinguish from
    // re-throw in __finally.
    void *continuationAddress = handlerAddress;

    BOOL ExceptionObjectDestroyed = FALSE;

#if defined(_M_IX86)
    // The stack pointer at entry to the try must be saved, in case there is
    // another try inside this catch.  We'll restore it on our way out.
    void *saveESP = PRN_STACK(pRN);

    // Push this catch block's frame info on a linked list
    FRAMEINFO FrameInfo;
    FRAMEINFO *pFrameInfo = _CreateFrameInfo(&FrameInfo, PER_PEXCEPTOBJ(pExcept));
#endif

    // Save the current exception in case of a rethrow.  Save the previous value
    // on the stack, to be restored when the catch exits.
    EHExceptionRecord *pSaveException = _pCurrentException;
    CONTEXT *pSaveExContext = _pCurrentExContext;

    _pCurrentException = pExcept;
    _pCurrentExContext = pContext;

    __try {
        __try {
            // Execute the handler as a funclet, whose return value is the
            // address to resume execution.

#if defined(_M_IX86)
            continuationAddress = _CallCatchBlock2(pRN, pFuncInfo,
              handlerAddress, CatchDepth, NLGCode);
#else
            continuationAddress = _CallSettingFrame(handlerAddress,
              REAL_FP(pRN, pFuncInfo), NLGCode);
#endif

        } __except(EHTRACE_EXCEPT(ExFilterRethrow(exception_info()))) {
#if defined(_M_IX86)
            // Here we are exiting the catch block on rethrow out of this
            // catch block. To keep the order of destruction and construction
            // same when the the rethrow was from function or was inline, here
            // we unwind to the parent state for this catch.
            UnwindMapEntry *pUnwindMap = pFuncInfo->pUnwindMap;
            int cState = GetCurrentState(pRN, handlerAddress, pFuncInfo);
            TryBlockMapEntry *pTryBlockMap = pFuncInfo->pTryBlockMap;
            unsigned int i;
            for (i = 0; i < pFuncInfo->nTryBlocks; i++) {
                if (cState > pTryBlockMap[i].tryHigh && 
                    cState <= pTryBlockMap[i].catchHigh) {
                    cState = pTryBlockMap[i].tryHigh +1;
                    cState = pUnwindMap[cState].toState;
                    break;
                }
            }
            __FrameUnwindToState(pRN, NULL, pFuncInfo, cState);
#endif
            // If the handler threw a typed exception without exception info or
            // exception object, then it's a re-throw, so return.  Otherwise
            // it's a new exception, which takes precedence over this one.
            continuationAddress = NULL;
        }
    } __finally {
        EHTRACE_SAVE_LEVEL;
        EHTRACE_FMT1("Executing __finally, %snormal termination", _abnormal_termination() ? "ab" : "");

#if defined(_M_IX86)
        // Restore the saved stack pointer, so the stack can be reset when
        // we're done.
        PRN_STACK(pRN) = saveESP;

        // Pop this catch block's frame info
        _FindAndUnlinkFrame(pFrameInfo);
#endif

        // Restore the 'current exception' for a possibly enclosing catch
        _pCurrentException = pSaveException;
        _pCurrentExContext = pSaveExContext;

        // Destroy the original exception object if we're not exiting on a
        // re-throw and the object isn't also in use by a more deeply nested
        // catch.  Note that the catch handles destruction of its parameter.

        if (PER_IS_MSVC_EH(pExcept) && !ExceptionObjectDestroyed
          && continuationAddress != NULL
#if defined(_M_IA64)
            && !_IsExceptionObjectDestroyed(PER_PEXCEPTOBJ(pExcept),pFrameInfo)
#elif defined(_M_IX86)
            && IsExceptionObjectToBeDestroyed(PER_PEXCEPTOBJ(pExcept))
#endif          
            ) {
#if defined(_M_IA64)
            pFrameInfo->dtorThrowFlag = TRUE;
#endif          
            __DestructExceptionObject(pExcept, abnormal_termination());
#if defined(_M_MRX000)
            ExceptionObjectDestroyed = TRUE;
#endif
        }

        EHTRACE_RESTORE_LEVEL(!!_abnormal_termination());
    }
    EHTRACE_EXIT;
#if defined(_M_IA64)
    pFrameInfo->dtorThrowFlag = FALSE;
#endif          
    return continuationAddress;
}


////////////////////////////////////////////////////////////////////////////////
//
// ExFilterRethrow - Exception filter for re-throw exceptions.
//
// Returns:
//     EXCEPTION_EXECUTE_HANDLER - exception was a re-throw
//     EXCEPTION_CONTINUE_SEARCH - anything else
//
// Side-effects: NONE.

static int ExFilterRethrow(
    EXCEPTION_POINTERS *pExPtrs
) {
    // Get the exception record thrown (don't care about other info)
    EHExceptionRecord *pExcept = (EHExceptionRecord *)pExPtrs->ExceptionRecord;
    
    // Check if it's ours and it's has no exception information.
    if (PER_IS_MSVC_EH(pExcept) && PER_PTHROW(pExcept) == NULL) {
        return EXCEPTION_EXECUTE_HANDLER;
    } else {
        return EXCEPTION_CONTINUE_SEARCH;
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// BuildCatchObject - Copy or construct the catch object from the object thrown.
//
// Returns:
//     nothing.
//
// Side-effects:
//     A buffer in the subject function's frame is initialized.
//
// Open issues:
//     What happens if the constructor throws?  (or faults?)

static void BuildCatchObject(
    EHExceptionRecord *pExcept,         // Original exception thrown
    void *pRN,                          // This is a pointer to the object
                                        // that we want to build while doing
                                        // COM+ eh. If we are in our own eh,
                                        // then this is a Registration node of
                                        // catching function
    HandlerType *pCatch,                // The catch clause that got it
    CatchableType *pConv                // The conversion to use
) {
    EHTRACE_ENTER;

    // If the catch is by ellipsis, then there is no object to construct.
    // If the catch is by type(No Catch Object), then leave too!
    if (HT_IS_TYPE_ELLIPSIS(*pCatch) ||
        (!HT_DISPCATCH(*pCatch) && !HT_ISCOMPLUSEH(*pCatch))) {
        EHTRACE_EXIT;
        return;
    }

    void **pCatchBuffer;
    if ( HT_ISCOMPLUSEH(*pCatch))
    {
        pCatchBuffer = (void **)pRN;
    }
    else
    {
#if defined(_M_IA64) /*IFSTRIP=IGN*/
        pCatchBuffer = (void **)__OffsetToAddress(
                                HT_DISPCATCH(*pCatch),
                                ((EHRegistrationNode *)pRN)->MemoryStackFp,
                                HT_FRAMENEST(*pCatch)
                                );
#else
        pCatchBuffer = (void **)__OffsetToAddress(
                                HT_DISPCATCH(*pCatch),
                                (EHRegistrationNode *)pRN,
                                HT_FRAMENEST(*pCatch)
                                );
#endif
    }
    __try {
        if (HT_ISREFERENCE(*pCatch)) {

            // The catch is of form 'reference to T'.  At the throw point we
            // treat both 'T' and 'reference to T' the same, i.e.
            // pExceptionObject is a (machine) pointer to T.  Adjust as
            // required.
            if (_ValidateRead(PER_PEXCEPTOBJ(pExcept))
              && _ValidateWrite(pCatchBuffer)) {
                *pCatchBuffer = PER_PEXCEPTOBJ(pExcept);
                *pCatchBuffer = AdjustPointer(*pCatchBuffer,
                  CT_THISDISP(*pConv));
            } else {
                _inconsistency(); // Does not return; TKB
            }
        } else if (CT_ISSIMPLETYPE(*pConv)) {

            // Object thrown is of simple type (this including pointers) copy
            // specified number of bytes.  Adjust the pointer as required.  If
            // the thing is not a pointer, then this should be safe since all
            // the entries in the THISDISP are 0.
            if (_ValidateRead(PER_PEXCEPTOBJ(pExcept))
              && _ValidateWrite(pCatchBuffer)) {
                memmove(pCatchBuffer, PER_PEXCEPTOBJ(pExcept), CT_SIZE(*pConv));

                if (CT_SIZE(*pConv) == sizeof(void*) && *pCatchBuffer != NULL) {
                    *pCatchBuffer = AdjustPointer(*pCatchBuffer,
                      CT_THISDISP(*pConv));
                }
            } else {
                _inconsistency(); // Does not return; TKB
            }
        } else {

            // Object thrown is UDT.
            if (CT_COPYFUNC(*pConv) == NULL) {

                // The UDT had a simple ctor.  Adjust in the thrown object,
                // then copy n bytes.
                if (_ValidateRead(PER_PEXCEPTOBJ(pExcept))
                  && _ValidateWrite(pCatchBuffer)) {
                    memmove(pCatchBuffer, AdjustPointer(PER_PEXCEPTOBJ(pExcept),
                      CT_THISDISP(*pConv)), CT_SIZE(*pConv));
                } else {
                    _inconsistency(); // Does not return; TKB
                }
            } else {

                // It's a UDT: make a copy using copy ctor

#pragma warning(disable:4191)

                if (_ValidateRead(PER_PEXCEPTOBJ(pExcept))
                  && _ValidateWrite(pCatchBuffer)
                  && _ValidateExecute((FARPROC)CT_COPYFUNC(*pConv))) {

#pragma warning(default:4191)

                    if (CT_HASVB(*pConv)) {
                        _CallMemberFunction2((char *)pCatchBuffer,
                          CT_COPYFUNC(*pConv),
                          AdjustPointer(PER_PEXCEPTOBJ(pExcept),
                          CT_THISDISP(*pConv)), 1);
                    } else {
                        _CallMemberFunction1((char *)pCatchBuffer,
                          CT_COPYFUNC(*pConv),
                          AdjustPointer(PER_PEXCEPTOBJ(pExcept),
                          CT_THISDISP(*pConv)));
                    }
                } else {
                    _inconsistency(); // Does not return; TKB
                }
            }
        }
    } __except(EHTRACE_EXCEPT(EXCEPTION_EXECUTE_HANDLER)) {
        // Something went wrong when building the catch object.
        terminate();
    }

    EHTRACE_EXIT;
}


////////////////////////////////////////////////////////////////////////////////
//
// __DestructExceptionObject - Call the destructor (if any) of the original
//   exception object.
//
// Returns: None.
//
// Side-effects:
//     Original exception object is destructed.
//
// Notes:
//     If destruction throws any exception, and we are destructing the exception
//       object as a result of a new exception, we give up.  If the destruction
//       throws otherwise, we let it be.

extern "C" void _CRTIMP __DestructExceptionObject(
    EHExceptionRecord *pExcept,         // The original exception record
    BOOLEAN fThrowNotAllowed            // TRUE if destructor not allowed to
                                        //   throw
) {
    EHTRACE_ENTER_FMT1("Destroying object @ 0x%p", PER_PEXCEPTOBJ(pExcept));

    if (pExcept != NULL && THROW_UNWINDFUNC(*PER_PTHROW(pExcept)) != NULL) {

        __try {

            // M00REVIEW: A destructor has additional hidden arguments, doesn't
            // it?

#if defined(_M_IA64) /*IFSTRIP=IGN*/
            _MarkExceptionObjectDestroyed(pExcept);
            _CallMemberFunction0(PER_PEXCEPTOBJ(pExcept),
              THROW_UNWINDFUNC_IB(*PER_PTHROW(pExcept),(unsigned __int64)PER_PTHROWIB(pExcept)));
#else
            _CallMemberFunction0(PER_PEXCEPTOBJ(pExcept),
              THROW_UNWINDFUNC(*PER_PTHROW(pExcept)));
#endif
            __ResetException(pExcept);

        } __except(EHTRACE_EXCEPT(fThrowNotAllowed
          ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)) {

            // Can't have new exceptions when we're unwinding due to another
            // exception.
            terminate();
        }
    }

    EHTRACE_EXIT;
}


////////////////////////////////////////////////////////////////////////////////
//
// AdjustPointer - Adjust the pointer to the exception object to a pointer to a
//   base instance.
//
// Output:
//     The address point of the base.
//
// Side-effects:
//     NONE.

static void *AdjustPointer(
    void *pThis,                        // Address point of exception object
    const PMD& pmd                      // Generalized pointer-to-member
                                        //   descriptor
) {
    char *pRet = (char *)pThis + pmd.mdisp;

    if (pmd.pdisp >= 0) {
        pRet += *(__int32 *)((char *)*(ptrdiff_t *)((char *)pThis + pmd.pdisp)
#if defined(_WIN64)
           + (unsigned _int64)pmd.vdisp);
#else
           + pmd.vdisp);
#endif
        pRet += pmd.pdisp;
    }

    return pRet;
}

///////////////////////////////////////////////////////////////////////////////
// 
// __uncaught_exception() - Returns true after completing of a throw-expression
//                          untils completing initialization of the 
//                          exception-declaration in the matching handler.
//


bool __uncaught_exception()
{
    return (__ProcessingThrow != 0);
}


#ifndef _M_IA64 // Enable&fix for IA64 when COM+ C++ EH support available there

////////////////////////////////////////////////////////////////////////////////
// Model of C++ eh in COM+
//
// void func()
// {
//     try {
//         TryBody();
//     } catch (cpp_object o)
//     {
//         CatchOBody();
//     } catch (...)
//     {
//         CatchAllBody();
//     }
// }
//
// Turns into this:
//
//
// void func()
// {
//     int rethrow;
//     // One per try block
//     int isCxxException;
//     // One per catch(...)
//     __try {
//         TryBody();
//     }
//     __except(__CxxExceptionFilter(exception,
//                                   typeinfo(cpp_object),
//                                   flags,
//                                   &o))
//     // This is how it's done already
//     {
//     // Begin catch(object) prefix
//     char *storage = _alloca(__CxxQueryExceptionSize());
//     rethrow = false;
//     __CxxRegisterExceptionObject(exception,
//                                  storage);
//     __try {
//         __try {
//             // End catch(object) prefix
//             CatchOBody();
//             // Begin catch(object) suffix
//         } __except(rethrow = __CxxDetectRethrow(exception),
//                    EXCEPTION_CONTINUE_SEARCH)
//         {}
//     }
//     __finally
//     {
//         __CxxUnregisterExceptionObject(storage,
//                                        rethrow);
//     }
//     // End catch(object) suffix
//     }
//     __except(1)
//     {
//         // Begin catch(...) prefix
//         char *storage = _alloca(__CxxQueryExceptionSize());
//         rethrow = false;
//         isCxxException = __CxxRegisterExceptionObject(exception,
//                                                       storage);
//         __try
//         {
//             __try
//             {
//             // End catch(...) prefix 
//             CatchAllBody();
//             // Begin catch(...) suffix
//         } __except(rethrow = __CxxDetectRethrow(exception),
//                    EXCEPTION_CONTINUE_SEARCH)
//         {}
//     } __finally
//     {
//         if (isCxxException)
//         __CxxUnregisterExceptionObject(storage, rethrow);
//     }
//     // End catch(...) suffix
//     }
// }
//         
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// __CxxExceptionFilter() - Returns EXCEPTION_EXECUTE_HANDLER when the pType
//                          matches with the objects we can catch. Returns
//                          EXCEPTION_CONTINUE_SEARCH when pType is not one of
//                          the catchable type for the thrown object. This
//                          function is made for use with COM+ EH, where they
//                          attempt to do C++ EH as well.
//


extern "C" int __cdecl __CxxExceptionFilter(
    void *ppExcept,                     // Information for this (logical)
                                        // exception
    void *pType,                        // Info about the datatype. 
    int adjectives,                     // Extra Info about the datatype.
    void *pBuildObj                     // Pointer to datatype.
    )
{
    struct _s_HandlerType pCatch;
#if defined(_M_IA64)
    __int32 const *ppCatchable;
#elif defined(_WIN64)
    CatchableType * UNALIGNED const *ppCatchable;
#else
    CatchableType * const *ppCatchable;
#endif
    CatchableType *pCatchable;
    int catchables;
    EHExceptionRecord *pExcept;

    if (!ppExcept)
        return EXCEPTION_CONTINUE_SEARCH;
    pExcept = *(EHExceptionRecord **)ppExcept;
    // If catch all, always return EXCEPTION_EXECUTE_HANDLER
    if ( TD_IS_TYPE_ELLIPSIS((TypeDescriptor *)pType))
    {
        if (PER_IS_MSVC_EH(pExcept))
        {
            if ( PER_PTHROW(pExcept) == NULL)
            {
                // This code should never be false.
                if ( _pCurrentException != NULL)
                    *(EHExceptionRecord **)ppExcept = _pCurrentException;
            }
        }
        __ProcessingThrow++;
        return EXCEPTION_EXECUTE_HANDLER;
    }
    if (PER_IS_MSVC_EH(pExcept)) 
    {
        if ( PER_PTHROW(pExcept) == NULL) {
            if (_pCurrentException == NULL)
                return EXCEPTION_CONTINUE_SEARCH;
            pExcept =  _pCurrentException;
        }
        pCatch.pType = (TypeDescriptor *)pType;
        pCatch.adjectives = adjectives;
        SET_HT_ISCOMPLUSEH(pCatch);

        // Scan all types that thrown object can be converted to:
        ppCatchable = THROW_CTLIST(*PER_PTHROW(pExcept));
        for (catchables = THROW_COUNT(*PER_PTHROW(pExcept));
          catchables > 0; catchables--, ppCatchable++) {
 
#if defined(_M_IA64)
            pCatchable = (CatchableType *)(_GetThrowImageBase() + *ppCatchable);
#else
            pCatchable = *ppCatchable;
#endif

            if (TypeMatch(&pCatch, pCatchable, PER_PTHROW(pExcept))) {
                // SucessFull. Now build the object.
                __ProcessingThrow++;
                if (pBuildObj != NULL)
                    BuildCatchObject(pExcept, pBuildObj, &pCatch, pCatchable);
                // We set the current exception.
                if ( PER_PTHROW(*(EHExceptionRecord **)ppExcept) == NULL)
                    *(EHExceptionRecord **)ppExcept = _pCurrentException;
                return EXCEPTION_EXECUTE_HANDLER;
            }
        } // Scan posible conversions
    }
    return EXCEPTION_CONTINUE_SEARCH;
}

////////////////////////////////////////////////////////////////////////////////
//
// __CxxRgisterExceptionObject() - Registers Exception Object and saves it to
//                                 This is same as first part of
//                                 CallCatchBlock.
//
extern "C" int __cdecl __CxxRegisterExceptionObject(
    void *ppExcept,
    void *pStorage
)
{
    // This function is only called for C++ EH.
    EHExceptionRecord *pExcept;
    FRAMEINFO *pFrameInfo = (FRAMEINFO *)pStorage;
    EHExceptionRecord **ppSaveException;
    CONTEXT **ppSaveExContext;
    ppSaveException = (EHExceptionRecord **)(&pFrameInfo[1]);
    ppSaveExContext = (CONTEXT **)(&ppSaveException[1]);
    pExcept = *(EHExceptionRecord **)ppExcept;
    pFrameInfo = _CreateFrameInfo(pFrameInfo, PER_PEXCEPTOBJ(pExcept));
    *ppSaveException = _pCurrentException;
    *ppSaveExContext = _pCurrentExContext;
    _pCurrentException = pExcept;
    __ProcessingThrow--;
    if ( __ProcessingThrow < 0)
        __ProcessingThrow = 0;
    return 1;
}

////////////////////////////////////////////////////////////////////////////////
//
// __CxxDetectRethrow() - Looks at the Exception and returns true if rethrow,
//                        false if not a rethrow. This is then used for
//                        destructing the exception object in
//                        __CxxUnregisterExceptionObject().
//
extern "C" int __cdecl __CxxDetectRethrow(
    void *ppExcept
)
{
    EHExceptionRecord *pExcept;
    if (!ppExcept)
        return 0;
    pExcept = *(EHExceptionRecord **)ppExcept;
    if (PER_IS_MSVC_EH(pExcept) && PER_PTHROW(pExcept) == NULL) {
        *(EHExceptionRecord **)ppExcept = _pCurrentException;
        return 1;
    } else if (*(EHExceptionRecord **)ppExcept == _pCurrentException)
        return 1;
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// __CxxUnregisterExceptionObject - Destructs Exception Objects if rethrow ==
//                          true. Also set __pCurrentException and
//                          __pCurrentExContext() to current value.
//
extern "C" void __cdecl __CxxUnregisterExceptionObject(
    void *pStorage,
    int rethrow
)
{
    FRAMEINFO *pFrameInfo = (FRAMEINFO *)pStorage;
    EHExceptionRecord **ppSaveException;
    CONTEXT **ppSaveExContext;
    ppSaveException = (EHExceptionRecord **)(&pFrameInfo[1]);
    ppSaveExContext = (CONTEXT **)(&ppSaveException[1]);
    _FindAndUnlinkFrame(pFrameInfo);
    if ( !rethrow && PER_IS_MSVC_EH(_pCurrentException) && IsExceptionObjectToBeDestroyed(PER_PEXCEPTOBJ(_pCurrentException))) {
        __DestructExceptionObject(_pCurrentException, TRUE);
    }
    _pCurrentException = *ppSaveException;
    _pCurrentExContext = *ppSaveExContext;
}

////////////////////////////////////////////////////////////////////////////////
//
// __CxxQueryExceptionSize - returns the value of Storage needed to save
//                          FrameInfo + two pointers.
//
extern "C" int __cdecl __CxxQueryExceptionSize(
    void
)
{
    return sizeof(FRAMEINFO) + sizeof(void *) + sizeof(void *);
}

////////////////////////////////////////////////////////////////////////////////
//
// __CxxCallUnwindDtor - Calls a destructor during unwind. For COM+, the dtor
//                       call needs to be wrapped inside a __try/__except to
//                       get correct terminate() behavior when an exception 
//                       occurs during the dtor call.
//
extern "C" void __cdecl __CxxCallUnwindDtor(
    void (__thiscall * pDtor)(void*),
    void *pThis
)
{
    __try
    {
        (*pDtor)(pThis);
    }
    __except(FrameUnwindFilter(exception_info()))
    {
    }
}

#endif  // ndef _M_IA64
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\oldexcpt.h ===
/***
*oldexcpt.h - User include file for standard exception classes (old version)
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file presents an interface to the standard exception classes,
*       as specified by the ANSI X3J16/ISO SC22/WG21 Working Paper for
*       Draft C++, May 1994.
*
*       [Public]
*
*Revision History:
*       11-15-94  JWM   Made logic & exception classes _CRTIMP
*       11-21-94  JWM   xmsg typedef now #ifdef __RTTI_OLDNAMES
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers, protect with _INC_STDEXCPT.
*       02-14-95  CFW   Clean up Mac merge.
*       02-15-95  JWM   Minor cleanups related to Olympus bug 3716.
*       07-02-95  JWM   Now generally ANSI-compliant; excess baggage removed.
*       12-14-95  JWM   Add "#pragma once".
*       03-04-96  JWM   Replaced by C++ header "exception".
*       01-05-99  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*
****/

#if _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_STDEXCPT
#define _INC_STDEXCPT

#if !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif /* _CRTBLD */

/**
 *      #ifdef __cplusplus
 *
 *      #include <exception>
 *
 *      #elif 0
**/

#ifndef _CRTIMP
#ifdef  _NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else   /* ndef _NTSDK */
/* current definition */
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _NTSDK */
#endif  /* _CRTIMP */

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64 size_t;
#else
typedef unsigned int     size_t;
#endif
#define _SIZE_T_DEFINED
#endif


//
// Standard exception class heirarchy (ref. 1/94 WP 17.3.2.1, as ammended 3/94).
//
// exception (formerly xmsg)
//   logic
//     domain
//   runtime
//     range
//     alloc
//       xalloc
//
// Updated as per May'94 Working Paper

typedef const char *__exString;

class _CRTIMP exception
{
public:
    exception();
    exception(const __exString&);
    exception(const exception&);
    exception& operator= (const exception&);
    virtual ~exception();
    virtual __exString what() const;
private:
    __exString _m_what;
    int _m_doFree;
};

#ifdef __RTTI_OLDNAMES
typedef exception xmsg;        // A synonym for folks using older standard
#endif

//
//  logic_error
//
class _CRTIMP logic_error: public exception 
{
public:
    logic_error (const __exString& _what_arg) : exception(_what_arg) {}
};

/**
 *      #endif  /-* ndef __cplusplus *-/
**/

#endif  /* _INC_STDEXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\sources.inc ===
MAJORCOMP=crt
MINORCOMP=eh

TARGETNAME=eh

!INCLUDE ..\..\crt32.inc

INCLUDES=$(INCLUDES);$(CRTBASE)\crtw32\stdhpp;$(CRTBASE)\crtw32\extinc

CXX_FLAGS=-d1Binl $(CXX_FLAGS)

USE_NATIVE_EH=1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\stdnewh.cpp ===
/***
*stdnewh.cpp - A 'new_handler' that throws xalloc
*
*	Copyright (c) 1994-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Implementation of default 'new_handler', as specified in
*	[lib.set.new.handler] (section 17.3.3.2 of 1/25/94 WP).
*
*Revision History:
*	04-27-94  BES   Module created.
*	10-17-94  BWT	Disable code for PPC.
*
*******************************************************************************/

#include <eh.h>
#include <stdlib.h>
#include <stdexcpt.h>

int __cdecl _standard_new_handler ( size_t )
{
	static xalloc ex;

	ex.raise();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\rtti.cpp ===
/***
*rtti.cxx - C++ runtime type information
*
*       Copyright (c) 1994-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Implementation of C++ standard runtime type information
*
*Revision History:
*       10-17-94  JWM   File created.
*       10-17-94  BWT   Disable code for PPC.
*       11-11-94  JWM   Now includes windows.h
*       12-01-94  JWM   Added optimized cases for single & multiple inheritance
*       02-03-95  JWM   FindVITargetTypeInstance() now checks offsets to
*                       determine ambiguity, not pointer equality
*       02-09-95  JWM   Mac merge.
*       03-22-95  PML   Add const for read-only compiler-gen'd structs
*       05-03-95  JWM   Test visibility in FindSITargetTypeInstance().
*       08-28-95  JWM   dynamic-cast of NULL ptr now returns NULL (bug 502).
*       05-10-99  PML   Win64 fix: int -> ptrdiff_t
*       05-17-99  PML   Remove all Macintosh support.
*       10-19-99  TGL   Win64 fix: ptrdiff_t -> __int32 in PMDtoOffset.
*       03-15-00  PML   Remove CC_P7_SOFT25.
*       04-21-00  PML   Add exception specifications to extern "C" helpers.
*       08-23-00  PML   IA64 fix: _ImageBase can't be a static global, since
*                       that's not thread-safe (VS7#154575).
*       08-28-00  PML   IA64 fix: _ImageBase needs to be set from the address
*                       of the _RTTICompleteObjectLocator, not the return
*                       address (VS7#156255)
*       09-07-00  PML   Get rid of /lib:libcp directive in obj (vs7#159463)
*
****/

#define _USE_ANSI_CPP   /* Don't emit /lib:libcp directive */

#include <windows.h>
#include <rtti.h>
#include <typeinfo.h>

#if defined(_M_IA64)
static unsigned __int64 GetImageBase(PVOID);
#undef BCD_PTD
#undef CHD_PBCA
#undef CHD_PBCD
#undef COL_PTD
#undef COL_PCHD
#define BCD_PTD(bcd)    BCD_PTD_IB((bcd),_ImageBase)
#define CHD_PBCA(chd)   CHD_PBCA_IB((chd),_ImageBase)
#define CHD_PBCD(chd)   CHD_PBCD_IB((chd),_ImageBase)
#define COL_PTD(col)    COL_PTD_IB((col),_ImageBase) 
#define COL_PCHD(col)   COL_PCHD_IB((col),_ImageBase)
extern "C" PVOID RtlPcToFileHeader(PVOID, PVOID*);
#endif

static PVOID __cdecl FindCompleteObject(PVOID *);
static _RTTIBaseClassDescriptor * __cdecl
    FindSITargetTypeInstance(PVOID,
                             _RTTICompleteObjectLocator *,
                             _RTTITypeDescriptor *,
                             ptrdiff_t,
                             _RTTITypeDescriptor *
#if defined(_M_IA64)
                             , unsigned __int64
#endif
                             );
static _RTTIBaseClassDescriptor * __cdecl
    FindMITargetTypeInstance(PVOID,
                             _RTTICompleteObjectLocator *,
                             _RTTITypeDescriptor *,
                             ptrdiff_t,
                             _RTTITypeDescriptor *
#if defined(_M_IA64)
                             , unsigned __int64
#endif
                             );
static _RTTIBaseClassDescriptor * __cdecl
    FindVITargetTypeInstance(PVOID,
                             _RTTICompleteObjectLocator *,
                             _RTTITypeDescriptor *,
                             ptrdiff_t,
                             _RTTITypeDescriptor *
#if defined(_M_IA64)
                             , unsigned __int64
#endif
                             );
static ptrdiff_t __cdecl PMDtoOffset(PVOID, const PMD&);

/////////////////////////////////////////////////////////////////////////////
//
// __RTCastToVoid - Implements dynamic_cast<void*>
//
// Output: Pointer to complete object containing *inptr
//
// Side-effects: NONE.
//

extern "C" PVOID __cdecl __RTCastToVoid (
    PVOID inptr)            // Pointer to polymorphic object
    throw(...)
{
    if (inptr == NULL)
        return NULL;

    __try {
        return FindCompleteObject((PVOID *)inptr);
    }
    __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION
              ? EXCEPTION_EXECUTE_HANDLER: EXCEPTION_CONTINUE_SEARCH)
    {
        throw __non_rtti_object ("Access violation - no RTTI data!");
        return NULL;
    }
}


/////////////////////////////////////////////////////////////////////////////
//
// __RTtypeid - Implements typeid() operator
//
// Output: Pointer to type descriptor of complete object containing *inptr
//
// Side-effects: NONE.
//

extern "C" PVOID __cdecl __RTtypeid (
    PVOID inptr)            // Pointer to polymorphic object
    throw(...)
{
    if (!inptr) {
        throw bad_typeid ("Attempted a typeid of NULL pointer!");   // WP 5.2.7
        return NULL;
    }

    __try {
        // Ptr to CompleteObjectLocator should be stored at vfptr[-1]
        _RTTICompleteObjectLocator *pCompleteLocator =
            (_RTTICompleteObjectLocator *) ((*((void***)inptr))[-1]);
#if defined(_M_IA64)
        unsigned __int64 _ImageBase = GetImageBase((PVOID)pCompleteLocator);
#endif

        if (!IsBadReadPtr((const void *)COL_PTD(*pCompleteLocator),
                          sizeof(TypeDescriptor)))
        {
            return (PVOID) COL_PTD(*pCompleteLocator);
        }
        else {
            throw __non_rtti_object ("Bad read pointer - no RTTI data!");
            return NULL;
        }
    }
    __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION
              ? EXCEPTION_EXECUTE_HANDLER: EXCEPTION_CONTINUE_SEARCH)
    {
        throw __non_rtti_object ("Access violation - no RTTI data!");
        return NULL;
    }
}


/////////////////////////////////////////////////////////////////////////////
//
// __RTDynamicCast - Runtime implementation of dynamic_cast<> operator
//
// Output: Pointer to the appropriate sub-object, if possible; NULL otherwise
//
// Side-effects: Throws bad_cast() if cast fails & input of dynamic_cast<> is
// a reference
//

extern "C" PVOID __cdecl __RTDynamicCast (
    PVOID inptr,            // Pointer to polymorphic object
    LONG VfDelta,           // Offset of vfptr in object
    PVOID SrcType,          // Static type of object pointed to by inptr
    PVOID TargetType,       // Desired result of cast
    BOOL isReference)       // TRUE if input is reference, FALSE if input is ptr
    throw(...)
{
    PVOID pResult;
    _RTTIBaseClassDescriptor *pBaseClass;

    if (inptr == NULL)
            return NULL;

    __try {

        PVOID pCompleteObject = FindCompleteObject((PVOID *)inptr);
        _RTTICompleteObjectLocator *pCompleteLocator =
            (_RTTICompleteObjectLocator *) ((*((void***)inptr))[-1]);
#if defined(_M_IA64)
        unsigned __int64 _ImageBase = GetImageBase((PVOID)pCompleteLocator);
#endif

        // Adjust by vfptr displacement, if any
        inptr = (PVOID *) ((char *)inptr - VfDelta);

        // Calculate offset of source object in complete object
        ptrdiff_t inptr_delta = (char *)inptr - (char *)pCompleteObject;

        if (!(CHD_ATTRIBUTES(*COL_PCHD(*pCompleteLocator)) & CHD_MULTINH)) {
            // if not multiple inheritance
            pBaseClass = FindSITargetTypeInstance(
                            pCompleteObject,
                            pCompleteLocator,
                            (_RTTITypeDescriptor *) SrcType,
                            inptr_delta,
                            (_RTTITypeDescriptor *) TargetType
#if defined(_M_IA64)
                            , _ImageBase
#endif
                            );
        }
        else if (!(CHD_ATTRIBUTES(*COL_PCHD(*pCompleteLocator)) & CHD_VIRTINH)) {
            // if multiple, but not virtual, inheritance
            pBaseClass = FindMITargetTypeInstance(
                            pCompleteObject,
                            pCompleteLocator,
                            (_RTTITypeDescriptor *) SrcType,
                            inptr_delta,
                            (_RTTITypeDescriptor *) TargetType
#if defined(_M_IA64)
                            , _ImageBase
#endif
                            );
        }
        else {
            // if virtual inheritance
            pBaseClass = FindVITargetTypeInstance(
                            pCompleteObject,
                            pCompleteLocator,
                            (_RTTITypeDescriptor *) SrcType,
                            inptr_delta,
                            (_RTTITypeDescriptor *) TargetType
#if defined(_M_IA64)
                            , _ImageBase
#endif
                            );
        }

        if (pBaseClass != NULL) {
            // Calculate ptr to result base class from pBaseClass->where
            pResult = ((char *) pCompleteObject) +
                      PMDtoOffset(pCompleteObject, pBaseClass->where);
        }
        else {
            pResult = NULL;
            if (isReference)
                throw bad_cast("Bad dynamic_cast!");
        }

    }
    __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION
              ? EXCEPTION_EXECUTE_HANDLER: EXCEPTION_CONTINUE_SEARCH)
    {
        pResult = NULL;
        throw __non_rtti_object ("Access violation - no RTTI data!");
    }

    return pResult;
}


/////////////////////////////////////////////////////////////////////////////
//
// FindCompleteObject - Calculate member offset from PMD & this
//
// Output: pointer to the complete object containing class *inptr
//
// Side-effects: NONE.
//

static PVOID __cdecl FindCompleteObject (
    PVOID *inptr)           // Pointer to polymorphic object
{
    // Ptr to CompleteObjectLocator should be stored at vfptr[-1]
    _RTTICompleteObjectLocator *pCompleteLocator =
        (_RTTICompleteObjectLocator *) ((*((void***)inptr))[-1]);
    char *pCompleteObject = (char *)inptr - pCompleteLocator->offset;

    // Adjust by construction displacement, if any
    if (pCompleteLocator->cdOffset)
        pCompleteObject += *(ptrdiff_t *)((char *)inptr - pCompleteLocator->cdOffset);
    return (PVOID) pCompleteObject;
}


/////////////////////////////////////////////////////////////////////////////
//
// FindSITargetTypeInstance - workhorse routine of __RTDynamicCast() in a
// Single-Inheritance hierarchy
//
// Output: pointer to the appropriate sub-object of targetted type; NULL if
// cast fails
//
// Side-effects: NONE.
//

static _RTTIBaseClassDescriptor * __cdecl FindSITargetTypeInstance (
    PVOID pCompleteObject,                  // pointer to complete object
    _RTTICompleteObjectLocator *pCOLocator, // pointer to Locator of complete object
    _RTTITypeDescriptor *pSrcTypeID,        // pointer to TypeDescriptor of source object
    ptrdiff_t SrcOffset,                    // offset of source object in complete object
    _RTTITypeDescriptor *pTargetTypeID      // pointer to TypeDescriptor of result of cast
#if defined(_M_IA64)
    , unsigned __int64 _ImageBase
#endif
    )
{
    _RTTIBaseClassDescriptor *pBase;
#if defined(_M_IA64)
    _RTTIBaseClassArray *pBaseClassArray;
#else
    _RTTIBaseClassDescriptor * const *pBasePtr;
#endif
    DWORD i;

#if defined(_M_IA64)
    for (i = 0, pBaseClassArray = CHD_PBCA(*COL_PCHD(*pCOLocator));
         i < CHD_NUMBASES(*COL_PCHD(*pCOLocator));
         i++)
    {
        pBase = CHD_PBCD(pBaseClassArray->arrayOfBaseClassDescriptors[i]);

        // Test type of selected base class
        if (TYPEIDS_EQ(BCD_PTD(*pBase), pTargetTypeID) &&
            !(BCD_ATTRIBUTES(*pBase) & BCD_NOTVISIBLE))
        {
                return pBase;
        }
    }
#else
    for (i = 0, pBasePtr = pCOLocator->pClassDescriptor->
                                       pBaseClassArray->
                                       arrayOfBaseClassDescriptors;
         i < pCOLocator->pClassDescriptor->numBaseClasses;
         i++, pBasePtr++)
    {
        pBase = *pBasePtr;

        // Test type of selected base class
        if (TYPEIDS_EQ(pBase->pTypeDescriptor, pTargetTypeID) &&
            !(BCD_ATTRIBUTES(*pBase) & BCD_NOTVISIBLE))
        {
                return pBase;
        }
    }
#endif
    return NULL;
}


/////////////////////////////////////////////////////////////////////////////
//
// FindMITargetTypeInstance - workhorse routine of __RTDynamicCast() in a
// Multiple-Inheritance hierarchy
//
// Output: pointer to the appropriate sub-object of targetted type; NULL if
// cast fails
//
// Side-effects: NONE.
//

static _RTTIBaseClassDescriptor * __cdecl FindMITargetTypeInstance (
    PVOID pCompleteObject,                  // pointer to complete object
    _RTTICompleteObjectLocator *pCOLocator, // pointer to Locator of complete object
    _RTTITypeDescriptor *pSrcTypeID,        // pointer to TypeDescriptor of source object
    ptrdiff_t SrcOffset,                    // offset of source object in complete object
    _RTTITypeDescriptor *pTargetTypeID      // pointer to TypeDescriptor of result of cast
#if defined(_M_IA64)
    , unsigned __int64 _ImageBase
#endif
    )
{
    _RTTIBaseClassDescriptor *pBase, *pSubBase;
#if defined(_M_IA64)
    _RTTIBaseClassArray *pBaseClassArray;
#else
    _RTTIBaseClassDescriptor * const *pBasePtr, * const *pSubBasePtr;
#endif
    DWORD i, j;

#if defined(_M_IA64)
    // First, try down-casts
    for (i = 0, pBaseClassArray = CHD_PBCA(*COL_PCHD(*pCOLocator));
         i < CHD_NUMBASES(*COL_PCHD(*pCOLocator));
         i++)
    {
        pBase = CHD_PBCD(pBaseClassArray->arrayOfBaseClassDescriptors[i]);

        // Test type of selected base class
        if (TYPEIDS_EQ(BCD_PTD(*pBase), pTargetTypeID)) {
            // If base class is proper type, see if it contains our instance
            // of source class
            for (j = 0;
                 j < pBase->numContainedBases;
                 j++)
            {
                pSubBase = CHD_PBCD(pBaseClassArray->arrayOfBaseClassDescriptors[i+1+j]);
                if (TYPEIDS_EQ(BCD_PTD(*pSubBase), pSrcTypeID) &&
                    (PMDtoOffset(pCompleteObject, pSubBase->where) == SrcOffset))
                {
                    // Yes, this is the proper instance of source class
                    return pBase;
                }
            }
        }
    }

    // Down-cast failed, try cross-cast
    for (i = 0, pBaseClassArray = CHD_PBCA(*COL_PCHD(*pCOLocator));
         i < CHD_NUMBASES(*COL_PCHD(*pCOLocator));
         i++)
    {
        pBase = CHD_PBCD(pBaseClassArray->arrayOfBaseClassDescriptors[i]);

        // Check if base class has proper type, is accessible & is unambiguous
        if (TYPEIDS_EQ(BCD_PTD(*pBase), pTargetTypeID) &&
            !(BCD_ATTRIBUTES(*pBase) & BCD_NOTVISIBLE) &&
            !(BCD_ATTRIBUTES(*pBase) & BCD_AMBIGUOUS))
        {
            return pBase;
        }
    }
#else
    // First, try down-casts
    for (i = 0, pBasePtr = pCOLocator->pClassDescriptor->
                                       pBaseClassArray->
                                       arrayOfBaseClassDescriptors;
         i < pCOLocator->pClassDescriptor->numBaseClasses;
         i++, pBasePtr++)
    {
        pBase = *pBasePtr;

        // Test type of selected base class
        if (TYPEIDS_EQ(pBase->pTypeDescriptor, pTargetTypeID)) {
            // If base class is proper type, see if it contains our instance
            // of source class
            for (j = 0, pSubBasePtr = pBasePtr+1;
                 j < pBase->numContainedBases;
                 j++, pSubBasePtr++)
            {
                pSubBase = *pSubBasePtr;
                if (TYPEIDS_EQ(pSubBase->pTypeDescriptor, pSrcTypeID) &&
                    (PMDtoOffset(pCompleteObject, pSubBase->where) == SrcOffset))
                {
                    // Yes, this is the proper instance of source class
                    return pBase;
                }
            }
        }
    }

    // Down-cast failed, try cross-cast
    for (i = 0, pBasePtr = pCOLocator->pClassDescriptor->
                                       pBaseClassArray->
                                       arrayOfBaseClassDescriptors;
         i < pCOLocator->pClassDescriptor->numBaseClasses;
         i++, pBasePtr++)
    {
        pBase = *pBasePtr;

        // Check if base class has proper type, is accessible & is unambiguous
        if (TYPEIDS_EQ(pBase->pTypeDescriptor, pTargetTypeID) &&
            !(BCD_ATTRIBUTES(*pBase) & BCD_NOTVISIBLE) &&
            !(BCD_ATTRIBUTES(*pBase) & BCD_AMBIGUOUS))
        {
            return pBase;
        }
    }
#endif

    return NULL;
}


/////////////////////////////////////////////////////////////////////////////
//
// FindVITargetTypeInstance - workhorse routine of __RTDynamicCast() in a
// Virtual-Inheritance hierarchy
//
// Output: pointer to the appropriate sub-object of targetted type; NULL if
// cast fails
//
// Side-effects: NONE.
//

static _RTTIBaseClassDescriptor * __cdecl FindVITargetTypeInstance (
    PVOID pCompleteObject,                  // pointer to complete object
    _RTTICompleteObjectLocator *pCOLocator, // pointer to Locator of complete object
    _RTTITypeDescriptor *pSrcTypeID,        // pointer to TypeDescriptor of source object
    ptrdiff_t SrcOffset,                    // offset of source object in complete object
    _RTTITypeDescriptor *pTargetTypeID      // pointer to TypeDescriptor of result of cast
#if defined(_M_IA64)
    , unsigned __int64 _ImageBase
#endif
    )
{
    _RTTIBaseClassDescriptor *pBase, *pSubBase;
#if defined(_M_IA64)
    _RTTIBaseClassArray *pBaseClassArray;
#else
    _RTTIBaseClassDescriptor * const *pBasePtr, * const *pSubBasePtr;
#endif
    _RTTIBaseClassDescriptor *pResult = NULL;
    DWORD i, j;

#if defined(_M_IA64)
    for (i = 0, pBaseClassArray = CHD_PBCA(*COL_PCHD(*pCOLocator));
         i < CHD_NUMBASES(*COL_PCHD(*pCOLocator));
         i++)
    {
        pBase = CHD_PBCD(pBaseClassArray->arrayOfBaseClassDescriptors[i]);

        // Test type of selected base class
        if (TYPEIDS_EQ(BCD_PTD(*pBase), pTargetTypeID)) {
            // If base class is proper type, see if it contains our instance
            // of source class
            for (j = 0;
                 j < pBase->numContainedBases;
                 j++)
            {
                pSubBase = CHD_PBCD(pBaseClassArray->arrayOfBaseClassDescriptors[i+1+j]);
                if (TYPEIDS_EQ(BCD_PTD(*pSubBase), pSrcTypeID) &&
                    (PMDtoOffset(pCompleteObject, pSubBase->where) == SrcOffset))
                {
                    // Yes, this is the proper instance of source class - make
                    // sure it is unambiguous.  Ambiguity now determined by
                    // inequality of offsets of source class within complete
                    // object, not pointer inequality
                    if ((pResult != NULL) &&
                        (PMDtoOffset(pCompleteObject, pResult->where) != 
                         PMDtoOffset(pCompleteObject, pBase->where)))
                    {
                        // We already found an earlier instance, hence
                        // ambiguity
                        return NULL;
                    }
                    else {
                        // Unambiguous
                        pResult = pBase;
                    }
                }
            }
        }
    }

    if (pResult != NULL)
        return pResult;

    // Down-cast failed, try cross-cast
    for (i = 0, pBaseClassArray = CHD_PBCA(*COL_PCHD(*pCOLocator));
         i < CHD_NUMBASES(*COL_PCHD(*pCOLocator));
         i++)
    {
        pBase = CHD_PBCD(pBaseClassArray->arrayOfBaseClassDescriptors[i]);

        // Check if base class has proper type, is accessible & is unambiguous
        if (TYPEIDS_EQ(BCD_PTD(*pBase), pTargetTypeID) &&
            !(BCD_ATTRIBUTES(*pBase) & BCD_NOTVISIBLE) &&
            !(BCD_ATTRIBUTES(*pBase) & BCD_AMBIGUOUS))
        {
            return pBase;
        }
    }
#else
    // First, try down-casts
    for (i = 0, pBasePtr = pCOLocator->pClassDescriptor->
                                       pBaseClassArray->
                                       arrayOfBaseClassDescriptors;
         i < pCOLocator->pClassDescriptor->numBaseClasses;
         i++, pBasePtr++)
    {
        pBase = *pBasePtr;

        // Test type of selected base class
        if (TYPEIDS_EQ(pBase->pTypeDescriptor, pTargetTypeID)) {
            // If base class is proper type, see if it contains our instance
            // of source class
            for (j = 0, pSubBasePtr = pBasePtr+1;
                 j < pBase->numContainedBases;
                 j++, pSubBasePtr++)
            {
                pSubBase = *pSubBasePtr;
                if (TYPEIDS_EQ(pSubBase->pTypeDescriptor, pSrcTypeID) &&
                    (PMDtoOffset(pCompleteObject, pSubBase->where) == SrcOffset))
                {
                    // Yes, this is the proper instance of source class - make
                    // sure it is unambiguous.  Ambiguity now determined by
                    // inequality of offsets of source class within complete
                    // object, not pointer inequality
                    if ((pResult != NULL) &&
                        (PMDtoOffset(pCompleteObject, pResult->where) != 
                         PMDtoOffset(pCompleteObject, pBase->where)))
                    {
                        // We already found an earlier instance, hence
                        // ambiguity
                        return NULL;
                    }
                    else {
                        // Unambiguous
                        pResult = pBase;
                    }
                }
            }
        }
    }

    if (pResult != NULL)
        return pResult;

    // Down-cast failed, try cross-cast
    for (i = 0, pBasePtr = pCOLocator->pClassDescriptor->
                                       pBaseClassArray->
                                       arrayOfBaseClassDescriptors;
         i < pCOLocator->pClassDescriptor->numBaseClasses;
         i++, pBasePtr++)
    {
        pBase = *pBasePtr;

        // Check if base class has proper type, is accessible & is unambiguous
        if (TYPEIDS_EQ(pBase->pTypeDescriptor, pTargetTypeID) &&
            !(BCD_ATTRIBUTES(*pBase) & BCD_NOTVISIBLE) &&
            !(BCD_ATTRIBUTES(*pBase) & BCD_AMBIGUOUS))
        {
            return pBase;
        }
    }
#endif

    return NULL;
}


/////////////////////////////////////////////////////////////////////////////
//
// PMDtoOffset - Calculate member offset from PMD & this
//
// Output: The offset of the base within the complete object.
//
// Side-effects: NONE.
//

static ptrdiff_t __cdecl PMDtoOffset(
    PVOID pThis,            // ptr to complete object
    const PMD& pmd)         // pointer-to-member-data structure
{
    ptrdiff_t RetOff = 0;

    if (pmd.pdisp >= 0) {
        // if base is in the virtual part of class
        RetOff = pmd.pdisp;
        RetOff += *(__int32*)((char*)*(ptrdiff_t*)((char*)pThis + RetOff) +
                                pmd.vdisp);
    }

    RetOff += pmd.mdisp;

    return RetOff;
}

#if defined(_M_IA64)
static unsigned __int64 GetImageBase(PVOID pCallerPC)
{
    unsigned __int64 _ImageBase;
    _ImageBase = (unsigned __int64)RtlPcToFileHeader(
        pCallerPC,
        (PVOID*)&_ImageBase);
    return _ImageBase;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\stdexcpt.cpp ===
/***
*stdexcpt.cpp - defines C++ standard exception classes
*
*       Copyright (c) 1994-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Implementation of C++ standard exception classes which must live in
*       the main CRT, not the C++ CRT, because they are referenced by RTTI
*       support in the main CRT.
*
*        exception
*          bad_cast
*          bad_typeid
*            __non_rtti_object
*
*Revision History:
*       04-27-94  BES   Module created.
*       10-17-94  BWT   Disable code for PPC.
*       02-15-95  JWM   Minor cleanups related to Olympus bug 3716
*       07-02-95  JWM   Now generally ANSI-compliant; excess baggage removed.
*       06-01-99  PML   __exString disappeared as of 5/3/99 Plauger STL drop.
*       11-09-99  PML   Use malloc, not new, to avoid recursion (vs7#16826).
*       09-07-00  PML   Get rid of /lib:libcp directive in obj (vs7#159463)
*       03-21-01  PML   Move bad_cast, bad_typeid, __non_rtti_object function
*                       defs out of typeinfo.h so _STATIC_CPPLIB will work.
*
*******************************************************************************/

#define _USE_ANSI_CPP   /* Don't emit /lib:libcp directive */

#include <stdlib.h>
#include <string.h>
#include <eh.h>
#include <stdexcpt.h>
#include <typeinfo.h>

////////////////////////////////////////////////////////////////////////////////
//
// Implementation of class "exception"
//

//
// Default constructor - initialize to blank
//
exception::exception ()
{
        _m_what = NULL;
        _m_doFree = 0;
}

//
// Standard constructor: initialize with copy of string
//
exception::exception ( const char * const & what )
{
        _m_what = static_cast< char * >( malloc( strlen( what ) + 1 ) );
        if ( _m_what != NULL )
            strcpy( (char*)_m_what, what );
        _m_doFree = 1;
}

//
// Copy constructor
//
exception::exception ( const exception & that )
{
        _m_doFree = that._m_doFree;
        if (_m_doFree)
        {
            _m_what = static_cast< char * >( malloc( strlen( that._m_what ) + 1 ) );
            if (_m_what != NULL)
                strcpy( (char*)_m_what, that._m_what );
        }
        else
           _m_what = that._m_what;
}

//
// Assignment operator: destruct, then copy-construct
//
exception& exception::operator=( const exception& that )
{
        if (this != &that)
        {
            this->exception::~exception();
            this->exception::exception(that);
        }
        return *this;
}

//
// Destructor: free the storage used by the message string if it was
// dynamicly allocated
//
exception::~exception()
{
        if (_m_doFree)
            free( const_cast< char * >( _m_what ) );
}


//
// exception::what
//  Returns the message string of the exception.
//  Default implementation of this method returns the stored string if there
//  is one, otherwise returns a standard string.
//
const char * exception::what() const
{
        if ( _m_what != NULL )
            return _m_what;
        else
            return "Unknown exception";
}

////////////////////////////////////////////////////////////////////////////////
//
// Implementation of class "bad_cast"
//

bad_cast::bad_cast(const char * _Message)
    : exception(_Message)
{
}

bad_cast::bad_cast(const bad_cast & that)
    : exception(that)
{
}

bad_cast::~bad_cast()
{
}

#ifdef CRTDLL
//
// This is a dummy constructor.  Previously, the only bad_cast ctor was
// bad_cast(const char * const &).  To provide backwards compatibility
// for std::bad_cast, we want the main ctor to be bad_cast(const char *)
// instead.  Since you can't have both bad_cast(const char * const &) and
// bad_cast(const char *), we define this bad_cast(const char * const *),
// which will have the exact same codegen as bad_cast(const char * const &),
// and alias the old form with a .def entry.
//
bad_cast::bad_cast(const char * const * _PMessage)
    : exception(*_PMessage)
{
}
#endif

////////////////////////////////////////////////////////////////////////////////
//
// Implementation of class "bad_typeid"
//

bad_typeid::bad_typeid(const char * _Message)
    : exception(_Message)
{
}

bad_typeid::bad_typeid(const bad_typeid & that)
    : exception(that)
{
}

bad_typeid::~bad_typeid()
{
}

////////////////////////////////////////////////////////////////////////////////
//
// Implementation of class "__non_rtti_object"
//

__non_rtti_object::__non_rtti_object(const char * _Message)
    : bad_typeid(_Message)
{
}

__non_rtti_object::__non_rtti_object(const __non_rtti_object & that)
    : bad_typeid(that)
{
}

__non_rtti_object::~__non_rtti_object()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\typinfo.cpp ===
/***
*typeinfo.cpp - Implementation of type_info for RTTI.
*
*	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This module provides an implementation of the class type_info
*	for Run-Time Type Information (RTTI).
*
*Revision History:
*	10-04-94  SB	Module created
*	10-07-94  JWM	rewrote
*	10-17-94  BWT	Disable code for PPC.
*	11-23-94  JWM	Strip trailing spaces from type_info.name().
*	02/15/95  JWM   Class type_info no longer _CRTIMP, member functions are exported instead
*       06-02-95  JWM   unDName -> __unDName.
*       06-19-95  JWM   type_info.name() moved to typename.cpp for granularity.
*       07-02-95  JWM   return values from == & != cleaned up, locks added to destructor.
*       09-07-00  PML   Get rid of /lib:libcp directive in obj (vs7#159463)
*
****/

#define _USE_ANSI_CPP   /* Don't emit /lib:libcp directive */

#include <stdlib.h>
#include <typeinfo.h>
#include <mtdll.h>
#include <string.h>
#include <dbgint.h>
#include <undname.h>



_CRTIMP type_info::~type_info()
{
        

        _mlock(_TYPEINFO_LOCK);
        if (_m_data != NULL) {
#ifdef _DEBUG /* CRT debug lib build */
            _free_base (_m_data);
#else
            free (_m_data);
#endif
        }
        _munlock(_TYPEINFO_LOCK);

}

_CRTIMP int type_info::operator==(const type_info& rhs) const
{
	return (strcmp((rhs._m_d_name)+1, (_m_d_name)+1)?0:1);
}

_CRTIMP int type_info::operator!=(const type_info& rhs) const
{
	return (strcmp((rhs._m_d_name)+1, (_m_d_name)+1)?1:0);
}

_CRTIMP int type_info::before(const type_info& rhs) const
{
	return (strcmp((rhs._m_d_name)+1,(_m_d_name)+1) > 0);
}

_CRTIMP const char* type_info::raw_name() const
{
    return _m_d_name;
}

type_info::type_info(const type_info& rhs)
{
//	*TBD*
//	"Since the copy constructor and assignment operator for
//	type_info are private to the class, objects of this type
//	cannot be copied." - 18.5.1
//
//  _m_data = NULL;
//  _m_d_name = new char[strlen(rhs._m_d_name) + 1];
//  if (_m_d_name != NULL)
//      strcpy( (char*)_m_d_name, rhs._m_d_name );
}


type_info& type_info::operator=(const type_info& rhs)
{
//	*TBD*
//
//  if (this != &rhs) {
//      this->type_info::~type_info();
//      this->type_info::type_info(rhs);
//  }
    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\typname.cpp ===
/***
*typename.cpp - Implementation of type_info.name() for RTTI.
*
*	Copyright (c) 1995-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This module provides an implementation of the class member function
*	type_info.name() for Run-Time Type Information (RTTI).
*
*Revision History:
*       06-19-95  JWM   broken out from typeinfo.cpp for granularity.
*       07-02-95  JWM   now locks around assignment to _m_data.
*       12-18-95  JWM   debug type_info::name() now calls _malloc_crt().
*       09-07-00  PML   Get rid of /lib:libcp directive in obj (vs7#159463)
*       02-19-01  GB    Added Check for return value of malloc
*
****/

#define _USE_ANSI_CPP   /* Don't emit /lib:libcp directive */

#include <stdlib.h>
#include <typeinfo.h>
#include <mtdll.h>
#include <string.h>
#include <dbgint.h>
#include <undname.h>

_CRTIMP const char* type_info::name() const //17.3.4.2.5
{
	void *pTmpUndName;


        if (this->_m_data == NULL) {
#ifdef _DEBUG /* CRT debug lib build */
#if _M_MRX000 >= 4000 /*IFSTRIP=IGN*/
            if ((pTmpUndName = __unDName(NULL, !strncmp(this->_m_d_name,"_TD",3)? (this->_m_d_name)+4 : (this->_m_d_name)+1, 0, &_malloc_base, &_free_base, UNDNAME_32_BIT_DECODE | UNDNAME_TYPE_ONLY)) == NULL)
                return NULL;
#else
            if ((pTmpUndName = __unDName(NULL, (this->_m_d_name)+1, 0, &_malloc_base, &_free_base, UNDNAME_32_BIT_DECODE | UNDNAME_TYPE_ONLY)) == NULL)
                return NULL;
#endif
#else
#if _M_MRX000 >= 4000 /*IFSTRIP=IGN*/
            if ((pTmpUndName = __unDName(NULL, !strncmp(this->_m_d_name,"_TD",3)? (this->_m_d_name)+4 : (this->_m_d_name)+1, 0, &malloc, &free, UNDNAME_32_BIT_DECODE | UNDNAME_TYPE_ONLY)) == NULL)
                return NULL;
#else
            if ((pTmpUndName = __unDName(NULL, (this->_m_d_name)+1, 0, &malloc, &free, UNDNAME_32_BIT_DECODE | UNDNAME_TYPE_ONLY)) == NULL)
                return NULL;
#endif
#endif
            for (int l=(int)strlen((char *)pTmpUndName)-1; ((char *)pTmpUndName)[l] == ' '; l--)
                ((char *)pTmpUndName)[l] = '\0';

            _mlock (_TYPEINFO_LOCK);
#ifdef _DEBUG /* CRT debug lib build */
            if ((((type_info *)this)->_m_data = _malloc_crt (strlen((char *)pTmpUndName) + 1)) != NULL)
                strcpy ((char *)((type_info *)this)->_m_data, (char *)pTmpUndName);
            _free_base (pTmpUndName);
#else
            if ((((type_info *)this)->_m_data = malloc (strlen((char *)pTmpUndName) + 1)) != NULL)
                strcpy ((char *)((type_info *)this)->_m_data, (char *)pTmpUndName);
            free (pTmpUndName);
#endif
            _munlock(_TYPEINFO_LOCK);


        }


        return (char *) this->_m_data;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\unhandld.cpp ===
/***
*unhandld.cxx - Wrapper to call terminate() when an exception goes unhandled.
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Wrapper to call terminate() when an exception goes unhandled.
*
*Description:
*       This module makes use of the Win32 API SetUnhandledExceptionFilter.
*       This assumes the call to main() is wrapped with
*       __try {  ... }
*       __except(UnhandledExceptionFilter(_exception_info())) {  ...  }
*
*Revision History:
*       10-04-93  BS    Module created
*       10-17-94  BWT   Disable code for PPC.
*       02-09-95  JWM   Mac merge.
*       02-16-95  JWM   Added __CxxRestoreUnhandledExceptionFilter().
*       11-19-96  GJF   Install handler during C initializers, remove it 
*                       during C termination. Also, reformatted the source a
*                       bit for readability.
*       04-28-99  PML   Wrap __declspec(allocate()) in _CRTALLOC macro.
*       05-17-99  PML   Remove all Macintosh support.
*       03-27-01  PML   .CRT$XI routines must now return 0 or _RT_* fatal
*                       error code (vs7#231220)
*
****/

#include <windows.h>
#include <ehdata.h>
#include <eh.h>
#include <ehhooks.h>
#include <ehassert.h>
#include <internal.h>
#include <stdlib.h>

#pragma hdrstop

#include <sect_attribs.h>

int  __cdecl __CxxSetUnhandledExceptionFilter(void);
void __cdecl __CxxRestoreUnhandledExceptionFilter(void);

#pragma data_seg(".CRT$XIY")
_CRTALLOC(".CRT$XIY") static _PIFV pinit = &__CxxSetUnhandledExceptionFilter;

#pragma data_seg(".CRT$XTB")
_CRTALLOC(".CRT$XTB") static _PVFV pterm = &__CxxRestoreUnhandledExceptionFilter;

#pragma data_seg()

static LPTOP_LEVEL_EXCEPTION_FILTER pOldExceptFilter;


/////////////////////////////////////////////////////////////////////////////
//
// __CxxUnhandledExceptionFilter - if the exception is ours, call terminate();
//
// Returns:
//      If the exception was MSVC C++ EH, does not return.
//      If the previous filter was NULL, returns EXCEPTION_CONTINUE_SEARCH.
//      Otherwise returns value returned by previous filter.
//
LONG WINAPI __CxxUnhandledExceptionFilter(
        LPEXCEPTION_POINTERS pPtrs
        )
{
        if (PER_IS_MSVC_EH((EHExceptionRecord*)(pPtrs->ExceptionRecord))) {
                terminate();            // Does not return
                return EXCEPTION_EXECUTE_HANDLER;
        }
        else {

#pragma warning(disable:4191)

                if ( pOldExceptFilter != NULL && 
                     _ValidateExecute((FARPROC)pOldExceptFilter) ) 

#pragma warning(default:4191)

                {
                        return pOldExceptFilter(pPtrs);
                }
                else {
                        return EXCEPTION_CONTINUE_SEARCH;
                }
        }
}


/////////////////////////////////////////////////////////////////////////////
//
// __CxxSetUnhandledExceptionFilter - sets unhandled exception filter to be
// __CxxUnhandledExceptionFilter.
//
// Returns:
//      Returns 0 to indicate no error.
//

int __cdecl __CxxSetUnhandledExceptionFilter(void)
{
        pOldExceptFilter = SetUnhandledExceptionFilter(&__CxxUnhandledExceptionFilter);
        return 0;
}


/////////////////////////////////////////////////////////////////////////////
//
// __CxxRestoreUnhandledExceptionFilter - on exit, restores OldExceptFilter
//
// Returns:
//      Nothing.
//

void __cdecl __CxxRestoreUnhandledExceptionFilter(void)
{
        SetUnhandledExceptionFilter(pOldExceptFilter);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\throw.cpp ===
/***
*throw.cxx - Implementation of the 'throw' command.
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Implementation of the exception handling 'throw' command.
*
*       Entry points:
*       * _CxxThrowException - does the throw.
*
*Revision History:
*       05-25-93  BS    Module created
*       09-29-94  GJF   Made (__)pMyUnhandledExceptionFilter global so the
*                       compiler (DEC Alpha) wouldn't optimize it away.
*       10-17-94  BWT   Disable code for PPC.
*       02-03-95  BWT   Remove Alpha export hack.
*       02-09-95  JWM   Mac merge.
*       04-13-95  DAK   Add NT Kernel EH support
*       04-25-95  DAK   More Kernel work
*       03-02-98  RKP   Add 64 bit support
*       05-17-99  PML   Remove all Macintosh support.
*       03-15-00  PML   Remove CC_P7_SOFT25, which is now on permanently.
*
****/

#include <stddef.h>

#if defined(_NTSUBSET_)
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>       // STATUS_UNHANDLED_EXCEPTION
#include <ntos.h>
#include <ex.h>             // ExRaiseException
}
#endif

#include <windows.h>
#include <mtdll.h>
#include <ehdata.h>
#include <eh.h>
#include <ehhooks.h>
#include <ehassert.h>

#pragma hdrstop

//
// Make sure PULONG_PTR is available
//

#if defined(_X86_) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif

#if !defined(PULONG_PTR)
#if defined(_WIN64)
typedef unsigned __int64 *      PULONG_PTR;
#else
typedef _W64 unsigned long *    PULONG_PTR;
#endif
#endif

#if defined(_M_IA64) 
extern "C" PVOID RtlPcToFileHeader(PVOID, PVOID*);
extern "C" PVOID _ReturnAddress(VOID);
#pragma intrinsic(_ReturnAddress)
#endif

//
// Make sure the terminate wrapper is dragged in:
//

#if defined(_NTSUBSET_)
void * __pMyUnhandledExceptionFilter = 0;
#else
void * __pMyUnhandledExceptionFilter = &__CxxUnhandledExceptionFilter;
#endif

/////////////////////////////////////////////////////////////////////////////
//
// _CxxThrowException - implementation of 'throw'
//
// Description:
//      Builds the NT Exception record, and calls the NT runtime to initiate
//      exception processing.
//
//      Why is pThrowInfo defined as _ThrowInfo?  Because _ThrowInfo is secretly
//      snuck into the compiler, as is the prototype for _CxxThrowException, so
//      we have to use the same type to keep the compiler happy.
//
//      Another result of this is that _CRTIMP can't be used here.  Instead, we
//      synthesisze the -export directive below.
//
// Returns:
//      NEVER.  (until we implement resumable exceptions, that is)
//

extern "C" void __stdcall _CxxThrowException(
        void*           pExceptionObject,   // The object thrown
#if _MSC_VER >= 900 /*IFSTRIP=IGN*/
        _ThrowInfo*     pThrowInfo          // Everything we need to know about it
#else
        ThrowInfo*      pThrowInfo          // Everything we need to know about it
#endif
) {
        EHTRACE_ENTER_FMT1("Throwing object @ 0x%p", pExceptionObject);

        static const EHExceptionRecord ExceptionTemplate = { // A generic exception record
            EH_EXCEPTION_NUMBER,            // Exception number
            EXCEPTION_NONCONTINUABLE,       // Exception flags (we don't do resume)
            NULL,                           // Additional record (none)
            NULL,                           // Address of exception (OS fills in)
            EH_EXCEPTION_PARAMETERS,        // Number of parameters
            {   EH_MAGIC_NUMBER1,           // Our version control magic number
                NULL,                       // pExceptionObject
                NULL,
#if defined(_M_IA64)
                NULL                        // Image base of thrown object
#endif
            }                      // pThrowInfo
        };
        EHExceptionRecord ThisException = ExceptionTemplate;    // This exception

        //
        // Fill in the blanks:
        //
        ThisException.params.pExceptionObject = pExceptionObject;
        ThisException.params.pThrowInfo = (ThrowInfo*)pThrowInfo;
#if defined(_M_IA64)
        PVOID ThrowImageBase = RtlPcToFileHeader(_ReturnAddress(), &ThrowImageBase); 
        ThisException.params.pThrowImageBase = ThrowImageBase;
#endif

        //
        // Hand it off to the OS:
        //

        EHTRACE_EXIT;
#if defined(_NTSUBSET_)
        ExRaiseException( (PEXCEPTION_RECORD) &ThisException );
#else
        RaiseException( ThisException.ExceptionCode,
                        ThisException.ExceptionFlags,
                        ThisException.NumberParameters,
                        (PULONG_PTR)&ThisException.params );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\user.cpp ===
/***
*user.cxx - E.H. functions only called by the client programs
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Exception handling functions only called by the client programs,
*       not by the C/C++ runtime itself.
*
*       Entry Points:
*       * set_terminate
*       * set_unexpected
*       * _set_seh_translator
*       * _set_inconsistency
*
*Revision History:
*       ??-??-93  BS    Module created
*       10-17-94  BWT   Disable code for PPC.
*       02-06-95  CFW   Test only for debug build.
*       02-09-95  JWM   Mac merge.
*       05-17-99  PML   Remove all Macintosh support.
*
****/

#include <stddef.h>
#include <windows.h>
#include <mtdll.h>
#include <ehassert.h>
#include <eh.h>
#include <ehhooks.h>

#pragma hdrstop

/////////////////////////////////////////////////////////////////////////////
//
// set_terminate - install a new terminate handler (ANSI Draft 17.1.2.1.3)
//

_CRTIMP terminate_function __cdecl
set_terminate( terminate_function pNew )
{
    terminate_function pOld = NULL;

#if defined(_DEBUG)

#pragma warning(disable:4191)

    if ( (pNew == NULL) || _ValidateExecute( (FARPROC) pNew ) )

#pragma warning(default:4191)

#endif
    {
        pOld = __pTerminate;
        __pTerminate = pNew;
    }

    return pOld;
}


/////////////////////////////////////////////////////////////////////////////
//
// set_unexpected - install a new unexpected handler (ANSI Draft 17.1.2.1.3)
//

_CRTIMP unexpected_function __cdecl
set_unexpected( unexpected_function pNew )
{
    unexpected_function pOld = NULL;

#if defined(_DEBUG)

#pragma warning(disable:4191)

    if ( (pNew == NULL) || _ValidateExecute( (FARPROC) pNew ) )

#pragma warning(default:4191)

#endif
    {
        pOld = __pUnexpected;
        __pUnexpected = pNew;
    }

    return pOld;
}


/////////////////////////////////////////////////////////////////////////////
//
// _set_se_translator - install a new SE to C++ EH translator.
//
// The 'new' seh translator may be NULL, because the default one is.
//

_CRTIMP _se_translator_function __cdecl
_set_se_translator( _se_translator_function pNew )
{
    _se_translator_function pOld = NULL;

#ifdef _DEBUG

#pragma warning(disable:4191)

    if ( (pNew == NULL) || _ValidateExecute( (FARPROC)pNew ) )

#pragma warning(default:4191)

#endif
    {
        pOld = __pSETranslator;
        __pSETranslator = pNew;
    }

    return pOld;
}

/////////////////////////////////////////////////////////////////////////////
//
// _set_inconsistency - install a new inconsistency handler(Internal Error)
//
// (This function is currently not documented for end-users.  At some point,
//  it might be advantageous to allow end-users to "catch" internal errors
//  from the EH CRT, but for now, they will terminate(). )

_inconsistency_function __cdecl
__set_inconsistency( _inconsistency_function pNew)
{
    _inconsistency_function pOld = NULL;

#if defined(_DEBUG)

#pragma warning(disable:4191)

    if ( (pNew == NULL) || _ValidateExecute( (FARPROC)pNew ) )

#pragma warning(default:4191)

#endif
    {
        pOld = __pInconsistency;
        __pInconsistency = pNew;
    }

    return pOld;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\validate.cpp ===
/***
*validate.cpp - Routines to validate the data structures.
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Routines to validate the Exception Handling data structures.
*
*       Entry points:
*
*       Error reporting:
*       * EHRuntimeError - reports the error with
*         a popup or print to stderr, then quits.
*
*       Pointer validation:
*       * _ValidateRead   - Confirms that a pointer is valid for reading
*       * _ValidateWrite   - Confirms that a pointer is valid for writing
*       * _ValidateExecute - Confirms that a pointer is valid to jump to
*
*       Data structure dumpers:
*       * DumpTypeDescriptor
*       * DumpFuncInfo
*       * DumpThrowInfo
*
*       Execution tracing (only in /DENABLE_EHTRACE builds):
*       * EHTraceOutput
*
*Revision History:
*       ??-??-93  BS    Module created
*       10-17-94  BWT   Disable code for PPC.
*       04-25-95  DAK   Add Kernel EH Support
*       05-17-99  PML   Remove all Macintosh support.
*       10-22-99  PML   Add EHTRACE support
*
****/

#if defined(_NTSUBSET_)
extern "C" {
        #include <nt.h>
        #include <ntrtl.h>
        #include <nturtl.h>
        #include <ntos.h>
}
#endif

#include <windows.h>
#include <eh.h>
#include <ehassert.h>

#pragma hdrstop

#if defined(DEBUG)

int __cdecl
dprintf( char *format, ... )
{
        static char buffer[512];

        int size = vsprintf( buffer, format, (char*)(&format+1) );
#if defined(_NTSUBSET_)
        DbgPrint( buffer );
#else
        OutputDebugString( buffer );
#endif

return size;
}

#endif

BOOL
_ValidateRead( const void *data, UINT size )
{
        BOOL bValid = TRUE;
#if defined(_NTSUBSET_)
//      bValid = MmIsSystemAddressAccessable( (PVOID) data );
#else
        if ( IsBadReadPtr( data, size ) ) {
            dprintf( "_ValidateRead( %p, %d ): Invalid Pointer!", data, size );
            //  terminate(); // terminate does not return.
            bValid = FALSE;
        }
#endif
        return bValid;
}

BOOL
_ValidateWrite( void *data, UINT size )
{
        BOOL bValid = TRUE;
#if defined(_NTSUBSET_)
//      bValid = MmIsSystemAddressAccessable( (PVOID) data );
#else
        if ( IsBadWritePtr( data, size ) ) {
            dprintf( "_ValidateWrite( %p, %d ): Invalid Pointer!", data, size );
//          terminate(); // terminate does not return.
            bValid = FALSE;
        }
#endif
        return bValid;
}

BOOL
_ValidateExecute( FARPROC code )
{
        BOOL    bValid = TRUE;
#if defined(_NTSUBSET_)
        bValid = _ValidateRead(code, sizeof(FARPROC) );
#else
        if ( IsBadCodePtr( code ) ) {
            dprintf( "_ValidateExecute( %p ): Invalid Function Address!", code );
//          terminate(); // terminate does not return
            bValid = FALSE;
        }
#endif
        return bValid;
}


#if defined(DEBUG) && defined(_M_IX86)
//
// dbRNListHead - returns current value of FS:0.
//
// For debugger use only, since debugger doesn't seem to be able to view the
// teb.
//
EHRegistrationNode *dbRNListHead(void)
{
        EHRegistrationNode *pRN;

        __asm {
            mov     eax, dword ptr FS:[0]
            mov     pRN, eax
            }

        return pRN;
}
#endif

#ifdef  ENABLE_EHTRACE

#include <stdio.h>
#include <stdarg.h>

//
// Current EH tracing depth, stack for saving levels during __finally block
// or __except filter.
//
int __ehtrace_level;
int __ehtrace_level_stack_depth;
int __ehtrace_level_stack[128];

//
// EHTraceOutput - Dump formatted string to OutputDebugString
//
void __cdecl EHTraceOutput(const char *format, ...)
{
    va_list arglist;
    char buf[1024];

    sprintf(buf, "%p ", &format);
    OutputDebugString(buf);

    va_start(arglist, format);
    _vsnprintf(buf, sizeof(buf), format, arglist);

    OutputDebugString(buf);
}

//
// EHTraceIndent - Return string for current EH tracing depth
//
const char*EHTraceIndent(int level)
{
    static char indentbuf[128 + 1];

    // Reset global level to recover from stack unwinds
    __ehtrace_level = level;

    int depth = max(0, level - 1);
    if (depth > (sizeof(indentbuf) - 1) / 2) {
        depth = (sizeof(indentbuf) - 1) / 2;
    }

    for (int i = 0; i < depth; ++i) {
        indentbuf[2 * i] = '|';
        indentbuf[2 * i + 1] = ' ';
    }
    indentbuf[2 * depth] = '\0';

    return indentbuf;
}

//
// EHTraceFunc - Chop down __FUNCTION__ to simple name
//
const char *EHTraceFunc(const char *func)
{
    static char namebuf[128];

    const char *p = func + strlen(func) - 1;

    if (*p != ')') {
        // Name already simple (no arg list found)
        return func;
    }

    // Skip backwards past the argument list
    int parendepth = 1;
    while (p > func && parendepth > 0) {
        switch (*--p) {
        case '(':
            --parendepth;
            break;
        case ')':
            ++parendepth;
            break;
        }
    }

    // Find beginning of name
    // TODO: Won't work for funcs which return func-ptrs
    const char *pEnd = p;
    while (p > func && p[-1] != ' ') {
        --p;
    }

    size_t len = min(pEnd - p, sizeof(namebuf) - 1);
    memcpy(namebuf, p, len);
    namebuf[len] = '\0';

    return namebuf;
}

//
// EHTracePushLevel - Push current trace depth on stack to allow temporary
// resetting of level with __finally block or __except filter.
//
void EHTracePushLevel(int new_level)
{
    if (__ehtrace_level_stack_depth < sizeof(__ehtrace_level_stack) / sizeof(__ehtrace_level_stack[0])) {
        __ehtrace_level_stack[__ehtrace_level_stack_depth] = __ehtrace_level;
    }
    ++__ehtrace_level_stack_depth;
    __ehtrace_level = new_level;
}

//
// EHTracePopLevel - Pop saved trace depth from stack on completion of
// __finally block or __except filter, and optionally restore global depth.
//

void EHTracePopLevel(bool restore)
{
    --__ehtrace_level_stack_depth;
    if (restore &&
        __ehtrace_level_stack_depth < sizeof(__ehtrace_level_stack) / sizeof(__ehtrace_level_stack[0]))
    {
        __ehtrace_level = __ehtrace_level_stack[__ehtrace_level_stack_depth];
    }
}

//
// EHTraceExceptFilter - Dump trace info for __except filter.  Trace level must
// have been pushed before entry with EHTracePushLevel, so any functions called
// for the 'expr' argument are dumped at the right level.
//
int EHTraceExceptFilter(const char *func, int expr)
{
    EHTraceOutput("In   : %s%s: __except filter returns %d (%s)\n",
                  EHTraceIndent(__ehtrace_level), EHTraceFunc(func), expr,
                  expr < 0 ? "EXCEPTION_CONTINUE_EXECUTION" :
                  expr > 0 ? "EXCEPTION_EXECUTE_HANDLER" :
                  "EXCEPTION_CONTINUE_SEARCH");

    EHTracePopLevel(expr <= 0);
    return expr;
}

//
// EHTraceHandlerReturn - Dump trace info for exception handler return
//
void EHTraceHandlerReturn(const char *func, int level, EXCEPTION_DISPOSITION result)
{
    EHTraceOutput( "Exit : %s%s: Handler returning %d (%s)\n", \
                   EHTraceIndent(level), EHTraceFunc(func), result,
                   result == ExceptionContinueExecution ? "ExceptionContinueExecution" :
                   result == ExceptionContinueSearch ? "ExceptionContinueSearch" :
                   result == ExceptionNestedException ? "ExceptionNestedException" :
                   result == ExceptionCollidedUnwind ? "ExceptionCollidedUnwind" :
                   "unknown" );
}

#endif  /* ENABLE_EHTRACE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\xundname.cpp ===
// Forwarder for use in the NT build
#include <undname.cxx>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\i386\ehprolog.asm ===
;***
;ehprolog.asm   - defines __EH_prolog
;
;	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       EH prolog helper function. Sets up the frame for a C++ EH function
;       with unwinds, by creating a link in the __except_list, and by setting
;       up EBP as frame base pointer.
;
;Revision History:
;	10-27-94  LL	Module created.
;	10-27-94  CFW	Comments added.
;	01-11-95  SKS	Remove MASM 5.X support
;
;*******************************************************************************
	title	ehprolog.asm
	.386P

.model FLAT

	ASSUME	FS: FLAT

PUBLIC	__EH_prolog

_TEXT	SEGMENT

__EH_prolog PROC NEAR
	push	-1			; State index
	push	eax			; Push address of handler thunk
	mov	eax, DWORD PTR fs:0
	push	eax			; List link
	mov	eax, DWORD PTR [esp+12]	; Load return address
	mov	DWORD PTR fs:0, esp
	mov	DWORD PTR [esp+12], ebp	; Save old ebp on the stack
	lea	ebp, DWORD PTR [esp+12]	; Set ebp to the base of the frame
	push	eax			; Push return addr on top of the stack
	ret	0			; JMP [eax] would be bad on P6
__EH_prolog ENDP

_TEXT	ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\i386\lowhelpr.asm ===
;***
;lowhelpr.asm
;
;	Copyright (C) 1995-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Contains _CallSettingFrame(), which must be in asm for NLG purposes.
;
;Notes:
;
;Revision History:
;	03-30-95  JWM	Module created.
;	06-09-95  JWM	NLG_CATCH_LEAVE now implemented.
;	08-21-95  JWM	Bug fix: Olympus 16585.
;	08-30-96  SKS	Save esi, edi around call to funclet
;	09-12-95  JWM	labvel _NLG_Return moved above new pops (Orion 9224).
;	03-09-01  PML   Add FPO directives for proper callstacks (vs7#221754)
;
;*******************************************************************************
	title	lowhelpr.asm

.xlist
	include cruntime.inc
	include exsup.inc
.list

EXTERN	_NLG_Notify:NEAR
EXTERN	_NLG_Notify1:NEAR
PUBLIC	_CallSettingFrame
PUBLIC	_NLG_Return
extern	_NLG_Destination:_NLG_INFO


CODESEG

;////////////////////////////////////////////////////////////////////////////
;/
;/ _CallSettingFrame - sets up EBP and calls the specified funclet.  Restores
;/					  EBP on return.  
;/
;/ Return value is return value of funclet (whatever is in EAX).
;/


	public _CallSettingFrame

_CallSettingFrame proc stdcall, funclet:IWORD, pRN:IWORD, dwInCode:DWORD
	; FPO = 0 dwords locals allocated in prolog
	;       3 dword parameters
	;       8 bytes in prolog
	;       4 registers saved (includes locals to work around debugger bug)
	;       1 EBP is used
	;       0 frame type = FPO
	.FPO    (0,3,8,4,1,0)

	sub	esp,4
	push	ebx
	push	ecx
	mov	eax,pRN
	add	eax,0Ch			; TODO - need sizeof(EHRegistrationNode), not 0Ch
	mov	dword ptr [ebp-4],eax
	mov	eax,funclet
	push	ebp			; Save our frame pointer
        push    dwInCode
	mov	ecx,dwInCode
	mov	ebp,dword ptr [ebp-4]	; Load target frame pointer
	call	_NLG_Notify1		; Notify debugger
	push	esi
	push	edi
	call	eax			; Call the funclet
_NLG_Return::
	pop	edi
	pop	esi
	mov	ebx,ebp
	pop	ebp
        mov     ecx,dwInCode
	push	ebp
	mov	ebp,ebx
	cmp	ecx, 0100h
	jne	_NLG_Continue
        mov     ecx, 02h
_NLG_Continue:
        push    ecx
	call	_NLG_Notify1		; Notify debugger yet again
	pop	ebp			; Restore our frame pointer
	pop	ecx
	pop	ebx
	ret	0Ch
_CallSettingFrame ENDP

	END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\i386\ehprolg2.c ===
/***
*ehprolg2.c - Defines _EH_prolog2 compiler helper
*
*       Copyright (c) 1999-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       EH prologue helper function for an aligned stack.
*
*Revision History:
*       11-14-99  JB    Module created
*
****/

/***
*void _EH_prolog2(alignment) - set up aligned stack with EH frame
*
*Purpose:
*       Sets up an aligned frame for a C++ EH function with unwinds, by
*       creating a link in the __except_list, setting EBX as the frame
*       parameter pointer, and EBP as the frame base pointer.
*
*Entry:
*       EAX = address of EH handler thunk
*       Incoming stack frame has:
*           [ESP + 8] = callee's return address
*           [ESP + 4] = stack alignment requirement
*           [ESP + 0] = _EH_prolog2's return address
*
*Exit:
*       EAX = destroyed
*       EBX = pointer to callee's parameters
*       EBP = aligned pointer to callee's locals
*       ESP = EBP - 12
*       FS:[0] = set to EBP-8 to create new link in EH chain
*       Stack frame has been set up as follows:
*           [EBX + 4]  = (entry [ESP+8]) callee's return address
*           [EBX + 0]  = saved EBX
*           padding to align stack (if needed)
*           [EBP + 4]  = callee's return address (from [EBX+4])
*           [EBP + 0]  = saved EBP
*           [EBP - 4]  = EH record state index, initialized to -1
*           [EBP - 8]  = address of EH handler thunk
*           [EBP - 12] = saved FS:[0]
*
*Exceptions:
*
*******************************************************************************/

void __declspec(naked) _EH_prolog2(void)
{
    /*
     * We want to generate a frame that is equivalent to
     * push ebx
     * ebx = esp
     * sub esp, 8
     * and esp, ~alignment
     * add esp, 4
     * push ebp
     * ebp = esp
     * mov [ebp+4], [ebx+4]
     * [EH record]
     */

    __asm {
        ; stack has:
        ; alignment
        ; ret addr   <== esp
    
        push        ecx           ; save ecx
                                  ; with ret addr == sub esp, 8

        ; stack has:
        ; alignment
        ; ret addr
        ; saved ecx  <== esp

        mov         ecx, [esp+8]  ; get alignment

        mov         [esp+8], ebx  ; save ebx over alignment
        lea         ebx, [esp+8]  ; set param pointer

        ; stack has:
        ; saved ebx  <== ebx
        ; ret addr
        ; saved ecx  <== esp

        neg         ecx           ; create alignment mask
        and         esp, ecx      ; align stack

        mov         ecx, [ebx-8]  ; restore ecx since it will be in the same
                                  ; location we want to store ebp if no
                                  ; padding is inserted (esp is aligned at and)
        
        mov         [esp], ebp    ; save ebp
        mov         ebp, esp      ; initialize ebp
        
        ; stack has
        ; saved ebx  <== ebx
        ; ret addr
        ; [padding]
        ; saved ebp  <== ebp, esp

        push        -1            ; create EH record
        push        eax
        mov         eax,fs:[00000000]
        push        eax
        mov         dword ptr fs:[0],esp

        push        ecx           ; we need this again

        mov         eax, [ebx-4]  ; get helper return address 

        mov         ecx, [ebx+4]  ; copy orig function caller return address
        mov         [ebp+4], ecx  ; (for ebp-based stack walks)

        pop         ecx           ; we are done

        push        eax           ; eax has return address

        ret
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\eh\i386\trnsctrl.cpp ===
/***
*trnsctrl.cxx -  Routines for doing control transfers
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Routines for doing control transfers; written using inline
*       assembly in naked functions.  Contains the public routine
*       _CxxFrameHandler, the entry point for the frame handler
*
*Revision History:
*       05-24-93  BES   Module created
*       01-13-95  JWM   NLG notifications now called from _CallSettingFrame().
*       04-10-95  JWM   _CallSettingFrame() moved to lowhelpr.asm
*       10-22-99  PML   Add EHTRACE support
*       11-30-99  PML   Compile /Wp64 clean.
*       01-31-00  PML   Disable new warning C4851
*       02-14-00  PML   C4851 in VC6PP is C4731 in VC7
*       03-02-00  PML   Preserve callee-save regs across RtlUnwind (VS7#83643).
*       03-03-00  PML   No more C4851, it's only C4731
*
****/

#include <windows.h>

#include <mtdll.h>

#include <ehdata.h>
#include <trnsctrl.h>
#include <eh.h>
#include <ehhooks.h>
#include <ehassert.h>

#pragma hdrstop

#include <setjmp.h>

#pragma warning(disable:4311 4312)      // x86 specific, ignore /Wp64 warnings
#pragma warning(disable:4731)           // ignore EBP mod in inline-asm warning

#ifdef _MT
#define pFrameInfoChain   (*((FRAMEINFO **)    &(_getptd()->_pFrameInfoChain)))
#else
static FRAMEINFO          *pFrameInfoChain     = NULL;        // used to remember nested frames
#endif

/////////////////////////////////////////////////////////////////////////////
//
// _JumpToContinuation - sets up EBP and jumps to specified code address.
//
// Does not return.
//
// NT leaves a marker registration node at the head of the list, under the
// assumption that RtlUnwind will remove it.  As it happens, we need to keep
// it in case of a rethrow (see below).  We only remove the current head
// (assuming it is NT's), because there may be other nodes that we still
// need.
//

void __stdcall _JumpToContinuation(
    void                *target,    // The funclet to call
    EHRegistrationNode  *pRN        // Registration node, represents location of frame
) {
    EHTRACE_ENTER_FMT1("Transfer to 0x%p", target);
    EHTRACE_RESET;

    register long targetEBP;

#if !CC_EXPLICITFRAME
    targetEBP = (long)pRN + FRAME_OFFSET;
#else
    targetEBP = pRN->frame;
#endif

    __asm {
        //
        // Unlink NT's marker node:
        //
        mov     ebx, FS:[0]
        mov     eax, [ebx]
        mov     FS:[0], eax

        //
        // Transfer control to the continuation point
        //
        mov     eax, target         // Load target address
        mov     ebx, pRN            // Restore target esp
        mov     esp, [ebx-4]
        mov     ebp, targetEBP      // Load target frame pointer
        jmp     eax                 // Call the funclet
        }
    }


/////////////////////////////////////////////////////////////////////////////
//
// _CallMemberFunction0 - call a parameterless member function using __thiscall
//                       calling convention, with 0 parameters.
//

__declspec(naked) void __stdcall _CallMemberFunction0(
    void *pthis,        // Value for 'this' pointer
    void *pmfn          // Pointer to the member function
) {
    __asm {
        pop     eax         // Save return address
        pop     ecx         // Get 'this'
        xchg    [esp],eax   // Get function address, stash return address
        jmp     eax         // jump to the function (function will return
                            // to caller of this func)
        }
    }


/////////////////////////////////////////////////////////////////////////////
//
// _CallMemberFunction1 - call a member function using __thiscall
//                       calling convention, with 1 parameter.
//

__declspec(naked) void __stdcall _CallMemberFunction1(
    void *pthis,        // Value for 'this' pointer
    void *pmfn,         // Pointer to the member function
    void *pthat         // Value of 1st parameter (type assumes copy ctor)
) {
    __asm {
        pop     eax         // Save return address
        pop     ecx         // Get 'this'
        xchg    [esp],eax   // Get function address, stash return address
        jmp     eax         // jump to the function (function will return
                            // to caller of this func)
        }
    }


/////////////////////////////////////////////////////////////////////////////
//
// _CallMemberFunction2 - call a member function using __thiscall
//                       calling convention, with 2 parameter.
//

__declspec(naked) void __stdcall _CallMemberFunction2(
    void *pthis,        // Value for 'this' pointer
    void *pmfn,         // Pointer to the member function
    void *pthat,        // Value of 1st parameter (type assumes copy ctor)
    int   val2          // Value of 2nd parameter (type assumes copy ctor w/vb)
) {
    __asm {
        pop     eax         // Save return address
        pop     ecx         // Get 'this'
        xchg    [esp],eax   // Get function address, stash return address
        jmp     eax         // jump to the function (function will return
                            // to caller of this func)
        }
    }


/////////////////////////////////////////////////////////////////////////////
//
// _UnwindNestedFrames - Call RtlUnwind, passing the address after the call
//                      as the continuation address.
//
//  Win32 assumes that after a frame has called RtlUnwind, it will never return
// to the dispatcher.
//
// Let me explain:  
//  When the dispatcher calls a frame handler while searching
// for the appropriate handler, it pushes an extra guard registration node
// onto the list.  When the handler returns to the dispatcher, the dispatcher
// assumes that its node is at the head of the list, restores esp from the
// address of the head node, and then unlinks that node from the chain.
//  However, if RtlUnwind removes ALL nodes below the specified node, including
// the dispatcher's node, so without intervention the result is that the 
// current subject node gets poped from the list, and the stack pointer gets
// reset to somewhere within the frame of that node, which is totally bogus
// (this last side effect is not a problem, because esp is then immediately
// restored from the ebp chain, which is still valid).
//
// So:
//  To get arround this, WE ASSUME that the registration node at the head of
// the list is the dispatcher's marker node (which it is in NT 1.0), and
// we keep a handle to it when we call RtlUnwind, and then link it back in
// after RtlUnwind has done its stuff.  That way, the dispatcher restores
// its stack exactly as it expected to, and leave our registration node alone.
//
// What happens if there is an exception during the unwind?
// We can't put a registration node here, because it will be removed 
// immediately.
//
// RtlUnwind:
//  RtlUnwind is evil.  It trashes all the registers except EBP and ESP.
// Because of that, EBX, ESI, and EDI must be preserved by this function,
// and the compiler may not assume that any callee-save register can be used
// across the call to RtlUnwind.  To accomplish the former, inline-asm code
// here uses EBX, ESI, and EDI, so they will be saved in the prologue.  For
// the latter, optimizations are disabled for the duration of this function.
//

#pragma optimize("g", off)      // WORKAROUND for DOLPH:3322

void __stdcall _UnwindNestedFrames(
    EHRegistrationNode *pRN,        // Unwind up to (but not including) this frame
    EHExceptionRecord   *pExcept    // The exception that initiated this unwind
) {
    EHTRACE_ENTER;

    void* pReturnPoint;
    EHRegistrationNode *pDispatcherRN;  // Magic!

    __asm {
        //
        // Save the dispatcher's marker node
        //
        // NOTE: RtlUnwind will trash the callee-save regs EBX, ESI, and EDI.
        // We explicitly use them here in the inline-asm so they get preserved
        // and restored by the function prologue/epilogue.
        //
        mov     esi, dword ptr FS:[0]   // use ESI
        mov     pDispatcherRN, esi
    }

    __asm mov pReturnPoint, offset ReturnPoint
    RtlUnwind(pRN, pReturnPoint, (PEXCEPTION_RECORD)pExcept, NULL);

ReturnPoint:

    PER_FLAGS(pExcept) &= ~EXCEPTION_UNWINDING; // Clear the 'Unwinding' flag
                                                // in case exception is rethrown
    __asm {
        //
        // Re-link the dispatcher's marker node
        //
        mov     edi, dword ptr FS:[0]   // Get the current head (use EDI)
        mov     ebx, pDispatcherRN      // Get the saved head (use EBX)
        mov     [ebx], edi              // Link saved head to current head
        mov     dword ptr FS:[0], ebx   // Make saved head current head
        }

    EHTRACE_EXIT;

    return;
    }

#pragma optimize("", on)

/////////////////////////////////////////////////////////////////////////////
//
// __CxxFrameHandler - Real entry point to the runtime; this thunk fixes up
//      the parameters, and then calls the workhorse.
//
extern "C" EXCEPTION_DISPOSITION __cdecl __InternalCxxFrameHandler(
    EHExceptionRecord  *pExcept,        // Information for this exception
    EHRegistrationNode *pRN,            // Dynamic information for this frame
    void               *pContext,       // Context info (we don't care what's in it)
    DispatcherContext  *pDC,            // More dynamic info for this frame (ignored on Intel)
    FuncInfo           *pFuncInfo,      // Static information for this frame
    int                 CatchDepth,     // How deeply nested are we?
    EHRegistrationNode *pMarkerRN,      // Marker node for when checking inside
                                        //  catch block
    BOOL                recursive);     // True if this is a translation exception

extern "C" _CRTIMP __declspec(naked) EXCEPTION_DISPOSITION __cdecl __CxxFrameHandler(
/*
    EAX=FuncInfo   *pFuncInfo,          // Static information for this frame
*/
    EHExceptionRecord  *pExcept,        // Information for this exception
    EHRegistrationNode *pRN,            // Dynamic information for this frame
    void               *pContext,       // Context info (we don't care what's in it)
    DispatcherContext  *pDC             // More dynamic info for this frame (ignored on Intel)
) {
    FuncInfo   *pFuncInfo;
    EXCEPTION_DISPOSITION result;

    __asm {
        //
        // Standard function prolog
        //
        push    ebp
        mov     ebp, esp
        sub     esp, __LOCAL_SIZE
        push    ebx
        push    esi
        push    edi
        cld             // A bit of paranoia -- Our code-gen assumes this

        //
        // Save the extra parameter
        //
        mov     pFuncInfo, eax
        }

    EHTRACE_ENTER_FMT1("pRN = 0x%p", pRN);

    result = __InternalCxxFrameHandler( pExcept, pRN, pContext, pDC, pFuncInfo, 0, NULL, FALSE );

    EHTRACE_HANDLER_EXIT(result);

    __asm {
        pop     edi
        pop     esi
        pop     ebx
        mov     eax, result
        mov     esp, ebp
        pop     ebp
        ret     0
        }
}

/////////////////////////////////////////////////////////////////////////////
//
// __CxxLongjmpUnwind - Entry point for local unwind required by longjmp
//      when setjmp used in same function as C++ EH.
//
extern "C" void __FrameUnwindToState(   // in frame.cpp
    EHRegistrationNode *pRN,            // Dynamic information for this frame
    DispatcherContext  *pDC,            // More dynamic info for this frame (ignored on Intel)
    FuncInfo           *pFuncInfo,      // Static information for this frame
    __ehstate_t         targetState);   // State to unwind to

extern "C" void __stdcall __CxxLongjmpUnwind(
    _JUMP_BUFFER       *jbuf
) {
    EHTRACE_ENTER;

    __FrameUnwindToState((EHRegistrationNode *)jbuf->Registration,
                         (DispatcherContext*)NULL,
                         (FuncInfo *)jbuf->UnwindData[0],
                         (__ehstate_t)jbuf->TryLevel);

    EHTRACE_EXIT;
}

/////////////////////////////////////////////////////////////////////////////
//
// _CallCatchBlock2 - The nitty-gritty details to get the catch called
//      correctly.
//
// We need to guard the call to the catch block with a special registration
// node, so that if there is an exception which should be handled by a try
// block within the catch, we handle it without unwinding the SEH node
// in CallCatchBlock.
//

struct CatchGuardRN {
    EHRegistrationNode *pNext;          // Frame link
    void               *pFrameHandler;  // Frame Handler
    FuncInfo           *pFuncInfo;      // Static info for subject function
    EHRegistrationNode *pRN;            // Dynamic info for subject function
    int                 CatchDepth;     // How deeply nested are we?
#if defined(ENABLE_EHTRACE) && (_MSC_VER >= 1300)
    int                 trace_level;    // Trace level to restore in handler
#endif
    };

static EXCEPTION_DISPOSITION __cdecl CatchGuardHandler( EHExceptionRecord*, CatchGuardRN *, void *, void * );

void *_CallCatchBlock2(
    EHRegistrationNode *pRN,            // Dynamic info of function with catch
    FuncInfo           *pFuncInfo,      // Static info of function with catch
    void               *handlerAddress, // Code address of handler
    int                CatchDepth,      // How deeply nested in catch blocks are we?
    unsigned long      NLGCode
) {
    EHTRACE_ENTER;

    //
    // First, create and link in our special guard node:
    //
    CatchGuardRN CGRN = { NULL,
                          (void*)CatchGuardHandler,
                          pFuncInfo,
                          pRN,
                          CatchDepth + 1
#if defined(ENABLE_EHTRACE) && (_MSC_VER >= 1300)
                          , __ehtrace_level
#endif
    };

    __asm {
        mov     eax, FS:[0]     // Fetch frame list head
        mov     CGRN.pNext, eax // Link this node in
        lea     eax, CGRN       // Put this node at the head
        mov     FS:[0], eax
        }

    //
    // Call the catch
    //
    void *continuationAddress = _CallSettingFrame( handlerAddress, pRN, NLGCode );

    //
    // Unlink our registration node
    //
    __asm {
        mov     eax, CGRN.pNext // Get parent node
        mov     FS:[0], eax     // Put it at the head
        }

    EHTRACE_EXIT;

    return continuationAddress;
    }


/////////////////////////////////////////////////////////////////////////////
//
// CatchGuardHandler - frame handler for the catch guard node.
//
// This function will attempt to find a handler for the exception within
// the current catch block (ie any nested try blocks).  If none is found,
// or the handler rethrows, returns ExceptionContinueSearch; otherwise does
// not return.
//
// Does nothing on an unwind.
//

static EXCEPTION_DISPOSITION __cdecl CatchGuardHandler( 
    EHExceptionRecord  *pExcept,        // Information for this exception
    CatchGuardRN       *pRN,            // The special marker frame
    void               *pContext,       // Context info (we don't care what's in it)
    void *                              // (ignored)
) {
#if defined(ENABLE_EHTRACE) && (_MSC_VER >= 1300)
    EHTracePushLevel(pRN->trace_level);
#endif
    EHTRACE_ENTER_FMT1("pRN = 0x%p", pRN);

    __asm cld;      // Our code-gen assumes this
        
    EXCEPTION_DISPOSITION result =
        __InternalCxxFrameHandler( pExcept,
                                   pRN->pRN,
                                   pContext,
                                   NULL,
                                   pRN->pFuncInfo,
                                   pRN->CatchDepth,
                                   (EHRegistrationNode*)pRN,
                                   FALSE );

    EHTRACE_HANDLER_EXIT(result);
    EHTRACE_RESTORE_LEVEL(true);
    return result;
    }


/////////////////////////////////////////////////////////////////////////////
//
// CallSEHTranslator - calls the SEH translator, and handles the translation
//      exception.
//
// Assumes that a valid translator exists.
//
// Method:
//  Sets up a special guard node, whose handler handles the translation 
// exception, and remembers NT's marker node (See _UnwindNestedFrames above).
// If the exception is not fully handled, the handler returns control to here,
// so that this function can return to resume the normal search for a handler
// for the original exception.
//
// Returns: TRUE if translator had a translation (handled or not)
//          FALSE if there was no translation
//          Does not return if translation was fully handled
//

struct TranslatorGuardRN /*: CatchGuardRN */ {
    EHRegistrationNode *pNext;          // Frame link
    void               *pFrameHandler;  // Frame Handler
    FuncInfo           *pFuncInfo;      // Static info for subject function
    EHRegistrationNode *pRN;            // Dynamic info for subject function
    int                 CatchDepth;     // How deeply nested are we?
    EHRegistrationNode *pMarkerRN;      // Marker for parent context
    void               *pContinue;      // Continuation address within CallSEHTranslator
    void               *ESP;            // ESP within CallSEHTranslator
    void               *EBP;            // EBP within CallSEHTranslator
    BOOL                DidUnwind;      // True if this frame was unwound
#if defined(ENABLE_EHTRACE) && (_MSC_VER >= 1300)
    int                 trace_level;    // Trace level to restore in handler
#endif
    };

static EXCEPTION_DISPOSITION __cdecl TranslatorGuardHandler( EHExceptionRecord*, TranslatorGuardRN *, void *, void * );

#pragma optimize("g", off)              // WORKAROUND for DOLPH:3322

BOOL _CallSETranslator(
    EHExceptionRecord  *pExcept,        // The exception to be translated
    EHRegistrationNode *pRN,            // Dynamic info of function with catch
    void               *pContext,       // Context info (we don't care what's in it)
    DispatcherContext  *pDC,            // More dynamic info of function with catch (ignored)
    FuncInfo           *pFuncInfo,      // Static info of function with catch
    int                 CatchDepth,     // How deeply nested in catch blocks are we?
    EHRegistrationNode *pMarkerRN       // Marker for parent context
) {
    EHTRACE_ENTER;

    //
    // Create and link in our special guard node:
    //
    TranslatorGuardRN TGRN = {  NULL,       // Frame link
                                (void*)TranslatorGuardHandler, 
                                pFuncInfo, 
                                pRN, 
                                CatchDepth,
                                pMarkerRN,
                                NULL,       // Continue
                                NULL,       // ESP
                                NULL,       // EBP
                                FALSE       // DidUnwind
#if defined(ENABLE_EHTRACE) && (_MSC_VER >= 1300)
                                , __ehtrace_level
#endif
    };

    __asm {
        //
        // Fill in the blanks:
        //
        mov     TGRN.pContinue, offset ExceptionContinuation
        mov     TGRN.ESP, esp
        mov     TGRN.EBP, ebp

        //
        // Link this node in:
        //
        mov     eax, FS:[0]             // Fetch frame list head
        mov     TGRN.pNext, eax         // Link this node in
        lea     eax, TGRN               // Put this node at the head
        mov     FS:[0], eax
        }

    //
    // Call the translator; assume it will give a translation.
    //
    BOOL DidTranslate = TRUE;
    _EXCEPTION_POINTERS pointers = {
        (PEXCEPTION_RECORD)pExcept,
        (PCONTEXT)pContext };

    __pSETranslator(PER_CODE(pExcept), &pointers);

    //
    // If translator returned normally, that means it didn't translate the
    // exception.
    //
    DidTranslate = FALSE;

    //
    // Here's where we pick up if the translator threw something.
    // Note that ESP and EBP were restored by our frame handler.
    //
ExceptionContinuation:
    
    if (TGRN.DidUnwind) {
        //
        // If the translated exception was partially handled (ie caught but
        // rethrown), then the frame list has the NT guard for the translation
        // exception context instead of the one for the original exception 
        // context.  Correct that sequencing problem.  Note that our guard
        // node was unlinked by RtlUnwind.
        //
        __asm {
            mov     ebx, FS:[0]     // Get the node below the (bad) NT marker
            mov     eax, [ebx]      //  (it was the target of the unwind)
            mov     ebx, TGRN.pNext // Get the node we saved (the 'good' marker)
            mov     [ebx], eax      // Link the good node to the unwind target
            mov     FS:[0], ebx     // Put the good node at the head of the list
            }
        }
    else {
        //
        // Translator returned normally or translation wasn't handled.
        // unlink our registration node and exit
        //
        __asm {
            mov     eax, TGRN.pNext // Get parent node
            mov     FS:[0], eax     // Put it at the head
            }
        }

    EHTRACE_EXIT;

    return DidTranslate;
    }

#pragma optimize("g", on)


/////////////////////////////////////////////////////////////////////////////
//
// TranslatorGuardHandler - frame handler for the translator guard node.
//
// On search:
//  This frame handler will check if there is a catch at the current level
//  for the translated exception.  If there is no handler or the handler
//  did a re-throw, control is transfered back into CallSEHTranslator, based
//  on the values saved in the registration node.
//
//  Does not return.
//
// On unwind:
//  Sets the DidUnwind flag in the registration node, and returns.
//
static EXCEPTION_DISPOSITION __cdecl TranslatorGuardHandler( 
    EHExceptionRecord  *pExcept,        // Information for this exception
    TranslatorGuardRN  *pRN,            // The translator guard frame
    void               *pContext,       // Context info (we don't care what's in it)
    void *                              // (ignored)
) {
#if defined(ENABLE_EHTRACE) && (_MSC_VER >= 1300)
    EHTracePushLevel(pRN->trace_level);
#endif
    EHTRACE_ENTER_FMT1("pRN = 0x%p", pRN);

    __asm cld;      // Our code-gen assumes this

    if (IS_UNWINDING(PER_FLAGS(pExcept))) 
        {
        pRN->DidUnwind = TRUE;

        EHTRACE_HANDLER_EXIT(ExceptionContinueSearch);
        EHTRACE_RESTORE_LEVEL(true);
        return ExceptionContinueSearch;
        }
    else {
        //
        // Check for a handler:
        //
        __InternalCxxFrameHandler( pExcept, pRN->pRN, pContext, NULL, pRN->pFuncInfo, pRN->CatchDepth, pRN->pMarkerRN, TRUE );

        if (!pRN->DidUnwind) {
            //
            // If no match was found, unwind the context of the translator
            //
            _UnwindNestedFrames( (EHRegistrationNode*)pRN, pExcept );
            }

        //
        // Transfer control back to establisher:
        //

        EHTRACE_FMT1("Transfer to establisher @ 0x%p", pRN->pContinue);
        EHTRACE_RESTORE_LEVEL(false);
        EHTRACE_EXIT;

        __asm {
            mov     ebx, pRN    // Get address of registration node
            mov     esp, [ebx]TranslatorGuardRN.ESP
            mov     ebp, [ebx]TranslatorGuardRN.EBP
            jmp     [ebx]TranslatorGuardRN.pContinue
            }

        // Unreached.
        return ExceptionContinueSearch;
        }
    }


/////////////////////////////////////////////////////////////////////////////
//
// _GetRangeOfTrysToCheck - determine which try blocks are of interest, given
//   the current catch block nesting depth.  We only check the trys at a single
//   depth.
//
// Returns:
//      Address of first try block of interest is returned
//      pStart and pEnd get the indices of the range in question
//

TryBlockMapEntry* _GetRangeOfTrysToCheck(
        FuncInfo   *pFuncInfo,
        int                     CatchDepth,
        __ehstate_t curState,
        unsigned   *pStart,
        unsigned   *pEnd
) {
        TryBlockMapEntry *pEntry = FUNC_PTRYBLOCK(*pFuncInfo, 0);
        unsigned start = FUNC_NTRYBLOCKS(*pFuncInfo);
        unsigned end = start;
        unsigned end1 = end;

        while (CatchDepth >= 0) {
                DASSERT(start != -1);
                start--;
                if ( TBME_HIGH(pEntry[start]) < curState && curState <= TBME_CATCHHIGH(pEntry[start])
                        || (start == -1)
                ) {
                        CatchDepth--;
                        end = end1;
                        end1 = start;
                        }
                }

        *pStart = ++start;              // We always overshoot by 1 (we may even wrap around)
        *pEnd = end;

        DASSERT( end <= FUNC_NTRYBLOCKS(*pFuncInfo) && start <= end );

        return &(pEntry[start]);
        }


/////////////////////////////////////////////////////////////////////////////
//
// _CreateFrameInfo - Save the frame information for this scope just before
//  calling the catch block.  Put it at the head of the linked list.  For
//  x86, all we need to save is the pointer to the exception object, so we
//  can determine when that object is no longer used by any nested catch
//  handler and can thus be destroyed on exiting from a catch.
//
// Returns:
//      Pointer to the frame info (the first input argument).
//
FRAMEINFO * _CreateFrameInfo(    
    FRAMEINFO * pFrameInfo,
    PVOID       pExceptionObject   
) {
    pFrameInfo->pExceptionObject = pExceptionObject;
    pFrameInfo->pNext            = (pFrameInfo < pFrameInfoChain)? pFrameInfoChain : NULL;
    pFrameInfoChain              = pFrameInfo;
    return pFrameInfo;
}

/////////////////////////////////////////////////////////////////////////////
//
// IsExceptionObjectToBeDestroyed - Determine if an exception object is still
//  in use by a more deeply nested catch frame, or if it unused and should be
//  destroyed on exiting from the current catch block.
//
// Returns:
//      TRUE if exception object not found and should be destroyed.
//
BOOL IsExceptionObjectToBeDestroyed(
    PVOID pExceptionObject
) {
    FRAMEINFO * pFrameInfo;

    for (pFrameInfo = pFrameInfoChain; pFrameInfo != NULL; pFrameInfo = pFrameInfo->pNext ) {
        if( pFrameInfo->pExceptionObject == pExceptionObject ) {
            return FALSE;
        }
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
// _FindAndUnlinkFrame - Pop the frame information for this scope that was
//  pushed by _CreateFrameInfo.  This should be the first frame in the list,
//  but the code will look for a nested frame and pop all frames, just in
//  case.
//
void _FindAndUnlinkFrame(
    FRAMEINFO * pFrameInfo
) {
    DASSERT(pFrameInfo == pFrameInfoChain);

    for (FRAMEINFO *pCurFrameInfo = pFrameInfoChain;
         pCurFrameInfo != NULL;
         pCurFrameInfo = pCurFrameInfo->pNext)
    {
        if (pFrameInfo == pCurFrameInfo) {
            pFrameInfoChain = pCurFrameInfo->pNext;
            return;
        }
    }

    // Should never be reached.
    DASSERT(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\cfinfo.c ===
/***
*cfinfo.c - clears C file info flag
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Clears the C file info flag.  By default, the openfile information
*	is NOT passed along to children on spawn/exec calls.  If the flag
*	is set, openfile information WILL get passed on to children on
*	spawn/exec calls.
*
*Revision History:
*	06-07-89   PHG	Module created, based on asm version
*	04-03-90   GJF	Added #include <cruntime.h>. Also, fixed the copyright.
*	01-23-92   GJF	Added #include <stdlib.h> (contains decl of _fileinfo).
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>

int _fileinfo = 0;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\cenvarg.c ===
/***
*cenvarg.c - set up environment, command line blocks
*
*       Copyright (c) 1986-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _cenvarg() - setup environment/command line blocks
*
*Revision History:
*       05-20-86  SKS   Module created
*       10-03-86  SKS   Wasn't clearing final null byte in environment block
*       10-13-86  SKS   Check for environment segment > 32 KB (esp. > 64 KB)
*       10-23-86  SKS   New format for C_FILE_INFO for Prot-Mode execution
*       12-17-86  SKS   Support for new command line format
*       01-21-87  BCM   Removed DCR475 switch, new command line format official
*       07-07-87  JCR   Corrected bug in ENV_MAX check
*       05-24-88  SJM   Removed support for ;C_FILE_INFO for Real-Mode execution
*       06-01-88  SJM   Added support for .cmd files via comname/cmdname
*       12-27-88  JCR   Added support for _fileinfo option
*       03-08-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h>, removed #include <register.h> and fixed
*                       the copyright. Also, cleaned up the formatting a bit.
*       04-02-90  GJF   Added const to arg types.
*       08-10-90  SBM   Compiles cleanly with -W3
*       09-27-90  GJF   New-style function declarator.
*       12-06-90  GJF   Added Win32 support. That is, support for encoding
*                       _osfinfo[] data into _C_FILE_INFO environment variable.
*       01-18-91  GJF   ANSI naming.
*       02-05-91  SRW   Removed usage of _C_FILE_INFO to pass binary data
*                       to child process.  [_WIN32_]
*       05-07-92  SKS   Remove code which stripped the extension from a batch
*                       file while building arguments to CMD.EXE.  This was
*                       done long ago (1988) for DOS 3.X, I think.
*       10-24-92  SKS   Remove special code for batch files - not needed on NT
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-15-93  SRW   Added _capture_argv function
*       08-31-93  GJF   Merged NT SDK and Cuda version. Also cleaned up the
*                       formating and removed (obsolete) Cruiser support.
*       12-07-93  CFW   Wide char enable.
*       12-08-94  CFW   Get wide environment if needed.
*       01-10-95  CFW   Debug CRT allocs.
*       03-13-96  JWM   Get all environments as needed; free buffers on exit.
*       08-15-96  JWM   Remove all 32K limitations on spawned processes.
*       12-15-98  GJF   Changes for 64-bit size_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <errno.h>
#include <msdos.h>
#include <stdlib.h>
#include <stdarg.h>
#include <internal.h>
#include <string.h>
#include <awint.h>
#include <tchar.h>
#include <dbgint.h>

#define ENV_MAX 32767

/* local tchar */
#ifdef  WPRFLAG
#define _tenvptr    _wenvptr
#else
#define _tenvptr    _aenvptr
#endif

#ifndef _XBOX

/***
*int _cenvarg(argv, envp, argblk, envblk, name) - set up cmd line/environ
*
*Purpose:
*       Set up the block forms of  the environment and the command line.
*       If "envp" is null, "_environ" is used instead.
*       File handle info is passed in the environment if _fileinfo is !0.
*
*Entry:
*       _TSCHAR **argv   - argument vector
*       _TSCHAR **envp   - environment vector
*       _TSCHAR **argblk - pointer to pointer set to malloc'ed space for args
*       _TSCHAR **envblk - pointer to pointer set to malloc'ed space for env
*       _TSCHAR *name    - name of program being invoked
*
*Exit:
*       returns 0 if ok, -1 if fails
*       stores through argblk and envblk
*       (calls malloc)
*
*Exceptions:
*
*******************************************************************************/

#ifdef  WPRFLAG
int __cdecl _wcenvarg (
#else
int __cdecl _cenvarg (
#endif
        const _TSCHAR * const *argv,
        const _TSCHAR * const *envp,
        _TSCHAR **argblk,
        _TSCHAR **envblk,
        const _TSCHAR *name
        )
{
        REG1 const _TSCHAR * const *vp;
        REG2 unsigned tmp;
        REG3 _TSCHAR *cptr;
        unsigned arg_len;
        int cfi_len;            /* counts the number of file handles in CFI */

        /*
         * Null environment pointer "envp" means use global variable,
         * "_environ"
         */

        int cwd_start;
        int cwd_end;            /* length of "cwd" strings in environment */

        /*
         * Allocate space for command line string
         *  tmp counts the number of bytes in the command line string
         *      including spaces between arguments
         *  An empty string is special -- 2 bytes
         */

        for (vp = argv, tmp = 2; *vp; tmp += (unsigned int)_tcslen(*vp++) + 1) ;

        arg_len = tmp;

        /*
         * Allocate space for the command line plus 2 null bytes
         */

        if ( (*argblk = _malloc_crt(tmp * sizeof(_TSCHAR))) == NULL)
        {
                *envblk = NULL;
                errno = ENOMEM;
                _doserrno = E_nomem;
                return(-1);
        }

        /*
         * Allocate space for environment strings
         *  tmp counts the number of bytes in the environment strings
         *      including nulls between strings
         *  Also add "_C_FILE_INFO=" string
         */
        if (envp)
                for (vp = envp, tmp = 2; *vp; tmp += (unsigned int)_tcslen(*vp++) + 1) ;

        /*
         * The _osfile and _osfhnd arrays are passed as binary data in
         * dospawn.c
         */
        cfi_len = 0;    /* no _C_FILE_INFO */

        if (!envp)
                *envblk = NULL;
        else {
                /*
                 * Now that we've decided to pass our own environment block,
                 * compute the size of the "current directory" strings to
                 * propagate to the new environment.
                 */

#ifdef  WPRFLAG
            /*
             * Make sure wide environment exists.
             */
            if (!_wenvptr)
            {
                    if ((_wenvptr = (wchar_t *)__crtGetEnvironmentStringsW()) == NULL)
                    return -1;
            }
#else
            if (!_aenvptr)
            {
                    if ((_aenvptr = (char *)__crtGetEnvironmentStringsA()) == NULL)
                    return -1;
            }
#endif

            /*
                 * search for the first one
                 */
                for (cwd_start = 0;
                     _tenvptr[cwd_start] != _T('\0') &&
                       _tenvptr[cwd_start] != _T('=');
                     cwd_start += (int)_tcslen(&_tenvptr[cwd_start]) + 1)
                {
                }

                /* find the total size of all contiguous ones */
                cwd_end = cwd_start;
                while (_tenvptr[cwd_end+0] == _T('=') &&
                       _tenvptr[cwd_end+1] != _T('\0') &&
                       _tenvptr[cwd_end+2] == _T(':') &&
                       _tenvptr[cwd_end+3] == _T('='))
                {
                        cwd_end += 4 + (int)_tcslen(&_tenvptr[cwd_end+4]) + 1;
                }
                tmp += cwd_end - cwd_start;

                /*
                 * Allocate space for the environment strings plus extra null byte
                 */
                if( !(*envblk = _malloc_crt(tmp * sizeof(_TSCHAR))) )
            {
                        _free_crt(*argblk);
                        *argblk = NULL;
                        errno = ENOMEM;
                        _doserrno = E_nomem;
                        return(-1);
                }

        }

        /*
         * Build the command line by concatenating the argument strings
         * with spaces between, and two null bytes at the end.
         * NOTE: The argv[0] argument is followed by a null.
         */

        cptr = *argblk;
        vp = argv;

        if (!*vp)       /* Empty argument list ? */
                ++cptr; /* just two null bytes */
        else {          /* argv[0] must be followed by a null */
                _tcscpy(cptr, *vp);
                cptr += (int)_tcslen(*vp++) + 1;
        }

        while( *vp ) {
                _tcscpy(cptr, *vp);
                cptr += (int)_tcslen(*vp++);
                *cptr++ = ' ';
        }

        *cptr = cptr[ -1 ] = _T('\0'); /* remove extra blank, add double null */

        /*
         * Build the environment block by concatenating the environment
         * strings with nulls between and two null bytes at the end
         */

        cptr = *envblk;

        if (envp != NULL) {
                /*
                 * Copy the "cwd" strings to the new environment.
                 */
                memcpy(cptr, &_tenvptr[cwd_start], (cwd_end - cwd_start) * sizeof(_TSCHAR));
                cptr += cwd_end - cwd_start;

                /*
                 * Copy the environment strings from "envp".
                 */
                vp = envp;
                while( *vp ) {
                        _tcscpy(cptr, *vp);
                        cptr += 1 + (int)_tcslen(*vp++);
                }
        }

        if (cptr != NULL) {
                if (cptr == *envblk) {
                        /*
                         * Empty environment block ... this requires two
                         * nulls.
                         */
                        *cptr++ = _T('\0');
                }
                /*
                 * Extra null terminates the segment
                 */
                *cptr = _T('\0');
        }

#ifdef  WPRFLAG
        _free_crt(_wenvptr);
        _wenvptr = NULL;
#else
        _free_crt(_aenvptr);
        _aenvptr = NULL;
#endif
        return(0);
}

#endif ! _XBOX


#ifndef _M_IX86

/***
*int _capture_argv(arglist, static_argv, max_static_entries) - set up argv array
*       for exec?? functions
*
*Purpose:
*       Set up the argv array for the exec?? functions by captures the
*       arguments from the passed va_list into the static_argv array.  If the
*       size of the static_argv array as specified by the max_static_entries
*       parameter is not large enough, then allocates a dynamic array to hold
*       the arguments. Return the address of the final argv array.  If NULL
*       then not enough memory to hold argument array.  If different from
*       static_argv parameter then call must free the return argv array when
*       done with it.
*
*       The scan of the arglist is terminated when a NULL argument is
*       reached. The terminating NULL parameter is stored in the resulting
*       argv array.
*
*Entry:
*       va_list *arglist          - pointer to variable length argument list.
*       _TSCHAR *firstarg            - first argument to store in array
*       _TSCHAR **static_argv        - pointer to static argv to use.
*       size_t max_static_entries - maximum number of entries that can be
*                                   placed in static_argv array.
*
*Exit:
*       returns NULL if no memory.
*       Otherwise returns pointer to argv array.
*       (sometimes calls malloc)
*
*Exceptions:
*
*******************************************************************************/

#ifdef  WPRFLAG
_TSCHAR ** __cdecl _wcapture_argv(
#else
_TSCHAR ** __cdecl _capture_argv(
#endif
        va_list *arglist,
        const _TSCHAR *firstarg,
        _TSCHAR **static_argv,
        size_t max_static_entries
        )
{
        _TSCHAR ** argv;
        _TSCHAR * nextarg;
        size_t i;
        size_t max_entries;

        nextarg = (_TSCHAR *)firstarg;
        argv = static_argv;
        max_entries = max_static_entries;
        i = 0;
        for (;;) {
            if (i >= max_entries) {
                if (argv == static_argv)
                    argv = _malloc_crt((max_entries * 2) * sizeof(_TSCHAR *));
                else
                    argv = _realloc_crt(argv, (max_entries * 2) * sizeof(_TSCHAR *));

                if (argv == NULL) break;
                max_entries += max_entries;
            }

            argv[ i++ ] = nextarg;
            if (nextarg == NULL) break;
            nextarg = va_arg(*arglist, _TSCHAR *);
        }

        return argv;
}

#endif  /* _M_IX86 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\execve.c ===
/***
*execve.c - execute a file with a given environment
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _execve() - execute a file
*
*Revision History:
*	??-??-??  ???	Module created.
*	12-07-93  CFW	Module commented.
*
*******************************************************************************/

#define EXECVE

#include "spawnve.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\execlpe.c ===
/***
*execlpe.c - execute a file with environ, search along path
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _execlpe() - execute a file with environ and search along PATH
*
*Revision History:
*       10-17-83  RN    written
*       ??-??-??  TC    added execlpe
*       06-18-86  JMB   added environment pointer which was erroneously missing
*       06-11-87  PHG   removed unnecessary environment pointer (isn't this
*                       fun!)
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, indents. Added const attribute to
*                       types of filename and arglist. #include-d PROCESS.H
*                       and added ellipsis to match prototype.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE2, added #include
*                       <cruntime.h> and removed #include <register.h>
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-16-93  SRW   ALPHA Merge
*       08-31-93  GJF   Merged NT SDK and Cuda versions
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <stdlib.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _execlpe(filename, arglist) - execute a file with environ
*
*Purpose:
*       Executes the given file with the parameters and the environment
*       which is passed after the parameters.  Searches along the PATH
*       for the file (done by execvp).
*
*Entry:
*       _TSCHAR *filename - file to execute
*       _TSCHAR *arglist  - argument list (environment is at the end)
*       call as _execlpe(path, arg0, arg1, ..., argn, NULL, envp);
*
*Exit:
*       destroys the calling process (hopefully)
*       if fails, returns -1
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _texeclpe (
        const _TSCHAR *filename,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef  _M_IX86

        REG1 const _TSCHAR **argp;

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        argp = &arglist;
        while (*argp++)
                ;

        return(_texecvpe(filename,&arglist,(_TSCHAR **)*argp));

#else   /* ndef_M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        _TSCHAR ** envp;
        intptr_t result;

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif
        envp = va_arg(vargs, _TSCHAR **);
        va_end(vargs);

        result = _texecvpe(filename,argv,envp);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\execv.c ===
/***
*execv.c - execute a file
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _execv() - execute a file
*
*Revision History:
*       10-14-83  RN    written
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, indents. Added const attribute to
*                       types of filename and argvector.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       02-14-90  SRW   Use NULL instead of _environ to get default.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Wide char enable.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _execv(filename, argvector) - execute a file
*
*Purpose:
*       Executes a file with given arguments.  Passes arguments to _execve and
*       uses pointer to the default environment.
*
*Entry:
*       _TSCHAR *filename        - file to execute
*       _TSCHAR **argvector - vector of arguments.
*
*Exit:
*       destroys calling process (hopefully)
*       if fails, returns -1
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _texecv (
        const _TSCHAR *filename,
        const _TSCHAR * const *argvector
        )
{
        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(argvector != NULL);
        _ASSERTE(*argvector != NULL);
        _ASSERTE(**argvector != _T('\0'));

        return(_texecve(filename,argvector,NULL));
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\execl.c ===
/***
*execl.c - execute a file with a list of arguments
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _execl() - execute a file with a list of arguments
*
*Revision History:
*       10-14-83  RN    written
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, indents. Added const attribute to
*                       types of filename and arglist. #include-d PROCESS.H
*                       and added ellipsis to match prototype.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE2, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       02-14-90  SRW   Use NULL instead of _environ to get default.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-16-93  SRW   ALPHA Merge
*       08-31-93  GJF   Merged NT SDK and Cuda versions
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <stdlib.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _execl(filename, arglist) - execute a file with arg list
*
*Purpose:
*       Transform the argument list so it is a vector, then pass its address
*       to execve.  Use a pointer to the default environment vector.
*
*Entry:
*       _TSCHAR *filename - file to execute
*       _TSCHAR *arglist  - list of arguments
*       call as _execl(path, arg0, arg1, ..., argn, NULL);
*
*Exit:
*       destroys the calling process, hopefully
*       returns -1 if fails
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _texecl (
        const _TSCHAR *filename,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef  _M_IX86

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        return(_texecve(filename,&arglist,NULL));

#else   /* ndef _M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        intptr_t result;

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif
        va_end(vargs);

        result = _texecve(filename,argv,NULL);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\execlp.c ===
/***
*execlp.c - execute a file (search along PATH)
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _execlp() - execute a file and search along PATH
*
*Revision History:
*       10-17-83  RN    written
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, indents. Added const attribute to
*                       types of filename and arglist. #include-d PROCESS.H
*                       and added ellipsis to match prototype.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE2, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-16-93  SRW   ALPHA Merge
*       08-31-93  GJF   Merged NT SDK and Cuda versions
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <stddef.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <malloc.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _execlp(filename, arglist) - execute a file, search along PATH
*
*Purpose:
*       Execute the given file with the given arguments; search along PATH
*       for the file. We pass the arguments to execvp where several paths
*       will be tried until one works.
*
*Entry:
*       _TSCHAR *filename - file to execute
*       _TSCHAR *arglist  - argument list
*       call as _execlp(path, arg0, arg1, ..., argn, NULL);
*
*Exit:
*       destroys calling process (hopefully)
*       returns -1 if fails.
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _texeclp (
        const _TSCHAR *filename,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef  _M_IX86

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        return(_texecvp(filename,&arglist));

#else   /* ndef_M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        intptr_t result;

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif
        va_end(vargs);

        result = _texecvp(filename,argbuf);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\execle.c ===
/***
*execle.c - execute a file with arg list and environment
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _execle() - execute a file
*
*Revision History:
*       10-14-83  RN    written
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, indents. Added const attribute to
*                       types of filename and arglist. #include-d PROCESS.H
*                       and added ellipsis to match prototype.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE2, added #include
*                       <cruntime.h> and removed #include <register.h>
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-16-93  SRW   ALPHA Merge
*       08-31-93  GJF   Merged NT SDK and Cuda versions
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <stddef.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <malloc.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _execle(filename, arglist) - execute a file
*
*Purpose:
*       Execute the given file (overlays the calling process).
*       We must dig the environment vector out of the stack and pass it
*       and address of argument vector to execve.
*
*Entry:
*       _TSCHAR *filename - file to execute
*       _TSCHAR *arglist  - argument list followed by environment
*       should be called like _execle(path, arg0, arg1, ..., argn, NULL, envp);
*
*Exit:
*       destroys calling process (hopefully)
*       if fails, returns -1.
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _texecle (
        const _TSCHAR *filename,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef  _M_IX86

        REG1 const _TSCHAR **e_search = &arglist;

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        while (*e_search++)
                ;

        return(_texecve(filename,&arglist,(_TSCHAR **)*e_search));

#else   /* ndef _M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        _TSCHAR ** envp;
        intptr_t result;

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif
        envp = va_arg(vargs, _TSCHAR **);
        va_end(vargs);

        result = _texecve(filename,argv,envp);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\execvp.c ===
/***
*execvp.c - execute a file and search along PATH
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _execvp() - execute a file and search along PATH
*
*Revision History:
*       10-17-83  RN    written
*       10-29-85  TC    added execvpe capability
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, indents. Added const attribute to
*                       types of filename and argvector.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>
*       05-21-90  GJF   Fixed stack checking pragma syntax.
*       08-24-90  SBM   Removed check_stack pragma since workhorse execve
*                       does stack checks
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       02-14-90  SRW   Use NULL instead of _environ to get default.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Wide char enable.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>

/***
*int _execvp(filename, argvector) - execute file; search along PATH
*
*Purpose:
*       Execute the given file with given path and current environ.
*       try to execute the file. start with the name itself (directory '.'),
*       and if that doesn't work start prepending pathnames from the
*       environment until one works or we run out. if the file is a pathname,
*       don't go to the environment to get alternate paths. if errno comes
*       back ENOEXEC, try it as a shell command file with up to MAXARGS-2
*       arguments from the original vector. if a needed text file is busy,
*       wait a little while and try again before despairing completely
*       Actually calls _execvpe() to do all the work.
*
*Entry:
*       _TSCHAR *filename        - file to execute
*       _TSCHAR **argvector - vector of arguments
*
*Exit:
*       destroys the calling process (hopefully)
*       if fails, returns -1
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _texecvp (
        REG3 const _TSCHAR *filename,
        const _TSCHAR * const *argvector
        )
{
        return _texecvpe( filename, argvector, NULL );
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\dospawn.c ===
/***
*dospawn.c - spawn a child process
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _dospawn - spawn a child process
*
*Revision History:
*       06-07-89  PHG   Module created, based on asm version
*       03-08-90  GJF   Made calling type _CALLTYPE2 (for now), added #include
*                       <cruntime.h> and fixed the copyright. Also, cleaned
*                       up the formatting a bit.
*       04-02-90  GJF   Now _CALLTYPE1. Added const to type of name arg.
*       07-24-90  SBM   Removed '32' from API names
*       09-27-90  GJF   New-style function declarator.
*       10-30-90  GJF   Added _p_overlay (temporary hack).
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-16-91  SRW   Fixed return value for dospawn [_WIN32_]
*       01-17-91  GJF   ANSI naming.
*       01-25-91  SRW   Changed CreateProcess parameters [_WIN32_]
*       01-29-91  SRW   Changed CreateProcess parameters again [_WIN32_]
*       02-05-91  SRW   Changed to pass _osfile and _osfhnd arrays as binary
*                       data to child process.  [_WIN32_]
*       02-18-91  SRW   Fixed code to return correct process handle and close
*                       handle for P_WAIT case. [_WIN32_]
*       04-05-91  SRW   Fixed code to free StartupInfo.lpReserved2 after
*                       CreateProcess call. [_WIN32_]
*       04-26-91  SRW   Removed level 3 warnings (_WIN32_)
*       12-02-91  SRW   Fixed command line setup code to not append an extra
*                       space [_WIN32_]
*       12-16-91  GJF   Return full 32-bit exit code from the child process
*                       [_WIN32_].
*       02-14-92  GJF   Replaced _nfile with _nhandle for Win32.
*       02-18-92  GJF   Merged in 12-16-91 change from \\vangogh version
*       11-20-92  SKS   errno/_doserrno must be 0 in case of success.  This
*                       will distinguish a child process return code of -1L
*                       (errno == 0) from an actual error (where errno != 0).
*       01-08-93  CFW   Added code to handle _P_DETACH case; add fdwCreate
*                       variable, nuke stdin, stdout, stderr entries of _osfile
*                       & _osfhnd tables, close process handle to completely
*                       detach process
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Rip out Cruiser.
*       12-07-93  CFW   Wide char enable, remove _p_overlay.
*       01-05-94  CFW   Unremove _p_overlay.
*       01-10-95  CFW   Debug CRT allocs.
*       06-12-95  GJF   Revised passing of C file handles to work from the
*                       ioinfo arrays.
*       07-10-95  GJF   Use UNALIGNED to avoid choking RISC platforms.
*       05-17-96  GJF   Don't pass info on handles marked FNOINHERIT (new 
*                       flag) to the child process.
*       02-05-98  GJF   Changes for Win64: return type changed to intptr_t.
*       01-09-00  PML   Sign-extend exit code for _P_WAIT on Win64.
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <msdos.h>
#include <process.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>
#include <tchar.h>
#include <dbgint.h>

#ifndef WPRFLAG
int _p_overlay = 2;
#endif

/***
*int _dospawn(mode, name, cmdblk, envblk) - spawn a child process
*
*Purpose:
*       Spawns a child process
*
*Entry:
*       int mode     - _P_WAIT, _P_NOWAIT, _P_NOWAITO, _P_OVERLAY, or _P_DETACH
*       _TSCHAR *name   - name of program to execute
*       _TSCHAR *cmdblk - parameter block
*       _TSCHAR *envblk - environment block
*
*Exit:
*       _P_OVERLAY: -1 = error, otherwise doesn't return
*       _P_WAIT:    termination code << 8 + result code
*       _P_DETACH: -1 = error, 0 = success
*       others:    PID of process
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
intptr_t __cdecl _wdospawn (
#else
intptr_t __cdecl _dospawn (
#endif
        int mode,
        const _TSCHAR *name,
        _TSCHAR *cmdblk,
        _TSCHAR *envblk
        )
{
#ifndef _XBOX
        char syncexec, asyncresult, background;
        LPTSTR CommandLine;
        STARTUPINFO StartupInfo;
        PROCESS_INFORMATION ProcessInformation;
        BOOL CreateProcessStatus;
        ULONG dosretval;                /* OS return value */
        DWORD exitcode;
        intptr_t retval;
        DWORD fdwCreate = 0;            /* flags for CreateProcess */
        int i;
        ioinfo *pio;
        char *posfile;
        UNALIGNED intptr_t *posfhnd;
        int nh;                         /* number of file handles to be
                                           passed to the child */

        /* translate input mode value to individual flags */
        syncexec = asyncresult = background = 0;
        switch (mode) {
        case _P_WAIT:    syncexec=1;    break;  /* synchronous execution */
        case 2: /* _P_OVERLAY */
        case _P_NOWAITO: break;                 /* asynchronous execution */
        case _P_NOWAIT:  asyncresult=1; break;  /* asynch + remember result */
        case _P_DETACH:  background=1;  break;  /* detached in null scrn grp */
        default:
            /* invalid mode */
            errno = EINVAL;
            _doserrno = 0;              /* not a Dos error */
            return -1;
        }

        /*
         * Loop over null separate arguments, and replace null separators
         * with spaces to turn it back into a single null terminated
         * command line.
         */
        CommandLine = cmdblk;
        while (*cmdblk) {
            while (*cmdblk) {
                cmdblk++;
            }

            /*
             * If not last argument, turn null separator into a space.
             */
            if (cmdblk[1] != _T('\0')) {
                *cmdblk++ = _T(' ');
            }
        }

        memset(&StartupInfo,0,sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);

        for ( nh = _nhandle ;
              nh && !_osfile(nh - 1) ;
              nh-- ) ;

        StartupInfo.cbReserved2 = (WORD)(sizeof( int ) + (nh *
                                  (sizeof( char ) + 
                                  sizeof( intptr_t ))));

        StartupInfo.lpReserved2 = _calloc_crt( StartupInfo.cbReserved2, 1 );

        *((UNALIGNED int *)(StartupInfo.lpReserved2)) = nh;

        for ( i = 0,
              posfile = (char *)(StartupInfo.lpReserved2 + sizeof( int )),
              posfhnd = (UNALIGNED intptr_t *)(StartupInfo.lpReserved2 + 
                        sizeof( int ) + (nh * sizeof( char ))) ;
              i < nh ;
              i++, posfile++, posfhnd++ )
        {
            pio = _pioinfo(i);
            if ( (pio->osfile & FNOINHERIT) == 0 ) {
                *posfile = pio->osfile;
                *posfhnd = pio->osfhnd;
            }
            else {
                *posfile = 0;
                *posfhnd = (intptr_t)INVALID_HANDLE_VALUE;
            }
        }

        /*
         * if the child process is detached, it cannot access the console, so
         * we must nuke the information passed for the first three handles.
         */
        if ( background ) {

            for ( i = 0,
                  posfile = (char *)(StartupInfo.lpReserved2 + sizeof( int )),
                  posfhnd = (UNALIGNED intptr_t *)(StartupInfo.lpReserved2 + sizeof( int )
                            + (nh * sizeof( char ))) ;
                  i < __min( nh, 3 ) ;
                  i++, posfile++, posfhnd++ )
            {
                *posfile = 0;
                *posfhnd = (intptr_t)INVALID_HANDLE_VALUE;
            }

            fdwCreate |= DETACHED_PROCESS;
        }

        /**
         * Set errno to 0 to distinguish a child process
         * which returns -1L from an error in the spawning
         * (which will set errno to something non-zero
        **/

        _doserrno = errno = 0 ;

#ifdef WPRFLAG
        /* indicate to CreateProcess that environment block is wide */
        fdwCreate |= CREATE_UNICODE_ENVIRONMENT;
#endif

        CreateProcessStatus = CreateProcess( (LPTSTR)name,
                                             CommandLine,
                                             NULL,
                                             NULL,
                                             TRUE,
                                             fdwCreate,
                                             envblk,
                                             NULL,
                                             &StartupInfo,
                                             &ProcessInformation
                                           );

        dosretval = GetLastError();
        _free_crt( StartupInfo.lpReserved2 );

        if (!CreateProcessStatus) {
            _dosmaperr(dosretval);
            return -1;
        }

        if (mode == 2 /* _P_OVERLAY */) {
            /* destroy ourselves */
            _exit(0);
        }
        else if (mode == _P_WAIT) {
            WaitForSingleObject(ProcessInformation.hProcess, (DWORD)(-1L));

            /* return termination code and exit code -- note we return
               the full exit code */
            GetExitCodeProcess(ProcessInformation.hProcess, &exitcode);

            retval = (intptr_t)(int)exitcode;

            CloseHandle(ProcessInformation.hProcess);
        }
        else if (mode == _P_DETACH) {
            /* like totally detached asynchronous spawn, dude,
               close process handle, return 0 for success */
            CloseHandle(ProcessInformation.hProcess);
            retval = (intptr_t)0;
        }
        else {
            /* asynchronous spawn -- return PID */
            retval = (intptr_t)ProcessInformation.hProcess;
        }

        CloseHandle(ProcessInformation.hThread);
        return retval;
#else // XBOX
    // RIPBUG
    errno = EINVAL;
    return -1;
#endif // XBOX
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\fileinfo.c ===
/***
*fileinfo.c - sets C file info flag
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Sets the C file info flag.  By default, the openfile information
*	is NOT passed along to children on spawn/exec calls.  If the flag
*	is set, openfile information WILL get passed on to children on
*	spawn/exec calls.
*
*Revision History:
*	06-07-89   PHG	Module created, based on asm version
*	04-03-90   GJF	Added #include <cruntime.h>. Also, fixed the copyright.
*	01-23-92   GJF	Added #include <stdlib.h> (contains decl of _fileinfo).
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>

int _fileinfo = -1;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\sources.inc ===
MAJORCOMP=crt
MINORCOMP=exec

TARGETNAME=exec

!INCLUDE ..\..\crt32.inc

# removed loaddll.c cenvarg.c wcenvarg.c getproc.c

SOURCES=\
        ..\fileinfo.c  \
        ..\dospawn.c   \
        ..\execl.c     \
        ..\execle.c    \
        ..\execlp.c    \
        ..\execlpe.c   \
        ..\execv.c     \
        ..\execve.c    \
        ..\execvp.c    \
        ..\execvpe.c   \
        ..\spawnl.c    \
        ..\spawnle.c   \
        ..\spawnlp.c   \
        ..\spawnlpe.c  \
        ..\spawnv.c    \
        ..\spawnve.c   \
        ..\spawnvp.c   \
        ..\spawnvpe.c  \
        ..\system.c    \
        ..\wait.c      \
        ..\wdospawn.c  \
        ..\wexecl.c    \
        ..\wexecle.c   \
        ..\wexeclp.c   \
        ..\wexeclpe.c  \
        ..\wexecv.c    \
        ..\wexecve.c   \
        ..\wexecvp.c   \
        ..\wexecvpe.c  \
        ..\wspawnl.c   \
        ..\wspawnle.c  \
        ..\wspawnlp.c  \
        ..\wspwnlpe.c  \
        ..\wspawnv.c   \
        ..\wspawnve.c  \
        ..\wspawnvp.c  \
        ..\wspwnvpe.c  \
        ..\wsystem.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\execvpe.c ===
/***
*execvpe.c - execute a file with given environ; search along PATH
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _execvpe() - execute a file with given environ
*
*Revision History:
*       10-17-83  RN    written
*       10-29-85  TC    added execvpe capability
*       11-19-86  SKS   handle both kinds of slashes
*       12-01-86  JMB   added Kanji file name support under conditional KANJI
*                       switches, corrected header info
*                       removed bogus check for env = b after call to strncpy().
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       09-05-88  SKS   Treat EACCES the same as ENOENT -- keep trying
*       10-18-88  GJF   Removed copy of PATH string to local array, changed
*                       bbuf to be a malloc-ed buffer. Removed bogus limits
*                       on the size of that PATH string.
*       10-26-88  GJF   Don't search PATH when relative pathname is given (per
*                       Stevesa). Also, if the name built from PATH component
*                       and filename is a UNC name, allow any error.
*       11-20-89  GJF   Fixed copyright. Added const attribute to types of
*                       filename, argvector and envptr. Also, added "#include
*                       <jstring.h>" under KANJI switch (same as 5-17-89 change
*                       to CRT version).
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>. Also,
*                       cleaned up the formatting a bit.
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       11-30-92  KRS   Port _MBCS code from 16-bit tree.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <process.h>
#include <mbstring.h>
#include <tchar.h>
#include <dbgint.h>

#define SLASHCHAR _T('\\')
#define XSLASHCHAR _T('/')

#define SLASH _T("\\")
#define DELIMITER _T(";")

#ifdef _MBCS
/* note, the macro below assumes p is to pointer to a single-byte character
 * or the 1st byte of a double-byte character, in a string.
 */
#define ISPSLASH(p)     ( ((p) == _mbschr((p), SLASHCHAR)) || ((p) == \
_mbschr((p), XSLASHCHAR)) )
#else
#define ISSLASH(c)      ( ((c) == SLASHCHAR) || ((c) == XSLASHCHAR) )
#endif


/***
*int _execvpe(filename, argvector, envvector) - execute a file
*
*Purpose:
*       Executes a file with given arguments and environment.
*       try to execute the file. start with the name itself (directory '.'),
*       and if that doesn't work start prepending pathnames from the
*       environment until one works or we run out. if the file is a pathname,
*       don't go to the environment to get alternate paths. If a needed text
*       file is busy, wait a little while and try again before despairing
*       completely
*
*Entry:
*       _TSCHAR *filename        - file to execute
*       _TSCHAR **argvector - vector of arguments
*       _TSCHAR **envvector - vector of environment variables
*
*Exit:
*       destroys the calling process (hopefully)
*       if fails, returns -1
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _texecvpe (
        REG3 const _TSCHAR *filename,
        const _TSCHAR * const *argvector,
        const _TSCHAR * const *envptr
        )
{
        REG1 _TSCHAR *env;
        _TSCHAR *bbuf = NULL;
        REG2 _TSCHAR *buf;
        _TSCHAR *pfin;

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(argvector != NULL);
        _ASSERTE(*argvector != NULL);
        _ASSERTE(**argvector != _T('\0'));

        _texecve(filename,argvector,envptr);

        if ( (errno != ENOENT)
        || (_tcschr(filename, SLASHCHAR) != NULL)
        || (_tcschr(filename, XSLASHCHAR) != NULL)
        || *filename && *(filename+1) == _T(':')
        || !(env=_tgetenv(_T("PATH"))) )
                goto reterror;

        /* allocate a buffer to hold alternate pathnames for the executable
         */
        if ( (buf = bbuf = _malloc_crt(_MAX_PATH * sizeof(_TSCHAR))) == NULL )
            goto reterror;

        do {
                /* copy a component into bbuf[], taking care not to overflow it
                 */
                /* UNDONE: make sure ';' isn't 2nd byte of DBCS char */
                while ( (*env) && (*env != _T(';')) && (buf < bbuf+(_MAX_PATH-2)*sizeof(_TSCHAR)) )
                        *buf++ = *env++;

                *buf = _T('\0');
                pfin = --buf;
                buf = bbuf;

#ifdef _MBCS
                if (*pfin == SLASHCHAR) {
                        if (pfin != _mbsrchr(buf,SLASHCHAR))
                                /* *pfin is the second byte of a double-byte
                                 * character
                                 */
                                strcat( buf, SLASH );
                }
                else if (*pfin != XSLASHCHAR)
                        strcat(buf, SLASH);
#else
                if (*pfin != SLASHCHAR && *pfin != XSLASHCHAR)
                        _tcscat(buf, SLASH);
#endif

                /* check that the final path will be of legal size. if so,
                 * build it. otherwise, return to the caller (return value
                 * and errno rename set from initial call to _execve()).
                 */
                if ( (_tcslen(buf) + _tcslen(filename)) < _MAX_PATH )
                        _tcscat(buf, filename);
                else
                        break;

                _texecve(buf, argvector, envptr);

                if ( (errno != ENOENT)
#ifdef _MBCS
                && (!ISPSLASH(buf) || !ISPSLASH(buf+1)) )
#else
                && (!ISSLASH(*buf) || !ISSLASH(*(buf+1))) )
#endif
                        break;
        } while ( *env && env++ );

reterror:
        if (bbuf != NULL)
                _free_crt(bbuf);

        return(-1);
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\spawnl.c ===
/***
*spawnl.c - spawn a child process
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _spawnl() - spawn a child process
*
*Revision History:
*       04-15-84  DFW   Re-do to correspond to similar exec call format
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, alignment. Added const to arg types
*                       for pathname and arglist. #include-d PROCESS.H and
*                       added ellipsis to match prototype.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE2 and added #include
*                       <cruntime.h>.
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       02-14-90  SRW   Use NULL instead of _environ to get default.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-16-93  SRW   ALPHA Merge
*       08-31-93  GJF   Merged NT SDK and Cuda versions
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <stdlib.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <malloc.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _spawnl(modeflag, pathname, arglist) - spawn a child process
*
*Purpose:
*       Spawns a child process.
*       formats the parameters and calls spawnve to do the actual work. The
*       new process will inherit the parent's environment. NOTE - at least
*       one argument must be present.  This argument is always, by convention,
*       the name of the file being spawned.
*
*Entry:
*       int modeflag   - defines which mode of spawn (WAIT, NOWAIT, or OVERLAY)
*                        only WAIT and OVERLAY are currently implemented
*       _TSCHAR *pathname - file to be spawned
*       _TSCHAR *arglist  - list of argument
*       call as _spawnl(modeflag, path, arg0, arg1, ..., argn, NULL);
*
*Exit:
*       returns exit code of child process
*       returns -1 if fails
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _tspawnl (
        int modeflag,
        const _TSCHAR *pathname,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef  _M_IX86

        _ASSERTE(pathname != NULL);
        _ASSERTE(*pathname != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        return(_tspawnve(modeflag,pathname,&arglist,NULL));

#else   /* ndef _M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        intptr_t result;

        _ASSERTE(pathname != NULL);
        _ASSERTE(*pathname != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif
        va_end(vargs);

        result = _tspawnve(modeflag,pathname,argv,NULL);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\spawnle.c ===
/***
*spawnle.c - spawn a child process with given environment
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _spawnle() - spawn a child process with given environ
*
*Revision History:
*       04-15-84  DFW   written
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, alignment. Added const to arg types
*                       for pathname and arglist. #include-d PROCESS.H and
*                       added ellipsis to match prototype
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE2, added #include
*                       <cruntime.h> and removed #include <register.h>
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-16-93  SRW   ALPHA Merge
*       08-31-93  GJF   Merged NT SDK and Cuda versions
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <stddef.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <malloc.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _spawnle(modeflag, pathname, arglist) - spawn a child process with env.
*
*Purpose:
*       Spawns a child process with given parameters and environment.
*       formats the parameters and calls _spawnve to do the actual work.
*       NOTE - at least one argument must be present.  This argument is always,
*       by convention, the name of the file being spawned.
*
*Entry:
*       int modeflag   - mode of spawn (WAIT, NOWAIT, OVERLAY)
*                        only WAIT, and OVERLAY currently implemented
*       _TSCHAR *pathname - name of file to spawn
*       _TSCHAR *arglist  - argument list, environment is at the end
*       call as _spawnle(modeflag, path, arg0, arg1, ..., argn, NULL, envp);
*
*Exit:
*       returns exit code of spawned process
*       if fails, return -1
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _tspawnle (
        int modeflag,
        const _TSCHAR *pathname,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef  _M_IX86

        REG1 const _TSCHAR **argp;

        _ASSERTE(pathname != NULL);
        _ASSERTE(*pathname != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        /* walk the arglist until the terminating NULL pointer is found.  The
         * next location holds the environment table pointer.
         */

        argp = &arglist;
        while (*argp++)
                ;

        return(_tspawnve(modeflag,pathname,&arglist,(_TSCHAR **)*argp));

#else   /* ndef _M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        _TSCHAR ** envp;
        intptr_t result;

        _ASSERTE(pathname != NULL);
        _ASSERTE(*pathname != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif
        envp = va_arg(vargs, _TSCHAR **);
        va_end(vargs);

        result = _tspawnve(modeflag,pathname,argv,envp);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\loaddll.c ===
/***
*loaddll.c - load or free a Dynamic Link Library
*
*	Copyright (c) 1991-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _loaddll() and _unloaddll() - load and unload DLL
*
*Revision History:
*	08-21-91  BWM	Wrote module.
*	09-30-93  GJF	Resurrected for compatibility with NT SDK.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <stdlib.h>
#include <process.h>

#ifndef _XBOX

/***
*int _loaddll(filename) - Load a dll
*
*Purpose:
*	Load a DLL into memory
*
*Entry:
*	char *filename - file to load
*
*Exit:
*	returns a unique DLL (module) handle if succeeds
*	returns 0 if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _loaddll(char * szName)
{
    return ((int)LoadLibrary(szName));
}

#endif !_XBOX

#ifndef _XBOX

/***
*int _unloaddll(handle) - Unload a dll
*
*Purpose:
*	Unloads a DLL. The resources of the DLL will be freed if no other
*	processes are using it.
*
*Entry:
*	int handle - handle from _loaddll
*
*Exit:
*	returns 0 if succeeds
*	returns DOS error if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _unloaddll(int hMod)
{
    if (!FreeLibrary((HANDLE)hMod)) {
	return ((int)GetLastError());
    }
    return (0);
}

#endif !_XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\spawnlp.c ===
/***
*spawnlp.c - spawn a file; search along PATH
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _spawnlp() - spawn a file with search along PATH
*
*Revision History:
*       04-15-84  DFW   written
*       10-29-85  TC    added spawnlpe
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, alignment. Added const to arg types
*                       for filename and arglist. #include-d PROCESS.H and
*                       added ellipsis to match prototype.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE2 and added #include
*                       <cruntime.h>.
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-16-93  SRW   ALPHA Merge
*       08-31-93  GJF   Merged NT SDK and Cuda versions
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <stddef.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <malloc.h>
#include <tchar.h>
#include <dbgint.h>

/***
*_spawnlp(modeflag, filename, arglist) - spawn file and search along PATH
*
*Purpose:
*       Spawns a child process.
*       formats the parameters and calls _spawnvp to do the work of searching
*       the PATH environment variable and calling _spawnve.  The NULL
*       environment pointer indicates that the new process will inherit the
*       parents process's environment.  NOTE - at least one argument must be
*       present.  This argument is always, by convention, the name of the file
*       being spawned.
*
*Entry:
*       int modeflag   - mode of spawn (WAIT, NOWAIT, OVERLAY)
*                        only WAIT, OVERLAY currently implemented
*       _TSCHAR *pathname - file to spawn
*       _TSCHAR *arglist  - argument list
*       call as _spawnlp(modeflag, path, arg0, arg1, ..., argn, NULL);
*
*Exit:
*       returns exit code of child process
*       returns -1 if fails
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _tspawnlp (
        int modeflag,
        const _TSCHAR *filename,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef  _M_IX86

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        return(_tspawnvp(modeflag,filename,&arglist));

#else   /* ndef _M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        intptr_t result;

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif
        va_end(vargs);

        result = _tspawnvp(modeflag,filename,argv);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\getproc.c ===
/***
*getproc.c - Get the address of a procedure in a DLL.
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _getdllprocadd() - gets a procedure address by name or
*       ordinal
*
*Revision History:
*       08-21-91  BWM   Wrote module.
*       09-30-93  GJF   Resurrected for compatiblity with NT SDK.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*       02-10-98  GJF   Changes for Win64: changed 3rd arg type intptr_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <process.h>

/***
*int (*)() _getdllprocaddr(handle, name, ordinal) - Get the address of a
*       DLL procedure specified by name or ordinal
*
*Purpose:
*
*Entry:
*       int handle - a DLL handle from _loaddll
*       char * name - Name of the procedure, or NULL to get by ordinal
*       int ordinal - Ordinal of the procedure, or -1 to get by name
*
*
*Exit:
*       returns a pointer to the procedure if found
*       returns NULL if not found
*
*Exceptions:
*
*******************************************************************************/

int (__cdecl * __cdecl _getdllprocaddr(
        intptr_t hMod,
        char * szProcName,
        intptr_t iOrdinal))()
{
        typedef int (__cdecl * PFN)();

        if (szProcName == NULL) {
            if (iOrdinal <= 65535) {
                return ((PFN)GetProcAddress((HANDLE)hMod, (LPSTR)iOrdinal));
            }
        }
        else {
            if (iOrdinal == (intptr_t)(-1)) {
                return ((PFN)GetProcAddress((HANDLE)hMod, szProcName));
            }
        }

        return (NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\wcenvarg.c ===
/***
*wcenvarg.c - set up environment, command line blocks (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wcenvarg() - setup wide environment/command line blocks
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "cenvarg.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\spawnvpe.c ===
/***
*spawnvpe.c - spawn a child process with given environ (search PATH)
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _spawnvpe() - spawn a child process with given environ (search
*       PATH)
*
*Revision History:
*       04-15-84  DFW   written
*       10-29-85  TC    added spawnvpe capability
*       11-19-86  SKS   handle both kinds of slashes
*       12-01-86  JMB   added Kanji file name support under conditional KANJI
*                       switches.  Corrected header info.  Removed bogus check
*                       for env = b after call to strncpy
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       09-05-88  SKS   Treat EACCES the same as ENOENT -- keep trying
*       10-17-88  GJF   Removed copy of PATH string to local array, changed
*                       bbuf to be a malloc-ed buffer. Removed bogus limits
*                       on the size of that PATH string.
*       10-25-88  GJF   Don't search PATH when relative pathname is given (per
*                       Stevesa). Also, if the name built from PATH component
*                       and filename is a UNC name, allow any error.
*       05-17-89  MT    Added "include <jstring.h>" under KANJI switch
*       05-24-89  PHG   Reduce _amblksiz to use minimal memory (DOS only)
*       08-29-89  GJF   Use _getpath() to retrieve PATH components, fixing
*                       several problems in handling unusual or bizarre
*                       PATH's.
*       11-20-89  GJF   Added const attribute to types of filename, argv and
*                       envptr.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       09-25-91  JCR   Changed ifdef "OS2" to "_DOS_" (unused in 32-bit tree)
*       11-30-92  KRS   Port _MBCS code from 16-bit tree.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <internal.h>
#include <process.h>
#include <mbstring.h>
#include <tchar.h>
#include <dbgint.h>

#define SLASH _T("\\")
#define SLASHCHAR _T('\\')
#define XSLASHCHAR _T('/')
#define DELIMITER _T(";")

#ifdef _MBCS
/* note, the macro below assumes p is to pointer to a single-byte character
 * or the 1st byte of a double-byte character, in a string.
 */
#define ISPSLASH(p)     ( ((p) == _mbschr((p), SLASHCHAR)) || ((p) == \
_mbschr((p), XSLASHCHAR)) )
#else
#define ISSLASH(c)      ( ((c) == SLASHCHAR) || ((c) == XSLASHCHAR) )
#endif

/***
*_spawnvpe(modeflag, filename, argv, envptr) - spawn a child process
*
*Purpose:
*       Spawns a child process with the given arguments and environ,
*       searches along PATH for given file until found.
*       Formats the parameters and calls _spawnve to do the actual work. The
*       NULL environment pointer indicates that the new process will inherit
*       the parents process's environment.  NOTE - at least one argument must
*       be present.  This argument is always, by convention, the name of the
*       file being spawned.
*
*Entry:
*       int modeflag - defines mode of spawn (WAIT, NOWAIT, or OVERLAY)
*                       only WAIT and OVERLAY supported
*       _TSCHAR *filename - name of file to execute
*       _TSCHAR **argv - vector of parameters
*       _TSCHAR **envptr - vector of environment variables
*
*Exit:
*       returns exit code of spawned process
*       if fails, returns -1
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _tspawnvpe (
        int modeflag,
        REG3 const _TSCHAR *filename,
        const _TSCHAR * const *argv,
        const _TSCHAR * const *envptr
        )
{
        intptr_t i;
        REG1 _TSCHAR *env;
        REG2 _TSCHAR *buf = NULL;
        _TSCHAR *pfin;
#ifdef _DOS_
        int tempamblksiz;          /* old _amblksiz */
#endif
        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(argv != NULL);
        _ASSERTE(*argv != NULL);
        _ASSERTE(**argv != _T('\0'));

#ifdef _DOS_
        tempamblksiz = _amblksiz;
        _amblksiz = 0x10;           /* reduce _amblksiz for efficient mallocs */
#endif

        if (
        (i = _tspawnve(modeflag, filename, argv, envptr)) != -1
                /* everything worked just fine; return i */

        || (errno != ENOENT)
                /* couldn't spawn the process, return failure */

        || (_tcschr(filename, XSLASHCHAR) != NULL)
                /* filename contains a '/', return failure */

#ifdef _DOS_
        || (_tcschr(filename,SLASHCHAR) != NULL)
                /* filename contains a '\', return failure */

        || *filename && *(filename+1) == _T(':')
                /* drive specification, return failure */
#endif

        || !(env = _tgetenv(_T("PATH")))
                /* no PATH environment string name, return failure */

        || ( (buf = _malloc_crt(_MAX_PATH * sizeof(_TSCHAR))) == NULL )
                /* cannot allocate buffer to build alternate pathnames, return
                 * failure */
        ) {
#ifdef _DOS_
                _amblksiz = tempamblksiz;       /* restore old _amblksiz */
#endif
                goto done;
        }

#ifdef _DOS_
        _amblksiz = tempamblksiz;               /* restore old _amblksiz */
#endif


        /* could not find the file as specified, search PATH. try each
         * component of the PATH until we get either no error return, or the
         * error is not ENOENT and the component is not a UNC name, or we run
         * out of components to try.
         */

#ifdef WPRFLAG
        while ( (env = _wgetpath(env, buf, _MAX_PATH - 1)) && (*buf) ) {
#else
        while ( (env = _getpath(env, buf, _MAX_PATH - 1)) && (*buf) ) {
#endif            

                pfin = buf + _tcslen(buf) - 1;

                /* if necessary, append a '/'
                 */
#ifdef _MBCS
                if (*pfin == SLASHCHAR) {
                        if (pfin != _mbsrchr(buf,SLASHCHAR))
                        /* fin is the second byte of a double-byte char */
                                strcat(buf, SLASH );
                }
                else if (*pfin !=XSLASHCHAR)
                        strcat(buf, SLASH);
#else
                if (*pfin != SLASHCHAR && *pfin != XSLASHCHAR)
                        _tcscat(buf, SLASH);
#endif
                /* check that the final path will be of legal size. if so,
                 * build it. otherwise, return to the caller (return value
                 * and errno rename set from initial call to _spawnve()).
                 */
                if ( (_tcslen(buf) + _tcslen(filename)) < _MAX_PATH )
                        _tcscat(buf, filename);
                else
                        break;

                /* try spawning it. if successful, or if errno comes back with a
                 * value other than ENOENT and the pathname is not a UNC name,
                 * return to the caller.
                 */
                if ( (i = _tspawnve(modeflag, buf, argv, envptr)) != -1
                        || ((errno != ENOENT)
#ifdef _MBCS
                                && (!ISPSLASH(buf) || !ISPSLASH(buf+1))) )
#else
                                && (!ISSLASH(*buf) || !ISSLASH(*(buf+1)))) )
#endif
                        break;

        }

done:
        if (buf != NULL)
            _free_crt(buf);
        return(i);
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\wait.c ===
/***
*wait.c - wait for child process to terminate
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wait() - wait for child process to terminate
*
*Revision History:
*       06-08-89  PHG   Module created, based on asm version
*       03-08-90  GJF   Made calling type _CALLTYPE2 (for now), added #include
*                       <cruntime.h> and fixed the copyright. Also, cleaned up
*                       the formatting a bit.
*       04-02-90  GJF   Now _CALLTYPE1.
*       07-24-90  SBM   Removed '32' from API names
*       09-27-90  GJF   New-style function declarators.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-17-91  GJF   ANSI naming
*       02-18-91  SRW   Fixed code to close process handle. [_WIN32_]
*       04-26-91  SRW   Removed level 3 warnings [_WIN32_]
*       12-17-91  GJF   Fixed _cwait for Win32. However, _wait is still
*                       broken [_WIN32_].
*       07-21-92  GJF   Removed _wait for Win32, not implemented and no good
*                       way to implement.
*       12-14-92  GJF   For Win32, map ERROR_INVALID_HANDLE to ECHILD.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Remove Cruiser support.
*       02-06-98  GJF   Changes for Win64: changed return and an arg type to 
*                       intptr_t.
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <oscalls.h>
#include <process.h>
#include <errno.h>
#include <internal.h>
#include <stdlib.h>

/***
*int _cwait(stat_loc, process_id, action_code) - wait for specific child
*       process
*
*Purpose:
*       The function _cwait() suspends the calling-process until the specified
*       child-process terminates.  If the specifed child-process terminated
*       prior to the call to _cwait(), return is immediate.
*
*Entry:
*       int *stat_loc - pointer to where status is stored or NULL
*       process_id - specific process id to be interrogated (0 means any)
*       action_code - specific action to perform on process ID
*                   either _WAIT_CHILD or _WAIT_GRANDCHILD
*
*Exit:
*       process ID of terminated child or -1 on error
*
*       *stat_loc is updated to contain the following:
*       Normal termination: lo-byte = 0, hi-byte = child exit code
*       Abnormal termination: lo-byte = term status, hi-byte = 0
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _cwait (
        int *stat_loc,
        intptr_t process_id,
        int action_code
        )
{
#ifndef _XBOX
        intptr_t retval;
        int retstatus;
        unsigned long oserror;

        DBG_UNREFERENCED_PARAMETER(action_code);

        /* Explicitly check for process_id being -1 or -2. In Windows NT,
         * -1 is a handle on the current process, -2 is a handle on the
         * current thread, and it is perfectly legal to to wait (forever)
         * on either */
        if ( (process_id == -1) || (process_id == -2) ) {
            errno = ECHILD;
            return -1;
        }

        /* wait for child process, then fetch its exit code */
        if ( (WaitForSingleObject((HANDLE)process_id, (DWORD)(-1L)) == 0) &&
          GetExitCodeProcess((HANDLE)process_id, (LPDWORD)&retstatus) ) {
            retval = process_id;
        }
        else {
            /* one of the API calls failed. map the error and set up to
               return failure. note the invalid handle error is mapped in-
               line to ECHILD */
            if ( (oserror = GetLastError()) == ERROR_INVALID_HANDLE ) {
                errno = ECHILD;
                _doserrno = oserror;
            }
            else
                _dosmaperr(GetLastError());

            retval = -1;
            retstatus = -1;
        }

        CloseHandle((HANDLE)process_id);

        if (stat_loc != NULL)
            *stat_loc = retstatus;

        return retval;
#else // XBOX
    RIP("_cwait() not supported on Xbox");
    errno = ECHILD;
    return -1;
#endif // XBOX
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\spawnlpe.c ===
/***
*spawnlpe.c - spawn a child process with environ and search along PATH
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _spawnlpe() - spawn a child process with environ/PATH search
*
*Revision History:
*       04-15-84  DFW   written
*       10-29-85  TC    added spawnlpe
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, alignment. Added const to arg types
*                       for filename and arglist. #include-d PROCESS.H and
*                       added ellipsis to match prototype.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE2, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-16-93  SRW   ALPHA Merge
*       08-31-93  GJF   Merged NT SDK and Cuda versions
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <stddef.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <malloc.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _spawnlpe(modeflag, filename, arglist) - spawn a child process
*
*Purpose:
*       Spawns a child process.
*       formats the parameters and calls _spawnvpe to do the work of searching
*       the PATH environment variable and calling _spawnve.  The NULL
*       environment pointer indicates that the new process will inherit the
*       parents process's environment.  NOTE - at least one argument must be
*       present.  This argument is always, by convention, the name of the file
*       being spawned.
*
*Entry:
*       int modeflag   - defines what mode of spawn (WAIT, NOWAIT, OVERLAY)
*                        only WAIT and OVERLAY currently supported
*       _TSCHAR *pathname - file to spawn
*       _TSCHAR *arglist  - list of arguments (environ at end)
*       call as _spawnlpe(modeflag, path, arg0, arg1, ..., argn, NULL, envp);
*
*Exit:
*       returns exit code of spawned process
*       returns -1 if fails
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _tspawnlpe (
        int modeflag,
        const _TSCHAR *filename,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef  _M_IX86

        REG1 const _TSCHAR **argp;

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        argp = &arglist;
        while (*argp++)
                ;

        return(_tspawnvpe(modeflag,filename,&arglist,(_TSCHAR **)*argp));

#else   /* ndef _M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        _TSCHAR ** envp;
        intptr_t result;

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(arglist != NULL);
        _ASSERTE(*arglist != _T('\0'));

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif
        envp = va_arg(vargs, _TSCHAR **);
        va_end(vargs);

        result = _tspawnvpe(modeflag,filename,argv,envp);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\spawnve.c ===
/***
*spawnve.c - Low level routine eventually called by all _spawnXX routines
*       also contains all code for _execve, called by _execXX routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*       This is the low level routine which is eventually invoked by all the
*       _spawnXX routines.
*
*       This is also the low-level routine which is eventually invoked by
*       all of the _execXX routines.
*
*Revision History:
*       03-??-84  RLB   created
*       05-??-84  DCW   modified to fix bug in initialization of envblock
*                       pointer (used int 0 which would fail in long model) and
*                       changed (char *)0 to NULL.
*       03-31-86  SKS   modified for OS/2; no OVERLAY mode,
*                       new format for DOS Exec function
*                       also check for Xenix or DOS style slash characters
*       10-13-86  SKS   pass program name to _cenvarg()
*       11-19-86  SKS   handle both kinds of slashes, with support for Kanji
*       01-29-87  BCM   don't try ".com" extension in protected mode (OS/2)
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05/31/88  SJM   Re-written to allow spawn of .CMD files, increase
*                       speed. Added comexecmd routine.
*       06/01/88  SJM   added #ifdef statements for execve.obj compilation
*       10-30-88  GJF   Call _dospawn() for EXECVE, not _doexec().
*       07-21-89  GJF   Progagated fixes of 11-23-88 and 05-27-89 from CRT tree.
*       11-16-89  GJF   Added code to execve/spawnve to ensure a relative or
*                       or absolute pathname is always used for the executable,
*                       not just a filename (otherwise DOSEXECPGM will search
*                       the PATH!). Also, cleaned up some of the erratic
*                       formatting. Same as 9-15-89 change to CRT version
*       11-20-89  GJF   Added const attribute to types of appropriate args.
*       02-08-90  GJF   Fixed bug in comexecmd (must free(comname) if and only
*                       if comname points to a malloc-ed block). Propagated
*                       from 02-07-90 change in crt6 version.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       04-02-90  GJF   Made comexecmd() _CALLTYPE4. Added #include <io.h>
*                       and a prototype for comexecmd() to fix compiler
*                       warnings (-W3).
*       05-21-90  GJF   Fixed stack checking pragma syntax.
*       07-24-90  SBM   Removed redundant include, minor optimization
*       09-27-90  GJF   New-style function declarators.
*       12-28-90  SRW   Added _CRUISER_ conditional around check_stack pragma
*       01-17-91  GJF   ANSI naming.
*       08-21-91  JCR   Call access() in before comexecmd (bug fix)
*       01-24-92  JCR   upgraded for Win32
*       10-24-92  SKS   Remove special treatment for batch files -
*                       Windows NT will spawn %COMSPEC% automatically
*       11-30-92  KRS   Ported _MBCS support from 16-bit tree.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Rip out Cruiser.
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <io.h>
#include <process.h>
#include <errno.h>
#include <msdos.h>
#include <string.h>
#include <stdlib.h>
#include <internal.h>
#include <mbstring.h>
#include <tchar.h>
#include <dbgint.h>

#ifdef _XBOX
#include <oscalls.h>
#endif // _XBOX

#define SLASHCHAR   _T('\\')
#define XSLASHCHAR  _T('/')

#ifndef EXECVE
#ifdef WPRFLAG
static intptr_t __cdecl wcomexecmd(int mode, const wchar_t * name,
        const wchar_t * const * argv, const wchar_t * const * envp);
#else 
static intptr_t __cdecl comexecmd(int mode, const char * name,
        const char * const * argv, const char * const * envp);
#endif
#else /* EXECVE */
#ifdef WPRFLAG
static intptr_t __cdecl wcomexecmd(const wchar_t * name,
        const wchar_t * const * argv, const wchar_t * const * envp);
#else
static intptr_t __cdecl comexecmd(const char * name,
        const char * const * argv, const char * const * envp);
#endif
#endif /* EXECVE */

/***
*static int comexecmd(mode, name, argv, envp) - do the exec
*       or spawn after name fixup
*
*Purpose:
*       Spawns a child process with given parameters and environment.  Either
*       overlays current process or loads in free memory while parent process
*       waits.  If the named file is a .cmd file, modifies the calling sequence
*       and prepends the /c and filename arguments into the command string
*
*       Exec doesn't take a mode; instead, the parent process goes away as
*       the child process is brought in.
*
*Entry:
*       int mode - mode to spawn (WAIT, NOWAIT, or OVERLAY)
*                   only WAIT and OVERLAY currently supported
*
*           ****  mode is only used in the spawnve() version  ****
*
*       _TSCHAR *name - pathname of file to spawn.  Includes the extension
*       _TSCHAR **argv - vector of parameter strings
*       _TSCHAR **envp - vector of environment variables
*
*Exit:
*       returns exit code of child process
*       if fails, returns -1
*
*Exceptions:
*       Returns a value of (-1) to indicate an error in exec'ing the child
*       process.  errno may be set to:
*
*       E2BIG   = failed in argument/environment processing (_cenvarg)
*                 argument list or environment too big;
*       EACCESS = locking or sharing violation on file;
*       EMFILE  = too many files open;
*       ENOENT  = failed to find program name - no such file or directory;
*       ENOEXEC = failed in exec - bad executable format;
*       ENOMEM  = failed in memory allocation (during malloc, or in
*                 setting up memory for executing child process).
*
*******************************************************************************/

#ifdef WPRFLAG
static intptr_t __cdecl wcomexecmd (
#else
static intptr_t __cdecl comexecmd (
#endif

#ifndef EXECVE
        REG3 int mode,
#endif /* EXECVE */

        REG2 const _TSCHAR *name,
        const _TSCHAR * const *argv,
        const _TSCHAR * const *envp
        )
{
#ifndef _XBOX
        _TSCHAR *argblk;
        _TSCHAR *envblk;
        REG4 intptr_t rc;

#ifdef WPRFLAG
        if (_wcenvarg(argv, envp, &argblk, &envblk, name) == -1)
#else
        if (_cenvarg(argv, envp, &argblk, &envblk, name) == -1)
#endif
                return -1;

#ifndef EXECVE
#ifdef WPRFLAG
        rc = _wdospawn(mode, name, argblk, envblk);
#else
        rc = _dospawn(mode, name, argblk, envblk);
#endif
#else /* EXECVE */
#ifdef WPRFLAG
        rc = _wdospawn(_P_OVERLAY, name, argblk, envblk);
#else
        rc = _dospawn(_P_OVERLAY, name, argblk, envblk);
#endif
#endif /* EXECVE */
        /* free memory */

        _free_crt(argblk);
        _free_crt(envblk);

        return rc;
#else // XBOX
    RIP("comexecmd() not supported on Xbox");
    return -1;
#endif // XBOX
}

/***
*int _spawnve(mode, name, argv, envp) - low level _spawnXX library function
*int _execve(name, argv, envp) - low level _execXX library function
*
*Purpose:
*       spawns or execs a child process; takes a single pointer to an argument
*       list as well as a pointer to the environment; unlike _spawnvpe,
*       _spawnve does not search the PATH= list in processing the name
*       parameter; mode specifies the parent's execution mode.
*
*Entry:
*       int mode    - parent process's execution mode:
*                     must be one of _P_OVERLAY, _P_WAIT, _P_NOWAIT;
*                     not used for _execve
*       _TSCHAR *name  - path name of program to spawn;
*       _TSCHAR **argv - pointer to array of pointers to child's arguments;
*       _TSCHAR **envp - pointer to array of pointers to child's environment
*                     settings.
*
*Exit:
*       Returns : (int) a status value whose meaning is as follows:
*               0        = normal termination of child process;
*               positive = exit code of child upon error termination
*                          (abort or exit(nonzero));
*               -1       = child process was not spawned;
*                          errno indicates what kind of error:
*                          (E2BIG, EINVAL, ENOENT, ENOEXEC, ENOMEM).
*
*Exceptions:
*       Returns a value of (-1) to indicate an error in spawning the child
*       process.  errno may be set to:
*
*       E2BIG   = failed in argument/environment processing (_cenvarg) -
*                 argument list or environment too big;
*       EINVAL  = invalid mode argument;
*       ENOENT  = failed to find program name - no such file or directory;
*       ENOEXEC = failed in spawn - bad executable format;
*       ENOMEM  = failed in memory allocation (during malloc, or in
*                 setting up memory for spawning child process).
*
*******************************************************************************/

/* Extension array - ordered in search order from right to left.

   ext_strings  = array of extensions
*/

static _TSCHAR *ext_strings[] = { _T(".cmd"), _T(".bat"), _T(".exe"), _T(".com") };
enum {CMD, BAT, EXE, COM, EXTFIRST=CMD, EXTLAST=COM};

intptr_t __cdecl

#ifndef EXECVE

_tspawnve (
        REG3 int mode,

#else /* EXECVE */

_texecve (

#endif /* EXECVE */

        const _TSCHAR *name,
        const _TSCHAR * const *argv,
        const _TSCHAR * const *envp
        )
{
        _TSCHAR *ext;   /* where the extension goes if we have to add one */
        REG1 _TSCHAR *p;
        _TSCHAR *q;
        REG2 _TSCHAR *pathname = (_TSCHAR *)name;
        REG4 intptr_t rc;
        REG5 int i;

        p = _tcsrchr(pathname, SLASHCHAR);
        q = _tcsrchr(pathname, XSLASHCHAR);

        /* ensure that pathname is an absolute or relative pathname. also,
         * position p to point at the filename portion of pathname (i.e., just
         * after the last occurence of a colon, slash or backslash character */

        if (!q) {
                if (!p)
                        if (!(p = _tcschr(pathname, _T(':')))) {

                                /* pathname is a filename only, force it to be
                                 * a relative pathname. note that an extra byte
                                 * is malloc-ed just in case pathname is NULL,
                                 * to keep the heap from being trashed by
                                 * strcpy */
                                if (!(pathname = _malloc_crt((_tcslen(pathname) + 3) * sizeof(_TSCHAR))))
                                        return(-1);

                                _tcscpy(pathname, _T(".\\"));
                                _tcscat(pathname, name);

                                /* set p to point to the start of the filename
                                 * (i.e., past the ".\\" prefix) */
                                p = pathname + 2;
                        }
                        /* else pathname has drive specifier prefix and p is
                         * is pointing to the ':' */
        }
        else if (!p || q > p)   /* p == NULL or q > p */
                p = q;


        rc = -1;        /* init to error value */

        if (ext = _tcsrchr(p, _T('.')))  {

                /* extension given; only do filename */

                if (_taccess(pathname, 0) != -1) {

#ifndef EXECVE

#ifdef WPRFLAG
                        rc = wcomexecmd(mode, pathname, argv, envp);
#else
                        rc = comexecmd(mode, pathname, argv, envp);
#endif

#else /* EXECVE */

#ifdef WPRFLAG
                        rc = wcomexecmd(pathname, argv, envp);
#else
                        rc = comexecmd(pathname, argv, envp);
#endif

#endif /* EXECVE */
                }

        }
        else    {

                /* no extension; try .cmd/.bat, then .com and .exe */

                if (!(p = _malloc_crt((_tcslen(pathname) + 5) * sizeof(_TSCHAR))))
                        return(-1);

                _tcscpy(p, pathname);
                ext = p + _tcslen(pathname);

                for (i = EXTLAST; i >= EXTFIRST; --i) {
                        _tcscpy(ext, ext_strings[i]);

                        if (_taccess(p, 0) != -1) {

#ifndef EXECVE
#ifdef WPRFLAG
                                rc = wcomexecmd(mode, p, argv, envp);
#else
                                rc = comexecmd(mode, p, argv, envp);
#endif
#else /* EXECVE */
#ifdef WPRFLAG
                                rc = wcomexecmd(p, argv, envp);
#else
                                rc = comexecmd(p, argv, envp);
#endif
#endif /* EXECVE */
                                break;
                        }
                }
                _free_crt(p);
        }

        if (pathname != name)
                _free_crt(pathname);

        return rc;
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\system.c ===
/***
*system.c - pass a command line to the shell
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines system() - passes a command to the shell
*
*Revision History:
*       12-01-83  RN    written
*       10-23-86  SKS   Fixed use of strtok(), added check for NULL rtn from getenv
*       12-18-86  SKS   PROTMODE symbol used for dual-modal version
*       02-23-86  JCR   Put in support for NULL command pointer (MSDOS only)
*       04-13-86  JCR   Added const to declaration
*       06-30-87  JCR   Re-wrote system to use spawnvpe, removed XENIX conditional
*                       code, lots of general cleaning up.
*       07-01-87  PHG   removed P->PROTMODE compile switch hack
*       09-22-87  SKS   remove extern variable declarations, add ";" to assert()'s
*       11-10-87  SKS   Removed IBMC20 switch, change PROTMODE to OS2
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       02-22-88  JCR   Added cast to get rid of cl const warning
*       09-05-88  SKS   Treat EACCES the same as ENOENT -- keep trying
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h>, removed some leftover DOS support and
*                       fixed the copyright. Also, cleaned up the formatting
*                       formatting a bit.
*       07-23-90  SBM   Compiles cleanly with -W3 (removed unreferenced
*                       variable), removed redundant includes, replaced
*                       <assertm.h> by <assert.h>, minor optimizations
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       02-14-90  SRW   Use NULL instead of _environ to get default.
*       02-23-93  SKS   Remove reference to _osmode and use of "command.com"
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Wide char enable.
*       12-06-94  SKS   Assume command.com for Win95, but cmd.exe for Win. NT.
*       01-16-95  SKS   Avoid calling access(NULL) if command==NULL and
*                       %COMSPEC% is unset.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: added cast to int where necessary
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <process.h>
#include <io.h>
#include <stdlib.h>
#include <errno.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int system(command) - send the command line to a shell
*
*Purpose:
*       Executes a shell and passes the command line to it.
*       If command is NULL, determine if a command processor exists.
*       The command processor is described by the environment variable
*       COMSPEC.  If that environment variable does not exist, try the
*       name "cmd.exe" for Windows NT and "command.com" for Windows '95.
*
*Entry:
*       char *command - command to pass to the shell (if NULL, just determine
*                       if command processor exists)
*
*Exit:
*       if command != NULL  returns status of the shell
*       if command == NULL  returns non-zero if CP exists, zero if CP doesn't exist
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tsystem (
        const _TSCHAR *command
        )
{
        int catch;
        _TSCHAR *argv[4];

        argv[0] = _tgetenv(_T("COMSPEC"));

        /*
         * If command == NULL, return true IFF %COMSPEC%
         * is set AND the file it points to exists.
         */

        if (command == NULL) {
                return argv[0] == NULL ? 0 : (!_taccess(argv[0],0));
        }

        _ASSERTE(*command != _T('\0'));

        argv[1] = _T("/c");
        argv[2] = (_TSCHAR *) command;
        argv[3] = NULL;

        /* If there is a COMSPEC defined, try spawning the shell */

        if (argv[0])    /* Do not try to spawn the null string */
                if ((catch = (int)_tspawnve(_P_WAIT,argv[0],argv,NULL)) != -1
                || (errno != ENOENT && errno != EACCES))
                        return(catch);

        /* No COMSPEC so set argv[0] to what COMSPEC should be. */
#ifdef _XBOX    // No need for osver check on XBox (RAID #1518)
        argv[0] = _T("cmd.exe");
#else
        argv[0] = ( _osver & 0x8000 ) ? _T("command.com") : _T("cmd.exe");
#endif

        /* Let the _spawnvpe routine do the path search and spawn. */

        return((int)_tspawnvpe(_P_WAIT,argv[0],argv,NULL));
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\spawnv.c ===
/***
*spawnv.c - spawn a child process
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _spawnv() - spawn a child process
*
*Revision History:
*       04-15-84  DFW   written
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, alignment. Added const to arg types
*                       for pathname and argv.
*       03-08-90  GJF   Replace _LOAD_DS with _CALLTYPE1 and added #include
*                       <cruntime.h>.
*       07-24-90  SBM   Removed redundant includes, replaced <assertm.h> by
*                       <assert.h>
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       02-14-90  SRW   Use NULL instead of _environ to get default.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Wide char enable.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _spawnv(modeflag, pathname, argv) - spawn a child process
*
*Purpose:
*       Spawns a child process.
*       formats the parameters and calls _spawnve to do the actual work.  The
*       NULL environment pointer indicates that the new process will inherit
*       the parents process's environment.  NOTE - at least one argument must
*       be present.  This argument is always, by convention, the name of the
*       file being spawned.
*
*Entry:
*       int modeflag   - mode to spawn (WAIT, NOWAIT, or OVERLAY)
*                        only WAIT and OVERLAY currently implemented
*       _TSCHAR *pathname - file to spawn
*       _TSCHAR **argv    - vector of arguments
*
*Exit:
*       returns exit code of child process
*       if fails, returns -1
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _tspawnv (
        int modeflag,
        const _TSCHAR *pathname,
        const _TSCHAR * const *argv
        )
{
        _ASSERTE(pathname != NULL);
        _ASSERTE(*pathname != _T('\0'));
        _ASSERTE(argv != NULL);
        _ASSERTE(*argv != NULL);
        _ASSERTE(**argv != _T('\0'));

        return(_tspawnve(modeflag,pathname,argv,NULL));
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\spawnvp.c ===
/***
*spawnvp.c - spawn a child process; search along PATH
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _spawnvp() - spawn a child process; search along PATH
*
*Revision History:
*       04-15-84  DFW   written
*       10-29-85  TC    added spawnvpe capability
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-20-89  GJF   Fixed copyright, alignment. Added const to arg types
*                       for filename and argv.
*       03-08-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>
*       05-21-90  GJF   Fixed stack checking pragma syntax.
*       08-24-90  SBM   Removed check_stack pragma since workhorse _spawnve
*                       does stack checks
*       09-27-90  GJF   New-style function declarator.
*       01-17-91  GJF   ANSI naming.
*       02-14-90  SRW   Use NULL instead of _environ to get default.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Wide char enable.
*       02-06-98  GJF   Changes for Win64: changed return type to intptr_t.
*
*******************************************************************************/

#ifndef _XBSTRICT

#include <cruntime.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>

/***
*int _spawnvp(modeflag, filename, argv) - spawn a child process (search PATH)
*
*Purpose:
*       Spawns a child process, with search along PATH variable.
*       formats the parameters and calls _spawnve to do the actual work. The
*       NULL environment pointer indicates the new process will inherit the
*       parents process's environment.  NOTE - at least one argument must be
*       present.  This argument is always, by convention, the name of the file
*       being spawned.
*
*Entry:
*       int modeflag   - mode to spawn (WAIT, NOWAIT, or OVERLAY)
*                        only WAIT and OVERLAY currently supported
*       _TSCHAR *pathname - name of file to spawn
*       _TSCHAR **argv    - vector of arguments
*
*Exit:
*       returns exit code of child process
*       returns -1 if fails
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _tspawnvp (
        int modeflag,
        REG3 const _TSCHAR *filename,
        const _TSCHAR * const *argv
        )
{
        return _tspawnvpe(modeflag, filename, argv, NULL);
}

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\wexecv.c ===
/***
*wexecv.c - execute a file (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wexecv() - execute a file
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "execv.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\wexecvp.c ===
/***
*wexecvp.c - execute a file and search along PATH (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wexecvp() - execute a file and search along PATH
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "execvp.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\wexecle.c ===
/***
*wexecle.c - execute a file with arg list and environment (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wexecle() - execute a file
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "execle.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\wdospawn.c ===
/***
*wdospawn.c - spawn a child process (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wdospawn - spawn a child process and pass wide environment
*
*Revision History:
*	11-19-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "dospawn.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\wexeclpe.c ===
/***
*wexeclpe.c - execute a file (search along PATH) (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wexeclpe() - execute a file and search along PATH
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "execlpe.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\wexecl.c ===
/***
*wexecl.c - execute a file with a list of arguments (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wexecl() - execute a file with a list of arguments
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "execl.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\wexecve.c ===
/***
*wexecve.c - execute a file with a given environment (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wexecve() - execute a file
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#define EXECVE
#include "spawnve.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\wexeclp.c ===
/***
*wexeclp.c - execute a file (search along PATH) (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wexeclp() - execute a file and search along PATH
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "execlp.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\wspawnl.c ===
/***
*wspawnl.c - spawn a child process (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wspawnl() - spawn a child process
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnl.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\wspawnve.c ===
/***
*wspawnve.c - Low level routine eventually called by all _wspawnXX routines
*	also contains all code for _wexecve, called by _wexecXX routines
*       (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*	This is the low level routine which is eventually invoked by all the
*	_wspawnXX routines.
*
*	This is also the low-level routine which is eventually invoked by
*	all of the _wexecXX routines.
*
*Revision History:
*	11-19-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnve.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\wspawnlp.c ===
/***
*wspawnlp.c - spawn a file; search along PATH (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wspawnlp() - spawn a file with search along PATH
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnlp.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\wexecvpe.c ===
/***
*wexecvpe.c - execute a file with given environ; search along PATH (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wexecvpe() - execute a file with given environ
*
*Revision History:
*	11-19-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "execvpe.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\wspwnlpe.c ===
/***
*wspwnlpe.c - spawn a child process with environ and search along PATH (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wspawnlpe() - spawn a child process with environ/PATH search
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnlpe.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\wspawnle.c ===
/***
*wspawnle.c - spawn a child process with given environment (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wspawnle() - spawn a child process with given environ
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnle.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\wspawnv.c ===
/***
*wspawnv.c - spawn a child process (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wspawnv() - spawn a child process
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnv.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\wspawnvp.c ===
/***
*wspawnvp.c - spawn a child process; search along PATH (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wspawnvp() - spawn a child process; search along PATH
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnvp.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\extinc\undname.h ===
#if !defined(_M_I86)
    //  The 32-bit compiler

    #define __far
    #define __near
    #define __pascal
    #define __loadds
#endif


typedef char *        pchar_t;
typedef const char *  pcchar_t;

typedef void * ( __cdecl * Alloc_t )( size_t );
typedef void   ( __cdecl * Free_t  )( void * );
typedef char * ( __cdecl * GetParameter_t  )( long );


#ifdef  __cplusplus
extern "C"
#endif


#ifdef _CRTBLD
_CRTIMP pchar_t __cdecl __unDName (
#else
pchar_t __cdecl unDName (
#endif
                            pchar_t,		// User supplied buffer (or NULL)
                            pcchar_t,		// Input decorated name
                            int,			// Maximum length of user buffer
                            Alloc_t,		// Address of heap allocator
                            Free_t,			// Address of heap deallocator
                            unsigned short	// Feature disable flags
                        );

#ifdef  __cplusplus
extern "C"
#endif

#ifdef _CRTBLD
_CRTIMP pchar_t __cdecl __unDNameEx (
#else
pchar_t __cdecl unDNameEx (
#endif
                            pchar_t,		// User supplied buffer (or NULL)
                            pcchar_t,		// Input decorated name
                            int,			// Maximum length of user buffer
                            Alloc_t,		// Address of heap allocator
                            Free_t,			// Address of heap deallocator
							GetParameter_t,	// Function to get any template parameters
                            unsigned long	// Feature disable flags
                        );
/*
 *  The user may provide a buffer into which the undecorated declaration
 *  is to be placed, in which case, the length field must be specified.
 *  The length is the maximum number of characters (including the terminating
 *  NULL character) which may be written into the user buffer.
 *
 *  If the output buffer is NULL, the length field is ignored, and the
 *  undecorator will allocate a buffer exactly large enough to hold the
 *  resulting declaration.  It is the users responsibility to deallocate
 *  this buffer.
 *
 *  The user may also supply the allocator and deallocator functions if
 *  they wish.  If they do, then all heap actions performed by the routine
 *  will use the provided heap functions.
 *
 *  If the allocator address is NULL, then the routine will default to using
 *  the standard allocator and deallocator functions, 'malloc' and 'free'.
 *
 *  If an error occurs internally, then the routine will return NULL.  If
 *  it was successful, it will return the buffer address provided by the
 *  user, or the address of the buffer allocated on their behalf, if they
 *  specified a NULL buffer address.
 *
 *  If a given name does not have a valid undecoration, the original name
 *  is returned in the output buffer.
 *
 *  Fine selection of a number of undecorator attributes is possible, by
 *  specifying flags (bit-fields) to disable the production of parts of the
 *  complete declaration.  The flags may be OR'ed together to select multiple
 *  disabling of selected fields.  The fields and flags are as follows :-
 */

#define UNDNAME_COMPLETE                (0x0000)    // Enable full undecoration

#define UNDNAME_NO_LEADING_UNDERSCORES  (0x0001)    // Remove leading underscores from MS extended keywords
#define UNDNAME_NO_MS_KEYWORDS          (0x0002)    // Disable expansion of MS extended keywords
#define UNDNAME_NO_FUNCTION_RETURNS     (0x0004)    // Disable expansion of return type for primary declaration
#define UNDNAME_NO_ALLOCATION_MODEL     (0x0008)    // Disable expansion of the declaration model
#define UNDNAME_NO_ALLOCATION_LANGUAGE  (0x0010)    // Disable expansion of the declaration language specifier
  #define   UNDNAME_NO_MS_THISTYPE          (0x0020)    /* NYI */   // Disable expansion of MS keywords on the 'this' type for primary declaration
  #define   UNDNAME_NO_CV_THISTYPE          (0x0040)    /* NYI */   // Disable expansion of CV modifiers on the 'this' type for primary declaration
#define UNDNAME_NO_THISTYPE             (0x0060)    // Disable all modifiers on the 'this' type
#define UNDNAME_NO_ACCESS_SPECIFIERS    (0x0080)    // Disable expansion of access specifiers for members
#define UNDNAME_NO_THROW_SIGNATURES     (0x0100)    // Disable expansion of 'throw-signatures' for functions and pointers to functions
#define UNDNAME_NO_MEMBER_TYPE          (0x0200)    // Disable expansion of 'static' or 'virtual'ness of members
#define UNDNAME_NO_RETURN_UDT_MODEL     (0x0400)    // Disable expansion of MS model for UDT returns
#define UNDNAME_32_BIT_DECODE           (0x0800)    // Undecorate 32-bit decorated names
#define UNDNAME_NAME_ONLY               (0x1000)    // Crack only the name for primary declaration;
                                                    //  return just [scope::]name.  Does expand template params
#define UNDNAME_TYPE_ONLY               (0x2000)    // Input is just a type encoding; compose an abstract declarator
#define UNDNAME_HAVE_PARAMETERS         (0x4000)    // The real templates parameters are available
#define UNDNAME_NO_ECSU                 (0x8000)    // Suppress enum/class/struct/union
#define UNDNAME_NO_IDENT_CHAR_CHECK     (0x10000)   // Suppress check for IsValidIdentChar
#define UNDNAME_NO_PTR64				(0x20000)	// disable just ptr64 in output
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\wspwnvpe.c ===
/***
*wspwnvpe.c - spawn a child process with given environ (search PATH) (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wspawnvpe() - spawn a child process with given environ (search
*	PATH)
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "spawnvpe.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\exec\wsystem.c ===
/***
*wsystem.c - pass a command line to the shell (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wsystem() - passes a command to the shell
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "system.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\awint.h ===
/***
*awint.h - internal definitions for A&W Win32 wrapper routines.
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains internal definitions/declarations for A&W wrapper functions.
*       Not included in internal.h since windows.h is required for these.
*
*       [Internal]
*
*Revision History:
*       03-30-94  CFW   Module created.
*       04-18-94  CFW   Add lcid parameter.
*       02-14-95  CFW   Clean up Mac merge.
*       02-24-95  CFW   Add _crtMessageBox.
*       02-27-95  CFW   Change __crtMessageBoxA params.
*       03-29-95  CFW   Add error message to internal headers.
*       05-26-95  GJF   Changed prototype for __crtGetEnvironmentStringsA.
*       12-14-95  JWM   Add "#pragma once".
*       03-16-97  RDK   Added error flag to __crtGetStringTypeA.
*       03-17-97  RDK   Added error flag to __crtLCMapStringA.
*       08-22-00  GB    Added __ansicp and __convertcp
*
****/

#if _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifdef _WIN32

#ifndef _INC_AWINC
#define _INC_AWINC

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif /* _CRTBLD */

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#endif // XBOX

/* internal A&W routines */

#ifndef _XBOX
int __cdecl __crtCompareStringW(LCID, DWORD, LPCWSTR, int, LPCWSTR, int, int);
int __cdecl __crtCompareStringA(LCID, DWORD, LPCSTR, int, LPCSTR, int, int);

int __cdecl __crtGetLocaleInfoW(LCID, LCTYPE, LPWSTR, int, int);
int __cdecl __crtGetLocaleInfoA(LCID, LCTYPE, LPSTR, int, int);
 
int __cdecl __crtLCMapStringW(LCID, DWORD, LPCWSTR, int, LPWSTR, int, int);
int __cdecl __crtLCMapStringA(LCID, DWORD, LPCSTR, int, LPSTR, int, int, BOOL);

BOOL __cdecl __crtGetStringTypeW(DWORD, LPCWSTR, int, LPWORD, int, int);
BOOL __cdecl __crtGetStringTypeA(DWORD, LPCSTR, int, LPWORD, int, int, BOOL);

LPVOID __cdecl __crtGetEnvironmentStringsW(VOID);
LPVOID __cdecl __crtGetEnvironmentStringsA(VOID);

LPWSTR __cdecl __crtGetCommandLineW(VOID);

int __cdecl __crtMessageBoxA(LPCSTR, LPCSTR, UINT);

/* internal routines for supporting A&W routines */

int __cdecl __ansicp(int);
char * __cdecl __convertcp(int, int, const char *, int *, char *, int);
#endif // XBOX

#ifdef __cplusplus
}
#endif

#endif /* _INC_AWINC */

#endif /* _WIN32 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\extinc\rttidata.h ===
//
//	_RTTIBaseClassDescriptor
//
//	TypeDescriptor is declared in ehdata.h
//
#if defined(_M_IA64) || defined(VERSP_P7)	/*IFSTRIP=IGN*/
#pragma pack(push, rttidata, 4)
#endif

#ifndef WANT_NO_TYPES
typedef const struct	_s_RTTIBaseClassDescriptor	{
#if defined(_M_IA64) && !defined(VERSP_P7)
	__int32     					pTypeDescriptor;    // Image relative offset of TypeDescriptor
#else
	TypeDescriptor					*pTypeDescriptor;
#endif
	DWORD							numContainedBases;
	PMD								where;
	DWORD							attributes;
	} _RTTIBaseClassDescriptor;
#endif // WANT_NO_TYPES

#define BCD_NOTVISIBLE				0x00000001
#define BCD_AMBIGUOUS				0x00000002
#define BCD_PRIVORPROTINCOMPOBJ		0x00000004
#define BCD_PRIVORPROTBASE			0x00000008
#define BCD_VBOFCONTOBJ				0x00000010
#define BCD_NONPOLYMORPHIC			0x00000020

#define BCD_PTD(bcd)				((bcd).pTypeDescriptor)
#define BCD_NUMCONTBASES(bcd)		((bcd).numContainedBases)
#define BCD_WHERE(bcd)				((bcd).where)
#define BCD_ATTRIBUTES(bcd)			((bcd).attributes)
#if defined(_M_IA64)
#define BCD_PTD_IB(bcd,ib)			((TypeDescriptor*)((ib) + (bcd).pTypeDescriptor))
#endif


//
//	_RTTIBaseClassArray
//
#pragma warning(disable:4200)		// get rid of obnoxious nonstandard extension warning
#ifndef WANT_NO_TYPES
typedef const struct	_s_RTTIBaseClassArray	{
#if defined(_M_IA64) && !defined(VERSP_P7)
	__int32                 		arrayOfBaseClassDescriptors[];  // Image relative offset of _RTTIBaseClassDescriptor
#else
	_RTTIBaseClassDescriptor		*arrayOfBaseClassDescriptors[];
#endif
	} _RTTIBaseClassArray;
#endif // WANT_NO_TYPES
#pragma warning(default:4200)

//
//	_RTTIClassHierarchyDescriptor
//
#ifndef WANT_NO_TYPES
typedef const struct	_s_RTTIClassHierarchyDescriptor	{
	DWORD							signature;
	DWORD							attributes;
	DWORD							numBaseClasses;
#if defined(_M_IA64) && !defined(VERSP_P7)
	__int32         				pBaseClassArray;    // Image relative offset of _RTTIBaseClassArray
#else
	_RTTIBaseClassArray				*pBaseClassArray;
#endif
	} _RTTIClassHierarchyDescriptor;
#endif // WANT_NO_TYPES

#define CHD_MULTINH					0x00000001
#define CHD_VIRTINH					0x00000002
#define CHD_AMBIGUOUS				0x00000004

#define CHD_SIGNATURE(chd)			((chd).signature)
#define CHD_ATTRIBUTES(chd)			((chd).attributes)
#define CHD_NUMBASES(chd)			((chd).numBaseClasses)
#define CHD_PBCA(chd)				((chd).pBaseClassArray)
#define CHD_PBCD(bcd)				(bcd)
#if defined(_M_IA64)
#define CHD_PBCA_IB(chd,ib)			((_RTTIBaseClassArray*)((ib) + (chd).pBaseClassArray))
#define CHD_PBCD_IB(bcd,ib)			((_RTTIBaseClassDescriptor*)((ib) + bcd))
#endif

//
//	_RTTICompleteObjectLocator
//
#ifndef WANT_NO_TYPES
typedef const struct	_s_RTTICompleteObjectLocator	{
	DWORD							signature;
	DWORD							offset;
	DWORD							cdOffset;
#if defined(_M_IA64) && !defined(VERSP_P7)
	__int32		    			    pTypeDescriptor;    // Image relative offset of TypeDescriptor
	__int32                         pClassDescriptor;   // Image relative offset of _RTTIClassHierarchyDescriptor
#else
	TypeDescriptor					*pTypeDescriptor;
	_RTTIClassHierarchyDescriptor	*pClassDescriptor;
#endif
	} _RTTICompleteObjectLocator;
#endif // WANT_NO_TYPES

#define COL_SIGNATURE(col)			((col).signature)
#define COL_OFFSET(col)				((col).offset)
#define COL_CDOFFSET(col)			((col).cdOffset)
#define COL_PTD(col)				((col).pTypeDescriptor)
#define COL_PCHD(col)				((col).pClassDescriptor)
#if defined(_M_IA64)
#define COL_PTD_IB(col,ib)			((TypeDescriptor*)((ib) + (col).pTypeDescriptor))
#define COL_PCHD_IB(col,ib)			((_RTTIClassHierarchyDescriptor*)((ib) + (col).pClassDescriptor))
#endif

#ifdef BUILDING_TYPESRC_C
//
// Type of the result of __RTtypeid and internal applications of typeid().
// This also introduces the tag "type_info" as an incomplete type.
//

typedef const class type_info &__RTtypeidReturnType;

//
// Declaration of CRT entrypoints, as seen by the compiler.  Types are 
// simplified so as to avoid type matching hassles.
//

#ifndef THROWSPEC
#if _MSC_VER >= 1300
#define THROWSPEC(_ex) throw _ex
#else
#define THROWSPEC(_ex)
#endif
#endif

// Perform a dynamic_cast on obj. of polymorphic type
extern "C" PVOID __cdecl __RTDynamicCast (
								PVOID,				// ptr to vfptr
								LONG,				// offset of vftable
								PVOID,				// src type
								PVOID,				// target type
								BOOL) THROWSPEC((...)); // isReference

// Perform 'typeid' on obj. of polymorphic type
extern "C" PVOID __cdecl __RTtypeid (PVOID)  THROWSPEC((...));	// ptr to vfptr

// Perform a dynamic_cast from obj. of polymorphic type to void*
extern "C" PVOID __cdecl __RTCastToVoid (PVOID)  THROWSPEC((...)); // ptr to vfptr
#endif

#if defined(_M_IA64) || defined(VERSP_P7)	/*IFSTRIP=IGN*/
#pragma pack(pop, rttidata)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\extinc\undname.inl ===
/*
 *	This module contains the definitions for the inline functions used by the
 *	name undecorator.  It is intended that this file should be included
 *	somewhere in the source file for the undecorator to maximise the chance
 *	that they will be truly inlined.
 */

//	The following class is a special node class, used in the implementation
//	of the internal chaining mechanism of the 'DName's

class	charNode;
class	pcharNode;
class	pDNameNode;
class	DNameStatusNode;


#if	( NO_VIRTUAL )
enum	NodeType
{
	charNode_t,
	pcharNode_t,
	pDNameNode_t,
	DNameStatusNode_t

};
#endif	// NO_VIRTUAL


class	DNameNode
{
private:

#if	NO_VIRTUAL
		NodeType			typeIndex;
#endif	// NO_VIRTUAL

		DNameNode *			next;

protected:

#if	( !NO_VIRTUAL )
					__near	DNameNode ();
#else	// } elif NO_VIRTUAL {
					__near	DNameNode ( NodeType );
#endif	// NO_VIRTUAL

					__near	DNameNode ( const DNameNode & );

public:

virtual	int			__near	length () const PURE;
virtual	char		__near	getLastChar () const PURE;
virtual	pchar_t		__near	getString ( pchar_t, int ) const PURE;
		DNameNode *	__near	clone ();
		DNameNode *	__near	nextNode () const;

		DNameNode &	__near	operator += ( DNameNode * );

};


class	charNode		: public DNameNode
{
private:
		char				me;

public:
					__near	charNode ( char );

virtual	int			__near	length () const;
virtual	char		__near	getLastChar () const;
virtual	pchar_t		__near	getString ( pchar_t, int ) const;

};


class	pcharNode		: public DNameNode
{
private:
		pchar_t				me;
		int					myLen;

public:
					__near	pcharNode ( pcchar_t, int = 0 );

virtual	int			__near	length () const;
virtual	char		__near	getLastChar () const;
virtual	pchar_t		__near	getString ( pchar_t, int ) const;

};


class	pDNameNode		: public DNameNode
{
private:
		DName *				me;

public:
					__near	pDNameNode ( DName * );

virtual	int			__near	length () const;
virtual	char		__near	getLastChar () const;
virtual	pchar_t		__near	getString ( pchar_t, int ) const;

};


class	DNameStatusNode	: public DNameNode
{
private:
#define	TruncationMessage		(" ?? ")
#define	TruncationMessageLength	(4)

		DNameStatus			me;
		int					myLen;

public:
					__near	DNameStatusNode ( DNameStatus );

virtual	int			__near	length () const;
virtual	char		__near	getLastChar () const;
virtual	pchar_t		__near	getString ( pchar_t, int ) const;

};



//	Memory allocation functions
			
inline	void __far *	__near __pascal	operator new ( size_t sz, HeapManager &, int noBuffer )
{	return	heap.getMemory ( sz, noBuffer );	}

void __far *	__near	HeapManager::getMemory ( size_t sz, int noBuffer )
{
	//	Align the allocation on an appropriate boundary

	sz	= (( sz + PACK_SIZE-1 ) & ~(PACK_SIZE-1) );

	if	( noBuffer )
		return	( *pOpNew )( sz );
	else
	{
		//	Handle a potential request for no space

		if	( !sz )
			sz	= PACK_SIZE;

		if	( blockLeft < sz )
		{
			//	Is the request greater than the largest buffer size ?

			if	( sz > memBlockSize )
				return	0;		// If it is, there is nothing we can do


			//	Allocate a new block

			Block *	pNewBlock	= rnew Block;


			//	Did the allocation succeed ?  If so connect it up

			if	( pNewBlock )
			{
				//	Handle the initial state

				if	( tail )
					tail	= tail->next	= pNewBlock;
				else
					head	= tail			= pNewBlock;

				//	Compute the remaining space

				blockLeft	= memBlockSize - sz;

			}	// End of IF then
			else
				return	0;		// Oh-oh!  Memory allocation failure

		}	// End of IF then
		else
			blockLeft	-= sz;	// Deduct the allocated amount

		//	And return the buffer address

		return	&( tail->memBlock[ blockLeft ]);

	}	// End of IF else
}	// End of "HeapManager" FUNCTION "getMemory(size_t,int)"




//	Friend functions of 'DName'

inline DName	__near __pascal	operator + ( char c, const DName & rd )
{	return	DName ( c ) + rd;	}

inline DName	__near __pascal	operator + ( DNameStatus st, const DName & rd )
{	return	DName ( st ) + rd;	}

inline DName	__near __pascal	operator + ( pcchar_t s, const DName & rd )
{	return	DName ( s ) + rd;	}


//	The 'DName' constructors

inline		__near	DName::DName ()					{	node	= 0;	stat	= DN_valid;	isIndir	= 0;	isAUDC	= 0; isAUDTThunk = 0;	isArrayType = 0;	NoTE	= 0; }
inline		__near	DName::DName ( DNameNode * pd )	{	node	= pd;	stat	= DN_valid;	isIndir	= 0;	isAUDC	= 0; isAUDTThunk = 0;	isArrayType = 0;	NoTE	= 0; }

__near	DName::DName ( char c )
{
	stat	= DN_valid;
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;
	node	= 0;
	NoTE	= 0;

	//	The NULL character is boring, do not copy

	if	( c )
		doPchar ( &c, 1 );

}	// End of "DName" CONSTRUCTOR '(char)'


#if	1
inline __near	DName::DName ( const DName & rd )
{
	stat	= rd.stat;
	isIndir	= rd.isIndir;
	isAUDC	= rd.isAUDC;
	isAUDTThunk = rd.isAUDTThunk;
	isArrayType = rd.isArrayType;
	node	= rd.node;
	NoTE	= rd.NoTE;
}	// End of "DName" CONSTRUCTOR '(const DName&)'
#endif


__near	DName::DName ( DName * pd )
{
	if	( pd )
	{
		node	= gnew pDNameNode ( pd );
		stat	= ( node ? DN_valid : DN_error );

	}	// End of IF else
	else
	{
		stat	= DN_valid;
		node	= 0;

	}	// End of IF else

	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;
	NoTE	= 0;

}	// End of "DName" CONSTRUCTOR '( DName* )'


__near	DName::DName ( pcchar_t s )
{
	stat	= DN_valid;
	node	= 0;
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;
	NoTE	= 0;

	if	( s )
		doPchar ( s, und_strlen ( s ));

}	// End of "DName" CONSTRUCTOR '(pcchar_t)'


__near	DName::DName ( pcchar_t & name, char terminator )
{
	stat	= DN_valid;
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;
	node	= 0;
	NoTE	= 0;

	//	Is there a string ?

	if	( name )
		if	( *name )
		{
			int	len	= 0;


			//	How long is the string ?

			for	( pcchar_t s = name; *name && ( *name != terminator ); name++ )
				if	( isValidIdentChar ( *name ) || UnDecorator::doNoIdentCharCheck () )
					len++;
				else
				{
					stat	= DN_invalid;

					return;

				}	// End of IF else

			//	Copy the name string fragment

			doPchar ( s, len );

			//	Now gobble the terminator if present, handle error conditions

			if	( *name )
			{
				if	( *name++ != terminator )
				{
					stat	= DN_error;
					node	= 0;

				}	// End of IF then
				else
					stat	= DN_valid;

			}	// End of IF then
			elif	( status () == DN_valid )
				stat	= DN_truncated;

		}	// End of IF then
		else
			stat	= DN_truncated;
	else
		stat	= DN_invalid;

}	// End of "DName" CONSTRUCTOR '(pcchar_t&,char)'


__near	DName::DName ( unsigned long num )
{
	char	buf[ 11 ];
	char *	pBuf	= buf + 10;


	stat	= DN_valid;
	node	= 0;
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;
	NoTE	= 0;

	//	Essentially, 'ultoa ( num, buf, 10 )' :-

	*pBuf	= 0;

	do
	{
		*( --pBuf )	= (char)(( num % 10 ) + '0' );
		num			/= 10UL;

	}	while	( num );

	doPchar ( pBuf, ( 10 - (int) ( pBuf - buf )));

}	// End of "DName" CONSTRUCTOR '(unsigned long)'

__near  DName::DName ( int num )
{
	char	buf[ 12 ];
	char *	pBuf	= buf + 11;

	stat	= DN_valid;
	node	= 0;
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;
	NoTE	= 0;

	//	Essentially, 'ltoa ( num, buf, 10 )' :-

	*pBuf	= 0;

	bool	fSigned = false;
	if (num < 0) {
		fSigned = true;
		num = -num;
	}

	do
	{
		*( --pBuf )	= (char)(( num % 10 ) + '0' );
		num			/= 10UL;

	}	while	( num );

	if (fSigned) {
		*(--pBuf) = '-';
	}

	doPchar ( pBuf, ( 11 - (int) ( pBuf - buf )));
}


__near	DName::DName ( DNameStatus st )
{
	stat	= ((( st == DN_invalid ) || ( st == DN_error )) ? st : DN_valid );
	node	= gnew DNameStatusNode ( st );
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;
	NoTE	= 0;

	if	( !node )
		stat	= DN_error;

}	// End of "DName" CONSTRUCTOR '(DNameStatus)'



//	Now the member functions for 'DName'

int		__near	DName::isValid () const		{	return	(( status () == DN_valid ) || ( status () == DN_truncated ));	}
int		__near	DName::isEmpty () const		{	return	(( node == 0 ) || !isValid ());	}

inline	DNameStatus	__near	DName::status () const	{	return	(DNameStatus)stat;	}	// The cast is to keep Glockenspiel quiet

inline	DName &	__near	DName::setPtrRef ()			{	isIndir	= 1;	return	*this;	}
inline	int		__near	DName::isPtrRef () const	{	return	isIndir;	}
inline	int		__near	DName::isUDC () const		{	return	( !isEmpty () && isAUDC );	}
inline	void	__near	DName::setIsUDC ()			{	if	( !isEmpty ())	isAUDC	= TRUE;	}
inline	int		__near	DName::isUDTThunk () const		{	return	( !isEmpty () && isAUDTThunk );	}
inline	void	__near	DName::setIsUDTThunk ()			{	if	( !isEmpty ())	isAUDTThunk	= TRUE;	}
inline	void	__near	DName::setIsArray ()		{	isArrayType	= 1;	}
inline	int		__near	DName::isArray () const		{	return	isArrayType;	}
inline	int				DName::isNoTE () const		{	return NoTE;	}
inline	void			DName::setIsNoTE ()			{	NoTE = TRUE;	}

int	__near	DName::length () const
{
	int	len	= 0;


	if	( !isEmpty ())
		for	( DNameNode * pNode = node; pNode; pNode = pNode->nextNode ())
			len	+= pNode->length ();

	return	len;

}	// End of "DName" FUNCTION "length"


char	__near	DName::getLastChar () const
{
	DNameNode * pLast = 0;

	if ( !isEmpty ())
		for ( DNameNode * pNode = node; pNode; pNode = pNode->nextNode ())
			if ( pNode->length () != 0 )
				pLast = pNode;

	return	pLast != 0 ? pLast->getLastChar () : '\0';

}	// End of "DName" FUNCTION "getLastChar"


pchar_t	__near	DName::getString ( pchar_t buf, int max ) const
{
	if		( !isEmpty ())
	{
		//	Does the caller want a buffer allocated ?

		if	( !buf )
		{
			max	= length () + 1;
			buf	= gnew char[ max ];	// Get a buffer big enough

		}	// End of IF then

		//	If memory allocation failure, then return no buffer

		if	( buf )
		{
			//	Now, go through the process of filling the buffer (until max is reached)

			int			curLen	= max;
			DNameNode *	curNode	= node;
			pchar_t		curBuf	= buf;


			while	( curNode && ( curLen > 0 ))
			{
				int		fragLen	= curNode->length ();
				pchar_t	fragBuf	= 0;


				//	Skip empty nodes

				if	( fragLen )
				{
					//	Handle buffer overflow

					if	(( curLen - fragLen ) < 0 )
						fragLen	= curLen;

					//	Now copy 'len' number of bytes of the piece to the buffer

					fragBuf	= curNode->getString ( curBuf, fragLen );

					//	Should never happen, but handle it anyway

					if	( fragBuf )
					{
						//	Update string position

						curLen	-= fragLen;
						curBuf	+= fragLen;

					}	// End of IF
				}	// End of IF

				//	Move on to the next name fragment

				curNode	= curNode->nextNode ();

			}	// End of WHILE

			*curBuf	= 0;	// Always NULL terminate the resulting string

		}	// End of IF
	}	// End of IF then
	elif	( buf )
		*buf	= 0;

	//	Return the buffer

	return	buf;

}	// End of "DName" FUNCTION "getString(pchar_t,int)"


DName	__near	DName::operator + ( char ch ) const
{
	DName	local ( *this );


	if	( local.isEmpty ())
		local	= ch;
	else
		local	+= ch;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(char)"


DName	__near	DName::operator + ( pcchar_t str ) const
{
	DName	local ( *this );


	if	( local.isEmpty ())
		local	= str;
	else
		local	+= str;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(pcchar_t)"


DName	__near	DName::operator + ( const DName & rd ) const
{
	DName	local ( *this );


	if		( local.isEmpty ())
		local	= rd;
	elif	( rd.isEmpty ())
		local	+= rd.status ();
	else
		local	+= rd;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(const DName&)"


DName	__near	DName::operator + ( DName * pd ) const
{
	DName	local ( *this );


	if	( local.isEmpty ())
		local	= pd;
	else
		local	+= pd;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(DName*)"


DName	__near	DName::operator + ( DNameStatus st ) const
{
	DName	local ( *this );


	if	( local.isEmpty ())
		local	= st;
	else
		local	+= st;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(DNameStatus)"



DName &	__near	DName::operator += ( char ch )
{
	if	( ch )
		if	( isEmpty ())
			*this	= ch;
		else
		{
			node	= node->clone ();

			if	( node )
				*node	+= gnew charNode ( ch );
			else
				stat	= DN_error;

		}	// End of IF

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR "+=(char)"


DName &	__near	DName::operator += ( pcchar_t str )
{
	if	( str && *str )
		if	( isEmpty ())
			*this	= str;
		else
		{
			node	= node->clone ();

			if	( node )
				*node	+= gnew pcharNode ( str );
			else
				stat	= DN_error;

		}	// End of IF

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR "+=(pcchar_t)"


DName &	__near	DName::operator += ( const DName & rd )
{
	if	( rd.isEmpty ())
		*this	+= rd.status ();
	else
		if	( isEmpty ())
			*this	= rd;
		else
		{
			node	= node->clone ();

			if	( node )
				*node	+= rd.node;
			else
				stat	= DN_error;

		}	// End of IF

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR "+=(const DName&)"


DName &	__near	DName::operator += ( DName * pd )
{
	if	( pd )
		if		( isEmpty ())
			*this	= pd;
		elif	(( pd->status () == DN_valid ) || ( pd->status () == DN_truncated ))
		{
			DNameNode *	pNew	= gnew pDNameNode ( pd );


			if	( pNew )
			{
				node	= node->clone ();

				if	( node )
					*node	+= pNew;

			}	// End of IF then
			else
				node	= 0;

			if	( !node )
				stat	= DN_error;

		}	// End of IF then
		else
			*this	+= pd->status ();

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR "+=(DName*)"


DName &	__near	DName::operator += ( DNameStatus st )
{
	if	( isEmpty () || (( st == DN_invalid ) || ( st == DN_error )))
		*this	= st;
	else
	{
		DNameNode *	pNew	= gnew DNameStatusNode ( st );


		if	( pNew )
		{
			node	= node->clone ();

			if	( node )
				*node	+= pNew;

		}	// End of IF then
		else
			node	= 0;

		if	( !node )
			stat	= DN_error;

	}	// End of IF else

	//	Return self

	return	*this;

}	// End of "DName" OPERATOR "+=(DNameStatus)"



DName &	__near	DName::operator |= ( const DName & rd )
{
	//	Attenuate the error status.  Always becomes worse.  Don't propogate truncation

	if	(( status () != DN_error ) && !rd.isValid ())
		stat	= rd.status ();

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '|=(const DName&)'



DName &	__near	DName::operator = ( char ch )
{
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;

	doPchar ( &ch, 1 );

	return	*this;

}	// End of "DName" OPERATOR '=(char)'


DName &	__near	DName::operator = ( pcchar_t str )
{
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;

	doPchar ( str, und_strlen ( str ));

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '=(pcchar_t)'


DName &	__near	DName::operator = ( const DName & rd )
{
	if	(( status () == DN_valid ) || ( status () == DN_truncated ))
	{
		stat	= rd.stat;
		isIndir	= rd.isIndir;
		isAUDC	= rd.isAUDC;
		isAUDTThunk = rd.isAUDTThunk;
		isArrayType	= rd.isArrayType;
		node	= rd.node;

	}	// End of IF

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '=(const DName&)'


DName &	__near	DName::operator = ( DName * pd )
{
	if	(( status () == DN_valid ) || ( status () == DN_truncated ))
		if	( pd )
		{
			isIndir	= 0;
			isAUDC	= 0;
			isAUDTThunk = 0;
			isArrayType	= 0;
			node	= gnew pDNameNode ( pd );

			if	( !node )
				stat	= DN_error;

		}	// End of IF then
		else
			*this	= DN_error;

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '=(DName*)'


DName &	__near	DName::operator = ( DNameStatus st )
{
	if	(( st == DN_invalid ) || ( st == DN_error ))
	{
		node	= 0;

		if	( status () != DN_error )
			stat	= st;

	}	// End of IF then
	elif	(( status () == DN_valid ) || ( status () == DN_truncated ))
	{
		isIndir	= 0;
		isAUDC	= 0;
		isAUDTThunk = 0;
		isArrayType	= 0;
		node	= gnew DNameStatusNode ( st );

		if	( !node )
			stat	= DN_error;

	}	// End of ELIF then

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '=(DNameStatus)'


//	Private implementation functions for 'DName'

void	__near	DName::doPchar ( pcchar_t str, int len )
{
	if	( !(( status () == DN_invalid ) || ( status () == DN_error )))
		if		( node )
			*this	= DN_error;
		elif	( str && len )
		{
			//	Allocate as economically as possible

			switch	( len )
			{
			case 0:
					stat	= DN_error;
				break;

			case 1:
					node	= gnew charNode ( *str );

					if	( !node )
						stat	= DN_error;
				break;

			default:
					node	= gnew pcharNode ( str, len );

					if	( !node )
						stat	= DN_error;
				break;

			}	// End of SWITCH
		}	// End of ELIF
		else
			stat	= DN_invalid;

}	// End of "DName" FUNCTION "doPchar(pcchar_t,int)"



//	The member functions for the 'Replicator'

inline	int	__near	Replicator::isFull () const		{	return	( index == 9 );	}
inline	__near		Replicator::Replicator ()
:	ErrorDName ( DN_error ), InvalidDName ( DN_invalid )
{	index	= -1;	}



Replicator &	__near	Replicator::operator += ( const DName & rd )
{
	if	( !isFull () && !rd.isEmpty ())
	{
		DName *	pNew	= gnew DName ( rd );


		//	Don't update if failed

		if	( pNew )
			dNameBuffer[ ++index ]	= pNew;

	}	// End of IF

	return	*this;

}	// End of "Replicator" OPERATOR '+=(const DName&)'


const DName &	__near	Replicator::operator [] ( int x ) const
{
	if		(( x < 0 ) || ( x > 9 ))
		return	ErrorDName;
	elif	(( index == -1 ) || ( x > index ))
		return	InvalidDName;
	else
		return	*dNameBuffer[ x ];

}	// End of "Replicator" OPERATOR '[](int)'



//	The member functions for the 'DNameNode' classes

#if	( !NO_VIRTUAL )
__near	DNameNode::DNameNode ()
#else	// } elif NO_VIRTUAL {
__near	DNameNode::DNameNode ( NodeType ndTy )
:	typeIndex ( ndTy )
#endif	// NO_VIRTUAL
{	next	= 0;	}

inline	__near	DNameNode::DNameNode ( const DNameNode & rd )	{	next	= (( rd.next ) ? rd.next->clone () : 0 );	}

inline	DNameNode *	__near	DNameNode::nextNode () const		{	return	next;	}

DNameNode *	__near	DNameNode::clone ()
{
	return	gnew pDNameNode ( gnew DName ( this ));
}

#if	( NO_VIRTUAL )
int	__near	DNameNode::length () const
{	//	Pure function, should not be called

	switch	( typeIndex )
	{
	case charNode_t:
		return	((charNode*)this )->length ();

	case pcharNode_t:
		return	((pcharNode*)this )->length ();

	case pDNameNode_t:
		return	((pDNameNode*)this )->length ();

	case DNameStatusNode_t:
		return	((DNameStatusNode*)this )->length ();

	}	// End of SWITCH

	return	0;
}


char	__near	DNameNode::getLastChar () const
{	//	Pure function, should not be called

	switch	( typeIndex )
	{
	case charNode_t:
		return	((charNode*)this )->getLastChar ();

	case pcharNode_t:
		return	((pcharNode*)this )->getLastChar ();

	case pDNameNode_t:
		return	((pDNameNode*)this )->getLastChar ();

	case DNameStatusNode_t:
		return	((DNameStatusNode*)this )->getLastChar ();

	}	// End of SWITCH

	return	0;
}


pchar_t	__near	DNameNode::getString ( pchar_t s, int l ) const
{	//	Pure function, should not be called

	switch	( typeIndex )
	{
	case charNode_t:
		return	((charNode*)this )->getString ( s, l );

	case pcharNode_t:
		return	((pcharNode*)this )->getString ( s, l );

	case pDNameNode_t:
		return	((pDNameNode*)this )->getString ( s, l );

	case DNameStatusNode_t:
		return	((DNameStatusNode*)this )->getString ( s, l );

	}	// End of SWITCH

	return	0;
}
#endif	// NO_VIRTUAL


DNameNode &	__near	DNameNode::operator += ( DNameNode * pNode )
{
	if	( pNode )
	{
		if	( next )
		{
			//	Skip to the end of the chain

			for	( DNameNode* pScan = next; pScan->next; pScan = pScan->next )
				;

			//	And append the new node

			pScan->next	= pNode;

		}	// End of IF then
		else
			next	= pNode;

	}	// End of IF

	//	And return self

	return	*this;

}	// End of "DNameNode" OPERATOR '+=(DNameNode*)'



//	The 'charNode' virtual functions

__near	charNode::charNode ( char ch )
#if	( NO_VIRTUAL )
:	DNameNode ( charNode_t )
#endif	// NO_VIRTUAL
{	me	= ch;	}

inline	int	__near	charNode::length () const		{	return	1;	}

inline	char __near	charNode::getLastChar () const	{	return	me;	}

pchar_t	__near	charNode::getString ( pchar_t buf, int len ) const
{
	if	( buf && len )
		*buf	= me;
	else
		buf		= 0;

	//	Now return the character

	return	buf;

}	// End of "charNode" FUNCTION "getString(pchar_t,int)"



//	The 'pcharNode' virtual functions

inline	int	__near	pcharNode::length () const		{	return	myLen;	}

inline	char __near	pcharNode::getLastChar () const	{	return	( myLen ? me[ myLen - 1 ] : '\0' );	}

__near	pcharNode::pcharNode ( pcchar_t str, int len )
#if ( NO_VIRTUAL )
:	DNameNode ( pcharNode_t )
#endif	// NO_VIRTUAL
{
	//	Get length if not supplied

	if	( !len && str )
		len	= und_strlen ( str );

	//	Allocate a new string buffer if valid state

	if	( len && str )
	{
		me		= gnew char[ len ];
		myLen	= len;

		if	( me )
			und_strncpy ( me, str, len );

	}	// End of IF then
	else
	{
		me		= 0;
		myLen	= 0;

	}	// End of IF else
}	// End of "pcharNode" CONSTRUCTOR '(pcchar_t,int)'


pchar_t	__near	pcharNode::getString ( pchar_t buf, int len ) const
{
	//	Use the shorter of the two lengths (may not be NULL terminated)

	if	( len > pcharNode::length ())
		len	= pcharNode::length ();

	//	Do the copy as appropriate

	return	(( me && buf && len ) ? und_strncpy ( buf, me, len ) : 0 );

}	// End of "pcharNode" FUNCTION "getString(pchar_t,int)"



//	The 'pDNameNode' virtual functions

__near	pDNameNode::pDNameNode ( DName * pName )
#if	( NO_VIRTUAL )
:	DNameNode ( pDNameNode_t )
#endif	// NO_VIRTUAL
{	me	= (( pName && (( pName->status () == DN_invalid ) || ( pName->status () == DN_error ))) ? 0 : pName );	}

inline	int	__near	pDNameNode::length () const					{	return	( me ? me->length () : 0 );	}

inline	char __near	pDNameNode::getLastChar () const			{	return	( me ? me->getLastChar () : '\0' ); }

pchar_t	__near	pDNameNode::getString ( pchar_t buf, int len ) const
{	return	(( me && buf && len ) ? me->getString ( buf, len ) : 0 );	}



//	The 'DNameStatusNode' virtual functions

__near	DNameStatusNode::DNameStatusNode ( DNameStatus stat )
#if	( NO_VIRTUAL )
:	DNameNode ( DNameStatusNode_t )
#endif	// NO_VIRTUAL
{	me	= stat;	myLen	= (( me == DN_truncated ) ? TruncationMessageLength : 0 );	}

inline	int	__near	DNameStatusNode::length () const	{	return	myLen;	}

inline	char __near	DNameStatusNode::getLastChar () const
{	return (( me == DN_truncated ) ? TruncationMessage[ TruncationMessageLength - 1 ] : '\0' );	}

pchar_t	__near	DNameStatusNode::getString ( pchar_t buf, int len ) const
{
	//	Use the shorter of the two lengths (may not be NULL terminated)

	if	( len > DNameStatusNode::length ())
		len	= DNameStatusNode::length ();

	//	Do the copy as appropriate

	return	((( me == DN_truncated ) && buf && len ) ? und_strncpy ( buf, TruncationMessage, len ) : 0 );

}	// End of "DNameStatusNode" FUNCTION "getString(pchar_t,int)"


static	unsigned int	__near __pascal	und_strlen ( pcchar_t str )
{
	for	( unsigned int len = 0; *str; str++ )
		len++;

	return	len;

}	// End of FUNCTION "und_strlen"


static	pchar_t			__near __pascal	und_strncpy ( pchar_t dst, pcchar_t src, unsigned int len )
{
	for	( char __far * d = dst; ( len && ( *d = *src )); d++, src++, len-- )
		;

	return	dst;

}	// End of FUNCTION "und_strncpy"

static	unsigned int	__near __pascal	und_strncmp ( pcchar_t first, pcchar_t last, unsigned int count)
{
	if (!count)
		return(0);

	while (--count && *first && *first == *last)
	{
		first++;
		last++;
	}

	return( *(unsigned char *)first - *(unsigned char *)last );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\assert.h ===
/***
*assert.h - define the assert macro
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the assert(exp) macro.
*       [ANSI/System V]
*
*       [Public]
*
*Revision History:
*       12-18-87  JCR   Added _FAR_ to declarations
*       01-18-88  JCR   Added fflush(stderr) to go with new stderr buffering scheme
*       02-10-88  JCR   Cleaned up white space
*       05-19-88  JCR   Use routine _assert() to save space
*       07-14-88  JCR   Allow user's to enable/disable assert multiple times in
*                       a single module [ANSI]
*       10-19-88  JCR   Revised to also work for the 386 (small model only)
*       12-22-88  JCR   Assert() must be an expression (no 'if' statements)
*       05-03-89  JCR   Added _INTERNAL_IFSTRIP for relinc usage
*       07-27-89  GJF   Cleanup, now specific to the 386
*       10-30-89  GJF   Fixed copyright
*       11-02-89  JCR   Changed "DLL" to "_DLL"
*       02-27-90  GJF   Added #include <cruntime.h> stuff. Also, removed some
*                       (now) useless preprocessor directives.
*       03-21-90  GJF   Replaced _cdecl with _CALLTYPE1 in prototype.
*       07-31-90  SBM   added ((void)0) to NDEBUG definition, now ANSI
*       08-20-91  JCR   C++ and ANSI naming
*       08-26-92  GJF   Function calling type and variable type macros.
*       09-25-92  SRW   Don't use ? in assert macro to keep CFRONT happy.
*       01-21-93  GJF   Removed support for C6-386's _cdecl.
*       02-01-93  GJF   Replaced SteveWo's assert macro with an ANSI-conformant
*                       one. Also got rid of '//' comment characters.
*       04-06-93  SKS   Replace _CRTAPI1/2 with __cdecl, _CRTVAR1 with nothing
*       04-07-93  SKS   Add _CRTIMP keyword for CRT DLL model
*       09-01-93  GJF   Merged Cuda and NT SDK versions.
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       03-02-95  CFW   Removed _INC_ASSERT. According to ANSI, must be able
*                       to include this file more than once.
*       12-14-95  JWM   Add "#pragma once".
*       12-19-95  JWM   Removed "#pragma once" - ANSI restriction.
*       02-20-97  GJF   Cleaned out obsolete support for _CRTAPI* and _NTSDK.
*                       Also, detab-ed.
*       09-30-97  JWM   Restored not-so-obsolete _CRTAPI1 support.
*       10-07-97  RDL   Added IA64.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*
****/

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifndef _INTERNAL_IFSTRIP_
#ifndef _ASSERT_OK
#error assert.h not for CRT internal use, use dbgint.h
#endif  /* _ASSERT_OK */
#include <cruntime.h>
#endif  /* _INTERNAL_IFSTRIP_ */


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#undef  assert

#ifdef  NDEBUG

#define assert(exp)     ((void)0)

#else

#ifdef  __cplusplus
extern "C" {
#endif

_CRTIMP void __cdecl _assert(void *, void *, unsigned);

#ifdef  __cplusplus
}
#endif

#define assert(exp) (void)( (exp) || (_assert(#exp, __FILE__, __LINE__), 0) )

#endif  /* NDEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\extinc\ehdata.h ===
/***
*ehdata.h -
*
*	Copyright (c) 1993-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Declare misc. types, macros, etc. for implementation
*	of C++ Exception Handling for the run-time and the compiler.
*	Hardware independent, assumes Windows NT.
*
* Portions of this header file can be disabled by defining the following
* macros:
*	_EHDATA_NOHEADERS - suppresses inclusion of standard header files
*		If this is specified, then appropriate typedefs or macros must
*		be provided by some other means.
*	_EHDATA_NOTHROW - suppresses definitions used only to describe a throw
*	_EHDATA_NOFUNCINFO - suppresses definitions for the frame descriptor
*	_EHDATA_NONT - suppresses definitions of our version of NT's stuff
*
* Other conditional compilation macros:
*    CC_EXPLICITFRAME - if true, representation of registration node includes
*	the value of the frame-pointer for that frame, making the location
*	of the registration node on the frame flexible.  This is intended
*	primarily for early testing.
*
*       [Internal]
*
*Revision History:
*       05-20-93  BS	Module Created.
*	03-01-94  CFW	Remove CONTEXT def for x86 for TiborL.
*	03-03-94  TL	Mips (_M_MRX000 >= 4000) changes
*	09-02-94  SKS	This header file added.
*	09-12-94  GJF	Merged in changes from/for DEC (Al Doser, dated 6/20,
*			and Bill Baxter, dated 6/28).
*	11-06-94  GJF	Changed pack pragma to 8 byte alignment.
*       02-14-95  CFW   Clean up Mac merge.
*       03-22-95  PML   Add const for read-only structs
*       03-29-95  CFW   Add error message to internal headers.
*	04-14-95  JWM	Added EH_ABORT_FRAME_UNWIND_PART for EH/SEH exception handling.
*	04-20-95  TGL	Added iFrameNestLevel field to MIPS FuncInfo
*	04-27-95  JWM	EH_ABORT_FRAME_UNWIND_PART now #ifdef ALLOW_UNWIND_ABORT.
*	06-08-95  JWM	Merged CRT version of ehdata.h into langapi source.
*	01-25-00  GB    Declared _CxxThrowException __declspec(noreturn)
*	02-08-00  GB    Added HT_ISCOMPLUSEH
*	03-27-00  PML   Remove CC_P7_SOFT25, which is now on permanently.
*       09-20-00  GB    Add __cdecl to URT C++ EH support routines (vs7#89576)
*
****/

#ifndef _INC_EHDATA
#define _INC_EHDATA

#ifdef ONLY_VALUES
#define _EHDATA_NOHEADERS
#endif

#ifndef _CRTBLD
#ifndef _VC_VER_INC
#ifdef _M_ALPHA
#include "vcver.h"
#else
#include "..\include\vcver.h"
#endif
#endif
#endif /* _CRTBLD */


#if defined(_M_IX86) && _M_IX86 >= 300 /*IFSTRIP=IGN*/
# ifndef CC_EXPLICITFRAME
#  define CC_EXPLICITFRAME	0	// If non-zero, we're using a hack version of the
								// registration node.
# endif
#endif

#ifndef _EHDATA_NOHEADERS
#include <stddef.h>
#include <excpt.h>
#if defined(_WIN32)
#include <windows.h>
#else
#include <nowin.h>
#endif
#endif /* _EHDATA_NOHEADERS */

#pragma pack(push, ehdata, 4)

#define EH_EXCEPTION_NUMBER	('msc' | 0xE0000000)	// The NT Exception # that we use
#define EH_MAGIC_NUMBER1	0x19930520		// The magic # identifying this version
							// As magic numbers increase, we have to keep track of
							// the versions that we are backwards compatible with.
#if defined(_M_IA64)
#define EH_EXCEPTION_PARAMETERS 4			// Number of parameters in exception record
#else
#define EH_EXCEPTION_PARAMETERS 3			// Number of parameters in exception record
#endif

#ifdef ALLOW_UNWIND_ABORT
#define EH_ABORT_FRAME_UNWIND_PART EH_EXCEPTION_NUMBER+1
#endif

#define EH_EMPTY_STATE	-1

#ifndef ONLY_VALUES

//
// PMD - Pointer to Member Data: generalized pointer-to-member descriptor
//

typedef struct PMD
{
#if defined(_WIN64)	 /*IFSTRIP=IGN*/
	__int32		mdisp;		// Offset of intended data within base
	__int32		pdisp;		// Displacement to virtual base pointer
	__int32		vdisp;		// Index within vbTable to offset of base
#else
	ptrdiff_t	mdisp;		// Offset of intended data within base
	ptrdiff_t	pdisp;		// Displacement to virtual base pointer
	ptrdiff_t	vdisp;		// Index within vbTable to offset of base
#endif
	} PMD;

//
// PMFN - Pointer to Member Function
//			M00REVIEW: we may need something more than this, but this will do for now.
//

#ifndef WANT_NO_TYPES
#if defined(_WIN64)	 /*IFSTRIP=IGN*/
#if defined(_M_IA64) && !defined(VERSP_P7)	/*IFSTRIP=IGN*/
typedef	__int32	PMFN;					// Image relative offset of Member Function
#else
typedef void (* __ptr64 PMFN)(void* __ptr64);
#endif
#else
typedef void (*PMFN)(void);
#endif
#endif // WANT_NO_TYPES

//
// TypeDescriptor - per-type record which uniquely identifies the type.
//
// Each type has a decorated name which uniquely identifies it, and a hash
// value which is computed by the compiler.  The hash function used is not
// important; the only thing which is essential is that it be the same for
// all time.
//
// The special type '...' (ellipsis) is represented by a null name.
//
#pragma warning(disable:4200)		// get rid of obnoxious nonstandard extension warning

#if defined(_M_ALPHA64) || defined(_M_IA64) || defined(VERSP_P7)
#pragma pack(push, TypeDescriptor, 8)
#endif

#ifndef WANT_NO_TYPES
typedef struct TypeDescriptor
{
#if defined(_WIN64) /*IFSTRIP=IGN*/
	const void * __ptr64	pVFTable;	// Field overloaded by RTTI
	void * __ptr64			spare;		// reserved, possible for RTTI
#else	// _WIN64
#if defined(_RTTI)
	const void *	pVFTable;	// Field overloaded by RTTI
#else
	DWORD	hash;			// Hash value computed from type's decorated name
#endif
	void *	spare;			// reserved, possible for RTTI
#endif	// _WIN64
	char	name[];			// The decorated name of the type; 0 terminated.
	} TypeDescriptor;
#endif // WANT_NO_TYPES

#if defined(_M_ALPHA64) || defined(_M_IA64) || defined(VERSP_P7)
#pragma pack(pop, TypeDescriptor)
#endif
#pragma warning(default:4200)

#define TD_HASH(td)		((td).hash)
#define TD_NAME(td)		((td).name)

#define TD_IS_TYPE_ELLIPSIS(td) ((td == NULL) || (TD_NAME(*td)[0] == '\0'))


#ifndef _EHDATA_NOTHROW

/////////////////////////////////////////////////////////////////////////////
//
// Description of the thrown object.  (M00REVIEW: not final)
//
// This information is broken down into three levels, to allow for maximum
// comdat folding (at the cost of some extra pointers).
//
// ThrowInfo is the head of the description, and contains information about
// 				the particular variant thrown.
// CatchableTypeArray is an array of pointers to type descriptors.  It will
//				be shared between objects thrown by reference but with varying
//				qualifiers.
// CatchableType is the description of an individual type, and how to effect
//				the conversion from a given type.
//
//---------------------------------------------------------------------------


//
// CatchableType - description of a type that can be caught.
//
// Note:  although isSimpleType can be part of ThrowInfo, it is more
//		  convenient for the run-time to have it here.
//

#ifndef WANT_NO_TYPES
typedef const struct _s_CatchableType {
	unsigned int	properties;				// Catchable Type properties (Bit field)
#if defined(_WIN64) /*IFSTRIP=IGN*/
#if defined(_M_IA64) && !defined(VERSP_P7)	/*IFSTRIP=IGN*/
	__int32			pType;					// Image relative offset of TypeDescriptor
#else
	TypeDescriptor * __ptr64 pType;			// Pointer to the type descriptor for this type
#endif
#else
	TypeDescriptor *pType;					// Pointer to the type descriptor for this type
#endif
	PMD 			thisDisplacement;		// Pointer to instance of catch type within
											//		thrown object.
	int				sizeOrOffset;			// Size of simple-type object or offset into
											//  buffer of 'this' pointer for catch object
	PMFN			copyFunction;			// Copy constructor or CC-closure
} CatchableType;
#endif // WANT_NO_TYPES

#define CT_IsSimpleType			0x00000001		// type is a simple type
#define CT_ByReferenceOnly		0x00000002		// type must be caught by reference
#define CT_HasVirtualBase		0x00000004		// type is a class with virtual bases

#define CT_PROPERTIES(ct)	((ct).properties)
#if defined(_M_IA64)
#define CT_PTD_IB(ct,ib)		((TypeDescriptor *)((ib) + (ct).pType))
#define CT_COPYFUNC_IB(ct,ib)	((void (* __ptr64)(void* __ptr64))((ib) + (ct).copyFunction))
#else
#define CT_PTD(ct)			((ct).pType)
#define CT_COPYFUNC(ct)		((ct).copyFunction)
#endif
#define CT_THISDISP(ct)		((ct).thisDisplacement)
#define CT_SIZE(ct)			((ct).sizeOrOffset)
#define CT_OFFSET(ct)		((ct).sizeOrOffset)
#define CT_HASH(ct)			(TD_HASH(*CT_PTD(ct)))
#define CT_NAME(ct)			(TD_NAME(*CT_PTD(ct)))

#define SET_CT_ISSIMPLETYPE(ct)		(CT_PROPERTIES(ct) |= CT_IsSimpleType)
#define SET_CT_BYREFONLY(ct)		(CT_PROPERTIES(ct) |= CT_ByReferenceOnly)
#define SET_CT_HASVB(ct)			(CT_PROPERTIES(ct) |= CT_HasVirtualBase)

#define CT_ISSIMPLETYPE(ct)			(CT_PROPERTIES(ct) & CT_IsSimpleType)		// Is it a simple type?
#define CT_BYREFONLY(ct)			(CT_PROPERTIES(ct) & CT_ByReferenceOnly)	// Must it be caught by reference?
#define CT_HASVB(ct)				(CT_PROPERTIES(ct) & CT_HasVirtualBase)		// Is this type a class with virtual bases?

//
// CatchableTypeArray - array of pointers to catchable types, with length
//
#pragma warning(disable:4200)		// get rid of obnoxious nonstandard extension warning
#ifndef WANT_NO_TYPES
typedef const struct _s_CatchableTypeArray {
	int	nCatchableTypes;
#if defined(_WIN64) /*IFSTRIP=IGN*/
#if defined(_M_IA64) && !defined(VERSP_P7)	/*IFSTRIP=IGN*/
	__int32			arrayOfCatchableTypes[];	// Image relative offset of Catchable Types
#else
	CatchableType	* __ptr64 arrayOfCatchableTypes[];
#endif
#else
	CatchableType	*arrayOfCatchableTypes[];
#endif
	} CatchableTypeArray;
#endif // WANT_NO_TYPES
#pragma warning(default:4200)

//
// ThrowInfo - information describing the thrown object, staticly built
// at the throw site.
//
// pExceptionObject (the dynamic part of the throw; see below) is always a
// reference, whether or not it is logically one.  If 'isSimpleType' is true,
// it is a reference to the simple type, which is 'size' bytes long.  If
// 'isReference' and 'isSimpleType' are both false, then it's a UDT or
// a pointer to any type (ie pExceptionObject points to a pointer).  If it's
// a pointer, copyFunction is NULL, otherwise it is a pointer to a copy
// constructor or copy constructor closure.
//
// The pForwardCompat function pointer is intended to be filled in by future
// versions, so that if say a DLL built with a newer version (say C10) throws,
// and a C9 frame attempts a catch, the frame handler attempting the catch (C9)
// can let the version that knows all the latest stuff do the work.
//

#ifndef WANT_NO_TYPES
typedef const struct _s_ThrowInfo {
	unsigned int	attributes;			// Throw Info attributes (Bit field)
	PMFN			pmfnUnwind;			// Destructor to call when exception
										// has been handled or aborted.

#if defined(_WIN64) /*IFSTRIP=IGN*/
#if defined(_M_IA64) && !defined(VERSP_P7)	/*IFSTRIP=IGN*/
	__int32			pForwardCompat;		// Image relative offset of Forward compatibility frame handler
	__int32			pCatchableTypeArray;// Image relative offset of CatchableTypeArray
#else
	int	(__cdecl* __ptr64 pForwardCompat)(...);	// Forward compatibility frame handler
	CatchableTypeArray	* __ptr64 pCatchableTypeArray;	// Pointer to list of pointers to types.
#endif
#else
	int	(__cdecl*pForwardCompat)(...);	// Forward compatibility frame handler
	CatchableTypeArray	*pCatchableTypeArray;	// Pointer to list of pointers to types.
#endif
} ThrowInfo;
#endif // WANT_NO_TYPES

#define TI_IsConst			0x00000001		// thrown object has const qualifier
#define TI_IsVolatile		0x00000002		// thrown object has volatile qualifier
#define TI_IsUnaligned		0x00000004		// thrown object has unaligned qualifier

#define THROW_ATTRS(t)			((t).attributes)
#if defined(_M_IA64)
#define THROW_UNWINDFUNC_IB(t,ib)		((void (* __ptr64)(void* __ptr64))((ib) + (t).pmfnUnwind))
#define THROW_FORWARDCOMPAT_IB(t,ib)	((int(__cdecl * __ptr64)(...))((ib) + (t).pForwardCompat))
#define THROW_CTARRAY_IB(t,ib)			((CatchableTypeArray*)((ib) + (t).pCatchableTypeArray))
#define THROW_COUNT_IB(t,ib)			(THROW_CTARRAY_IB(t,ib)->nCatchableTypes)
#define THROW_CTLIST_IB(t,ib)			(THROW_CTARRAY_IB(t,ib)->arrayOfCatchableTypes)
#else
#define THROW_UNWINDFUNC(t)		((t).pmfnUnwind)
#define THROW_FORWARDCOMPAT(t)	((t).pForwardCompat)
#define THROW_COUNT(t)			((t).pCatchableTypeArray->nCatchableTypes)
#define THROW_CTLIST(t)			((t).pCatchableTypeArray->arrayOfCatchableTypes)
#endif
#define THROW_PCTLIST(t)		(&THROW_CTLIST(t))
#define THROW_CT(t, n)			(*THROW_CTLIST(t)[n])
#define THROW_PCT(t, n)			(THROW_CTLIST(t)[n])

#define SET_TI_ISCONST(t)		(THROW_ATTRS(t) |= TI_IsConst)		// Is the object thrown 'const' qualified
#define SET_TI_ISVOLATILE(t)	(THROW_ATTRS(t) |= TI_IsVolatile)	// Is the object thrown 'volatile' qualified
#define SET_TI_ISUNALIGNED(t)	(THROW_ATTRS(t) |= TI_IsUnaligned)	// Is the object thrown 'unaligned' qualified

#define THROW_ISCONST(t)		(THROW_ATTRS(t) & TI_IsConst)
#define THROW_ISVOLATILE(t)		(THROW_ATTRS(t) & TI_IsVolatile)
#define THROW_ISUNALIGNED(t)	(THROW_ATTRS(t) & TI_IsUnaligned)

//
// Here's how to throw:
// M00HACK: _ThrowInfo is the name of the type that is 'pre-injected' into the
// compiler; since this prototype is known to the FE along with the pre-injected
// types, it has to match exactly.
//
#if _MSC_VER >= 900 /*IFSTRIP=IGN*/
__declspec (noreturn) extern "C" void __stdcall _CxxThrowException(void* pExceptionObject, _ThrowInfo* pThrowInfo);
#else
// If we're not self-building, we need to use the name that we defined above.
__declspec (noreturn) extern "C" void __stdcall _CxxThrowException(void* pExceptionObject, ThrowInfo* pThrowInfo);
#endif

#ifndef WANT_NO_TYPES
extern "C" int __cdecl __CxxExceptionFilter(void*, void*, int, void *);

// Returns true if the object is really a C++ exception
// If it is, stores the previous exception in *storage, and saves the current one
// This is needed to keep track of the current exception object (used for rethrow & destruction)
extern "C" int __cdecl __CxxRegisterExceptionObject(void *exception, void *storage);

// Returns true if exception is a C++ rethrown exception
// This is needed, so Unregister can know whether or not to destroy the object
extern "C" int __cdecl __CxxDetectRethrow(void *exception);

// Returns the byte count of stack space required to store the exception info
extern "C" int __cdecl __CxxQueryExceptionSize(void);

// Pops the current exception, restoring the previous one from *storage
// This detects whether or not the exception object needs to be destroyed
extern "C" void __cdecl __CxxUnregisterExceptionObject(void *storage, int rethrow);

#endif // WANT_NO_TYPES

#endif /* _EHDATA_NOTHROW */


#ifndef _EHDATA_NOFUNCINFO

/////////////////////////////////////////////////////////////////////////////
//
// Describing 'try/catch' blocks:
//
//---------------------------------------------------------------------------

//
// Current state of a function.
// -1 is the 'blank' state, ie there is nothing to unwind, no try blocks active.
//

typedef int __ehstate_t;		// The type of a state index


//
// HandlerType - description of a single 'catch'
//

#ifndef WANT_NO_TYPES
typedef const struct _s_HandlerType {
	unsigned int	adjectives;			// Handler Type adjectives (bitfield)
#if defined(_M_IA64)	 /*IFSTRIP=IGN*/
	__int32			dispType;			// Image relative offset of the corresponding type descriptor
	__int32			dispCatchObj;		// Displacement of catch object from base
	__int32			dispOfHandler;		// Image relative offset of 'catch' code
#else
	TypeDescriptor	*pType;				// Pointer to the corresponding type descriptor
#if defined(_M_ALPHA64)
	__int32			dispCatchObj;		// Displacement of catch object from base
#else
	ptrdiff_t		dispCatchObj;		// Displacement of catch object from base
#endif
#if _M_MRX000 >= 4000	 /*IFSTRIP=IGN*/
	ULONG			frameNestLevel;		// The static nesting level of parent function
#endif
	void *			addressOfHandler;	// Address of 'catch' code
#endif
} HandlerType;
#endif

#define HT_IsConst			0x00000001		// type referenced is 'const' qualified
#define HT_IsVolatile		0x00000002		// type referenced is 'volatile' qualified
#define HT_IsUnaligned		0x00000004		// type referenced is 'unaligned' qualified
#define HT_IsReference		0x00000008		// catch type is by reference
#define HT_IsResumable		0x00000010		// the catch may choose to resume (Reserved)
#define HT_IsComplusEh      0x80000000      // Is handling within complus eh.

#define HT_ADJECTIVES(ht)		((ht).adjectives)
#if defined(_M_IA64)	 /*IFSTRIP=IGN*/
#define HT_PTD_IB(ht,ib)		((TypeDescriptor*)((ib) + (ht).dispType))
#define HT_HANDLER_IB(ht,ib)	((void* __ptr64)((ib) + (ht).dispOfHandler))
#else
#define HT_PTD(ht)				((ht).pType)
#define HT_HANDLER(ht)			((ht).addressOfHandler)
#endif
#define HT_DISPCATCH(ht)		((ht).dispCatchObj)
#if _M_MRX000 >= 4000	 /*IFSTRIP=IGN*/
#define HT_FRAMENEST(ht)		((ht).frameNestLevel)
#endif
#define HT_NAME(ht)				(TD_NAME(*HT_PTD(ht)))
#define HT_HASH(ht)				(TD_HASH(*HT_PTD(ht)))
#define HT_IS_TYPE_ELLIPSIS(ht)	TD_IS_TYPE_ELLIPSIS(HT_PTD(ht))

#define SET_HT_ISCONST(ht)		(HT_ADJECTIVES(ht) |= HT_IsConst)
#define SET_HT_ISVOLATILE(ht)	(HT_ADJECTIVES(ht) |= HT_IsVolatile)
#define SET_HT_ISUNALIGNED(ht)	(HT_ADJECTIVES(ht) |= HT_IsUnaligned)
#define SET_HT_ISREFERENCE(ht)	(HT_ADJECTIVES(ht) |= HT_IsReference)
#define SET_HT_ISRESUMABLE(ht)	(HT_ADJECTIVES(ht) |= HT_IsResumable)
#define SET_HT_ISCOMPLUSEH(ht)  (HT_ADJECTIVES(ht) |= HT_IsComplusEh)

#define HT_ISCONST(ht)			(HT_ADJECTIVES(ht) & HT_IsConst)		// Is the type referenced 'const' qualified
#define HT_ISVOLATILE(ht)		(HT_ADJECTIVES(ht) & HT_IsVolatile)		// Is the type referenced 'volatile' qualified
#define HT_ISUNALIGNED(ht)		(HT_ADJECTIVES(ht) & HT_IsUnaligned)	// Is the type referenced 'unaligned' qualified
#define HT_ISREFERENCE(ht)		(HT_ADJECTIVES(ht) & HT_IsReference)	// Is the catch type by reference
#define HT_ISRESUMABLE(ht)		(HT_ADJECTIVES(ht) & HT_IsResumable)	// Might the catch choose to resume (Reserved)
#define HT_ISCOMPLUSEH(ht)      (HT_ADJECTIVES(ht) & HT_IsComplusEh)

//
// HandlerMapEntry - associates a handler list (sequence of catches) with a
//	range of eh-states.
//

#ifndef WANT_NO_TYPES
typedef const struct _s_TryBlockMapEntry {
	__ehstate_t	tryLow;				// Lowest state index of try
	__ehstate_t	tryHigh;			// Highest state index of try
#if !defined(_M_ALPHA)
	__ehstate_t	catchHigh;			// Highest state index of any associated catch
#endif
	int			nCatches;			// Number of entries in array
#if defined(_M_IA64)	/*IFSTRIP=IGN*/
	__int32		dispHandlerArray;	// Image relative offset of list of handlers for this try
#else
	HandlerType *pHandlerArray;		// List of handlers for this try
#endif
} TryBlockMapEntry;
#endif // WANT_NO_TYPES

#define TBME_LOW(hm)		((hm).tryLow)
#define TBME_HIGH(hm)		((hm).tryHigh)
#define TBME_CATCHHIGH(hm)	((hm).catchHigh)
#define TBME_NCATCHES(hm)	((hm).nCatches)
#if defined(_M_IA64)	/*IFSTRIP=IGN*/
#define TBME_PLIST(hm,ib)	((HandlerType*)((ib) + (hm).dispHandlerArray))
#define TBME_CATCH(hm,n,ib)	(TBME_PLIST(hm,ib)[n])
#define TBME_PCATCH(hm,n,ib)(&(TBME_PLIST(hm,ib)[n]))
#else
#define TBME_PLIST(hm)		((hm).pHandlerArray)
#define TBME_CATCH(hm, n)	(TBME_PLIST(hm)[n])
#define TBME_PCATCH(hm, n)	(&(TBME_PLIST(hm)[n]))
#endif


/////////////////////////////////////////////////////////////////////////////
//
// Description of the function:
//
//---------------------------------------------------------------------------

//
// UnwindMapEntry - Description of each state transition for unwinding
//	the stack (ie destructing objects).
//
// The unwind map is an array, indexed by current state.  Each entry specifies
// the state to go to during unwind, and the action required to get there.
// Note that states are represented by a signed integer, and that the 'blank'
// state is -1 so that the array remains 0-based (because by definition there
// is never any unwind action to be performed from state -1).  It is also
// assumed that state indices will be dense, ie that there will be no gaps of
// unused state indices in a function.
//

typedef const struct _s_UnwindMapEntry {
	__ehstate_t		toState;			// State this action takes us to
#if defined(_M_IA64)	/*IFSTRIP=IGN*/
	__int32			action;				// Image relative offset of funclet
#else
	void			(*action)(void);	// Funclet to call to effect state change
#endif
} UnwindMapEntry;

#define UWE_TOSTATE(uwe)	((uwe).toState)
#if defined(_M_IA64)
#define UWE_ACTION_IB(uwe,ib)	((void (*__ptr64)(void))((ib) + (uwe).action))
#else
#define UWE_ACTION(uwe)			((uwe).action)
#endif

#if _M_MRX000 >= 4000 || defined(_M_MPPC) || defined(_M_PPC) || defined(_M_IA64)	 /*IFSTRIP=IGN*/
typedef struct IptoStateMapEntry {
#if defined(_M_IA64)	/*IFSTRIP=IGN*/
	__int32		Ip;		// Image relative offset of IP
#else
	ULONG		Ip;
#endif
	__ehstate_t	State;
} IptoStateMapEntry;
#endif

//
// FuncInfo - all the information that describes a function with exception
//	handling information.
//

// bbtFlags values
#define BBT_UNIQUE_FUNCINFO 1

#ifndef WANT_NO_TYPES
typedef const struct _s_FuncInfo
{
    unsigned int		magicNumber:29;		// Identifies version of compiler
    unsigned int        bbtFlags:3;         // flags that may be set by BBT processing
	__ehstate_t			maxState;			// Highest state number plus one (thus
											// number of entries in unwind map)
#if defined(_M_IA64)	/*IFSTRIP=IGN*/
	__int32				dispUnwindMap;		// Image relative offset of the unwind map
	unsigned int		nTryBlocks;			// Number of 'try' blocks in this function
	__int32				dispTryBlockMap;	// Image relative offset of the handler map
	unsigned int		nIPMapEntries;		// # entries in the IP-to-state map. NYI (reserved)
	__int32				dispIPtoStateMap;	// Image relative offset of the IP to state map
	__int32				dispUwindHelp;		// Displacement of unwind helpers from base
#else
	UnwindMapEntry		*pUnwindMap;		// Where the unwind map is
	unsigned int		nTryBlocks;			// Number of 'try' blocks in this function
	TryBlockMapEntry	*pTryBlockMap;		// Where the handler map is
#if defined(_M_ALPHA)
    signed int          EHContextDelta;     // Frame offset of EHContext record
#endif
	unsigned int		nIPMapEntries;		// # entries in the IP-to-state map. NYI (reserved)
#if _M_MRX000 >= 4000	 /*IFSTRIP=IGN*/
	IptoStateMapEntry	*pIPtoStateMap;     // An IP to state map..
	ptrdiff_t			dispUnwindHelp;		// Displacement of unwind helpers from base
	int					iTryBlockIndex;		// Used by catch functions only
	int					iFrameNestLevel;	// The static nesting level of parent function
#elif defined(_M_MPPC) || defined(_M_PPC)
	IptoStateMapEntry	*pIPtoStateMap;		// An IP to state map..
#else
	void				*pIPtoStateMap;		// An IP to state map.  NYI (reserved).
#endif
#endif
} FuncInfo;
#endif // WANT_NO_TYPES

#define FUNC_MAGICNUM(fi)			((fi).magicNumber)
#define FUNC_MAXSTATE(fi)		((fi).maxState)
#define FUNC_NTRYBLOCKS(fi)		((fi).nTryBlocks)
#define FUNC_NIPMAPENT(fi)		((fi).nIPMapEntries)
#if defined(_M_IA64)
#define FUNC_PUNWINDMAP(fi,ib)	((UnwindMapEntry*)((ib) + (fi).dispUnwindMap))
#define FUNC_PHANDLERMAP(fi,ib)	((TryBlockMapEntry*)((ib) + (fi).dispTryBlockMap))
#define FUNC_IPMAP(fi,ib)		((IptoStateMapEntry*)((ib) + (fi).dispIPtoStateMap))
#define FUNC_UNWIND(fi,st,ib)	(FUNC_PUNWINDMAP(fi,ib)[st])
#define FUNC_PUNWIND(fi,st,ib)	(&FUNC_UNWIND(fi,st,ib))
#define FUNC_TRYBLOCK(fi,n,ib)	(FUNC_PHANDLERMAP(fi,ib)[n])
#define FUNC_PTRYBLOCK(fi,n,ib)	(&FUNC_TRYBLOCK(fi,n,ib))
#else
#define FUNC_PUNWINDMAP(fi)		((fi).pUnwindMap)
#define FUNC_PHANDLERMAP(fi)	((fi).pTryBlockMap)
#define FUNC_IPMAP(fi)			((fi).pIPtoStateMap)
#define FUNC_UNWIND(fi, st)		((fi).pUnwindMap[st])
#define FUNC_PUNWIND(fi, st)	(&FUNC_UNWIND(fi, st))
#define FUNC_TRYBLOCK(fi,n)		((fi).pTryBlockMap[n])
#define FUNC_PTRYBLOCK(fi,n)	(&FUNC_TRYBLOCK(fi, n))
#endif
#if defined(_M_ALPHA)
#define FUNC_EHCONTEXTDELTA(fi) ((fi).EHContextDelta)
#endif
#if _M_MRX000 >= 4000		 /*IFSTRIP=IGN*/
#define FUNC_IPTOSTATE(fi,n)	((fi).pIPtoStateMap[n])
#define FUNC_PIPTOSTATE(fi,n)	(&FUNC_IPTOSTATE(fi,n))
#define FUNC_DISPUNWINDHELP(fi)	((fi).dispUnwindHelp)
#define FUNC_TRYBLOCKINDEX(fi)	((fi).iTryBlockIndex)
#define FUNC_FRAMENEST(fi)		((fi).iFrameNestLevel)
#elif defined(_M_MPPC) || defined(_M_PPC)
#define FUNC_IPTOSTATE(fi,n)	((fi).pIPtoStateMap[n])
#define FUNC_PIPTOSTATE(fi,n)	(&FUNC_IPTOSTATE(fi,n))
#elif defined(_M_IA64)
#define FUNC_IPTOSTATE(fi,n,ib)	(FUNC_IPMAP(fi,ib)[n])
#define FUNC_PIPTOSTATE(fi,n,ib)(&FUNC_IPTOSTATE(fi,n,ib))
#define FUNC_DISPUNWINDHELP(fi)	((fi).dispUwindHelp)
#else
#define FUNC_IPTOSTATE(fi,n) 	__ERROR_NYI__
#endif

#endif /* _EHDATA_NOFUNCINFO */

#ifndef _EHDATA_NONT

/////////////////////////////////////////////////////////////////////////////
//
// Data types that are variants of data used by NT (and Chicago) to manage
// exception handling.
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//
// A stack registration node (i386 only)
//

#if defined(_M_IX86) && _M_IX86 >= 300 /*IFSTRIP=IGN*/
struct EHRegistrationNode {
	/* void *			stackPtr */		// Stack ptr at entry to try (below address point)
	EHRegistrationNode	*pNext;			// Next node in the chain
	void *				frameHandler;	// The handler function for this frame
	__ehstate_t			state;			// The current state of this function
#if CC_EXPLICITFRAME
	void *				frame;			// Value of ebp for this frame
#endif
};

#if !CC_EXPLICITFRAME
				// Cannonical offset
# define FRAME_OFFSET	sizeof(EHRegistrationNode)
#endif

#define PRN_NEXT(prn)		((prn)->pNext)
#define PRN_HANDLER(prn)	((prn)->frameHandler)
#define PRN_STATE(prn)		((prn)->state)
#define PRN_STACK(prn)		(((void**)(prn))[-1])
#if CC_EXPLICITFRAME
# define PRN_FRAME(prn)		((prn)->frame)
#else
# define PRN_FRAME(prn)		((void*)(((char*)prn) + FRAME_OFFSET))
#endif

typedef void DispatcherContext;		// Meaningless on Intel

#elif _M_MRX000 >= 4000 /*IFSTRIP=IGN*/
//
// On MIPS we don't have a registration node, just a pointer to the stack frame base
//
typedef ULONG EHRegistrationNode;

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

#define FRAME_OFFSET		0
#if !defined(_NTSUBSET_)
typedef struct _RUNTIME_FUNCTION {
    ULONG BeginAddress;
    ULONG EndAddress;
    EXCEPTION_DISPOSITION (*ExceptionHandler)();
    PVOID HandlerData;
    ULONG PrologEndAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    ULONG ControlPc;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG EstablisherFrame;
    PCONTEXT ContextRecord;
} DispatcherContext;					// changed the case of the name to conform to EH conventions

#elif defined(_M_IA64) /*IFSTRIP=IGN*/

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

#define FRAME_OFFSET		0

#if !defined(_NTSUBSET_)
typedef struct _FRAME_POINTERS {
    __int64 MemoryStackFp;                     // memory stack frame pointer
    __int64 BackingStoreFp;                    // backing store frame pointer
} FRAME_POINTERS, *PFRAME_POINTERS;

typedef struct _UNWIND_INFO {
    unsigned __int16 Version;                  // Version Number
    unsigned __int16 Flags;                    // Flags
    unsigned __int32 DataLength;               // Length of Descriptor Data
} UNWIND_INFO, *PUNWIND_INFO;

typedef struct _RUNTIME_FUNCTION {             
    unsigned __int32 BeginAddress;             // image relative offset to start of function
    unsigned __int32 EndAddress;               // image relative offset to end of function
    unsigned __int32 UnwindInfoAddress;        // image relative offset to unwind info block
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    FRAME_POINTERS EstablisherFrame;
    __int64 ControlPc;
    __int64 ImageBase;
    PRUNTIME_FUNCTION FunctionEntry;
    PCONTEXT ContextRecord;
} DispatcherContext;					// changed the case of the name to conform to EH conventions


//
// On P7 we don't have a registration node, just a pointer to the stack frame base
//
typedef FRAME_POINTERS EHRegistrationNode;

#elif defined(_M_ALPHA)
//
// On Alpha we don't have a registration node,
//     just a pointer to the stack frame base
//
typedef ULONG_PTR EHRegistrationNode;

#define PRN_NEXT(prn)           __ERROR__
#define PRN_HANDLER(prn)        __ERROR__
#define PRN_STATE(prn)          __ERROR__
#define PRN_STACK(prn)          __ERROR__
#define PRN_FRAME(prn)          __ERROR__

#if defined(_M_ALPHA64)	 /*IFSTRIP=IGN*/
#pragma pack(push, EHContext, 8)
#endif

#define FRAME_OFFSET            0
#if !defined(_NTSUBSET_)
typedef struct _RUNTIME_FUNCTION {
    ULONG_PTR BeginAddress;
    ULONG_PTR EndAddress;
    EXCEPTION_DISPOSITION (*ExceptionHandler)();
    PVOID HandlerData;    // ptr to FuncInfo record
    ULONG_PTR PrologEndAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    ULONG_PTR ControlPc;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG_PTR EstablisherFrame;  // Virtual Frame Pointer
    PCONTEXT ContextRecord;
} DispatcherContext;            // changed the case of the name to conform to EH conventions

//
// _EHCONTEXT is a struct built in the frame by the compiler.
// On entry to a function, compiler generated code stores the
// address of the base of the fixed frame area (the so-called
// Real Frame Pointer) into the Rfp. On every state transition,
// compiler generated code stores the current state index into
// the State field.
//
// The FuncInfo record for the function contains the offset of
// the _EHCONTEXT record from the Virtual Frame Pointer - a
// pointer to the highest address of the frame so this offset
// is negative (frames grow down in the address space).
//
typedef struct _EHCONTEXT {
    ULONG State;
    PVOID Rfp;
} EHContext;
#if defined(_M_ALPHA64)	 /*IFSTRIP=IGN*/
#pragma pack(pop, EHContext)
#endif

#define VIRTUAL_FP(pDC) (pDC->EstablisherFrame)

#define REAL_FP(VirtualFP, pFuncInfo)           \
    (((EHContext *)((char *)VirtualFP           \
     + pFuncInfo->EHContextDelta)) -> Rfp)

#define EH_STATE(VirtualFP, pFuncInfo)          \
    (((EHContext *)((char *)VirtualFP           \
     + pFuncInfo->EHContextDelta)) -> State)

#elif defined(_M_M68K)
struct EHRegistrationNode {
/*	void * 				_sp;			// The stack pointer for the entry of try/catch	*/
	void *				frameHandler;	// The handler function for this frame
	__ehstate_t			state;			// The current state of this function
};

#define PRN_HANDLER(prn)	((prn)->frameHandler)
#define PRN_STATE(prn)		((prn)->state)

typedef void DispatcherContext;		// Meaningless on Mac


#elif defined(_M_PPC) || defined(_M_MPPC)
//
// On PowerPC we don't have a registration node, just a pointer to the stack
// frame base
//
typedef ULONG EHRegistrationNode;

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

#define FRAME_OFFSET		0

#if !defined(_NTSUBSET_)
typedef struct _RUNTIME_FUNCTION {
    ULONG BeginAddress;
    ULONG EndAddress;
    EXCEPTION_DISPOSITION (*ExceptionHandler)(...);
    PVOID HandlerData;
    ULONG PrologEndAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    ULONG ControlPc;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG EstablisherFrame;
    PCONTEXT ContextRecord;
} DispatcherContext;
    // changed the case of the name to conform to EH conventions

#if defined(_M_MPPC)
typedef struct _ftinfo {
    ULONG dwMagicNumber;                // magic number
    void *pFrameInfo;			// pointer to runtime frame info
    PRUNTIME_FUNCTION rgFuncTable;	// function table
    ULONG cFuncTable;			// number of function entry
    ULONG dwEntryCF;			// address of starting of the code fragment
    ULONG dwSizeCF;			// size of the code fragment
} FTINFO, *PFTINFO;

#define offsFTINFO              64
#endif

#else
#error "Machine not supported"
#endif

/////////////////////////////////////////////////////////////////////////////
//
// The NT Exception record that we use to pass information from the throw to
// the possible catches.
//
// The constants in the comments are the values we expect.
// This is based on the definition of EXCEPTION_RECORD in winnt.h.
//
#if defined(_M_IA64) || defined(_M_ALPHA64)	 /*IFSTRIP=IGN*/
#pragma pack(push, ExceptionRecord, 8)
#endif
#ifndef WANT_NO_TYPES
typedef struct EHExceptionRecord {
	DWORD		ExceptionCode;			// The code of this exception. (= EH_EXCEPTION_NUMBER)
	DWORD		ExceptionFlags;			// Flags determined by NT
    struct _EXCEPTION_RECORD *ExceptionRecord;	// An extra exception record (not used)
    void * 		ExceptionAddress;		// Address at which exception occurred
    DWORD 		NumberParameters;		// Number of extended parameters. (= EH_EXCEPTION_PARAMETERS)
	struct EHParameters {
		DWORD		magicNumber;		// = EH_MAGIC_NUMBER1
		void *		pExceptionObject;	// Pointer to the actual object thrown
		ThrowInfo	*pThrowInfo;		// Description of thrown object
#if defined(_M_IA64)
		void		*pThrowImageBase;	// Image base of thrown object
#endif
		} params;
} EHExceptionRecord;
#endif // WANT_NO_TYPES
#if defined(_M_IA64) || defined(_M_ALPHA64)	 /*IFSTRIP=IGN*/
#pragma pack(pop, ExceptionRecord)
#endif

#define PER_CODE(per)		((per)->ExceptionCode)
#define PER_FLAGS(per)		((per)->ExceptionFlags)
#define PER_NEXT(per)		((per)->ExceptionRecord)
#define PER_ADDRESS(per)	((per)->ExceptionAddress)
#define PER_NPARAMS(per)	((per)->NumberParameters)
#define PER_MAGICNUM(per)	((per)->params.magicNumber)
#define PER_PEXCEPTOBJ(per)	((per)->params.pExceptionObject)
#define PER_PTHROW(per)		((per)->params.pThrowInfo)
#define PER_THROW(per)		(*PER_PTHROW(per))

#define PER_ISSIMPLETYPE(t)	(PER_THROW(t).isSimpleType)
#define PER_ISREFERENCE(t)	(PER_THROW(t).isReference)
#define PER_ISCONST(t)		(PER_THROW(t).isConst)
#define PER_ISVOLATILE(t)	(PER_THROW(t).isVolatile)
#define PER_ISUNALIGNED(t)	(PER_THROW(t).isUnaligned)
#define PER_UNWINDFUNC(t)	(PER_THROW(t).pmfnUnwind)
#define PER_PCTLIST(t)		(PER_THROW(t).pCatchable)
#define PER_CTLIST(t)		(*PER_PCTLIST(t))

#define PER_IS_MSVC_EH(per)	((PER_CODE(per) == EH_EXCEPTION_NUMBER) && 			\
		 					 (PER_NPARAMS(per) == EH_EXCEPTION_PARAMETERS) &&	\
		 					 (PER_MAGICNUM(per) == EH_MAGIC_NUMBER1))

/////////////////////////////////////////////////////////////////////////////
//
// NT kernel routines and definitions required to implement exception handling:
//
// (from ntxcapi.h, which is not a public header file)
//
//---------------------------------------------------------------------------

#ifndef _NTXCAPI_

// begin_ntddk
//
// Exception flag definitions.
//

// begin_winnt
#define EXCEPTION_NONCONTINUABLE 0x1    // Noncontinuable exception
// end_winnt

// end_ntddk
#define EXCEPTION_UNWINDING 0x2         // Unwind is in progress
#define EXCEPTION_EXIT_UNWIND 0x4       // Exit unwind is in progress
#define EXCEPTION_STACK_INVALID 0x8     // Stack out of limits or unaligned
#define EXCEPTION_NESTED_CALL 0x10      // Nested exception handler call
#define EXCEPTION_TARGET_UNWIND 0x20    // Target unwind in progress
#define EXCEPTION_COLLIDED_UNWIND 0x40  // Collided exception handler call

#define EXCEPTION_UNWIND (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND | \
                          EXCEPTION_TARGET_UNWIND | EXCEPTION_COLLIDED_UNWIND)

#define IS_UNWINDING(Flag) ((Flag & EXCEPTION_UNWIND) != 0)
#define IS_DISPATCHING(Flag) ((Flag & EXCEPTION_UNWIND) == 0)
#define IS_TARGET_UNWIND(Flag) (Flag & EXCEPTION_TARGET_UNWIND)
#define IS_EXIT_UNWIND(Flag) (Flag & EXCEPTION_EXIT_UNWIND)

#if !defined(_M_M68K)
#ifdef __cplusplus
extern "C" {
#endif

void WINAPI
RtlUnwind (
    IN void * TargetFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue
    );

#if defined(_M_IA64) /*IFSTRIP=IGN*/
RtlUnwind2 (
    IN FRAME_POINTERS TargetFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue,
    IN PCONTEXT ContextRecord
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
     unsigned __int64 ControlPc,
     unsigned __int64 *ImageBase,
     unsigned __int64 *TargetGp
    );
#endif

#if defined(_M_ALPHA)
#define STATUS_UNWIND 0xc0000027

void WINAPI
RtlUnwindRfp (
    IN void * TargetRealFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue
    );
#endif

#if defined(_M_PPC)
ULONG WINAPI
RtlVirtualUnwind (
    IN ULONG ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    OUT PBOOLEAN InFunction,
    OUT PULONG EstablisherFrame,
    IN OUT PVOID ContextPointers OPTIONAL,
    IN ULONG LowStackLimit,
    IN ULONG HighStackLimit
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
    IN ULONG ControlPc
    );
#endif

#if defined(_M_MPPC)
ULONG WINAPI
RtlVirtualUnwind (
    IN ULONG ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    OUT PBOOLEAN InFunction,
    OUT PULONG EstablisherFrame,
    IN OUT PVOID ContextPointers OPTIONAL,
    IN ULONG LowStackLimit,
    IN ULONG HighStackLimit
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
    IN PRUNTIME_FUNCTION RuntimeFunction,
    IN ULONG ControlPc,
    IN ULONG Rtoc
    );

VOID
RtlRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord
    );
#endif

#ifdef __cplusplus
}
#endif
#endif

#endif /* _NTXCAPI_ */

#endif /* _EHDATA_NONT */

#endif /* ONLY_VALUES */

#pragma pack(pop, ehdata)

#endif /* _INC_EHDATA */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\extinc\undname.cxx ===
//	Make sure all dependent defines exist and have a valid value

#ifndef	NO_COMPILER_NAMES
#define	NO_COMPILER_NAMES		0
#endif

#ifndef VERS_32BIT
#define VERS_32BIT				1
#endif

#ifndef PACK_SIZE
#ifdef _CRTBLD
#define PACK_SIZE				8
#elif !VERS_32BIT
#define PACK_SIZE				2
#elif defined(_X86_)
#define PACK_SIZE				4
#else
#define PACK_SIZE				8
#endif
#endif

//	Check for version inconsistancies, and setup version flags

#ifdef	VERS_BSC
	#undef	NO_COMPILER_NAMES
	#define	NO_COMPILER_NAMES	1

	#pragma	inline_depth ( 3 )
	#pragma	check_stack ( off )
#else
	#pragma	inline_depth ( 3 )
	#pragma	check_stack ( off )
#endif


#define	PURE	=0

#ifndef CC_COR
#define CC_COR 1
#endif

#include	<stddef.h>
#include	<stdlib.h>
#include	"undname.hxx"

#if !defined(_CRTBLD) && (!VERSP_RELEASE || defined(_DEBUG))
#include	<assert.h>
#define DASSERT(x) assert(x)
#else
#define DASSERT(x)
#endif

#if (defined(_CRTBLD) && defined(_MT))
#include <mtdll.h>
#endif

#pragma warning(disable:4291)	// No matching operator delete

static	unsigned int	__near __pascal	und_strlen ( pcchar_t );
static	pchar_t			__near __pascal	und_strncpy ( pchar_t, pcchar_t, unsigned int );
static	unsigned int	__near __pascal	und_strncmp ( pcchar_t, pcchar_t, unsigned int );

static	bool fExplicitTemplateParams = false;

class	DName;
class	DNameNode;
class	Replicator;
class	HeapManager;
class	UnDecorator;


// A '512' byte block including the header
const   unsigned int    memBlockSize = 512 - sizeof(void*);


class	HeapManager
{
private:
		Alloc_t			pOpNew;
		Free_t			pOpDelete;

		struct	Block
		{
			Block *		next;
			char		memBlock[ memBlockSize ];

				__near	Block ()	{	next	= 0;	}

		};

		Block *			head;
		Block *			tail;
		size_t			blockLeft;

public:
		void	__near	Constructor ( Alloc_t pAlloc, Free_t pFree )
						{	pOpNew		= pAlloc;
							pOpDelete	= pFree;
							blockLeft	= 0;
							head		= 0;
							tail		= 0;
						}

		void __far *	__near	getMemory ( size_t, int );

		void	__near	Destructor ( void )
						{	if	( pOpDelete != 0 )
								while	( tail = head )
								{
									head	= tail->next;

									( *pOpDelete )( tail );

								}
						}

		#define	gnew	new(heap,0)
		#define	rnew	new(heap,1)

};



void   *	__near __pascal	operator new ( size_t, HeapManager &, int = 0 );



static	HeapManager	heap;


//	The MS Token table

enum	Tokens
{
#if !VERS_32BIT
	TOK_near,
	TOK_nearSp,
	TOK_nearP,
	TOK_far,
	TOK_farSp,
	TOK_farP,
	TOK_huge,
	TOK_hugeSp,
	TOK_hugeP,
#endif
	TOK_basedLp,
	TOK_cdecl,
	TOK_pascal,
	TOK_stdcall,
	TOK_thiscall,
	TOK_fastcall,
	TOK_cocall,
	TOK_ptr64,
	TOK_restrict,
	TOK_unaligned,
#if !VERS_32BIT
	TOK_interrupt,
	TOK_saveregs,
	TOK_self,
	TOK_segment,
	TOK_segnameLpQ,
#endif
	TOK__last
};


static	const pcchar_t	__near	tokenTable[]	=
{
#if !VERS_32BIT
	"__near",		// TOK_near
	"__near ",		// TOK_nearSp
	"__near*",		// TOK_nearP
	"__far",		// TOK_far
	"__far ",		// TOK_farSp
	"__far*",		// TOK_farP
	"__huge",		// TOK_huge
	"__huge ",		// TOK_hugeSp
	"__huge*",		// TOK_hugeP
#endif
	"__based(",		// TOK_basedLp
	"__cdecl",		// TOK_cdecl
	"__pascal",		// TOK_pascal
	"__stdcall",	// TOK_stdcall
	"__thiscall",	// TOK_thiscall
	"__fastcall",	// TOK_fastcall
	"__clrcall",		// TOK_cocall
	"__ptr64",		// TOK_ptr64
	"__restrict",	// TOK_restrict
	"__unaligned",	// TOK_unaligned
#if !VERS_32BIT
	"__interrupt",	// TOK_interrupt
	"__saveregs",	// TOK_saveregs
	"__self",		// TOK_self
	"__segment",	// TOK_segment
	"__segname(\"",	// TOK_segnameLpQ
#endif
	""
};


//	The operator mapping table

static	const pcchar_t	__near	nameTable[]	=
{
	" new",
	" delete",
	"=",
	">>",
	"<<",
	"!",
	"==",
	"!=",
	"[]",
	"operator",
	"->",
	"*",
	"++",
	"--",
	"-",
	"+",
	"&",
	"->*",
	"/",
	"%",
	"<",
	"<=",
	">",
	">=",
	",",
	"()",
	"~",
	"^",
	"|",
	"&&",
	"||",
	"*=",
	"+=",
	"-=",
	"/=",
	"%=",
	">>=",
	"<<=",
	"&=",
	"|=",
	"^=",

#if	( !NO_COMPILER_NAMES )
	"`vftable'",
	"`vbtable'",
	"`vcall'",
	"`typeof'",
	"`local static guard'",
	"`string'",
	"`vbase destructor'",
	"`vector deleting destructor'",
	"`default constructor closure'",
	"`scalar deleting destructor'",
	"`vector constructor iterator'",
	"`vector destructor iterator'",
	"`vector vbase constructor iterator'",
	"`virtual displacement map",
	"`eh vector constructor iterator'",
	"`eh vector destructor iterator'",
	"`eh vector vbase constructor iterator'",
	"`copy constructor closure'",
	"`udt returning'",
	"`EH", //eh initialized struct
	"`RTTI", //rtti initialized struct
	"`local vftable'",
	"`local vftable constructor closure'",
#endif	// !NO_COMPILER_NAMES

	" new[]",
	" delete[]",

#if ( !NO_COMPILER_NAMES )
	"`omni callsig'",
	"`placement delete closure'",
	"`placement delete[] closure'",
	"`managed vector constructor iterator'",
	"`managed vector destructor iterator'",
	"`eh vector copy constructor iterator'",
	"`eh vector vbase copy constructor iterator'",
#endif

	""
};

static const pcchar_t __near ehTable[] =
{
	" Ptr to Member Data'",
	" Catchable Type'",
	" Catchable Type Array'",
	" ThrowInfo'",
};

static const pcchar_t __near rttiTable[] =
{
	" Type Descriptor'",
	" Base Class Descriptor at (",
	" Base Class Array'",
	" Class Hierarchy Descriptor'",
	" Complete Object Locator'",
};


//	The following 'enum' should really be nested inside 'class DName', but to
//	make the code compile better with Glockenspiel, I have extracted it

enum	DNameStatus
{
	DN_valid,
	DN_invalid,
	DN_truncated,
	DN_error
};


class	DName
{
public:
					__near	DName ();
					__near	DName ( char );

#if	1
					__near	DName ( const DName & );		// Shallow copy
#endif

					__near	DName ( DNameNode * );
					__near	DName ( pcchar_t );
					__near	DName ( pcchar_t&, char );
					__near	DName ( DNameStatus );
					__near	DName ( DName * );
					__near	DName ( unsigned long );
					__near	DName ( int );

		int			__near	isValid () const;
		int			__near	isEmpty () const;
		DNameStatus	__near	status () const;

		DName &		__near	setPtrRef ();
		int			__near	isPtrRef () const;
		int			__near	isUDC () const;
		void		__near	setIsUDC ();
		int			__near	isUDTThunk () const;
		void		__near	setIsUDTThunk ();
		int			__near	isArray() const;
		void		__near	setIsArray();
		int					isNoTE () const;
		void				setIsNoTE ();

		int			__near	length () const;
		char		__near	getLastChar () const;
		pchar_t		__near	getString ( pchar_t, int ) const;

		DName		__near	operator + ( pcchar_t ) const;
		DName		__near	operator + ( const DName & ) const;
		DName		__near	operator + ( char ) const;
		DName		__near	operator + ( DName * ) const;
		DName		__near	operator + ( DNameStatus ) const;

		DName &		__near	operator += ( char );
		DName &		__near	operator += ( pcchar_t );
		DName &		__near	operator += ( DName * );
		DName &		__near	operator += ( DNameStatus );
		DName &		__near	operator += ( const DName & );

		DName &		__near	operator |= ( const DName & );

		DName &		__near	operator = ( pcchar_t );
		DName &		__near	operator = ( const DName & );
		DName &		__near	operator = ( char );
		DName &		__near	operator = ( DName * );
		DName &		__near	operator = ( DNameStatus );

//	Friends :

friend	DName		__near __pascal	operator + ( char, const DName & );
friend	DName		__near __pascal	operator + ( pcchar_t, const DName & );
friend	DName		__near __pascal	operator + ( DNameStatus, const DName & );

private:
		DNameNode *		node;

		DNameStatus		stat	: 4;
		unsigned int	isIndir	: 1;
		unsigned int	isAUDC	: 1;
		unsigned int	isAUDTThunk	: 1;
		unsigned int	isArrayType	: 1;
		unsigned int	NoTE	: 1;

		void		__near	doPchar ( pcchar_t, int );

};



class	Replicator
{
private:
		//	Declare, in order to suppress automatic generation
		void			operator = ( const Replicator& );

		int				index;
		DName *			dNameBuffer[ 10 ];
		const DName		ErrorDName;
		const DName		InvalidDName;

public:
						__near	Replicator ();

		int				__near	isFull () const;

		Replicator &	__near	operator += ( const DName & );
		const DName &	__near	operator [] ( int ) const;

};



class	UnDecorator
{
private:
		//	Declare, in order to suppress automatic generation
		void			operator = ( const UnDecorator& );

		Replicator		ArgList;
static	Replicator *	pArgList;

		Replicator		ZNameList;
static	Replicator *	pZNameList;

static	Replicator *	pTemplateArgList;

static	pcchar_t		gName;
static	pcchar_t		name;
static	pchar_t			outputString;
static	int				maxStringLength;
static	unsigned long	disableFlags;

static	DName	__near	getDecoratedName ( void );
static	DName	__near	getSymbolName ( void );
static	DName	__near	getZName ( bool fUpdateCachedNames );
static	DName	__near	getOperatorName ( void );
static	DName	__near	getScope ( void );
static	DName			getScopedName ( void );
static	DName	__near	getSignedDimension ( void );
static	DName	__near	getDimension ( bool fSigned = false );
static	int		__near	getNumberOfDimensions ( void );
static	DName	__near	getTemplateName ( void );
static	DName	__near	getTemplateArgumentList( void );
static	DName	__near	getTemplateConstant( void );
static	DName	__near	composeDeclaration ( const DName & );
static	int		__near	getTypeEncoding ( void );
static	DName	__near	getBasedType ( void );
static	DName	__near	getECSUName ( void );
static	DName	__near	getEnumType ( void );
static	DName	__near	getCallingConvention ( void );
static	DName	__near	getReturnType ( DName * = 0 );
static	DName	__near	getDataType ( DName * );
static	DName	__near	getPrimaryDataType ( const DName & );
static	DName	__near	getDataIndirectType ( const DName &, char, const DName &, int = FALSE );
static	DName	__near	getDataIndirectType ();
static	DName	__near	getBasicDataType ( const DName & );
static	DName	__near	getECSUDataType ( void );
static	DName	__near	getPtrRefType ( const DName &, const DName &, char );
static	DName	__near	getPtrRefDataType ( const DName &, int );
static	DName	__near	getArrayType ( const DName& );
static	DName			getFunctionIndirectType( const DName & superType );
static	DName	__near	getArgumentTypes ( void );
static	DName	__near	getArgumentList ( void );
static	DName	__near	getThrowTypes ( void );
static	DName	__near	getLexicalFrame ( void );
static	DName	__near	getStorageConvention ( void );
static	DName	__near	getThisType ( void );
static	DName	__near	getPointerType ( const DName &, const DName & );
static	DName	__near	getPointerTypeArray ( const DName &, const DName & );
static	DName	__near	getReferenceType ( const DName &, const DName & );
static	DName	__near	getExternalDataType ( const DName & );
static	DName	__near	getSegmentName ( void );

#if	( !NO_COMPILER_NAMES )
static	DName	__near	getDisplacement ( void );
static	DName	__near	getCallIndex ( void );
static	DName	__near	getGuardNumber ( void );
static	DName	__near	getVfTableType ( const DName & );
static	DName	__near	getVbTableType ( const DName & );
static	DName	__near	getVCallThunkType ( void );
#endif	// !NO_COMPILER_NAMES

static	DName			getStringEncoding ( char *prefix, int wantBody );

static GetParameter_t m_pGetParameter;

public:
				__near	UnDecorator ( pchar_t, pcchar_t, int, GetParameter_t, unsigned long );

static	int		__near	doUnderScore ();
static	int		__near	doMSKeywords ();
static	int		__near	doPtr64 ();
static	int		__near	doFunctionReturns ();
static	int		__near	doAllocationModel ();
static	int		__near	doAllocationLanguage ();

#if	0
static	int		__near	doMSThisType ();
static	int		__near	doCVThisType ();
#endif

static	int		__near	doThisTypes ();
static	int		__near	doAccessSpecifiers ();
static	int		__near	doThrowTypes ();
static	int		__near	doMemberTypes ();
static	int		__near	doReturnUDTModel ();

static	int		__near	do32BitNear ();

static	int		__near	doNameOnly ();
static	int		__near	doTypeOnly ();
static	int		__near	haveTemplateParameters ();
static	int		__near	doEcsu ();
static	int		__near	doNoIdentCharCheck ();

static	pcchar_t	__near	UScore ( Tokens );

				__near	operator pchar_t ();

};



Replicator *	UnDecorator::pArgList;
Replicator *	UnDecorator::pZNameList			= 0;
Replicator *	UnDecorator::pTemplateArgList	= 0;
pcchar_t		UnDecorator::gName				= 0;
pcchar_t		UnDecorator::name				= 0;
pchar_t			UnDecorator::outputString		= 0;
int				UnDecorator::maxStringLength	= 0;
unsigned long	UnDecorator::disableFlags		= 0;
GetParameter_t	UnDecorator::m_pGetParameter	= 0;


#ifdef _CRTBLD
pchar_t	__far _CRTIMP __loadds	__unDName (	pchar_t outputString,
#else
pchar_t	__far __cdecl __loadds	unDName (	pchar_t outputString,
#endif
											pcchar_t name,
											int maxStringLength,	// Note, COMMA is leading following optional arguments
											Alloc_t pAlloc,
											Free_t pFree,
											unsigned short disableFlags

										)
/*
 *	This function will undecorate a name, returning the string corresponding to
 *	the C++ declaration needed to produce the name.  Its has a similar interface
 *	to 'strncpy'.
 *
 *	If the target string 'outputString' is specified to be NULL, a string of
 *	suitable length will be allocated and its address returned.  If the returned
 *	string is allocated by 'unDName', then it is the programmers responsibility
 *	to deallocate it.  It will have been allocated on the far heap.
 *
 *	If the target string is not NULL, then the parameter 'maxStringLength' will
 *	specify the maximum number of characters which may be placed in the string.
 *	In this case, the returned value is the same as 'outputString'.
 *
 *	Both the input parameter 'name' and the returned string are NULL terminated
 *	strings of characters.
 *
 *	If the returned value is NULL, it indicates that the undecorator ran out of
 *	memory, or an internal error occurred, and was unable to complete its task.
 */

{
	//	Must have an allocator and a deallocator (and we MUST trust them)
	if	( !( pAlloc ))
		return	0;
	
	pchar_t		unDecoratedName;
#if (defined(_CRTBLD) && defined(_MT))
    _mlock(_UNDNAME_LOCK);
    __try {
#endif
	heap.Constructor ( pAlloc, pFree );

	//	Create the undecorator object, and get the result

	UnDecorator	unDecorate (	outputString,
								name,
								maxStringLength,
								0,
								disableFlags
							);
	unDecoratedName	= unDecorate;


	// Destruct the heap (would use a destructor, but that causes DLL problems)

	heap.Destructor ();

	//	And return the composed name
#if (defined(_CRTBLD) && defined(_MT))
    } __finally{
        _munlock(_UNDNAME_LOCK);
    }
#endif

	return unDecoratedName;

}	// End of FUNCTION "unDName"




#ifdef _CRTBLD
pchar_t	__far _CRTIMP __loadds	__unDNameEx (	pchar_t outputString,
#else
pchar_t	__far __cdecl __loadds	unDNameEx (	pchar_t outputString,
#endif
											pcchar_t name,
											int maxStringLength,	// Note, COMMA is leading following optional arguments
											Alloc_t pAlloc,
											Free_t pFree,
											GetParameter_t pGetParameter,
											unsigned long disableFlags

										)
/*
 *	This function will undecorate a name, returning the string corresponding to
 *	the C++ declaration needed to produce the name.  Its has a similar interface
 *	to 'strncpy'.
 *
 *	If the target string 'outputString' is specified to be NULL, a string of
 *	suitable length will be allocated and its address returned.  If the returned
 *	string is allocated by 'unDName', then it is the programmers responsibility
 *	to deallocate it.  It will have been allocated on the far heap.
 *
 *	If the target string is not NULL, then the parameter 'maxStringLength' will
 *	specify the maximum number of characters which may be placed in the string.
 *	In this case, the returned value is the same as 'outputString'.
 *
 *	Both the input parameter 'name' and the returned string are NULL terminated
 *	strings of characters.
 *
 *	If the returned value is NULL, it indicates that the undecorator ran out of
 *	memory, or an internal error occurred, and was unable to complete its task.
 */

{
	//	Must have an allocator and a deallocator (and we MUST trust them)

	if	( !( pAlloc ))
		return	0;
	else
		heap.Constructor ( pAlloc, pFree );

	//	Create the undecorator object, and get the result

	UnDecorator	unDecorate (	outputString,
								name,
								maxStringLength,
								pGetParameter,
								disableFlags
							);
	pchar_t		unDecoratedName	= unDecorate;


	// Destruct the heap (would use a destructor, but that causes DLL problems)

	heap.Destructor ();

	//	And return the composed name

	return	unDecoratedName;

}	// End of FUNCTION "unDName"

//	The 'UnDecorator' member functions

inline	__near	UnDecorator::UnDecorator	(	pchar_t output,
												pcchar_t dName,
												int maxLen,
												GetParameter_t pGetParameter,
												unsigned long disable
									)
{
	name			= dName;
	gName			= name;

	if	( output ) {
		maxStringLength	= maxLen - 1;	// The algorithm in getString doesn't leave room
										// for terminating NULL; be paranoid and leave one
										// extra char.
										// It's a lot easier to fix this here....
		outputString	= output;	
	}
	else {
		outputString	= 0;
		maxStringLength	= 0;
	}

	pZNameList		= &ZNameList;
	pArgList		= &ArgList;
	disableFlags	= disable;
	m_pGetParameter	= pGetParameter;

}	// End of "UnDecorator" CONSTRUCTOR '()'


inline	__near	UnDecorator::operator pchar_t ()
{
	DName		result;
	DName		unDName;


	//	Find out if the name is a decorated name or not.  Could be a reserved
	//	CodeView variant of a decorated name

	if	( name )
	{
		if	(( *name == '?' ) && ( name[ 1 ] == '@' ))
		{
#if	( !NO_COMPILER_NAMES )
			gName	+= 2;
			result	= "CV: " + getDecoratedName ();
#else	// } elif NO_COMPILER_NAMES
			result	= DN_invalid;
#endif	// NO_COMPILER_NAMES

		}	// End of IF then
		elif	(( *name == '?' ) && ( name[1] == '$' ))
			result	= getTemplateName ();
		else
			result	= getDecoratedName ();

	}	// End of IF then

	//	If the name was not a valid name, then make the name the same as the original
	//	It is also invalid if there are any remaining characters in the name (except when
	//	we're giving the name only)

	if		( result.status () == DN_error )
		return	0;
	elif	( (*gName && !doNameOnly ()) || ( result.status () == DN_invalid ))
		unDName	= name;	// Return the original name
	else
		unDName	= result;

	//	Construct the return string

	if	( !outputString )
	{
		maxStringLength	= unDName.length () + 1;
		outputString 	= rnew char[ maxStringLength ];

	}	// End of IF

	if	( outputString ) {
		unDName.getString ( outputString, maxStringLength );

		// strip extra whitespace out of name
		pchar_t pRead = outputString;
		pchar_t pWrite = pRead;
		while (*pRead) {
			if (*pRead == ' ') {
				pRead++;
				*pWrite++ = ' ';
				while ( *pRead == ' ' ) {
					pRead++;
				}
			}
			else
				*pWrite++ = *pRead++;
		}
		*pWrite = *pRead;
	}

	//	Return the result

	return	outputString;

}	// End of "UnDecorator" OPERATOR 'pchar_t'



DName	__near	UnDecorator::getDecoratedName ( void )
{
	//	Ensure that it is intended to be a decorated name

	if		( doTypeOnly() )
	{
		// Disable the type-only flag, so that if we get here recursively, eg.
		// in a template tag, we do full name undecoration.
		disableFlags &= ~UNDNAME_TYPE_ONLY;

		// If we're decoding just a type, process it as the type for an abstract
		// declarator, by giving an empty symbol name.

		DName	result = getDataType ( NULL );
		disableFlags |= UNDNAME_TYPE_ONLY;

		return result;
	}
	elif	( *gName == '?' )
	{
		//	Extract the basic symbol name

		gName++;	// Advance the original name pointer


		DName	symbolName	= getSymbolName ();																						
		int		udcSeen		= symbolName.isUDC ();

		//	Abort if the symbol name is invalid

		if	( !symbolName.isValid ())
			return	symbolName;

		//	Extract, and prefix the scope qualifiers

		if	( *gName && ( *gName != '@' )) {
			DName	scope = getScope ();
			
			if	( !scope.isEmpty() )
				if (fExplicitTemplateParams) {
					fExplicitTemplateParams = false;
					symbolName	= symbolName + scope;
					if (*gName != '@') {
						scope = getScope();					
						symbolName	= scope + "::" + symbolName;
					}
				} else {
					symbolName	= scope + "::" + symbolName;
				}
			}

		if	( udcSeen )
			symbolName.setIsUDC ();

		//	Now compose declaration

		if	( symbolName.isEmpty () || symbolName.isNoTE() )
		{
			return	symbolName;
		}
		elif	( !*gName || ( *gName == '@' ) )
		{
			if	( *gName )
				gName++;

			if	(doNameOnly () && !udcSeen) {
				// Eat the rest of the dname, in case this is a recursive invocation,
				// such as for a template argument.
				(void)composeDeclaration( DName() );
				return symbolName;
			}
			else {
				return	composeDeclaration ( symbolName );
			}

		}	// End of ELIF then
		else
			return	DN_invalid;

	}	// End of IF then
	elif	( *gName )
		return	DN_invalid;
	else
		return	DN_truncated;

}	// End of "UnDecorator" FUNCTION "getDecoratedName"



inline	DName	__near	UnDecorator::getSymbolName ( void )
{
	if	( *gName == '?' )
	{
		gName++;

		return	getOperatorName ();

	}	// End of IF then
	else
		return	getZName ( true );

}	// End of "UnDecorator" FUNCTION "getSymbolName"



DName	__near	UnDecorator::getZName ( bool fUpdateCachedNames )
{
	int		zNameIndex	= *gName - '0';


	//	Handle 'zname-replicators', otherwise an actual name

	if	(( zNameIndex >= 0 ) && ( zNameIndex <= 9 ))
	{
		gName++;	// Skip past the replicator

		//	And return the indexed name

		return	( *pZNameList )[ zNameIndex ];

	}	// End of IF then
	else
	{
		DName	zName;

		if	( *gName == '?' )
		{
			zName	= getTemplateName ();

			if	( *gName++ != '@' )
				zName	= *--gName ? DN_invalid : DN_truncated;
		}
		else {
			#define TEMPLATE_PARAMETER "template-parameter-"
			#define TEMPLATE_PARAMETER_LEN 19
			#define GENERIC_TYPE "generic-type-"
			#define GENERIC_TYPE_LEN 13

			pchar_t genericType;
			if (und_strncmp(gName, TEMPLATE_PARAMETER, TEMPLATE_PARAMETER_LEN) == 0) {
				genericType = TEMPLATE_PARAMETER;
				gName += TEMPLATE_PARAMETER_LEN;
			} else if (und_strncmp(gName, GENERIC_TYPE, GENERIC_TYPE_LEN) == 0) {
				genericType = GENERIC_TYPE;
				gName += GENERIC_TYPE_LEN;
			} else {
				genericType = NULL;
			}

			if (genericType) {
				DName dimension = getSignedDimension();

				if ( haveTemplateParameters()) {
					char buffer[16];

					dimension.getString( buffer, 16 );

					char *str = (*m_pGetParameter)(atol(buffer));

					if ( str != NULL ) {
						zName = str;
					}
					else {
						zName = "`";
						zName += genericType + dimension + "'";
					}
				}
				else {
					zName = "`";
					zName += genericType + dimension + "'";
				}
			}
			else {
				//	Extract the 'zname' to the terminator

				zName	= DName( gName, '@' );	// This constructor updates 'name'
			}
		}


		//	Add it to the current list of 'zname's

		if	( fUpdateCachedNames && !pZNameList->isFull ())
			*pZNameList	+= zName;

		//	And return the symbol name
		return	zName;

	}	// End of IF else
}	// End of "UnDecorator" FUNCTION "getZName"



inline	DName	__near	UnDecorator::getOperatorName ( void )
{
	DName	operatorName;
	DName	tmpName;
	int		udcSeen	= FALSE;


	//	So what type of operator is it ?

	switch	( *gName++ )
	{
	case 0:
		gName--;		// End of string, better back-track

		return	DN_truncated;

	case OC_ctor:
	case OC_dtor:
		//
		// The constructor and destructor are special:
		// Their operator name is the name of their first enclosing scope, which
		// will always be a tag, which may be a template specialization!
		//
		{
			//	Use a temporary.  Don't want to advance the name pointer

			pcchar_t	pName	= gName;


			operatorName		= getZName ( false );


			gName = pName;		// Undo our lookahead

			if	( !operatorName.isEmpty () && ( gName[ -1 ] == OC_dtor ))
				operatorName	= '~' + operatorName;

			return	operatorName;

		}	// End of CASE 'OC_ctor,OC_dtor'
		break;

	case OC_new:
	case OC_delete:
	case OC_assign:
	case OC_rshift:
	case OC_lshift:
	case OC_not:
	case OC_equal:
	case OC_unequal:
			operatorName	= nameTable[ gName[ -1 ] - OC_new ];
		break;

	case OC_udc:
			udcSeen	= TRUE;

		//	No break

	case OC_index:
	case OC_pointer:
	case OC_star:
	case OC_incr:
	case OC_decr:
	case OC_minus:
	case OC_plus:
	case OC_amper:
	case OC_ptrmem:
	case OC_divide:
	case OC_modulo:
	case OC_less:
	case OC_leq:
	case OC_greater:
	case OC_geq:
	case OC_comma:
	case OC_call:
	case OC_compl:
	case OC_xor:
	case OC_or:
	case OC_land:
	case OC_lor:
	case OC_asmul:
	case OC_asadd:
	case OC_assub:			// Regular operators from the first group
			operatorName	= nameTable[ gName[ -1 ] - OC_index + ( OC_unequal - OC_new + 1 )];
		break;

	case '_':
			switch	( *gName++ )
			{
			case 0:
				gName--;		// End of string, better back-track

				return	DN_truncated;

			case OC_asdiv:
			case OC_asmod:
			case OC_asrshift:
			case OC_aslshift:
			case OC_asand:
			case OC_asor:
			case OC_asxor:	// Regular operators from the extended group
					operatorName	= nameTable[ gName[ -1 ] - OC_asdiv + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];
				break;

#if	( !NO_COMPILER_NAMES )
			case OC_vftable:
			case OC_vbtable:
			case OC_vcall:
				return	nameTable[ gName[ -1 ] - OC_asdiv + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];


			case OC_string:
				{
				DName result = getStringEncoding( "`string'", TRUE );
				result.setIsNoTE();
				return result;
				}

			case OC_metatype:
			case OC_guard:
			case OC_vbdtor:
			case OC_vdeldtor:
			case OC_defctor:
			case OC_sdeldtor:
			case OC_vctor:
			case OC_vdtor:
			case OC_vallctor:
			case OC_ehvctor:
			case OC_ehvdtor:
			case OC_ehvctorvb:
			case OC_copyctorclosure:
			case OC_locvfctorclosure:
			case OC_locvftable:	// Special purpose names
			case OC_placementDeleteClosure:
			case OC_placementArrayDeleteClosure:
				return	nameTable[ gName[ -1 ] - OC_metatype + ( OC_vcall - OC_asdiv + 1 ) + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];

			case OC_udtthunk:
				operatorName	= nameTable[ gName[ -1 ] - OC_metatype + ( OC_vcall - OC_asdiv + 1 ) + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];
				tmpName 		= getOperatorName();
				if ( !tmpName.isEmpty() && tmpName.isUDTThunk() )
					return	DN_invalid;
				return operatorName + tmpName;
				break;
			case OC_eh_init:
				break;
			case OC_rtti_init:
				operatorName	= nameTable[ gName[ -1 ] - OC_metatype + ( OC_vcall - OC_asdiv + 1 ) + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];
				tmpName = rttiTable[ gName[0] - OC_rtti_TD ];
				switch	( *gName++ )
				{
				case OC_rtti_TD:
					{
					DName	result = getDataType ( NULL );
					return result + ' ' + operatorName + tmpName;
					}
					break;
				case OC_rtti_BCD:
					{
					DName	result = operatorName + tmpName;
					result += getSignedDimension() + ',';
					result += getSignedDimension() + ',';
					result += getSignedDimension() + ',';
					result += getDimension() + ')';
					return result + '\'';
					}
					break;
				case OC_rtti_BCA:
				case OC_rtti_CHD:
				case OC_rtti_COL:
					return operatorName + tmpName;
					break;
				default:
					gName--;
					return DN_truncated;
					break;
				}
				break;

#endif	// !NO_COMPILER_NAMES

			case OC_arrayNew:
			case OC_arrayDelete:
				operatorName	= nameTable[ gName[ -1 ] - OC_metatype + ( OC_vcall - OC_asdiv + 1 ) + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )
#if NO_COMPILER_NAMES
											- ( OC_locvfctorclosure - OC_vftable + 1 )	// discount names not in table
#endif
									];
				break;

			// Yet another level of nested encodings....
			case '?':
				switch( *gName++ ) {

					case 0:
						gName--;		// End of string, better back-track

						return	DN_truncated;

					case OC_anonymousNamespace:
						//
						// Anonymous namespace (new-style) is a string encoding of the
						// machine name and the translation unit name.  Since the remainder
						// of the name doesn't really fit the dname grammar, skip it.
						// There are two '@' markers in the name....
						//
						{
						DName result = getStringEncoding( "`anonymous namespace'", FALSE );
						result.setIsNoTE();
						return result;
						}

					default:
						return	DN_invalid;
				}
				break;

			//
			// A double extended operator
			//
			case '_':
				switch (*gName++) {
					case OC_man_vec_ctor:
					case OC_man_vec_dtor:
					case OC_ehvcctor:
					case OC_ehvcctorvb:
						return nameTable[ gName[ -1 ] - OC_man_vec_ctor + ( OC_placementArrayDeleteClosure - OC_metatype + 1) + ( OC_vcall - OC_asdiv + 1 ) + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];

					default:
						return DN_invalid;
				}
				break;

			default:
				return	DN_invalid;

			}	// End of SWITCH
		break;

	default:
		return	DN_invalid;

	}	// End of SWITCH

	//	This really is an operator name, so prefix it with 'operator'

	if	( udcSeen )
		operatorName.setIsUDC ();
	elif	( !operatorName.isEmpty ())
		operatorName	= "operator" + operatorName;

	return	operatorName;

}	// End of "UnDecorator" FUNCTION "getOperatorName"

DName	UnDecorator::getStringEncoding ( char *prefix, int wantBody )
{
	DName result = prefix;

	// First @ comes right after operator code
	if	( *gName++ != '@' || *gName++ != '_' ) {
		return DN_invalid;
	}

	// Skip the string kind
	*gName++;

	// Get (& discard) the length
	getDimension();

	// Get (& discart) the checksum
	getDimension();

	while ( *gName && *gName != '@' ) {
		// For now, we'll just skip it
		gName++;
	}

	if	( !*gName ) {
		gName--;
		return DN_truncated;
	}

	// Eat the terminating '@'
	gName++;

	return result;
}


DName	__near	UnDecorator::getScope ( void )
{
	DName	scope;
	bool	fNeedBracket = false;


	//	Get the list of scopes

	while	(( scope.status () == DN_valid ) && *gName && ( *gName != '@' ))
	{	//	Insert the scope operator if not the first scope

		if (fExplicitTemplateParams) {
			return scope;
		}
		if	( !scope.isEmpty() ) {
			scope	= "::" + scope;

			if (fNeedBracket) {
				scope = '[' + scope;
				fNeedBracket = false;
			}
		}

		//	Determine what kind of scope it is

		if	( *gName == '?' )
			switch	( *++gName )
			{
			case '?':
					if	( gName[1] == '_' && gName[2] == '?' ) {
						//
						// Anonymous namespace name (new style)
						//
						gName++;
						scope = getOperatorName () + scope;

						// There should be a zname termination @...
						if	( *gName == '@' ) {
							gName++;
						}
					}
					else
						scope	= '`' + getDecoratedName () + '\'' + scope;
				break;

			case '$':
					// It's a template name, which is a kind of zname; back up
					// and handle like a zname.
					gName--;
					scope	= getZName ( true ) + scope;
				break;

			case 'A':
					//
					// This is a new-new encoding for anonymous namespaces
					//
					// fall-through

			case '%':
					//
					// It an anonymous namespace (old-style);
					// skip the (unreadable) name and instead insert
					// an appropriate string
					//
					while ( *gName != '@' ) {
						gName++;
					}

					gName++;

					scope = "`anonymous namespace'" + scope;
				break;
			case 'I':
				//
				// This is the interface whose method the class is
				// implementing
				//
				gName++;
				scope = getZName ( true ) + ']' + scope;
				fNeedBracket = true;
				break;

			default:
				scope	= getLexicalFrame () + scope;
				break;

			}	// End of SWITCH
		else
			scope	= getZName ( true ) + scope;

	}	// End of WHILE

	//	Catch error conditions

	switch	( *gName )
	{
	case 0:
			if	( scope.isEmpty() )
				scope	= DN_truncated;
			else
				scope	= DName ( DN_truncated ) + "::" + scope;
		break;

	case '@':		// '@' expected to end the scope list
		break;

	default:
			scope	= DN_invalid;
		break;

	}	// End of SWITCH

	//	Return the composed scope

	return	scope;

}	// End of "UnDecorator" FUNCTION "getScope"


DName	__near	UnDecorator::getSignedDimension ( void )
{
	if		( !*gName )
		return	DN_truncated;
	elif	( *gName == '?' ) {
		gName++;	// skip the '?'
		return	'-' + getDimension();
	}
	else
		return	getDimension();
}	// End of "Undecorator" FUNCTION "getSignedDimension"


DName	__near	UnDecorator::getDimension ( bool fSigned )
{
	char* prefix = 0;
	if (*gName == TC_nontype_dummy) {
		prefix = "`non-type-template-parameter";
		++gName;
	}

	if		( !*gName )
		return	DN_truncated;
	elif	(( *gName >= '0' ) && ( *gName <= '9' ))
		return	prefix ? (prefix + DName ((unsigned long)( *gName++ - '0' + 1 ))) : DName ((unsigned long)( *gName++ - '0' + 1 ));
	else
	{
		unsigned long dim = 0L;


		//	Don't bother detecting overflow, it's not worth it

		while	( *gName != '@' )
		{
			if		( !*gName )
				return	DN_truncated;
			elif	(( *gName >= 'A' ) && ( *gName <= 'P' ))
				dim	= ( dim << 4 ) + ( *gName - 'A' );
			else
				return	DN_invalid;

			gName++;

		}	// End of WHILE

		//	Ensure integrity, and return

		if	( *gName++ != '@' )
			return	DN_invalid;		// Should never get here

		if (fSigned) {
			return prefix ? (prefix + DName((int)dim)) : DName((int)dim);
		} else {
			return prefix ? (prefix + DName(dim)) : dim;
		}

	}	// End of ELIF else
}	// End of "UnDecorator" FUNCTION "getDimension"


int	__near	UnDecorator::getNumberOfDimensions ( void )
{
	if		( !*gName )
		return	0;
	elif	(( *gName >= '0' ) && ( *gName <= '9' ))
		return	(( *gName++ - '0' ) + 1 );
	else
	{
		int	dim	= 0;


		//	Don't bother detecting overflow, it's not worth it

		while	( *gName != '@' )
		{
			if		( !*gName )
				return	0;
			elif	(( *gName >= 'A' ) && ( *gName <= 'P' ))
				dim	= ( dim << 4 ) + ( *gName - 'A' );
			else
				return	-1;

			gName++;

		}	// End of WHILE

		//	Ensure integrity, and return

		if	( *gName++ != '@' )
			return	-1;		// Should never get here

		return	dim;

	}	// End of ELIF else
}	// End of "UnDecorator" FUNCTION "getNumberOfDimensions"


DName	__near	UnDecorator::getTemplateName ( void )
{
	//
	// First make sure we're really looking at a template name
	//
	if	( gName[0] != '?' || gName[1] != '$' )
		return DN_invalid;

	gName += 2;			// Skip the marker characters

	//
	// Stack the replicators, since template names are their own replicator scope:
	//
	Replicator * pSaveArgList 			= pArgList;
	Replicator * pSaveZNameList 		= pZNameList;
	Replicator * pSaveTemplateArgList 	= pTemplateArgList;

	Replicator localArgList, localZNameList, localTemplateArgList;

	pArgList 			= &localArgList;
	pZNameList 			= &localZNameList;
	pTemplateArgList 	= &localTemplateArgList;

	//
	// Crack the template name:
	//
	DName	templateName	= getZName ( true );

	if	(templateName.isEmpty ()) {
		fExplicitTemplateParams = true;
	}

	templateName	+= '<' + getTemplateArgumentList ();
	if	( templateName.getLastChar () == '>' )
		templateName += ' ';
	templateName	+= '>';

	//
	// Restore the previous replicators:
	//
	pArgList			= pSaveArgList;
	pZNameList			= pSaveZNameList;
	pTemplateArgList	= pSaveTemplateArgList;

	//	Return the completed 'template-name'

	return	templateName;

}	// End of "UnDecorator" FUNCTION "getTemplateName"


DName	__near	UnDecorator::getTemplateArgumentList ( void )
{
	int		first	= TRUE;
	DName	aList;


	while	(( aList.status () == DN_valid ) && *gName && ( *gName != AT_endoflist ))
	{
		//	Insert the argument list separator if not the first argument

		if	( first )
			first	= FALSE;
		else
			aList	+= ',';


		//	Get the individual argument type

		int		argIndex	= *gName - '0';


		//	Handle 'template-argument-replicators', otherwise a new argument type

		if	(( argIndex >= 0 ) && ( argIndex <= 9 ))
		{
			gName++;	// Skip past the replicator

			//	Append to the argument list

			aList	+= ( *pTemplateArgList )[ argIndex ];

		}	// End of IF then
		else
		{
			pcchar_t	oldGName	= gName;
			DName		arg;

			//
			//	Extract the 'argument' type
			//

			if	( *gName == DT_void ) {
				gName++;
				arg = "void";
			} 
			elif ( (*gName == '$') && (gName[1] != '$')) {
				gName++;
				arg = getTemplateConstant();
			}
			elif ( *gName == '?' ) {
				//
				// This is a template-parameter, i.e. we have a "specialization" of
				// X<T>. so get the template-parameter-index and use a "generic" name
				// for this parameter
				//
				DName dimension = getSignedDimension();

				if ( haveTemplateParameters()) {
					char buffer[16];

					dimension.getString( buffer, 16 );

					char *str = (*m_pGetParameter)(atol(buffer));

					if ( str != NULL ) {
						arg = str;
					}
					else {
						arg = "`template-parameter" + dimension + "'";
					}
				}
				else {
					arg = "`template-parameter" + dimension + "'";
				}
			}
			else {
				arg = getPrimaryDataType ( DName() );
			}


			//	Add it to the current list of 'template-argument's, if it is bigger than a one byte encoding

			if	((( gName - oldGName ) > 1 ) && !pTemplateArgList->isFull ())
				*pTemplateArgList	+= arg;

			//	Append to the argument list

			aList	+= arg;

		}	// End of IF else
	}	// End of WHILE

	//	Return the completed template argument list

	return	aList;

}	// End of "UnDecorator" FUNCTION "getTemplateArgumentList"


DName	__near	UnDecorator::getTemplateConstant(void)
{
	//
	// template-constant ::=
	//		'0'	<template-integral-constant>
	//		'1' <template-address-constant>
	//		'2' <template-floating-point-constant>
	//
	switch ( *gName++ )
	{
		//
		// template-integral-constant ::=
		//		<signed-dimension>
		//
	case TC_integral:
		return 	getSignedDimension ();

		//
		// template-address-constant ::=
		//		'@'			// Null pointer
		//		<decorated-name>
		//
	case TC_address:
		if 	( *gName == TC_nullptr )
		{
			gName++;
			return	"NULL";
		}
		else
			return	DName("&") + getDecoratedName ();

		//
		// template-name ::=
		//		<docorated-name>
		//
	case TC_name:
		return getDecoratedName ();

		//
		// template-floating-point-constant ::=
		//		<normalized-mantissa><exponent>
		//
	case TC_fp:
		{
			DName	mantissa ( getSignedDimension () );
			DName	exponent ( getSignedDimension () );

			if	( mantissa.isValid() && exponent.isValid() )
			{
				//
				// Get string representation of mantissa
				//
				char	buf[100];		// Way overkill for a compiler generated fp constant

				if	( !mantissa.getString( &(buf[1]), 100 ) )	
					return	DN_invalid;

				//
				// Insert decimal point
				//
				buf[0] = buf[1];

				if	( buf[0] == '-' )
				{
					buf[1] = buf[2];
					buf[2] = '.';
				}
				else
					buf[1] = '.';

				//
				// String it all together
				//
				return DName( buf ) + 'e' + exponent;

			} // End of IF then
			else
				return DN_truncated;

		}	// End of BLOCK case TC_fp

	case TC_dummy:
	case TC_nontype_dummy:
		{
			//
			// This is a template-parameter, i.e. we have a "specialization" of
			// X<n>. so get the template-parameter-index and use a "generic" name
			// for this parameter
			//
			DName dimension = getSignedDimension();

			if ( haveTemplateParameters()) {
				char buffer[16];

				dimension.getString( buffer, 16 );

				char *str = (*m_pGetParameter)(atol(buffer));

				if ( str != NULL ) {
					return str;
				}
			}

			if (*gName == TC_dummy) {
				return "`template-parameter" + dimension + "'";
			} else {
				return "`non-type-template-parameter" + dimension + "'";
			}
		}
		break;

	case '\0':
		--gName;
		return	DN_truncated;

	default:
		return	DN_invalid;

	}	// End of SWITCH
}	// End of "UnDecorator" FUNCTION "getTemplateConstant"

	
inline	DName	__near	UnDecorator::composeDeclaration ( const DName & symbol )
{
	DName			declaration;
	unsigned int	typeCode	= getTypeEncoding ();
	int				symIsUDC	= symbol.isUDC ();


	//	Handle bad typeCode's, or truncation

	if		( TE_isbadtype ( typeCode ))
		return	DN_invalid;
	elif	( TE_istruncated ( typeCode ))
		return	( DN_truncated + symbol );
	elif	( TE_isCident ( typeCode ))
		return	symbol;

	//	This is a very complex part.  The type of the declaration must be
	//	determined, and the exact composition must be dictated by this type.

	//	Is it any type of a function ?
	//	However, for ease of decoding, treat the 'localdtor' thunk as data, since
	//	its decoration is a function of the variable to which it belongs and not
	//	a usual function type of decoration.

#if	( NO_COMPILER_NAMES )
	if	( TE_isthunk ( typeCode ))
		return	DN_invalid;

	if	( TE_isfunction ( typeCode ))
#else	// } elif !NO_COMPILER_NAMES {
	if	( TE_isfunction ( typeCode ) && !(( TE_isthunk ( typeCode ) && TE_islocaldtor ( typeCode )) ||
			( TE_isthunk ( typeCode ) && ( TE_istemplatector ( typeCode ) || TE_istemplatedtor ( typeCode )))))
#endif	// !NO_COMPILER_NAMES

	{
		//	If it is based, then compose the 'based' prefix for the name

		if	( TE_isbased ( typeCode ))
			if	( doMSKeywords () && doAllocationModel ())
				declaration	= ' ' + getBasedType ();
			else
				declaration	|= getBasedType ();	// Just lose the 'based-type'

#if	( !NO_COMPILER_NAMES )
		//	Check for some of the specially composed 'thunk's

		if	( TE_isthunk ( typeCode ) && TE_isvcall ( typeCode ))
		{
			declaration	+= symbol + '{' + getCallIndex () + ',';
			declaration	+= getVCallThunkType () + "}' ";
			if ( doMSKeywords () && doAllocationLanguage ())
				declaration	= ' ' + getCallingConvention () + ' ' + declaration;	// What calling convention ?
			else
				declaration |= getCallingConvention ();	// Just lose the 'calling-convention'

		}	// End of IF then
		else
#endif	// !NO_COMPILER_NAMES
		{
			DName	vtorDisp;
			DName	adjustment;
			DName	thisType;

#if	( !NO_COMPILER_NAMES )
			if	( TE_isthunk ( typeCode ))
			{
				if	( TE_isvtoradj ( typeCode ))
					vtorDisp	= getDisplacement ();

				adjustment	= getDisplacement ();

			}	// End of IF else
#endif	// !NO_COMPILER_NAMES

			//	Get the 'this-type' for non-static function members

			if	( TE_ismember ( typeCode ) && !TE_isstatic ( typeCode ))
				if	( doThisTypes ())
					thisType	= getThisType ();
				else
					thisType	|= getThisType ();

			if	( doMSKeywords ())
			{
				//	Attach the calling convention

				if	( doAllocationLanguage ())
					declaration	= getCallingConvention () + declaration;	// What calling convention ?
				else
					declaration	|= getCallingConvention ();	// Just lose the 'calling-convention'

				//	Any model specifiers ?

#if !VERS_32BIT
				if	( doAllocationModel ())
					if		( TE_isnear ( typeCode ))
						declaration	= UScore ( TOK_nearSp ) + declaration;
					elif	( TE_isfar ( typeCode ))
						declaration	= UScore ( TOK_farSp ) + declaration;
#endif

			}	// End of IF
			else
				declaration	|= getCallingConvention ();	// Just lose the 'calling-convention'

			//	Now put them all together

			if	( !symbol.isEmpty ())
				if	( !declaration.isEmpty () && !doNameOnly() )			// And the symbol name
					declaration	+= ' ' + symbol;
				else
					declaration	= symbol;


			//	Compose the return type, catching the UDC case

			DName *	pDeclarator	= 0;
			DName	returnType;


			if	( symIsUDC )		// Is the symbol a UDC operator ?
			{
				declaration	+= " " + getReturnType ();

				if	( doNameOnly() )
					return	declaration;
			}
			else
			{
				pDeclarator	= gnew DName;
				returnType	= getReturnType ( pDeclarator );

			}	// End of IF else

#if	( !NO_COMPILER_NAMES )
			//	Add the displacements for virtual function thunks

			if	( TE_isthunk ( typeCode ))
			{
				if	( TE_isvtoradj ( typeCode ))
					declaration	+= "`vtordisp{" + vtorDisp + ',';
				else
					declaration	+= "`adjustor{";

				declaration	+= adjustment + "}' ";

			}	// End of IF
#endif	// !NO_COMPILER_NAMES

			//	Add the function argument prototype

			declaration	+= '(' + getArgumentTypes () + ')';

			//	If this is a non-static member function, append the 'this' modifiers

			if	( TE_ismember ( typeCode ) && !TE_isstatic ( typeCode ))
				declaration	+= thisType;

			//	Add the 'throw' signature

			if	( doThrowTypes ())
				declaration	+= getThrowTypes ();
			else
				declaration	|= getThrowTypes ();	// Just lose the 'throw-types'

			//	If it has a declarator, then insert it into the declaration,
			//	sensitive to the return type composition

			if	( doFunctionReturns () && pDeclarator )
			{
				*pDeclarator	= declaration;
				declaration		= returnType;

			}	// End of IF
		}	// End of IF else
	}	// End of IF then
	else
	{
		declaration	+= symbol;

		//	Catch the special handling cases

#if	( !NO_COMPILER_NAMES )
		if		( TE_isvftable ( typeCode ))
			return	getVfTableType ( declaration );
		elif	( TE_isvbtable ( typeCode ))
			return	getVbTableType ( declaration );
		elif	( TE_isguard ( typeCode ))
			return	( declaration + '{' + getGuardNumber () + "}'" );
		elif	( TE_isthunk ( typeCode ) && TE_islocaldtor ( typeCode ))
			declaration	+= "`local static destructor helper'";
		elif	( TE_isthunk ( typeCode ) && TE_istemplatector ( typeCode ))
			declaration	+= "`template static data member constructor helper'";
		elif	( TE_isthunk ( typeCode ) && TE_istemplatedtor ( typeCode ))
			declaration	+= "`template static data member destructor helper'";
		elif	( TE_ismetaclass ( typeCode ))
			//
			// Meta-class information has its information in its operator id
			//
			return declaration;
#else	// } elif NO_COMPILER_NAMES {
		if	( TE_isvftable ( typeCode )
				|| TE_isvbtable ( typeCode )
				|| TE_isguard ( typeCode )
				|| TE_ismetaclass ( typeCode ))
			return	DN_invalid;
#endif	// NO_COMPILER_NAMES

		if ( TE_isthunk( typeCode ) && ( TE_istemplatector( typeCode ) || TE_istemplatedtor( typeCode ))) {
			//
			// Insert a space before the declaration
			//
			declaration = " " + declaration;
		}
		else {
			//	All others are decorated as data symbols
			declaration	= getExternalDataType ( declaration );
		}

	}	// End of IF else

	//	Prepend the 'virtual' and 'static' attributes for members

	if	( TE_ismember ( typeCode ))
	{
		if	( doMemberTypes ())
		{
			if	( TE_isstatic ( typeCode ))
				declaration	= "static " + declaration;

			if	( TE_isvirtual ( typeCode ) || ( TE_isthunk ( typeCode ) && ( TE_isvtoradj ( typeCode ) || TE_isadjustor ( typeCode ))))
				declaration	= "virtual " + declaration;

		}	// End of IF

		//	Prepend the access specifiers

		if	( doAccessSpecifiers ())
			if		( TE_isprivate ( typeCode ))
				declaration	= "private: " + declaration;
			elif	( TE_isprotected ( typeCode ))
				declaration	= "protected: " + declaration;
			elif	( TE_ispublic ( typeCode ))
				declaration	= "public: " + declaration;

	}	// End of IF

#if	( !NO_COMPILER_NAMES )
	//	If it is a thunk, mark it appropriately

	if	( TE_isthunk ( typeCode ))
		declaration	= "[thunk]:" + declaration;
#endif	// !NO_COMPILER_NAMES

	//	Return the composed declaration

	return	declaration;

}	// End of "UnDecorator" FUNCTION "composeDeclaration"


inline	int		__near	UnDecorator::getTypeEncoding ( void )
{
	unsigned int	typeCode	= 0u;


	//	Strip any leading '_' which indicates that it is based

	if	( *gName == '_' )
	{
		TE_setisbased ( typeCode );

		gName++;

	}	// End of IF

	//	Now handle the code proper :-

	if		(( *gName >= 'A' ) && ( *gName <= 'Z' ))	// Is it some sort of function ?
	{
		int	code	= *gName++ - 'A';


		//	Now determine the function type

		TE_setisfunction ( typeCode );	// All of them are functions ?

		//	Determine the calling model

		if	( code & TE_far )
			TE_setisfar ( typeCode );
		else
			TE_setisnear ( typeCode );

		//	Is it a member function or not ?

		if	( code < TE_external )
		{
			//	Record the fact that it is a member

			TE_setismember ( typeCode );

			//	What access permissions does it have

			switch	( code & TE_access )
			{
			case TE_private:
					TE_setisprivate ( typeCode );
				break;

			case TE_protect:
					TE_setisprotected ( typeCode );
				break;

			case TE_public:
					TE_setispublic ( typeCode );
				break;

			default:
					TE_setisbadtype ( typeCode );
					return	typeCode;

			}	// End of SWITCH

			//	What type of a member function is it ?

			switch	( code & TE_adjustor )
			{
			case TE_adjustor:
					TE_setisadjustor ( typeCode );
				break;

			case TE_virtual:
					TE_setisvirtual ( typeCode );
				break;

			case TE_static:
					TE_setisstatic ( typeCode );
				break;

			case TE_member:
				break;

			default:
					TE_setisbadtype ( typeCode );
					return	typeCode;

			}	// End of SWITCH
		}	// End of IF
	}	// End of IF then
	elif	( *gName == '$' )	// Extended set ?  Special handling
	{
		//	What type of symbol is it ?

		switch	( *( ++gName ))
		{
		case SHF_localdtor:	// A destructor helper for a local static ?
				TE_setislocaldtor ( typeCode );
			break;

		case SHF_vcall:	// A VCall-thunk ?
				TE_setisvcall ( typeCode );
			break;
		
		case SHF_templateStaticDataMemberCtor:	// A constructor helper for template static data members
				TE_setistemplatector ( typeCode );
			break; 

		case SHF_templateStaticDataMemberDtor:	// A destructor helper for template static data members
				TE_setistemplatedtor ( typeCode );
			break; 

		case '$':
			switch ( *( ++gName )) {
				case SHF_CPPManagedILFunction:				// C++ managed-IL function
				case SHF_CPPManagedNativeFunction:			// C++ managed-native function
				case SHF_CPPManagedILMain:					// C++ managed-IL main
				case SHF_CPPManagedNativeMain:				// C++ managed-native main
				case SHF_CPPManagedILDLLImportData:			// C++ managed-IL DLL-import function
				case SHF_CPPManagedNativeDLLImportData:		// C++ managed-native DLL-import function
					//
					// Skip the encoding
					//
					gName += 1;
					return getTypeEncoding();

				case SHF_CManagedILFunction:				// C (or extern "C") managed-IL function
				case SHF_CManagedNativeFunction:			// C (or extern "C") managed-native function
				case SHF_CManagedILDLLImportData:			// C (or extern "C") managed-IL DLL-import function 
				case SHF_CManagedNativeDLLImportData:		// C (or extern "C") managed-native DLL-import function 
					//
					// Skip the encoding
					//
					gName += 1;

					//
					// The next character should be the number of characters
					// in the byte-count
					//
					if (( *gName >= '0' ) && ( *gName <= '9' )) {
						//
						// Skip the character count and the byte-count
						// itself
						//
						gName += (( *gName - '0' ) + 1 );

						return getTypeEncoding();
					}
					else {
						TE_setisbadtype( typeCode );
					}
					break;

				default:
					break;
			}
			break;

		case 0:
				TE_setistruncated ( typeCode );
			break;

		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':	// Construction displacement adjustor thunks
			{
				int	code	= *gName - '0';


				//	Set up the principal type information

				TE_setisfunction ( typeCode );
				TE_setismember ( typeCode );
				TE_setisvtoradj ( typeCode );

				//	Is it 'near' or 'far' ?

				if	( code & TE_far )
					TE_setisfar ( typeCode );
				else
					TE_setisnear ( typeCode );

				//	What type of access protection ?

				switch	( code & TE_access_vadj )
				{
				case TE_private_vadj:
						TE_setisprivate ( typeCode );
					break;

				case TE_protect_vadj:
						TE_setisprotected ( typeCode );
					break;

				case TE_public_vadj:
						TE_setispublic ( typeCode );
					break;

				default:
						TE_setisbadtype ( typeCode );
						return	typeCode;

				}	// End of SWITCH
			}	// End of CASE '0,1,2,3,4,5'
			break;

		default:
				TE_setisbadtype ( typeCode );
				return	typeCode;

		}	// End of SWITCH

		//	Advance past the code character

		gName++;

	}	// End of ELIF then
	elif	(( *gName >= TE_static_d ) && ( *gName <= TE_metatype ))	// Non function decorations ?
	{
		int	code	= *gName++;


		TE_setisdata ( typeCode );

		//	What type of symbol is it ?

		switch	( code )
		{
		case ( TE_static_d | TE_private_d ):
				TE_setisstatic ( typeCode );
				TE_setisprivate ( typeCode );
			break;

		case ( TE_static_d | TE_protect_d ):
				TE_setisstatic ( typeCode );
				TE_setisprotected ( typeCode );
			break;

		case ( TE_static_d | TE_public_d ):
				TE_setisstatic ( typeCode );
				TE_setispublic ( typeCode );
			break;

		case TE_global:
				TE_setisglobal ( typeCode );
			break;

		case TE_guard:
				TE_setisguard ( typeCode );
			break;

		case TE_local:
				TE_setislocal ( typeCode );
			break;

		case TE_vftable:
				TE_setisvftable ( typeCode );
			break;

		case TE_vbtable:
				TE_setisvbtable ( typeCode );
			break;

		case TE_metatype:
				TE_setismetaclass ( typeCode );
			break;

		default:
				TE_setisbadtype ( typeCode );

				return	typeCode;

		}	// End of SWITCH
	}	// End of ELIF then
	elif	( *gName == '9' ) {
		gName++;

		TE_setisCident ( typeCode );
	}
	elif	( *gName )
		TE_setisbadtype ( typeCode );
	else
		TE_setistruncated ( typeCode );

	//	Return the composed type code

	return	typeCode;

}	// End of "UnDecorator" FUNCTION "getTypeEncoding"



DName	__near	UnDecorator::getBasedType ( void )
{
	DName	basedDecl ( UScore ( TOK_basedLp ));


	//	What type of 'based' is it ?

	if	( *gName )
	{
		switch	( *gName++ )
		{
#if !VERS_32BIT
		case BT_segname:
				basedDecl	+= UScore ( TOK_segnameLpQ ) + getSegmentName () + "\")";
			break;

		case BT_segment:
				basedDecl	+= DName ( "NYI:" ) + UScore ( TOK_segment );
			break;
#endif

		case BT_void:
				basedDecl	+= "void";
			break;

#if !VERS_32BIT
		case BT_self:
				basedDecl	+= UScore ( TOK_self );
			break;

		case BT_nearptr:
				basedDecl	+= DName ( "NYI:" ) + UScore ( TOK_nearP );
			break;

		case BT_farptr:
				basedDecl	+= DName ( "NYI:" ) + UScore ( TOK_farP );
			break;

		case BT_hugeptr:
				basedDecl	+= DName ( "NYI:" ) + UScore ( TOK_hugeP );
			break;

		case BT_segaddr:
				basedDecl	+= "NYI:<segment-address-of-variable>";
			break;
#else
		case BT_nearptr:
				basedDecl	+= getScopedName();
			break;
#endif

		case BT_basedptr:
				//
				// Note: based pointer on based pointer is reserved
				//
				return	DN_invalid;

		}	// End of SWITCH
	}	// End of IF else
	else
		basedDecl	+= DN_truncated;

	//	Close the based syntax

	basedDecl	+= ") ";

	//	Return completed based declaration

	return	basedDecl;

}	// End of "UnDecorator" FUNCTION "getBasedType"



DName	__near	UnDecorator::getScopedName ( void )
{
	DName	name;


	//	Get the beginning of the name

	name	= getZName ( true );

	//	Now the scope (if any)

	if	(( name.status () == DN_valid ) && *gName && ( *gName != '@' ))
		name	= getScope () + "::" + name;

	//	Skip the trailing '@'

	if		( *gName == '@' )
		gName++;
	elif	( *gName )
		name	= DN_invalid;
	elif	( name.isEmpty ())
		name	= DN_truncated;
	else
		name	= DName ( DN_truncated ) + "::" + name;

	//	And return the complete name

	return	name;

}	// End of "UnDecorator" FUNCTION "getECSUName"


inline	DName			UnDecorator::getECSUName ( void )		{ return getScopedName(); }


inline	DName	__near	UnDecorator::getEnumType ( void )
{
	DName	ecsuName;


	if	( *gName )
	{
		//	What type of an 'enum' is it ?

		switch	( *gName )
		{
		case ET_schar:
		case ET_uchar:
				ecsuName	= "char ";
			break;

		case ET_sshort:
		case ET_ushort:
				ecsuName	= "short ";
			break;

		case ET_sint:
			break;

		case ET_uint:
				ecsuName	= "int ";
			break;

		case ET_slong:
		case ET_ulong:
				ecsuName	= "long ";
			break;

		default:
			return	DN_invalid;

		}	// End of SWITCH

		//	Add the 'unsigned'ness if appropriate
		
		switch	( *gName++ )
		{
		case ET_uchar:
		case ET_ushort:
		case ET_uint:
		case ET_ulong:
				ecsuName	= "unsigned " + ecsuName;
			break;

		}	// End of SWITCH

		//	Now return the composed name

		return	ecsuName;

	}	// End of IF then
	else
		return	DN_truncated;

}	// End of "UnDecorator" FUNCTION "getEnumType"



DName	__near	UnDecorator::getCallingConvention ( void )
{
	if	( *gName )
	{
		unsigned int	callCode	= ((unsigned int)*gName++ ) - 'A';


		//	What is the primary calling convention

		DASSERT(CC_cdecl == 0);
#if CC_COR
		if	(/*( callCode >= CC_cdecl ) &&*/( callCode <= CC_cocall ))
#else	// CC_COR
		if	(/*( callCode >= CC_cdecl ) &&*/( callCode <= CC_interrupt ))
#endif	// CC_COR
		{
			DName	callType;


			//	Now, what type of 'calling-convention' is it, 'interrupt' is special ?

			if	( doMSKeywords ())
#if !VERS_32BIT
				if	( callCode == CC_interrupt )
					callType	= UScore ( TOK_interrupt );
				else
#endif
				{
					switch	( callCode & ~CC_saveregs )
					{
					case CC_cdecl:
							callType	= UScore ( TOK_cdecl );
						break;

					case CC_pascal:
							callType	= UScore ( TOK_pascal );
						break;

					case CC_thiscall:
							callType	= UScore ( TOK_thiscall );
						break;

					case CC_stdcall:
							callType	= UScore ( TOK_stdcall );
						break;

					case CC_fastcall:
							callType	= UScore ( TOK_fastcall );
						break;

					case CC_cocall:
							callType	= UScore ( TOK_cocall );
						break;

					}	// End of SWITCH

					//	Has it also got 'saveregs' marked ?

#if !VERS_32BIT
					if	( callCode & CC_saveregs )
						callType	+= ' ' + UScore ( TOK_saveregs );
#endif

				}	// End of IF else

			//	And return

			return	callType;

		}	// End of IF then
		else
			return	DN_invalid;

	}	// End of IF then
	else
		return	DN_truncated;

}	// End of "UnDecorator" FUNCTION "getCallingConvention"



DName	__near	UnDecorator::getReturnType ( DName * pDeclarator )
{
	if	( *gName == '@' )	// Return type for constructors and destructors ?
	{
		gName++;

		return	DName ( pDeclarator );

	}	// End of IF then
	else
		return	getDataType ( pDeclarator );

}	// End of "UnDecorator" FUNCTION "getReturnType"



DName	__near	UnDecorator::getDataType ( DName * pDeclarator )
{
	DName	superType ( pDeclarator );


	//	What type is it ?

	switch	( *gName )
	{
	case 0:
			return	( DN_truncated + superType );

	case DT_void:
			gName++;

			if	( superType.isEmpty ())
				return	"void";
			else
				return	"void " + superType;

	case '?':
		{

			gName++;	// Skip the '?'

			superType = getDataIndirectType ( superType, 0, DName (), 0);
			return	getPrimaryDataType ( superType );

			return	superType;

		}	// End of CASE '?'

	default:
			return	getPrimaryDataType ( superType );

	}	// End of SWITCH
}	// End of "UnDecorator" FUNCTION "getDataType"



DName	__near	UnDecorator::getPrimaryDataType ( const DName & superType )
{
	DName	cvType;


	switch	( *gName )
	{
	case 0:
			return	( DN_truncated + superType );

	case PDT_volatileReference:
			cvType	= "volatile";

			if	( !superType.isEmpty ())
				cvType	+= ' ';

		// No break

	case PDT_reference:
		{
			DName	superName ( superType );


			gName++;

			return	getReferenceType ( cvType, superName.setPtrRef ());

		}	// End of CASE 'PDT_reference'

	case PDT_extend:
		{
			//
			// Extended Primary Data Type (items overlooked in original design):
			// prefixed by '$$'.
			//
			if	( gName[1] != PDT_extend )
				if	( gName[1] == '\0' ) 
					return DN_truncated + superType;
				else
					return DN_invalid;

			gName += 2;

			switch	( *gName )
			{
			case PDT_ex_function:
				gName++;
				return	getFunctionIndirectType( superType );

			case PDT_ex_other:
				gName++;
				return	getPtrRefDataType( superType, /* isPtr = */ TRUE );

			case PDT_ex_qualified:
				gName++;
				return(getBasicDataType(getDataIndirectType ( superType, 0, DName (), 0)));

			case 0:
				return	( DN_truncated + superType );

			default:
				return	DN_invalid;
			}
		}

	default:
			return	getBasicDataType ( superType );

	}	// End of SWITCH
}	// End of "UnDecorator" FUNCTION "getPrimaryDataType"



DName	__near	UnDecorator::getArgumentTypes ( void )
{
	switch	( *gName )
	{
	case AT_ellipsis:
			return	( gName++, "..." );

	case AT_void:
			return	( gName++, "void" );

	default:
		{
			DName	arguments ( getArgumentList ());


			//	Now, is it a varargs function or not ?

			if	( arguments.status () == DN_valid )
				switch	( *gName )
				{
				case 0:
						return	arguments;

				case AT_ellipsis:
						return	( gName++, arguments + ",..." );

				case AT_endoflist:
						return	( gName++, arguments );

				default:
						return	DN_invalid;

				}	// End of SWITCH
			else
				return	arguments;

		}	// End of DEFAULT
	}	// End of SWITCH
}	// End of "UnDecorator" FUNCTION "getArgumentTypes"


DName	__near	UnDecorator::getArgumentList ( void )
{
	int		first	= TRUE;
	DName	aList;


	while	(( aList.status () == DN_valid ) && ( *gName != AT_endoflist ) && ( *gName != AT_ellipsis ))
	{
		//	Insert the argument list separator if not the first argument

		if	( first )
			first	= FALSE;
		else
			aList	+= ',';


		//	Get the individual argument type

		if	( *gName )
		{
			int		argIndex	= *gName - '0';


			//	Handle 'argument-replicators', otherwise a new argument type

			if	(( argIndex >= 0 ) && ( argIndex <= 9 ))
			{
				gName++;	// Skip past the replicator

				//	Append to the argument list

				aList	+= ( *pArgList )[ argIndex ];

			}	// End of IF then
			else
			{
				pcchar_t	oldGName	= gName;


				//	Extract the 'argument' type

				DName	arg ( getPrimaryDataType ( DName ()));


				//	Add it to the current list of 'argument's, if it is bigger than a one byte encoding

				if	((( gName - oldGName ) > 1 ) && !pArgList->isFull ())
					*pArgList	+= arg;

				//	Append to the argument list

				aList	+= arg;

			}	// End of IF else
		}	// End of IF then
		else
		{
			aList	+= DN_truncated;

			break;

		}	// End of IF else
	}	// End of WHILE

	//	Return the completed argument list

	return	aList;

}	// End of "UnDecorator" FUNCTION "getArgumentList"



DName	__near	UnDecorator::getThrowTypes ( void )
{
	if	( *gName )
		if	( *gName == AT_ellipsis )	// Handle ellipsis here to suppress the 'throw' signature
			return	( gName++, DName ());
		else
			return	( " throw(" + getArgumentTypes () + ')' );
	else
		return	( DName ( " throw(" ) + DN_truncated + ')' );

}	// End of "UnDecorator" FUNCTION "getThrowTypes"



DName	__near	UnDecorator::getBasicDataType ( const DName & superType )
{
	if	( *gName )
	{
		unsigned char	bdtCode	= *gName++;
		unsigned char	extended_bdtCode;
		int				pCvCode	= -1;
		DName			basicDataType;


		//	Extract the principal type information itself, and validate the codes

		switch	( bdtCode )
		{
		case BDT_schar:
		case BDT_char:
		case ( BDT_char   | BDT_unsigned ):
				basicDataType	= "char";
			break;

		case BDT_short:
		case ( BDT_short  | BDT_unsigned ):
				basicDataType	= "short";
			break;

		case BDT_int:
		case ( BDT_int    | BDT_unsigned ):
				basicDataType	= "int";
			break;

		case BDT_long:
		case ( BDT_long   | BDT_unsigned ):
				basicDataType	= "long";
			break;

#if !VERS_32BIT
		case BDT_segment:
				basicDataType	= UScore ( TOK_segment );
			break;
#endif

		case BDT_float:
				basicDataType	= "float";
			break;

		case BDT_longdouble:
				basicDataType	= "long ";

			// No break

		case BDT_double:
				basicDataType	+= "double";
			break;

		case BDT_pointer:
		case ( BDT_pointer | BDT_const ):
		case ( BDT_pointer | BDT_volatile ):
		case ( BDT_pointer | BDT_const | BDT_volatile ):
				pCvCode	= ( bdtCode & ( BDT_const | BDT_volatile ));
			break;
		case BDT_extend:
			switch(extended_bdtCode = *gName++) {
				case BDT_array:
					pCvCode = -2;
					break;
				case BDT_bool:
					basicDataType	= "bool";
					break;
				case BDT_int8:
				case ( BDT_int8   | BDT_unsigned ):
					basicDataType	= "__int8";
					break;
				case BDT_int16:
				case ( BDT_int16  | BDT_unsigned ):
					basicDataType	= "__int16";
					break;
				case BDT_int32:
				case ( BDT_int32  | BDT_unsigned ):
					basicDataType	= "__int32";
					break;
				case BDT_int64:
				case ( BDT_int64  | BDT_unsigned ):
					basicDataType	= "__int64";
					break;
				case BDT_int128:
				case ( BDT_int128 | BDT_unsigned ):
					basicDataType	= "__int128";
					break;
				case BDT_wchar_t:
					basicDataType	= "wchar_t";
					break;
#if CC_COR
				case BDT_coclass:
				case BDT_cointerface:
					{
						gName--;	// Backup, since 'ecsu-data-type' does it's own decoding

						basicDataType = getECSUDataType();

						if ( basicDataType.isEmpty()) {
							return basicDataType;
						}
					}
					break;
#endif	// CC_COR
				case '$':
					return "__w64 " + getBasicDataType (superType);
				default:
					basicDataType	= "UNKNOWN";
					break;
				}
			break;
		default:
				gName--;	// Backup, since 'ecsu-data-type' does it's own decoding

				basicDataType	= getECSUDataType ();

				if	( basicDataType.isEmpty ())
					return	basicDataType;
			break;

		}	// End of SWITCH

		//	What type of basic data type composition is involved ?

		if	( pCvCode == -1 )	// Simple ?
		{
			//	Determine the 'signed/unsigned'ness

			switch	( bdtCode )
			{
			case ( BDT_char   | BDT_unsigned ):
			case ( BDT_short  | BDT_unsigned ):
			case ( BDT_int    | BDT_unsigned ):
			case ( BDT_long   | BDT_unsigned ):
					basicDataType	= "unsigned " + basicDataType;
				break;

			case BDT_schar:
					basicDataType	= "signed " + basicDataType;
				break;
			case BDT_extend:
				switch	( extended_bdtCode )
				{

					case ( BDT_int8   | BDT_unsigned ):
					case ( BDT_int16  | BDT_unsigned ):
					case ( BDT_int32  | BDT_unsigned ):
					case ( BDT_int64  | BDT_unsigned ):
					case ( BDT_int128 | BDT_unsigned ):
						basicDataType	= "unsigned " + basicDataType;
						break;

				}	// End of SWITCH
				break;

			}	// End of SWITCH

			// 	Add the indirection type to the type

			if	( !superType.isEmpty () )
					basicDataType	+= ' ' + superType;

			//	And return the completed type

			return	basicDataType;

		}	// End of IF then
		else
		{
			DName	cvType;
			DName	superName ( superType );

			if ( pCvCode == -2 )
			{
				superName.setIsArray();
				DName arType =	getPointerTypeArray ( cvType, superName );
				// if we didn't get back an array, append.
				// A multidimensional array sticks the braces in before the
				// other dimensions at sets isArray on it's return type.
				if (!arType.isArray()) {
					arType += "[]";
				}
				return arType;
			}

			//	Is it 'const/volatile' qualified ?
			
			if		( superType . isEmpty() ) 
			{
				//
				// const/volatile are redundantly encoded, except at the start
				// of a "type only" context.  In such a context, the super-type
				// is empty.
				//
				if		( pCvCode & BDT_const )
				{
					cvType	= "const";

					if	( pCvCode & BDT_volatile )
						cvType	+= " volatile";
				}	// End of IF then
				elif	( pCvCode & BDT_volatile )
					cvType	= "volatile";
			}	// End of IF then

			//	Construct the appropriate pointer type declaration

			return	getPointerType ( cvType, superName );

		}	// End of IF else
	}	// End of IF then
	else
		return	( DN_truncated + superType );

}	// End of "UnDecorator" FUNCTION "getBasicDataType"



DName	__near	UnDecorator::getECSUDataType ( void )
{
	//	Extract the principal type information itself, and validate the codes

	int fPrefix = doEcsu() && !doNameOnly();

	DName Prefix;

	switch	( *gName++ )
	{
	case 0:
			gName--;	// Backup to permit later error recovery to work safely

			return	"`unknown ecsu'" + DN_truncated;

	case BDT_union:
			Prefix = "union ";
		break;

	case BDT_struct:
			Prefix = "struct ";
		break;

	case BDT_class:
			Prefix = "class ";
		break;

#if CC_COR
	case BDT_coclass:
			Prefix = "coclass ";
		break;

	case BDT_cointerface:
			Prefix = "cointerface ";
		break;
#endif	// CC_COR

	case BDT_enum:
			fPrefix = doEcsu();

			Prefix = "enum " + getEnumType ();
		break;

//	default:
//			return	DN_invalid;

	}	// End of SWITCH

	DName			ecsuDataType;

	if	( fPrefix )
		ecsuDataType	= Prefix;

	//	Get the 'class/struct/union' name

	ecsuDataType	+= getECSUName ();

	//	And return the formed 'ecsu-data-type'

	return	ecsuDataType;

}	// End of "UnDecorator" FUNCTION "getECSUDataType"


//
// Undecorator::getFunctionIndirectType
//
//	Note: this function gets both the function-indirect-type and the function-type.
//
DName		UnDecorator::getFunctionIndirectType( const DName & superType )
{
	if	( ! *gName )
		return DN_truncated + superType;

	if	( ! IT_isfunction( *gName ))
		return DN_invalid;


	int		fitCode	= *gName++ - '6';

	if		( fitCode == ( '_' - '6' ))
	{
		if	( *gName )
		{
			fitCode	= *gName++ - 'A' + FIT_based;

			if	(( fitCode < FIT_based ) || ( fitCode > ( FIT_based | FIT_far | FIT_member )))
				fitCode	= -1;

		}	// End of IF then
		else
			return	( DN_truncated + superType );

	}	// End of IF then
	elif	(( fitCode < FIT_near ) || ( fitCode > ( FIT_far | FIT_member )))
		fitCode	= -1;

	//	Return if invalid name

	if	( fitCode == -1 )
		return	DN_invalid;


	//	Otherwise, what are the function indirect attributes

	DName	thisType;
	DName	fitType = superType;

	//	Is it a pointer to member function ?

	if	( fitCode & FIT_member )
	{
		fitType	= "::" + fitType;

		if	( *gName )
			fitType	= ' ' + getScope () + fitType;
		else
			fitType	= DN_truncated + fitType;

		if	( *gName )
			if	( *gName == '@' )
				gName++;
			else
				return	DN_invalid;
		else
			return	( DN_truncated + fitType );

		if	( doThisTypes ())
			thisType	= getThisType ();
		else
			thisType	|= getThisType ();

	}	// End of IF

	//	Is it a based allocated function ?

	if	( fitCode & FIT_based )
		if	( doMSKeywords ())
			fitType	= ' ' + getBasedType () + fitType;
		else
			fitType	|= getBasedType ();	// Just lose the 'based-type'

	//	Get the 'calling-convention'

	if	( doMSKeywords ())
	{
		fitType	= getCallingConvention () + fitType;

		//	Is it a near or far function pointer

#if !VERS_32BIT
		fitType	= UScore ((( fitCode & FIT_far ) ? TOK_farSp : TOK_nearSp )) + fitType;
#endif

	}	// End of IF then
	else
		fitType	|= getCallingConvention ();	// Just lose the 'calling-convention'

	//	Parenthesise the indirection component, and work on the rest

	if	( ! superType . isEmpty() ) {
		fitType	= '(' + fitType + ')';
	}

	//	Get the rest of the 'function-type' pieces

	DName *	pDeclarator	= gnew DName;
	DName	returnType ( getReturnType ( pDeclarator ));


	fitType	+= '(' + getArgumentTypes () + ')';

	if	( doThisTypes () && ( fitCode & FIT_member ))
		fitType	+= thisType;

	if	( doThrowTypes ())
		fitType	+= getThrowTypes ();
	else
		fitType	|= getThrowTypes ();	// Just lose the 'throw-types'

	//	Now insert the indirected declarator, catch the allocation failure here

	if	( pDeclarator )
		*pDeclarator	= fitType;
	else
		return	DN_error;

	//	And return the composed function type (now in 'returnType' )

	return	returnType;
}


DName	__near	UnDecorator::getPtrRefType ( const DName & cvType, const DName & superType, char ptrChar )
{
	//	Doubles up as 'pointer-type' and 'reference-type'

	if	( *gName )
		if	( IT_isfunction ( *gName ))	// Is it a function or data indirection ?
		{
			DName	fitType	= ptrChar;


			if	( !cvType.isEmpty () && ( superType.isEmpty () || !superType.isPtrRef ()))
				fitType	+= cvType;

			if	( !superType.isEmpty ())
				fitType	+= superType;

			return getFunctionIndirectType( fitType );
		}	// End of IF then
		else
		{
			//	Otherwise, it is either a pointer or a reference to some data type

			DName	innerType ( getDataIndirectType ( superType, ptrChar, cvType ));

			return	getPtrRefDataType ( innerType, ptrChar == '*' );
		}	// End of IF else
	else
	{
		DName	trunk ( DN_truncated );


		trunk	+= ptrChar;

		if	( !cvType.isEmpty ())
			trunk	+= cvType;

		if	( !superType.isEmpty ())
		{
			if	( !cvType.isEmpty ())
				trunk	+= ' ';

			trunk	+= superType;

		}	// End of IF

		return	trunk;

	}	// End of IF else
}	// End of "UnDecorator" FUNCTION "getPtrRefType"



DName	__near	UnDecorator::getDataIndirectType ( const DName & superType, char prType, const DName & cvType, int thisFlag )
{
	DName szComPlusIndirSpecifier;

	if		( *gName )
	{
		if( gName[0] == '$' ) 
		{
			bool bGenericArray = false;

			gName++;	// swallow up the dollar

			switch( *gName++ )
			{
			case PDT_GCPointer:
				szComPlusIndirSpecifier = "__gc ";
				break;

			case PDT_PinnedPointer:
				szComPlusIndirSpecifier = "__pin ";
				break;
			case '1':
				bGenericArray = true;
				// fall through
			case '0':

				// this is a COM+ array

				if( bGenericArray )
				{
					szComPlusIndirSpecifier = "__gc[?] ";
					gName += 2;	// ignore the rank
				}
				else
				{
					unsigned int nRank = ((gName[0]-'0') << 4) + (gName[1]-'0');
					gName += 2;

					DASSERT( nRank < 256 );

					szComPlusIndirSpecifier = "__gc[";

					for( unsigned int i=1; i<nRank; i++ )
					{
						szComPlusIndirSpecifier = szComPlusIndirSpecifier + ",";
					}

					szComPlusIndirSpecifier = szComPlusIndirSpecifier + "] ";
				}

				prType = 0;	// so we won't get '*' for COM+ array
			}
		}

		unsigned int	ditCode	= ( *gName - (( *gName >= 'A' ) ? (unsigned int)'A': (unsigned int)( '0' - 26 )));

		DName msExtension;
		DName msExtensionPre;

		int fContinue = TRUE;

		do
		{
			switch	( ditCode )
			{
			case DIT_ptr64:
					if	( doMSKeywords () && doPtr64() ) {
						if ( !msExtension.isEmpty())
							msExtension = msExtension + ' ' + UScore( TOK_ptr64 );
						else
							msExtension = UScore( TOK_ptr64 );
					}
					gName++;
					ditCode	= ( *gName - (( *gName >= 'A' ) ? (unsigned int)'A': (unsigned int)( '0' - 26 )));
				break;
			case DIT_unaligned:
					if	( doMSKeywords ()) {
						if ( !msExtensionPre.isEmpty())
							msExtensionPre = msExtensionPre + ' ' + UScore( TOK_unaligned );
						else
							msExtensionPre = UScore( TOK_unaligned );
					}
					gName++;
					ditCode	= ( *gName - (( *gName >= 'A' ) ? (unsigned int)'A': (unsigned int)( '0' - 26 )));
				break;
			case DIT_restrict:
					if	( doMSKeywords ()) {
						if ( !msExtension.isEmpty())
							msExtension = msExtension + ' ' + UScore( TOK_restrict );
						else
							msExtension = UScore( TOK_restrict );
					}
					gName++;
					ditCode	= ( *gName - (( *gName >= 'A' ) ? (unsigned int)'A': (unsigned int)( '0' - 26 )));
				break;

			default:

				fContinue = FALSE;
				break;
			}
		} while (fContinue);

		gName++;		// Skip to next character in name

		//	Is it a valid 'data-indirection-type' ?

		DASSERT(DIT_near == 0);
		if	(( ditCode <= ( DIT_const | DIT_volatile | DIT_modelmask | DIT_member )))
		{
			DName	ditType ( prType );

			ditType = szComPlusIndirSpecifier + ditType;

			if ( !msExtension.isEmpty()) 
				ditType = ditType + ' ' + msExtension;

			if ( !msExtensionPre.isEmpty())
				ditType = msExtensionPre + ' ' + ditType;

			//	If it is a member, then these attributes immediately precede the indirection token

			if	( ditCode & DIT_member )
			{
				//	If it is really 'this-type', then it cannot be any form of pointer to member

				if	( thisFlag )
					return	DN_invalid;

				//	Otherwise, extract the scope for the PM

				if		( prType != '\0' )
				{
					ditType		= "::" + ditType;

					if	( *gName )
						ditType	= getScope () + ditType;
					else
						ditType	= DN_truncated + ditType;
				}
				elif	( *gName )
				{
					//
					// The scope is ignored for special uses of data-indirect-type, such
					// as storage-convention.  I think it's a bug that we ever mark things
					// with Member storage convention, as that is already covered in the
					// scope of the name.  However, we don't want to change the dname scheme,
					// so we're stuck with it.
					//
					ditType |= getScope ();
				}

				//	Now skip the scope terminator

				if		( !*gName )
					ditType	+= DN_truncated;
				elif	( *gName++ != '@' )
					return	DN_invalid;

			}	// End of IF

			//	Add the 'model' attributes (prefixed) as appropriate

			if	( doMSKeywords ()) {
				switch	( ditCode & DIT_modelmask )
				{
#if !VERS_32BIT
				case DIT_near:
						if	( do32BitNear ())
							ditType	= UScore ( TOK_near ) + ditType;
					break;

				case DIT_far:
						ditType	= UScore ( TOK_far ) + ditType;
					break;

				case DIT_huge:
						ditType	= UScore ( TOK_huge ) + ditType;
					break;
#endif

				case DIT_based:
						//	The 'this-type' can never be 'based'

						if	( thisFlag )
							return	DN_invalid;

						ditType	= getBasedType () + ditType;
					break;

				}	// End of SWITCH
			}	// End of IF
			elif	(( ditCode & DIT_modelmask ) == DIT_based )
				ditType	|= getBasedType ();	// Just lose the 'based-type'

			//	Handle the 'const' and 'volatile' attributes

			if	( ditCode & DIT_volatile )
				ditType	= "volatile " + ditType;

			if	( ditCode & DIT_const )
				ditType	= "const " + ditType;

			//	Append the supertype, if not 'this-type'

			if	( !thisFlag )
				if		( !superType.isEmpty ())
				{
					//	Is the super context included 'cv' information, ensure that it is added appropriately

					if	( superType.isPtrRef () || cvType.isEmpty ())
						if (superType.isArray())
							ditType	= superType;	// array type, skip space
						else
							ditType	+= ' ' + superType;
					else
						ditType	+= ' ' + cvType + ' ' + superType;

				}	// End of IF then
				elif	( !cvType.isEmpty ())
					ditType	+= ' ' + cvType;

			//	Make sure qualifiers aren't re-applied
			ditType.setPtrRef ();

			//	Finally, return the composed 'data-indirection-type' (with embedded sub-type)

			return	ditType;

		}	// End of IF then
		else
			return	DN_invalid;

	}	// End of IF then
	elif	( !thisFlag && !superType.isEmpty ())
	{
		//	Is the super context included 'cv' information, ensure that it is added appropriately

		if	( superType.isPtrRef () || cvType.isEmpty ())
			return	( DN_truncated + superType );
		else
			return	( DN_truncated + cvType + ' ' + superType );

	}	// End of ELIF then
	elif	( !thisFlag && !cvType.isEmpty ())
		return	( DN_truncated + cvType );
	else
		return	DN_truncated;

}	// End of "UnDecorator" FUNCTION "getDataIndirectType"


inline	DName	__near	UnDecorator::getPtrRefDataType ( const DName & superType, int isPtr )
{
	//	Doubles up as 'pointer-data-type' and 'reference-data-type'

	if	( *gName )
	{
		//	Is this a 'pointer-data-type' ?

		if	( isPtr && ( *gName == PoDT_void ))
		{
			gName++;	// Skip this character

			if	( superType.isEmpty ())
				return	"void";
			else
				return	"void " + superType;

		}	// End of IF

		//	Otherwise it may be a 'reference-data-type'

		if	( *gName == RDT_array )	// An array ?
		{
			gName++;

			return	getArrayType( superType );

		}	// End of IF

		//	Otherwise, it is a 'basic-data-type'

		if	( *gName == '_' && gName[1] == 'Z' )	// A boxed type ?
		{
			gName += 2;
			return "__box " + getBasicDataType ( superType );
		}

		return	getBasicDataType ( superType );

	}	// End of IF then
	else
		return	( DN_truncated + superType );

}	// End of "UnDecorator" FUNCTION "getPtrRefDataType"


inline	DName	__near	UnDecorator::getArrayType ( const DName & superType )
{
	if	( *gName )
	{
		int	noDimensions	= getNumberOfDimensions ();

		if ( noDimensions < 0 )
			noDimensions = 0;

		if	( !noDimensions )
			return	getBasicDataType ( DName ( '[' ) + DN_truncated + ']' );
		else
		{
			DName	arrayType;

			if ( superType.isArray() ) {
				arrayType	+= "[]";
			}

			while	( noDimensions-- )
				arrayType	+= '[' + getDimension () + ']';

			//	If it is indirect, then parenthesise the 'super-type'

			if	( !superType.isEmpty () )
				if ( superType.isArray() )
					arrayType	= superType + arrayType;
				else
					arrayType	= '(' + superType + ')' + arrayType;

			//	Return the finished array dimension information

			DName newType =	getPrimaryDataType ( arrayType );
			newType.setIsArray();
			return newType;

		}	// End of IF else
	}	// End of IF
	elif	( !superType.isEmpty ())
		return	getBasicDataType ( '(' + superType + ")[" + DN_truncated + ']' );
	else
		return	getBasicDataType ( DName ( '[' ) + DN_truncated + ']' );

}	// End of "UnDecorator" FUNCTION "getArrayType"


inline		DName		__near	UnDecorator::getLexicalFrame ( void )		{	return	'`' + getDimension () + '\'';	}
inline		DName		__near	UnDecorator::getStorageConvention ( void )	{	return	getDataIndirectType ();	}
inline		DName		__near	UnDecorator::getDataIndirectType ()			{	return	getDataIndirectType ( DName (),  0, DName ());	}
inline		DName		__near	UnDecorator::getThisType ( void )			{	return	getDataIndirectType ( DName (), 0, DName (), TRUE );	}

inline	DName		__near	UnDecorator::getPointerType ( const DName & cv, const DName & name )
{	return	getPtrRefType ( cv, name, '*' );	}

inline	DName		__near	UnDecorator::getPointerTypeArray ( const DName & cv, const DName & name )
{	return	getPtrRefType ( cv, name, '\0' );	}

inline	DName		__near	UnDecorator::getReferenceType ( const DName & cv, const DName & name )
{	return	getPtrRefType ( cv, name, '&' );	}

inline	DName		__near	UnDecorator::getSegmentName ( void )		{	return	getZName ( true );	}

#if	( !NO_COMPILER_NAMES )
inline	DName		__near	UnDecorator::getDisplacement ( void )		{	return	getDimension ( true );	}
inline	DName		__near	UnDecorator::getCallIndex ( void )			{	return	getDimension ();	}
inline	DName		__near	UnDecorator::getGuardNumber ( void )		{	return	getDimension ();	}

inline	DName	__near	UnDecorator::getVbTableType ( const DName & superType )
{	return	getVfTableType ( superType );	}


inline	DName	__near	UnDecorator::getVCallThunkType ( void )
{
#if VERS_32BIT
	switch (*gName) {
	case VMT_nTnCnV:
		++gName;
		return DName("{flat}");
	case 0:
		return DN_truncated;
	default:
		return DN_invalid;
	}
#else
	DName	vcallType	= '{';


	//	Get the 'this' model, and validate all values

	switch	( *gName )
	{
	case VMT_nTnCnV:
	case VMT_nTfCnV:
	case VMT_nTnCfV:
	case VMT_nTfCfV:
	case VMT_nTnCbV:
	case VMT_nTfCbV:
			vcallType	+= UScore ( TOK_nearSp );
		break;

	case VMT_fTnCnV:
	case VMT_fTfCnV:
	case VMT_fTnCfV:
	case VMT_fTfCfV:
	case VMT_fTnCbV:
	case VMT_fTfCbV:
			vcallType	+= UScore ( TOK_farSp );
		break;

	case 0:
			return	DN_truncated;

	default:
			return	DN_invalid;

	}	// End of SWITCH

	//	Always append 'this'

	vcallType	+= "this, ";

	//	Get the 'call' model

	switch	( *gName )
	{
	case VMT_nTnCnV:
	case VMT_fTnCnV:
	case VMT_nTnCfV:
	case VMT_fTnCfV:
	case VMT_nTnCbV:
	case VMT_fTnCbV:
			vcallType	+= UScore ( TOK_nearSp );
		break;

	case VMT_nTfCnV:
	case VMT_fTfCnV:
	case VMT_nTfCfV:
	case VMT_fTfCfV:
	case VMT_nTfCbV:
	case VMT_fTfCbV:
			vcallType	+= UScore ( TOK_farSp );
		break;

	}	// End of SWITCH

	//	Always append 'call'

	vcallType	+= "call, ";

	//	Get the 'vfptr' model

	switch	( *gName++ )	// Last time, so advance the pointer
	{
	case VMT_nTnCnV:
	case VMT_nTfCnV:
	case VMT_fTnCnV:
	case VMT_fTfCnV:
			vcallType	+= UScore ( TOK_nearSp );
		break;

	case VMT_nTnCfV:
	case VMT_nTfCfV:
	case VMT_fTnCfV:
	case VMT_fTfCfV:
			vcallType	+= UScore ( TOK_farSp );
		break;

	case VMT_nTfCbV:
	case VMT_fTnCbV:
	case VMT_fTfCbV:
	case VMT_nTnCbV:
			vcallType	+= getBasedType ();
		break;

	}	// End of SWITCH	

	//	Always append 'vfptr'

	vcallType	+= "vfptr}";

	//	And return the resultant 'vcall-model-type'

	return	vcallType;
#endif

}	// End of "UnDecorator" FUNCTION "getVCallThunk"


inline	DName	__near	UnDecorator::getVfTableType ( const DName & superType )
{
	DName	vxTableName	= superType;


	if	( vxTableName.isValid () && *gName )
	{
		vxTableName	= getStorageConvention () + ' ' + vxTableName;

		if	( vxTableName.isValid ())
		{
			if	( *gName != '@' )
			{
				vxTableName	+= "{for ";

				while	( vxTableName.isValid () && *gName && ( *gName != '@' ))
				{
					vxTableName	+= '`' + getScope () + '\'';

					//	Skip the scope delimiter

					if	( *gName == '@' )
						gName++;

					//	Close the current scope, and add a conjunction for the next (if any)

					if	( vxTableName.isValid () && ( *gName != '@' ))
						vxTableName	+= "s ";

				}	// End of WHILE

				if	( vxTableName.isValid ())
				{
					if	( !*gName )
						vxTableName	+= DN_truncated;

					vxTableName	+= '}';

				}	// End of IF
			}	// End of IF

			//	Skip the 'vpath-name' terminator

			if	( *gName == '@' )
				gName++;

		}	// End of IF
	}	// End of IF then
	elif	( vxTableName.isValid ())
		vxTableName	= DN_truncated + vxTableName;

	return	vxTableName;

}	//	End of "UnDecorator" FUNCTION "getVfTableType"
#endif	// !NO_COMPILER_NAMES


inline	DName	__near	UnDecorator::getExternalDataType ( const DName & superType )
{
	//	Create an indirect declarator for the the rest

	DName *	pDeclarator	= gnew DName ();
	DName	declaration	= getDataType ( pDeclarator );


	//	Now insert the declarator into the declaration along with its 'storage-convention'

	*pDeclarator	= getStorageConvention () + ' ' + superType;

	return	declaration;

}	//	End of "UnDecorator" FUNCTION "getExternalDataType"

inline	int			__near	UnDecorator::doUnderScore ()				{	return	!( disableFlags & UNDNAME_NO_LEADING_UNDERSCORES );	}
inline	int			__near	UnDecorator::doMSKeywords ()				{	return	!( disableFlags & UNDNAME_NO_MS_KEYWORDS );			}
inline	int			__near	UnDecorator::doPtr64 ()						{	return	!( disableFlags & UNDNAME_NO_PTR64 );				}
inline	int			__near	UnDecorator::doFunctionReturns ()			{	return	!( disableFlags & UNDNAME_NO_FUNCTION_RETURNS );	}
inline	int			__near	UnDecorator::doAllocationModel ()			{	return	!( disableFlags & UNDNAME_NO_ALLOCATION_MODEL );	}
inline	int			__near	UnDecorator::doAllocationLanguage ()		{	return	!( disableFlags & UNDNAME_NO_ALLOCATION_LANGUAGE );	}

#if	0
inline	int			__near	UnDecorator::doMSThisType ()				{	return	!( disableFlags & UNDNAME_NO_MS_THISTYPE );			}
inline	int			__near	UnDecorator::doCVThisType ()				{	return	!( disableFlags & UNDNAME_NO_CV_THISTYPE );			}
#endif

inline	int			__near	UnDecorator::doThisTypes ()					{	return	(( disableFlags & UNDNAME_NO_THISTYPE ) != UNDNAME_NO_THISTYPE );	}
inline	int			__near	UnDecorator::doAccessSpecifiers ()			{	return	!( disableFlags & UNDNAME_NO_ACCESS_SPECIFIERS );	}
inline	int			__near	UnDecorator::doThrowTypes ()				{	return	!( disableFlags & UNDNAME_NO_THROW_SIGNATURES );	}
inline	int			__near	UnDecorator::doMemberTypes ()				{	return	!( disableFlags & UNDNAME_NO_MEMBER_TYPE );			}
inline	int			__near	UnDecorator::doReturnUDTModel ()			{	return	!( disableFlags & UNDNAME_NO_RETURN_UDT_MODEL );	}

inline	int			__near	UnDecorator::do32BitNear ()					{	return	!( disableFlags & UNDNAME_32_BIT_DECODE );			}

inline	int			__near	UnDecorator::doNameOnly ()					{	return	( disableFlags & UNDNAME_NAME_ONLY );				}
inline	int			__near	UnDecorator::doTypeOnly ()					{	return	( disableFlags & UNDNAME_TYPE_ONLY );				}
inline	int			__near	UnDecorator::haveTemplateParameters ()		{	return	( disableFlags & UNDNAME_HAVE_PARAMETERS);			}
inline	int 		__near	UnDecorator::doEcsu ()						{	return	!( disableFlags & UNDNAME_NO_ECSU );				}
inline	int 		__near	UnDecorator::doNoIdentCharCheck ()			{	return	( disableFlags & UNDNAME_NO_IDENT_CHAR_CHECK );		}


pcchar_t	__near	UnDecorator::UScore ( Tokens tok  )
{
#if !VERS_32BIT
	if		((( tok == TOK_nearSp ) || ( tok == TOK_nearP )) && !do32BitNear ())
		return	tokenTable[ tok ] + 6;	// Skip '__near'
#endif
	if		( doUnderScore ())
		return	tokenTable[ tok ];
	else
		return	tokenTable[ tok ] + 2 ;

}	// End of "UnDecorator" FUNCTION "UScore"



//	Include the string composition support classes.  Mostly inline stuff, and
//	not important to the algorithm.

#include	"undname.inl"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\crtdbg.h ===
/***
*crtdbg.h - Supports debugging features of the C runtime library.
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Support CRT debugging features.
*
*       [Public]
*
*Revision History:
*       08-16-94  CFW   Module created.
*       11-28-94  CFW   Add DumpClient, more params for AllocHook.
*       12-08-94  CFW   Use non-win32 names.
*       01-09-95  CFW   Dump client needs size, add _CrtSetBreakAlloc,
*                       use const state pointers.
*       01-10-95  CFW   dbgint.h merge.
*       01-20-94  CFW   Change unsigned chars to chars.
*       01-24-94  CFW   Cleanup: remove unneeded funcs, add _CrtSetDbgFlag.
*       01-24-94  CFW   _CrtDbgReport now returns 1 for debug.
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       02-17-95  CFW   new() proto moved from dbgint.h.
*       02-27-95  CFW   Change debug break scheme.
*       03-21-95  CFW   Add _CRT_ASSERT & _delete_client, remove tracking.
*       03-23-95  JWM   Restored tracking.
*       03-28-95  CFW   Remove tracking, export _crtBreakAlloc.
*       04-06-95  CFW   Add malloc -> _malloc_dbg macros.
*       04-10-95  CFW   Define NULL.
*       03-21-95  CFW   Remove _delete_client.
*       03-30-95  CFW   Avoid _CRTDBG_xxx conflicts with MFC.
*       05-11-95  CFW   Move C++ code to its own section.
*       05-12-95  CFW   Use _CrtIsValidPointer & _CrtIsValidHeapPointer.
*       06-08-95  CFW   Add return value parameter to report hook.
*       06-27-95  CFW   Add win32s support for debug libs.
*       07-25-95  CFW   Add win32s support for user visible debug heap variables.
*       09-01-95  GJF   Moved a proto for new up slightly to avoid compiler
*                       error C2660 (Olympus 1015).
*       09-20-95  CFW   Change _RPT0, _RPTF0 to support messages with '%' in them.
*       12-14-95  JWM   Add "#pragma once".
*       01-23-97  GJF   Cleaned out obsolete support for Win32s.
*       04-21-97  JWM   Added 4-parameter operator delete(), required by 6.0 compiler.
*       04-29-97  JWM   Made 4-parameter operator delete() #if _MSC_VER >= 1200.
*       08-14-97  GJF   Strip __p_* prototypes from release version. Also,
*                       moved the constant and type definition out of the ifdef
*                       _DEBUG so they are always defined.
*       01-19-98  JWM   At request of DeanM, made debug prototypes of new & delete
*                       #ifndef _MFC_OVERRIDES_NEW
*       05-22-98  JWM   Added support for new[] & delete[], courtesy of KFrei's RTC work.
*       06-08-98  JWM   Minor cleanups.
*       12-01-98  GJF   More choices for calling _CrtCheckMemory than never or always.
*       12-15-98  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*       08-30-99  PML   Get rid of unprintable character in comment.
*       10-06-99  PML   Add _W64 modifier to types which are 32 bits in Win32,
*                       64 bits in Win64.
*       11-02-99  PML   Add extern "C++" around C++ definitions.
*       11-08-99  PML   Don't mark debug operator new _CRTIMP (vs7#16060).
*       11-16-99  PML   Forward-decl _CrtMemBlockHeader to work around vs7#63059
*       01-04-00  GB    Added support for debug version for _aligned routines
*       02-25-00  PML   _CrtDbgBreak should use __debugbreak if available.
*       05-31-00  PML   Add _CrtReportBlockType (VS7#55049).
*       09-26-00  PML   Fix _ASSERT*, _RPT* to compile /W4 clean (vs7#166894)
*       12-10-00  PML   Non-_DEBUG macro versions of _CrtSet* should not be
*                       typed as void (vs7#166572).
*       03-21-01  PML   Add _CrtSetReportHook2 (vs7#124998)
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_CRTDBG
#define _INC_CRTDBG

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  __cplusplus
extern "C" {
#endif  /* __cplusplus */


 /****************************************************************************
 *
 * Constants and types
 *
 ***************************************************************************/

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300 /*IFSTRIP=IGN*/
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

typedef void *_HFILE; /* file handle pointer */

#define _CRT_WARN           0
#define _CRT_ERROR          1
#define _CRT_ASSERT         2
#define _CRT_ERRCNT         3

#define _CRTDBG_MODE_FILE      0x1
#define _CRTDBG_MODE_DEBUG     0x2
#define _CRTDBG_MODE_WNDW      0x4
#define _CRTDBG_REPORT_MODE    -1

#define _CRTDBG_INVALID_HFILE ((_HFILE)-1)
#define _CRTDBG_HFILE_ERROR   ((_HFILE)-2)
#ifndef _XBOX
#define _CRTDBG_FILE_STDOUT   ((_HFILE)-4)
#define _CRTDBG_FILE_STDERR   ((_HFILE)-5)
#endif
#define _CRTDBG_REPORT_FILE   ((_HFILE)-6)

typedef int (__cdecl * _CRT_REPORT_HOOK)(int, char *, int *);

#define _CRT_RPTHOOK_INSTALL  0
#define _CRT_RPTHOOK_REMOVE   1

 /****************************************************************************
 *
 * Heap
 *
 ***************************************************************************/

 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

#define _HOOK_ALLOC     1
#define _HOOK_REALLOC   2
#define _HOOK_FREE      3

typedef int (__cdecl * _CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int);

 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bit values for _crtDbgFlag flag:
 *
 * These bitflags control debug heap behavior.
 */

#define _CRTDBG_ALLOC_MEM_DF        0x01  /* Turn on debug allocation */
#define _CRTDBG_DELAY_FREE_MEM_DF   0x02  /* Don't actually free memory */
#define _CRTDBG_CHECK_ALWAYS_DF     0x04  /* Check heap every alloc/dealloc */
#define _CRTDBG_RESERVED_DF         0x08  /* Reserved - do not use */
#define _CRTDBG_CHECK_CRT_DF        0x10  /* Leak check/diff CRT blocks */
#define _CRTDBG_LEAK_CHECK_DF       0x20  /* Leak check at program exit */

/*
 * Some bit values for _crtDbgFlag which correspond to frequencies for checking
 * the the heap.
 */
#define _CRTDBG_CHECK_EVERY_16_DF   0x00100000  /* check heap every 16 heap ops */
#define _CRTDBG_CHECK_EVERY_128_DF  0x00800000  /* check heap every 128 heap ops */
#define _CRTDBG_CHECK_EVERY_1024_DF 0x04000000  /* check heap every 1024 heap ops */
#ifdef _XBOX
#define _CRTDBG_CHECK_DEFAULT_DF    0
#else
#define _CRTDBG_CHECK_DEFAULT_DF    _CRTDBG_CHECK_EVERY_1024_DF
#endif

#define _CRTDBG_REPORT_FLAG         -1    /* Query bitflag status */

#define _BLOCK_TYPE(block)          (block & 0xFFFF)
#define _BLOCK_SUBTYPE(block)       (block >> 16 & 0xFFFF)


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

/* Memory block identification */
#define _FREE_BLOCK      0
#define _NORMAL_BLOCK    1
#define _CRT_BLOCK       2
#define _IGNORE_BLOCK    3
#define _CLIENT_BLOCK    4
#define _MAX_BLOCKS      5

typedef void (__cdecl * _CRT_DUMP_CLIENT)(void *, size_t);

struct _CrtMemBlockHeader;
typedef struct _CrtMemState
{
        struct _CrtMemBlockHeader * pBlockHeader;
        size_t lCounts[_MAX_BLOCKS];
        size_t lSizes[_MAX_BLOCKS];
        size_t lHighWaterCount;
        size_t lTotalCount;
} _CrtMemState;


 /****************************************************************************
 *
 * Declarations, prototype and function-like macros
 *
 ***************************************************************************/


#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

#define _ASSERT(expr) ((void)0)

#define _ASSERTE(expr) ((void)0)


#define _RPT0(rptno, msg)

#define _RPT1(rptno, msg, arg1)

#define _RPT2(rptno, msg, arg1, arg2)

#define _RPT3(rptno, msg, arg1, arg2, arg3)

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4)


#define _RPTF0(rptno, msg)

#define _RPTF1(rptno, msg, arg1)

#define _RPTF2(rptno, msg, arg1, arg2)

#define _RPTF3(rptno, msg, arg1, arg2, arg3)

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4)

#define _malloc_dbg(s, t, f, l)         malloc(s)
#define _calloc_dbg(c, s, t, f, l)      calloc(c, s)
#define _realloc_dbg(p, s, t, f, l)     realloc(p, s)
#define _expand_dbg(p, s, t, f, l)      _expand(p, s)
#define _free_dbg(p, t)                 free(p)
#define _msize_dbg(p, t)                _msize(p)

#define _aligned_malloc_dbg(s, a, f, l)     _aligned_malloc(s, a)
#define _aligned_realloc_dbg(p, s, a, f, l) _aligned_realloc(p, s, a)
#define _aligned_free_dbg(p)                _aligned_free(p)
#define _aligned_offset_malloc_dbg(s, a, o, f, l)       _aligned_offset_malloc(s, a, o)
#define _aligned_offset_realloc_dbg(p, s, a, o, f, l)   _aligned_offset_realloc(p, s, a, o)

#define _CrtSetReportHook(f)                ((_CRT_REPORT_HOOK)0)
#define _CrtSetReportHook2(t, f)            ((int)0)
#define _CrtSetReportMode(t, f)             ((int)0)
#define _CrtSetReportFile(t, f)             ((_HFILE)0)

#define _CrtDbgBreak()                      ((void)0)

#define _CrtSetBreakAlloc(a)                ((long)0)

#define _CrtSetAllocHook(f)                 ((_CRT_ALLOC_HOOK)0)

#define _CrtCheckMemory()                   ((int)1)
#define _CrtSetDbgFlag(f)                   ((int)0)
#define _CrtDoForAllClientObjects(f, c)     ((void)0)
#define _CrtIsValidPointer(p, n, r)         ((int)1)
#define _CrtIsValidHeapPointer(p)           ((int)1)
#define _CrtIsMemoryBlock(p, t, r, f, l)    ((int)1)
#define _CrtReportBlockType(p)              ((int)-1)

#define _CrtSetDumpClient(f)                ((_CRT_DUMP_CLIENT)0)

#define _CrtMemCheckpoint(s)                ((void)0)
#define _CrtMemDifference(s1, s2, s3)       ((int)0)
#define _CrtMemDumpAllObjectsSince(s)       ((void)0)
#define _CrtMemDumpStatistics(s)            ((void)0)
#define _CrtDumpMemoryLeaks()               ((int)0)


#else   /* _DEBUG */


 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

#ifndef _INTERNAL_IFSTRIP_
#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP long * __cdecl __p__crtAssertBusy(void);
#endif
#endif  /* _INTERNAL_IFSTRIP_ */
_CRTIMP extern long _crtAssertBusy;

_CRTIMP _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
        _CRT_REPORT_HOOK
        );

_CRTIMP int __cdecl _CrtSetReportHook2(
        int,
        _CRT_REPORT_HOOK
        );

_CRTIMP int __cdecl _CrtSetReportMode(
        int,
        int
        );

_CRTIMP _HFILE __cdecl _CrtSetReportFile(
        int,
        _HFILE
        );

_CRTIMP int __cdecl _CrtDbgReport(
        int,
        const char *,
        int,
        const char *,
        const char *,
        ...);

/* Asserts */

#if     _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE) /*IFSTRIP=IGN*/
#define _ASSERT_BASE(expr, msg) \
        (void) ((expr) || \
                (1 != _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, msg)) || \
                (_CrtDbgBreak(), 0))
#else
#define _ASSERT_BASE(expr, msg) \
        do { if (!(expr) && \
                (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, msg))) \
             _CrtDbgBreak(); } while (0)
#endif

#define _ASSERT(expr)   _ASSERT_BASE((expr), NULL)

#define _ASSERTE(expr)  _ASSERT_BASE((expr), #expr)

/* Reports with no file/line info */

#if     _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE) /*IFSTRIP=IGN*/
#define _RPT_BASE(args) \
        (void) ((1 != _CrtDbgReport args) || \
                (_CrtDbgBreak(), 0))
#else
#define _RPT_BASE(args) \
        do { if ((1 == _CrtDbgReport args)) \
                _CrtDbgBreak(); } while (0)
#endif

#define _RPT0(rptno, msg) \
        _RPT_BASE((rptno, NULL, 0, NULL, "%s", msg))

#define _RPT1(rptno, msg, arg1) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1))

#define _RPT2(rptno, msg, arg1, arg2) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2))

#define _RPT3(rptno, msg, arg1, arg2, arg3) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3))

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3, arg4))


/* Reports with file/line info */

#define _RPTF0(rptno, msg) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, "%s", msg))

#define _RPTF1(rptno, msg, arg1) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1))

#define _RPTF2(rptno, msg, arg1, arg2) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2))

#define _RPTF3(rptno, msg, arg1, arg2, arg3) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3))

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3, arg4))

#if     _MSC_VER >= 1300 && !defined(_CRT_PORTABLE) /*IFSTRIP=IGN*/
#define _CrtDbgBreak() __debugbreak()
#elif   defined(_M_IX86) && !defined(_CRT_PORTABLE)
#define _CrtDbgBreak() __asm { int 3 }
#elif   defined(_M_ALPHA) && !defined(_CRT_PORTABLE)
void _BPT();
#pragma intrinsic(_BPT)
#define _CrtDbgBreak() _BPT()
#elif   defined(_M_IA64) && !defined(_CRT_PORTABLE)
void __break(int);
#pragma intrinsic (__break)
#define _CrtDbgBreak() __break(0x80016)
#else
_CRTIMP void __cdecl _CrtDbgBreak(
        void
        );
#endif

 /****************************************************************************
 *
 * Heap routines
 *
 ***************************************************************************/

#ifdef  _CRTDBG_MAP_ALLOC

#define   malloc(s)         _malloc_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   calloc(c, s)      _calloc_dbg(c, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   realloc(p, s)     _realloc_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _expand(p, s)     _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   free(p)           _free_dbg(p, _NORMAL_BLOCK)
#define   _msize(p)         _msize_dbg(p, _NORMAL_BLOCK)
#define   _aligned_malloc(s, a)                 _aligned_malloc_dbg(s, a, __FILE__, __LINE__)
#define   _aligned_realloc(p, s, a)             _aligned_realloc_dbg(p, s, a, __FILE__, __LINE__)
#define   _aligned_offset_malloc(s, a, o)       _aligned_offset_malloc_dbg(s, a, o, __FILE__, __LINE__)
#define   _aligned_offset_realloc(p, s, a, o)   _aligned_offset_realloc_dbg(p, s, a, o, __FILE__, __LINE__)
#define   _aligned_free(p)  _aligned_free_dbg(p)

#endif  /* _CRTDBG_MAP_ALLOC */

#ifndef _INTERNAL_IFSTRIP_
#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP long * __cdecl __p__crtBreakAlloc(void);
#endif
#endif  /* _INTERNAL_IFSTRIP_ */
_CRTIMP extern long _crtBreakAlloc;      /* Break on this allocation */

_CRTIMP long __cdecl _CrtSetBreakAlloc(
        long
        );

/*
 * Prototypes for malloc, free, realloc, etc are in malloc.h
 */

_CRTIMP void * __cdecl _malloc_dbg(
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _calloc_dbg(
        size_t,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _realloc_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _expand_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void __cdecl _free_dbg(
        void *,
        int
        );

_CRTIMP size_t __cdecl _msize_dbg (
        void *,
        int
        );

_CRTIMP void * __cdecl _aligned_malloc_dbg(
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_realloc_dbg(
        void *,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_offset_malloc_dbg(
        size_t,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_offset_realloc_dbg(
        void *,
        size_t,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void __cdecl _aligned_free_dbg(
        void *
        );


 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

_CRTIMP _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
        _CRT_ALLOC_HOOK
        );


 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bitfield flag that controls CRT heap behavior
 * Default setting is _CRTDBG_ALLOC_MEM_DF
 */

#ifndef _INTERNAL_IFSTRIP_
#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP int * __cdecl __p__crtDbgFlag(void);
#endif
#endif  /* _INTERNAL_IFSTRIP_ */
_CRTIMP extern int _crtDbgFlag;

_CRTIMP int __cdecl _CrtCheckMemory(
        void
        );

_CRTIMP int __cdecl _CrtSetDbgFlag(
        int
        );

_CRTIMP void __cdecl _CrtDoForAllClientObjects(
        void (*pfn)(void *, void *),
        void *
        );

_CRTIMP int __cdecl _CrtIsValidPointer(
        const void *,
        unsigned int,
        int
        );

_CRTIMP int __cdecl _CrtIsValidHeapPointer(
        const void *
        );

_CRTIMP int __cdecl _CrtIsMemoryBlock(
        const void *,
        unsigned int,
        long *,
        char **,
        int *
        );

_CRTIMP int __cdecl _CrtReportBlockType(
        const void *
        );


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

_CRTIMP _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
        _CRT_DUMP_CLIENT
        );

_CRTIMP void __cdecl _CrtMemCheckpoint(
        _CrtMemState *
        );

_CRTIMP int __cdecl _CrtMemDifference(
        _CrtMemState *,
        const _CrtMemState *,
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpAllObjectsSince(
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpStatistics(
        const _CrtMemState *
        );

_CRTIMP int __cdecl _CrtDumpMemoryLeaks(
        void
        );

#endif  /* _DEBUG */

#ifdef  __cplusplus
}

#ifndef _MFC_OVERRIDES_NEW

extern "C++" {

#pragma warning(disable: 4507)  /* Ignore faulty warning */

#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

 
void * __cdecl operator new[](size_t);

inline void * __cdecl operator new(size_t s, int, const char *, int)
        { return ::operator new(s); }

inline void* __cdecl operator new[](size_t s, int, const char *, int)
        { return ::operator new[](s); }

#if     _MSC_VER >= 1200 /*IFSTRIP=IGN*/


void __cdecl operator delete[](void *);

inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }
inline void __cdecl operator delete[](void * _P, int, const char *, int)
        { ::operator delete[](_P); }
#endif
#else /* _DEBUG */

 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/
 
void * __cdecl operator new[](size_t);

void * __cdecl operator new(
        size_t,
        int,
        const char *,
        int
        );

void * __cdecl operator new[](
        size_t,
        int,
        const char *,
        int
        );

#if     _MSC_VER >= 1200 /*IFSTRIP=IGN*/
void __cdecl operator delete[](void *);

inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }

inline void __cdecl operator delete[](void * _P, int, const char *, int)
        { ::operator delete[](_P); }
#endif

#ifdef _CRTDBG_MAP_ALLOC

inline void * __cdecl operator new(size_t s)
        { return ::operator new(s, _NORMAL_BLOCK, __FILE__, __LINE__); }

inline void* __cdecl operator new[](size_t s)
        { return ::operator new[](s, _NORMAL_BLOCK, __FILE__, __LINE__); }

#endif  /* _CRTDBG_MAP_ALLOC */

#endif  /* _DEBUG */

}

#endif  /* _MFC_OVERRIDES_NEW */

#endif  /* __cplusplus */

#endif  /* _INC_CRTDBG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\cmacros.inc ===
comment $

	SCCSID = "@(#)cmacros.mas:1.12"

cmacros - assembly macros for interfacing to hhls

Copyright (C) 1984-2001, Microsoft Corporation. All rights reserved.

$

;; Revision History
;;
;;	1.00	05/03/84	Initial Release
;;
;;	1.01	05/06/84	Greg Whitten
;;				Added defgrp and changed cMerge to Microsoft C
;;				Added copyright message and changed to 1.01
;;				Changes should have no affect on working programs
;;
;;	1.02	07/10/84	Steve Wood
;;				Added labelx macros
;;
;;	1.03	07/14/84	Greg Whitten
;;				Added defines for ?pu, ?adj, ?lblpu
;;				  (removes undefined errors)
;;				Changes should have no affect on working programs
;;
;;	1.04	07/18/84	Greg Whitten
;;				Added local control from PL/M or C conventions
;;				  except for cCall macro
;;
;;	1.05	08/06/84	Steve Wood
;;				Made ?PLM and ?WIN be the defaults
;;
;;	1.06	01/02/85	Steve Wood
;;				Changed createSeg and defgrp to automatically
;;				  define the ln_assumes macro and the lnoffset
;;				  and lnbase equates for each logical segment
;;				  name.
;;
;;	1.07	02/19/85	Walt Moore
;;				Added farptr macro for defining a far pointer
;;				to be used in a cCall.	Folded regptr into
;;				farptr.  Space compaction in macros.  Changed
;;				?pp to be smaller.  Moved ?ia out of ?al1 into
;;				?aloc.	Merged cProc and ?pd into one macro.
;;				Changed some %outs to use the error macro so
;;				an error would be generated.  Added makeframe
;;				and parmR to cProc.  Changed error to also put
;;                              the error message in the listing.
;;				Deleted the smashes macro.
;;
;;	1.08	03/18/85	Steve Wood
;;				Added NODATA support.
;;
;;	1.09	03/27/85	Steve Wood
;;				Added ?definitions
;;
;;	2.00	04/01/85	Steve Wood
;;				April fools
;;
;;	2.01	06/17/85	Steve Wood
;;				Changed NODATA to always generate POP DS
;;				  for return address patching
;;
;;	2.02	02/11/86	Steve Wood
;;				Added ATOMIC keyword to cProc macro
;;				Changed far epilog to use LEA SP,BP-2
;;				Changed error macro to ??error to avoid
;;				  conflict
;;
;;	2.03	03/06/86	Steve Wood
;;				Fixed bug with ATOMIC and locals in far proc
;;				Added DOS5 switch to disable INC/DEC BP
;;				  instructions in special far prologs/epilogs
;;
;;	2.04	08/07/86	Scott Randell
;;				Fixed bug with ATOMIC and ?TF
;;				  (was doing unnecessary MOV SP,BP)
;;				Added pcode profile ?PROFILE
;;
;;	2.05	08/12/86	Walt Moore
;;				Changed _TEXT alignment to word.
;;				Added/corrected some comments.
;;				Removed redundant init of ?pc in cProc
;;				Made ATOMIC require NODATA
;;				Moved definition of non-underscored 'C' label
;;				  from the cProc to the cBegin macro
;;				Minor clean-up of code
;;
;;	2.06	09/11/86	Walt Moore
;;				Added private stack checking
;;				Put local control for PL/M or C into cCall
;;
;;
;;	2.07	09/19/86	Steve Wood
;;				Added ?SMALL, ?MEDIUM, etc.  symbols
;;				Added forceframe keyword to cProc macro.
;;				Interpret ?TF for all epilogs.
;;
;;	3.xx.a	02/26/87	Walt Moore
;;				Massive rework.  Documentation coming.
;;
;;	3.xx.b	04/08/87	NeilK
;;				Added parmH, which is like parmW except
;;				that it reserves 4 bytes on frame.
;;
;;	3.xx.c	05/11/87	Walt Moore
;;				Added <> to ?ap so that arg <DataOFFSET foo>
;;				can be used.
;;
;;	3.01	07/03/87	Walt Moore
;;				parm_bytes_&procname is now generated for
;;				all cProcs, and is the number of bytes of
;;				parameters to the cProc.
;;
;;				NO_BP added as a keyword to cProc which
;;				causes all equates to be generated without
;;				reference to BP for the procedure.  All type
;;				info is still generated, but the user must
;;				supply any segment and base register.
;;				?NO_BP, if defined, makes this the default.
;;
;;				USE_BP can be specified on the cProc line
;;				to force the generation of BP in equates.
;;
;;				Moved definition of xxxxBASE.  The equ was to
;;				a forward reference.
;;
;;				Don't generate a warning for a nogen if only
;;				parameters are present.
;;
;;				Keywords for cProc, cBegin, cEnd, and registers
;;				are now allowed to be either all upper case or
;;				all lower case.
;;
;;				Only generate warnings on pass 2.
;;
;;	3.02	07/06/87	Walt Moore
;;				Boy did I screw up <nogen>  If the text is
;;				recognized as nogen, then process it as such,
;;				else ignore it and generate frame as needed.
;;
;;	3.03	07/14/87	Walt Moore
;;				Added <partial> keyword to the cBegin macro
;;				to only allocate locals and save registers.
;;				Used in conjunction with dispatching in the
;;				Winthorn engine and drivers.
;;
;;				Added cleanframe macro which will take the
;;				frame down, but not generate the RET statement.
;;				Used in conjunction with dispatching in the
;;				Winthorn engine and drivers.
;;
;;	3.04	07/16/87	Walt Moore
;;				globalD was generating off and seg name
;;				without word ptr override, giving them a
;;				dword attribute
;;
;;	3.05	07/17/87	Walt Moore
;;				.xcref cleanframe
;;
;;	3.06    07/24/87	Hans Spiller
;;				32 bit small model (?SMALL32):
;;				  new entry exit sequences using pseudoregs
;;				  mach independant register names (IAX, etc)
;;				  parmI/localI (int size variables)
;;				  mpush/mpop uses mach independant names
;;				  IPUSHF, IPOPF, IPUSHA,IPOPA,IIRET
;;				  
;;				case sensitivity bugfix. the compiler
;;				  generates "CODE", not "Code"
;;
;;				32 bit issues as yet undone:  allocation
;;			        macros for dealing with 32 bit mode far
;;				pointers, globalI, staticI, parmR, saving
;;				si,di vs. esi,edi,ebx
;;
;;	3.06a   09/29/87	Mark Roberts
;;				32 bit small model (?SMALL32):
;;				  fix a few bugs and add staticI
;;
;;	3.06b	07/20/87	Scott Randell
;;				Fix up for ?COW compatibility, added ?NOATOMIC
;;				to 3.xx version.
;;
;;	3.06c	04/29/88	Jim Schaad
;;				Put in ?DFDATA to force data segments even if
;;				?NODATA is set.
;;
;;	3.06d	05/02/88	Andy Padawer
;;				Bug fixes for 3.06b (cEnd), 3.06c (general).
;;
;;	3.06e	08/31/88	Andy Padawer
;;				use "if memS32" not "ifdef ?SMALL32".
;;
;;	3.06f   05/12/89	Mark Roberts
;;			  	fix staticI, globalDP and add globalI
;;
;;	3.06g   12/07/89	Mark Roberts
;;			  	add externI
;;
;;	3.06h	01/25/90	Jan de Rie
;;				add ?DFCODE to allow suppressing code segments
;;
;; Assembly macros for interfacing to C
;;
;;      User settable conditional assembly flags used within the cmacros
;;
;;	Memory model flags.  Set only one of the following.  memS is the
;;	default.  The symbols with ? are for defining from the command line
;;      and the memx symbols are numeric symbols that can be set in your source
;;      file prior to including this file.
;;
;;	    ?SMALL   memS - small model
;;	    ?MEDIUM  memM - medium model
;;	    ?LARGE   memL - large model
;;	    ?COMPACT memC - compact model
;;	    ?HUGE    memH - huge model
;;	    ?SMALL32 memS32 - 32 bit small model
;;
;;	?DF	Define flag.  If this flag is 0, then defines default segment
;;		and group definitions based on the compiler flag.  If this
;;              flag is 1, then does not define any segments or groups.
;;
;;	?DFDATA Define Data Flag.  If this flag is 0, then defines default
;;		data segment and group definitions based on compiler flag.
;;		If this flag is 1, then does not define any data segments
;;		or groups.
;;
;;	?DFCODE Define Code Flag.  If this flag is 0, then defines default
;;		code segments based on the compiler flag.  If this flag is 1,
;;		then does not define the code segments.  Inactive if
;;		?DF is 1.
;;
;;	?TF	Tight flag.  If this flag is 0, then use longer epilog
;;		sequence that safely cleans up a stack frame.  If this flag is
;;              1, then use more efficient epilog that assumes the stack is
;;		valid (SP)
;;
;;	?WIN	Windows flag.  Enables generation of special prolog/epilog
;;		for far procedures.  Default value is 1 (Windows).
;;
;;	?COW	Character Windows flag.  To be used in conjunction with ?WIN,
;;		If defined will not save DS for ?NODATA far prolog/epilog
;;		(CW does not modify the DS on the stack).
;;
;;	DOS5	If defined, then special far prolog/epilog seqeuences will not
;;		include the INC/DEC BP instructions.
;;
;;	?PLM	Calling convention flag.  If this flag is 0, then the
;;		calling convention used is that of C.  If this flag
;;		is 1, then the PL/M calling convention is used.
;;		The default value is 1.  The PL/M calling convention
;;		is used by pascal, fortran, basic, and cobol.
;;
;;		In the C calling convention, arguments are passed
;;              in reverse order; arg0 is the last pushed, argn is the
;;              first pushed.  also, it is the callers responsibility
;;              to remove the arguments from the stack upon a return
;;              from a call.
;;
;;		In the PL/M calling comvention, arguments are passed
;;              as encountered; arg0 is the first pushed, argn is the
;;              last pushed.  also, it is the called procedure's
;;              responsibility to remove parameters from the stack
;;		before returning (using the RET n instruction)
;;
;;	?NODATA If defined, then no data segment or DGROUP is defined and
;;              the special prolog/epilog sequences will not contain the
;;		code needed to setup DS.
;;
;;	?CHKSTK If defined, then prolog sequences for cProcs with local
;;		parameters will call the CHKSTK procedure to allocate
;;              the stack space.
;;
;;	?CHKSTKPROC	If defined, then this macro will be invoked to
;;                      perform the stack checking, otherwise the
;;                      standard stack checking procedure will be
;;			performed.  ?CHKSTKPROC must be declared
;;                      before the cmacros are included in the source
;;			else the standard chkstk routine will be declared
;;                      as an external symbol.
;;
;;			On entry to the user's stack checking procedure,
;;                      the frame has been setup except for allocating
;;                      local variable space and saving autosave registers.
;;
;;			The user supplied macro is passed as an argument
;;                      the number of byte of stack space requested.
;;
;;	?PROFILE  If defined then all far cBegin entries will have StartNMeas,
;;		  and all cEnd will have StopNMeas calls, StartNMeas and
;;		  StopNMeas will be defined as externfp
;;
;;	?NOPARMR  If defined, then the "parmR"	 macro	will not be defined.
;;
;;	?NOGLOBAL If defined, then the "globalx" macros will not be defined.
;;
;;	?NOSTATIC If defined, then the "staticx" macros will not be defined.
;;
;;	?NOEXTERN If defined, then the "externx" macros will not be defined.
;;
;;	?NOLABEL  If defined, then the "labelx"  macros will not be defined.
;;
;;	?NODEF	  If defined, then the "defx"	 macros will not be defined.
;;
;;	?NOPTR	  If defined, then "farptr & regptr"	will not be defined.
;;
;;	?QUIET	  If defined, then only error messages will be issued to
;;		  the console.	If undefined, then certain cmacro text will
;;		  be generated to the console.
;;
;;	?NOATOMIC If defined, then ATOMIC will be ignored (for giving real
;;		  frames to all procedures (and profiling).
;;
;;	?NO_BP	  If defined, then equates generated for parms and locals
;;		  will not explicitly reference BP.
;;	IAX, ICX, IDX, IBX, ISP, IBP, ISI, IDI
;;		  these pseudo registers expand to either ax..., or eax...
;;		  depending upon 32bit mode being enabled.  they should be
;;		  used whenever a pointer or integer is being used in order
;;		  to make source code machine independant



.xcref					;;Get rid of a lot of symbols


;	??_out	- output given message to the console unless ?QUIET has
;	been specified.
;
;	usage:
;		??_out	<t>
;
;	where:
;		<t> is the message to output

.xcref	??_out
??_out macro t
  ifndef ?QUIET
    %out t
  endif
endm



;	outif - output msg if name is non-zero.  if name is undefined,
;	set name = 0, else set name to the default value.
;
;	usage:
;		outif	name,defval,onmsg,offmsg
;	where:
;		name	name of symbol
;		defval	default value to give symbol if not defined
;			if blank, then 0 will be used
;		onmsg	text to display if symbol is non-zero
;		offmsg	test to be displayed if symbol is zero


outif macro name,defval,onmsg,offmsg
  ifndef name
    ifb <defval>
      name=0
    else
      name=defval
    endif
  endif
  if name
    name=1
    ifnb <onmsg>
      ??_out <! onmsg>
    endif
  else
    ifnb <offmsg>
      ??_out <! offmsg>
    endif
  endif
endm



;	??error - output msg and generate an assembly time error
;		  on regardess of assembler pass
;	usage:
;		??error <t>
;	where:
;		t	is the text to be output


.xcref	??error
??error macro	msg
  %out e r r o r ----- msg		;;to console
  .err e r r o r ----- msg		;;forced error by assembler
endm


;	??error2 - output msg and generate an assembly time error
;		   on pass 2 only
;	usage:
;		??error2 <t>
;	where:
;		t	is the text to be output


.xcref	??error2
??error2 macro	 msg
  if2
  %out e r r o r ----- msg		;;to console
  .err e r r o r ----- msg		;;forced error by assembler
  endif
endm


.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized,memS32,sizeI,wordI

;if1					;;Only on pass 1
  ASMpass=1
  ifdef ?SMALL				;;inform user what is going on
    memS=1
  endif
  ifdef ?MEDIUM
    memM=1
  endif
  ifdef ?COMPACT
    memC=1
  endif
  ifdef ?LARGE
    memL=1
  endif
  ifdef ?HUGE
    memH=1
  endif
  ifdef ?SMALL32
    memS32=1
  endif
  ifdef ?FLAT32
    memF32=1
  endif

  ??_out  <cMacros Version 3.06h - 01/25/90>
  ??_out  <Copyright (C) 1984-2001 Microsoft Corporation. All rights reserved.>
  outif   memS,0,<Small Model>
  outif   memM,0,<Medium model>
  outif   memL,0,<Large Model>
  outif   memC,0,<Compact Model>
  outif   memH,0,<Huge Model>
  outif	  memS32,0,<32 Bit Small Model>
  outif   memF32,0,<32 Bit Flat Model>

  memMOD= memS + memM + memL + memC + memH + memS32
  if memMOD ne 1
    if memMOD eq 0
      memS = 1				; assume small model
      outif   memS,0,<Small model>
    else
      ??error	<must have only 1 memory model selected>
    endif
  endif

  sizec=  memM + memL + memH		; large code
  sized=  memL + memC + (memH*2)	; large data (2 if huge)
  ;; note that memS32 is used generaly to indicate 32 bitness.  I
  ;; doubt very much whether anyone will ever do other models in
  ;; 32 bit code...
  if memS32
    sizeI = 4				; size of a push
    wordI equ <dword>
    asmdI equ <dd>
  else
    sizeI = 2
    wordI equ <word>
    asmdI equ <dw>
  endif

  outif ?DF,0,<No segments or groups will be defined>
  outif ?DFDATA,0,<No data segments will be defined>
  outif ?DFCODE,0,<No code segments will be defined>
  outif ?TF,0,<Epilog sequences assume valid SP>
  outif ?WIN,1,<Windows support>
  outif	?COW,0,<Characters Windows support>
  outif ?PLM,1,<PL/M calling convention>
  outif	?NOATOMIC,0,<ATOMIC disabled>
  outif ?NODATA,0,<NODATA module>

  ife ?NODATA
    ?nodata1=0
  else
    ?nodata1=1
  endif

  ifndef ?CHKSTK
    ?chkstk1=0
  else
    ?chkstk1=1
    ifdef ?CHKSTKPROC
      ??_out <! Private stack checking enabled>
    else
      ??_out <! Stack checking enabled>
    endif
  endif

  ifndef DOS5
    ?DOS5=0
  else
    ?DOS5=1
    ??_out <! DOS5 module>
  endif

  ifdef ?PROFILE
    ??_out <! Native profiling enabled>
  endif

  ifndef ?NO_BP
    ?no_bp1=0
  else
    ?no_bp1=1
    ??_out <! NO_BP is default>
  endif
;else
  ASMpass=2
;endif

;; define pseudo registers and instructions for 386/8086 independance
if memS32
  .386
  IAX equ <eax>
  ICX equ <ecx>
  IDX equ <edx>
  IBX equ <ebx>
  ISP equ <esp>
  IBP equ <ebp>
  ISI equ <esi>
  IDI equ <edi>
  IPUSHF equ pushfd
  IPOPF equ popfd
  IPUSHA equ pushad
  IPOPA equ popad
  IIRET equ iretd
else
  IAX equ <ax>
  ICX equ <cx>
  IDX equ <dx>
  IBX equ <bx>
  ISP equ <sp>
  IBP equ <bp>
  ISI equ <si>
  IDI equ <di>
  IPUSHF equ pushf
  IPOPF equ popf
;  IPUSHA equ pusha
;  IPOPA equ popa
  IIRET equ iret
endif

;;	Initialize all symbols used in the macros.  Theses symbols will not be
;;      included in any cross reference listing.

	.xcref	?n,?ax,?ah,?al,?bx,?bh
	.xcref	?bl,?cx,?ch,?cl,?dx,?dh
	.xcref	?dl,?si,?di,?es,?ds,?bp
	.xcref	?sp,?ss,?cs
	.xcref	?n,?AX,?AH,?AL,?BX,?BH
	.xcref	?BL,?CX,?CH,?CL,?DX,?DH
	.xcref	?DL,?SI,?DI,?ES,?DS,?BP
	.xcref	?SP,?SS,?CS
	.xcref  ?EAX,?EBX,?ECX,?EDX,?ESI,?EDI,?ESP,?EBP
	.xcref  ?eax,?ebx,?ecx,?edx,?esi,?edi,?esp,?ebp
	.xcref  ?IAX,?IBX,?ICX,?IDX,?ISI,?IDI,?ISP,?IBP

	.xcref	?rsl,?cpd,?argl,?argc,?ba
	.xcref	?acb,???,?po
	.xcref	?pas,?pc

	.xcref	uconcat,mpush,mpop
	.xcref	?ri,?pp,?pp1,?al1
	.xcref	?ad,?ap,?atal,?dd,?dd1,?dd2
	.xcref	?pg,?pg1,?aloc,?cs1,?cs2
	.xcref	?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
	.xcref	?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5
	.xcref	?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
	.xcref	defgrp,addseg,createSeg
	.xcref	save,outif,errnz,errn$,errnz1
	.xcref	?PLMPrevParm,?gcc
	.xcref	?cCall1,?pcc,?no_bp1,?no_bp2
	.xcref	?cbe,?pcbe



;;      conditionals set by the macros
;;
;;	?pc	Procedure class.  If this is set to 1, then the procedure
;;              is a far procedure, else it is a near procedure.
;;
;;	?ia	Interface adjustment count for far procedures.	The
;;              interface adjustment defines the number of bytes of
;;		storage allocated between BP and the first frame variable
;;              allocated on the stack.
;;
;;		Normally zero, it will be adjusted for both far windows
;;              procedures and by register parameters.
;;
;;	?cpd	Current procedure defined.  This is set to a non-zero
;;		value if a procedure is being defined (i.e a cProc has
;;		been encountered, and cBegin has not).
;;
;;	?ba	Begin active.  This is set to a non-zero value if a
;;		cBegin is active (i.e. a cBegin has been encountered,
;;		and cEnd has not).
;;
;;	?wfp	Windows far procedure.	Set if a windows far procedure
;;
;;	?pcc	procedure calling conventing.  Calling convention for
;;		this procedure.  May be different than the default set
;;		via ?PLM
;;
;;
;;	Other variables that are defined once so that the .xcref command
;;      doesn't get too upset if they show up missing!

?rsl    =       0                       ;;0 = no register to save
?cpd    =       0                       ;;<> 0 if in a procedure definition
?argl   =       0                       ;;length of arguments pushed on stack
?argc   =       0                       ;;# of arguments so far
?ba     =       0                       ;;<>0 if in a procedure (xbegin)
?acb    =       0                       ;;number of arguments to a call
???     =       0                       ;;byte count of local storage
?po     =       0                       ;;byte count of parameters
?pas    =       0                       ;;autosave value for procedure
?pc     =       0                       ;;class of a procedure (near/far)
?ia     =       0                       ;;no adjustment
?pu     =       0                       ;;public flag for some macros
?adj    =       0                       ;;initial define for .xcref
?rp     =       0                       ;;count of register parameters
?uf     =       0                       ;;user's frame code specified
?nd	=	0			;;NODATA keyword specified
?nx	=	0			;;ATOMIC keyword specified
?wfp    =       0                       ;;window far procedure
?ff     =       0                       ;;forceframe keyword specified
?dd2	=	0			;;used for globalx and staticx
?cCall1 =	0			;;used for cCalls
?pcc	=	?PLM			;;procedure calling convention
?PLMPrevParm =	0			;;Used in parameter processing
?no_bp2 =	?no_bp1 		;;BP / No BP flag
?cbe	=	0			;;cbegin/cEnd keyword flag

	.xcref	?casen
if1					;;only define ?casen on pass 1
?casen	=	0			;;case sensitive assembly if <> 0
endif



?n      =       0000000000000000b       ;;register none
?ax	=	0000000000000011b	;;register ax
?ah	=	0000000000000001b	;;register ah
?al	=	0000000000000010b	;;register al
?bx	=	0000000000001100b	;;register bx
?bh	=	0000000000000100b	;;register bh
?bl	=	0000000000001000b	;;register bl
?cx	=	0000000000110000b	;;register cx
?ch	=	0000000000010000b	;;register ch
?cl	=	0000000000100000b	;;register cl
?dx	=	0000000011000000b	;;register dx
?dh	=	0000000001000000b	;;register dh
?dl	=	0000000010000000b	;;register dl
?si	=	0000000100000000b	;;register si
?di	=	0000001000000000b	;;register di
?es	=	0000010000000000b	;;register es
?ds	=	0000100000000000b	;;register ds
?bp	=	0001000000000000b	;;register bp
?sp	=	0010000000000000b	;;register sp
?ss	=	0100000000000000b	;;register ss
?cs	=	1000000000000000b	;;register cs
					;;Incase we're case sensitive
?AX	=	0000000000000011b	;;register ax
?AH	=	0000000000000001b	;;register ah
?AL	=	0000000000000010b	;;register al
?BX	=	0000000000001100b	;;register bx
?BH	=	0000000000000100b	;;register bh
?BL	=	0000000000001000b	;;register bl
?CX	=	0000000000110000b	;;register cx
?CH	=	0000000000010000b	;;register ch
?CL	=	0000000000100000b	;;register cl
?DX	=	0000000011000000b	;;register dx
?DH	=	0000000001000000b	;;register dh
?DL	=	0000000010000000b	;;register dl
?SI	=	0000000100000000b	;;register si
?DI	=	0000001000000000b	;;register di
?ES	=	0000010000000000b	;;register es
?DS	=	0000100000000000b	;;register ds
?BP	=	0001000000000000b	;;register bp
?SP	=	0010000000000000b	;;register sp
?SS	=	0100000000000000b	;;register ss
?CS	=	1000000000000000b	;;register cs

?EAX	=	0000000000000011b	;;register ax
?EBX	=	0000000000001100b	;;register bx
?ECX	=	0000000000110000b	;;register cx
?EDX	=	0000000011000000b	;;register dx
?ESI	=	0000000100000000b	;;register si
?EDI	=	0000001000000000b	;;register di
?EBP	=	0001000000000000b	;;register bp
?ESP	=	0010000000000000b	;;register sp

?eax	=	0000000000000011b	;;register ax
?ebx	=	0000000000001100b	;;register bx
?ecx	=	0000000000110000b	;;register cx
?edx	=	0000000011000000b	;;register dx
?esi	=	0000000100000000b	;;register si
?edi	=	0000001000000000b	;;register di
?ebp	=	0001000000000000b	;;register bp
?esp	=	0010000000000000b	;;register sp

?IAX	=	0000000000000011b	;;register ax
?IBX	=	0000000000001100b	;;register bx
?ICX	=	0000000000110000b	;;register cx
?IDX	=	0000000011000000b	;;register dx
?ISI	=	0000000100000000b	;;register si
?IDI	=	0000001000000000b	;;register di
?IBP	=	0001000000000000b	;;register bp
?ISP	=	0010000000000000b	;;register sp

        .cref



;;      uconcat - unconditionally generate a statement from a field
;;      of given parameters
;;
;;      usage:
;;		uconcat  a,b,c,d,e,f,g
;;
;;      where:
;;              a,b   are concatenated for field 1
;;              c,d   are concatenated for field 2
;;		e,f,g are concatenated for field 3

uconcat macro a,b,c,d,e,f,g
  a&b c&d e&f&g
endm



;;      mpush pushes multiple registers onto the stack according to
;;      a register specification.
;;
;;      format:
;;              mpush   r
;;
;;      where:
;;              r       is a numeric expression returned from ?ri
;;                      or any other valid register expression

mpush macro r
  irp x,<IAX,IBX,ICX,IDX,ISI,IDI,es,ds,IBP,ISP,ss,cs>
    if (r and ?&&x)
      push x								      ;@
    endif
  endm
endm



;;      mpop pops multiple registers from the stack according to
;;      a register specification.
;;
;;      format:
;;              mpop    r
;;
;;      where:
;;              r       is a numeric expression returned from ?ri
;;                      or any other valid register expression

mpop macro r
  irp x,<cs,ss,ISP,IBP,ds,es,IDI,ISI,IDX,ICX,IBX,IAX>
    if (r and ?&&x)
      pop x								      ;@
    endif
  endm
endm


;;      save - flag that the indicated registers are to be saved/restored
;;
;;	A flag is created which indicates which registers are to be saved
;;	when the cCall macro is invoked, and then restored after the call.
;;
;;      usage:
;;              save    <r>
;;
;;      where  r  is the list of registers to save, which may be:
;;
;;		register     saves
;;		   AX	      AX
;;		   AH	      AX
;;		   AL	      AX
;;		   BX	      BX
;;		   BH	      BX
;;		   BL	      BX
;;		   CX	      CX
;;		   CH	      CX
;;		   CL	      CX
;;		   DX	      DX
;;		   DH	      DX
;;		   DL	      DX
;;		   SI	      SI
;;		   DI	      DI
;;		   ES	      ES
;;		   DS	      DS
;;		   BP	      BP
;;
;;		  none	    nothing
;;
;;      the macro generates a value for the variable ?rsl

save macro r
  ?rsl=0				;;initialize save list
  ?ri ?rsl,<r>				;;generate magic number
endm



;;      ?ri - or register indexes to variable
;;
;;      ?ri is a macro that examines the passed argument list and computes
;;      a register index variable.
;;
;;	The values ORed with the variable are:
;;
;;              ?n       equ     0000000000000000b;
;;		?AX	 equ	 0000000000000011b;
;;		?AH	 equ	 0000000000000001b;
;;		?AL	 equ	 0000000000000010b;
;;		?BX	 equ	 0000000000001100b;
;;		?BH	 equ	 0000000000000100b;
;;		?BL	 equ	 0000000000001000b;
;;		?CX	 equ	 0000000000110000b;
;;		?CH	 equ	 0000000000010000b;
;;		?CL	 equ	 0000000000100000b;
;;		?DX	 equ	 0000000011000000b;
;;		?DH	 equ	 0000000001000000b;
;;		?DL	 equ	 0000000010000000b;
;;		?SI	 equ	 0000000100000000b;
;;		?DI	 equ	 0000001000000000b;
;;		?ES	 equ	 0000010000000000b;
;;		?DS	 equ	 0000100000000000b;
;;		?BP	 equ	 0001000000000000b;
;;		?SP	 equ	 0010000000000000b;
;;		?SS	 equ	 0100000000000000b;
;;		?CS	 equ	 1000000000000000b;
;;      usage:
;;		?ri n,<rl>
;s mach independant names;      where:
;;              n       is the variable to contain the new index value
;;		r	is the register list

?ri macro n,r
  irp x,<r>
    ifdef ?&&x				;;if defined, then add to list
      n=n or ?&&x
    else
      ??error2 <unknown register x>
      .err
    endif
  endm
endm



;;      parmx - generate reference to parameter(s) on the stack
;;
;;	An equate is generated for addressing a paramter(s)
;;      on the stack for the current procedural frame.
;;
;;	An error message is generated if there isn't a current frame.
;;
;;      usage:
;;              parmX   n
;;      where:
;;              X       is the type of the argument(s)  B=byte, W=word, D=dword
;;			I = machine independant int size
;;              n       is the name(s) to be given the parameter(s).
;;
;;	Bytes are considered to be two bytes long for alignment.
;;
;;	The parmd form of the macro generates three equates:
;;
;;              name       -    for accessing the parameter as a double word
;;              off_name   -    for accessing the offset  (lsw) of the parameter
;;              seg_name   -    for accessing the segment (msw) of the parameter

.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP,parmH,parmI
.cref

parmB macro n
  ?pp <n>,<byte>,sizeI,1
endm

parmW macro n
  ?pp <n>,<word>,sizeI,2
endm

parmI macro n
  ?pp <n>,wordI,sizeI,sizeI
endm

parmD macro n
  ife ?pcc				;;if to assemble for C
    irp x,<n>
      ?pp <&&x>,<dword>,0,4
      ?pp <off_&&x>,<word>,2,2
      ?pp <seg_&&x>,<word>,2,2
    endm
  else					;;if to assemble for PL/M
    irp x,<n>
      ?pp <seg_&&x>,<word>,2,2
      ?pp <off_&&x>,<word>,2,2
      ?pp <&&x>,<dword>,0,4
    endm
  endif
endm

parmH macro n
  ?pp <n>,<word>,4,2
endm

parmQ macro n
  ?pp <n>,<qword>,8,8
endm

parmT macro n
  ?pp <n>,<tbyte>,10,10
endm

if sizec
  parmCP macro n
    parmD <n>
  endm
else
  parmCP macro n
    parmW <n>
  endm
endif

if sized
  parmDP macro n
    parmD <n>
  endm
else
  parmDP macro n
    parmI <n>
  endm
endif



;;      ?pp is the generalized parameter definition macro
;;
;;      usage:
;;              ?pp m,t,l,s
;;
;;      where:
;;              n       is the name(s) of the parameters
;;              t       is the type (word, dword)
;;              l       is the length to update parameter byte count by
;;              s       is the internal typing size


?pp macro n,t,l,s			;;process parameter
  if ?cpd				;;must be in a procedure definition
    .xcref
    irp x,<n>
      .xcref ?t&&x			;;don't want this in xref
      ?t&&x=s				;;save size info
      ife ?pcc				;;if C calling convention
	?pp1 x,<t>,,,%(?po+?adj)
	?po=?po+l			;;update parameter offset
      else				;;else assemble for PL/M
	?PLMPrevParm=?PLMPrevParm+1	;;Show next parameter
	?po=?po+l			;;update parameter offset
	?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
      endif
    endm
    .cref
  else
    ??error2 <parm(s) "&n" declared outside proc def>
  endif
endm



;;	?pp1 is the macro that generates the text equate for the
;;	parameter.  Two options exist, one for the C calling
;;      convention where the last parameter was the first pushed onto
;;	the stack ('C' convention), and one for the PL/M calling
;;      convention where the first parameter was the first
;;      pushed (also the same as ms-pascal).
;;
;;	The text generated will be of one of two forms:
;;
;;		name equ (type ptr [bp+(adj+offset)]) for C
;;           or
;;		name equ (type ptr [bp+adj+?po-offset]) for PL/M
;;
;;
;;	For C, since parameters are pushed first last, the offset
;;      plus the adjust will point to the correct parameter.
;;
;;	For PL/M, since parameters are pushed first first, the offset
;;	of a parameter is much more complicated.  A known portion of
;;      the offset can be computed when the text equate is generated.
;;
;;	What is known is the number of garbage bytes between BP and
;;      the nearest parameter (in this case the last parameter), and
;;      also how many bytes of parameters have preceeded this parameter.
;;
;;	What is unknown is how many total bytes of parameters there will
;;      be, which affects all the generated text equates since the offset
;;      from bp must be determined at some point.
;;
;;	Well, the offset from BP can be computed with one variable if
;;      the following is remembered:
;;
;;          the offset of any parameter from the first parameter is always
;;          the current parameter offset (?po).
;;
;;	With this in mind, you just have to figure out where the first
;;      parameter is, which is:
;;
;;              bp + garbage adjustment + distance to first parameter
;;         or
;;              bp + ?adj + ?po
;;
;;	This implies that any parameter can be defined as:
;;
;;              bp + ?adj + ?po -%?po
;;
;;	Make any sense?
;;
;;	For PL/M, a chain of self-purging macros will be generated
;;	which will pass the evaluated ?po to any previous incarnation
;;	of the macro.  This will allow the text equate to be generated
;;	with the actual offset instead of the symbolic ?po.
;;
;;
;;      usage:
;;		?pp1	n,t,o,a,b,cpc,ppc
;;
;;      where:
;;              n    is the name to be given the equate
;;              t    is the type (byte, word, dword)
;;              o    is the offset from the first parameter
;;              a    is the adjustment
;;              b    is the adjustment plus the offset from the first parameter
;;		cpc  is the number of parameters so far
;;		ppc  is cpc - 1


?pp1 macro n,t,o,a,b,cpc,ppc
  ife ?pcc				;;if to generate for C
    if ?no_bp2
      n equ (t ptr [+b])
    else
      n equ (t ptr [IBP][+b])
    endif
  else					;;else generate for PL/M
    .xcref
    .xcref ?PLMParm&cpc
    .cref
    if ?no_bp2
      ?PLMParm&cpc &macro po
	uconcat <n>,,<equ>,,<(t ptr [+>,%(a+po-o),<])>
	?PLMParm&ppc po
	purge ?PLMParm&cpc
      &endm
    else
      ?PLMParm&cpc &macro po
	uconcat <n>,,<equ>,,<(t ptr [IBP][+>,%(a+po-o),<])>
	?PLMParm&ppc po
	purge ?PLMParm&cpc
      &endm
    endif
  endif
endm



;;	parmR - register parameter
;;
;;	parmR is the macro used for generating register parameters.
;;	The space allocated for the register parameters will be
;;      the ?ia (interface adjust) area which is between the  old
;;	BP and the first parameter.  Normally this is empty (?ia=0),
;;      or has the saved ds for a windows far procedure.
;;
;;	Byte and dword register parameters will be allowed.
;;
;;      usage:
;;		parmR	n,r,r2
;;      where:
;;              n       is the name of the parameter
;;              r       is the register it is in
;;              r2      is the offset register if a dword


ifndef ?NOPARMR
  .xcref
  .xcref ?pr,parmR
  .cref

  parmR macro n,r,r2
    ?pr n,r,r2,%?rp,%(?ia+2)
  endm

  ;;	?pr - register parameter
  ;;
  ;;	?pr is the actual macro for generating the equates for
  ;;	register parameters.
  ;;
  ;;	usage:
  ;;		parmR	n,r,r2,i,o
  ;;	where:
  ;;		n	is the name of the parameter
  ;;		r	is the register it is in
  ;;		r2	is the offset register if a dword
  ;;		i	is the index of the ?rp to generate
  ;;		o	is the offset from bp where the parm will be

  ?pr macro n,r,r2,i,o
    .xcref
    ifnb <r2>				;;if a dword parameter
      parmR seg_&n,r			;;define segment equate
      parmR off_&n,r2			;;define offset  equate
      if ?no_bp2
	n equ (dword ptr [-o-2])	;;define dword equate
      else
	n equ (dword ptr [bp][-o-2])	;;define dword equate
      endif
      .xcref ?t&n
      ?t&n=4				;;show a dword to cmacros
    else
      .xcref ?rp&i
      ?rp&i=0				;;show no register(s)
      ifdef ?&r 			;;define register if valid
	?rp&i=?&r
      endif

      if ??? or (?cpd eq 0) or (?rp&i eq 0)
	??error2 <invalid parmR encountered: &n,&r>
	exitm
      endif

      if ?no_bp2
	n equ (word ptr [-o])		;;assume a word register
      else
	n equ (word ptr [bp][-o])	;;assume a word register
      endif
      .xcref ?t&n
      ?t&n=2				;;show a word to cmacros
      irp x,<bh,ch,dh,bl,cl,dl,ah,al>
	if ?&&x eq ?&r			;;if really a byte register
	  if ?no_bp2
	    n equ (byte ptr [-o])	;;  then make it a byte
	  else
	    n equ (byte ptr [bp][-o])	;;  then make it a byte
	  endif
	  ?t&n=1			;;show a byte to cmacros
	  exitm
	endif
      endm
      ?ia=?ia+2 			;;show this guy is out there
      ?rp=?rp+1 			;;show one more register parameter
    endif
    .cref
  endm
endif



;;      localx - generate reference to a local variable on the stack
;;
;;	An equate is generated for addressing a local variable
;;      on the stack for the current procedural frame.
;;
;;      usage:
;;              localx    n
;;      where:
;;              x       is the type b=byte, w=word, d=dword, v=variable size
;;              n       is the name(s) to be given the variable(s).
;;
;;	Bytes are considered to be two bytes long for alignment reasons
;;
;;	The locald form of the macro generates three equates:
;;
;;              name       -    for accessing the variable as a double word
;;              off_name   -    for accessing the offset  (lsw) of the variable
;;              seg_name   -    for accessing the segment (msw) of the variable


.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV,localI
.cref

localB macro n
  ?aloc <n>,<byte ptr>,1,1,0		;; no alignment
endm

localW macro n
  ?aloc <n>,<word ptr>,2,2,1		;; word aligned
endm

localI macro n
  ?aloc <n>,&wordI&< ptr>,sizeI,sizeI,1	;; dword aligned
endm

localD macro n
  irp x,<n>
    ?aloc <seg_&&x>,<word ptr>,2,2,1	;; word aligned
    ?aloc <off_&&x>,<word ptr>,2,2,1	;; word aligned
    ?aloc <&&x>,<dword ptr>,0,4,1	;; word aligned
  endm
endm

localQ macro n
  ?aloc <n>,<qword ptr>,8,8,1		;; word aligned
endm

localT macro n
  ?aloc <n>,<tbyte ptr>,10,10,1 	;; word aligned
endm

if sizec
  localCP macro n
    localD <n>
  endm
else
  localCP macro n
    localW <n>
  endm
endif

if sized
  localDP macro n
    localD <n>
  endm
else
  localDP macro n
    localI <n>
  endm
endif

localV macro n,a
  ?aloc <n>,,%(a),0,1			;; word aligned
endm


;;      ?aloc is the macro that actually allocates local storage.
;;      it is only invoked by the localx macros.
;;
;;      usage:
;;              ?aloc  n,t,l,s,a
;;      where:
;;              n      is a list of names of local variable of the
;;                      given type.
;;              t       is the text string for the given variable
;;                      and is one of:
;;                          word  ptr
;;                          dword ptr
;;                          byte  ptr
;;                      or alternatively left blank for variable size
;;                      allocations (no implicit type).
;;              l       is the size of the variable in bytes
;;              s       is the internal type flag (size), and is one of:
;;                              word     - 2
;;                              dword    - 4
;;                              byte     - 1
;;                              variable - 0
;;              a       is a flag indicating that word alignment is to be
;;                      forced for this type of item.
;;
;;	NOTE:	It is assumed that the stack is already aligned on a word
;;		boundary when the cProc is invoked.  The macros will guarantee
;;		to allocate an even number of bytes on the stack to maintain
;;              word alignment.


?aloc macro n,t,l,s,a
  if ?cpd				;;must be in a proc def
    .xcref
    irp x,<n>				;;generate symbol equates
      ???=???+l 			;;update length of locals
      if a				;;if align, then force word alignment
	if memS32 and l GT 2
	  ???=((??? + 3) and 0fffffffch) ;; dword alignment
	else
	  ???=((??? + 1) and 0fffeh)
	endif
      endif
      ?al1 x,<t>,%(???+?ia)		;;?ia will always be valid (0 or 2)
      .xcref ?t&&x
      ?t&&x=s				;;save size info
    endm
    .cref
  else
    ??error2 <locals "&n" declared outside procedure def>
  endif
endm



;;      ?al1 - allocate local, continued.
;;
;;      ?al1 actually generates the text equate for the local variable.
;;	The form of the text equate generated is more or less:
;;
;;		name equ (type ptr [bp-?ia-nn])
;;          or
;;		name equ ([bp-?ia-nn])
;;
;;      where:
;;              ?ia   is defined to be either zero, or is defined to be
;;		      the number of bytes between the saved BP and the first
;;		      local.  ?ia is only applicable if the current cProc is
;;		      a windows far procedure or if parmRs have been
;;		      encountered.  If not, the ?ia will be zero.  since ?ia
;;		      is determinable prior to invoking this macro, it will be
;;		      added into the  offset ("nn") passed to this macro
;;
;;      usage:
;;              ?al1 n,t,o
;;      where:
;;              n    is the name for the text equate
;;              t    is the type of the equate
;;              o    is the offset of the equate


?al1 macro n,t,o
  if ?no_bp2
    n equ (t [-o])
  else
    n equ (t [IBP][-o])
  endif
endm


;;	?gcc - get calling convention
;;
;;	?gcv sets the given symbol to the calling convention
;;	to be used.
;;
;;	usage:
;;		?gcc s,i,cc
;;
;;	where:
;;		s  is the symbol to return the convention in
;;		   s = 0 if 'C' calling convention
;;		   s = 1 if PL/M (PASCAL) calling convention
;;		i  is the initial value for s
;;		cc is the calling convention override, and may be one of
;;		   C	  use 'C' convention
;;		   PLM	  use PL/M calling convention
;;		   PASCAL use PL/M calling convention

?gcc macro s,i,cc
  s = i 				;;Set default calling convention
  ifnb <cc>
    ifidn <cc>,<C>			;;If overriding default
      s=0				;;  'C' calling convention
    endif
    ifidn <cc>,<PLM>
      s=1				;;  PL/M calling convention
    endif
    ifidn <cc>,<PASCAL>
      s=1				;;  PL/M calling convention
    endif
  endif
endm



ifndef ?NOGLOBAL
  .xcref
  .xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP,globalI
  .cref

  ;;	globalx - define global data of type x
  ;;
  ;;	usage:
  ;;		globalx n,i,s,c
  ;;	where:
  ;;		x	is the type of the variable  b=byte, w=word, d=dword
  ;;			q=quad word, t=tenbytes, cp=code pointer, dp=data pointer
  ;;		n	is the name to be given the variable.
  ;;		i	is the initial value of the variable.
  ;;		s	is the duplication factor
  ;;		c	is the convention, C for C, PLM or PASCAL for PL/M.
  ;;			The default (?PLM flag) will be used if not specified.
  ;;
  ;;	The D form will generate two extra equates of the form off_n and seg_n.

  globalB macro n,i,s,c
    ?ad <n>,1
    ?dd n,1,<byte>,<db>,<i>,<s>,<c>
  endm

  globalW macro n,i,s,c
    ?ad <n>,2
    ?dd n,1,<word>,<dw>,<i>,<s>,<c>
  endm

  globalI macro n,i,s,c
    ?ad <n>,2
    ?dd n,1,wordI,%asmdI,<i>,<s>,<c>
  endm

  globalD macro n,i,s,c
    ?ad <n>,4
    ?dd n,1,<dword>,<dd>,<i>,<s>,<c>
    off_&n equ word ptr n[0]
    seg_&n equ word ptr n[2]
  endm

  globalQ macro n,i,s,c
    ?ad <n>,8
    ?dd n,1,<qword>,<dq>,<i>,<s>,<c>
  endm

  globalT macro n,i,s,c
    ?ad <n>,10
    ?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
  endm

  if sizec
    globalCP macro n,i,s,c
      globalD n,<i>,<s>,<c>
    endm
  else
    globalCP macro n,i,s,c
      globalW n,<i>,<s>,<c>
    endm
  endif

  if sized
    globalDP macro n,i,s,c
      globalD n,<i>,<s>,<c>
    endm
  else
    globalDP macro n,i,s,c
      globalI n,<i>,<s>,<c>
    endm
  endif

endif


ifndef ?NOSTATIC
  .xcref
  .xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP,staticI
  .cref

  ;;	staticx - define static data of type x
  ;;
  ;;	usage:
  ;;		staticx n,i,s
  ;;	where:
  ;;		x	is the type of the variable  b=byte, w=word, d=dword
  ;;			q=quad word, t=tenbytes, cp=code pointer, dp=data pointer
  ;;		n	is the name to be given the variable.
  ;;		i	is the initial value of the variable.
  ;;		s	is the duplication factor
  ;;
  ;;	statics do not generate an underscored version of the symbol
  ;;	since they are intended to be internal symbols.  If they are
  ;;	required to be public, use globlax.


  staticB macro n,i,s
    ?ad <n>,1
    ?dd n,0,<byte>,<db>,<i>,<s>,<PLM>	;;PLM to keep from generating _
  endm

  staticW macro n,i,s
    ?ad <n>,2
    ?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
  endm

  staticD macro n,i,s
    ?ad <n>,4
    ?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
  endm

  staticI macro n,i,s
    ?ad <n>,sizeI
    ?dd n,0,wordI,%asmdI,<i>,<s>,<PLM>
  endm

  staticQ macro n,i,s
    ?ad <n>,8
    ?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
  endm

  staticT macro n,i,s
    ?ad <n>,10
    ?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
  endm

  if sizec
    staticCP macro n,i,s
      staticD n,<i>,<s>
    endm
  else
    staticCP macro n,i,s
      staticW n,<i>,<s>
    endm
  endif

  if sized
    staticDP macro n,i,s
      staticD n,<i>,<s>
    endm
  else
    staticDP macro   n,i,s
      staticI n,<i>,<s>
    endm
  endif
endif



;;      ?dd is the generalized data definition macro.
;;
;;      format:
;;		?dd n,p,t,d,i,s,c
;;      where:
;;              n       is the name of the procedure
;;              p       is the public flag
;;              t       is the assembler type (byte, word, dword)
;;              d       is the assembler directive (db,dw or dd)
;;              i       is the initial value
;;              s       is a duplication factor
;;		c	is the convention, C for C, PLM or PSACAL for PL/M.
;;			The default (?PLM flag) will be used if not specified.


?dd macro n,p,t,d,i,s,c
  ?gcc ?dd2,%?PLM,<c>			;;Set calling convention
  ife ?dd2				;;If 'C'
    n label t
    ?dd1 _&n,p,<d>,<i>,<s>		;;Microsoft C uses leading underscores
  else
    ?dd1 n,p,<d>,<i>,<s>		;;If PL/M
  endif
endm



;;      ?dd1 is the generalized data definition macro.
;;
;;      format:
;;              ?dd1 n,p,d,i,s
;;      where:
;;              n       is the name of the procedure
;;              p       is the public flag
;;              d       is the assembler directive (db,dw or dd)
;;              i       is the initial value
;;              s       is a duplication factor


?dd1 macro n,p,d,i,s
  if p
    public n
  endif
  ifb <s>
    n d i
  else
    ifb <i>
      n d s dup (?)
    else
      n d s dup (i)
    endif
  endif
endm



ifndef ?NOEXTERN
  .xcref
  .xcref ?ex1,?ex2,externB,externW,externD,externQ,externT,externI
  .xcref externNP,externFP,externP,externCP,externDP,externA
  .cref
  ?ex2 = 0

  ;;	externx - define external data of type x
  ;;
  ;;	usage:
  ;;		externx n,c
  ;;	where:
  ;;		x	is the type of the variable  b=byte, w=word, d=dword
  ;;			q=quad word, t=tenbytes, cp=code pointer
  ;;			dp=data pointer,  a=absolute
  ;;		n	is a list of names to define
  ;;		c	is the convention, C for C, PLM or PSACAL forPL/M.
  ;;			The default (?PLM flag) will be used if not specified.

  externA macro n,c			;;40h is reserved for whatever will
    ?ex1 <n>,40h,<abs>,<c>,<>		;;  be done in the future for ASB
  endm					;;  externals

  externB macro n,c
    ?ex1 <n>,1,<byte>,<c>,<>
  endm

  externW macro n,c
    ?ex1 <n>,2,<word>,<c>,<>
  endm

  externD macro n,c
    ?ex1 <n>,4,<dword>,<c>,<>
  endm

  externI macro n,c
    ?ex1 <n>,sizeI,%wordI,<c>,<>
  endm

  externQ macro n,c
    ?ex1 <n>,8,<qword>,<c>,<>
  endm

  externT macro n,c
    ?ex1 <n>,10,<tbyte>,<c>,<>
  endm

  externNP macro n,c
    ?ex1 <n>,2,<near>,<c>,<cc>
  endm

  externFP macro n,c
    ?ex1 <n>,4,<far>,<c>,<cc>
  endm

  if sizec
    externP macro n,c
      ?ex1 <n>,4,<far>,<c>,<cc>
    endm
  else
    externP macro n,c
      ?ex1 <n>,2,<near>,<c>,<cc>
    endm
  endif

  if sizec
    externCP macro n,c
      ?ex1 <n>,4,<dword>,<c>,<>
    endm
  else
    externCP macro n,c
      ?ex1 <n>,2,<word>,<c>,<>
    endm
  endif

  if sized
    externDP macro n,c
      ?ex1 <n>,4,<dword>,<c>,<>
    endm
  else
    externDP macro n,c
      ?ex1 <n>,2,<word>,<c>,<>
    endm
  endif



  ;;	?ex1 is the generalized external definition macro
  ;;
  ;;	format:
  ;;		?ex1 n,s,d,c,scv
  ;;	where:
  ;;		n	is are the names of the externals
  ;;		s	is the size in bytes (used for typing)
  ;;		d	is the type
  ;;		c	is the convention, C for C, PLM or PSACAL for PL/M.
  ;;			The default (?PLM flag) will be used if not specified.
  ;;		scv	save calling convention.  If this field is "cc", then
  ;;			the calling convention will be saved in a ?CCn equ.

  ?ex1 macro n,s,d,c,scv
    ?gcc ?ex2,%?PLM,<c>
    irp x,<n>
      .xcref
      .xcref ?t&&x
      .cref
      ?t&&x=s				;;save size info
      ife ?ex2
	extrn _&&x:&d
	x equ _&&x
      else
	extrn x:&d
      endif
      ifidn <scv>,<cc>			;;save calling convention (C or PL/M)
	.xcref				;;  if NP, FP, or P
	.xcref ?CC&&x
	.cref
	?CC&&x=?ex2
      endif
    endm
  endm
endif



ifndef ?NOLABEL
  .xcref
  .xcref ?lb1,?lblpu,?lb2
  .xcref labelB,labelW,labelD,labelQ,labelT
  .xcref labelNP,labelFP,labelP,labelCP,labelDP
  .cref
  ?lblpu = 0
  ?lb2 = 0

  ;;	  labelx - define label of data type x
  ;;
  ;;	  usage:
  ;;		  labelx n,c
  ;;	  where:
  ;;		x	is the type of the variable  b=byte, w=word, d=dword
  ;;			q=quad word, t=tenbytes, cp=code pointer, dp=data pointer
  ;;		n	is a list of names to define, the first of which can
  ;;			be the keyword public
  ;;		c	is the convention, C for C, PLM or PSACAL for PL/M.
  ;;			The default (?PLM flag) will be used if not specified.

  labelB macro n,c
    ?lb1 <n>,1,<byte>,<c>
  endm

  labelW macro n,c
    ?lb1 <n>,2,<word>,<c>
  endm

  labelD macro n,c
    ?lb1 <n>,4,<dword>,<c>
  endm

  labelQ macro n,c
    ?lb1 <n>,8,<qword>,<c>
  endm

  labelT macro n,c
    ?lb1 <n>,10,<tbyte>,<c>
  endm

  labelNP macro n,c
    ?lb1 <n>,2,<near>,<c>
  endm

  labelFP macro n,c
    ?lb1 <n>,4,<far>,<c>
  endm

  if sizec
    labelP macro n,c
      ?lb1 <n>,4,<far>,<c>
    endm
  else
    labelP macro n,c
      ?lb1 <n>,2,<near>,<c>
    endm
  endif

  if sizec
    labelCP macro n,c
      ?lb1 <n>,4,<dword>,<c>
    endm
  else
    labelCP macro n,c
      ?lb1 <n>,2,<word>,<c>
    endm
  endif

  if sized
    labelDP macro n,c
      ?lb1 <n>,4,<dword>,<c>
    endm
  else
    labelDP macro n,c
      ?lb1 <n>,2,<word>,<c>
    endm
  endif


  ;;	?lb1 is the generalized label definition macro
  ;;
  ;;	format:
  ;;		?lb1 n,s,d
  ;;	where:
  ;;		n	are the names of the labels
  ;;		s	is the size in bytes (used for typing)
  ;;		d	is the type
  ;;		c	is the convention, C for C, PLM or PSACAL for PL/M.
  ;;			The default (?PLM flag) will be used if not specified.

  ?lb1 macro n,s,d,c
   ?gcc ?lb2,%?PLM,<c>
    ?lblpu=0
    irp x,<n>
      ifidn <x>,<PUBLIC>
	?lblpu=1
      else
	.xcref
	.xcref ?t&&x
	.cref
	?t&&x=s 			;;save size info
	ife ?lb2			;;If C
	  if ?lblpu
	     public _&&x
	  endif
	  _&&x label &d
	  x equ _&&x
	else				;;If PL/M
	  if ?lblpu
	     public x
	  endif
	  x label &d
	endif
      endif
    endm
  endm
endif



ifndef ?NODEF

  ;;	defx - inform macros that name is of type x
  ;;
  ;;	The given name(s) is flaged to be of the given type.  This macro
  ;;	is intended for giving types to variables that were not generated
  ;;	by the macros (i.e., static storage).  There must be a type definition
  ;;	for all parameters in a call list.
  ;;
  ;;	usage:
  ;;		defx	n
  ;;	where:
  ;;		x	is the type of the variable  b=byte, w=word, d=dword
  ;;		n      is the name(s) to be given the variable(s).
  ;;
  ;;	Bytes are considered to be two bytes long for alignment reasons

  .xcref
  .xcref defB,defW,defD,defQ,defT,defCP,defDP
  .cref

  defB macro n
    ?ad <n>,1
  endm

  defW macro n
    ?ad <n>,2
  endm

  defD macro n
    ?ad <n>,4
  endm

  defQ macro n
    ?ad <n>,8
  endm

  defT macro n
    ?ad <n>,10
  endm

  if sizec
    defCP macro n
      defD <n>
    endm
  else
    defCP macro n
      defW <n>
    endm
  endif

  if sized
    defDP macro n
      defD <n>
    endm
  else
    defDP macro n
      defW <n>
    endm
  endif
endif



;	?ad is the macro which creates a definition for the given
;	symbol
;
;	usage:
;		?ad <n>,s
;	where:
;		n is a list of names to define
;		s is the size info (1,2,4,8,10)


?ad macro n,s
  irp x,<n>
    .xcref
    .xcref ?t&&x
    .cref
    ?t&&x=s				;;save size info
  endm
endm



ifndef ?NOPTR
  .xcref
  .xcref regPtr,farPtr
  .cref

  ;;	regPtr generates information allowing a 32-bit pointer currently
  ;;	in a register to be pushed as a parameter to a subroutine using
  ;;	the cCall macro.
  ;;
  ;;	usage:
  ;;		regptr	n,s,o
  ;;	where:
  ;;		n	is the name the argument will be known as
  ;;		s	is the register containing the segment portion
  ;;			of the pointer
  ;;		o	is the register containing the offset portion
  ;;			of the pointer
  ;;
  ;;	2/14/85 - made obsolete with farptr

  regPtr macro n,s,o
    farPtr n,s,o
  endm



  ;;	farPtr generates information allowing a 32-bit pointer to be
  ;;	pushed as a parameter to a subroutine using the cCall macro.
  ;;
  ;;	usage:
  ;;		farptr	n,s,o
  ;;	where:
  ;;		n	is the name the argument will be known as
  ;;		s	is the segment portion of the pointer
  ;;		o	is the offset portion of the pointer
  ;;
  ;;	Note that any cast must have been made in the argument itself
  ;;	(i.e. regptr ptr1,ds,<word ptr 3[si]>)


  farPtr macro n,s,o
    .xcref
    .xcref ?t&n
    .cref
    n &macro
      push s								      ;@
      push o								      ;@
    &endm
    ?t&n=80h
  endm
endif



;;      arg - declare argument
;;
;;	The given argument(s) is added to the argument list structure
;;
;;      format:
;;              arg     a
;;
;;      where:
;;              a       is any valid argument to push.
;;
;;	If any element in arglist has not been defined or isn't a 16-bit
;;      register, then a complete specification must have been given in a
;;      text equate and a defx also given (if not, you'll pay the penalty!)


arg macro a
  irp x,<a>
    ?argc=?argc+1			;;increment the arg count
    ?atal <x>,%?argc			;;generate argument
  endm
endm



;;      ?atal (add to argument list) generates a macro that will cause
;;	the given argument to be processed when invoked.  It is used by
;;      the arg macro only.


?atal macro n,i
  .xcref
  .xcref ?ali&i
  .cref
  ?ali&i &macro
    ?ap <n>
  &endm
endm



;;      ?ap - process arguments and place onto stack
;;
;;	The given argument is processed (type checking) and place on
;;	the stack for a pending call.  There must be a type definition
;;	for all arguments (except words).  This can be done by using
;;      text equates and the defx macro.
;;
;;      format:
;;              ?ap n
;;      where:
;;              n       is the name of the argument to be pushed
;;
;;	The variable  ?argl  is updated by the length of the arguments
;;      pushed so that the stack can be cleaned up after the call.


?ap macro n
  ?argl=?argl+2 			;;assume one word is pushed
  ifdef ?t&n
    ife ?t&n-1				;;byte type
      push word ptr (n) 						      ;@
      exitm
    endif

    ife ?t&n-2				;;word type
      push n								      ;@
      exitm
    endif

    ife ?t&n-4				;;dword type
      push word ptr (n)[2]						      ;@
      push word ptr (n) 						      ;@
      ?argl=?argl+2
      exitm
    endif

    ife ?t&n-8				;;qword type
      push word ptr (n)[6]						      ;@
      push word ptr (n)[4]						      ;@
      push word ptr (n)[2]						      ;@
      push word ptr (n) 						      ;@
      ?argl=?argl+6
      exitm
    endif

    if ?t&n and 80h			;;far pointer type
      n
      ?argl=?argl+2
      exitm
    endif

    ife ?t&n				;;variable storage
      push word ptr (n) 						      ;@
      exitm
    endif
  endif

  push n				;;unknown or register or immediate    ;@
endm



;;	cCall - call a 'c' language procedure
;;
;;	The given procedure is called with the given parameters.
;;	If the calling convention is C, the arguments are pushed
;;      in reverse order, and removed after the called procedure
;;	returns.  If the calling conventing is PL/M, the arguments
;;      are pushed as they were encountered, and the called procedure
;;      is assumed to have removed them from the stack.
;;
;;	The calling convention priority will be:
;;	   1)	that specified on the cCall if present
;;	   2)	that defined by the target
;;	   3)	the default (?PLM flag)
;;
;;      format:
;;		ccall n,<a>,c
;;
;;      where:
;;              n       is the name of the procedure to call
;;              a       are arguments to be pushed (optional, may be
;;                      specified with the "arg" macro.
;;		c	is the convention, C for C, PLM or PSACAL for PL/M.
;;			The default (?PLM flag) will be used if not specified.


cCall macro n,a,c
  ifnb <a>				;;add any arguments to list
    arg <a>
  endif
  mpush %?rsl				;;save registers (if any)

  ifdef ?CC&n				;;if calling convention has been
    ?cCall1=?CC&n			;;   defined for target, use it
  else					;;else use the default
    ?cCall1=?PLM
  endif

  ifnb <c>				;;If possible override, check it out
    ?gcc ?cCall1,%?cCall1,<c>
  endif

  ?argl=0				;;init argument length
  ife ?cCall1				;;if C calling convention
    ?acb=?argc				;;initialize for looping
  else
    ?acb=1				;;initialize for looping
  endif

  rept ?argc				;;push arguments and purge macros
    uconcat <?ali>,%?acb
    uconcat <purge>,,<?ali>,%?acb
    ife ?cCall1 			;;if C calling convention
      ?acb=?acb-1
    else
      ?acb=?acb+1
    endif
  endm
  call n				;;call the procedure		      ;@
  if ((?cCall1 eq 0) and (?argl ne 0))	;;If C calling convention and arguments
    add sp,?argl			;;  then remove them		      ;@
  endif
  mpop %?rsl				;;pop all specified regs
  ?rsl=0				;;invalidate save list
  ?argc= 0				;;    "      arguments
  ?argl= 0
endm




;;	cProc - define a 'c' procedure
;;
;;	cProc is the procedure definition for procedures.
;;
;;      format:
;;		cProc n,cf,a
;;      where:
;;              n       is the name of the procedure
;;
;;		cf	controls certain definitions, and may be:
;;			    NEAR       proc is to be a near label
;;			    FAR        proc is to be a far  label
;;			    PUBLIC     proc is to be defined as public
;;			    SMALL      call makeframe procedure
;;			    NODATA     dont create prolog code to setup DS
;;			    ATOMIC     don't link stack if not needed
;;				       NODATA must be specified for ATOMIC
;;			    FORCEFRAME Force generation of a frame
;;			    C	       proc is to be a C    procedure
;;			    PLM        proc is to be a PL/M procedure
;;			    PASCAL     proc is to be a PL/M procedure
;;			    WIN        proc is to be a windows procedure
;;			    NONWIN     proc isn't to be a windows procedure
;;			    NO_BP      don't generate BP in text equates
;;			    BP	       generate BP in text equates
;;
;;              a       is a list of registers that are to be saved whenever
;;                      the procedure is invoked.
;;
;;			makeframe procedure:   If small is specified, then
;;                      the "makeframe procedure" is invoked instead of
;;                      generating normal prologues/epilogues
;;
;;			A call is performed to the makeframe procedure.  The
;;                      call is followed by two bytes.  the first byte is the
;;                      number of locals to allocate for the frame, the second
;;			is the number of bytes of parameters.  The makeframe
;;			procedure will in turn call the cProc routine at the
;;			address following the data bytes.  When the cProc is
;;                      finished, it will do a near return to the makeframe
;;                      procedure to clean up the frame and exit.
;;
;;			Note that register parameters and makeframe are
;;                      incompatible and cannot be used together.
;;
;;			The makeframe procedure will save SI, DI, and also
;;			DS if a far procedure.	These registers will be
;;                      removed from the autosave list if specified.


cProc macro n,cf,a
  if ?cpd
    ?utpe				;;generate unterminated proc error
  endif

  ?cpd=1				;;a procdef is active now
  ???=0 				;;no locals are defined yet
  ?argc=0				;;no arguments are defined
  ?ba=0 				;;not in a procedure
  ?po=0 				;;initial parameter offset
  ?pu=0 				;;initial public setting
  ?ia=0 				;;no special prolog/epilog
  ?adj=2*sizeI				;;parameter adjustment (near ret+bp)
  ?rp=0 				;;no register parameters
  ?uf=0 				;;don't use makeframe
  ?wfp=?WIN				;;default far procedure (win or not)
  ?ff=0 				;;don't force frame setup
  ?pas=0				;;process register save list
  ?pcc=?PLM				;;calling convention (C or PL/M)
  ?no_bp2=?no_bp1			;;Default base register generation

  ifnb <a>				;;register save list
    ?ri ?pas,<a>
  endif

  ?pc=sizec				;;default size
  ?nd=?nodata1				;;default NODATA flag
  ?nx=0 				;;default is not ATOMIC

  irp x,<cf>
    ifdef ??_cproc_&&x
      ??_cproc_&&x
    else
      ??error2 <e r r o r - unknown keyword x>
      .err
    endif

  endm

  if ?pcc				;;If PLM
    ?PLMPrevParm=0			;;  show no previous parameter
    .xcref
    .xcref ?PLMParm0
    .cref
    ?PLMParm0 &macro			;;Null macro to terminate
    purge ?PLMParm0
    &endm
  endif

  .xcref
  .xcref ?CC&n
  .cref
  ?CC&n=?pcc				;;Save procedure type

  if (?nx eq 1) and (?nd eq 0)		;;ATOMIC requires NODATA
    ?nx = 0				;;clear the ATOMIC keyword
    ??error2 <ATOMIC specified without NODATA - ATOMIC ignored>
  endif

  if ?pc				;;if a far procedure
    if ?wfp				;;if windows
      ife ?nx				;;if not ATOMIC
        ife ?COW			;; COW dos not save DS
	  ?ia=2				;;  adjust locals for saved ds
	  ?pas = ?pas and (not ?ds)	;;no need for extra save
	endif
      endif
    endif
    ?adj=?adj+sizeI 			;;far, make parameter adjustment
  else
    ?wfp=0				;;not a far windows procedure
  endif

  ?pas = ?pas and (not (?sp+?cs+?ss))	;;make no sense to save these

  if ?uf				;;don't save these if user frame
    ?pas = ?pas and (not (?bp+?si+?di))
  endif

  ife ?pcc
    ?pg  <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
  else
    ?pg  <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
  endif
endm




;;      ?pg - generate begin and nested macros for current procedure
;;
;;      format:
;;		?pg n,p,c,a,w,nnu,cc
;;      where:
;;              n       is the name of the procedure
;;              p       is the public flag
;;              c       is the class definition for the procedure
;;              a       is an enumerated list of registers to save
;;                      at entry and restore at exit
;;              w       true if a far windows procedure
;;		nnu	procedure name without any underscore
;;		cc	calling convention (C or PL/M)
;;
;;
;;      local stack allocation will be forced to an even byte count to
;;      maintain stack word alignment.


?pg macro n,p,c,a,w,nnu,cc
  .xcref
  if ?uf				;;if user frame
    if ?nd
      ??error2 <NODATA encountered in &n - user frame ignored>
      ?uf=0
    endif
  endif

  .xcref cBegin
  cBegin &macro g			;;generate cBegin macro
    .xcref
    if cc				;;Finish definition of parameters
      uconcat <?PLMParm>,%?PLMPrevParm,%?po
    endif

    if ?uf				;;if user frame
      if ?rp				;;If register parameters
	??error2 <parmR encountered in &n - user frame ignored>
	?uf=0
      endif
    endif
    ?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc,<nnu>,%??? ;;generate cEnd macro
    ?cpd=0				;;terminate current proc def
    ?argc=0				;;no arguments are defined yet
    ?ba=1				;;have reached a begin
    ???=(???+1) and 0fffeh		;;word align local storage

    if p				;;If to be public
      public n
    endif

    ife c				;;declare procedure type
      n proc near
    else
      n proc far
    endif

    ife cc				;;if 'C' calling convention
      nnu equ n 			;;  generate label without underscore
    endif

    ?cbe = 0				;;Assume no command on cBegin line
    ifnb <g>
      ?pcbe <g>,<nnu>,<cBegin>
    endif
    if ?cbe eq 1			;;if nogen, then cannot have locals
      if ???+a+?rp			;;  saved regs, or parmRs
	if2
	  ??_out <cBegin - possibly invalid use of nogen>
	endif
      endif
    else				;;else must generate a frame
      if ?uf				;;if user frame code specified
	 ?mf c,%???,%?po		;;  call user's makeframe
	 mpush a			;;  save specified registers
      else
	ife ?cbe			;;If full frame to be set up
	  if w				;;if a far windows procedure
	    ife ?nd			;;if not NODATA,
	      mov IAX,ds 		;;   then set AX = current ds, and    ;@
	      nop			;;   leave room for  MOV AX,1234h     ;@
	    endif
	    ife ?nx			;;if not ATOMIC, far frame must be set
	      ife ?DOS5 		;;if not DOS5, then set far frame flag
		inc IBP			;;  by incrementing the old bp	      ;@
	      endif
	      push IBP							      ;@
	      mov IBP,ISP 						      ;@
	      ife ?COW			;; save DS not needed for CW
	  	push ds							      ;@
	      endif
	    else			;;ATOMIC procedure
	      if ?ff+???+?po+?rp	;;if any locals or parameters
		push IBP 		;;  then must set frame pointer       ;@
		mov IBP,ISP		;;  to be able to access them	      ;@
	      endif
	    endif
	    ife ?nd			;;if not NODATA, then AX should
	      mov ds,IAX 		;;  have the ds to use		      ;@
	    endif
	  else				;;not windows.	use standard prolog
	    if ?ff+???+?po+?rp		;;if any locals or parameters
	      push IBP			;;  then must set frame pointer       ;@
	      mov IBP,ISP 		;;  to be able to access them	      ;@
	    endif
	  endif
	  if ?rp			;;if parmR's, push them before
	    ?uf=0			;;  allocating locals and saving
	    rept ?rp			;;  the autosave registers
	      uconcat mpush,,?rp,%?uf
	      ?uf=?uf+1
	    endm
	  endif
	  if ???			;;if locals to allocate
	    if ?chkstk1 		;;if stack checking enabled
	      ifdef ?CHKSTKPROC 	;;if user supplied stack checking
		?CHKSTKPROC %???	;;  invoke it with bytes requested
	      else
		mov IAX,???		;;invoke default stack checking       ;@
		ife cc
		  call _chkstk						      ;@
		else
		  call chkstk						      ;@
		endif
	      endif
	    else			;;no stack checking
	      sub   ISP,???		;; allocate any local storage	      ;@
	    endif
	  endif
	else				;;partial frame, only set locals
	  if ?rp			;;If parmRs, error
	    ??error2 <cBegin - parmRs encountered with partial frame>
	  else
	    if ???			;;Only realloc frame if locals
	      lea ISP,[IBP][-???-?ia]	;;?ia will adjust for saved BP	      ;@
	    endif
	  endif
	endif
	mpush a 			;;save autosave registers
      endif

      ifdef ?PROFILE			;;if profiling enabled
	if c				;;  and a far procedure
	  call StartNMeas		;;  invoke profile start procedure    ;@
	endif
      endif

    endif

    .cref
    purge cBegin			;;remove the macro
  &endm 				;;end of cBegin macro

  .xcref ?utpe
  ?utpe &macro
    ??error2 <unterminated procedure definition: "&n">
  &endm
  .cref
endm					;;end of ?pg macro




;;      ?pg1 - generate end macro for current procedure
;;
;;      format:
;;		?pg1 n,c,a,o,w,f,d,r,cc,nnu,lc
;;      where:
;;              n       is the name of the procedure
;;              c       is the class definition for the procedure
;;              a       is an enumerated list of registers to save
;;                      at entry and restore at exit
;;              o       is the number of bytes of paramteres to remove at exit
;;              w       true if a far windows procedure
;;              f       is 1 if to use the user's makeframe procedure
;;		d	is 1 if NODATA procedure
;;              r       number of register parameters
;;		cc	calling convention (C or PL/M)
;;		nnu	procedure name without any underscore
;;		lc	locals byte count


?pg1 macro n,c,a,o,w,f,d,r,cc,nnu,lc
  .xcref
  .xcref cEnd

  parm_bytes_&nnu = o			;;Define number of parameter bytes

  cEnd &macro g 			;;start of cEnd macro
    .xcref
    ?ba=0				;;no longer in a procedure
    ?cbe = 0				;;Assume no command on cBegin line
    ifnb <g>
      ?pcbe <g>,<nnu>,<cEnd>
    endif
    if ?cbe eq 1			;;if nogen, then cannot have parmRs
      if a+r+lc 			;;  locals, or saved registers
	if2
	  ??_out <cEnd - possibly invalid use of nogen>
	endif
      endif
    else				;;else must remove the frame
      ifdef ?PROFILE			;;if profiling enabled
	if c				;;  and a far procedure
	  call StopNMeas		;;  invoke profile stop procedure
	endif				;;  (doesn't trash DX:AX)
      endif
      mpop a				;;restore autosaved registers
      if f				;;if to use the "makeframe" procedure
	db 0c3h 			;;  near return to user's makeframe    @
      else
	if w				;;if far win proc, use special epilog
	  ife ?nx			;;if not ATOMIC, bp was pushed
	    ife ?COW			;; restore DS not needed for CW
	      if (?TF eq 0) or (???+r)	;;if cannot assume valid sp
		lea sp,-2[bp]		;;  or locals or parmR's, get valid SP @
	      endif
	      pop ds			;;restore saved ds and bp	       @
	    else
	      if (?TF eq 0) or (???+r)	;;if cannot assume valid sp
	        mov sp,bp
	      endif
	    endif
	    pop IBP			;;				       @
	    ife ?DOS5			;;if not DOS5, bp was
	      dec IBP			;;  incremented to mark far frame      @
	    endif
	  else				;;ATOMIC frame was set up
	    if memS32
	      leave
	    else
	      if (?TF eq 0) or (???+r)	;;if cannot assume valid sp
	        mov ISP,IBP 		;;  or locals or parmR's, get valid SP @
	      endif
	      if ???+?po+r
	        pop IBP						      ;@
	      endif
	    endif
	  endif
	else				;;non-windows standard epilog
	  if ?ff+???+?po+r		;;if any parameters
	    if (?TF eq 0) or (???+r)	;;if cannot assume valid SP
	      mov ISP,IBP 		;;  or locals or parmR's, get valid SP;@
	    endif
	    pop IBP							      ;@
	  endif
	endif
	if ?cbe ne 4			;;Don't generate ret if ??cleanframe??   e
	  ife cc			;;if C calling convention
	    ret 			;;  return			      ;@
	  else				;;else
	    ret o			;;  return and remove paramteres      ;@
	  endif
	endif
      endif
    endif
    if ?cbe ne 4			;;Don't delete macro if ??cleanframe??   e
      n endp				;;end of process
      .cref
      purge cEnd			;;remove the macro
    else
      .cref
    endif
  &endm
  .cref
endm


;;	cleanframe
;;
;;	cleanframe removes a cMacros generated frame, invoking cEnd
;;	with a special keyword which will keep the cEnd macro from
;;	generating a return statement and purging itself.

.xcref
.xcref cleanframe
cleanframe macro
  cEnd <??cleanframe??>
endm
.cref



;; The following macros are used to speed up the processing of the
;; command allowed on a cProc command line.  They simply set or clear
;; the correct flag as needed.

.xcref
.xcref ??_cproc_FAR,??_cproc_NEAR,??_cproc_PUBLIC,??_cproc_SMALL
.xcref ??_cproc_DATA,??_cproc_NODATA,??_cproc_ATOMIC,??_cproc_C
.xcref ??_cproc_PLM,??_cproc_PASCAL,??_cproc_WIN,??_cproc_NONWIN
.xcref ??_cproc_NO_BP,??_cproc_BP

.xcref ??_cproc_far,??_cproc_near,??_cproc_public,??_cproc_small
.xcref ??_cproc_data,??_cproc_nodata,??_cproc_atomic,??_cproc_c
.xcref ??_cproc_plm,??_cproc_pascal,??_cproc_win,??_cproc_nonwin
.xcref ??_cproc_no_bp,??_cproc_bp
.cref

??_cproc_FAR macro
 ?pc=1
endm

??_cproc_NEAR macro
  ?pc=0
endm

??_cproc_PUBLIC macro
  ?pu=1
endm

??_cproc_SMALL macro
  ?uf=1
endm

??_cproc_DATA macro
  ?nd=0
endm

??_cproc_NODATA macro
  ?nd=1
endm

??_cproc_ATOMIC macro
  ?nx=1
endm

??_cproc_C macro
  ?pcc=0
endm

??_cproc_PLM macro
  ?pcc=1
endm

??_cproc_PASCAL macro
  ?pcc=1
endm

??_cproc_WIN macro
  ?wfp=1
endm

??_cproc_NONWIN macro
  ?wfp=0
endm

??_cproc_NO_BP macro
  ?no_bp2=1
endm

??_cproc_BP macro
  ?no_bp2=0
endm

??_cproc_far macro
 ?pc=1
endm

??_cproc_near macro
  ?pc=0
endm

??_cproc_public macro
  ?pu=1
endm

??_cproc_small macro
  ?uf=1
endm

??_cproc_data macro
  ?nd=0
endm

??_cproc_nodata macro
  ?nd=1
endm

??_cproc_atomic macro
  ?nx=1
endm

??_cproc_c macro
  ?pcc=0
endm

??_cproc_plm macro
  ?pcc=1
endm

??_cproc_pascal macro
  ?pcc=1
endm

??_cproc_win macro
  ?wfp=1
endm

??_cproc_nonwin macro
  ?wfp=0
endm

??_cproc_no_bp macro
  ?no_bp2=1
endm

??_cproc_bp macro
  ?no_bp2=0
endm


;	?pcbe is the macro which processes the text on cBegin/cEnd
;	The text is allowed to be:
;
;		NOGEN	nogen
;		PARTIAL partial
;		the procedure name as given on the cProc line
;
;	usage:
;		?pcbe <g>,<nnu>,<mt>
;	where:
;		g	is the text on the cBegin/cEnd line
;		nnu	is the procedure name without any underscores
;		mt	macro type (cBegin/cEnd)
;
;	The variable ?cbe is set to the following value
;
;		0 = invalid (defualt action>
;		1 = nogen
;		2 = partial frame
;		4 = clean frame


?pcbe macro g,nnu,mt
  ifidn <g>,<NOGEN>
    ?cbe = 1
  else
    ifidn <g>,<nogen>
      ?cbe = 1
    else
      ifidn <mt>,<cBegin>
	ifidn <g>,<PARTIAL>
	  ?cbe = 2
	else
	  ifidn <g>,<partial>
	    ?cbe = 2
	  else
	    ifdif <g>,<nnu>
	      ??error2 <mt - unknown keyword g>
	    endif
	  endif
	endif
      else
	ifidn <g>,<??cleanframe??>
	  ?cbe = 4
	else
	  ifdif <g>,<nnu>
	    ??error2 <mt - unknown keyword g>
	  endif
	endif
      endif
    endif
  endif
endm



;	assumes is a macro that will set up the assumes for a segment
;	or group created with the createSeg macro.  If the assumed
;	value passed in isn't known, then a normal assume is made.
;
;       usage:
;               assumes s,g
;
;       where:
;               s       is the register to make the assumption about
;		g	is the value to assume is in it
;
; as a hack, substitute FLAT for g if memF32 is set


assumes macro   s,ln
  if  memF32
    assume s:FLAT
  endif
  ife memF32
    ifndef ln&_assumes
      assume s:ln
    else
      ln&_assumes s
    endif
  endif
endm



;	createSeg is a macro that sets up a segment definition and
;	a logical name for that segment.  The logical name can be
;       used to enter the segment, but it cannot be used for anything
;       else.
;
;       usage:
;		createSeg n,ln,a,co,cl,grp
;       where:
;               n       is the physical name of the segment
;               ln      is the name it is to be invoked by
;               a       is the alignment, and is optional
;               co      is the combine type, and is optional
;               cl      is the class, and is optional
;               grp     is the name of the group that contains this segment


createSeg macro n,ln,a,co,cl,grp
  ifnb <cl>
    n segment a co '&cl'
  else
    n segment a co
  endif
  n ends
  ifnb <grp>
    addseg grp,n
  else
    ln&OFFSET equ offset n:
    ln&BASE equ n
    ?cs3 <ln>,<n>
  endif
  ?cs1 <ln>,<n>
endm


addseg macro grp,seg
  .xcref
  .xcref grp&_def
  .cref
  ifndef  grp&_def
    grp&_def=0
  endif
  if grp&_def ne ASMpass
    .xcref
    .xcref grp&_add
    .cref
    grp&_add &macro s
      grp&_in <seg>,s
    &endm
    .xcref
    .xcref grp&_in
    .cref
    grp&_in &macro sl,s
      ifb <s>
	grp group sl
      else
	grp&_add &macro  ns
	grp&_in  <sl,s>,ns
	&endm
      endif
    &endm
    grp&_def=ASMpass
  else
    grp&_add seg
  endif
endm


defgrp macro grp,ln
  addseg grp
  ifnb <ln>
    irp x,<ln>
      ?cs3 <&x>,<grp>
      x&&OFFSET equ offset grp:
      x&&BASE equ grp
    endm
  endif
endm


?cs1 macro ln,n
  .xcref
  .xcref ln&_sbegin
  .cref
  ln&_sbegin &macro
    .xcref
    .xcref ?mf
    .cref
    ?mf &&macro c,l,p			;;when sBegin is invoked, generate
      if c				;;  the makeframe macro
	extrn n&_FARFRAME:near		;;  make frame for far procedures     ;@
	call n&_FARFRAME						      ;@
      else
	extrn n&_NEARFRAME:near 	;;  make frame for near procedures    ;@
	call n&_NEARFRAME						      ;@
      endif
      db l shr 1			;;define number of locals	      ;@
      db p shr 1			;;define number of parameters	      ;@
      &&endm
    ?cs2 <ln>,<n>
    n segment
  &endm
endm


?cs2 macro ln,n
  .xcref
  .xcref sEnd
  .cref
  sEnd &macro
    n ends
    purge ?mf				;;delete the makeframe macro
    purge sEnd
  &endm
endm


?cs3 macro ln,n
  .xcref
  .xcref ln&_assumes
  .cref
  ln&_assumes &macro s
    assume s:&n
  &endm
endm



;	sBegin is the macro that opens up the definition of a segment.
;	The segment must have already been defined with the createSeg
;       macro.
;
;       usage:
;		sBegin ln
;
;       where:
;               ln      is the logical name given to the segment when
;                       it was declared.

.xcref
.xcref sBegin
.cref
sBegin macro ln
  ln&_sbegin
endm

BeginDATA macro
  ife memF32
    sBegin DATA
  else
    .data
  endif
endm

BeginCODE macro
  ife memF32
    sBegin CODE
  else
    .code
  endif
endm

EndDATA macro
  ife memF32
    sEnd DATA
  endif
endm

EndCODE macro
  ife memF32
    sEnd CODE
  endif
endm

ife ?DF

  ;	Define all segments that will be used.	This will allow the
  ;	assume and groups to be set up at one given place, and also
  ;	allow quick changes to be made
  ;
  ;	createSeg name,logname,align,combine,class,group

ife ?DFCODE
  createSeg _TEXT,CODE,%wordI,public,CODE
endif
  ife ?nodata1
    createSeg _DATA,DATA,%wordI,public,DATA,DGROUP
    defgrp DGROUP,DATA
  else
    ife ?DFDATA
      createSeg _DATA,DATA,%wordI,public,DATA,DGROUP
      defgrp DGROUP,DATA
    endif
  endif

  if ?chkstk1
    ifndef ?CHKSTKPROC
      externp <chkstk>
    endif
  endif
endif


;       errnz exp - generate error message if expression isn't zero
;
;	The errnz will generate an error message if the expression "exp"
;	does not evaluate to zero.  This macro is very useful for testing
;       relationships between items, labels, and data that was coded into
;       an application.
;
;                  errnz   <offset $ - offset label>   ;error if not at "label"
;                  errnz   <eofflag and 00000001b>     ;eofflag must be bit 0
;
;	For expressions involving more than one token, the angle brackets
;       must be used.
;
;	The macro is only evaluated on pass 2, so forward references may be
;       used in the expression.

errnz macro x				;;display error if expression is <>0
  if2
    if x				;;if expression is non-zero,
      errnz1  <x>,%(x)
    endif
  endif
endm

errnz1 macro x1,x2
  = *errnz* x1 = x2
  .err
endm



;       errn$ label,exp - generate error message if label (exp) <> $
;
;	The errnz will generate an error message if the label and "exp"
;       does not evaluate to the current value of the location counter.
;	This macro is very useful for testing relationships between
;       labels and the location counter that was coded into an application.
;
;       examples:  errn$   label        ;error if not at "label"
;                  errn$   label,+3     ;error if not three bytes from "label"
;                  errn$   label,-3     ;error if not three bytes past "label"
;
;	If no "exp" is given, it is the same as specifying 0
;
;	The macro is only evaluated on pass 2, so forward references may be
;       used in the expression.

errn$ macro l,x 			;;error if <$-label1 (exp2)> <>0
  errnz   <offset $ - offset l x>
endm



;;	If profile has been specified, declare the profile routines
;;	to be external and far.  It would be best if this could be done
;;	when the call is actually made, but then the fix-up would be
;;	generated as segment-relative.


ifdef ?PROFILE
  externFP  <StartNMeas,StopNMeas>
endif

if memF32
  .model small
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\cmsgs.h ===
/***
*cmsgs.h - runtime errors
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       The file defines, in one place, all error message strings used within
*       the C run-time library.
*
*       [Internal]
*
*Revision History:
*       06-04-90  GJF   Module created.
*       08-08-90  GJF   Added _RT_CONIO_TXT
*       10-11-90  GJF   Added _RT_ABORT_TXT, _RT_FLOAT_TXT, _RT_HEAP_TXT.
*       09-08-91  GJF   Added _RT_ONEXIT_TXT for Win32 (_WIN32_).
*       09-18-91  GJF   Fixed _RT_NONCONT_TXT and _RT_INVALDISP_TXT to
*                       avoid conflict with RTE messages in 16-bit Windows
*                       libs. Also, added math error messages.
*       10-23-92  GJF   Added _RT_PUREVIRT_TXT.
*       02-23-93  SKS   Update copyright to 1993
*       12-15-94  XY    merged with mac header
*       02-14-95  CFW   Clean up Mac merge.
*       03-03-95  GJF   Added _RT_STDIOINIT_TXT.
*       03-29-95  CFW   Add error message to internal headers.
*       06-02-95  GJF   Added _RT_LOWIOINIT_TXT.
*       12-14-95  JWM   Add "#pragma once".
*       04-22-96  GJF   Added _RT_HEAPINIT_TXT.
*       02-24-97  GJF   Replaced defined(_M_MPPC) || defined(_M_M68K) with
*                       defined(_MAC).
*       05-17-99  PML   Remove all Macintosh support.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_CMSGS
#define _INC_CMSGS

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

/*
 * runtime error and termination messages
 */

#define EOL "\r\n"

#define _RT_STACK_TXT      "R6000" EOL "- stack overflow" EOL

#define _RT_FLOAT_TXT      "R6002" EOL "- floating point not loaded" EOL

#define _RT_INTDIV_TXT     "R6003" EOL "- integer divide by 0" EOL

#define _RT_SPACEARG_TXT   "R6008" EOL "- not enough space for arguments" EOL

#define _RT_SPACEENV_TXT   "R6009" EOL "- not enough space for environment" EOL

#define _RT_ABORT_TXT      "" EOL "This application has requested the Runtime to terminate it in an unusual way.\nPlease contact the application's support team for more information." EOL

#define _RT_THREAD_TXT     "R6016" EOL "- not enough space for thread data" EOL

#define _RT_LOCK_TXT       "R6017" EOL "- unexpected multithread lock error" EOL

#define _RT_HEAP_TXT       "R6018" EOL "- unexpected heap error" EOL

#define _RT_OPENCON_TXT    "R6019" EOL "- unable to open console device" EOL

#define _RT_NONCONT_TXT    "R6022" EOL "- non-continuable exception" EOL

#define _RT_INVALDISP_TXT  "R6023" EOL "- invalid exception disposition" EOL

/*
 * _RT_ONEXIT_TXT is specific to Win32 and Dosx32 platforms
 */
#define _RT_ONEXIT_TXT     "R6024" EOL "- not enough space for _onexit/atexit table" EOL

#define _RT_PUREVIRT_TXT   "R6025" EOL "- pure virtual function call" EOL

#define _RT_STDIOINIT_TXT  "R6026" EOL "- not enough space for stdio initialization" EOL

#define _RT_LOWIOINIT_TXT  "R6027" EOL "- not enough space for lowio initialization" EOL

#define _RT_HEAPINIT_TXT   "R6028" EOL "- unable to initialize heap" EOL

/*
 * _RT_DOMAIN_TXT, _RT_SING_TXT and _RT_TLOSS_TXT are used by the floating
 * point library.
 */
#define _RT_DOMAIN_TXT     "DOMAIN error" EOL

#define _RT_SING_TXT       "SING error" EOL

#define _RT_TLOSS_TXT      "TLOSS error" EOL


#define _RT_CRNL_TXT       EOL

#define _RT_BANNER_TXT     "runtime error "


#endif  /* _INC_CMSGS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\conio.h ===
/***
*conio.h - console and port I/O declarations
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for
*       the MS C V2.03 compatible console I/O routines.
*
*       [Public]
*
*Revision History:
*       07-27-87  SKS   Added inpw(), outpw()
*       08-05-87  SKS   Change outpw() from "int" return to "unsigned"
*       11-16-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_loadds" functionality
*       12-17-87  JCR   Added _MTHREAD_ONLY
*       12-18-87  JCR   Added _FAR_ to declarations
*       02-10-88  JCR   Cleaned up white space
*       08-19-88  GJF   Modified to also work for the 386 (small model only)
*       05-03-89  JCR   Added _INTERNAL_IFSTRIP for relinc usage
*       07-27-89  GJF   Cleanup, now specific to the 386
*       10-30-89  GJF   Fixed copyright
*       11-02-89  JCR   Changed "DLL" to "_DLL"
*       11-17-89  GJF   Added const to appropriate arg types of cprintf(),
*                       cputs() and cscanf().
*       02-27-90  GJF   Added #ifndef _INC_CONIO and #include <cruntime.h>
*                       stuff. Also, removed some (now) useless preprocessor
*                       directives.
*       03-21-90  GJF   Replaced _cdecl with _CALLTYPE1 or _CALLTYPE2 in
*                       prototypes.
*       07-23-90  SBM   Added _getch_lk() prototype/macro
*       01-16-91  GJF   ANSI support. Also, removed prototypes for port i/o
*                       functions (not supported in 32-bit).
*       08-20-91  JCR   C++ and ANSI naming
*       09-28-91  JCR   ANSI names: DOSX32=prototypes, WIN32=#defines for now
*       08-26-92  GJF   Function calling type and variable type macros.
*       01-21-93  GJF   Removed support for C6-386's _cdecl.
*       04-06-93  SKS   Replace _CRTAPI1/2 with __cdecl, _CRTVAR1 with nothing
*       04-07-93  SKS   Add _CRTIMP keyword for CRT DLL model
*                       Use link-time aliases for old names, not #define's
*       04-09-93  GJF   Restored prototypes for port i/o.
*       04-13-93  GJF   Change port i/o prototypes per ChuckM.
*       09-01-93  GJF   Merged Cuda and NT SDK versions.
*       10-27-93  GJF   Made port i/o prototypes conditional on _M_IX86.
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       05-24-95  CFW   Header not for use with Mac.
*       12-14-95  JWM   Add "#pragma once".
*       01-23-97  GJF   Cleaned out obsolete support for _NTSDK and _CRTAPI*.
*                       Also, detab-ed.
*       09-30-97  JWM   Restored not-so-obsolete _CRTAPI1 support.
*       10-07-97  RDL   Added IA64.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*       02-11-00  GB    Added support for unicode console output functions.
*       04-25-00  GB    Added support for unicode console input functions.
*       07-20-00  GB    typedefed wint_t to unsigned short
*       11-22-00  PML   Wide-char *putwc* functions take a wchar_t, not wint_t.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_CONIO
#define _INC_CONIO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif /* _CRTBLD */

#ifndef _XBSTRICT

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _INTERNAL_IFSTRIP_
#include <cruntime.h>
#endif  /* _INTERNAL_IFSTRIP_ */


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Function prototypes */

_CRTIMP char * __cdecl _cgets(char *);
_CRTIMP int __cdecl _cprintf(const char *, ...);
_CRTIMP int __cdecl _cputs(const char *);
_CRTIMP int __cdecl _cscanf(const char *, ...);
_CRTIMP int __cdecl _getch(void);
_CRTIMP int __cdecl _getche(void);
#ifdef  _M_IX86
int __cdecl _inp(unsigned short);
unsigned short __cdecl _inpw(unsigned short);
unsigned long __cdecl _inpd(unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl _kbhit(void);
#ifdef  _M_IX86
int __cdecl _outp(unsigned short, int);
unsigned short __cdecl _outpw(unsigned short, unsigned short);
unsigned long __cdecl _outpd(unsigned short, unsigned long);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl _putch(int);
_CRTIMP int __cdecl _ungetch(int);

#ifdef  _MT                                                 /* _MTHREAD_ONLY */
int __cdecl _getch_lk(void);                                /* _MTHREAD_ONLY */
int __cdecl _getche_lk(void);                               /* _MTHREAD_ONLY */
int __cdecl _putch_lk(int);                                 /* _MTHREAD_ONLY */
int __cdecl _ungetch_lk(int);                               /* _MTHREAD_ONLY */
#else                                                       /* _MTHREAD_ONLY */
#define _getch_lk()             _getch()                    /* _MTHREAD_ONLY */
#define _getche_lk()            _getche()                   /* _MTHREAD_ONLY */
#define _putch_lk(c)            _putch(c)                   /* _MTHREAD_ONLY */
#define _ungetch_lk(c)          _ungetch(c)                 /* _MTHREAD_ONLY */
#endif                                                      /* _MTHREAD_ONLY */

#ifndef _WCONIO_DEFINED

/* wide function prototypes, also declared in wchar.h */

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

_CRTIMP wchar_t * __cdecl _cgetws(wchar_t *);
_CRTIMP wint_t __cdecl _getwch(void);
_CRTIMP wint_t __cdecl _getwche(void);
_CRTIMP wint_t __cdecl _putwch(wchar_t);
_CRTIMP wint_t __cdecl _ungetwch(wint_t);
_CRTIMP int __cdecl _cputws(const wchar_t *);
_CRTIMP int __cdecl _cwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _cwscanf(const wchar_t *, ...);

#ifdef  _MT                                                 /* _MTHREAD_ONLY */
wint_t __cdecl _putwch_lk(wchar_t);                         /* _MTHREAD_ONLY */
wint_t __cdecl _getwch_lk();                                /* _MTHREAD_ONLY */
wint_t __cdecl _getwche_lk();                               /* _MTHREAD_ONLY */
wint_t __cdecl _ungetwch_lk(wint_t);                        /* _MTHREAD_ONLY */
#else   /* ndef _MT */                                      /* _MTHREAD_ONLY */
#define _putwch_lk(c)           _putwch(c)                  /* _MTHREAD_ONLY */
#define _getwch_lk()            _getwch()                   /* _MTHREAD_ONLY */
#define _getwche_lk()           _getwche()                  /* _MTHREAD_ONLY */
#define _ungetwch_lk(c)         _ungetwch(c)                /* _MTHREAD_ONLY */
#endif  /* _MT */                                           /* _MTHREAD_ONLY */

#define _WCONIO_DEFINED
#endif  //_WCONIO_DEFINED

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP char * __cdecl cgets(char *);
_CRTIMP int __cdecl cprintf(const char *, ...);
_CRTIMP int __cdecl cputs(const char *);
_CRTIMP int __cdecl cscanf(const char *, ...);
#ifdef  _M_IX86
int __cdecl inp(unsigned short);
unsigned short __cdecl inpw(unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl getch(void);
_CRTIMP int __cdecl getche(void);
_CRTIMP int __cdecl kbhit(void);
#ifdef  _M_IX86
int __cdecl outp(unsigned short, int);
unsigned short __cdecl outpw(unsigned short, unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl putch(int);
_CRTIMP int __cdecl ungetch(int);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif // XBSTRICT

#endif  /* _INC_CONIO */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\cruntime.h ===
/***
*cruntime.h - definitions specific to the target operating system and hardware
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This header file contains widely used definitions specific to the
*       host operating system and hardware. It is included by every C source
*       and most every other header file.
*
*       [Internal]
*
*Revision History:
*       02-27-90  GJF   File created
*       03-06-90  GJF   Added register macros (REG1,...,etc.)
*       04-11-90  GJF   Set _CALLTYPE1 and _CALLTYPE4 to _stdcall.
*       10-30-90  GJF   Added macros defining variable args interface.
*       10-31-90  GJF   Added definition of _JBLEN (from setjmp.h).
*       11-13-90  GJF   Revised #ifdef-s, now use symbolic constants
*                       representing target OS and target processor, with
*                       #error directives for unsupported targets. Note the
*                       general grouping of only OS-dependent definitions
*                       followed by OS and processor dependent definitions.
*       02-25-91  SRW   Move _JBLEN definition back to setjmp.h [_WIN32_]
*       04-09-91  PNT   Added _MAC_ definitions
*       05-09-91  GJF   Restored _JBLEN definitions. Also fixed the macros
*                       defining the target processor so both Stevewo's stuff
*                       and mine would work.
*       05-13-91  GJF   Changed _CALLTYPE1 and _CALLTYPE4 to _cdecl for
*                       Cruiser (_CRUISER_).
*       08-28-91  JCR   ANSI keywords
*       11-01-91  GDP   _JBLEN back to setjmp.h, stdarg macros back to stdarg.h
*       03-30-92  DJM   POSIX support.
*       08-07-92  GJF   Revised various macros.
*       09-08-92  GJF   Restored definition of _MIPS_ (temporarily).
*       11-09-92  GJF   Revised preprocessing conditionals for MIPS.
*       01-09-93  SRW   Remove usage of MIPS and ALPHA to conform to ANSI
*                       Use _MIPS_ and _ALPHA_ instead.
*       02-01-93  GJF   Removed support for C6-386.
*       04-06-93  SKS   Remove support for OS/2, MAC, POSIX, MIPS, etc.
*       11-11-93  GJF   Merged in NT SDK version. Note that having
*                       definitions for the variable-argument access macros
*                       in this file is probably obsolete - this needs to be
*                       checked.
*       10-02-94  BWT   Add PPC support.
*       10-09-94  BWT   Unknown platform changes from John Morgan.
*       12-15-94  XY    merged with mac header
*       02-14-95  CFW   Clean up Mac merge.
*       03-29-95  CFW   Add error message to internal headers.
*       12-14-95  JWM   Add "#pragma once".
*       02-24-97  GJF   Detab-ed.
*       10-07-97  RDL   Added IA64.
*       05-17-99  PML   Remove all Macintosh support.
*       11-03-99  PML   Remove _VA_LIST_T
*       03-18-01  PML   Define _USE_OLD_STDCPP when compiling with stdcpp64
*                       and stdhpp64, for the Win64 system CRTs.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_CRUNTIME
#define _INC_CRUNTIME

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#if     defined(_SYSCRT) && defined(_WIN64)
#define _USE_OLD_STDCPP 1
#endif

#if defined(_XBOX) && !defined(_NTSYSTEM_) && !defined(_BUILD_LIBCP)
// XBLD version stamping

#ifdef NDEBUG

#ifdef _CRT_LIBCI
#ifdef _BUILD_FOR_MT
#define _XBLD_SYM __CrtiBuildNumberMT
#pragma comment(linker, "/include:___CrtiBuildNumberMT")
#define _XBLD_VER1 'MI'
#define _XBLD_VER2 'T'
#else // _BUILD_FOR_MT
#define _XBLD_SYM __CrtiBuildNumber
#pragma comment(linker, "/include:___CrtiBuildNumber")
#define _XBLD_VER1 'I'
#define _XBLD_VER2 0
#endif // _BUILD_FOR_MT
#else // LIBCI
#ifdef _BUILD_FOR_MT
#define _XBLD_SYM __CrtBuildNumberMT
#pragma comment(linker, "/include:___CrtBuildNumberMT")
#define _XBLD_VER1 'TM'
#define _XBLD_VER2 0
#else // _BUILD_FOR_MT
#define _XBLD_SYM __CrtBuildNumber
#pragma comment(linker, "/include:___CrtBuildNumber")
#define _XBLD_VER1 0
#define _XBLD_VER2 0
#endif // _BUILD_FOR_MT
#endif // LIBCI

#else // NDEBUG

#ifdef _CRT_LIBCI
#ifdef _BUILD_FOR_MT
#define _XBLD_SYM __DebugCrtiBuildNumberMT
#pragma comment(linker, "/include:___DebugCrtiBuildNumberMT")
#define _XBLD_VER1 'MI'
#define _XBLD_VER2 'DT'
#else // _BUILD_FOR_MT
#define _XBLD_SYM __DebugCrtiBuildNumber
#pragma comment(linker, "/include:___DebugCrtiBuildNumber")
#define _XBLD_VER1 'DI'
#define _XBLD_VER2 0
#endif // _BUILD_FOR_MT
#else // LIBCI
#ifdef _BUILD_FOR_MT
#define _XBLD_SYM __DebugCrtBuildNumberMT
#pragma comment(linker, "/include:___DebugCrtBuildNumberMT")
#define _XBLD_VER1 'TM'
#define _XBLD_VER2 'D'
#else // _BUILD_FOR_MT
#define _XBLD_SYM __DebugCrtBuildNumber
#pragma comment(linker, "/include:___DebugCrtBuildNumber")
#define _XBLD_VER1 'D'
#define _XBLD_VER2 0
#endif // _BUILD_FOR_MT
#endif // LIBCI

#endif // NDEBUG

#ifdef __cplusplus
extern "C" {
#endif
#include <xboxverp.h>
#pragma data_seg(".XBLD$V")
__declspec(selectany) unsigned short _XBLD_SYM[8] = {
    'IL', 'CB', _XBLD_VER1, _XBLD_VER2, VER_PRODUCTVERSION |
#ifdef NDEBUG
    0x4000
#else
    0x8000
#endif
};
#pragma data_seg()
#ifdef __cplusplus
}
#endif
#endif // XBOX

#if     defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif

#ifdef  _M_IX86
/*
 * 386/486
 */
#define REG1    register
#define REG2    register
#define REG3    register
#define REG4
#define REG5
#define REG6
#define REG7
#define REG8
#define REG9

#elif   ( defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64) )
/*
 * MIPS, ALPHA, or PPC
 */
#define REG1    register
#define REG2    register
#define REG3    register
#define REG4    register
#define REG5    register
#define REG6    register
#define REG7    register
#define REG8    register
#define REG9    register

#else

#pragma message ("Machine register set not defined")

/*
 * Unknown machine
 */

#define REG1
#define REG2
#define REG3
#define REG4
#define REG5
#define REG6
#define REG7
#define REG8
#define REG9

#endif

/*
 * Are the macro definitions below still needed in this file? Are they even
 * correct for MIPS (probably not).
 */
#if     defined(_POSIX_) && !defined(_M_ALPHA)

#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define _VA_START(ap,v) ap = (va_list)&v + _INTSIZEOF(v)
#define _VA_ARG(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define _VA_END(ap) ap = (va_list)0

#endif

#endif  /* _INC_CRUNTIME */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\ctime.h ===
/***
*ctime.h - constant for dates and times
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Include file used by the c time routines containing definitions of
*       various constants and macros used in determining dates and times.
*
*       [Internal]
*
*Revision History:
*       03-??-84  RLB   written
*       05-??-84  DFW   split out the constant from each routine into this file
*       07-27-89  GJF   Fixed copyright
*       10-30-89  GJF   Fixed copyright (again)
*       02-28-90  GJF   Added #ifndef _INC_CTIME stuff.
*       03-29-93  GJF   Revised constants.
*       02-14-95  CFW   Clean up Mac merge.
*       03-29-95  CFW   Add error message to internal headers.
*       12-14-95  JWM   Add "#pragma once".
*       02-24-97  GJF   Detab-ed.
*       05-07-97  GJF   Added _MAX_YEAR64 and _MAX_TIME64_T constants. Added
*                       _IS_LEAP_YEAR() and _ELAPSED_LEAP_YEAR macros. Took
*                       out unnecessary casts.
*       02-09-98  GJF   Changes for Win64: removed unnecessary typing of 
*                       constants as long, also put in larger value for 
*                       _MAX_YEAR.
*       12-10-99  GB    _MAX_YEAR for Win64 be equal to _MAX_YEAR64 
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_CTIME
#define _INC_CTIME

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

/*
 * Constants
 */
#define _DAY_SEC           (24 * 60 * 60)       /* secs in a day */

#define _YEAR_SEC          (365 * _DAY_SEC)     /* secs in a year */

#define _FOUR_YEAR_SEC     (1461 * _DAY_SEC)    /* secs in a 4 year interval */

#define _DEC_SEC           315532800            /* secs in 1970-1979 */

#define _BASE_YEAR         70                   /* 1970 is the base year */

#define _BASE_DOW          4                    /* 01-01-70 was a Thursday */

#define _LEAP_YEAR_ADJUST  17                   /* Leap years 1900 - 1970 */

#ifdef  _WIN64
#define _MAX_YEAR          1099                 /* 2999 is the max year */
#else
#define _MAX_YEAR          138                  /* 2038 is the max year */
#endif

#define _MAX_YEAR64        1099                 /* 2999 is the max year */

#define _MAX__TIME64_T     0x100000000000i64    /* number of seconds from 
                                                   00:00:00, 01/01/1970 UTC to
                                                   23:59:59. 12/31/2999 UTC */

/*
 * Macro to determine if a given year, expressed as the number of years since
 * 1900, is a leap year.
 */
#define _IS_LEAP_YEAR(y)        (((y % 4 == 0) && (y % 100 != 0)) || \
                                ((y + 1900) % 400 == 0))

/*
 * Number of leap years from 1970 up to, but not including, the specified year
 * (expressed as the number of years since 1900).
 */
#define _ELAPSED_LEAP_YEARS(y)  (((y - 1)/4) - ((y - 1)/100) + ((y + 299)/400) \
                                - _LEAP_YEAR_ADJUST)

#endif  /* _INC_CTIME */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\cruntime.inc ===
;***
;cruntime.inc - multi-model assembly macros for interfacing to HLLs
;
;	Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	This file defines the current memory model being used.
;
;Revision History:
;	08-04-88  SJM	Initial version to handle all four memory models
;			in 16-bit mode and small model in 32-bit mode
;	08-08-88  JCR	Added CPDIST, ?WIN, PCS, ISHIFT/LSHIFT, OS2,
;			DNPTR/DFPTR, DFLOAT/DDOUBLE/DLDOUBLE
;	08-16-88  PHG	Added FPES, LFPES, CBI, ZXAL, ZXBL, ZXCL, ZXDL
;	08-17-88  JCR	Added CAXDX, modified FPSIZE
;	08-20-88  PHG	Added diagnostic messages, removed 386 16-bit support
;			and 386 large code/data support, added mucho comments,
;			PSS now defined as es: only if SS_NEQ_GROUP defined
;	08-24-88  JCR	Added RBXSAVE and RBXONLY for use in 'proc uses'
;	08-25-88  JCR	Added savereg macro, removed rbxsave/rbxonly...
;	08-26-88  GJF	Added codeseg (text) macro
;	09-15-88  JCR	Corrected savelist/reglist macro to go with new MASM
;	09-21-88  WAJ	Added JS*, static*, global*, and label*, and lab macros
;	09-22-88  JCR	Change 'plm' to 'pascal' in label macro
;	09-26-88  WAJ	Added PUSH16 which will do a 16 bit push in a USE32 seg.
;	09-28-88  WAJ	Added CPWORD and DPWORD
;	09-29-88  WAJ	Added JMPFAR16 macro
;	10-12-88  JCR	Made PCS evaluate to 'cs:' for 16/32 stub testbed
;	04-24-89  JCR	Added 'assume seg:flat' for 386 to avoid masm/link bug
;	05-25-89  GJF	Added APIEXT, a macro that expands to the proper extrn
;			declaration for an API function
;	06-13-89  JCR	Added 'flat:' to DCPTR and DDPTR
;	09-15-89  JCR	Added DCPTR? and DDPTR?, always use "FLAT" not "flat"
;	10-27-92  SKS	Miscellaneous minor changes for MASM 6.10 compatibility
;	09-06-94  CFW	Replace MTHREAD with _MT.
;	01-11-95  SKS	Remove MASM 5.X support
;	05-04-95  GJF	Use .586 for Win32.
;
;*******************************************************************************

;==============================================================================
;
;Use the following defines to control processor/segment model
;
;   -DI86		8086/8088 processor
;   -DI286		80286 processor
;   -DI386		80386 processor with 32-bit code/data segment
;
;   -Dmem_S		Small memory model   (near code, near data)
;   -Dmem_M		Medium memory model  (far code, near data)
;   -Dmem_C		Compact memory model (near code, fat data)
;   -Dmem_L		Large memory model   (far code, far data)
;
;   -DSS_NEQ_DGROUP	SS and DS point to different segments
;
;   default is -DI86 -Dmem_S
;
;==============================================================================
;
;The following variables are defined by this file:
;   cpu 			86, 286, or 386
;   sizeC			code distance; 1 = far code, 0 = near code
;   sizeD			data distance; 1 = far data, 0 = near data
;   mmodel			english name of the memory model, i.e. "Medium"
;   ISIZE, LSIZE, NSIZE 	size of ints, longs, shorts
;   FLTSIZE, DBLSIZE, LDBLSIZE	size of float, double, long double
;   NPSIZE, FPSIZE		size of near/far pointers
;   CPSIZE, DPSIZE		size of code/data pointers
;   ISHIFT, LSHIFT		bits to shift to convert byte to int/long
;
;The following macros allow easy writing of combined 16/32 bit code:
;
; 16/32 bit registers:
;   rax, rbx, rcx, rdx, 	expand to native registers (rax = eax or ax)
;   rsi, rdi, rsp, rbp
; 16/32 bit register instructions:
;   JRCXZ			jump when rcx is zero
;   CBI 			convert byte to int (al to rax)
;   CAXDX			convert rax to rax:rdx
;   ZXAL, ZXBL, ZXCL, ZXDL	zero extend al,bl,cl,dl to rax,rbx,rcx,rdx
; Pointer instructions:
;   LPDS, LPES			load data pointer with ES or DS
;   PDS, PES			segment overrides when pointer loaded as above
;   PCS, PSS			segment override to get at code/stack segment
;   LFPDS, LFPES		load far pointer with ES or DS
;   FPDS, FPES			segment overrides when pointer loaded as above
;   CPTR			data type of code pointer
;   CPDIST			distance of code (near/far)
;   DNPTR, DFPTR		define near/far pointer
;   DCPTR, DDPTR		define code/data pointer
;   DCPTR?, DDPTR?		define uninitialized code/data pointer
;   CPWORD, DPWORD		data type of code or data pointer
; Numeric type instructions:
;   IWORD, LWORD, SWORD 	data type of int, long, short
;   DINT, DLONG, DSHORT 	define int, long, short
;   DFLOAT, DDOUBLE, DLDOUBLE	define float, double, long double
; Offsets:
;   codeoffset, dataoffset	offsets from code and data segments
; API calls:
;   APIDIST			distance of API calls (near/far)
;   APIEXT ApiName		extrn declaration for an API function
;
;The following utility macros are provided:
;   codeseg			define/declare code segment
;   error <msg> 		stop assembly with message
;   display <msg>		display a message, unless QUIET defined
;   savelist [<reg> ...]	init list of regs to be save by 'proc uses'
;   _if cond <instruction>	assemble instruction only if cond is TRUE
;   _ife cond <instruction>	assemble instruction only if cond is FALSE
;   _ifd symbol <instruction>	assemble instruction only if symbol defined
;   _ifnd symbol <instruction>	assemble instruction only if symbol not defined
;
;   lab  LabelName		assembles to "LabelName:" If DEBUG is defined
;				LabelName is made public
;
;   JS* (ex. JSE,JSZ,JSB ...)	assemble to "je short","jz short","jb short"
;
;   Cmacro look alikes
;   static* Name, InitialValue, Repeat	 defines a static variable of type *
;   global* Name, InitialValue, Repeat	 defines a global variable of type *
;   label*  Name, {PUBLIC,PASCAL,C}	 defines a label of type *
;
;   PUSH16  SegmentReg		pushes 16 bits in a use32 segment
;   JMPFAR16  label		will do a far 16:16 jmp from a use32 segment
;
;==============================================================================

; error <msg>	-    Output message and generate error

error	MACRO	msg
if2			;; only on pass 2 can we generate errors
	%out	**********************************************************
	%out	*** E r r o r  --  msg
	%out	**********************************************************
	.err
endif
        ENDM

; display msg	-    Output message unless QUIET defined

display MACRO	msg
ifndef QUIET		;; only when quiet flag not set
if1			;; and on pass 1, then display message
	%out msg
endif
endif
	ENDM

; One line conditionals:
;   here we create the capability of writing code lines like
;
; _if sizeD   <push ds>   as opposed to    if sizeD
;					       push  ds
;					   endif

_if	MACRO	cond,text
    if	cond
	text
    endif
	ENDM

_ife	MACRO	cond,text
    ife cond
	text
    endif
	ENDM

_ifd	MACRO	cond,text
    ifdef   cond
	text
    endif
	ENDM

_ifnd	MACRO	cond,text
    ifndef  cond
	text
    endif
	ENDM

; set windows flag to 0

	?WIN	equ	0	; disable windows-specific code

; check for _MT, requires 286 or greater processor

ifdef _MT
ifndef I386
ifndef I286
; _MT implies 286 processor
display <Multi-thread specified - assuming 80286 processor>
I286 equ <>
endif
endif
endif

; Process memory-model arguments

ifdef  mem_M
	; Medium model
	sizeC	equ	1
	sizeD	equ	0
	mmodel	equ	<Medium>
elseifdef  mem_C
	; Compact model
	sizeC	equ	0
	sizeD	equ	1
	mmodel	equ	<Compact>
elseifdef  mem_L
	; Large model
	sizeC	equ	1
	sizeD	equ	1
	mmodel	equ	<Large>
else
	; Small model - default
	sizeC	equ	0
	sizeD	equ	0
	mmodel	equ	<Small>
endif

; Process processor arguments

ifdef	_WIN32
	display <Processor:		486/586>
	cpu equ 586
	.586
elseifdef	_POSIX_
	display <Processor:		486/586>
	cpu equ 586
	.586
elseifdef   I286
	display <Processor:		80286>
	cpu equ 286
	.286
elseifdef   I386
	display <Processor:		80386>
	cpu equ 386
	.386
else
	display <Processor:		8086/8088>
	cpu equ 86
	.8086
endif

;  386 32-bit checking.  Currently we are only expecting small model
;  32 bit segments, so we make a few checks to be sure nothing is
;  incorrectly being defined.

ifdef I386
    if sizeC or sizeD
	error <Must use Small memory model for 386 version.>
    endif

    ifdef _LOAD_DGROUP
	error <No loading DGROUP in 386 version.>
    endif

    ifdef SS_NEQ_DGROUP
	error <SS always equals DGROUP in 386 version.>
    endif
endif

;  Set memory model

%	display <Memory model:		mmodel>
%	.model	mmodel, C

;
; *** Temporary Workaround ***
; Currently, MASM will not recognize the 'FLAT' keyword unless it previously
; appears in an 'assume' statement.  Presumably, when the '.model FLAT' feature
; is implemented, this will go away.  [Use 'gs:' since we never use that
; segment register.
;

ifdef	I386
	; ensure that MASM recognizes 'FLAT'
	assume	gs:FLAT
endif


; Define registers:
; Instead of using the "word" registers directly, we will use a set of
; text equates.  This will allow you to use the native word size instead of
; hard coded to 16 bit words.  We also have some instruction equates for
; instruction with the register type hard coded in.

ifdef I386

    rax equ <eax>
    rbx equ <ebx>
    rcx equ <ecx>
    rdx equ <edx>
    rdi equ <edi>
    rsi equ <esi>
    rbp equ <ebp>
    rsp equ <esp>

    JRCXZ equ <jecxz>
    CBI   equ <movsx eax, al>	 ; convert byte to int (al to rax)
    CAXDX equ <cdq>		 ; convert rax to rdx:rax
    ZXAL  equ <movzx eax, al>	 ; zero extend al
    ZXBL  equ <movzx ebx, bl>	 ; zero extend bl
    ZXCL  equ <movzx ecx, cl>	 ; zero extend cl
    ZXDL  equ <movzx edx, dl>	 ; zero extend dl

else

    rax equ <ax>
    rbx equ <bx>
    rcx equ <cx>
    rdx equ <dx>
    rdi equ <di>
    rsi equ <si>
    rbp equ <bp>
    rsp equ <sp>

    JRCXZ equ <jcxz>
    CBI   equ <cbw>		 ; convert byte to int (al to rax)
    CAXDX equ <cwd>		 ; convert rax to rdx:rax
    ZXAL  equ <xor ah, ah>	 ; zero extend al
    ZXBL  equ <xor bh, bh>	 ; zero extend bl
    ZXCL  equ <xor ch, ch>	 ; zero extend cl
    ZXDL  equ <xor dh, dh>	 ; zero extend dl

endif

; The following equates deal with the differences in near versus
; far data pointers, and segment overrides.
;
; Use LPES and PES when loading a default size pointer -- it loads
; a 16-bit pointer register in 286 Small/Medium model,
; a 16-bit pointer register and 16-bit segment register in 8086/286
; Compact/Large model, and a 32-bit pointer register in 386 mode.
;
; Use LFPES and FPES when loading an always far pointer -- it loads a
; 16-bit pointer register and 16-bit segment register in 8086/286,
; all models; a 32-bit pointer register in 386 mode.

if sizeD
    LPES equ <les>
    LPDS equ <lds>
    PDS  equ <ds:>
    PES  equ <es:>
else
    LPES equ <mov>
    LPDS equ <mov>
    PDS  equ <>
    PES  equ <>
endif

ifdef I386
    LFPES equ <mov>
    LFPDS equ <mov>
    FPES equ <>
    FPDS equ <>
else
    LFPES equ <les>
    LFPDS equ <lds>
    FPES equ <es:>
    FPDS equ <ds:>
endif

if sizeC or @WordSize eq 2
    PCS  equ <cs:>		; large code model or non-386
else
 IF 1	;*** TEMP 16/32 TESTBED ***
    PCS  equ <cs:>
 ELSE
    PCS  equ <> 		; 386 small code model
 ENDIF	;*** END TEMP CODE
endif

ifdef SS_NEQ_DGROUP
    PSS   equ <ss:>		; SS != DS
else
    PSS   equ <>		; SS == DS
endif

; Define offset macros:
;   The 32-bit segments will not have 'groups'

ifdef I386
    codeoffset	equ <offset FLAT:>
    dataoffset	equ <offset FLAT:>
else
    codeoffset	equ <offset @code:>
    dataoffset	equ <offset DGROUP:>
endif

; The next set of equates deals with the size of SHORTS, INTS, LONGS, and
; pointers in the 16 and 32 bit versions.

ifdef I386	 ;--- 32 bit segment ---

    ; parameters and locals
    IWORD   equ <dword>
    LWORD   equ <dword>

    ; static storage
    DINT    equ <dd>
    DLONG   equ <dd>
    DSHORT  equ <dw>

    ; sizes for fixing SP, stepping through tables, etc.
    ISIZE   equ 4
    LSIZE   equ 4
    SSIZE   equ 2
    NPSIZE  equ 4
    FPSIZE  equ 4

    ; bit shift count to convert byte cnt/ptr to int/long cnt/ptr
    ISHIFT  equ 2		; byte-to-int shift count
    LSHIFT  equ 2		; byte-to-long shift count

    ; sizes dependent upon memory model.  dq -vs- df is not yet clear
    DNPTR equ <dd>		; near pointer
    DFPTR equ <dd>		; far pointer

    DCPTR   equ <dd offset FLAT:>; 32 bit offset only
    DCPTR?  equ <dd>		; No seg override for uninitialized values
    CPSIZE  equ 4
    CPDIST  equ <near>		; code pointers are near
    CPTR    equ <near ptr>

    DDPTR   equ <dd offset FLAT:>
    DDPTR?  equ <dd>
    DPSIZE  equ 4

    CPWORD  equ <dword> 	; code pointers are dwords
    DPWORD  equ <dword> 	; data pointers are dwords

    APIDIST equ <near>		; all API calls are NEAR in the 32 bit model

; macro to declare API functions
EXTAPI	macro	apiname
	extrn pascal apiname:near
endm

else	;--- 16-bit segment ---

    ; parameters and locals
    IWORD   equ <word>
    LWORD   equ <dword>

    ; static storage
    DINT    equ <dw>
    DLONG   equ <dd>
    DSHORT  equ <dw>

    ; sizes for fixing SP, stepping through tables, etc
    ISIZE   equ 2
    LSIZE   equ 4
    SSIZE   equ 2
    NPSIZE  equ 2
    FPSIZE  equ 4

    ; bit shift count to convert byte cnt/ptr to int/long cnt/ptr
    ISHIFT  equ 1		; byte-to-int shift count
    LSHIFT  equ 2		; byte-to-long shift count

    ; sizes dependent upon memory model
    DNPTR equ <dw>		; near pointer
    DFPTR equ <dd>		; far pointer

    if sizeC
	DCPTR	equ <dd>       ; 16 bit segment and 16 bit offset
	DCPTR?	equ <dd>
	CPSIZE	equ 4
	CPDIST	equ <far>      ; code pointers are far
	CPTR	equ <far ptr>
	CPWORD	equ <dword>    ; code pointers are dwords
    else
	DCPTR	equ <dw>       ; 16 bit offset only
	DCPTR?	equ <dw>
	CPSIZE	equ 2
	CPDIST	equ <near>     ; code pointers are near
	CPTR	equ <near ptr>
	CPWORD	equ <word>     ; code pointers are words
    endif

    if sizeD
	DDPTR	equ <dd>
	DDPTR?	equ <dd>
	DPSIZE	equ 4
	DPWORD	equ <dword>    ; data pointers are dwords
    else
	DDPTR	equ <dw>
	DDPTR?	equ <dw>
	DPSIZE	equ 2
	DPWORD	equ <word>     ; data pointers are words
    endif

    APIDIST equ <far>		; API calls are FAR in 16 bit model

; macro to declare API functions
EXTAPI	macro	apiname
	extrn pascal apiname:far
endm

endif	; --- 16/32 segment ---

; Float/double definitions
; (currently the same for 16- and 32-bit segments)

FLTSIZE  equ	4	; float
DBLSIZE  equ	8	; double
LDBLSIZE equ	10	; long double

DFLOAT	 equ	<dd>
DDOUBLE  equ	<dq>
DLDOUBLE equ	<dt>

;
; savelist - Generate a list of regs to be saved by the proc 'uses' option.
;
; Input:
;	reg1, reg2, reg3, reg4 = registers to be saved across function
; Output:
;	reglist = text string of registers that can be passed to the 'uses'
;	option on the 'proc' command.
;

savelist  MACRO   reg1, reg2, reg3, reg4
	local	ws, listsize
	ws	catstr	< >		; whitespace char

	IFNDEF	I386
	 rbx equ <>			; 8086/286 don't save rbx
	ENDIF

	IFNB	    <reg4>
	 reglist     catstr  reg1, ws, reg2, ws, reg3, ws, reg4
	ELSEIFNB    <reg3>
	 reglist     catstr  reg1, ws, reg2, ws, reg3, ws
	ELSEIFNB    <reg2>
	 reglist     catstr  reg1, ws, reg2, ws,       ws
	ELSEIFNB    <reg1>
	 reglist     catstr  reg1, ws,	     ws,       ws
	ELSE
	 reglist     catstr  <>
	ENDIF

	listsize sizestr reglist	; size of register list

	IF	listsize LE 3		; if list is only the 3 ws chars...
	 reglist catstr  <>
	ENDIF

	IFNDEF	I386
	 rbx equ <bx>			; restore rbx
	ENDIF

	ENDM	; savelist

;
; codeseg - Define/declare the standard code segment. Maps to the proper
; form of the .code directive.
;
; Input:
;
; Output:
;	.code _TEXT	; for large code models
;	.code		; for small code models
;	assume	cs:FLAT ; for 386
;	assume	ds:FLAT ; for 386
;	assume	es:FLAT ; for 386
;	assume	ss:FLAT ; for 386
;

codeseg MACRO

if	sizeC
	.code _TEXT
else
	.code
endif

ifdef	I386
	assume	ds:FLAT
	assume	es:FLAT
	assume	ss:FLAT
endif

	ENDM

;*========
;*
;*  Debug lab macro
;*
;*========

lab	macro name
ifdef	DEBUG
    public  pascal name	    ;; define label public for Symdeb
endif
name:
	endm


;*========
;*
;*  Conditional jump short macros
;*
;*========


	irp	x,<Z,NZ,E,NE,S,NS,C,NC,P,NP,PE,PO,A,AE,B,BE,NB,G,GE,L,LE>
JS&x	equ   <j&x short>
	endm


;*========
;*
;*  Global data definition macros
;*
;*  Usage:
;*	globalI   Name, InitialValue, Repeat
;*
;*========


MakeGlobal  macro   suffix, DataType	    ;; makes all of the global* macros

global&suffix  macro   name, data, rep
public	name
ifb	<rep>
    _repeat = 1
else
    _repeat = (rep)
endif

name	&DataType  _repeat dup( data )
	endm

	endm


    MakeGlobal	T, dt			; globalT
    MakeGlobal	Q, dq			; globalQ
    MakeGlobal	D, dd			; globalD
    MakeGlobal	W, dw			; globalW
    MakeGlobal	B, db			; globalB

%   MakeGlobal	I, <DINT>		; globalI

%   MakeGlobal	DP, <DDPTR>		; globalDP
%   MakeGlobal	CP, <DCPTR>		; globalCP
%   MakeGlobal	FP, <DFPTR>		; globalFP
%   MakeGlobal	NP, <DNPTR>		; globalNP



;*========
;*
;*  Static data definition macros
;*
;*  Usage:
;*	staticI   Name, InitialValue, Repeat
;*
;*========


MakeStatic  macro   suffix, DataType	    ;; makes all of the static* macros

static&suffix  macro   name, data, rep

ifdef  DEBUG
    public  pascal name			    ;; make statics public if DEBUG
endif

ifb	<rep>
    _repeat = 1
else
    _repeat = (rep)
endif

name	&DataType  _repeat dup( data )
	endm

	endm


    MakeStatic	T, dt			; staticT
    MakeStatic	Q, dq			; staticQ
    MakeStatic	D, dd			; staticD
    MakeStatic	W, dw			; staticW
    MakeStatic	B, db			; staticB

%   MakeStatic	I, <DINT>		; staticI

%   MakeStatic	DP, <DDPTR>		; staticDP
%   MakeStatic	CP, <DCPTR>		; staticCP
%   MakeStatic	FP, <DFPTR>		; staticFP
%   MakeStatic	NP, <DNPTR>		; staticNP

;*========
;*
;*  Label definition macros
;*
;*========
;*
;*  Label definition macros
;*
;*  Usage:
;*	labelI	 Name, {PUBLIC, PASCAL, C}
;*
;*========

__MakePublic	macro	name, option	;; decides if a label should be
ifidni	<option>, <PUBLIC>		;; made public
    public  name
elseifidni  <option>, <PASCAL>
    public  pascal name
elseifidni  <option>, <C>
    public  C name
elseifb  <option>
    ifdef  DEBUG
	public	pascal name	;; make public if DEBUG
    endif
endif
		endm


MakeLabel   macro suffix, LabelType	;; makes all of the label* macros

%@CatStr(<label>,<suffix>)	macro	name, option
	__MakePublic	<name>,<option>
name	label	&LabelType
	endm

	endm


	MakeLabel   T, tbyte	; make labelT
	MakeLabel   Q, qword	; make labelQ
	MakeLabel   D, dword	; make labelD
	MakeLabel   W, word	; make labelW
	MakeLabel   B, byte	; make labelB

	MakeLabel   P, proc	; make labelP
	MakeLabel   FP, far	; make labelFP
	MakeLabel   NP, near	; make labelNP

%	MakeLabel   I, IWORD	; make labelI


labelDP macro	name, option		    ;; labelDP
	__MakePublic	<name>,<option>
ifdef  I386
    if sizeD
	name	label	fword
    else
	name	label	dword
    endif
else	;not I386
    if sizeD
	name	label	dword
    else
	name	label	word
    endif
endif	;not I386
	endm

labelCP macro	name, option		    ;; labelCP
	__MakePublic	<name>,<option>
ifdef  I386
    if sizeC
	name	label	fword
    else
	name	label	dword
    endif
else	;not I386
    if sizeC
	name	label	dword
    else
	name	label	word
    endif
endif	;not I386
	endm


;*
;*  PUSH16 SegReg   - pushes 16 bits in a use32 segment
;*

PUSH16	macro	SegReg

ifdef I386
	nop
	db	66h	    ; operand size over-ride
endif	; I386

	push	SegReg
	endm


;*
;*  JMPFAR16  label - jmps far from a use32 to a use16 segment
;*

JMPFAR16 macro	label

ifndef I386
	error  <JMPFAR16 can only be used in a use32 code segment>
endif	;I386

	nop
	db	66h	    ;; operand size over-ride
	db	0eah	    ;; jmp far immediate op code
	dw	offset label
	dw	seg label
	endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\cvt.h ===
/***
*cvt.h - definitions used by formatting routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       cvt.h contains definitions used by the formatting routines [efg]cvt and
*       _output and _input.  The value of CVTBUFSIZE is used to dimension
*       arrays used to hold the maximum size double precision number plus some
*       slop to aid in formatting.
*
*       [Internal]
*
*Revision History:
*       12-11-87  JCR   Added "_loadds" functionality
*       02-10-88  JCR   Cleaned up white space
*       07-28-89  GJF   Fixed copyright
*       10-30-89  GJF   Fixed copyright (again)
*       02-28-90  GJF   Added #ifndef _INC_CVT stuff. Also, removed some
*                       (now) useless preprocessor directives.
*       02-14-95  CFW   Clean up Mac merge.
*       03-29-95  CFW   Add error message to internal headers.
*       06-23-95  GJF   Added leading '_' to several macros to avoid conflict
*                       with macros in win*.h.
*       12-14-95  JWM   Add "#pragma once".
*       02-24-97  GJF   Detab-ed.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_CVT
#define _INC_CVT

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#define _SHORT  1
#define _LONG   2
#define _USIGN  4
#define _NEAR   8
#define _FAR    16

#define OCTAL   8
#define DECIMAL 10
#define HEX     16

#define MUL10(x)        ( (((x)<<2) + (x))<<1 )
#define ISDIGIT(c)      ( ((c) >= '0') && ((c) <= '9') )

#define CVTBUFSIZE (309+40) /* # of digits in max. dp value + slop */

#endif  /* _INC_CVT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines macros for character classification/conversion.
*       [ANSI/System V]
*
*       [Public]
*
*Revision History:
*       07-31-87  PHG   changed (unsigned char)(c) to (0xFF & (c)) to
*                       suppress -W2 warning
*       08-07-87  SKS   Removed (0xFF & (c)) -- is????() functions take an (int)
*       12-18-87  JCR   Added _FAR_ to declarations
*       01-19-87  JCR   DLL routines
*       02-10-88  JCR   Cleaned up white space
*       08-19-88  GJF   Modify to also work for the 386 (small model only)
*       12-08-88  JCR   DLL now access _ctype directly (removed DLL routines)
*       03-26-89  GJF   Brought into sync with CRT\H\CTYPE.H
*       05-03-89  JCR   Added _INTERNAL_IFSTRIP for relinc usage
*       07-28-89  GJF   Cleanup, now specific to OS/2 2.0 (i.e., 386 flat model)
*       10-30-89  GJF   Fixed copyright, removed dummy args from prototypes
*       11-02-89  JCR   Changed "DLL" to "_DLL"
*       02-28-90  GJF   Added #ifndef _INC_CTYPE and #include <cruntime.h>
*                       stuff. Also, removed #ifndef _CTYPE_DEFINED stuff and
*                       some other (now) useless preprocessor directives.
*       03-22-90  GJF   Replaced _cdecl with _CALLTYPE1 in prototypes and
*                       with _VARTYPE1 in variable declarations.
*       01-16-91  GJF   ANSI naming.
*       03-21-91  KRS   Added isleadbyte macro.
*       08-20-91  JCR   C++ and ANSI naming
*       09-28-91  JCR   ANSI names: DOSX32=prototypes, WIN32=#defines for now
*       10-11-91  ETC   All under _INTL: isleadbyte/isw* macros, prototypes;
*                       new is* macros; add wchar_t typedef; some intl defines.
*       12-17-91  ETC   ctype width now independent of _INTL, leave original
*                       short ctype table under _NEWCTYPETABLE.
*       01-22-92  GJF   Changed definition of _ctype for users of crtdll.dll.
*       04-06-92  KRS   Changes for new ISO proposal.
*       08-07-92  GJF   Function calling type and variable type macros.
*       10-26-92  GJF   Fixed _pctype and _pwctype for crtdll.
*       01-19-93  CFW   Move to _NEWCTYPETABLE, remove switch.
*       01-21-93  GJF   Removed support for C6-386's _cdecl.
*       02-17-93  CFW   Removed incorrect UNDONE comment and unused code.
*       02-18-93  CFW   Clean up common _WCTYPE_DEFINED section.
*       03-25-93  CFW   _toupper\_tolower now defined when _INTL.
*       04-06-93  SKS   Replace _CRTAPI1/2 with __cdecl, _CRTVAR1 with nothing
*       04-07-93  SKS   Add _CRTIMP keyword for CRT DLL model
*                       Use link-time aliases for old names, not #define's
*       04-12-93  CFW   Change is*, isw* macros to evaluate args only once.
*       04-14-93  CFW   Simplify MB_CUR_MAX def.
*       05-05-93  CFW   Change is_wctype to iswctype as per ISO.
*       09-01-93  GJF   Merged Cuda and NT SDK versions.
*       10-14-93  SRW   Add support for _CTYPE_DISABLE_MACROS symbol
*       11-11-93  GJF   Merged in change above (10-14-93).
*       11-22-93  CFW   Wide stuff must be under !__STDC__.
*       11-30-93  CFW   Change is_wctype from #define to proto.
*       12-07-93  CFW   Move wide defs outside __STDC__ check.
*       02-07-94  CFW   Move _isctype proto.
*       04-08-94  CFW   Optimize isleadbyte.
*       04-11-94  GJF   Made MB_CUR_MAX, _pctype and _pwctype into deferences
*                       of function returns for _DLL (for compatiblity with
*                       the Win32s version of msvcrt*.dll). Also,
*                       conditionally include win32s.h for DLL_FOR_WIN32S.
*       05-03-94  GJF   Made declarations of MB_CUR_MAX, _pctype and _pwctype
*                       for _DLL also conditional on _M_IX86.
*       10-18-94  GJF   Added prototypes and macros for _tolower_lk,
*                       _toupper_lk, _towlower_lk and _towupper_lk.
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       04-03-95  JCF   Remove #ifdef _WIN32 around wchar_t.
*       10-16-95  GJF   Define _to[w][lower|upper]_lk to be to[w][lower|upper]
*                       for DLL_FOR_WIN32S.
*       12-14-95  JWM   Add "#pragma once".
*       02-22-96  JWM   Merge in PlumHall mods.
*       01-21-97  GJF   Cleaned out obsolete support for Win32s, _NTSDK and
*                       _CRTAPI*. Fixed prototype for __p_pwctype(). Also,
*                       detab-ed.
*       08-14-97  GJF   Strip __p_* prototypes from release version.
*       09-30-97  JWM   Restored not-so-obsolete _CRTAPI1 support.
*       10-07-97  RDL   Added IA64.
*       09-10-98  GJF   Added support for per-thread locale information.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*       10-25-99  GB    Added chvalidator for debug version. VS7#5695
*       11-08-99  PML   wctype_t is unsigned short, not wchar_t - it's a set
*                       of bitflags, not a wide char.
*       07-20-00  GB    typedefed wint_t to unsigned short
*       08-18-00  GB    changed MACRO __ascii_iswalpha to just work 'A'-'Z'
*                       and 'a' to 'z'.
*       09-06-00  GB    declared _ctype, _pwctype etc as const.
*       01-29-01  GB    Added __pctype_func, __pwctype_func, __mb_cur_max_func
*                       for use with STATIC_STDCPP stuff
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_CTYPE
#define _INC_CTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _INTERNAL_IFSTRIP_
#include <cruntime.h>
#endif  /* _INTERNAL_IFSTRIP_ */


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifndef _CTYPE_DISABLE_MACROS
_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];
#ifndef _INTERNAL_IFSTRIP_
_CRTIMP const unsigned short * __cdecl __pctype_func(void);
_CRTIMP const wctype_t * __cdecl __pwctype_func(void);
#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP const unsigned short ** __cdecl __p__pctype(void);
_CRTIMP const wctype_t ** __cdecl __p__pwctype(void);
#endif
#endif  /* _INTERNAL_IFSTRIP_ */
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;
#endif  /* _CTYPE_DISABLE_MACROS */


#ifndef _INTERNAL_IFSTRIP_
#ifdef  _MT
struct  threadlocaleinfostruct;
typedef struct threadlocaleinfostruct * pthreadlocinfo;
extern pthreadlocinfo __ptlocinfo;
pthreadlocinfo __cdecl __updatetlocinfo(void);
#endif
#endif  /* _INTERNAL_IFSTRIP_ */


/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* character classification function prototypes */

#ifndef _CTYPE_DEFINED

_CRTIMP int __cdecl _isctype(int, int);
_CRTIMP int __cdecl isalpha(int);
_CRTIMP int __cdecl isupper(int);
_CRTIMP int __cdecl islower(int);
_CRTIMP int __cdecl isdigit(int);
_CRTIMP int __cdecl isxdigit(int);
_CRTIMP int __cdecl isspace(int);
_CRTIMP int __cdecl ispunct(int);
_CRTIMP int __cdecl isalnum(int);
_CRTIMP int __cdecl isprint(int);
_CRTIMP int __cdecl isgraph(int);
_CRTIMP int __cdecl iscntrl(int);
_CRTIMP int __cdecl toupper(int);
_CRTIMP int __cdecl tolower(int);
_CRTIMP int __cdecl _tolower(int);
_CRTIMP int __cdecl _toupper(int);
_CRTIMP int __cdecl __isascii(int);
_CRTIMP int __cdecl __toascii(int);
_CRTIMP int __cdecl __iscsymf(int);
_CRTIMP int __cdecl __iscsym(int);
#define _CTYPE_DEFINED
#endif

#ifndef _WCTYPE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

/* character classification function prototypes */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

/* the character classification macro definitions */

#ifndef _CTYPE_DISABLE_MACROS

/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in stdlib.h).
 */
#ifndef MB_CUR_MAX
#ifndef _INTERNAL_IFSTRIP_
#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP int * __cdecl __p___mb_cur_max(void);
#endif
#endif  /* _INTERNAL_IFSTRIP_ */
#define MB_CUR_MAX __mb_cur_max
_CRTIMP extern int __mb_cur_max;
/* These functions are for enabling STATIC_CPPLIB functionality */
_CRTIMP int __cdecl ___mb_cur_max_func(void);
#endif  /* MB_CUR_MAX */

/* Introduced to detect error when character testing functions are called
 * with illegal input of integer.
 */
#ifdef _DEBUG
_CRTIMP int __cdecl _chvalidator(int, int);
#define __chvalidchk(a,b)       _chvalidator(a,b)
#else
#define __chvalidchk(a,b)       (_pctype[a] & (b))
#endif


#ifndef _INTERNAL_IFSTRIP_
#define __ascii_isalpha(c)      ( __chvalidchk(c, _ALPHA))
#define __ascii_isdigit(c)      ( __chvalidchk(c, _DIGIT))
#define __ascii_tolower(c)      ( (((c) >= 'A') && ((c) <= 'Z')) ? ((c) - 'A' + 'a') : (c) )
#define __ascii_toupper(c)      ( (((c) >= 'a') && ((c) <= 'z')) ? ((c) - 'a' + 'A') : (c) )
#define __ascii_iswalpha(c)     ( ('A' <= (c) && (c) <= 'Z') || ( 'a' <= (c) && (c) <= 'z'))
#define __ascii_iswdigit(c)     ( '0' <= (c) && (c) <= '9')
#define __ascii_towlower(c)     ( (((c) >= L'A') && ((c) <= L'Z')) ? ((c) - L'A' + L'a') : (c) )
#define __ascii_towupper(c)     ( (((c) >= L'a') && ((c) <= L'z')) ? ((c) - L'a' + L'A') : (c) )
#endif  /* _INTERNAL_IFSTRIP_ */

#if !defined(_MT) || defined(_XBOX)
#ifndef __cplusplus
#define isalpha(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA) : __chvalidchk(_c, _ALPHA))
#define isupper(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_UPPER) : __chvalidchk(_c, _UPPER))
#define islower(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_LOWER) : __chvalidchk(_c, _LOWER))
#define isdigit(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_DIGIT) : __chvalidchk(_c, _DIGIT))
#define isxdigit(_c)    (MB_CUR_MAX > 1 ? _isctype(_c,_HEX)   : __chvalidchk(_c, _HEX))
#define isspace(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_SPACE) : __chvalidchk(_c, _SPACE))
#define ispunct(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT) : __chvalidchk(_c, _PUNCT))
#define isalnum(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA|_DIGIT) : __chvalidchk(_c, (_ALPHA|_DIGIT)))
#define isprint(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) : __chvalidchk(_c, (_BLANK|_PUNCT|_ALPHA|_DIGIT)))
#define isgraph(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT|_ALPHA|_DIGIT) : __chvalidchk(_c, (_PUNCT|_ALPHA|_DIGIT)))
#define iscntrl(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_CONTROL) : __chvalidchk(_c, _CONTROL))
#elif   0         /* Pending ANSI C++ integration */
inline int isalpha(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_ALPHA) : __chvalidchk(_C, _ALPHA)); }
inline int isupper(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_UPPER) : __chvalidchk(_C, _UPPER)); }
inline int islower(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_LOWER) : __chvalidchk(_C, _LOWER)); }
inline int isdigit(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_DIGIT) : __chvalidchk(_C, _DIGIT)); }
inline int isxdigit(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_HEX)   : __chvalidchk(_C, _HEX)); }
inline int isspace(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_SPACE) : __chvalidchk(_C, _SPACE)); }
inline int ispunct(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_PUNCT) : __chvalidchk(_C, _PUNCT)); }
inline int isalnum(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_ALPHA|_DIGIT)
                : __chvalidchk(_C) , (_ALPHA|_DIGIT)); }
inline int isprint(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)
                : __chvalidchk(_C , (_BLANK|_PUNCT|_ALPHA|_DIGIT))); }
inline int isgraph(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_PUNCT|_ALPHA|_DIGIT)
                : __chvalidchk(_C , (_PUNCT|_ALPHA|_DIGIT))); }
inline int iscntrl(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_CONTROL)
                : __chvalidchk(_C , _CONTROL)); }
#endif  /* __cplusplus */
#endif  /* _MT */

#ifdef _MT                                                                          /* _MTHREAD_ONLY */
                                                                                    /* _MTHREAD_ONLY */
#ifdef _DEBUG                                                                       /* _MTHREAD_ONLY */
int __cdecl _chvalidator_mt(pthreadlocinfo, int, int);                              /* _MTHREAD_ONLY */
#define __chvalidchk_mt(p, a, b)  _chvalidator_mt(p, a, b)                          /* _MTHREAD_ONLY */
#else                                                                               /* _MTHREAD_ONLY */
#define __chvalidchk_mt(p, a, b)  (p->pctype[a] & (b))                              /* _MTHREAD_ONLY */
#endif  /* DEBUG */                                                                 /* _MTHREAD_ONLY */
                                                                                    /* _MTHREAD_ONLY */
int __cdecl __isctype_mt(pthreadlocinfo, int, int);                                 /* _MTHREAD_ONLY */
                                                                                    /* _MTHREAD_ONLY */
#define __ischartype_mt(p, c, a)    ( p->mb_cur_max > 1 ? __isctype_mt(p, c, (a)) : __chvalidchk_mt(p,c,a))    /* _MTHREAD_ONLY */
#define __isalpha_mt(p, c)      __ischartype_mt(p, c, _ALPHA)                       /* _MTHREAD_ONLY */
#define __isupper_mt(p, c)      __ischartype_mt(p, c, _UPPER)                       /* _MTHREAD_ONLY */
#define __islower_mt(p, c)      __ischartype_mt(p, c, _LOWER)                       /* _MTHREAD_ONLY */
#define __isdigit_mt(p, c)      __ischartype_mt(p, c, _DIGIT)                       /* _MTHREAD_ONLY */
#define __isxdigit_mt(p, c)     __ischartype_mt(p, c, _HEX)                         /* _MTHREAD_ONLY */
#define __isspace_mt(p, c)      __ischartype_mt(p, c, _SPACE)                       /* _MTHREAD_ONLY */
#define __ispunct_mt(p, c)      __ischartype_mt(p, c, _PUNCT)                       /* _MTHREAD_ONLY */
#define __isalnum_mt(p, c)      __ischartype_mt(p, c, _ALPHA|_DIGIT)                /* _MTHREAD_ONLY */
#define __isprint_mt(p, c)      __ischartype_mt(p, c, _BLANK|_PUNCT|_ALPHA|_DIGIT)  /* _MTHREAD_ONLY */
#define __isgraph_mt(p, c)      __ischartype_mt(p, c, _PUNCT|_ALPHA|_DIGIT)         /* _MTHREAD_ONLY */
#define __iscntrl_mt(p, c)      __ischartype_mt(p, c, _CONTROL)                     /* _MTHREAD_ONLY */
#define __isleadbyte_mt(p, c)   (p->pctype[(unsigned char)(c)] & _LEADBYTE)         /* _MTHREAD_ONLY */
                                                                                    /* _MTHREAD_ONLY */
#endif /* _MT */                                                                    /* _MTHREAD_ONLY */

#define _tolower(_c)    ( (_c)-'A'+'a' )
#define _toupper(_c)    ( (_c)-'a'+'A' )

#define __isascii(_c)   ( (unsigned)(_c) < 0x80 )
#define __toascii(_c)   ( (_c) & 0x7f )

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )
#define isleadbyte(_c)  ( _pctype[(unsigned char)(_c)] & _LEADBYTE)
#elif   0         /* __cplusplus */
inline int iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

inline int isleadbyte(int _C)
        {return (_pctype[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */

#ifdef  _MT                                                                         /* _MTHREAD_ONLY */
                                                                                    /* _MTHREAD_ONLY */
int __cdecl __iswctype_mt(pthreadlocinfo, wchar_t, wctype_t);                       /* _MTHREAD_ONLY */
                                                                                    /* _MTHREAD_ONLY */
#define __iswupper_mt(p, _c)    ( __iswctype_mt(p, _c,_UPPER) )                     /* _MTHREAD_ONLY */
#define __iswlower_mt(p, _c)    ( __iswctype_mt(p, _c,_LOWER) )                     /* _MTHREAD_ONLY */
#define __iswspace_mt(p, _c)    ( __iswctype_mt(p, _c,_SPACE) )                     /* _MTHREAD_ONLY */
#endif                                                                              /* _MTHREAD_ONLY */


/* MS C version 2.0 extended ctype macros */

#define __iscsymf(_c)   (isalpha(_c) || ((_c) == '_'))
#define __iscsym(_c)    (isalnum(_c) || ((_c) == '_'))

#endif  /* _CTYPE_DISABLE_MACROS */

#if defined(_MT) && !defined(XBOX)                          /* _MTHREAD_ONLY */
int __cdecl __tolower_mt(pthreadlocinfo, int);              /* _MTHREAD_ONLY */
int __cdecl __toupper_mt(pthreadlocinfo, int);              /* _MTHREAD_ONLY */
wchar_t __cdecl __towlower_mt(pthreadlocinfo, wchar_t);     /* _MTHREAD_ONLY */
wchar_t __cdecl __towupper_mt(pthreadlocinfo, wchar_t);     /* _MTHREAD_ONLY */
#else                                                       /* _MTHREAD_ONLY */
#define __tolower_mt(p, c)  tolower(c)                      /* _MTHREAD_ONLY */
#define __toupper_mt(p, c)  toupper(c)                      /* _MTHREAD_ONLY */
#define __towlower_mt(p, c) towlower(c)                     /* _MTHREAD_ONLY */
#define __towupper_mt(p, c) towupper(c)                     /* _MTHREAD_ONLY */
#endif                                                      /* _MTHREAD_ONLY */

#if     !__STDC__

/* Non-ANSI names for compatibility */

#ifndef _CTYPE_DEFINED
_CRTIMP int __cdecl isascii(int);
_CRTIMP int __cdecl toascii(int);
_CRTIMP int __cdecl iscsymf(int);
_CRTIMP int __cdecl iscsym(int);
#else
#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym  __iscsym
#endif

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif


#endif  /* _INC_CTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\defsects.inc ===
;***
;defsects.inc - defines sections.
;
;   Copyright (c) 1989-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;   This file defines sections for the C and C++ libs.
;
;   NOTE:  As needed, special "CRT" sections can be added into the existing
;   init/term tables.  These will be for our use only -- users who put
;   stuff in here do so at their own risk.
;
;Revision History:
;   03-19-92  SKS   Loosely based on the 16-bit include file DEFSEGS.INC
;   08-06-92  SKS   Changed these section names from X[ICPT]$[ACLUXZ] to
;		    .CRT$X[ICPT][ACLUXZ] to avoid creating too many sections
;		    Also, sections are no longer defined in groups.  That was
;		    for use with OMF type objects where order of appearance
;		    is important.  With COFF, sorting is done by section name.
;
;******************************************************************************

;*******
;*
;* beginSection - a macro for declaring and beginning a section
;*
;* endSection - a macro for ending a previously declared section
;*
;*******

beginSection	MACRO	SectName
.CRT$&SectName	SEGMENT DWORD PUBLIC 'DATA'
		ENDM

endSection	MACRO	SectName
.CRT$&SectName	ENDS
		ENDM

;  XIA	Begin C Initializer Sections
;  XIC	 Microsoft Reserved
;  XIU	 User
;  XIZ	End C Initializer Sections
;
;  XCA	Begin C++ Constructor Sections
;  XCC	 Compiler (MS)
;  XCL	 Library
;  XCU	 User
;  XCZ	End C++ Constructor Sections
;
;  XPA	Begin C Pre-Terminator Sections
;  XPU	 User
;  XPX	 Microsoft Reserved
;  XPZ	End C Pre-Terminator Sections
;
;  XTA	Begin C Pre-Terminator Sections
;  XTU	 User
;  XTX	 Microsoft Reserved
;  XTZ	End C Pre-Terminator Sections
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\eh.h ===
/***
*eh.h - User include file for exception handling.
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       User include file for exception handling.
*
*       [Public]
*
*Revision History:
*       10-12-93  BSC   Module created.
*       11-04-93  CFW   Converted to CRT format.
*       11-03-94  GJF   Ensure 8 byte alignment. Also, changed nested include
*                       macro to match our naming convention.
*       12-15-94  XY    merged with mac header
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       12-14-95  JWM   Add "#pragma once".
*       02-20-97  GJF   Cleaned out obsolete support for _CRTAPI* and _NTSDK.
*                       Replaced !defined(_M_MPPC) && !defined(_M_M68K) with
*                       !defined(_MAC). Also, detab-ed.
*       09-30-97  JWM   Restored not-so-obsolete _CRTAPI1 support.
*       10-07-97  RDL   Added IA64.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*       12-10-99  GB    Added __uncaught_exception().
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_EH
#define _INC_EH

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)
#endif  // _MSC_VER

#ifndef __cplusplus
#error "eh.h is only for C++!"
#endif


/* Define _CRTIMP */
#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */

typedef void (__cdecl *terminate_function)();
typedef void (__cdecl *unexpected_function)();
typedef void (__cdecl *terminate_handler)();
typedef void (__cdecl *unexpected_handler)();

struct _EXCEPTION_POINTERS;
typedef void (__cdecl *_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

#if     _MSC_VER >= 1200 /*IFSTRIP=IGN*/
_CRTIMP __declspec(noreturn) void __cdecl terminate(void);
_CRTIMP __declspec(noreturn) void __cdecl unexpected(void);
#else
_CRTIMP void __cdecl terminate(void);
_CRTIMP void __cdecl unexpected(void);
#endif

_CRTIMP terminate_function __cdecl set_terminate(terminate_function);
_CRTIMP unexpected_function __cdecl set_unexpected(unexpected_function);
_CRTIMP _se_translator_function __cdecl _set_se_translator(_se_translator_function);
_CRTIMP bool __uncaught_exception();

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_EH
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\dbgint.h ===
/***
*dbgint.h - Supports debugging features of the C runtime library.
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Support CRT debugging features.
*
*       [Internal]
*
*Revision History:
*       08-16-94  CFW   Module created.
*       11-28-94  CFW   Add DumpClient.
*       12-05-94  CFW   Fix debug new handler support, clean up macros.
*       12-06-94  CFW   Export _CrtThrowMemoryException.
*       12-08-94  CFW   Export _assertfailed.
*       01-05-95  CFW   Asserts are errors, add report hook.
*       01-05-95  CFW   Filename pointers are const.
*       01-10-95  CFW   Lots moved to crtdbg.h
*       01-11-95  CFW   Add _xxxx_crt macros.
*       01-13-95  CFW   Add new() support.
*       01-20-94  CFW   Change unsigned chars to chars.
*       02-14-95  CFW   Clean up Mac merge.
*       02-17-95  CFW   new() proto moved to crtdbg.h.
*       03-21-95  CFW   Add _delete_crt.
*       03-29-95  CFW   Add error message to internal headers.
*       03-21-95  CFW   Remove _delete_crt, add _BLOCK_TYPE_IS_VALID.
*       06-27-95  CFW   Add win32s support for debug libs.
*       12-14-95  JWM   Add "#pragma once".
*       04-17-96  JWM   Make _CrtSetDbgBlockType() _CRTIMP (for msvcirtd.dll).
*       02-05-97  GJF   Removed use of obsolete DLL_FOR_WIN32S.
*       01-04-00  GB    Added support for debug version of _aligned routines.
*       08-25-00  PML   Reverse _CrtMemBlockHeader fields nDataSize and
*                       nBlockUse on Win64 so size % 16 == 0 (vs7#153113).
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_DBGINT
#define _INC_DBGINT

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif /* _CRTBLD */

#include <crtdbg.h>

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

#ifdef  __cplusplus

#define _new_crt                        new

#endif  /* __cplusplus */

#define _malloc_crt                     malloc
#define _calloc_crt                     calloc
#define _realloc_crt                    realloc
#define _expand_crt                     _expand
#define _free_crt                       free
#define _msize_crt                      _msize


#define _malloc_base                    malloc
#define _nh_malloc_base                 _nh_malloc
#define _nh_malloc_dbg(s, n, t, f, l)   _nh_malloc(s, n)
#define _heap_alloc_base                _heap_alloc
#define _heap_alloc_dbg(s, t, f, l)     _heap_alloc(s)
#define _calloc_base                    calloc
#define _realloc_base                   realloc
#define _expand_base                    _expand
#define _free_base                      free
#define _msize_base                     _msize
#define _aligned_malloc_base            _aligned_malloc
#define _aligned_realloc_base           _aligned_realloc
#define _aligned_offset_malloc_base     _aligned_offset_malloc
#define _aligned_offset_realloc_base    _aligned_offset_realloc
#define _aligned_free_base              _aligned_free

#ifdef  _MT

#define _calloc_dbg_lk(c, s, t, f, l)   _calloc_lk(c, s)
#define _realloc_dbg_lk(p, s, t, f, l)  _realloc_lk(p, s)
#define _free_base_lk                   _free_lk
#define _free_dbg_lk(p, t)              _free_lk(p)

#else   /* ndef _MT */

#define _calloc_dbg_lk(c, s, t, f, l)   calloc(c, s)
#define _realloc_dbg_lk(p, s, t, f, l)  realloc(p, s)
#define _free_base_lk                   free
#define _free_dbg_lk(p, t)              free(p)

#endif  /* _MT */


#else   /* _DEBUG */


 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/

#define _THISFILE   __FILE__

#ifdef  __cplusplus

#define _new_crt        new(_CRT_BLOCK, _THISFILE, __LINE__)

#endif  /* __cplusplus */

#define _malloc_crt(s)      _malloc_dbg(s, _CRT_BLOCK, _THISFILE, __LINE__)
#define _calloc_crt(c, s)   _calloc_dbg(c, s, _CRT_BLOCK, _THISFILE, __LINE__)
#define _realloc_crt(p, s)  _realloc_dbg(p, s, _CRT_BLOCK, _THISFILE, __LINE__)
#define _expand_crt(p, s)   _expand_dbg(p, s, _CRT_BLOCK)
#define _free_crt(p)        _free_dbg(p, _CRT_BLOCK)
#define _msize_crt(p)       _msize_dbg(p, _CRT_BLOCK)

/*
 * Prototypes for malloc, free, realloc, etc are in malloc.h
 */

void * __cdecl _malloc_base(
        size_t
        );

void * __cdecl _nh_malloc_base (
        size_t,
        int
        );

void * __cdecl _nh_malloc_dbg (
        size_t,
        int,
        int,
        const char *,
        int
        );

void * __cdecl _heap_alloc_base(
        size_t
        );

void * __cdecl _heap_alloc_dbg(
        size_t,
        int,
        const char *,
        int
        );

void * __cdecl _calloc_base(
        size_t,
        size_t
        );

void * __cdecl _realloc_base(
        void *,
        size_t
        );

void * __cdecl _expand_base(
        void *,
        size_t
        );

void __cdecl _free_base(
        void *
        );

size_t __cdecl _msize_base (
        void *
        );

void    __cdecl _aligned_free_base(
        void *
        );

void *  __cdecl _aligned_malloc_base(
        size_t,
        size_t
        );

void *  __cdecl _aligned_offset_malloc_base(
        size_t,
        size_t,
        size_t
        );

void *  __cdecl _aligned_realloc_base(
        void *,
        size_t,
        size_t
        );

void *  __cdecl _aligned_offset_realloc_base(
        void *,
        size_t,
        size_t,
        size_t
        );

#ifdef  _MT

/*
 * Prototypes and macros for multi-thread support
 */


void * __cdecl _calloc_dbg_lk(
        size_t,
        size_t,
        int,
        char *,
        int
        );


void * __cdecl _realloc_dbg_lk(
        void *,
        size_t,
        int,
        const char *,
        int
        );


void __cdecl _free_base_lk(
        void *
        );

void __cdecl _free_dbg_lk(
        void *,
        int
        );

#else   /* ndef _MT */

#define _calloc_dbg_lk                  _calloc_dbg
#define _realloc_dbg_lk                 _realloc_dbg
#define _free_base_lk                   _free_base
#define _free_dbg_lk                    _free_dbg

#endif  /* _MT */

/*
 * For diagnostic purpose, blocks are allocated with extra information and
 * stored in a doubly-linked list.  This makes all blocks registered with
 * how big they are, when they were allocated, and what they are used for.
 */

#define nNoMansLandSize 4

typedef struct _CrtMemBlockHeader
{
        struct _CrtMemBlockHeader * pBlockHeaderNext;
        struct _CrtMemBlockHeader * pBlockHeaderPrev;
        char *                      szFileName;
        int                         nLine;
#ifdef  _WIN64
        /* These items are reversed on Win64 to eliminate gaps in the struct
         * and ensure that sizeof(struct)%16 == 0, so 16-byte alignment is
         * maintained in the debug heap.
         */
        int                         nBlockUse;
        size_t                      nDataSize;
#else
        size_t                      nDataSize;
        int                         nBlockUse;
#endif
        long                        lRequest;
        unsigned char               gap[nNoMansLandSize];
        /* followed by:
         *  unsigned char           data[nDataSize];
         *  unsigned char           anotherGap[nNoMansLandSize];
         */
} _CrtMemBlockHeader;

#define pbData(pblock) ((unsigned char *)((_CrtMemBlockHeader *)pblock + 1))
#define pHdr(pbData) (((_CrtMemBlockHeader *)pbData)-1)


_CRTIMP void __cdecl _CrtSetDbgBlockType(
        void *,
        int
        );

#define _BLOCK_TYPE_IS_VALID(use) (_BLOCK_TYPE(use) == _CLIENT_BLOCK || \
                                              (use) == _NORMAL_BLOCK || \
                                   _BLOCK_TYPE(use) == _CRT_BLOCK    || \
                                              (use) == _IGNORE_BLOCK)

extern _CRT_ALLOC_HOOK _pfnAllocHook; /* defined in dbghook.c */

int __cdecl _CrtDefaultAllocHook(
        int,
        void *,
        size_t,
        int,
        long,
        const unsigned char *,
        int
        );

#endif  /* _DEBUG */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_DBGINT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\dostypes.h ===
/***
*dostypes.h - defines DOS packed date and time types
*
*       Copyright (c) 1987-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the DOS packed date and time types.
*
*       [Internal]
*
*Revision History:
*       11-18-87  SKS   Removed declaration of _dtoxtime
*       09-27-88  JCR   386 versions of macros
*       10-03-88  GJF   Use M_I386, not I386
*       05-01-89  JCR   Fixed 386 versions for new rev of OS/2 386
*       08-03-89  GJF   Cleanup, now specific to OS/2 2.0 (i.e., 386 flat model)
*       10-30-89  GJF   Fixed copyright
*       02-28-90  GJF   Added #ifndef _INC_DOSTYPES stuff
*       08-11-90  SBM   Enhanced SET_DOS_* macros to compile cleanly with -W3
*       04-09-91  PNT   Added _MAC_ definitions
*       09-06-94  CFW   Remove Cruiser support.
*       02-14-95  CFW   Clean up Mac merge.
*       03-29-95  CFW   Add error message to internal headers.
*       12-14-95  JWM   Add "#pragma once".
*       02-24-97  GJF   Replaced defined(_M_MPPC) || defined(_M_M68K) with
*                       defined(_MAC). Also, detab-ed.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_DOSTYPES
#define _INC_DOSTYPES

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#define MASK4   0xf     /* 4 bit mask */
#define MASK5   0x1f    /* 5 bit mask */
#define MASK6   0x3f    /* 6 bit mask */
#define MASK7   0x7f    /* 7 bit mask */

#define DAYLOC          0       /* day value starts in bit 0 */
#define MONTHLOC        5       /* month value starts in bit 5 */
#define YEARLOC         9       /* year value starts in bit 9 */

#define SECLOC          0       /* seconds value starts in bit 0 */
#define MINLOC          5       /* minutes value starts in bit 5 */
#define HOURLOC         11      /* hours value starts in bit 11 */

#define _DATECAST(fd)                   * (unsigned short *) &(fd)
#define _TIMECAST(ft)                   * (unsigned short *) &(ft)

#ifdef  _WIN32

#define SET_DOS_DAY(fd, xday)           fd.Day = (unsigned short)((xday) & MASK5)
#define SET_DOS_MONTH(fd, xmon)         fd.Month = (unsigned short)((xmon) & MASK4)
#define SET_DOS_YEAR(fd, xyr)           fd.Year = (unsigned short)((xyr) & MASK7)

#define SET_DOS_HOUR(ft, xhr)           ft.Hours = (unsigned short)((xhr) & MASK5)
#define SET_DOS_MIN(ft, xmin)           ft.Minutes = (unsigned short)((xmin) & MASK6)
#define SET_DOS_SEC(ft, xsec)           ft.DoubleSeconds = (unsigned short)((xsec) & MASK5)

#define DOS_DAY(fd)                     (fd.Day)
#define DOS_MONTH(fd)                   (fd.Month)
#define DOS_YEAR(fd)                    (fd.Year)

#define DOS_HOUR(ft)                    (ft.Hours)
#define DOS_MIN(ft)                     (ft.Minutes)
#define DOS_SEC(ft)                     (ft.DoubleSeconds)

#else   /* ndef _WIN32 */

#ifdef  _MAC

#define SET_DOS_DAY(fd, xday)           fd.day = (unsigned short)((xday) & MASK5)
#define SET_DOS_MONTH(fd, xmon)         fd.month = (unsigned short)((xmon) & MASK4)
#define SET_DOS_YEAR(fd, xyr)           fd.year = (unsigned short)((xyr) & MASK7)

#define SET_DOS_HOUR(ft, xhr)           ft.hours = (unsigned short)((xhr) & MASK5)
#define SET_DOS_MIN(ft, xmin)           ft.minutes = (unsigned short)((xmin) & MASK6)
#define SET_DOS_SEC(ft, xsec)           ft.twosecs = (unsigned short)((xsec) & MASK5)

#define DOS_DAY(fd)                     (fd.day)
#define DOS_MONTH(fd)                   (fd.month)
#define DOS_YEAR(fd)                    (fd.year)

#define DOS_HOUR(ft)                    (ft.hours)
#define DOS_MIN(ft)                     (ft.minutes)
#define DOS_SEC(ft)                     (ft.twosecs)

#else   /* ndef _MAC */

#error ERROR - ONLY WIN32 OR MAC TARGET SUPPORTED!

#endif  /* _MAC */

#endif  /* _WIN32 */

#define XTIME(d,t) _dtoxtime(DOS_YEAR(d),DOS_MONTH(d),DOS_DAY(d),DOS_HOUR(t),\
     DOS_MIN(t),DOS_SEC(t)*2)

#endif  /* _INC_DOSTYPES */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the structs and unions used for the direct DOS interface
*       routines; includes macros to access the segment and offset
*       values of far pointers, so that they may be used by the routines; and
*       provides function prototypes for direct DOS interface functions.
*
*       [Public]
*
*Revision History:
*       06-11-87  JCR   Added find_t
*       06-15-87  JCR   Added O_NOINHERIT
*       06-18-87  JCR   Added some DOS function prototypes
*       06-19-87  JCR   Moved O_NOINHERIT to fcntl.h
*       06-25-87  JMB   Added _HARDERR_* constants
*       06-25-87  SKS   Added diskfree_t, dosdate_t, dostime_t structures
*       06-25-87  JCR   Added _A_NORMAL, etc. constants
*       07-17-87  JCR   Added _chain_intr, also the "interrupt" type to
*                       _dos_setvec and _dos_getvec.
*       07-27-87  SKS   Added several _dos_*() functions, _disable()/_enable()
*       08-17-87  PHG   Fixed bad prototype for _dos_getdiskfree()
*       10-08-87  JCR   Added _CDECL to prototypes with "interrupt" declaration
*                       (needed for compiling with -Gc switch).
*       09-27-88  JCR   386 version
*       10-03-88  GJF   Use M_I386, not I386
*       05-03-89  JCR   Added _INTERNAL_IFSTRIP for relinc usage
*       07-25-89  GJF   Major cleanup. Alignment of struct fields is now
*                       protected by pack pragmas. Now specific to 386.
*       10-30-89  GJF   Fixed copyright
*       11-02-89  JCR   Changed "DLL" to "_DLL"
*       02-28-90  GJF   Added #ifndef _INC_DOS and #include <cruntime.h>
*                       stuff. Also, removed some (now) useless preprocessor
*                       directives.
*       03-22-90  GJF   Replaced _cdecl with _CALLTYPE1 in prototype and with
*                       _VARTYPE1 in variable declaration.
*       12-28-90  SRW   Added _CRUISER_ conditional around pack pragmas
*       01-23-91  GJF   Removed segread() prototype.
*       04-04-91  GJF   Added version info variables (_WIN32_).
*       08-20-91  JCR   C++ and ANSI naming
*       08-26-91  BWM   Added _peek, poke, and _getvideoaddr (_DOSX32_).
*       08-26-91  BWM   Removed _harderr constants, replaced by _seterrormode.
*       08-26-91  BWM   Removed datetime prototypes, replaced by systime functions.
*       09-05-91  JCR   Added missing #endif (bug fix), removed obsolete stuff
*       09-16-91  BWM   Fixed reversed #ifdef on screen address constants.
*       01-22-92  GJF   Fixed up definitions of global variables for build of,
*                       and users of, crtdll.dll.
*       03-30-92  DJM   POSIX support.
*       06-02-92  SKS   Fix typo in DLL declaration of _osmajor
*                       Add declartion of _pgmptr
*       08-07-92  GJF   Function calling type and variable type macros.
*       01-21-93  GJF   Removed support for C6-386's _cdecl.
*       04-06-93  SKS   Replace _CRTAPI1/2 with __cdecl, _CRTVAR1 with nothing
*                       Remove support for DOSX32, OS/2, etc.
*                       Remove obsolete vars and vars moved to STDLIB.H
*                       Remove duplicate references to _osver, etc.
*                       Remove obsolete functions peek, poke, etc.
*       04-07-93  SKS   Add _CRTIMP keyword for CRT DLL model
*       06-15-93  GJF   Restored prototypes for _enable, _disable.
*       09-01-93  GJF   Merged Cuda and NT SDK versions.
*       11-19-93  CFW   Add _wpgmptr.
*       11-03-94  GJF   Ensure 8 byte alignment.
*       12-15-94  XY    merged with mac header
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       12-14-95  JWM   Add "#pragma once".
*       01-23-97  GJF   Cleaned out obsolete support for _NTSDK and _CRTAPI*.
*                       Also, detab-ed.
*       09-30-97  JWM   Restored not-so-obsolete _CRTAPI1 support.
*       10-07-97  RDL   Added IA64.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_DOS
#define _INC_DOS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _INTERNAL_IFSTRIP_
#include <cruntime.h>
#endif  /* _INTERNAL_IFSTRIP_ */


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _XBOX
#ifndef _DISKFREE_T_DEFINED
/* _getdiskfree structure (duplicated in DIRECT.H) */
struct _diskfree_t {
        unsigned total_clusters;
        unsigned avail_clusters;
        unsigned sectors_per_cluster;
        unsigned bytes_per_sector;
        };

#define _DISKFREE_T_DEFINED
#endif
#endif // XBOX

/* File attribute constants */

#define _A_NORMAL       0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY       0x01    /* Read only file */
#define _A_HIDDEN       0x02    /* Hidden file */
#define _A_SYSTEM       0x04    /* System file */
#define _A_SUBDIR       0x10    /* Subdirectory */
#define _A_ARCH         0x20    /* Archive file */

#ifndef _XBOX
/* Function prototypes */
_CRTIMP unsigned __cdecl _getdiskfree(unsigned, struct _diskfree_t *);
#endif // XBOX

#ifdef  _M_IX86
void __cdecl _disable(void);
void __cdecl _enable(void);
#endif  /* _M_IX86 */

#if     !__STDC__
/* Non-ANSI name for compatibility */
#define diskfree_t  _diskfree_t
#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_DOS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\direct.h ===
/***
*direct.h - function declarations for directory handling/creation
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for the library
*       functions related to directory handling and creation.
*
*       [Public]
*
*Revision History:
*       12/11/87  JCR   Added "_loadds" functionality
*       12-18-87  JCR   Added _FAR_ to declarations
*       02-10-88  JCR   Cleaned up white space
*       08-22-88  GJF   Modified to also work with the 386 (small model only)
*       01-31-89  JCR   Added _chdrive, _fullpath, _getdrive, _getdcwd
*       05-03-89  JCR   Added _INTERNAL_IFSTRIP for relinc usage
*       07-28-89  GJF   Cleanup, now specific to OS/2 2.0 (i.e., 386 flat model)
*       10-30-89  GJF   Fixed copyright
*       11-02-89  JCR   Changed "DLL" to "_DLL"
*       11-17-89  GJF   Moved _fullpath prototype to stdlib.h. Added const
*                       attrib. to arg types for chdir, mkdir, rmdir
*       02-28-90  GJF   Added #ifndef _INC_DIRECT and #include <cruntime.h>
*                       stuff. Also, removed some (now) useless preprocessor
*                       directives.
*       03-21-90  GJF   Replaced _cdecl with _CALLTYPE1 or _CALLTYPE2 in
*                       prototypes.
*       03-30-90  GJF   Now all are _CALLTYPE1.
*       01-17-91  GJF   ANSI naming.
*       08-20-91  JCR   C++ and ANSI naming
*       08-26-91  BWM   Added _diskfree_t, _getdiskfree, and
*       09-26-91  JCR   Non-ANSI alias is for getcwd, not getDcwd (oops)
*       09-28-91  JCR   ANSI names: DOSX32=prototypes, WIN32=#defines for now
*       04-29-92  GJF   Added _getdcwd_lk for Win32.
*       08-07-92  GJF   Function calling type and variable type macros.
*       01-21-93  GJF   Removed support for C6-386's _cdecl.
*       04-06-93  SKS   Replace _CRTAPI1/2 with __cdecl, _CRTVAR1 with nothing
*       04-07-93  SKS   Add _CRTIMP keyword for CRT DLL model
*                       Use link-time aliases for old names, not #define's
*       04-08-93  SKS   Fix oldnames prototype for getcwd()
*       09-01-93  GJF   Merged Cuda and NT SDK versions.
*       12-07-93  CFW   Add wide char version protos.
*       11-03-94  GJF   Ensure 8 byte alignment.
*       12-15-94  XY    merged with mac header
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       12-14-95  JWM   Add "#pragma once".
*       02-20-97  GJF   Cleaned out obsolete support for _CRTAPI* and _NTSDK.
*                       Also, detab-ed.
*       09-30-97  JWM   Restored not-so-obsolete _CRTAPI1 support.
*       10-07-97  RDL   Added IA64.
*       12-15-98  GJF   Changes for 64-bit size_t.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*       10-06-99  PML   Add _W64 modifier to types which are 32 bits in Win32,
*                       64 bits in Win64.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_DIRECT
#define _INC_DIRECT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _INTERNAL_IFSTRIP_
#include <cruntime.h>
#endif  /* _INTERNAL_IFSTRIP_ */

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300 /*IFSTRIP=IGN*/
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* _getdiskfree structure for _getdiskfree() */
#ifndef _DISKFREE_T_DEFINED

struct _diskfree_t {
        unsigned total_clusters;
        unsigned avail_clusters;
        unsigned sectors_per_cluster;
        unsigned bytes_per_sector;
        };

#define _DISKFREE_T_DEFINED
#endif

/* function prototypes */

_CRTIMP int __cdecl _chdir(const char *);
_CRTIMP char * __cdecl _getcwd(char *, int);
_CRTIMP int __cdecl _mkdir(const char *);
_CRTIMP int __cdecl _rmdir(const char *);

#ifndef _XBSTRICT
_CRTIMP int __cdecl _chdrive(int);
_CRTIMP char * __cdecl _getdcwd(int, char *, int);
_CRTIMP int __cdecl _getdrive(void);
#endif // XBSTRICT
_CRTIMP unsigned long __cdecl _getdrives(void);
#ifndef _XBOX
_CRTIMP unsigned __cdecl _getdiskfree(unsigned, struct _diskfree_t *);
#endif

#ifndef _WDIRECT_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _wchdir(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wgetcwd(wchar_t *, int);
_CRTIMP wchar_t * __cdecl _wgetdcwd(int, wchar_t *, int);
_CRTIMP int __cdecl _wmkdir(const wchar_t *);
_CRTIMP int __cdecl _wrmdir(const wchar_t *);

#define _WDIRECT_DEFINED
#endif

#ifdef  _MT                                                     /* _MTHREAD_ONLY */
char * __cdecl _getdcwd_lk(int, char *, int);                   /* _MTHREAD_ONLY */
wchar_t * __cdecl _wgetdcwd_lk(int, wchar_t *, int);            /* _MTHREAD_ONLY */
#else                                                           /* _MTHREAD_ONLY */
#define _getdcwd_lk(drv, buf, len)  _getdcwd(drv, buf, len)     /* _MTHREAD_ONLY */
#define _wgetdcwd_lk(drv, buf, len)  _wgetdcwd(drv, buf, len)   /* _MTHREAD_ONLY */
#endif                                                          /* _MTHREAD_ONLY */

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP int __cdecl chdir(const char *);
_CRTIMP char * __cdecl getcwd(char *, int);
_CRTIMP int __cdecl mkdir(const char *);
_CRTIMP int __cdecl rmdir(const char *);

#define diskfree_t  _diskfree_t

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_DIRECT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\ehassert.h ===
/***
*ehassert.h - our own little versions of the assert macros.
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Versions of the assert macros for exception handling.
*
*       [Internal]
*
*Revision History:
*       09-02-94  SKS   This header file added.
*       12-15-94  XY    merged with mac header
*       02-14-95  CFW   Clean up Mac merge.
*       03-29-95  CFW   Add error message to internal headers.
*       04-13-95  DAK   Add NT Kernel EH support
*       12-14-95  JWM   Add "#pragma once".
*       02-24-97  GJF   Detab-ed.
*       05-17-99  PML   Remove all Macintosh support.
*       10-22-99  PML   Add EHTRACE support
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_EHASSERT
#define _INC_EHASSERT

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#include <windows.h>

#ifdef  DEBUG

#include <stdio.h>
#include <stdlib.h>

int __cdecl dprintf( char *, ... );

#ifdef  _NTSUBSET_

#define DASSERT(c)  ((c)?0: \
                      (DbgPrint("Runtime internal error (%s, line %d)", __FILE__, __LINE__),\
                      terminate()))

#define DEXPECT(c)      ((c)?0: \
                      DbgPrint("Runtime internal error suspected (%s, line %d)", __FILE__, __LINE__))

#else   /* _NTSUBSET_ */

#define DASSERT(c)  ((c)?0: \
                      (printf("Runtime internal error (%s, line %d)", __FILE__, __LINE__),\
                      terminate()))

#define DEXPECT(c)  ((c)?0: \
                      printf("Runtime internal error suspected (%s, line %d)", __FILE__, __LINE__))

#endif  /* _NTSUBSET_ */

#else

// Disable dprintf output
#define dprintf

#define DASSERT(c)  ((c)?0:_inconsistency())
#define DEXPECT(c)  (c)

#endif

#define CHECKPTR(p) (_ValidateRead((p),sizeof(typeof(*(p))))
#define CHECKCODE(p) (_ValidateExecute( (FARPROC)(p) )

BOOL _ValidateRead( const void *data, UINT size = sizeof(char) );
BOOL _ValidateWrite( void *data, UINT size = sizeof(char) );
BOOL _ValidateExecute( FARPROC code );

#if     defined(ENABLE_EHTRACE) && (_MSC_VER >= 1300)

// Warning: EH tracing can only be used in a single thread because this tracing
// level global is not per-thread.
extern int __ehtrace_level;

void __cdecl EHTraceOutput(const char *format, ...);
const char * EHTraceIndent(int level);
const char * EHTraceFunc(const char *func);
void         EHTracePushLevel(int new_level);
void         EHTracePopLevel(bool restore);
int          EHTraceExceptFilter(const char *func, int expr);
void         EHTraceHandlerReturn(const char *func, int level, EXCEPTION_DISPOSITION result);

#define EHTRACE_INIT              int __ehtrace_local_level; __ehtrace_local_level = ++__ehtrace_level
#define EHTRACE_RESET             __ehtrace_level = 0
#define EHTRACE_SAVE_LEVEL        EHTracePushLevel(__ehtrace_local_level)
#define EHTRACE_RESTORE_LEVEL(x)  EHTracePopLevel(x)
#define EHTRACE_ENTER             EHTRACE_INIT; \
                                  EHTraceOutput( "Enter: %s%s\n", EHTraceIndent(__ehtrace_local_level), EHTraceFunc(__FUNCTION__) )
#define EHTRACE_ENTER_MSG(x)      EHTRACE_INIT; \
                                  EHTraceOutput( "Enter: %s%s: %s\n", EHTraceIndent(__ehtrace_local_level), EHTraceFunc(__FUNCTION__), x )
#define EHTRACE_ENTER_FMT1(x,y)   EHTRACE_INIT; \
                                  EHTraceOutput( "Enter: %s%s: " x "\n", EHTraceIndent(__ehtrace_local_level), EHTraceFunc(__FUNCTION__), y )
#define EHTRACE_ENTER_FMT2(x,y,z) EHTRACE_INIT; \
                                  EHTraceOutput( "Enter: %s%s: " x "\n", EHTraceIndent(__ehtrace_local_level), EHTraceFunc(__FUNCTION__), y, z )
#define EHTRACE_MSG(x)            EHTraceOutput( "In   : %s%s: %s\n", EHTraceIndent(__ehtrace_local_level), EHTraceFunc(__FUNCTION__), x )
#define EHTRACE_FMT1(x,y)         EHTraceOutput( "In   : %s%s: " x "\n", EHTraceIndent(__ehtrace_local_level), EHTraceFunc(__FUNCTION__), y )
#define EHTRACE_FMT2(x,y,z)       EHTraceOutput( "In   : %s%s: " x "\n", EHTraceIndent(__ehtrace_local_level), EHTraceFunc(__FUNCTION__), y, z )
#define EHTRACE_EXCEPT(x)         EHTRACE_SAVE_LEVEL, EHTraceExceptFilter( __FUNCTION__, x )
#define EHTRACE_EXIT              --__ehtrace_level
#define EHTRACE_HANDLER_EXIT(x)   EHTraceHandlerReturn( __FUNCTION__, __ehtrace_local_level, x); \
                                  EHTRACE_EXIT

#else

#define EHTRACE_RESET
#define EHTRACE_SAVE_LEVEL
#define EHTRACE_RESTORE_LEVEL(x)
#define EHTRACE_ENTER
#define EHTRACE_ENTER_MSG(x)
#define EHTRACE_ENTER_FMT1(x,y)
#define EHTRACE_ENTER_FMT2(x,y,z)
#define EHTRACE_MSG(x)
#define EHTRACE_FMT1(x,y)
#define EHTRACE_FMT2(x,y,z)
#define EHTRACE_EXCEPT(x)       (x)
#define EHTRACE_EXIT
#define EHTRACE_HANDLER_EXIT(x)

#endif  /* ENABLE_EHTRACE */

#endif  /* _INC_EHASSERT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\errno.h ===
/***
*errno.h - system wide error numbers (set by system calls)
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the system-wide error numbers (set by
*       system calls).  Conforms to the XENIX standard.  Extended
*       for compatibility with Uniforum standard.
*       [System V]
*
*       [Public]
*
*Revision History:
*       07-15-88  JCR   Added errno definition [ANSI]
*       08-22-88  GJF   Modified to also work with the 386 (small model only)
*       05-03-89  JCR   Added _INTERNAL_IFSTRIP for relinc usage
*       08-01-89  GJF   Cleanup, now specific to OS/2 2.0 (i.e., 386 flat model)
*       10-30-89  GJF   Fixed copyright
*       11-02-89  JCR   Changed "DLL" to "_DLL"
*       02-28-90  GJF   Added #ifndef _INC_ERRNO and #include <cruntime.h>
*                       stuff. Also, removed some (now) useless preprocessor
*                       directives.
*       03-29-90  GJF   Replaced _cdecl with _CALLTYPE1 or _VARTYPE1, as
*                       appropriate.
*       08-16-90  SBM   Made MTHREAD _errno() return int *
*       08-20-91  JCR   C++ and ANSI naming
*       08-06-92  GJF   Function calling type and variable type macros.
*       10-01-92  GJF   Made compatible with POSIX. Next step is to renumber
*                       to remove gaps (after next beta).
*       01-21-93  GJF   Removed support for C6-386's _cdecl.
*       04-06-93  SKS   Replace _CRTAPI1/2 with __cdecl, _CRTVAR1 with nothing
*       04-07-93  SKS   Add _CRTIMP keyword for CRT DLL model
*       04-08-93  CFW   Added EILSEQ 42.
*       09-01-93  GJF   Merged Cuda and NT SDK versions.
*       06-06-94  SKS   Change if def(_MT) to if def(_MT) || def(_DLL)
*                       This will support single-thread apps using MSVCRT*.DLL
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       12-14-95  JWM   Add "#pragma once".
*       02-20-97  GJF   Cleaned out obsolete support for _CRTAPI* and _NTSDK.
*                       Replaced !defined(_M_MPPC) && !defined(_M_M68K) with
*                       !defined(_MAC). Also, detab-ed.
*       09-30-97  JWM   Restored not-so-obsolete _CRTAPI1 support.
*       10-07-97  RDL   Added IA64.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_ERRNO
#define _INC_ERRNO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _INTERNAL_IFSTRIP_
#include <cruntime.h>
#endif  /* _INTERNAL_IFSTRIP_ */


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* declare reference to errno */

#if     defined(_MT) || defined(_DLL)
_CRTIMP extern int * __cdecl _errno(void);
#define errno   (*_errno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;
#endif  /* _MT || _DLL */

/* Error Codes */

#define EPERM           1
#define ENOENT          2
#define ESRCH           3
#define EINTR           4
#define EIO             5
#define ENXIO           6
#define E2BIG           7
#define ENOEXEC         8
#define EBADF           9
#define ECHILD          10
#define EAGAIN          11
#define ENOMEM          12
#define EACCES          13
#define EFAULT          14
#define EBUSY           16
#define EEXIST          17
#define EXDEV           18
#define ENODEV          19
#define ENOTDIR         20
#define EISDIR          21
#define EINVAL          22
#define ENFILE          23
#define EMFILE          24
#define ENOTTY          25
#define EFBIG           27
#define ENOSPC          28
#define ESPIPE          29
#define EROFS           30
#define EMLINK          31
#define EPIPE           32
#define EDOM            33
#define ERANGE          34
#define EDEADLK         36
#define ENAMETOOLONG    38
#define ENOLCK          39
#define ENOSYS          40
#define ENOTEMPTY       41
#define EILSEQ          42

/*
 * Support EDEADLOCK for compatibiity with older MS-C versions.
 */
#define EDEADLOCK       EDEADLK

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_ERRNO */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\excpt.h ===
/***
*excpt.h - defines exception values, types and routines
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the definitions and prototypes for the compiler-
*       dependent intrinsics, support functions and keywords which implement
*       the structured exception handling extensions.
*
*       [Public]
*
*Revision History:
*       11-01-91  GJF   Module created. Basically a synthesis of except.h
*                       and excpt.h and intended as a replacement for
*                       both.
*       12-13-91  GJF   Fixed build for Win32.
*       05-05-92  SRW   C8 wants C6 style names for now.
*       07-20-92  SRW   Moved from winxcpt.h to excpt.h
*       08-06-92  GJF   Function calling type and variable type macros. Also
*                       revised compiler/target processor macro usage.
*       11-09-92  GJF   Fixed preprocessing conditionals for MIPS. Also,
*                       fixed some compiler warning (fix from/for RichardS).
*       01-03-93  SRW   Fold in ALPHA changes
*       01-04-93  SRW   Add leave keyword for x86
*       01-09-93  SRW   Remove usage of MIPS and ALPHA to conform to ANSI
*                       Use _MIPS_ and _ALPHA_ instead.
*       01-21-93  GJF   Removed support for C6-386's _cdecl.
*       02-18-93  GJF   Changed _try to __try, etc.
*       03-31-93  CFW   Removed #define try, except, leave, finally for x86.
*       04-06-93  SKS   Replace _CRTAPI1/2 with __cdecl, _CRTVAR1 with nothing
*       07-29-93  GJF   Added declarations for _First_FPE_Indx and _Num_FPE.
*       09-01-93  GJF   Merged Cuda and NT SDK versions.
*       10-04-93  SRW   Fix ifdefs for MIPS and ALPHA to only check for _M_??????
*                       defines
*       10-12-93  GJF   Merged again.
*       10-19-93  GJF   MS/MIPS compiler gets most of the same SEH defs and
*                       decls as the MS compiler for the X86.
*       10-29-93  GJF   Don't #define try, et al, when compiling C++ app!
*       12-09-93  GJF   Alpha compiler now has MS front-end and implements
*                       the same SEH names.
*       11-03-94  GJF   Ensure 8 byte alignment.
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       12-14-95  JWM   Add "#pragma once".
*       02-21-97  GJF   Cleaned out obsolete support for _CRTAPI* and _NTSDK.
*                       Also, detab-ed.
*       09-30-97  JWM   Restored not-so-obsolete _CRTAPI1 support.
*       10-07-97  RDL   Added IA64.
*       11-12-97  RDL   __C_specific_handler() prototype change from SC.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_EXCPT
#define _INC_EXCPT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _INTERNAL_IFSTRIP_
#include <cruntime.h>
#endif  /* _INTERNAL_IFSTRIP_ */


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/*
 * Exception disposition return values.
 */
typedef enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;


/*
 * Prototype for SEH support function.
 */

#ifdef  _M_IX86

/*
 * Declarations to keep MS C 8 (386/486) compiler happy
 */
struct _EXCEPTION_RECORD;
struct _CONTEXT;

EXCEPTION_DISPOSITION __cdecl _except_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void * EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void * DispatcherContext
    );

#elif   defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)

/*
 * Declarations to keep MIPS, ALPHA, and PPC compiler happy
 */
typedef struct _EXCEPTION_POINTERS *Exception_info_ptr;
struct _EXCEPTION_RECORD;
struct _CONTEXT;
struct _DISPATCHER_CONTEXT;


#if defined(_M_IA64)
_CRTIMP EXCEPTION_DISPOSITION __C_specific_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    unsigned __int64 MemoryStackFp,
    unsigned __int64 BackingStoreFp,
    struct _CONTEXT *ContextRecord,
    struct _DISPATCHER_CONTEXT *DispatcherContext,
    unsigned __int64 GlobalPointer
    );
#else
_CRTIMP EXCEPTION_DISPOSITION __C_specific_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    struct _DISPATCHER_CONTEXT *DispatcherContext
    );
#endif // defined(_M_IA64)

#endif


/*
 * Keywords and intrinsics for SEH
 */

#ifdef  _MSC_VER

#define GetExceptionCode            _exception_code
#define exception_code              _exception_code
#define GetExceptionInformation     (struct _EXCEPTION_POINTERS *)_exception_info
#define exception_info              (struct _EXCEPTION_POINTERS *)_exception_info
#define AbnormalTermination         _abnormal_termination
#define abnormal_termination        _abnormal_termination

unsigned long __cdecl _exception_code(void);
void *        __cdecl _exception_info(void);
int           __cdecl _abnormal_termination(void);

#endif


/*
 * Legal values for expression in except().
 */

#define EXCEPTION_EXECUTE_HANDLER       1
#define EXCEPTION_CONTINUE_SEARCH       0
#define EXCEPTION_CONTINUE_EXECUTION    -1


#ifndef _INTERNAL_IFSTRIP_
/*
 * for convenience, define a type name for a pointer to signal-handler
 */

typedef void (__cdecl * _PHNDLR)(int);

/*
 * Exception-action table used by the C runtime to identify and dispose of
 * exceptions corresponding to C runtime errors or C signals.
 */
struct _XCPT_ACTION {

    /*
     * exception code or number. defined by the host OS.
     */
    unsigned long XcptNum;

    /*
     * signal code or number. defined by the C runtime.
     */
    int SigNum;

    /*
     * exception action code. either a special code or the address of
     * a handler function. always determines how the exception filter
     * should dispose of the exception.
     */
    _PHNDLR XcptAction;
};

extern struct _XCPT_ACTION _XcptActTab[];

/*
 * number of entries in the exception-action table
 */
extern int _XcptActTabCount;

/*
 * size of exception-action table (in bytes)
 */
extern int _XcptActTabSize;

/*
 * index of the first floating point exception entry
 */
extern int _First_FPE_Indx;

/*
 * number of FPE entries
 */
extern int _Num_FPE;

/*
 * return values and prototype for the exception filter function used in the
 * C startup
 */
int __cdecl _XcptFilter(unsigned long, struct _EXCEPTION_POINTERS *);

#endif  /* _INTERNAL_IFSTRIP_ */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_EXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\exsup.inc ===
;***
;exsup.inc
;
;	Copyright (C) 1993-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Common data structures & definitions for exsup.asm and other
;	Structured Exception Handling support modules.
;
;Revision History:
;	04-13-93  JWM	Initial version
;	12-05-93  PML	Update for C9.0
;	01-12-94  PML	Move jmp_buf struct here, add new fields
;	01-13-95  JWM	Added _NLG_INFO struct.
;	06-05-95  JWM	Added uoffFramePointer to _NLG_INFO struct.
;       02-16-01  PML   _NLG_LOCK is obsolete
;
;******************************************************************************


;handler dispositions
DISPOSITION_DISMISS             equ     0
DISPOSITION_CONTINUE_SEARCH     equ     1
DISPOSITION_NESTED_EXCEPTION    equ     2
DISPOSITION_COLLIDED_UNWIND     equ     3

;filter return codes
FILTER_ACCEPT           equ     1
FILTER_DISMISS          equ     -1
FILTER_CONTINUE_SEARCH  equ     0

;handler flags settings..
EXCEPTION_UNWINDING     equ     2
EXCEPTION_EXIT_UNWIND   equ     4
EXCEPTION_UNWIND_CONTEXT equ    EXCEPTION_UNWINDING OR EXCEPTION_EXIT_UNWIND

TRYLEVEL_NONE           equ     -1
TRYLEVEL_INVALID        equ     -2

;callback interface codes (mimimal required set)
CB_GET_MAX_CODE		equ	0
CB_DO_LOCAL_UNWIND	equ	1
CB_GET_FRAME_EBP	equ	2
CB_GET_SCOPE_INDEX	equ	3
CB_GET_SCOPE_DATA	equ	4
MAX_CALLBACK_CODE	equ	4

;typedef struct _EXCEPTION_REGISTRATION PEXCEPTION_REGISTRATION;
;struct _EXCEPTION_REGISTRATION{
;     struct _EXCEPTION_REGISTRATION *prev;
;     void (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);
;     struct scopetable_entry *scopetable;
;     int trylevel;
;     int _ebp;
;     PEXCEPTION_POINTERS xpointers;
;};
_EXCEPTION_REGISTRATION struc
    prev                dd      ?
    handler             dd      ?
_EXCEPTION_REGISTRATION ends

;setjmp/longjmp buffer
_JMP_BUF struc
    saved_ebp           dd      ?
    saved_ebx           dd      ?
    saved_edi           dd      ?
    saved_esi           dd      ?
    saved_esp           dd      ?
    saved_return        dd      ?
    saved_xregistration dd      ?
    saved_trylevel      dd      ?
    ; following only found in C9.0 or later jmp_buf
    version_cookie	dd	?
    unwind_func		dd	?
    unwind_data		dd	6 dup(?)
_JMP_BUF ends

; Cookie placed in the jmp_buf to identify the new, longer form
JMPBUF_COOKIE	equ	'VC20'

; Offset of TryLevel in a C8.0 SEH registration node
C8_TRYLEVEL	equ	12

; NLG struct (debugging info)
;
; struct {
;    unsigned long   dwSig;	 	
;    unsigned long   uoffDestination;	
;    unsigned long   dwCode;	 	
;    unsigned long   uoffFramePointer;	
; } _NLG_Destination = {EH_MAGIC_NUMBER1,0,0,0};

MAGIC_NUMBER1		equ	019930520h

_NLG_INFO struc
    dwSig			dd	MAGIC_NUMBER1
    uoffDestination	dd	0
    dwCode			dd	0
    uoffFramePointer	dd	0
_NLG_INFO ends
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\ehstate.h ===
/***
*ehstate.h - exception handling state management declarations
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       EH State management declarations.  Does target-dependent definitions.
*
*       Macros defined:
*
*       GetCurrentState - determines current state (may call function)
*       SetState - sets current state to specified value (may call function)
*
*       [Internal]
*
*Revision History:
*       05-21-93  BS    Module created.
*       03-03-94  TL    Added Mips (_M_MRX000 >= 4000) changes 
*       09-02-94  SKS   This header file added.
*       09-13-94  GJF   Merged in changes from/for DEC Alpha (from Al Doser,
*                       dated 6/20).
*       12-15-94  XY    merged with mac header
*       02-14-95  CFW   Clean up Mac merge.
*       03-29-95  CFW   Add error message to internal headers.
*       12-14-95  JWM   Add "#pragma once".
*       02-24-97  GJF   Detab-ed.
*       06-01-97  TL    Added P7 changes 
*       05-17-99  PML   Remove all Macintosh support.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_EHSTATE
#define _INC_EHSTATE

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#if     _M_MRX000 >= 4000 /*IFSTRIP=IGN*/

//
// This is a function calls on MIPS, defined in 'ehstate.cxx'
// The function SetState is not used on Mips
//
extern __ehstate_t GetCurrentState( EHRegistrationNode*, DispatcherContext*, FuncInfo* ); 

#elif   defined(_M_IA64) /*IFSTRIP=IGN*/

extern __ehstate_t GetCurrentState(EHRegistrationNode*, DispatcherContext*, FuncInfo*); 
extern __ehstate_t GetUnwindState(EHRegistrationNode*, DispatcherContext*, FuncInfo*); 
extern VOID        SetState(EHRegistrationNode*, DispatcherContext*, FuncInfo*, __ehstate_t); 
extern VOID        SetUnwindTryBlock(EHRegistrationNode*, DispatcherContext*, FuncInfo*, INT); 
extern INT         GetUnwindTryBlock(EHRegistrationNode*, DispatcherContext*, FuncInfo*); 
extern __ehstate_t _StateFromControlPc(FuncInfo*, DispatcherContext*);
extern __ehstate_t _StateFromIp(FuncInfo*, DispatcherContext*, __int64);

#elif   _M_IX86 >= 300 /*IFSTRIP=IGN*/

//
// In the initial implementation, the state is simply stored in the 
// registration node.
//

#define GetCurrentState( pRN, pDC, pFuncInfo )  (pRN->state)

#define SetState( pRN, pDC, pFuncInfo, newState )       (pRN->state = newState)

#elif   defined(_M_ALPHA)
//
// These macros defined in terms of the EH_STATE macro which lives in ehdata.h.
//
#define GetCurrentState(pRN, pDC, pFuncInfo)    (EH_STATE(pRN, pFuncInfo))
#define SetState(pRN, pDC, pFuncInfo, newState) (EH_STATE(pRN, pFuncInfo)=newState)

#elif   defined(_M_PPC)
//
// This is a function call on PowerPC, defined in 'ehstate.cxx'
// The function SetState is not used on PowerPC
//
extern __ehstate_t GetCurrentState(EHRegistrationNode *, DispatcherContext *, FuncInfo *); 
extern __ehstate_t GetUnwindState(EHRegistrationNode *, DispatcherContext *, FuncInfo *); 
#define SetState(pRN, pDC, pFuncInfo, newState)

#else
#error "State management unknown for this platform "
#endif

#endif  /* _INC_EHSTATE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\ehhooks.h ===
/***
*ehhook.h - declaration of exception handling hook variables
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Declaration of E.H. hook variables
*
*       [Internal]
*
*Revision History:
*       05-26-93  BS    Module created.
*       09-02-94  SKS   This header file added.
*       12-15-94  XY    merged with mac header
*       02-14-95  CFW   Clean up Mac merge.
*       03-29-95  CFW   Add error message to internal headers.
*       12-14-95  JWM   Add "#pragma once".
*       02-24-97  GJF   Detab-ed.
*       05-17-99  PML   Remove all Macintosh support.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_EHHOOKS
#define _INC_EHHOOKS

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

/* Private Revectoring control for _inconsistency() faults */

typedef void (__cdecl *_inconsistency_function)();
void __cdecl _inconsistency(void);
_inconsistency_function __cdecl __set_inconsistency(_inconsistency_function);


/* Thread specific pointers to handler functions */

#ifdef  _MT
#define __pTerminate     (*((terminate_function*) &(_getptd()->_terminate)))
#define __pUnexpected    (*((unexpected_function*) &(_getptd()->_unexpected)))
#define __pSETranslator  (*((_se_translator_function*) &(_getptd()->_translator)))
#else
extern terminate_function __pTerminate;
extern unexpected_function __pUnexpected;
extern _se_translator_function __pSETranslator;
#endif

extern _inconsistency_function __pInconsistency;

//
// This filter needs to be dragged in for any exe which has any eh.
//
LONG WINAPI __CxxUnhandledExceptionFilter( LPEXCEPTION_POINTERS );

#endif  /* _INC_EHHOOKS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\errmsg.h ===
/***
*errmsg.h - defines error message numbers
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the constants for error message numbers.
*       Same as errmsg.inc
*
*       [Internal]
*
*Revision History:
*       08-03-89  GJF   Fixed copyright
*       10-30-89  GJF   Fixed copyright
*       02-28-90  GJF   Added #ifndef _INC_ERRMSG stuff
*       02-14-95  CFW   Clean up Mac merge.
*       03-29-95  CFW   Add error message to internal headers.
*       12-14-95  JWM   Add "#pragma once".
*       02-24-97  GJF   Detab-ed.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_ERRMSG

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#define STCKOVR 0
#define NULLERR 1
#define NOFP    2
#define DIVZR   3
#define BADVERS 4
#define NOMEM   5
#define BADFORM 6
#define BADENV  7
#define NOARGV  8
#define NOENVP  9
#define ABNORM  10
#define UNKNOWN 11

#define CRT_NERR 11

#define _INC_ERRMSG
#endif  /* _INC_ERRMSG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\except.inc ===
;***
;except.inc - definitions for exception handling
;
;	Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Structure and constant definitions used by exception handling code.
;
;Revision History:
;	07-19-90  GJF	Module created.
;	08-28-90  GJF	Added some definitions of exceptions.
;	10-19-90  GJF	Revised some constants to agree with the definitions in
;			\\os2rel\public!2.0\h\bsexcpt.h (dated 10-1-90).
;	07-30-91  GJF	Different values of _XCPT_CONTINUE_[SEARCH|EXECUTION]
;			for Cruiser and Win32 [_WIN32_].
;	09-07-94  CFW	Remove _CRUISER.
;
;*******************************************************************************

; structure used by SEH support function and intrinsics. the information
; passed by the OS exception dispatcher is repackaged in this form by the
; runtime (_except_handler()).

__EXCEPTION_INFO_PTRS struc
	preport 		dd	?
	pcontext		dd	?
__EXCEPTION_INFO_PTRS ends


; exception registration record structure.

__EXCEPTIONREGISTRATIONRECORD struc
	prev_structure		dd	?
	ExceptionHandler	dd	?
	ExceptionFilter 	dd	?
	FilterFrame		dd	?
	PExceptionInfoPtrs	dd	?
__EXCEPTIONREGISTRATIONRECORD ends

; size of exception registration record in double words

DWORDS_IN_XREGREC	equ	5


; exception report record

__EXCEPTIONREPORTRECORD struc
	ExceptionNum		dd	?
	fHandlerFlags		dd	?
	ExceptionReportRecord	dd	?
	ExceptionAddress	dd	?
	cParameters		dd	?
	ExceptionInfo		dd	4 dup (?)
__EXCEPTIONREPORTRECORD ends


; setjmp/longjmp buffer (i.e., structure underlying jmp_buf array)

_JMP_BUF	struc
	ebpsave 		dd	?
	ebxsave 		dd	?
	edisave 		dd	?
	esisave 		dd	?
	espsave 		dd	?
	retsave 		dd	?
	xcptsave		dd	?
_JMP_BUF	ends


; exceptions corresponding to C runtime errors (these are explicitly
; referenced in the startup code)

_XCPT_UNABLE_TO_GROW_STACK	equ		080010001h
_XCPT_INTEGER_DIVIDE_BY_ZERO	equ		0C000009Bh
_XCPT_NONCONTINUABLE_EXCEPTION	equ		0C0000024h
_XCPT_INVALID_DISPOSITION	equ		0C0000025h
_XCPT_SIGABRT			equ		020000001h


; unwind settings in fHandlerFlags

_EH_UNWINDING	equ	2
_EH_EXIT_UNWIND equ	4
UNWIND		equ	_EH_UNWINDING OR _EH_EXIT_UNWIND


; return values (to the exception dispatcher)

IFDEF	_WIN32

_XCPT_CONTINUE_SEARCH		equ	000000001h
_XCPT_CONTINUE_EXECUTION	equ	000000000h

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\file2.h ===
/***
*file2.h - auxiliary file structure used internally by file run-time routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the auxiliary file structure used internally by
*       the file run time routines.
*
*       [Internal]
*
*Revision History:
*       06-29-87  JCR   Removed _OLD_IOLBF/_OLD_IOFBF and associated lbuf macro.
*       09-28-87  JCR   Added _iob_index(); modified ybuf() and tmpnum() to use it.
*       06-03-88  JCR   Added _iob2_ macro; modified ybuf()/tmpnum()/_iob_index;
*                       also padded FILE2 definition to be the same size as FILE.
*       06-10-88  JCR   Added ybuf2()/bigbuf2()/anybuf2()
*       06-14-88  JCR   Added (FILE *) casts to _iob_index() macro
*       06-29-88  JCR   Added _IOFLRTN bit (flush stream on per routine basis)
*       08-18-88  GJF   Revised to also work with the 386 (small model only).
*       12-05-88  JCR   Added _IOCTRLZ bit (^Z encountered by lowio read)
*       04-11-89  JCR   Removed _IOUNGETC bit (no longer needed)
*       07-27-89  GJF   Cleanup, now specific to the 386. Struct field
*                       alignment is now protected by pack pragma.
*       10-30-89  GJF   Fixed copyright
*       02-16-90  GJF   _iob[], _iob2[] merge
*       02-21-90  GJF   Restored _iob_index() macro
*       02-28-90  GJF   Added #ifndef _INC_FILE2 stuff. Also, removed some
*                       (now) useless preprocessor directives.
*       07-11-90  SBM   Added _IOCOMMIT bit (lowio commit on fflush call)
*       03-11-92  GJF   Removed _tmpnum() macro for Win32.
*       06-03-92  KRS   Added extern "C" stuff.
*       02-23-93  SKS   Update copyright to 1993
*       06-22-93  GJF   Added _IOSETVBUF flag.
*       09-06-94  CFW   Remove Cruiser support.
*       02-14-95  CFW   Clean up Mac merge.
*       03-06-95  GJF   Removed _iob_index().
*       03-29-95  CFW   Add error message to internal headers.
*       12-14-95  JWM   Add "#pragma once".
*       02-24-97  GJF   Detab-ed.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_FILE2
#define _INC_FILE2

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  __cplusplus
extern "C" {
#endif

/* Additional _iobuf[]._flag values
 *
 *  _IOSETVBUF - Indicates file was buffered via a setvbuf (or setbuf call).
 *               Currently used ONLY in _filbuf.c, _getbuf.c, fseek.c and
 *               setvbuf.c, to disable buffer resizing on "random access"
 *               files if the buffer was user-installed.
 */

#define _IOYOURBUF      0x0100
#define _IOSETVBUF      0x0400
#define _IOFEOF         0x0800
#define _IOFLRTN        0x1000
#define _IOCTRLZ        0x2000
#define _IOCOMMIT       0x4000


/* General use macros */

#define inuse(s)        ((s)->_flag & (_IOREAD|_IOWRT|_IORW))
#define mbuf(s)         ((s)->_flag & _IOMYBUF)
#define nbuf(s)         ((s)->_flag & _IONBF)
#define ybuf(s)         ((s)->_flag & _IOYOURBUF)
#define bigbuf(s)       ((s)->_flag & (_IOMYBUF|_IOYOURBUF))
#define anybuf(s)       ((s)->_flag & (_IOMYBUF|_IONBF|_IOYOURBUF))

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_FILE2 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\fcntl.h ===
/***
*fcntl.h - file control options used by open()
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines constants for the file control options used
*       by the _open() function.
*       [System V]
*
*       [Public]
*
*Revision History:
*       06-19-87  JCR   Added O_NOINHERIT
*       08-18-88  GJF   Modified (slightly) to also work for the 386.
*       08-01-89  GJF   Fixed copyright
*       10-30-89  GJF   Fixed copyright
*       02-28-90  GJF   Added #ifndef _INC_FCNTL stuff. Made the definition
*                       of O_BINARY a 32-bit constant unconditionally.
*       01-17-91  GJF   ANSI naming.
*       03-30-92  DJM   POSIX support.
*       05-02-92  SRW   Add support for _O_TEMPORARY flag
*       04-07-93  SKS   Fix copyright
*       05-24-93  PML   Add support for _O_SHORT_LIVED, _O_SEQUENTIAL,
*                       _O_RANDOM
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       12-14-95  JWM   Add "#pragma once".
*       02-24-97  GJF   Detab-ed.
*       05-17-99  PML   Remove all Macintosh support.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_FCNTL
#define _INC_FCNTL

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#define _O_RDONLY       0x0000  /* open for reading only */
#define _O_WRONLY       0x0001  /* open for writing only */
#define _O_RDWR         0x0002  /* open for reading and writing */
#define _O_APPEND       0x0008  /* writes done at eof */

#define _O_CREAT        0x0100  /* create and open file */
#define _O_TRUNC        0x0200  /* open and truncate */
#define _O_EXCL         0x0400  /* open only if file doesn't already exist */

/* O_TEXT files have <cr><lf> sequences translated to <lf> on read()'s,
** and <lf> sequences translated to <cr><lf> on write()'s
*/

#define _O_TEXT         0x4000  /* file mode is text (translated) */
#define _O_BINARY       0x8000  /* file mode is binary (untranslated) */

/* macro to translate the C 2.0 name used to force binary mode for files */

#define _O_RAW  _O_BINARY

/* Open handle inherit bit */

#define _O_NOINHERIT    0x0080  /* child process doesn't inherit file */

/* Temporary file bit - file is deleted when last handle is closed */

#define _O_TEMPORARY    0x0040  /* temporary file bit */

/* temporary access hint */

#define _O_SHORT_LIVED  0x1000  /* temporary storage file, try not to flush */

/* sequential/random access hints */

#define _O_SEQUENTIAL   0x0020  /* file access is primarily sequential */
#define _O_RANDOM       0x0010  /* file access is primarily random */

#if     !__STDC__ || defined(_POSIX_)
/* Non-ANSI names for compatibility */
#define O_RDONLY        _O_RDONLY
#define O_WRONLY        _O_WRONLY
#define O_RDWR          _O_RDWR
#define O_APPEND        _O_APPEND
#define O_CREAT         _O_CREAT
#define O_TRUNC         _O_TRUNC
#define O_EXCL          _O_EXCL
#define O_TEXT          _O_TEXT
#define O_BINARY        _O_BINARY
#define O_RAW           _O_BINARY
#define O_TEMPORARY     _O_TEMPORARY
#define O_NOINHERIT     _O_NOINHERIT
#define O_SEQUENTIAL    _O_SEQUENTIAL
#define O_RANDOM        _O_RANDOM
#endif  /* __STDC__ */

#endif  /* _INC_FCNTL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\fpieee.h ===
/***
*fpieee.h - Definitions for floating point IEEE exception handling
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains constant and type definitions for handling
*       floating point exceptions [ANSI/IEEE std. 754]
*
*       [Public]
*
*Revision History:
*       03-01-92  GDP   written
*       04-05-92  GDP   calling convention macros
*       01-21-93  GJF   Removed support for C6-386's _cdecl.
*       04-06-93  SKS   Replace _CRTAPI1/2 with __cdecl, _CRTVAR1 with nothing
*       09-01-93  GJF   Merged Cuda and NT SDK versions.
*       09-24-93  GJF   Removed dummy args from _fpieee_flt prototype.
*       01-13-94  RDL   Added #ifndef _LANGUAGE_ASSEMBLY for asm includes.
*       01-24-94  GJF   Merged in 01-13 change above (from crt32 tree on
*                       \\orville\razzle).
*       11-03-94  GJF   Ensure 8 byte alignment.
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       12-14-95  JWM   Add "#pragma once".
*       02-21-97  GJF   Cleaned out obsolete support for _CRTAPI* and _NTSDK.
*                       Also, detab-ed.
*       09-30-97  JWM   Restored not-so-obsolete _CRTAPI1 support.
*       10-07-97  RDL   Added IA64.
*       09-11-98  JWM   Added Katmai exception support.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*       03-01-00  PML   Add WNI exception support.
*       09-14-00  PML   Add alignment for 64-bit, 128-bit types (vs7#160260).
*       03-24-01  PML   Enable 64-bit/128-bit type alignment on x86.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_FPIEEE
#define _INC_FPIEEE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _INTERNAL_IFSTRIP_
#include <cruntime.h>
#endif  /* _INTERNAL_IFSTRIP_ */


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/*
 * Define floating point IEEE compare result values.
 */

typedef enum {
    _FpCompareEqual,
    _FpCompareGreater,
    _FpCompareLess,
    _FpCompareUnordered
} _FPIEEE_COMPARE_RESULT;

/*
 * Define floating point format and result precision values.
 */

typedef enum {
    _FpFormatFp32,
    _FpFormatFp64,
    _FpFormatFp80,
    _FpFormatFp128,
    _FpFormatI16,
    _FpFormatI32,
    _FpFormatI64,
    _FpFormatU16,
    _FpFormatU32,
    _FpFormatU64,
    _FpFormatBcd80,
    _FpFormatCompare,
    _FpFormatString,
#if defined(_M_IA64)
    _FpFormatFp82
#endif
} _FPIEEE_FORMAT;

/*
 * Define operation code values.
 */

typedef enum {
    _FpCodeUnspecified,
    _FpCodeAdd,
    _FpCodeSubtract,
    _FpCodeMultiply,
    _FpCodeDivide,
    _FpCodeSquareRoot,
    _FpCodeRemainder,
    _FpCodeCompare,
    _FpCodeConvert,
    _FpCodeRound,
    _FpCodeTruncate,
    _FpCodeFloor,
    _FpCodeCeil,
    _FpCodeAcos,
    _FpCodeAsin,
    _FpCodeAtan,
    _FpCodeAtan2,
    _FpCodeCabs,
    _FpCodeCos,
    _FpCodeCosh,
    _FpCodeExp,
    _FpCodeFabs,
    _FpCodeFmod,
    _FpCodeFrexp,
    _FpCodeHypot,
    _FpCodeLdexp,
    _FpCodeLog,
    _FpCodeLog10,
    _FpCodeModf,
    _FpCodePow,
    _FpCodeSin,
    _FpCodeSinh,
    _FpCodeTan,
    _FpCodeTanh,
    _FpCodeY0,
    _FpCodeY1,
    _FpCodeYn,
    _FpCodeLogb,
    _FpCodeNextafter,
    _FpCodeNegate, 
    _FpCodeFmin,         //XMMI
    _FpCodeFmax,         //XMMI
    _FpCodeConvertTrunc, //XMMI
    _XMMIAddps,          //XMMI
    _XMMIAddss,
    _XMMISubps,
    _XMMISubss,
    _XMMIMulps,
    _XMMIMulss,
    _XMMIDivps,
    _XMMIDivss,
    _XMMISqrtps,
    _XMMISqrtss,
    _XMMIMaxps,
    _XMMIMaxss,
    _XMMIMinps,
    _XMMIMinss,
    _XMMICmpps,
    _XMMICmpss,
    _XMMIComiss,
    _XMMIUComiss,
    _XMMICvtpi2ps,
    _XMMICvtsi2ss,
    _XMMICvtps2pi,
    _XMMICvtss2si,
    _XMMICvttps2pi,
    _XMMICvttss2si,
    _XMMI2Addpd,         //XMMI2 
    _XMMI2Addsd,
    _XMMI2Subpd,
    _XMMI2Subsd,
    _XMMI2Mulpd,
    _XMMI2Mulsd,
    _XMMI2Divpd,
    _XMMI2Divsd,
    _XMMI2Sqrtpd,
    _XMMI2Sqrtsd,
    _XMMI2Maxpd,
    _XMMI2Maxsd,
    _XMMI2Minpd,
    _XMMI2Minsd,
    _XMMI2Cmppd,
    _XMMI2Cmpsd,
    _XMMI2Comisd,
    _XMMI2UComisd,
    _XMMI2Cvtpd2pi,   //66 2D
    _XMMI2Cvtsd2si,   //F2
    _XMMI2Cvttpd2pi,  //66 2C
    _XMMI2Cvttsd2si,  //F2
    _XMMI2Cvtps2pd,   //0F 5A
    _XMMI2Cvtss2sd,   //F3
    _XMMI2Cvtpd2ps,   //66
    _XMMI2Cvtsd2ss,   //F2
    _XMMI2Cvtdq2ps,   //0F 5B
    _XMMI2Cvttps2dq,  //F3
    _XMMI2Cvtps2dq,   //66
    _XMMI2Cvttpd2dq,  //66 0F E6
    _XMMI2Cvtpd2dq,   //F2 
#if defined(_M_IA64)
    _FpCodeFma,
    _FpCodeFmaSingle,
    _FpCodeFmaDouble,
    _FpCodeFms,
    _FpCodeFmsSingle,
    _FpCodeFmsDouble,
    _FpCodeFnma,
    _FpCodeFnmaSingle,
    _FpCodeFnmaDouble,
    _FpCodeFamin,
    _FpCodeFamax
#endif
} _FP_OPERATION_CODE;

#endif  /* #ifndef __assembler */
#ifndef _INTERNAL_IFSTRIP_
#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

#define OP_UNSPEC    _FpCodeUnspecified
#define OP_ADD       _FpCodeAdd
#define OP_SUB       _FpCodeSubtract
#define OP_MUL       _FpCodeMultiply
#define OP_DIV       _FpCodeDivide
#define OP_REM       _FpCodeRemainder
#define OP_COMP      _FpCodeCompare
#define OP_CVT       _FpCodeConvert
#define OP_RND       _FpCodeRound
#define OP_TRUNC     _FpCodeTruncate

#define OP_EXP       _FpCodeExp

#define OP_POW       _FpCodePow
#define OP_LOG       _FpCodeLog
#define OP_LOG10     _FpCodeLog10
#define OP_SINH      _FpCodeSinh
#define OP_COSH      _FpCodeCosh
#define OP_TANH      _FpCodeTanh
#define OP_ASIN      _FpCodeAsin
#define OP_ACOS      _FpCodeAcos
#define OP_ATAN      _FpCodeAtan
#define OP_ATAN2     _FpCodeAtan2
#define OP_SQRT      _FpCodeSquareRoot
#define OP_SIN       _FpCodeSin
#define OP_COS       _FpCodeCos
#define OP_TAN       _FpCodeTan
#define OP_CEIL      _FpCodeCeil
#define OP_FLOOR     _FpCodeFloor
#define OP_ABS       _FpCodeFabs
#define OP_MODF      _FpCodeModf
#define OP_LDEXP     _FpCodeLdexp
#define OP_CABS      _FpCodeCabs
#define OP_HYPOT     _FpCodeHypot
#define OP_FMOD      _FpCodeFmod
#define OP_FREXP     _FpCodeFrexp
#define OP_Y0        _FpCodeY0
#define OP_Y1        _FpCodeY1
#define OP_YN        _FpCodeYn

#define OP_LOGB       _FpCodeLogb
#define OP_NEXTAFTER  _FpCodeNextafter

//XMMI
#define OP_ADDPS     _XMMIAddps
#define OP_ADDSS     _XMMIAddss
#define OP_SUBPS     _XMMISubps
#define OP_SUBSS     _XMMISubss
#define OP_MULPS     _XMMIMulps
#define OP_MULSS     _XMMIMulss
#define OP_DIVPS     _XMMIDivps
#define OP_DIVSS     _XMMIDivss
#define OP_SQRTPS    _XMMISqrtps
#define OP_SQRTSS    _XMMISqrtss
#define OP_MAXPS     _XMMIMaxps
#define OP_MAXSS     _XMMIMaxss
#define OP_MINPS     _XMMIMinps
#define OP_MINSS     _XMMIMinss
#define OP_CMPPS     _XMMICmpps
#define OP_CMPSS     _XMMICmpss
#define OP_COMISS    _XMMIComiss
#define OP_UCOMISS   _XMMIUComiss
#define OP_CVTPI2PS  _XMMICvtpi2ps
#define OP_CVTSI2SS  _XMMICvtsi2ss
#define OP_CVTPS2PI  _XMMICvtps2pi
#define OP_CVTSS2SI  _XMMICvtss2si
#define OP_CVTTPS2PI _XMMICvttps2pi
#define OP_CVTTSS2SI _XMMICvttss2si
//XMMI

//XMMI2
#define OP_ADDPD     _XMMI2Addpd         //XMMI2 
#define OP_ADDSD     _XMMI2Addsd
#define OP_SUBPD     _XMMI2Subpd
#define OP_SUBSD     _XMMI2Subsd
#define OP_MULPD     _XMMI2Mulpd
#define OP_MULSD     _XMMI2Mulsd
#define OP_DIVPD     _XMMI2Divpd
#define OP_DIVSD     _XMMI2Divsd
#define OP_SQRTPD    _XMMI2Sqrtpd
#define OP_SQRTSD    _XMMI2Sqrtsd
#define OP_MAXPD     _XMMI2Maxpd
#define OP_MAXSD     _XMMI2Maxsd
#define OP_MINPD     _XMMI2Minpd
#define OP_MINSD     _XMMI2Minsd
#define OP_CMPPD     _XMMI2Cmppd
#define OP_CMPSD     _XMMI2Cmpsd
#define OP_COMISD    _XMMI2Comisd
#define OP_UCOMISD   _XMMI2UComisd
#define OP_CVTPD2PI  _XMMI2Cvtpd2pi   //66 2D
#define OP_CVTSD2SI  _XMMI2Cvtsd2si   //F2
#define OP_CVTTPD2PI _XMMI2Cvttpd2pi  //66 2C
#define OP_CVTTSD2SI _XMMI2Cvttsd2si  //F2
#define OP_CVTPS2PD  _XMMI2Cvtps2pd   //0F 5A
#define OP_CVTSS2SD  _XMMI2Cvtss2sd   //F3
#define OP_CVTPD2PS  _XMMI2Cvtpd2ps   //66
#define OP_CVTSD2SS  _XMMI2Cvtsd2ss   //F2
#define OP_CVTDQ2PS  _XMMI2Cvtdq2ps   //0F 5B
#define OP_CVTTPS2DQ _XMMI2Cvttps2dq  //F3
#define OP_CVTPS2DQ  _XMMI2Cvtps2dq   //66
#define OP_CVTTPD2DQ _XMMI2Cvttpd2dq  //66 0F E6
#define OP_CVTPD2DQ  _XMMI2Cvtpd2dq   //F2
//XMMI2

#else   /* #ifndef __assembler */

/* This must be the same as the enumerator _FP_OPERATION_CODE ! */
#define OP_UNSPEC    0
#define OP_ADD       1
#define OP_SUB       2
#define OP_MUL       3
#define OP_DIV       4
#define OP_SQRT      5
#define OP_REM       6
#define OP_COMP      7
#define OP_CVT       8
#define OP_RND       9
#define OP_TRUNC     10
#define OP_FLOOR     11
#define OP_CEIL      12
#define OP_ACOS      13
#define OP_ASIN      14
#define OP_ATAN      15
#define OP_ATAN2     16
#define OP_CABS      17
#define OP_COS       18
#define OP_COSH      19
#define OP_EXP       20
#define OP_ABS       21         /* same as OP_FABS */
#define OP_FABS      21         /* same as OP_ABS  */
#define OP_FMOD      22
#define OP_FREXP     23
#define OP_HYPOT     24
#define OP_LDEXP     25
#define OP_LOG       26
#define OP_LOG10     27
#define OP_MODF      28
#define OP_POW       29
#define OP_SIN       30
#define OP_SINH      31
#define OP_TAN       32
#define OP_TANH      33
#define OP_Y0        34
#define OP_Y1        35
#define OP_YN        36
#define OP_LOGB       37
#define OP_NEXTAFTER  38
#define OP_NEG       39

#endif  /* #ifndef __assembler */
#endif  /* _INTERNAL_IFSTRIP_ */

/*
 * Define rounding modes.
 */

#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

typedef enum {
    _FpRoundNearest,
    _FpRoundMinusInfinity,
    _FpRoundPlusInfinity,
    _FpRoundChopped
} _FPIEEE_ROUNDING_MODE;

typedef enum {
    _FpPrecisionFull,
    _FpPrecision53,
    _FpPrecision24,
#if defined(_M_IA64)
    _FpPrecision64,
    _FpPrecision113
#endif
} _FPIEEE_PRECISION;


/*
 * Define floating point context record
 */

typedef float           _FP32;
typedef double          _FP64;
typedef short           _I16;
typedef int             _I32;
typedef unsigned short  _U16;
typedef unsigned int    _U32;
typedef __int64         _Q64;

#ifndef _INTERNAL_IFSTRIP_
typedef struct {
    unsigned long W[4];
} _U32ARRAY;
#endif  /* _INTERNAL_IFSTRIP_ */

typedef struct
#if defined(_M_IA64)
    __declspec(align(16))
#endif
{
    unsigned short W[5];
} _FP80;

typedef struct __declspec(align(16))
{
    unsigned long W[4];
} _FP128;

typedef struct __declspec(align(8))
{
    unsigned long W[2];
} _I64;

typedef struct __declspec(align(8))
{
    unsigned long W[2];
} _U64;

typedef struct
#if defined(_M_IA64)
    __declspec(align(16))
#endif
{
    unsigned short W[5];
} _BCD80;

typedef struct __declspec(align(16))
{
    _Q64 W[2];
} _FPQ64;

typedef struct {
    union {
        _FP32        Fp32Value;
        _FP64        Fp64Value;
        _FP80        Fp80Value;
        _FP128       Fp128Value;
        _I16         I16Value;
        _I32         I32Value;
        _I64         I64Value;
        _U16         U16Value;
        _U32         U32Value;
        _U64         U64Value;
        _BCD80       Bcd80Value;
        char         *StringValue;
        int          CompareValue;
#ifndef _INTERNAL_IFSTRIP_
        _U32ARRAY    U32ArrayValue;
#endif  /* _INTERNAL_IFSTRIP_ */
        _Q64         Q64Value;
        _FPQ64       Fpq64Value;
    } Value;

    unsigned int OperandValid : 1;
    unsigned int Format : 4;

} _FPIEEE_VALUE;


typedef struct {
    unsigned int Inexact : 1;
    unsigned int Underflow : 1;
    unsigned int Overflow : 1;
    unsigned int ZeroDivide : 1;
    unsigned int InvalidOperation : 1;
} _FPIEEE_EXCEPTION_FLAGS;


typedef struct {
    unsigned int RoundingMode : 2;
    unsigned int Precision : 3;
    unsigned int Operation :12;
    _FPIEEE_EXCEPTION_FLAGS Cause;
    _FPIEEE_EXCEPTION_FLAGS Enable;
    _FPIEEE_EXCEPTION_FLAGS Status;
    _FPIEEE_VALUE Operand1;
    _FPIEEE_VALUE Operand2;
    _FPIEEE_VALUE Result;
#if defined(_M_IA64)
    _FPIEEE_VALUE Operand3;
#endif
} _FPIEEE_RECORD, *_PFPIEEE_RECORD;


struct _EXCEPTION_POINTERS;

/*
 * Floating point IEEE exception filter routine
 */

_CRTIMP int __cdecl _fpieee_flt(
        unsigned long,
        struct _EXCEPTION_POINTERS *,
        int (__cdecl *)(_FPIEEE_RECORD *)
        );

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */
#endif  /* #ifndef __assembler */

#endif  /* _INC_FPIEEE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\heap.h ===
/***
*heap.h - Heap code include file
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains information needed by the C library heap code.
*
*       [Internal]
*
*Revision History:
*       05-16-89  JCR   Module created
*       06-02-89  GJF   Removed naming conflict
*       06-29-89  JCR   Completely new for "New heap - rev 2"
*       06-29-89  GJF   Added _HDRSIZE, fixed some minor glitches.
*       06-29-89  GJF   Added _BLKSIZE(), fixed more minor bugs.
*       06-30-89  GJF   Changed several macros to operate on a pointer to a
*                       descriptor, rather than a descriptor itself.
*       06-30-89  JCR   Corrected/updated several macros
*       07-06-89  JCR   Added region support, misc improvements, etc.
*       07-07-89  GJF   Minor bug in _ROUND() macro
*       07-07-89  JCR   Added _DUMMY status
*       07-19-89  GJF   Removed _PBACKPTR macro
*       07-20-89  JCR   Region routine prototypes, _HEAPFIND values
*       07-21-89  JCR   #define _heap_growsize to _amblksiz for compatibility
*       07-25-89  GJF   Added prototypes for calloc, free and malloc
*       07-28-89  GJF   Added prototype for _msize
*       08-28-89  JCR   Added _HEAP_COALESCE value
*       10-30-89  GJF   Fixed copyright
*       11-03-89  GJF   Added _DISTTOBNDRY(), _NEXTSEGBNDRY() macros and
*                       prototypes for _flat_malloc(), _heap_advance_rover(),
*                       _heap_split_block() functions
*       11-07-89  GJF   Added _SEGSIZE_, added prototype for _heap_search()
*                       restored function prototype for_heap_grow_region()
*       11-08-89  JCR   Added non-pow2 rounding macro
*       11-10-89  JCR   Added _heap_free_region prototype
*       11-10-89  GJF   Added prototypes and macros for multi-thread support
*       11-16-89  JCR   If DEBUG defined include <assert.h>, added sanity check
*       12-13-89  GJF   Removed prototypes duplicated in malloc.h
*       12-20-89  GJF   Removed plastdesc from _heap_desc_ struct, removed
*                       _DELHEAP and _ADDHEAP macros (unused and wrong), added
*                       explicit _cdecl to function prototypes
*       01-08-89  GJF   Use assert macro from assertm.h instead of assert.h
*       03-01-90  GJF   Added #ifndef _INC_HEAP and #include <cruntime.h>
*                       stuff. Also, removed some unused DEBUG286 stuff.
*       03-22-90  GJF   Replaced _cdecl with _CALLTYPE1 in prototypes.
*       07-25-90  SBM   Replaced <assertm.h> by <assert.h>
*       08-13-90  SBM   Added casts to macros for clean compiles at -W3
*       12-28-90  SRW   Fixed _heap_split_block prototype to match code
*       12-28-90  SRW   Changed _HEAP_GROWSIZE to be 0x10000 [_WIN32_]
*       03-05-91  GJF   Added decl for _heap_resetsize, removed proto for
*                       _heap_advance_rover (both conditioned on _OLDROVER_
*                       not being #define-d).
*       03-13-91  GJF   Made _HEAP_GROWSIZE 32K for [_CRUISER_].
*       04-09-91  PNT   Added _MAC_ definitions
*       08-20-91  JCR   C++ and ANSI naming
*       03-30-92  DJM   POSIX support.
*       08-06-92  GJF   Function calling type and variable type macros.
*       01-21-93  GJF   Removed support for C6-386's _cdecl.
*       04-06-93  SKS   Replace _CRTAPI1/2 with __cdecl, _CRTVAR1 with nothing
*       04-16-93  SKS   Change _HEAP_REGIONSIZE from 4 MB to 16 KB.
*                       Low memory environments such as Win32S cannot commit
*                       memory without actually allocating it.
*       04-20-93  SKS   Add new constant _HEAP_MAXREGIONSIZE.
*       04-26-93  SKS   Constants _HEAP_REGIONSIZE and _HEAP_MAXREGIONSIZE
*                       split to handle both small and large memory modes
*                       _HEAP_MAXREGIONSIZE becomes variable "_heap_maxregsize"
*       09-01-93  GJF   Merged NT SDK and Cuda version (this include file is
*                       not used for the winheap\*.* heap manager).
*       12-09-93  GJF   Added _GRANULARITY and defined _HDRSIZE in terms of it.
*       12-13-93  SKS   Add _heapused_lk().  Move here declarations of
*                       _heap_descpages and _HEAP_EMPTYLIST_SIZE.
*       03-02-94  GJF   Deleted _GETEMPTY() macro and prototype for
*                       _heap_grow_emptylist() (now static). Added prototype
*                       for __getempty(). Changed _heap_split_block() return
*                       type.
*       03-31-94  GJF   Made declarations of:
*                           _heap_descpages
*                           _heap_maxregsize
*                           _heap_regions
*                           _heap_regionsize
*                           _heap_resetsize
*                       conditional on ndef DLL_FOR_WIN32S. Also, made the
*                       definition of _heap_growsize conditional in the same
*                       manner and conditionally include win32s.h.
*       07-29-94  GJF   Page are twice as big on the DEC Alpha.
*       08-04-94  GJF   DEC Alpha needs 8 byte alignment too.
*       09-06-94  CFW   Remove _CRTHEAP_ switch.
*       09-21-94  SKS   Fix typo: no leading _ on "DLL_FOR_WIN32S"
*       10-09-94  BWT   PPC changes from John Morgan.
*       11-02-94  SKS   Change _HEAP_MAXREGIONSIZE_S from 256 KB to 16 MB
*                       (same as _HEAP_MAXREGIONSIZE_L) for users who want a
*                       LOT of memory under Win32s.  This is reasonable now
*                       that Win32s supports reserved but uncommitted memory.
*       12-05-94  CFW   Fix debug new handler support.
*       02-06-95  GJF   Removed some of the Mac-merge changes.
*       02-06-95  CFW   Remove assert.h, DEBUG -> _DEBUG
*       02-14-95  CFW   Clean up Mac merge.
*       03-29-95  CFW   Add error message to internal headers.
*       04-24-95  CFW   Add heap hook.
*       12-14-95  JWM   Add "#pragma once".
*       04-23-96  SKS   Return type of _heap_init changed from void to int.
*       02-21-97  GJF   Cleaned out obsolete support for DLL_FOR_WIN32S.
*                       Replaced defined(_M_MPPC) || defined(_M_M68K) with
*                       defined(_MAC). Also, detab-ed.
*       10-07-97  RDL   Added IA64.
*       05-17-99  PML   Remove all Macintosh support.
*       07-07-99  AWB   Changes for 64-bit size_t. (v-aborni)
*       10-06-99  PML   Add _W64 modifier to types which are 32 bits in Win32,
*                       64 bits in Win64.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_HEAP
#define _INC_HEAP

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  __cplusplus
extern "C" {
#endif

#include <cruntime.h>


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/*
 * Heap block descriptor
 */

struct _block_descriptor {
        struct _block_descriptor *pnextdesc;    /* ptr to next descriptor */
        void *pblock;               /* ptr to memory block */
};

#define _BLKDESC    struct _block_descriptor
#define _PBLKDESC   struct _block_descriptor *


/*
 * Useful constants
 */

/*
 * Unit of allocation. All allocations are of size n * _GRANULARITY. Note
 * that _GRANULARITY must be a power of 2, or it cannot be used with the
 * _ROUND2 macro.
 */
#if     defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)
#define _GRANULARITY    8
#else
#define _GRANULARITY    4
#endif

/*
 * Size of the header in a memory block. Note that we must have
 * sizeof(void *) <= _HDRSIZE so the header is big enough to hold a pointer
 * to the descriptor.
 */

#define _HDRSIZE    1 * _GRANULARITY

/* _heapchk/_heapset parameter */
#define _HEAP_NOFILL    0x7FFFFFF


/*
 * Descriptor status values
 */

#define _INUSE      0
#define _FREE       1
#define _DUMMY      2


#if     _INUSE != 0 /*IFSTRIP=IGN*/
#error *** Heap code assumes _INUSE value is 0! ***
#endif


/*
 * Macros for manipulating heap memory block descriptors
 *      stat = one of the status values
 *      addr = user-visible address of a heap block
 */

#define _STATUS_MASK    0x3 /* last 2 bits are status */

#define _ADDRESS(pdesc)     ( (void *) ((unsigned)((pdesc)->pblock) & \
                    (~_STATUS_MASK)) )
#define _STATUS(pdesc)      ( (unsigned) ((unsigned)((pdesc)->pblock) & \
                    _STATUS_MASK) )

#define _SET_INUSE(pdesc)   ( pdesc->pblock = (void *) \
                       ((unsigned)_ADDRESS(pdesc) | _INUSE) )
#define _SET_FREE(pdesc)    ( pdesc->pblock = (void *) \
                       ((unsigned)_ADDRESS(pdesc) | _FREE) )
#define _SET_DUMMY(pdesc)   ( pdesc->pblock = (void *) \
                       ((unsigned)_ADDRESS(pdesc) | _DUMMY) )

#define _IS_INUSE(pdesc)    ( _STATUS(pdesc) == _INUSE )
#define _IS_FREE(pdesc)     ( _STATUS(pdesc) == _FREE )
#define _IS_DUMMY(pdesc)    ( _STATUS(pdesc) == _DUMMY )

#define _BLKSIZE(pdesc)     ( (unsigned) ( \
                      (char *)_ADDRESS(pdesc->pnextdesc) - \
                      (char *)_ADDRESS(pdesc) - _HDRSIZE ) )

#define _MEMSIZE(pdesc)     ( (char *)_ADDRESS(pdesc->pnextdesc) - \
                      (char *)_ADDRESS(pdesc) )

#define _BACKPTR(addr)      ( *(_PBLKDESC*)((char *)(addr) - _HDRSIZE) )

#define _CHECK_PDESC(pdesc) ( (*(_PBLKDESC*) (_ADDRESS(pdesc))) == pdesc )

#define _CHECK_BACKPTR(addr)    ( ((char *)(_BACKPTR(addr)->pblock) + _HDRSIZE) \
                    == addr)


/*
 * Heap descriptor
 */

struct _heap_desc_ {

        _PBLKDESC pfirstdesc;   /* pointer to first descriptor */
        _PBLKDESC proverdesc;   /* rover pointer */
        _PBLKDESC emptylist;    /* pointer to empty list */

        _BLKDESC  sentinel; /* Sentinel block for end of heap list */

};

extern struct _heap_desc_ _heap_desc;

/*
 * Region descriptor and heap grow data
 */

struct _heap_region_ {
        void * _regbase;    /* base address of region */
        unsigned _currsize; /* current size of region */
        unsigned _totalsize;    /* total size of region */
        };

#define _heap_growsize _amblksiz

#ifndef _OLDROVER_
extern unsigned int _heap_resetsize;
#endif  /* _OLDROVER_ */
extern unsigned int _heap_regionsize;
extern unsigned int _heap_maxregsize;
extern struct _heap_region_ _heap_regions[];
extern void ** _heap_descpages;

#ifdef  _M_ALPHA
#define _PAGESIZE_      0x2000      /* one page */
#else
#define _PAGESIZE_      0x1000      /* one page */
#endif

#define _SEGSIZE_       0x10000     /* one segment (i.e., 64 Kb) */

#define _HEAP_REGIONMAX     0x40        /* Max number of regions: 64 */
                                        /* For small memory systems: */
#define _HEAP_REGIONSIZE_S  0x4000      /* Initial region size (16K) */
#define _HEAP_MAXREGSIZE_S  0x1000000   /* Maximum region size (16M) */
                                        /* For large memory systems: */
#define _HEAP_REGIONSIZE_L  0x100000    /* Initial region size  (1M) */
#define _HEAP_MAXREGSIZE_L  0x1000000   /* Maximum region size (16M) */

#define _HEAP_GROWSIZE      0x10000     /* Default grow increment (64K) */

#define _HEAP_GROWMIN       _PAGESIZE_  /* Minimum grow inc (1 page) */
#define _HEAP_GROWSTART     _PAGESIZE_  /* Startup grow increment */
#define _HEAP_COALESCE      -1      /* Coalesce heap value */

#define _HEAP_EMPTYLIST_SIZE    (1 * _PAGESIZE_)

/*
 * Values returned by _heap_findaddr() routine
 */

#define _HEAPFIND_EXACT     0   /* found address exactly */
#define _HEAPFIND_WITHIN    1   /* address is within a block */
#define _HEAPFIND_BEFORE    -1  /* address before beginning of heap */
#define _HEAPFIND_AFTER     -2  /* address after end of heap */
#define _HEAPFIND_EMPTY     -3  /* address not found: empty heap */

/*
 * Arguments to _heap_param
 */

#define _HP_GETPARAM    0       /* get heap parameter value */
#define _HP_SETPARAM    1       /* set heap parameter value */

#define _HP_AMBLKSIZ    1       /* get/set _amblksiz value (aka */
#define _HP_GROWSIZE    _HP_AMBLKSIZ    /* _heap_growsize */
#define _HP_RESETSIZE   2       /* get/set _heap_resetsize value */


/*
 * Macros to round numbers
 *
 * _ROUND2 = rounds a number up to a power of 2
 * _ROUND = rounds a number up to any other numer
 *
 * n = number to be rounded
 * pow2 = must be a power of two value
 * r = any number
 */

#define _ROUND2(n,pow2) \
        ( ( n + pow2 - 1) & ~(pow2 - 1) )

#define _ROUND(n,r) \
        ( ( (n/r) + ((n%r)?1:0) ) * r)

/*

   Macros for accessing heap descriptor lists:

        _PUTEMPTY(x) = Puts an empty heap desc on the empty list

        (x = _PBLKDESC = pointer to heap block descriptor)
*/

#ifdef  _DEBUG

#define _PUTEMPTY(x) \
{                               \
        (x)->pnextdesc = _heap_desc.emptylist;      \
                                \
        (x)->pblock = NULL;             \
                                \
        _heap_desc.emptylist = (x);         \
}

#else

#define _PUTEMPTY(x) \
{                               \
        (x)->pnextdesc = _heap_desc.emptylist;      \
                                \
        _heap_desc.emptylist = (x);         \
}

#endif


/*
 * Macros for finding the next 64 Kb boundary from a pointer
 */

#define _NXTSEGBNDRY(p)     ((void *)((unsigned)(p) & 0xffff0000 + 0x10000))

#define _DISTTOBNDRY(p)     ((unsigned)(0x10000 - (0x0000ffff & (unsigned)(p))))


/*
 * Define size_t type (if necessary)
 */

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300 /*IFSTRIP=IGN*/
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


/*
 * Prototypes
 */

void * __cdecl _nh_malloc(size_t, int);
void * __cdecl _heap_alloc(size_t);
void * __cdecl _flat_malloc(size_t);
_PBLKDESC __getempty(void);
void __cdecl _heap_abort(void);
int __cdecl _heap_addblock(void *, unsigned int);

#ifdef  _OLDROVER_
void __cdecl _heap_advance_rover(void);
#endif  /* _OLDROVER_ */

void __cdecl _heap_free_region(int);
int __cdecl _heap_findaddr(void *, _PBLKDESC *);
int __cdecl _heap_grow(unsigned int);
int __cdecl _heap_grow_region(unsigned, size_t);
#ifndef _XBOX
int __cdecl _heap_init(void);
#endif

#ifndef _OLDROVER_
int __cdecl _heap_param(int, int, void *);
#endif  /* _OLDROVER_ */

_PBLKDESC __cdecl _heap_search(unsigned size);
_PBLKDESC __cdecl _heap_split_block(_PBLKDESC, size_t);

#ifdef  _DEBUG
void __cdecl _heap_print_all(void);
void __cdecl _heap_print_regions(void);
void __cdecl _heap_print_desc(void);
void __cdecl _heap_print_emptylist(void);
void __cdecl _heap_print_heaplist(void);
#endif


/*
 * Prototypes and macros for multi-thread support
 */

#ifdef  _MT

void __cdecl _free_lk(void *);
size_t __cdecl _msize_lk(void *);
size_t __cdecl _heapused_lk(size_t *pUsed, size_t *pFree);

#ifdef  _DEBUG
void __cdecl _heap_print_regions_lk(void);
void __cdecl _heap_print_desc_lk(void);
void __cdecl _heap_print_emptylist_lk(void);
void __cdecl _heap_print_heaplist_lk(void);
#endif

#else   /* ndef _MT */

#define _free_lk(p) free(p)
#define _msize_lk(p)    _msize(p)

#ifdef  _DEBUG
#define _heap_print_regions_lk()    _heap_print_regions()
#define _heap_print_desc_lk()       _heap_print_desc()
#define _heap_print_emptylist_lk()  _heap_print_emptylist()
#define _heap_print_heaplist_lk()   _heap_print_heaplist()
#endif

#endif  /* _MT */

#ifdef  HEAPHOOK
#ifndef _HEAPHOOK_DEFINED
/* hook function type */
typedef int (__cdecl * _HEAPHOOK)(int, size_t, void *, void *);
#define _HEAPHOOK_DEFINED
#endif  /* _HEAPHOOK_DEFINED */

extern _HEAPHOOK _heaphook;
#endif  /* HEAPHOOK */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_HEAP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\fstream.h ===
/***
*fstream.h - definitions/declarations for filebuf and fstream classes
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the filebuf and fstream classes.
*       [AT&T C++]
*
*       [Public]
*
*Revision History:
*       01-23-92  KRS   Ported from 16-bit version.
*       08-19-92  KRS   Remove sh_compat for NT.
*       02-23-93  SKS   Update copyright to 1993
*       03-23-93  CFW   Modified #pragma warnings.
*       09-01-93  GJF   Merged Cuda and NT SDK versions.
*       10-13-93  GJF   Enclose #pragma-s in #ifdef _MSC_VER
*       08-12-94  GJF   Disable warning 4514 instead of 4505.
*       11-03-94  GJF   Changed pack pragma to 8 byte alignment.
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       05-11-95  CFW   Only for use by C++ programs.
*       12-14-95  JWM   Add "#pragma once".
*       04-09-96  SKS   Change _CRTIMP to _CRTIMP1 for special iostream build
*       04-15-96  JWM   Remove _OLD_IOSTREAMS, add '#pragma comment(lib,"cirt")'.
*       04-16-96  JWM   '#include useoldio.h' replaces '#pragma comment(...)'.
*       02-21-97  GJF   Cleaned out obsolete support for _NTSDK. Also, 
*                       detab-ed.
*       05-17-99  PML   Remove all Macintosh support.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_FSTREAM
#define _INC_FSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */

#ifndef _INTERNAL_IFSTRIP_
/* Define _CRTIMP1 */

#ifndef _CRTIMP1
#ifdef  CRTDLL1
#define _CRTIMP1 __declspec(dllexport)
#else   /* ndef CRTDLL1 */
#define _CRTIMP1 _CRTIMP
#endif  /* CRTDLL1 */
#endif  /* _CRTIMP1 */
#endif  /* _INTERNAL_IFSTRIP_ */

#include <iostream.h>

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

typedef int filedesc;

class _CRTIMP1 filebuf : public streambuf {
public:
static  const int       openprot;       // default share/prot mode for open

// optional share values for 3rd argument (prot) of open or constructor
static  const int       sh_none;        // exclusive mode no sharing
static  const int       sh_read;        // allow read sharing
static  const int       sh_write;       // allow write sharing
// use (sh_read | sh_write) to allow both read and write sharing

// options for setmode member function
static  const int       binary;
static  const int       text;

                        filebuf();
                        filebuf(filedesc);
                        filebuf(filedesc, char *, int);
                        ~filebuf();

        filebuf*        attach(filedesc);
        filedesc        fd() const { return (x_fd==-1) ? EOF : x_fd; }
        int             is_open() const { return (x_fd!=-1); }
        filebuf*        open(const char *, int, int = filebuf::openprot);
        filebuf*        close();
        int             setmode(int = filebuf::text);

virtual int             overflow(int=EOF);
virtual int             underflow();

virtual streambuf*      setbuf(char *, int);
virtual streampos       seekoff(streamoff, ios::seek_dir, int);
// virtual      streampos       seekpos(streampos, int);
virtual int             sync();

private:
        filedesc        x_fd;
        int             x_fOpened;
};

class _CRTIMP1 ifstream : public istream {
public:
        ifstream();
        ifstream(const char *, int =ios::in, int = filebuf::openprot);
        ifstream(filedesc);
        ifstream(filedesc, char *, int);
        ~ifstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int =ios::in, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};

class _CRTIMP1 ofstream : public ostream {
public:
        ofstream();
        ofstream(const char *, int =ios::out, int = filebuf::openprot);
        ofstream(filedesc);
        ofstream(filedesc, char *, int);
        ~ofstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int =ios::out, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};
        
class _CRTIMP1 fstream : public iostream {
public:
        fstream();
        fstream(const char *, int, int = filebuf::openprot);
        fstream(filedesc);
        fstream(filedesc, char *, int);
        ~fstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ostream::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};
        
// manipulators to dynamically change file access mode (filebufs only)
inline  ios& binary(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::binary); return _fstrm; }
inline  ios& text(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::text); return _fstrm; }

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_FSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\float.h ===
/***
*float.h - constants for floating point values
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains defines for a number of implementation dependent
*       values which are commonly used by sophisticated numerical (floating
*       point) programs.
*       [ANSI]
*
*       [Public]
*
*Revision History:
*       08-05-87  PHG   added comments
*       12-11-87  JCR   Added "_loadds" functionality
*       12-18-87  JCR   Added _FAR_ to declarations
*       02-10-88  JCR   Cleaned up white space
*       07-12-88  JCR   Added some close comment delimeters (bug fix)
*       08-22-88  GJF   Modified to also work with the 386 (small model only)
*       12-16-88  GJF   Changed [FLT|DBL|LDBL]_ROUNDS to 1
*       04-28-89  SKS   Put parentheses around negative constants
*       05-03-89  JCR   Added _INTERNAL_IFSTRIP for relinc usage
*       08-03-89  GJF   Cleanup, now specific to OS/2 2.0 (i.e., 386 flat model)
*       10-20-89  KRS   Add 'F' to FLT_MAX/MIN/EPSILON consts like in ANSI spec.
*       10-30-89  GJF   Fixed copyright
*       11-02-89  JCR   Changed "DLL" to "_DLL"
*       02-28-90  GJF   Added #ifndef _INC_FLOAT and #include <cruntime.h>
*                       stuff. Also, removed some (now) useless preprocessor
*                       directives.
*       03-22-90  GJF   Replaced _cdecl with _CALLTYPE2 (for now).
*       08-17-90  WAJ   Floating point routines now use _stdcall.
*       09-25-90  GJF   Added _fpecode stuff.
*       08-20-91  JCR   C++ and ANSI naming
*       02-03-91  GDP   Added definitions for MIPS
*       04-03-92  GDP   Use abstract control word definitions for all platforms
*                       Removed Infinity Control, [EM|SW]_DENORMAL, SW_SQRTNEG
*       04-14-92  GDP   Added Inf. control, [EM|SW]_DENORMAL, SW_SQRTNEG again
*       05-07-92  GDP   Added IEEE recommended functions
*       08-06-92  GJF   Function calling type and variable type macros. Also
*                       revised compiler/target processor macro usage.
*       09-16-92  GJF   Added _CRTAPI1 to _copysign - _fpclass prototypes.
*       11-09-92  GJF   Fixed preprocessing conditionals for MIPS.
*       01-03-93  SRW   Fold in ALPHA changes
*       01-09-93  SRW   Remove usage of MIPS and ALPHA to conform to ANSI
*                       Use _MIPS_ and _ALPHA_ instead.
*       01-21-93  GJF   Removed support for C6-386's _cdecl.
*       04-06-93  SKS   Replace _CRTAPI1/2 with __cdecl, _CRTVAR1 with nothing
*       04-07-93  SKS   Add _CRTIMP keyword for CRT DLL model
*                       Use link-time aliases for old names, not #define's
*                       Remove support for DOSX32, non-X86 CPUs, etc.
*       09-01-93  GJF   Merged Cuda and NT SDK versions.
*       10-12-93  GJF   Re-merged. Dropped use of _MIPS_ and _ALPHA_.
*       06-06-94  SKS   Change if def(_MT) to if def(_MT) || def(_DLL)
*                       This will support single-thread apps using MSVCRT*.DLL
*       10-02-94  BWT   Add PPC support.
*       12-15-94  XY    merged with mac header
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       04-11-95  JWM   Redefined CW_DEFAULT for x86.
*       05-24-95  CFW   xxx87() nor for mac use.
*       05-24-95  CFW   oldnames xxx87() uses macros.
*       12-14-95  JWM   Add "#pragma once".
*       02-05-97  GJF   Deleted obsolete support for _CRTAPI* and _NTSDK.
*                       Replaced (defined(_M_MPPC) || defined(_M_M68K)) with
*                       defined(_MAC) where appropriate. Also, detab-ed.
*       05-21-97  RKP   Added new denormal options for ALPHA.
*       09-30-97  JWM   Restored not-so-obsolete _CRTAPI1 support.
*       10-07-97  RDL   Added IA64.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*       06-04-99  PML   Define _CW_DEFAULT for IA64.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_FLOAT
#define _INC_FLOAT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _INTERNAL_IFSTRIP_
#include <cruntime.h>
#endif  /* _INTERNAL_IFSTRIP_ */


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#define DBL_DIG         15                      /* # of decimal digits of precision */
#define DBL_EPSILON     2.2204460492503131e-016 /* smallest such that 1.0+DBL_EPSILON != 1.0 */
#define DBL_MANT_DIG    53                      /* # of bits in mantissa */
#define DBL_MAX         1.7976931348623158e+308 /* max value */
#define DBL_MAX_10_EXP  308                     /* max decimal exponent */
#define DBL_MAX_EXP     1024                    /* max binary exponent */
#define DBL_MIN         2.2250738585072014e-308 /* min positive value */
#define DBL_MIN_10_EXP  (-307)                  /* min decimal exponent */
#define DBL_MIN_EXP     (-1021)                 /* min binary exponent */
#define _DBL_RADIX      2                       /* exponent radix */
#define _DBL_ROUNDS     1                       /* addition rounding: near */

#define FLT_DIG         6                       /* # of decimal digits of precision */
#define FLT_EPSILON     1.192092896e-07F        /* smallest such that 1.0+FLT_EPSILON != 1.0 */
#define FLT_GUARD       0
#define FLT_MANT_DIG    24                      /* # of bits in mantissa */
#define FLT_MAX         3.402823466e+38F        /* max value */
#define FLT_MAX_10_EXP  38                      /* max decimal exponent */
#define FLT_MAX_EXP     128                     /* max binary exponent */
#define FLT_MIN         1.175494351e-38F        /* min positive value */
#define FLT_MIN_10_EXP  (-37)                   /* min decimal exponent */
#define FLT_MIN_EXP     (-125)                  /* min binary exponent */
#define FLT_NORMALIZE   0
#define FLT_RADIX       2                       /* exponent radix */
#define FLT_ROUNDS      1                       /* addition rounding: near */

#define LDBL_DIG        DBL_DIG                 /* # of decimal digits of precision */
#define LDBL_EPSILON    DBL_EPSILON             /* smallest such that 1.0+LDBL_EPSILON != 1.0 */
#define LDBL_MANT_DIG   DBL_MANT_DIG            /* # of bits in mantissa */
#define LDBL_MAX        DBL_MAX                 /* max value */
#define LDBL_MAX_10_EXP DBL_MAX_10_EXP          /* max decimal exponent */
#define LDBL_MAX_EXP    DBL_MAX_EXP             /* max binary exponent */
#define LDBL_MIN        DBL_MIN                 /* min positive value */
#define LDBL_MIN_10_EXP DBL_MIN_10_EXP          /* min decimal exponent */
#define LDBL_MIN_EXP    DBL_MIN_EXP             /* min binary exponent */
#define _LDBL_RADIX     DBL_RADIX               /* exponent radix */
#define _LDBL_ROUNDS    DBL_ROUNDS              /* addition rounding: near */

/* Function prototypes */

_CRTIMP unsigned int __cdecl _clearfp(void);
_CRTIMP unsigned int __cdecl _controlfp(unsigned int,unsigned int);
_CRTIMP unsigned int __cdecl _statusfp(void);
_CRTIMP void __cdecl _fpreset(void);

#define _clear87        _clearfp
#define _status87       _statusfp

/*
 * Abstract User Control Word Mask and bit definitions
 */
#define _MCW_EM         0x0008001f              /* interrupt Exception Masks */
#define _EM_INEXACT     0x00000001              /*   inexact (precision) */
#define _EM_UNDERFLOW   0x00000002              /*   underflow */
#define _EM_OVERFLOW    0x00000004              /*   overflow */
#define _EM_ZERODIVIDE  0x00000008              /*   zero divide */
#define _EM_INVALID     0x00000010              /*   invalid */

#define _MCW_RC         0x00000300              /* Rounding Control */
#define _RC_NEAR        0x00000000              /*   near */
#define _RC_DOWN        0x00000100              /*   down */
#define _RC_UP          0x00000200              /*   up */
#define _RC_CHOP        0x00000300              /*   chop */

/*
 * Abstract User Status Word bit definitions
 */

#define _SW_INEXACT     0x00000001              /* inexact (precision) */
#define _SW_UNDERFLOW   0x00000002              /* underflow */
#define _SW_OVERFLOW    0x00000004              /* overflow */
#define _SW_ZERODIVIDE  0x00000008              /* zero divide */
#define _SW_INVALID     0x00000010              /* invalid */


/*
 * i386 specific definitions
 */
#define _MCW_PC         0x00030000              /* Precision Control */
#define _PC_64          0x00000000              /*    64 bits */
#define _PC_53          0x00010000              /*    53 bits */
#define _PC_24          0x00020000              /*    24 bits */

#define _MCW_IC         0x00040000              /* Infinity Control */
#define _IC_AFFINE      0x00040000              /*   affine */
#define _IC_PROJECTIVE  0x00000000              /*   projective */

#define _EM_DENORMAL    0x00080000              /* denormal exception mask (_control87 only) */

#define _SW_DENORMAL    0x00080000              /* denormal status bit */


_CRTIMP unsigned int __cdecl _control87(unsigned int,unsigned int);


/*
 * RISC specific definitions
 */

#define _MCW_DN         0x03000000              /* Denormal Control */
#define _DN_SAVE        0x00000000              /*   save denormal results and operands */
#define _DN_FLUSH       0x01000000              /*   flush denormal results and operands to zero */
#define _DN_FLUSH_OPERANDS_SAVE_RESULTS 0x02000000  /*   flush operands to zero and save results */
#define _DN_SAVE_OPERANDS_FLUSH_RESULTS 0x03000000  /*   save operands and flush results to zero */


/* initial Control Word value */

#if     defined(_M_IX86)

#define _CW_DEFAULT ( _RC_NEAR + _PC_53 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#elif   defined(_M_IA64)

#define _CW_DEFAULT ( _RC_NEAR + _PC_64 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#elif   defined(_M_MRX000) || defined (_M_ALPHA) || defined(_M_PPC)

#define _CW_DEFAULT ( _RC_NEAR + _DN_FLUSH + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT )

#endif

/* Global variable holding floating point error code */

#if     defined(_MT) || defined(_DLL)
_CRTIMP extern int * __cdecl __fpecode(void);
#define _fpecode        (*__fpecode())
#else   /* ndef _MT && ndef _DLL */
extern int _fpecode;
#endif  /* _MT || _DLL */

/* invalid subconditions (_SW_INVALID also set) */

#define _SW_UNEMULATED          0x0040  /* unemulated instruction */
#define _SW_SQRTNEG             0x0080  /* square root of a neg number */
#define _SW_STACKOVERFLOW       0x0200  /* FP stack overflow */
#define _SW_STACKUNDERFLOW      0x0400  /* FP stack underflow */

/*  Floating point error signals and return codes */

#define _FPE_INVALID            0x81
#define _FPE_DENORMAL           0x82
#define _FPE_ZERODIVIDE         0x83
#define _FPE_OVERFLOW           0x84
#define _FPE_UNDERFLOW          0x85
#define _FPE_INEXACT            0x86

#define _FPE_UNEMULATED         0x87
#define _FPE_SQRTNEG            0x88
#define _FPE_STACKOVERFLOW      0x8a
#define _FPE_STACKUNDERFLOW     0x8b

#define _FPE_EXPLICITGEN        0x8c    /* raise( SIGFPE ); */


/* IEEE recommended functions */

_CRTIMP double __cdecl _copysign (double, double);
_CRTIMP double __cdecl _chgsign (double);
_CRTIMP double __cdecl _scalb(double, long);
_CRTIMP double __cdecl _logb(double);
_CRTIMP double __cdecl _nextafter(double, double);
_CRTIMP int    __cdecl _finite(double);
_CRTIMP int    __cdecl _isnan(double);
_CRTIMP int    __cdecl _fpclass(double);

#define _FPCLASS_SNAN   0x0001  /* signaling NaN */
#define _FPCLASS_QNAN   0x0002  /* quiet NaN */
#define _FPCLASS_NINF   0x0004  /* negative infinity */
#define _FPCLASS_NN     0x0008  /* negative normal */
#define _FPCLASS_ND     0x0010  /* negative denormal */
#define _FPCLASS_NZ     0x0020  /* -0 */
#define _FPCLASS_PZ     0x0040  /* +0 */
#define _FPCLASS_PD     0x0080  /* positive denormal */
#define _FPCLASS_PN     0x0100  /* positive normal */
#define _FPCLASS_PINF   0x0200  /* positive infinity */


#if     !__STDC__

/* Non-ANSI names for compatibility */

#define clear87         _clear87
#define status87        _status87
#define control87       _control87

_CRTIMP void __cdecl fpreset(void);

#define DBL_RADIX               _DBL_RADIX
#define DBL_ROUNDS              _DBL_ROUNDS

#define LDBL_RADIX              _LDBL_RADIX
#define LDBL_ROUNDS             _LDBL_ROUNDS

#define MCW_EM                  _MCW_EM
#define EM_INVALID              _EM_INVALID
#define EM_DENORMAL             _EM_DENORMAL
#define EM_ZERODIVIDE           _EM_ZERODIVIDE
#define EM_OVERFLOW             _EM_OVERFLOW
#define EM_UNDERFLOW            _EM_UNDERFLOW
#define EM_INEXACT              _EM_INEXACT

#define MCW_IC                  _MCW_IC
#define IC_AFFINE               _IC_AFFINE
#define IC_PROJECTIVE           _IC_PROJECTIVE

#define MCW_RC                  _MCW_RC
#define RC_CHOP                 _RC_CHOP
#define RC_UP                   _RC_UP
#define RC_DOWN                 _RC_DOWN
#define RC_NEAR                 _RC_NEAR

#define MCW_PC                  _MCW_PC
#define PC_24                   _PC_24
#define PC_53                   _PC_53
#define PC_64                   _PC_64

#define CW_DEFAULT              _CW_DEFAULT

#define SW_INVALID              _SW_INVALID
#define SW_DENORMAL             _SW_DENORMAL
#define SW_ZERODIVIDE           _SW_ZERODIVIDE
#define SW_OVERFLOW             _SW_OVERFLOW
#define SW_UNDERFLOW            _SW_UNDERFLOW
#define SW_INEXACT              _SW_INEXACT

#define SW_UNEMULATED           _SW_UNEMULATED
#define SW_SQRTNEG              _SW_SQRTNEG
#define SW_STACKOVERFLOW        _SW_STACKOVERFLOW
#define SW_STACKUNDERFLOW       _SW_STACKUNDERFLOW

#define FPE_INVALID             _FPE_INVALID
#define FPE_DENORMAL            _FPE_DENORMAL
#define FPE_ZERODIVIDE          _FPE_ZERODIVIDE
#define FPE_OVERFLOW            _FPE_OVERFLOW
#define FPE_UNDERFLOW           _FPE_UNDERFLOW
#define FPE_INEXACT             _FPE_INEXACT

#define FPE_UNEMULATED          _FPE_UNEMULATED
#define FPE_SQRTNEG             _FPE_SQRTNEG
#define FPE_STACKOVERFLOW       _FPE_STACKOVERFLOW
#define FPE_STACKUNDERFLOW      _FPE_STACKUNDERFLOW

#define FPE_EXPLICITGEN         _FPE_EXPLICITGEN

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_FLOAT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\fltintrn.h ===
/***
*fltintrn.h - contains declarations of internal floating point types,
*             routines and variables
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Declares floating point types, routines and variables used
*       internally by the C run-time.
*
*       [Internal]
*
*Revision History:
*       10-20-88  JCR   Changed 'DOUBLE' to 'double' for 386
*       08-15-89  GJF   Fixed copyright, indents
*       10-30-89  GJF   Fixed copyright (again)
*       03-02-90  GJF   Added #ifndef _INC_STRUCT stuff. Also, cleaned up
*                       the formatting a bit.
*       03-05-90  GJF   Fixed up the arg types in protoypes. Also, added
*                       #include <cruntime.h>
*       03-22-90  GJF   Made _fltin(), _fltin2(), _fltout() and _fltout2()
*                       _CALLTYPE2 (for now) and added a prototype for
*                       _fptostr().
*       08-01-90  SBM   Moved _cftoe() and _cftof() here from internal.h
*                       and _cfltcvt_tab from input.c and output.c,
*                       added typedefs for _cfltcvt_tab entries,
*                       renamed module from <struct.h> to <fltintrn.h> and
*                       adjusted #ifndef stuff to #ifndef _INC_FLTINTRN
*       08-29-90  SBM   Changed type of _cfltcvt_tab[] to agree with
*                       definition in cmiscdat.c
*       04-26-91  SRW   Removed level 3 warnings
*       08-26-91  JCR   Changed MIPS to _MIPS_, ANSI naming
*       08-06-92  GJF   Function calling type and variable type macros. Revised
*                       use of target processor macros.
*       11-09-92  GJF   Fixed preprocessing conditionals for MIPS.
*       01-09-93  SRW   Remove usage of MIPS and ALPHA to conform to ANSI
*                       Use _MIPS_ and _ALPHA_ instead.
*       01-21-93  GJF   Removed support for C6-386's _cdecl.
*       04-06-93  SKS   Replace _CRTAPI1/2 with __cdecl, _CRTVAR1 with nothing
*       09-01-93  GJF   Merged Cuda and NT SDK versions.
*       10-13-93  GJF   Dropped _MIPS_. Replaced  _ALPHA_ with _M_ALPHA.
*       10-29-93  GJF   Disabled the ever-annoying 4069 warning.
*       10-02-94  BWT   Add PPC support.
*       12-15-94  XY    merged with mac header
*       02-14-95  CFW   Clean up Mac merge.
*       03-29-95  CFW   Add error message to internal headers.
*       12-14-95  JWM   Add "#pragma once".
*       02-05-97  GJF   Deleted obsolete support for _CRTAPI* and _NTSDK.
*                       Replaced (defined(_M_MPPC) || defined(_M_M68K)) with
*                       defined(_MAC) where appropriate. Replaced _CALLTYPE2
*                       with __cdecl. Also, detab-ed.
*       05-17-99  PML   Remove all Macintosh support.
*	    09-05-00  GB    Changed the defination of fltout functions. Use DOUBLE 
*	                    instead of double
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_FLTINTRN
#define _INC_FLTINTRN

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  __cplusplus
extern "C" {
#endif

#include <cruntime.h>


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/*
 * For MS C for the x86 family, disable the annoying "long double is the
 * same precision as double" warning
 */

#ifdef  _M_IX86
#pragma warning(disable:4069)
#endif

/*
 * structs used to fool the compiler into not generating floating point
 * instructions when copying and pushing [long] double values
 */

#ifndef DOUBLE

typedef struct {
        double x;
} DOUBLE;

#endif

#ifndef LONGDOUBLE

typedef struct {
#if     defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)
        /*
         * No long double type for MIPS, ALPHA, PPC.
         */
        double x;
#else
        /*
         * Assume there is a long double type
         */
        long double x;
#endif
} LONGDOUBLE;

#endif

/*
 * typedef for _fltout
 */

typedef struct _strflt
{
        int sign;             /* zero if positive otherwise negative */
        int decpt;            /* exponent of floating point number */
        int flag;             /* zero if okay otherwise IEEE overflow */
        char *mantissa;       /* pointer to mantissa in string form */
}
        *STRFLT;


/*
 * typedef for _fltin
 */

typedef struct _flt
{
        int flags;
        int nbytes;          /* number of characters read */
        long lval;
        double dval;         /* the returned floating point number */
}
        *FLT;


/* floating point conversion routines, keep in sync with mrt32\include\convert.h */

char *_cftoe(double *, char *, int, int);
char *_cftof(double *, char *, int);
void __cdecl _fptostr(char *, int, STRFLT);

#ifdef  _MT

STRFLT  __cdecl _fltout2( DOUBLE, STRFLT, char * );
FLT     __cdecl _fltin2( FLT , const char *, int, int, int );

#else

STRFLT  __cdecl _fltout( DOUBLE );
FLT     __cdecl _fltin( const char *, int, int, int );

#endif


/*
 * table of pointers to floating point helper routines
 *
 * We can't specify the prototypes for the entries of the table accurately,
 * since different functions in the table have different arglists.
 * So we declare the functions to take and return void (which is the
 * correct prototype for _fptrap(), which is what the entries are all
 * initialized to if no floating point is loaded) and cast appropriately
 * on every usage.
 */

typedef void (* PFV)(void);
extern PFV _cfltcvt_tab[6];

typedef void (* PF0)(DOUBLE*, char*, int, int, int);
#define _cfltcvt(a,b,c,d,e) (*((PF0)_cfltcvt_tab[0]))(a,b,c,d,e)

typedef void (* PF1)(char*);
#define _cropzeros(a)       (*((PF1)_cfltcvt_tab[1]))(a)

typedef void (* PF2)(int, char*, char*);
#define _fassign(a,b,c)     (*((PF2)_cfltcvt_tab[2]))(a,b,c)

typedef void (* PF3)(char*);
#define _forcdecpt(a)       (*((PF3)_cfltcvt_tab[3]))(a)

typedef int (* PF4)(DOUBLE*);
#define _positive(a)        (*((PF4)_cfltcvt_tab[4]))(a)

typedef void (* PF5)(LONGDOUBLE*, char*, int, int, int);
#define _cldcvt(a,b,c,d,e)  (*((PF5)_cfltcvt_tab[5]))(a,b,c,d,e)


#ifdef  _M_IX86
#pragma warning(default:4069)
#endif

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_FLTINTRN */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\internal.h ===
/***
*internal.h - contains declarations of internal routines and variables
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Declares routines and variables used internally by the C run-time.
*
*       [Internal]
*
*Revision History:
*       05-18-87  SKS   Module created
*       07-15-87  JCR   Added _old_pfxlen and _tempoff
*       08-05-87  JCR   Added _getbuf (corrected by SKS)
*       11-05-87  JCR   Added _buferr
*       11-18-87  SKS   Add __tzset(), made _isindst() near, remove _dtoxmode
*       01-26-88  SKS   Make __tzset, _isindst, _dtoxtime near/far for QC
*       02-10-88  JCR   Cleaned up white space
*       06-22-88  SKS   _canonic/_getcdrv are now used by all models
*       06-29-88  JCR   Removed static buffers _bufout and _buferr
*       08-18-88  GJF   Revised to also work for the 386 (small model only).
*       09-22-88  GJF   Added declarations for _freebuf, _stbuf and _ftbuf.
*       01-31-89  JCR   Removed _canonic, _getcdrv, _getcdwd (see direct.h)
*       06-07-89  PHG   Added _dosret for i860 (N10) version of libs
*       07-05-89  PHG   Changed above to _dosmaperr, added startup variables
*       08-17-89  GJF   Cleanup, removed stuff not needed for 386
*       10-25-89  JCR   Added prototype for _getpath()
*       10-30-89  GJF   Fixed copyright
*       11-02-89  JCR   Changed "DLL" to "_DLL"
*       03-01-90  GJF   Added #ifndef _INC_INTERNAL and #include <cruntime.h>
*                       stuff. Also, removed some (now) useless preprocessing
*                       directives.
*       03-21-90  GJF   Put _CALLTYPE1 into prototypes.
*       03-26-90  GJF   Added prototypes for _output() and _input(). Filled
*                       out the prototype for _openfile
*       04-05-90  GJF   Added prototype for __NMSG_WRITE() (C source build
*                       only).
*       04-10-90  GJF   Added prototypes for startup functions.
*       05-28-90  SBM   Added _flush()
*       07-11-90  SBM   Added _commode, removed execload()
*       07-20-90  SBM   Changes supporting clean -W3 compiles (added _cftoe
*                       and _cftof prototypes)
*       08-01-90  SBM   Moved _cftoe() and _cftof() to new header
*                       <fltintrn.h>, formerly named <struct.h>
*       08-21-90  GJF   Changed prototypes for _amsg_exit() and _NMSG_WRITE().
*       11-29-90  GJF   Added some defs/decls for lowio under Win32.
*       12-04-90  SRW   Added _osfile back for win32.  Changed _osfinfo from
*                       an array of structures to an array of 32-bit handles
*                       (_osfhnd)
*       04-06-91  GJF   Changed _heapinit to _heap_init.
*       08-19-91  JCR   Added _exitflag
*       08-20-91  JCR   C++ and ANSI naming
*       01-05-92  GJF   Added declaration for termination done flag [_WIN32_]
*       01-08-92  GJF   Added prototype for _GetMainArgs.
*       01-18-92  GJF   Added _aexit_rtn.
*       01-22-92  GJF   Fixed definitions of _acmdln and _aexit_rtn for the
*                       of crtdll.dll, crtdll.lib.
*       01-29-92  GJF   Added support for linked-in options equivalent to
*                       commode.obj and setargv.obj (i.e., special declarations
*                       for _commode and _dowildcard).
*       02-14-92  GJF   Replace _nfile with _nhandle for Win32. Also, added
*                       #define-s for _NHANDLE_.
*       03-17-92  GJF   Removed declaration of _tmpoff for Win32.
*       03-30-92  DJM   POSIX support.
*       04-27-92  GJF   Added prototypes for _ValidDrive (in stat.c).
*       05-28-92  GJF   Added prototype for _mtdeletelocks() for Win32.
*       06-02-92  SKS   Move prototype for _pgmptr to <DOS.H>
*       06-02-92  KRS   Added prototype for _woutput().
*       08-06-92  GJF   Function calling type and variable type macros.
*       08-17-92  KRS   Added prototype for _winput().
*       08-21-92  GJF   Merged last two changes above.
*       08-24-92  PBS   Added _dstoffset for posix TZ
*       10-24-92  SKS   Add a fourth parameter to _GetMainArgs: wildcard flag
*                       _GetMainArgs => __GetMainArgs: 2 leading _'s = internal
*       10-24-92  SKS   Remove two unnecessary parameters from _cenvarg()
*       01-21-93  GJF   Removed support for C6-386's _cdecl.
*       03-30-93  GJF   __gmtotime_t supercedes _dtoxtime.
*       04-06-93  SKS   Replace _CRTAPI1/2 with __cdecl, _CRTVAR1 with nothing
*                       Change _ValidDrive to _validdrive
*       04-07-93  SKS   Add _CRTIMP keyword for CRT DLL model
*                       Use link-time aliases for old names, not #define's
*       04-13-93  SKS   Add _mtterm (complement of _mtinit)
*       04-26-93  SKS   _mtinit now returns success (1) or failure (0)
*       05-06-93  SKS   Add _heap_term() - frees up memory upon DLL detach
*       07-21-93  GJF   __loctotime_t supercedes _gmtotime_t.
*       09-15-93  CFW   Added mbc init function prototypes.
*       09-17-93  GJF   Merged NT SDK and Cuda versions, added prototype for
*                       _heap_abort.
*       10-13-93  GJF   Replaced _ALPHA_ with _M_ALPHA.
*       10-21-93  GJF   Changed _NTSDK definition of _commode slightly to
*                       work with dllsuff\crtexe.c.
*       10-22-93  CFW   Test for invalid MB chars using global preset flag.
*       10-26-93  GJF   Added typedef for _PVFV.
*       11-19-93  CFW   Add _wcmdln, wmain, _wsetargv.
*       11-23-93  CFW   Undef GetEnvironmentStrings (TEMPORARY).
*       11-29-93  CFW   Remove GetEnvironmentStrings undef, NT 540 has fix.
*       12-01-93  CFW   Add _wenvptr and protos for wide environ functions.
*       12-07-93  CFW   Add _wcenvarg, _wcapture_argv, and wdospawn protos.
*       01-11-94  GJF   __GetMainArgs() instead of __getmainargs for NT SDK.
*       03-04-94  SKS   Add declarations of _newmode and _dowildcard.
*                       Adjust decl of _[w]getmainargs for 4th parameter.
*       03-25-94  GJF   Added declaration of __[w]initenv
*       03-25-94  GJF   Made declarations of:
*                           _acmdln,    _wcmdln,
*                           _aenvptr,   _wenvptr
*                           _C_Termination_Flag,
*                           _exitflag,
*                           __initenv,  __winitenv,
*                           __invalid_mb_chars
*                           _lastiob,
*                           _old_pfxlen,
*                           _osfhnd[]
*                           _osfile[],
*                           _pipech[],
*                           _tempoff,
*                           _umaskval
*                       conditional on DLL_FOR_WIN32S. Made declaration of
*                       _newmode conditional on DLL_FOR_WIN32S and CRTDLL.
*                       Made declaration of _cflush conditional on CRTDLL.
*                       Defined _commode to be a dereferenced function return
*                       for _DLL. Conditionally included win32s.h.
*       04-14-94  GJF   Added definition for FILE.
*       05-03-94  GJF   Made declarations of _commode, __initenv, __winitenv
*                       _acmdln and _wcmdln also conditional on _M_IX86.
*       05-09-94  CFW   Add __fcntrlcomp, remove DLL_FOR_WIN32S protection
*                       on __invalid_mb_chars.
*       09-06-94  GJF   Added declarations for __app_type, __set_app_type()
*                       and related constants, and __error_mode.
*       09-06-94  CFW   Remove _MBCS_OS switch.
*       12-14-94  SKS   Increase file handle limit for MSVCRT30.DLL
*       12-15-94  XY    merged with mac header
*       12-21-94  CFW   Remove fcntrlcomp & invalid_mb NT 3.1 hacks.
*       12-23-94  GJF   Added prototypes for _fseeki64, _fseeki64_lk,
*                       _ftelli64 and _ftelli64_lk.
*       12-28-94  JCF   Changed _osfhnd from long to int in _MAC_.
*       01-17-95  BWT   Don't define main/wmain for POSIX
*       02-11-95  CFW   Don't define __argc, __argv, _pgmptr for Mac.
*       02-14-95  GJF   Made __dnames[] and __mnames[] const.
*       02-14-95  CFW   Clean up Mac merge.
*       03-03-95  GJF   Changes to manage streams via __piob[], rather than
*                       _iob[].
*       03-29-95  BWT   Define _commode properly for RISC _DLL CRTEXE case.
*       03-29-95  CFW   Add error message to internal headers.
*       04-06-95  CFW   Add parameter to _setenvp().
*       05-08-95  CFW   Official ANSI C++ new handler added.
*       06-15-95  GJF   Revised for ioinfo arrays.
*       07-04-95  GJF   Removed additional parameter from _setenvp().
*       06-23-95  CFW   ANSI new handler removed from build.
*       07-26-95  GJF   Added safe versions of ioinfo access macros.
*       09-25-95  GJF   Added parameter to __loctotime_t.
*       12-08-95  SKS   Add __initconin()/__initconout() for non-MAC platforms.
*       12-14-95  JWM   Add "#pragma once".
*       04-12-96  SKS   __badioinfo and __pioinfo must be exported for the
*                       Old Iostreams DLLs (msvcirt.dll and msvcirtd.dll).
*       04-22-96  GJF   Return type of _heap_init changed.
*       05-10-96  SKS   Add definition of _CRTIMP1 -- needed by mtlock/mtunlock
*       08-01-96  RDK   For PMac, add extern for _osfileflags for extra byte of
*                       file flags.
*       08-22-96  SKS   Add definition of _CRTIMP2
*       02-03-97  GJF   Cleaned out obsolete support for Win32s, _CRTAPI* and 
*                       _NTSDK. Replaced defined(_M_MPPC) || defined(_M_M68K)
*                       with defined(_MAC). Also, detab-ed.
*       04-16-97  GJF   Restored the macros for _[w]initenv in the DLL model
*                       because they prove useful in something else.
*       07-23-97  GJF   _heap_init changed slightly.
*       02-07-98  GJF   Changes for Win64: use intptr_t where appropriate, 
*                       and made time_t __int64.
*       05-04-98  GJF   Added __time64_t support.
*       12-15-98  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*       05-28-99  GJF   Changed prototype for __crt[w]setenv.
*       06-01-99  PML   Minor cleanup for 5/3/99 Plauger STL drop.
*       10-06-99  PML   Add _W64 modifier to types which are 32 bits in Win32,
*                       64 bits in Win64.
*       10-14-99  PML   Add __crtInitCritSecAndSpinCount and _CRT_SPINCOUNT.
*       11-03-99  PML   Add va_list definition for _M_CEE.
*       11-12-99  PML   Wrap __time64_t in its own #ifndef.
*       03-06-00  PML   Add __crtExitProcess.
*       09-07-00  PML   Remove va_list definition for _M_CEE (vs7#159777)
*       02-20-01  PML   vs7#172586 Avoid _RT_LOCK by preallocating all locks
*                       that will be required, and returning failure back on
*                       inability to allocate a lock.
*       03-27-01  PML   Return success/failure code from several startup
*                       routines instead of calling _amsg_exit (vs7#231220)
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_INTERNAL
#define _INC_INTERNAL

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  __cplusplus
extern "C" {
#endif

#include <cruntime.h>

/*
 * Conditionally include windows.h to pick up the definition of 
 * CRITICAL_SECTION.
 */
#ifdef  _MT
#include <windows.h>
#endif

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300 /*IFSTRIP=IGN*/
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


/* Define _CRTIMP1 */

#ifndef _CRTIMP1
#ifdef  CRTDLL1
#define _CRTIMP1 __declspec(dllexport)
#else   /* ndef CRTDLL1 */
#define _CRTIMP1 _CRTIMP
#endif  /* CRTDLL1 */
#endif  /* _CRTIMP1 */


/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#if defined(CRTDLL2)
#define _CRTIMP2 __declspec(dllexport)
#else   /* ndef CRTDLL2 */
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL && !STATIC_CPPLIB */
#define _CRTIMP2
#endif  /* _DLL && !STATIC_CPPLIB */
#endif  /* CRTDLL2 */
#endif  /* _CRTIMP2 */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* Define function types used in several startup sources */

typedef void (__cdecl *_PVFV)(void);
typedef int  (__cdecl *_PIFV)(void);


#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP int * __p__commode(void);
#endif
#if     defined(SPECIAL_CRTEXE) && defined(_DLL)
        extern int _commode;
#else
_CRTIMP extern int _commode;
#endif  /* defined(_DLL) && defined(SPECIAL_CRTEXE) */


/*
 * Control structure for lowio file handles
 */
typedef struct {
        intptr_t osfhnd;    /* underlying OS file HANDLE */
        char osfile;        /* attributes of file (e.g., open in text mode?) */
        char pipech;        /* one char buffer for handles opened on pipes */
#ifdef  _MT
        int lockinitflag;
        CRITICAL_SECTION lock;
#endif
    }   ioinfo;

/*
 * Definition of IOINFO_L2E, the log base 2 of the number of elements in each
 * array of ioinfo structs.
 */
#define IOINFO_L2E          5

/*
 * Definition of IOINFO_ARRAY_ELTS, the number of elements in ioinfo array
 */
#define IOINFO_ARRAY_ELTS   (1 << IOINFO_L2E)

/*
 * Definition of IOINFO_ARRAYS, maximum number of supported ioinfo arrays.
 */
#define IOINFO_ARRAYS       64

#define _NHANDLE_           (IOINFO_ARRAYS * IOINFO_ARRAY_ELTS)

/*
 * Access macros for getting at an ioinfo struct and its fields from a
 * file handle
 */
#define _pioinfo(i) ( __pioinfo[(i) >> IOINFO_L2E] + ((i) & (IOINFO_ARRAY_ELTS - \
                              1)) )
#define _osfhnd(i)  ( _pioinfo(i)->osfhnd )

#define _osfile(i)  ( _pioinfo(i)->osfile )

#define _pipech(i)  ( _pioinfo(i)->pipech )

/*
 * Safer versions of the above macros. Currently, only _osfile_safe is 
 * used.
 */
#define _pioinfo_safe(i)    ( ((i) != -1) ? _pioinfo(i) : &__badioinfo )

#define _osfhnd_safe(i)     ( _pioinfo_safe(i)->osfhnd )

#define _osfile_safe(i)     ( _pioinfo_safe(i)->osfile )

#define _pipech_safe(i)     ( _pioinfo_safe(i)->pipech )

/*
 * Special, static ioinfo structure used only for more graceful handling
 * of a C file handle value of -1 (results from common errors at the stdio 
 * level). 
 */
extern _CRTIMP ioinfo __badioinfo;

/*
 * Array of arrays of control structures for lowio files.
 */
extern _CRTIMP ioinfo * __pioinfo[];

/*
 * Current number of allocated ioinfo structures (_NHANDLE_ is the upper
 * limit).
 */
extern int _nhandle;

int __cdecl _alloc_osfhnd(void);
int __cdecl _free_osfhnd(int);
int __cdecl _set_osfhnd(int, intptr_t);

#ifdef  _POSIX_
extern long _dstoffset;
#endif  /* _POSIX_ */

extern const char __dnames[];
extern const char __mnames[];

extern int _days[];
extern int _lpdays[];

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _TIME64_T_DEFINED
typedef __int64 __time64_t;     /* 64-bit time value */
#define _TIME64_T_DEFINED
#endif

extern time_t __cdecl __loctotime_t(int, int, int, int, int, int, int);

extern __time64_t __cdecl __loctotime64_t(int, int, int, int, int, int, int);

#ifdef  _TM_DEFINED
extern int __cdecl _isindst(struct tm *);
#endif

extern void __cdecl __tzset(void);

extern int __cdecl _validdrive(unsigned);


/*
 * This variable is in the C start-up; the length must be kept synchronized
 * It is used by the *cenvarg.c modules
 */

extern char _acfinfo[]; /* "_C_FILE_INFO=" */

#define CFI_LENGTH  12  /* "_C_FILE_INFO" is 12 bytes long */


/* typedefs needed for subsequent prototypes */

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED
#ifdef  _M_ALPHA
typedef struct {
        char *a0;       /* pointer to first homed integer argument */
        int offset;     /* byte offset of next parameter */
} va_list;
#else
typedef char *  va_list;
#endif
#define _VA_LIST_DEFINED
#endif

/*
 * stdio internals
 */
#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif  /* _FILE_DEFINED */

#if     !defined(_FILEX_DEFINED) && (defined(_WINDOWS_) || defined(_XBOX))

/*
 * Variation of FILE type used for the dynamically allocated portion of
 * __piob[]. For single thread, _FILEX is the same as FILE. For multithread
 * models, _FILEX has two fields: the FILE struct and the CRITICAL_SECTION
 * struct used to serialize access to the FILE.
 */
#ifdef  _MT

typedef struct {
        FILE f;
        CRITICAL_SECTION lock;
        }   _FILEX;

#else   /* ndef _MT */

typedef FILE    _FILEX;

#endif  /* _MT */

#define _FILEX_DEFINED
#endif  /* _FILEX_DEFINED */

/*
 * Number of entries supported in the array pointed to by __piob[]. That is,
 * the number of stdio-level files which may be open simultaneously. This
 * is normally set to _NSTREAM_ by the stdio initialization code.
 */
extern int _nstream;

/*
 * Pointer to the array of pointers to FILE/_FILEX structures that are used
 * to manage stdio-level files.
 */
extern void **__piob;

FILE * __cdecl _getstream(void);
#ifdef  _POSIX_
FILE * __cdecl _openfile(const char *, const char *, FILE *);
#else
FILE * __cdecl _openfile(const char *, const char *, int, FILE *);
#endif
FILE * __cdecl _wopenfile(const wchar_t *, const wchar_t *, int, FILE *);
void __cdecl _getbuf(FILE *);
int __cdecl _filwbuf (FILE *);
int __cdecl _flswbuf(int, FILE *);
void __cdecl _freebuf(FILE *);
int __cdecl _stbuf(FILE *);
void __cdecl _ftbuf(int, FILE *);
int __cdecl _output(FILE *, const char *, va_list);
int __cdecl _woutput(FILE *, const wchar_t *, va_list);
int __cdecl _input(FILE *, const unsigned char *, va_list);
int __cdecl _winput(FILE *, const wchar_t *, va_list);
int __cdecl _flush(FILE *);
void __cdecl _endstdio(void);

int __cdecl _fseeki64(FILE *, __int64, int);
int __cdecl _fseeki64_lk(FILE *, __int64, int);
__int64 __cdecl _ftelli64(FILE *);
#ifdef  _MT
__int64 __cdecl _ftelli64_lk(FILE *);
#else   /* ndef _MT */
#define _ftelli64_lk    _ftelli64
#endif  /* _MT */

#ifndef CRTDLL
extern int _cflush;
#endif  /* CRTDLL */

extern unsigned int _tempoff;

extern unsigned int _old_pfxlen;

extern int _umaskval;       /* the umask value */

extern char _pipech[];      /* pipe lookahead */

extern char _exitflag;      /* callable termination flag */

extern int _C_Termination_Done; /* termination done flag */

char * __cdecl _getpath(const char *, char *, unsigned);
wchar_t * __cdecl _wgetpath(const wchar_t *, wchar_t *, unsigned);

extern int _dowildcard;     /* flag to enable argv[] wildcard expansion */

#ifndef _PNH_DEFINED
typedef int (__cdecl * _PNH)( size_t );
#define _PNH_DEFINED
#endif

#ifdef  ANSI_NEW_HANDLER
/* ANSI C++ new handler */
#ifndef _ANSI_NH_DEFINED
typedef void (__cdecl * new_handler) ();
#define _ANSI_NH_DEFINED
#endif

#ifndef _NO_ANSI_NH_DEFINED
#define _NO_ANSI_NEW_HANDLER  ((new_handler)-1)
#define _NO_ANSI_NH_DEFINED
#endif

extern new_handler _defnewh;  /* default ANSI C++ new handler */
#endif  /* ANSI_NEW_HANDLER */

/* calls the currently installed new handler */
int __cdecl _callnewh(size_t);

extern int _newmode;    /* malloc new() handler mode */

/* pointer to initial environment block that is passed to [w]main */
#if     defined(_DLL) && defined(_M_IX86)
#define __winitenv  (*__p___winitenv())
_CRTIMP wchar_t *** __cdecl __p___winitenv(void);
#define __initenv  (*__p___initenv())
_CRTIMP char *** __cdecl __p___initenv(void);
#else
extern _CRTIMP wchar_t **__winitenv;
extern _CRTIMP char **__initenv;
#endif

/* startup set values */
extern char *_aenvptr;      /* environment ptr */
extern wchar_t *_wenvptr;   /* wide environment ptr */

/* command line */

#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP char ** __cdecl __p__acmdln(void);
_CRTIMP wchar_t ** __cdecl __p__wcmdln(void);
#endif
_CRTIMP extern char *_acmdln;
_CRTIMP extern wchar_t *_wcmdln;


/*
 * prototypes for internal startup functions
 */
int __cdecl _cwild(void);           /* wild.c */
int __cdecl _wcwild(void);          /* wwild.c */
#ifdef  _MT
int  __cdecl _mtinit(void);         /* tidtable.c */
void __cdecl _mtterm(void);         /* tidtable.c */
int  __cdecl _mtinitlocks(void);    /* mlock.c */
void __cdecl _mtdeletelocks(void);  /* mlock.c */
int  __cdecl _mtinitlocknum(int);   /* mlock.c */
#endif

#ifdef  _MT
/* Wrapper for InitializeCriticalSection API, with default spin count */
int __cdecl __crtInitCritSecAndSpinCount(PCRITICAL_SECTION, DWORD);
#define _CRT_SPINCOUNT  4000
#endif

/*
 * C source build only!!!!
 *
 * more prototypes for internal startup functions
 */
void __cdecl _amsg_exit(int);           /* crt0.c */
void __cdecl __crtExitProcess(int);     /* crt0dat.c */
int  __cdecl _cinit(void);              /* crt0dat.c */
#ifdef _XBOX
void __cdecl rtinit(void);
#endif // XBOX
void __cdecl __doinits(void);           /* astart.asm */
void __cdecl __doterms(void);           /* astart.asm */
void __cdecl __dopreterms(void);        /* astart.asm */
void __cdecl _FF_MSGBANNER(void);
void __cdecl _fptrap(void);             /* crt0fp.c */
#ifdef _XBOX
int  __cdecl _heap_init(int);
#endif // XBOX
void __cdecl _heap_term(void);
void __cdecl _heap_abort(void);
void __cdecl __initconin(void);         /* initcon.c */
void __cdecl __initconout(void);        /* initcon.c */
int  __cdecl _ioinit(void);             /* crt0.c, crtlib.c */
void __cdecl _ioterm(void);             /* crt0.c, crtlib.c */
char * __cdecl _GET_RTERRMSG(int);
void __cdecl _NMSG_WRITE(int);
#ifdef _XBOX
int  __cdecl _setargv(void);            /* setargv.c, stdargv.c */
int  __cdecl __setargv(void);           /* stdargv.c */
int  __cdecl _wsetargv(void);           /* wsetargv.c, wstdargv.c */
int  __cdecl __wsetargv(void);          /* wstdargv.c */
int  __cdecl _setenvp(void);            /* stdenvp.c */
int  __cdecl _wsetenvp(void);           /* wstdenvp.c */
#endif //XBOX
void __cdecl __setmbctable(unsigned int);   /* mbctype.c */

#ifdef  _MBCS
int  __cdecl __initmbctable(void);      /* mbctype.c */
#endif

#ifndef _POSIX_
int __cdecl main(int, char **, char **);
int __cdecl wmain(int, wchar_t **, wchar_t **);
#endif

#ifdef _XBOX
/* helper functions for wide/multibyte environment conversion */
int __cdecl __mbtow_environ (void);
int __cdecl __wtomb_environ (void);
int __cdecl __crtsetenv (char *, const int);
int __cdecl __crtwsetenv (wchar_t *, const int);
#endif // XBOX

_CRTIMP extern void (__cdecl * _aexit_rtn)(int);

#if     defined(_DLL) || defined(CRTDLL)

#ifndef _STARTUP_INFO_DEFINED
typedef struct
{
        int newmode;
#ifdef  ANSI_NEW_HANDLER
        new_handler newh;
#endif  /* ANSI_NEW_HANDLER */
} _startupinfo;
#define _STARTUP_INFO_DEFINED
#endif  /* _STARTUP_INFO_DEFINED */

_CRTIMP int __cdecl __getmainargs(int *, char ***, char ***,
                                  int, _startupinfo *);

_CRTIMP int __cdecl __wgetmainargs(int *, wchar_t ***, wchar_t ***,
                                   int, _startupinfo *);

#endif  /* defined(_DLL) || defined(CRTDLL) */

/*
 * Prototype, variables and constants which determine how error messages are
 * written out.
 */
#define _UNKNOWN_APP    0
#define _CONSOLE_APP    1
#define _GUI_APP        2

extern int __app_type;

extern int __error_mode;

_CRTIMP void __cdecl __set_app_type(int);

/*
 * C source build only!!!!
 *
 * map Win32 errors into Xenix errno values -- for modules written in C
 */
extern void __cdecl _dosmaperr(unsigned long);

/*
 * internal routines used by the exec/spawn functions
 */

#ifndef _XBSTRICT
extern intptr_t __cdecl _dospawn(int, const char *, char *, char *);
extern intptr_t __cdecl _wdospawn(int, const wchar_t *, wchar_t *, wchar_t *);
#endif // XBSTRICT
#ifdef _XBOX
extern int __cdecl _cenvarg(const char * const *, const char * const *,
        char **, char **, const char *);
extern int __cdecl _wcenvarg(const wchar_t * const *, const wchar_t * const *,
        wchar_t **, wchar_t **, const wchar_t *);
#ifndef _M_IX86
extern char ** _capture_argv(va_list *, const char *, char **, size_t);
extern wchar_t ** _wcapture_argv(va_list *, const wchar_t *, wchar_t **, size_t);
#endif
#endif // XBOX

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_INTERNAL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\iostream.h ===
/***
*iostream.h - definitions/declarations for iostream classes
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the iostream classes.
*       [AT&T C++]
*
*       [Public]
*
*Revision History:
*       01-23-92  KRS   Ported from 16-bit version.
*       02-23-92  KRS   Added cruntime.h.
*       02-23-93  SKS   Update copyright to 1993
*       03-23-93  CFW   Modified #pragma warnings.
*       09-01-93  GJF   Merged Cuda and NT SDK versions.
*       10-13-93  GJF   Deleted obsolete COMBOINC check. Enclose #pragma-s
*                       in #ifdef _MSC_VER
*       08-12-94  GJF   Disable warning 4514 instead of 4505.
*       11-03-94  GJF   Changed pack pragma to 8 byte alignment.
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       05-11-95  CFW   Only for use by C++ programs.
*       12-14-95  JWM   Add "#pragma once".
*       04-09-96  SKS   Change _CRTIMP to _CRTIMP1 for special iostream build
*       04-15-96  JWM   Remove _OLD_IOSTREAMS, add '#pragma comment(lib,"cirt")'.
*       04-16-96  JWM   '#include useoldio.h' replaces '#pragma comment(...)'.
*       02-21-97  GJF   Cleaned out obsolete support for _NTSDK. Also, 
*                       detab-ed.
*       05-17-99  PML   Remove all Macintosh support.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOSTREAM
#define _INC_IOSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

#ifndef _INTERNAL_IFSTRIP_
#include <cruntime.h>
#ifndef _WINSTATIC
#define _WINSTATIC
#endif

#endif  /* !_INTERNAL_IFSTRIP_ */

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */

#ifndef _INTERNAL_IFSTRIP_
/* Define _CRTIMP1 */

#ifndef _CRTIMP1
#ifdef  CRTDLL1
#define _CRTIMP1 __declspec(dllexport)
#else   /* ndef CRTDLL1 */
#define _CRTIMP1 _CRTIMP
#endif  /* CRTDLL1 */
#endif  /* _CRTIMP1 */
#endif  /* _INTERNAL_IFSTRIP_ */

typedef long streamoff, streampos;

#include <ios.h>                // Define ios.

#include <streamb.h>            // Define streambuf.

#include <istream.h>            // Define istream.

#include <ostream.h>            // Define ostream.

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

class _CRTIMP1 iostream : public istream, public ostream {
public:
        iostream(streambuf*);
        virtual ~iostream();
protected:
        iostream();
        iostream(const iostream&);
inline iostream& operator=(streambuf*);
inline iostream& operator=(iostream&);
private:
        iostream(ios&);
        iostream(istream&);
        iostream(ostream&);
};

inline iostream& iostream::operator=(streambuf* _sb) { istream::operator=(_sb); ostream::operator=(_sb); return *this; }

inline iostream& iostream::operator=(iostream& _strm) { return operator=(_strm.rdbuf()); }

class _CRTIMP1 Iostream_init {
public:
        Iostream_init();
        Iostream_init(ios &, int =0);   // treat as private
        ~Iostream_init();
};

// used internally
// static Iostream_init __iostreaminit; // initializes cin/cout/cerr/clog

#ifdef  _MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\ios.h ===
/***
*ios.h - definitions/declarations for the ios class.
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the ios class.
*       [AT&T C++]
*
*       [Public]
*
*Revision History:
*       01-23-92  KRS   Ported from 16-bit version.
*       03-02-92  KRS   Added locks for multithread support.
*       06-03-92  KRS   Add NULL definition here too, for convenience.
*       08-27-92  KRS   Removed bogus 'short' defs from private section.
*       02-23-93  SKS   Update copyright to 1993
*       03-23-93  CFW   Modified #pragma warnings.
*       10-06-93  GJF   Merged Cuda and NT version. Replaced MTHREAD with
*                       _MT.
*       10-13-93  GJF   Deleted obsolete COMBOINC check. Enclose #pragma-s
*                       in #ifdef _MSC_VER
*       10-28-93  SKS   Add _mttermlock() as d-tor versionf _mtinitlock()
*       03-03-94  SKS   Add __cdecl keyword to _mt*lock* functions.
*                       _mtlockinit & _mtlockterm are for internal use only.
*       04-12-94  SKS   Add __cdecl keyword to dec/hex/oct functions.
*       08-12-94  GJF   Disable warning 4514 instead of 4505.
*       11-03-94  GJF   Changed pack pragma to 8 byte alignment.
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       02-30-95  CFW   Fix _CRT_CRITICAL_SECTION stuff.
*       05-11-95  CFW   Only for use by C++ programs.
*       12-14-95  JWM   Add "#pragma once".
*       04-09-96  SKS   Change _CRTIMP to _CRTIMP1 for special iostream build
*       04-15-96  JWM   Remove _OLD_IOSTREAMS, add '#pragma comment(lib,"cirt")'.
*       04-16-96  JWM   '#include useoldio.h' replaces '#pragma comment(...)'.
*       02-21-97  GJF   Cleaned out obsolete support for _NTSDK. Also, 
*                       detab-ed.
*       05-17-99  PML   Remove all Macintosh support.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOS
#define _INC_IOS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */

#ifndef _INTERNAL_IFSTRIP_
/* Define _CRTIMP1 */

#ifndef _CRTIMP1
#ifdef  CRTDLL1
#define _CRTIMP1 __declspec(dllexport)
#else   /* ndef CRTDLL1 */
#define _CRTIMP1 _CRTIMP
#endif  /* CRTDLL1 */
#endif  /* _CRTIMP1 */
#endif  /* _INTERNAL_IFSTRIP_ */

#ifdef  _MT

typedef struct __CRT_LIST_ENTRY {
   struct __CRT_LIST_ENTRY *Flink;
   struct __CRT_LIST_ENTRY *Blink;
} _CRT_LIST_ENTRY;

typedef struct _CRT_CRITICAL_SECTION_DEBUG {
    unsigned short Type;
    unsigned short CreatorBackTraceIndex;
    struct _CRT_CRITICAL_SECTION *CriticalSection;
    _CRT_LIST_ENTRY ProcessLocksList;
    unsigned long EntryCount;
    unsigned long ContentionCount;
    unsigned long Depth;
    void * OwnerBackTrace[ 5 ];
} _CRT_CRITICAL_SECTION_DEBUG, *_PCRT_CRITICAL_SECTION_DEBUG;

typedef struct _CRT_CRITICAL_SECTION {
    _PCRT_CRITICAL_SECTION_DEBUG DebugInfo;

    //
    //  The following three fields control entering and exiting the critical
    //  section for the resource
    //

#ifdef _XBOX

    long SynchronizationObject[4];
    long LockCount;
    long RecursionCount;
    void * OwningThread;        // from the thread's ClientId->UniqueThread

#else

    long LockCount;
    long RecursionCount;
    void * OwningThread;        // from the thread's ClientId->UniqueThread
    void * LockSemaphore;
    unsigned long Reserved;

#endif // XBOX

} _CRT_CRITICAL_SECTION, *_PCRT_CRITICAL_SECTION;

extern "C" {
#ifndef _INTERNAL_IFSTRIP_
void __cdecl _mtlockinit(_PCRT_CRITICAL_SECTION);
void __cdecl _mtlockterm(_PCRT_CRITICAL_SECTION);
#endif
_CRTIMP1 void __cdecl _mtlock(_PCRT_CRITICAL_SECTION);
_CRTIMP1 void __cdecl _mtunlock(_PCRT_CRITICAL_SECTION);
}

#endif  /* _MT */

#ifndef NULL
#define NULL    0
#endif

#ifndef EOF
#define EOF     (-1)
#endif

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

class _CRTIMP1 streambuf;
class _CRTIMP1 ostream;

class _CRTIMP1 ios {

public:
    enum io_state {  goodbit = 0x00,
                     eofbit  = 0x01,
                     failbit = 0x02,
                     badbit  = 0x04 };

    enum open_mode { in        = 0x01,
                     out       = 0x02,
                     ate       = 0x04,
                     app       = 0x08,
                     trunc     = 0x10,
                     nocreate  = 0x20,
                     noreplace = 0x40,
                     binary    = 0x80 };

    enum seek_dir { beg=0, cur=1, end=2 };

    enum {  skipws     = 0x0001,
            left       = 0x0002,
            right      = 0x0004,
            internal   = 0x0008,
            dec        = 0x0010,
            oct        = 0x0020,
            hex        = 0x0040,
            showbase   = 0x0080,
            showpoint  = 0x0100,
            uppercase  = 0x0200,
            showpos    = 0x0400,
            scientific = 0x0800,
            fixed      = 0x1000,
            unitbuf    = 0x2000,
            stdio      = 0x4000
                                 };

    static const long basefield;        // dec | oct | hex
    static const long adjustfield;      // left | right | internal
    static const long floatfield;       // scientific | fixed

    ios(streambuf*);                    // differs from ANSI
    virtual ~ios();

    inline long flags() const;
    inline long flags(long _l);

    inline long setf(long _f,long _m);
    inline long setf(long _l);
    inline long unsetf(long _l);

    inline int width() const;
    inline int width(int _i);

    inline ostream* tie(ostream* _os);
    inline ostream* tie() const;

    inline char fill() const;
    inline char fill(char _c);

    inline int precision(int _i);
    inline int precision() const;

    inline int rdstate() const;
    inline void clear(int _i = 0);

//  inline operator void*() const;
    operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
    inline int operator!() const;

    inline int  good() const;
    inline int  eof() const;
    inline int  fail() const;
    inline int  bad() const;

    inline streambuf* rdbuf() const;

    inline long & iword(int) const;
    inline void * & pword(int) const;

    static long bitalloc();
    static int xalloc();
    static void sync_with_stdio();

#ifdef  _MT
    inline void __cdecl setlock();
    inline void __cdecl clrlock();
    void __cdecl lock() { if (LockFlg<0) _mtlock(lockptr()); };
    void __cdecl unlock() { if (LockFlg<0) _mtunlock(lockptr()); }
    inline void __cdecl lockbuf();
    inline void __cdecl unlockbuf();
#else
    void __cdecl lock() { }
    void __cdecl unlock() { }
    void __cdecl lockbuf() { }
    void __cdecl unlockbuf() { }
#endif

protected:
    ios();
    ios(const ios&);                    // treat as private
    ios& operator=(const ios&);
    void init(streambuf*);

    enum { skipping, tied };
    streambuf*  bp;

    int     state;
    int     ispecial;                   // not used
    int     ospecial;                   // not used
    int     isfx_special;               // not used
    int     osfx_special;               // not used
    int     x_delbuf;                   // if set, rdbuf() deleted by ~ios

    ostream* x_tie;
    long    x_flags;
    int     x_precision;
    char    x_fill;
    int     x_width;

    static void (*stdioflush)();        // not used

#ifdef  _MT
    static void lockc() { _mtlock(& x_lockc); }
    static void unlockc() { _mtunlock( & x_lockc); }
    _PCRT_CRITICAL_SECTION lockptr() { return & x_lock; }
#else
    static void lockc() { }
    static void unlockc() { }
#endif

public:
    int delbuf() const { return x_delbuf; }
    void    delbuf(int _i) { x_delbuf = _i; }

private:
    static long x_maxbit;
    static int x_curindex;
    static int sunk_with_stdio;         // make sure sync_with done only once
#ifdef  _MT
#define MAXINDEX 7
    static long x_statebuf[MAXINDEX+1];  // used by xalloc()
    static int fLockcInit;              // used to see if x_lockc initialized
    static _CRT_CRITICAL_SECTION x_lockc; // used to lock static (class) data members
    int LockFlg;                        // enable locking flag
    _CRT_CRITICAL_SECTION x_lock;       // used for multi-thread lock on object
#else
    static long * x_statebuf;  // used by xalloc()
#endif
};

#include <streamb.h>

inline _CRTIMP1 ios& __cdecl dec(ios& _strm) { _strm.setf(ios::dec,ios::basefield); return _strm; }
inline _CRTIMP1 ios& __cdecl hex(ios& _strm) { _strm.setf(ios::hex,ios::basefield); return _strm; }
inline _CRTIMP1 ios& __cdecl oct(ios& _strm) { _strm.setf(ios::oct,ios::basefield); return _strm; }

inline long ios::flags() const { return x_flags; }
inline long ios::flags(long _l){ long _lO; _lO = x_flags; x_flags = _l; return _lO; }

inline long ios::setf(long _l,long _m){ long _lO; lock(); _lO = x_flags; x_flags = (_l&_m) | (x_flags&(~_m)); unlock(); return _lO; }
inline long ios::setf(long _l){ long _lO; lock(); _lO = x_flags; x_flags |= _l; unlock(); return _lO; }
inline long ios::unsetf(long _l){ long _lO; lock(); _lO = x_flags; x_flags &= (~_l); unlock(); return _lO; }

inline int ios::width() const { return x_width; }
inline int ios::width(int _i){ int _iO; _iO = (int)x_width; x_width = _i; return _iO; }

inline ostream* ios::tie(ostream* _os){ ostream* _osO; _osO = x_tie; x_tie = _os; return _osO; }
inline ostream* ios::tie() const { return x_tie; }
inline char ios::fill() const { return x_fill; }
inline char ios::fill(char _c){ char _cO; _cO = x_fill; x_fill = _c; return _cO; }
inline int ios::precision(int _i){ int _iO; _iO = (int)x_precision; x_precision = _i; return _iO; }
inline int ios::precision() const { return x_precision; }

inline int ios::rdstate() const { return state; }

// inline ios::operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
inline int ios::operator!() const { return state&(badbit|failbit); }

inline int  ios::bad() const { return state & badbit; }
inline void ios::clear(int _i){ lock(); state = _i; unlock(); }
inline int  ios::eof() const { return state & eofbit; }
inline int  ios::fail() const { return state & (badbit | failbit); }
inline int  ios::good() const { return state == 0; }

inline streambuf* ios::rdbuf() const { return bp; }

inline long & ios::iword(int _i) const { return x_statebuf[_i] ; }
inline void * & ios::pword(int _i) const { return (void * &)x_statebuf[_i]; }

#ifdef  _MT
    inline void ios::setlock() { LockFlg--; if (bp) bp->setlock(); }
    inline void ios::clrlock() { if (LockFlg <= 0) LockFlg++; if (bp) bp->clrlock(); }
    inline void ios::lockbuf() { bp->lock(); }
    inline void ios::unlockbuf() { bp->unlock(); }
#endif

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOS

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\io.h ===
/***
*io.h - declarations for low-level file handling and I/O functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the low-level
*       file handling and I/O functions.
*
*       [Public]
*
*Revision History:
*       10/20/87  JCR   Removed "MSC40_ONLY" entries
*       11/09/87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_loadds" functionality
*       12-17-87  JCR   Added _MTHREAD_ONLY comments
*       12-18-87  JCR   Added _FAR_ to declarations
*       02-10-88  JCR   Cleaned up white space
*       08-19-88  GJF   Modified to also work for the 386 (small model only)
*       05-03-89  JCR   Added _INTERNAL_IFSTRIP for relinc usage
*       08-03-89  GJF   Cleanup, now specific to OS/2 2.0 (i.e., 386 flat model)
*       08-14-89  GJF   Added prototype for _pipe()
*       10-30-89  GJF   Fixed copyright
*       11-02-89  JCR   Changed "DLL" to "_DLL"
*       11-17-89  GJF   read() should take "void *" not "char *", write()
*                       should take "const void *" not "char *". Also,
*                       added const to appropriate arg types for access(),
*                       chmod(), creat(), open() and sopen()
*       03-01-90  GJF   Added #ifndef _INC_IO and #include <cruntime.h>
*                       stuff. Also, removed some (now) useless preprocessor
*                       directives.
*       03-21-90  GJF   Replaced _cdecl with _CALLTYPE1 or _CALLTYPE2 in
*                       prototypes.
*       05-28-90  SBM   Added _commit()
*       01-18-91  GJF   ANSI naming.
*       02-25-91  SRW   Exposed _get_osfhandle and _open_osfhandle [_WIN32_]
*       08-01-91  GJF   No _pipe for Dosx32.
*       08-20-91  JCR   C++ and ANSI naming
*       08-26-91  BWM   Added _findfirst, etc.
*       09-16-91  BWM   Changed find handle type to long.
*       09-28-91  JCR   ANSI names: DOSX32=prototypes, WIN32=#defines for now
*       03-30-92  DJM   POSIX support.
*       06-23-92  GJF   // is non-ANSI comment delimiter.
*       08-06-92  GJF   Function calling type and variable type macros.
*       08-25-92  GJF   For POSIX build, #ifdef-ed out all but some internally
*                       used macros (and these are stripped out on release).
*       09-03-92  GJF   Merge two changes above.
*       01-21-93  GJF   Removed support for C6-386's _cdecl.
*       03-29-93  JWM   Increased name buffer in finddata structure to 260 bytes.
*       04-06-93  SKS   Replace _CRTAPI1/2 with __cdecl, _CRTVAR1 with nothing
*       04-07-93  SKS   Add _CRTIMP keyword for CRT DLL model
*                       Use link-time aliases for old names, not #define's
*       05-17-93  SKS   #if for old names no longer checks for _cplusplus.
*                       It used to do so past because #define-ing names like
*                       open, read, write, etc. created problems for users
*       09-01-93  GJF   Merged NT SDK and Cuda versions.
*       12-07-93  CFW   Add wide char version protos.
*       11-03-94  GJF   Ensure 8 byte alignment.
*       11-18-94  GJF   Added prototypes for _lseeki64, _filelengthi64 and
*                       _telli64.
*       12-07-94  SKS   Add comment for ifstrip utility (src release process)
*       12-15-94  XY    merged with mac header
*       12-29-94  GJF   Added _[w]findfilei64 and _[w]findnexti64. Also removed
*                       obsolete _CALLTYPE* macro.
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       02-24-95  SKS   Replace _MTHREAD_ONLY comments (stripped by source
*                       cleansing) with #ifdef _NOT_CRTL_BUILD_
*       10-06-95  SKS   Add "const" to "char *" in prototypes for *findfirst().
*       12-14-95  JWM   Add "#pragma once".
*       02-20-97  GJF   Cleaned out obsolete support for _CRTAPI* and _NTSDK.
*                       Also, detab-ed.
*       09-30-97  JWM   Restored not-so-obsolete _CRTAPI1 support.
*       10-07-97  RDL   Added IA64.
*       02-10-98  GJF   Changes for Win64: made time_t __int64, and changed
*                       arg and return types to intptr_t where appropriate
*       05-04-98  GJF   Added __time64_t support.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*       10-06-99  PML   Add _W64 modifier to types which are 32 bits in Win32,
*                       64 bits in Win64.
*       11-12-99  PML   Wrap __time64_t in its own #ifndef.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_IO
#define _INC_IO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifndef _POSIX_

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _INTERNAL_IFSTRIP_
#include <cruntime.h>
#endif  /* _INTERNAL_IFSTRIP_ */

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300 /*IFSTRIP=IGN*/
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _TIME64_T_DEFINED
#if     _INTEGRAL_MAX_BITS >= 64    /*IFSTRIP=IGN*/
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME64_T_DEFINED
#endif

#ifndef _FSIZE_T_DEFINED
typedef unsigned long _fsize_t; /* Could be 64 bits for Win32 */
#define _FSIZE_T_DEFINED
#endif

#ifndef _FINDDATA_T_DEFINED

struct _finddata_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        _fsize_t    size;
        char        name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64    /*IFSTRIP=IGN*/

struct _finddatai64_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        __int64     size;
        char        name[260];
};

struct __finddata64_t {
        unsigned    attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        char        name[260];
};

#endif

#define _FINDDATA_T_DEFINED
#endif

#ifndef _WFINDDATA_T_DEFINED

struct _wfinddata_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        _fsize_t    size;
        wchar_t     name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64    /*IFSTRIP=IGN*/

struct _wfinddatai64_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        __int64     size;
        wchar_t     name[260];
};

struct __wfinddata64_t {
        unsigned    attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

#endif

#define _WFINDDATA_T_DEFINED
#endif

/* File attribute constants for _findfirst() */

#define _A_NORMAL       0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY       0x01    /* Read only file */
#define _A_HIDDEN       0x02    /* Hidden file */
#define _A_SYSTEM       0x04    /* System file */
#define _A_SUBDIR       0x10    /* Subdirectory */
#define _A_ARCH         0x20    /* Archive file */

/* function prototypes */

_CRTIMP int __cdecl _access(const char *, int);
_CRTIMP int __cdecl _chmod(const char *, int);
_CRTIMP int __cdecl _chsize(int, long);
_CRTIMP int __cdecl _close(int);
_CRTIMP int __cdecl _commit(int);
_CRTIMP int __cdecl _creat(const char *, int);
_CRTIMP int __cdecl _dup(int);
_CRTIMP int __cdecl _dup2(int, int);
_CRTIMP int __cdecl _eof(int);
_CRTIMP long __cdecl _filelength(int);
_CRTIMP intptr_t __cdecl _findfirst(const char *, struct _finddata_t *);
_CRTIMP int __cdecl _findnext(intptr_t, struct _finddata_t *);
_CRTIMP int __cdecl _findclose(intptr_t);
_CRTIMP int __cdecl _isatty(int);
#ifndef _XBSTRICT
_CRTIMP int __cdecl _locking(int, int, long);
#endif // XBSTRICT
_CRTIMP long __cdecl _lseek(int, long, int);
_CRTIMP char * __cdecl _mktemp(char *);
_CRTIMP int __cdecl _open(const char *, int, ...);
#ifndef _XBSTRICT
_CRTIMP int __cdecl _pipe(int *, unsigned int, int);
#endif // XBSTRICT
_CRTIMP int __cdecl _read(int, void *, unsigned int);
_CRTIMP int __cdecl remove(const char *);
_CRTIMP int __cdecl rename(const char *, const char *);
_CRTIMP int __cdecl _setmode(int, int);
_CRTIMP int __cdecl _sopen(const char *, int, int, ...);
_CRTIMP long __cdecl _tell(int);
_CRTIMP int __cdecl _umask(int);
_CRTIMP int __cdecl _unlink(const char *);
_CRTIMP int __cdecl _write(int, const void *, unsigned int);

#if     _INTEGRAL_MAX_BITS >= 64    /*IFSTRIP=IGN*/
_CRTIMP __int64 __cdecl _filelengthi64(int);
_CRTIMP intptr_t __cdecl _findfirsti64(const char *, struct _finddatai64_t *);
_CRTIMP intptr_t __cdecl _findfirst64(const char *, struct __finddata64_t *);
_CRTIMP int __cdecl _findnexti64(intptr_t, struct _finddatai64_t *);
_CRTIMP int __cdecl _findnext64(intptr_t, struct __finddata64_t *);
_CRTIMP __int64 __cdecl _lseeki64(int, __int64, int);
_CRTIMP __int64 __cdecl _telli64(int);
#endif

#ifndef _WIO_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _waccess(const wchar_t *, int);
_CRTIMP int __cdecl _wchmod(const wchar_t *, int);
_CRTIMP int __cdecl _wcreat(const wchar_t *, int);
_CRTIMP intptr_t __cdecl _wfindfirst(const wchar_t *, struct _wfinddata_t *);
_CRTIMP int __cdecl _wfindnext(intptr_t, struct _wfinddata_t *);
_CRTIMP int __cdecl _wunlink(const wchar_t *);
_CRTIMP int __cdecl _wrename(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wopen(const wchar_t *, int, ...);
_CRTIMP int __cdecl _wsopen(const wchar_t *, int, int, ...);
_CRTIMP wchar_t * __cdecl _wmktemp(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64 /*IFSTRIP=IGN*/
_CRTIMP intptr_t __cdecl _wfindfirsti64(const wchar_t *, struct _wfinddatai64_t *);
_CRTIMP int __cdecl _wfindnexti64(intptr_t, struct _wfinddatai64_t *);
_CRTIMP intptr_t __cdecl _wfindfirst64(const wchar_t *, struct __wfinddata64_t *);
_CRTIMP int __cdecl _wfindnext64(intptr_t, struct __wfinddata64_t *);
#endif

#define _WIO_DEFINED
#endif

#ifndef _NOT_CRTL_BUILD_
#ifdef  _MT
int __cdecl _chsize_lk(int,long);
int __cdecl _close_lk(int);
long __cdecl _lseek_lk(int, long, int);
int __cdecl _setmode_lk(int, int);
int __cdecl _read_lk(int, void *, unsigned int);
int __cdecl _write_lk(int, const void *, unsigned int);
#if     _INTEGRAL_MAX_BITS >= 64 /*IFSTRIP=IGN*/
__int64 __cdecl _lseeki64_lk(int, __int64, int);
#endif
#else   /* not _MT */
#define _chsize_lk(fh,size)             _chsize(fh,size)
#define _close_lk(fh)                   _close(fh)
#define _lseek_lk(fh,offset,origin)     _lseek(fh,offset,origin)
#define _setmode_lk(fh,mode)            _setmode(fh,mode)
#define _read_lk(fh,buff,count)         _read(fh,buff,count)
#define _write_lk(fh,buff,count)        _write(fh,buff,count)
#if     _INTEGRAL_MAX_BITS >= 64 /*IFSTRIP=IGN*/
#define _lseeki64_lk(fh,offset,origin)  _lseeki64(fh,offset,origin)
#endif
#endif  /* _MT */
#endif  /* _NOT_CRTL_BUILD_ */

_CRTIMP intptr_t __cdecl _get_osfhandle(int);
_CRTIMP int __cdecl _open_osfhandle(intptr_t, int);

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP int __cdecl access(const char *, int);
_CRTIMP int __cdecl chmod(const char *, int);
_CRTIMP int __cdecl chsize(int, long);
_CRTIMP int __cdecl close(int);
_CRTIMP int __cdecl creat(const char *, int);
_CRTIMP int __cdecl dup(int);
_CRTIMP int __cdecl dup2(int, int);
_CRTIMP int __cdecl eof(int);
_CRTIMP long __cdecl filelength(int);
_CRTIMP int __cdecl isatty(int);
_CRTIMP int __cdecl locking(int, int, long);
_CRTIMP long __cdecl lseek(int, long, int);
_CRTIMP char * __cdecl mktemp(char *);
_CRTIMP int __cdecl open(const char *, int, ...);
_CRTIMP int __cdecl read(int, void *, unsigned int);
_CRTIMP int __cdecl setmode(int, int);
_CRTIMP int __cdecl sopen(const char *, int, int, ...);
_CRTIMP long __cdecl tell(int);
_CRTIMP int __cdecl umask(int);
_CRTIMP int __cdecl unlink(const char *);
_CRTIMP int __cdecl write(int, const void *, unsigned int);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _POSIX_ */

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_IO */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\locale.h ===
/***
*locale.h - definitions/declarations for localization routines
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structures, values, macros, and functions
*       used by the localization routines.
*
*       [Public]
*
*Revision History:
*       03-21-89  JCR   Module created.
*       03-11-89  JCR   Modified for 386.
*       04-06-89  JCR   Corrected lconv definition (don't use typedef)
*       04-18-89  JCR   Added _LCONV_DEFINED so locale.h can be included twice
*       05-03-89  JCR   Added _INTERNAL_IFSTRIP for relinc usage
*       08-04-89  GJF   Cleanup, now specific to OS/2 2.0 (i.e., 386 flat model)
*       10-30-89  GJF   Fixed copyright, removed dummy args from prototype
*       11-02-89  JCR   Changed "DLL" to "_DLL"
*       03-01-90  GJF   Added #ifndef _INC_LOCALE and #include <cruntime.h>
*                       stuff. Also, removed some (now) useless preprocessor
*                       directives.
*       03-15-90  GJF   Replaced _cdecl with _CALLTYPE1 in prototypes.
*       11-12-90  GJF   Changed NULL to (void *)0.
*       02-12-91  GJF   Only #define NULL if it isn't #define-d.
*       08-20-91  JCR   C++ and ANSI naming
*       08-05-92  GJF   Function calling type and variable type macros.
*       12-29-92  CFW   Added _lc_time_data definition and supporting #defines.
*       01-21-93  GJF   Removed support for C6-386's _cdecl.
*       02-01-93  CFW   Removed __c_lconvinit vars to locale.h.
*       02-08-93  CFW   Removed time definitions to setlocal.h.
*       04-06-93  SKS   Replace _CRTAPI1/2 with __cdecl, _CRTVAR1 with nothing
*       04-07-93  SKS   Add _CRTIMP keyword for CRT DLL model
*       04-13-93  CFW   Add _charmax (when compiled -J, _CHAR_UNSIGNED is defined,
*                       and _charmax yanks in module to allow lconv struct members
*                       to be set to UCHAR_MAX).
*       04-14-93  CFW   Change _charmax from short to int.
*       10-07-93  GJF   Merged Cuda and NT versions.
*       12-17-93  CFW   Add wide char version protos.
*       11-03-94  GJF   Ensure 8 byte alignment.
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       12-14-95  JWM   Add "#pragma once".
*       02-20-97  GJF   Cleaned out obsolete support for _CRTAPI* and _NTSDK.
*                       Also, detab-ed.
*       09-30-97  JWM   Restored not-so-obsolete _CRTAPI1 support.
*       10-07-97  RDL   Added IA64.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_LOCALE
#define _INC_LOCALE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _INTERNAL_IFSTRIP_
#include <cruntime.h>
#endif  /* _INTERNAL_IFSTRIP_ */


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

/* Locale categories */

#define LC_ALL          0
#define LC_COLLATE      1
#define LC_CTYPE        2
#define LC_MONETARY     3
#define LC_NUMERIC      4
#define LC_TIME         5

#define LC_MIN          LC_ALL
#define LC_MAX          LC_TIME

/* Locale convention structure */

#ifndef _LCONV_DEFINED
struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        };
#define _LCONV_DEFINED
#endif

/* ANSI: char lconv members default is CHAR_MAX which is compile time
   dependent. Defining and using _charmax here causes CRT startup code
   to initialize lconv members properly */

#ifdef  _CHAR_UNSIGNED
extern int _charmax;
extern __inline int __dummy() { return _charmax; }
#endif

/* function prototypes */

_CRTIMP char * __cdecl setlocale(int, const char *);
_CRTIMP struct lconv * __cdecl localeconv(void);

#ifndef _WLOCALE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wsetlocale(int, const wchar_t *);

#define _WLOCALE_DEFINED
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_LOCALE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\iomanip.h ===
/***
*iomanip.h - definitions/declarations for iostream's parameterized manipulators
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the iostream classes' paramterized manipulators.
*       [AT&T C++]
*
*       [Public]
*
*Revision History:
*       01-23-92  KRS   Ported from 16-bit version.
*       02-23-93  SKS   Update copyright to 1993
*       06-08-93  SKS   Add "const" keyword in declaration operator >> & <<
*       10-13-93  GJF   Enclose #pragma-s in #ifdef _MSC_VER
*       08-12-94  GJF   Disable warning 4514 instead of 4505.
*       11-03-94  GJF   Changed pack pragma to 8 byte alignment.
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       05-11-95  CFW   Only for use by C++ programs.
*       12-14-95  JWM   Add "#pragma once".
*       04-15-96  JWM   Remove _OLD_IOSTREAMS, add '#pragma comment(lib,"cirt")'.
*       04-16-96  JWM   '#include useoldio.h' replaces '#pragma comment(...)'.
*       09-05-96  RDK   Change class initialization to handle reference definition.
*       02-24-97  GJF   Detab-ed.
*       05-17-99  PML   Remove all Macintosh support.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOMANIP
#define _INC_IOMANIP

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

#include <iostream.h>

#ifdef  _MSC_VER
#pragma warning(disable:4514)           // disable unwanted /W4 warning
// #pragma warning(default:4514)        // use this to reenable, if necessary
#endif  // _MSC_VER

// #define __MKMANIP(X) \#define X##(T) __##X##_ \#\# T
// __MKMANIP(SMANIP);
// __MKMANIP(SAPP);
// __MKMANIP(IMANIP);
// __MKMANIP(IAPP);
// __MKMANIP(OMANIP);
// __MKMANIP(OAPP);
// __MKMANIP(IOMANIP);
// __MKMANIP(IOAPP);

#define SMANIP(T) __SMANIP_##T
#define SAPP(T) __SAPP_##T
#define IMANIP(T) __IMANIP_##T
#define IAPP(T) __IAPP_##T
#define OMANIP(T) __OMANIP_##T
#define OAPP(T) __OAPP_##T
#define IOMANIP(T) __IOMANIP_##T
#define IOAPP(T) __IOAPP_##T

#define IOMANIPdeclare(T)  \
class SMANIP(T) { \
public: \
        SMANIP(T)(ios& (*f)(ios&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(istream& s, const SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
        friend ostream& operator<<(ostream& s, const SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
private:        \
        ios& (* _fp)(ios&,T); \
        T _tp; \
};      \
class SAPP(T) { \
public: \
        SAPP(T)( ios& (*f)(ios&,T)) : _fp(f) {} \
        SMANIP(T) operator()(T t) { return SMANIP(T)(_fp,t); }  \
private:        \
        ios& (* _fp)(ios&,T); \
};      \
class IMANIP(T) { \
public: \
        IMANIP(T)(istream& (*f)(istream&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(istream& s, IMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        istream& (* _fp)(istream&,T); \
        T _tp;  \
};      \
class IAPP(T) { \
public: \
        IAPP(T)( istream& (*f)(istream&,T)) : _fp(f) {} \
        IMANIP(T) operator()(T t) { return IMANIP(T)(_fp,t); }  \
private:        \
        istream& (* _fp)(istream&,T); \
};      \
class OMANIP(T) { \
public: \
        OMANIP(T)(ostream& (*f)(ostream&,T), T t) : _fp(f), _tp(t) {} \
        friend ostream& operator<<(ostream& s, OMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        ostream& (* _fp)(ostream&,T); \
        T _tp; \
};      \
class OAPP(T) { \
public: \
        OAPP(T)(ostream& (*f)(ostream&,T)) : _fp(f) {}  \
        OMANIP(T) operator()(T t) { return OMANIP(T)(_fp,t); } \
private:        \
        ostream& (* _fp)(ostream&,T); \
};      \
\
class IOMANIP(T) { \
public: \
        IOMANIP(T)(iostream& (*f)(iostream&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
        friend ostream& operator<<(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        iostream& (* _fp)(iostream&,T); \
        T _tp; \
};      \
class IOAPP(T) {        \
public: \
        IOAPP(T)( iostream& (*f)(iostream&,T)) : _fp(f) {}      \
        IOMANIP(T) operator()(T t) { return IOMANIP(T)(_fp,t); }        \
private:        \
        iostream& (* _fp)(iostream&,T); \
}; \

        
IOMANIPdeclare(int)

IOMANIPdeclare(long)

inline ios& __resetiosflags(ios& s, long _flg) { s.setf(0,_flg); return s; }
inline ios& __setfill(ios& s, int _fc) { s.fill((char)_fc); return s; }
inline ios& __setiosflags(ios& s, long _flg) { s.setf(_flg); return s; }
inline ios& __setprecision(ios& s, int _pre) { s.precision(_pre); return s; }
inline ios& __setw(ios& s, int _wid) { s.width(_wid); return s; }

inline SMANIP(long)     resetiosflags(long _l) { return SMANIP(long)(__resetiosflags, _l); }
inline SMANIP(int)      setfill(int _m) {return SMANIP(int)(__setfill, _m); }
inline SMANIP(long)     setiosflags(long _l) {return SMANIP(long)(__setiosflags, _l); }
inline SMANIP(int)      setprecision(int _p) {return SMANIP(int)(__setprecision, _p); }
inline SMANIP(int)      setw(int _w) { return SMANIP(int)(__setw, _w); }

// Restore previous packing
#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOMANIP

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\limits.h ===
/***
*limits.h - implementation dependent values
*
*       Copyright (c) 1985-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Contains defines for a number of implementation dependent values
*       which are commonly used in C programs.
*       [ANSI]
*
*       [Public]
*
*Revision History:
*       06-03-87  JMB   Added support for unsigned char max values
*       08-19-88  GJF   Revised to also support the 386
*       04-28-89  SKS   Put parentheses around negative constants
*       08-17-89  GJF   Cleanup, now specific to 386
*       10-30-89  GJF   Fixed copyright
*       11-15-89  KRS   Add MB_LEN_MAX, fix CHAR_MIN/MAX, order like ANSI spec.
*       03-01-90  GJF   Added #ifndef _INC_LIMITS stuff
*       02-21-91  KRS   Change MB_LEN_MAX to 2 for C 7.00.
*       03-30-92  DJM   POSIX support.
*       08-22-92  SRW   Fix value of _POSIX_ARG_MAX
*       12-14-92  SRW   Fix value of _POSIX_ARG_MAX again
*       12-14-92  SRW   Back merge MattBr's changes from 10/29/92
*       01-15-93  CFW   Added __c_lconvinit dummy variable.
*       01-28-93  SRW   MAke PATH_MAX for Posix right for Posix
*       02-01-93  CFW   Removed __c_lconvinit vars to locale.h.
*       03-10-93  MJB   More fixes for Posix.
*       04-07-93  SKS   Fix copyright
*       04-20-93  GJF   Changed SCHAR_MIN, SHRT_MIN, INT_MIN, LONG_MIN
*       04-21-93  GJF   By directive of JonM, backed out prior change.
*       04-26-93  GJF   By directive of JonM, restored change.
*       02-01-94  GJF   Added type suffixes to LONG_MAX, LONG_MIN and
*                       ULONG_MAX. Added constants for sized integer types.
*       02-23-94  CFW   Add u suffixes.
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       12-14-95  JWM   Add "#pragma once".
*       01-01-96  BWT   Define LINK_MAX for POSIX.
*       02-24-97  GJF   Detab-ed.
*       05-17-99  PML   Remove all Macintosh support.
*       12-16-99  GB    Updated MB_LEN_MAX
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_LIMITS
#define _INC_LIMITS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#define CHAR_BIT      8         /* number of bits in a char */
#define SCHAR_MIN   (-128)      /* minimum signed char value */
#define SCHAR_MAX     127       /* maximum signed char value */
#define UCHAR_MAX     0xff      /* maximum unsigned char value */

#ifndef _CHAR_UNSIGNED
#define CHAR_MIN    SCHAR_MIN   /* mimimum char value */
#define CHAR_MAX    SCHAR_MAX   /* maximum char value */
#else
#define CHAR_MIN      0
#define CHAR_MAX    UCHAR_MAX
#endif  /* _CHAR_UNSIGNED */

#define MB_LEN_MAX    5             /* max. # bytes in multibyte char */
#define SHRT_MIN    (-32768)        /* minimum (signed) short value */
#define SHRT_MAX      32767         /* maximum (signed) short value */
#define USHRT_MAX     0xffff        /* maximum unsigned short value */
#define INT_MIN     (-2147483647 - 1) /* minimum (signed) int value */
#define INT_MAX       2147483647    /* maximum (signed) int value */
#define UINT_MAX      0xffffffff    /* maximum unsigned int value */
#define LONG_MIN    (-2147483647L - 1) /* minimum (signed) long value */
#define LONG_MAX      2147483647L   /* maximum (signed) long value */
#define ULONG_MAX     0xffffffffUL  /* maximum unsigned long value */

#if     _INTEGRAL_MAX_BITS >= 8 /*IFSTRIP=IGN*/
#define _I8_MIN     (-127i8 - 1)    /* minimum signed 8 bit value */
#define _I8_MAX       127i8         /* maximum signed 8 bit value */
#define _UI8_MAX      0xffui8       /* maximum unsigned 8 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 16 /*IFSTRIP=IGN*/
#define _I16_MIN    (-32767i16 - 1) /* minimum signed 16 bit value */
#define _I16_MAX      32767i16      /* maximum signed 16 bit value */
#define _UI16_MAX     0xffffui16    /* maximum unsigned 16 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 32 /*IFSTRIP=IGN*/
#define _I32_MIN    (-2147483647i32 - 1) /* minimum signed 32 bit value */
#define _I32_MAX      2147483647i32 /* maximum signed 32 bit value */
#define _UI32_MAX     0xffffffffui32 /* maximum unsigned 32 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 64 /*IFSTRIP=IGN*/
/* minimum signed 64 bit value */
#define _I64_MIN    (-9223372036854775807i64 - 1)
/* maximum signed 64 bit value */
#define _I64_MAX      9223372036854775807i64
/* maximum unsigned 64 bit value */
#define _UI64_MAX     0xffffffffffffffffui64
#endif

#if     _INTEGRAL_MAX_BITS >= 128 /*IFSTRIP=IGN*/
/* minimum signed 128 bit value */
#define _I128_MIN   (-170141183460469231731687303715884105727i128 - 1)
/* maximum signed 128 bit value */
#define _I128_MAX     170141183460469231731687303715884105727i128
/* maximum unsigned 128 bit value */
#define _UI128_MAX    0xffffffffffffffffffffffffffffffffui128
#endif

#ifdef  _POSIX_

#define _POSIX_ARG_MAX      4096
#define _POSIX_CHILD_MAX    6
#define _POSIX_LINK_MAX     8
#define _POSIX_MAX_CANON    255
#define _POSIX_MAX_INPUT    255
#define _POSIX_NAME_MAX     14
#define _POSIX_NGROUPS_MAX  0
#define _POSIX_OPEN_MAX     16
#define _POSIX_PATH_MAX     255
#define _POSIX_PIPE_BUF     512
#define _POSIX_SSIZE_MAX    32767
#define _POSIX_STREAM_MAX   8
#define _POSIX_TZNAME_MAX   3

#define ARG_MAX             14500       /* 16k heap, minus overhead */
#define LINK_MAX            1024
#define MAX_CANON           _POSIX_MAX_CANON
#define MAX_INPUT           _POSIX_MAX_INPUT
#define NAME_MAX            255
#define NGROUPS_MAX         16
#define OPEN_MAX            32
#define PATH_MAX            512
#define PIPE_BUF            _POSIX_PIPE_BUF
#define SSIZE_MAX           _POSIX_SSIZE_MAX
#define STREAM_MAX          20
#define TZNAME_MAX          10

#endif  /* POSIX */

#endif  /* _INC_LIMITS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\istream.h ===
/***
*istream.h - definitions/declarations for the istream class
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the istream class.
*       [AT&T C++]
*
*       [Public]
*
*Revision History:
*       01-23-92  KRS   Ported from 16-bit version.
*       02-23-93  SKS   Update copyright to 1993
*       03-23-93  CFW   Modified #pragma warnings.
*       05-10-93  CFW   Enable operator<<(long double)
*       05-11-93  CFW   Add _CRTIMP directive to class definition.
*       09-01-93  GJF   Merged Cuda and NT SDK versions.
*       10-13-93  GJF   Deleted obsolete COMBOINC check. Enclose #pragma-s
*                       in #ifdef _MSC_VER
*       04-12-94  SKS   Add __cdecl keyword to dec/hex/oct functions and
*                       operator >>.  Add underscores to some parameter names.
*       05-24-94  GJF   Added definition of MAXLONGSIZ for internal use.
*       06-06-94  CFW   Fix ignore, bad return.
*       08-12-94  GJF   Disable warning 4514 instead of 4505.
*       11-03-94  GJF   Changed pack pragma to 8 byte alignment.
*       01-26-95  CFW   Removed QWIN ifdef.
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       05-11-95  CFW   Only for use by C++ programs.
*       05-24-95  CFW   Support for ignore(.., 0xFF).
*       06-21-95  CFW   Add inline support for ignore(.., 0xFF).
*       07-07-95  CFW   Fix ambiguous get.
*       07-17-95  CFW   Make get(char*,int,int) protected.
*       12-14-95  JWM   Add "#pragma once".
*       04-09-96  SKS   Change _CRTIMP to _CRTIMP1 for special iostream build
*       04-15-96  JWM   Remove _OLD_IOSTREAMS, add '#pragma comment(lib,"cirt")'.
*       04-16-96  JWM   '#include useoldio.h' replaces '#pragma comment(...)'.
*       02-24-97  GJF   Cleaned out obsolete support for _NTSDK. Also,
*                       detab-ed.
*       05-17-99  PML   Remove all Macintosh support.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_ISTREAM
#define _INC_ISTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */

#ifndef _INTERNAL_IFSTRIP_
/* Define _CRTIMP1 */

#ifndef _CRTIMP1
#ifdef  CRTDLL1
#define _CRTIMP1 __declspec(dllexport)
#else   /* ndef CRTDLL1 */
#define _CRTIMP1 _CRTIMP
#endif  /* CRTDLL1 */
#endif  /* _CRTIMP1 */
#endif  /* _INTERNAL_IFSTRIP_ */

#include <ios.h>

#ifdef  _MSC_VER
// C4069: "long double != double"
#pragma warning(disable:4069)   // disable C4069 warning
// #pragma warning(default:4069)    // use this to reenable, if desired

// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)    // use this to reenable, if desired
#endif  // _MSC_VER

#ifndef _INTERNAL_IFSTRIP_
#define MAXLONGSIZ  16
#endif  /* _INTERNAL_IFSTRIP_ */

typedef long streamoff, streampos;

class _CRTIMP1 istream : virtual public ios {

public:
    istream(streambuf*);
    virtual ~istream();

    int  ipfx(int =0);
    void isfx() { unlockbuf(); unlock(); }

    inline istream& operator>>(istream& (__cdecl * _f)(istream&));
    inline istream& operator>>(ios& (__cdecl * _f)(ios&));
    istream& operator>>(char *);
    inline istream& operator>>(unsigned char *);
    inline istream& operator>>(signed char *);
    istream& operator>>(char &);
    inline istream& operator>>(unsigned char &);
    inline istream& operator>>(signed char &);
    istream& operator>>(short &);
    istream& operator>>(unsigned short &);
    istream& operator>>(int &);
    istream& operator>>(unsigned int &);
    istream& operator>>(long &);
    istream& operator>>(unsigned long &);
    istream& operator>>(float &);
    istream& operator>>(double &);
    istream& operator>>(long double &);
    istream& operator>>(streambuf*);

    int get();

    inline istream& get(         char *,int,char ='\n');
    inline istream& get(unsigned char *,int,char ='\n');
    inline istream& get(  signed char *,int,char ='\n');

    istream& get(char &);
    inline istream& get(unsigned char &);
    inline istream& get(  signed char &);

    istream& get(streambuf&,char ='\n');
    inline istream& getline(         char *,int,char ='\n');
    inline istream& getline(unsigned char *,int,char ='\n');
    inline istream& getline(  signed char *,int,char ='\n');

    inline istream& ignore(int =1,int =EOF);
    istream& read(char *,int);
    inline istream& read(unsigned char *,int);
    inline istream& read(signed char *,int);

    int gcount() const { return x_gcount; }
    int peek();
    istream& putback(char);
    int sync();

    istream& seekg(streampos);
    istream& seekg(streamoff,ios::seek_dir);
    streampos tellg();

    void eatwhite();

protected:
    istream();
    istream(const istream&);    // treat as private
    istream& operator=(streambuf* _isb); // treat as private
    istream& operator=(const istream& _is) { return operator=(_is.rdbuf()); }
    istream& get(char *, int, int);
     int do_ipfx(int);

private:
    istream(ios&);
    int getint(char *);
    int getdouble(char *, int);
    int _fGline;
    int x_gcount;
};

    inline istream& istream::operator>>(istream& (__cdecl * _f)(istream&)) { (*_f)(*this); return *this; }
    inline istream& istream::operator>>(ios& (__cdecl * _f)(ios&)) { (*_f)(*this); return *this; }

    inline istream& istream::operator>>(unsigned char * _s) { return operator>>((char *)_s); }
    inline istream& istream::operator>>(  signed char * _s) { return operator>>((char *)_s); }

    inline istream& istream::operator>>(unsigned char & _c) { return operator>>((char &) _c); }
    inline istream& istream::operator>>(  signed char & _c) { return operator>>((char &) _c); }

    inline istream& istream::get(         char * _b, int _lim, char _delim) { return get(        _b, _lim, (int)(unsigned char)_delim); }
    inline istream& istream::get(unsigned char * _b, int _lim, char _delim) { return get((char *)_b, _lim, (int)(unsigned char)_delim); }
    inline istream& istream::get(signed   char * _b, int _lim, char _delim) { return get((char *)_b, _lim, (int)(unsigned char)_delim); }

    inline istream& istream::get(unsigned char & _c) { return get((char &)_c); }
    inline istream& istream::get(  signed char & _c) { return get((char &)_c); }

    inline istream& istream::getline(         char * _b,int _lim,char _delim) { lock(); _fGline++; get(        _b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }
    inline istream& istream::getline(unsigned char * _b,int _lim,char _delim) { lock(); _fGline++; get((char *)_b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }
    inline istream& istream::getline(  signed char * _b,int _lim,char _delim) { lock(); _fGline++; get((char *)_b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }

    inline istream& istream::ignore(int _n,int _delim) { lock(); _fGline++; get((char *)0, _n+1, _delim); unlock(); return *this; }

    inline istream& istream::read(unsigned char * _ptr, int _n) { return read((char *) _ptr, _n); }
    inline istream& istream::read(  signed char * _ptr, int _n) { return read((char *) _ptr, _n); }

class _CRTIMP1 istream_withassign : public istream {
        public:
            istream_withassign();
            istream_withassign(streambuf*);
            ~istream_withassign();
    istream& operator=(const istream& _is) { return istream::operator=(_is); }
    istream& operator=(streambuf* _isb) { return istream::operator=(_isb); }
};

extern _CRTIMP1 istream_withassign cin;

inline _CRTIMP1 istream& __cdecl ws(istream& _ins) { _ins.eatwhite(); return _ins; }

_CRTIMP1 ios&        __cdecl dec(ios&);
_CRTIMP1 ios&        __cdecl hex(ios&);
_CRTIMP1 ios&        __cdecl oct(ios&);

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_ISTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\mbdata.h ===
/***
*mbdata.h - MBCS lib data
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines data for use when building MBCS libs and routines
*
*       [Internal].
*
*Revision History:
*       11-19-92  KRS   Ported from 16-bit sources.
*       02-23-93  SKS   Update copyright to 1993
*       08-03-93  KRS   Move _ismbbtruelead() from mbctype.h. Internal-only.
*       10-13-93  GJF   Deleted obsolete COMBOINC check.
*       10-19-93  CFW   Remove _MBCS test and SBCS defines.
*       04-15-93  CFW   Remove _mbascii, add _mbcodepage and _mblcid.
*       04-21-93  CFW   _mbcodepage and _mblcid shouldn't be _CRTIMP.
*       04-21-94  GJF   Made declarations of __mbcodepage and __mblcid
*                       conditional on ndef DLL_FOR_WIN32S. Added conditional
*                       include of win32s.h. Also, made safe for multiple or
*                       nested includes.
*       05-12-94  CFW   Add full-width-latin upper/lower info.
*       05-16-94  CFW   Add _mbbtolower/upper.
*       05-19-94  CFW   Mac-enable, remove _KANJI/_MBCS_OS check.
*       02-14-95  CFW   Clean up Mac merge.
*       03-29-95  CFW   Add error message to internal headers.
*       12-14-95  JWM   Add "#pragma once".
*       03-17-97  RDK   Change _mbbisXXXXX and _mbbtoXXXX macros.
*       03-26-97  GJF   Cleaned out obsolete support for Win32s.
*       09-08-97  GJF   Added __ismbcodepage, and the _ISMBCP and _ISNOTMBCP
*                       macros.
*       09-26-97  BWT   Fix POSIX
*       04-17-98  GJF   Added support for per-thread mbc information.
*       06-08-00  PML   Remove threadmbcinfo.{pprev,pnext}.  Rename
*                       THREADMBCINFO to _THREADMBCINFO.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_MBDATA
#define _INC_MBDATA

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  __cplusplus
extern "C" {
#endif

#if     defined(_WIN32) && !defined (_POSIX_)

#define NUM_ULINFO 6 /* multibyte full-width-latin upper/lower info */

#else   /* _WIN32 && !_POSIX */

#define NUM_ULINFO 12 /* multibyte full-width-latin upper/lower info */

#endif  /* _WIN32 && !_POSIX */

#ifdef  _MT
#ifndef _THREADMBCINFO
typedef struct threadmbcinfostruct {
        int refcount;
        int mbcodepage;
        int ismbcodepage;
        int mblcid;
        unsigned short mbulinfo[6];
        char mbctype[257];
        char mbcasemap[256];
} threadmbcinfo;
typedef threadmbcinfo * pthreadmbcinfo;
#define _THREADMBCINFO
#endif
#endif

/* global variable to indicate current code page */
extern int __mbcodepage;

/* global flag indicating if the current code page is a multibyte code page */
extern int __ismbcodepage;

#if     defined(_WIN32) && !defined (_POSIX_)
/* global variable to indicate current LCID */
extern int __mblcid;
#endif  /* _WIN32 && !_POSIX */

/* global variable to indicate current full-width-latin upper/lower info */
extern unsigned short __mbulinfo[NUM_ULINFO];

#ifdef  _MT
/* global variable pointing to the current mbc information structure */
extern pthreadmbcinfo __ptmbcinfo;
/* function to update mbc info used by the current thread */
pthreadmbcinfo __cdecl __updatetmbcinfo(void);
#endif

/*
 * MBCS - Multi-Byte Character Set
 */

/*
 * general use macros for model dependent/independent versions.
 */

#define _ISMBCP     (__ismbcodepage != 0)
#define _ISNOTMBCP  (__ismbcodepage == 0)

#ifdef  _MT
#define _ISMBCP_MT(p)       (p->ismbcodepage != 0)
#define _ISNOTMBCP_MT(p)    (p->ismbcodepage == 0)
#endif

#define _ismbbtruelead(_lb,_ch) (!(_lb) && _ismbblead((_ch)))

/* internal use macros since tolower/toupper are locale-dependent */
#define _mbbisupper(_c) ((_mbctype[(_c) + 1] & _SBUP) == _SBUP)
#define _mbbislower(_c) ((_mbctype[(_c) + 1] & _SBLOW) == _SBLOW)

#define _mbbtolower(_c) (_mbbisupper(_c) ? _mbcasemap[_c] : _c)
#define _mbbtoupper(_c) (_mbbislower(_c) ? _mbcasemap[_c] : _c)

#ifdef  _MT
#define __ismbbtruelead_mt(p,_lb,_ch)   (!(_lb) && __ismbblead_mt(p, (_ch)))
#define __mbbisupper_mt(p, _c)      ((p->mbctype[(_c) + 1] & _SBUP) == _SBUP)
#define __mbbislower_mt(p, _c)      ((p->mbctype[(_c) + 1] & _SBLOW) == _SBLOW)
#define __mbbtolower_mt(p, _c)      (__mbbisupper_mt(p, _c) ? p->mbcasemap[_c] : _c)
#define __mbbtoupper_mt(p, _c)      (__mbbislower_mt(p, _c) ? p->mbcasemap[_c] : _c)
#endif

/* define full-width-latin upper/lower ranges */

#define _MBUPPERLOW1    __mbulinfo[0]
#define _MBUPPERHIGH1   __mbulinfo[1]
#define _MBCASEDIFF1    __mbulinfo[2]

#define _MBUPPERLOW2    __mbulinfo[3]
#define _MBUPPERHIGH2   __mbulinfo[4]
#define _MBCASEDIFF2    __mbulinfo[5]

#ifdef  _MT
#define _MBUPPERLOW1_MT(p)  p->mbulinfo[0]
#define _MBUPPERHIGH1_MT(p) p->mbulinfo[1]
#define _MBCASEDIFF1_MT(p)  p->mbulinfo[2]

#define _MBUPPERLOW2_MT(p)  p->mbulinfo[3]
#define _MBUPPERHIGH2_MT(p) p->mbulinfo[4]
#define _MBCASEDIFF2_MT(p)  p->mbulinfo[5]
#endif

#if     !defined(_WIN32) || defined(_POSIX_)

#define _MBLOWERLOW1    __mbulinfo[6]
#define _MBLOWERHIGH1   __mbulinfo[7]

#define _MBLOWERLOW2    __mbulinfo[8]
#define _MBLOWERHIGH2   __mbulinfo[9]

#define _MBDIGITLOW     __mbulinfo[10]
#define _MBDIGITHIGH    __mbulinfo[11]

#endif  /* !_WIN32 || _POSIX */

/* Kanji-specific ranges */
#define _MBHIRALOW      0x829f  /* hiragana */
#define _MBHIRAHIGH     0x82f1

#define _MBKATALOW      0x8340  /* katakana */
#define _MBKATAHIGH     0x8396
#define _MBKATAEXCEPT   0x837f  /* exception */

#define _MBKIGOULOW     0x8141  /* kanji punctuation */
#define _MBKIGOUHIGH    0x81ac
#define _MBKIGOUEXCEPT  0x817f  /* exception */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_MBDATA */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\mbctype.h ===
/***
*mbctype.h - MBCS character conversion macros
*
*       Copyright (c) 1985-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines macros for MBCS character classification/conversion.
*
*       [Public]
*
*Revision History:
*       11-19-92  KRS   Ported from 16-bit sources.
*       02-23-93  SKS   Update copyright to 1993
*       07-09-93  KRS   Fix problems with _isxxxlead/trail macros, etc.
*       08-12-93  CFW   Change _mbctype type, fix ifstrip macro name.
*       09-29-93  CFW   Add _ismbbkprint, modify _ismbbkana.
*       10-08-93  GJF   Support NT SDK and Cuda.
*       10-13-93  GJF   Deleted obsolete COMBOINC check.
*       10-19-93  CFW   Remove _MBCS test.
*       10-27-93  CFW   _CRTIMP for __mbcodepage.
*       01-04-94  CFW   Add _setmbcp and _getmbcp.
*       04-14-94  CFW   Remove _mbcodepage and second _setmbcp parameter.
*       04-18-94  CFW   Use _ALPHA instead of _LOWER|_UPPER.
*       04-21-94  CFW   Remove _mbcodepage ref.
*       04-21-94  GJF   Made declaration of _mbctype conditional on _DLL
*                       (for compatibility with the Win32s version of
*                       msvcrt*.dll). Made safe for repeated inclusions.
*                       Also, conditionally included win32s.h.
*       05-03-94  GJF   Made declaration of _mbctype for _DLL conditional on
*                       _M_IX86 also.
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       03-22-95  CFW   Add _MB_CP_LOCALE.
*       12-14-95  JWM   Add "#pragma once".
*       03-17-97  RDK   Add external _mbcasemap.
*       03-26-97  GJF   Cleaned out obsolete support for Win32s, _NTSDK and
*                       _CRTAPI*.
*       08-13-97  GJF   Strip __p_* prototypes from release version.
*       09-30-97  JWM   Restored not-so-obsolete _CRTAPI1 support.
*       10-07-97  RDL   Added IA64.
*       04-24-98  GJF   Added support for per-thread mbc information.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*       06-08-00  PML   Remove threadmbcinfo.{pprev,pnext}.  Rename
*                       THREADMBCINFO to _THREADMBCINFO.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_MBCTYPE
#define _INC_MBCTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

/* include the standard ctype.h header file */

#include <ctype.h>

#ifdef  __cplusplus
extern "C" {
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     (!defined(_MSC_VER) && !defined(__cdecl))
#define __cdecl
#endif


/*
 * MBCS - Multi-Byte Character Set
 */

/*
 * This declaration allows the user access the _mbctype[] look-up array.
 */
#ifndef _INTERNAL_IFSTRIP_
#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP unsigned char * __cdecl __p__mbctype(void);
_CRTIMP unsigned char * __cdecl __p__mbcasemap(void);
#endif
#endif  /* _INTERNAL_IFSTRIP_ */
_CRTIMP extern unsigned char _mbctype[];
_CRTIMP extern unsigned char _mbcasemap[];

#ifndef _INTERNAL_IFSTRIP_
#ifdef  _MT
#ifndef _THREADMBCINFO
typedef struct threadmbcinfostruct {
        int refcount;
        int mbcodepage;
        int ismbcodepage;
        int mblcid;
        unsigned short mbulinfo[6];
        char mbctype[257];
        char mbcasemap[256];
} threadmbcinfo;
typedef threadmbcinfo * pthreadmbcinfo;
#define _THREADMBCINFO
#endif
extern pthreadmbcinfo __ptmbcinfo;
pthreadmbcinfo __cdecl __updatetmbcinfo(void);
#endif
#endif  /* _INTERNAL_IFSTRIP_ */

/* bit masks for MBCS character types */

#define _MS     0x01    /* MBCS single-byte symbol */
#define _MP     0x02    /* MBCS punct */
#define _M1     0x04    /* MBCS 1st (lead) byte */
#define _M2     0x08    /* MBCS 2nd byte*/

#define _SBUP   0x10    /* SBCS upper char */
#define _SBLOW  0x20    /* SBCS lower char */

/* byte types  */

#define _MBC_SINGLE     0       /* valid single byte char */
#define _MBC_LEAD       1       /* lead byte */
#define _MBC_TRAIL      2       /* trailing byte */
#define _MBC_ILLEGAL    (-1)    /* illegal byte */

#define _KANJI_CP   932

/* _setmbcp parameter defines */
#define _MB_CP_SBCS     0
#define _MB_CP_OEM      -2
#define _MB_CP_ANSI     -3
#define _MB_CP_LOCALE   -4


#ifndef _MBCTYPE_DEFINED

/* MB control routines */

_CRTIMP int __cdecl _setmbcp(int);
_CRTIMP int __cdecl _getmbcp(void);


/* MBCS character classification function prototypes */


/* byte routines */
_CRTIMP int __cdecl _ismbbkalnum( unsigned int );
_CRTIMP int __cdecl _ismbbkana( unsigned int );
_CRTIMP int __cdecl _ismbbkpunct( unsigned int );
_CRTIMP int __cdecl _ismbbkprint( unsigned int );
_CRTIMP int __cdecl _ismbbalpha( unsigned int );
_CRTIMP int __cdecl _ismbbpunct( unsigned int );
_CRTIMP int __cdecl _ismbbalnum( unsigned int );
_CRTIMP int __cdecl _ismbbprint( unsigned int );
_CRTIMP int __cdecl _ismbbgraph( unsigned int );

#ifndef _MBLEADTRAIL_DEFINED
_CRTIMP int __cdecl _ismbblead( unsigned int );
_CRTIMP int __cdecl _ismbbtrail( unsigned int );
_CRTIMP int __cdecl _ismbslead( const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _ismbstrail( const unsigned char *, const unsigned char *);
#ifndef _INTERNAL_IFSTRIP_
#ifdef  _MT
_CRTIMP int __cdecl __ismbslead_mt(pthreadmbcinfo, const unsigned char *, 
                                   const unsigned char *);
#endif
#endif  /* _INTERNAL_IFSTRIP_ */
#define _MBLEADTRAIL_DEFINED
#endif

#define _MBCTYPE_DEFINED
#endif

/*
 * char byte classification macros
 */

#define _ismbbkalnum(_c)    ((_mbctype+1)[(unsigned char)(_c)] & _MS)
#define _ismbbkprint(_c)    ((_mbctype+1)[(unsigned char)(_c)] & (_MS|_MP))
#define _ismbbkpunct(_c)    ((_mbctype+1)[(unsigned char)(_c)] & _MP)

#define _ismbbalnum(_c) (((_ctype+1)[(unsigned char)(_c)] & (_ALPHA|_DIGIT))||_ismbbkalnum(_c))
#define _ismbbalpha(_c) (((_ctype+1)[(unsigned char)(_c)] & (_ALPHA))||_ismbbkalnum(_c))
#define _ismbbgraph(_c) (((_ctype+1)[(unsigned char)(_c)] & (_PUNCT|_ALPHA|_DIGIT))||_ismbbkprint(_c))
#define _ismbbprint(_c) (((_ctype+1)[(unsigned char)(_c)] & (_BLANK|_PUNCT|_ALPHA|_DIGIT))||_ismbbkprint(_c))
#define _ismbbpunct(_c) (((_ctype+1)[(unsigned char)(_c)] & _PUNCT)||_ismbbkpunct(_c))

#define _ismbblead(_c)  ((_mbctype+1)[(unsigned char)(_c)] & _M1)
#define _ismbbtrail(_c) ((_mbctype+1)[(unsigned char)(_c)] & _M2)

#define _ismbbkana(_c)  ((_mbctype+1)[(unsigned char)(_c)] & (_MS|_MP))

#ifndef _INTERNAL_IFSTRIP_
#ifdef  _MT
#define __ismbbalnum_mt(p, _c)  (((_ctype+1)[(unsigned char)(_c)] & \
                                (_ALPHA|_DIGIT)) || \
                                ((p->mbctype+1)[(unsigned char)(_c)] & _MS))
#define __ismbbalpha_mt(p, _c)  (((_ctype+1)[(unsigned char)(_c)] & \
                                (_ALPHA)) || \
                                ((p->mbctype+1)[(unsigned char)(_c)] & _MS))
#define __ismbbgraph_mt(p, _c)  (((_ctype+1)[(unsigned char)(_c)] & \
                                (_PUNCT|_ALPHA|_DIGIT)) || \
                                ((p->mbctype+1)[(unsigned char)(_c)] & (_MS|_MP)))
#define __ismbbprint_mt(p, _c)  (((_ctype + 1)[(unsigned char)(_c)] & \
                                (_BLANK|_PUNCT|_ALPHA|_DIGIT)) || \
                                ((p->mbctype + 1)[(unsigned char)(_c)] & (_MS|_MP)))
#define __ismbbpunct_mt(p, _c)  (((_ctype+1)[(unsigned char)(_c)] & _PUNCT) || \
                                ((p->mbctype+1)[(unsigned char)(_c)] & _MP))
#define __ismbblead_mt(p, _c)   ((p->mbctype + 1)[(unsigned char)(_c)] & _M1)
#define __ismbbtrail_mt(p, _c)  ((p->mbctype + 1)[(unsigned char)(_c)] & _M2)
#endif
#endif  /* _INTERNAL_IFSTRIP_ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_MBCTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\malloc.h ===
/***
*malloc.h - declarations and definitions for memory allocation functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the function declarations for memory allocation functions;
*       also defines manifest constants and types used by the heap routines.
*       [System V]
*
*       [Public]
*
*Revision History:
*       01-08-87  JMB   Standardized header, added heap consistency routines
*       02-26-87  BCM   added the manifest constant _HEAPBADPTR
*       04-13-87  JCR   Added size_t and "void *" to declarations
*       04-24-87  JCR   Added 'defined' statements around _heapinfo
*       05-15-87  SKS   Cleaned up _CDECL and near/far ptr declarations
*                       corrected #ifdef usage, and added _amblksiz
*       12-11-87  JCR   Added "_loadds" functionality
*       12-18-87  JCR   Added _FAR_ to declarations
*       02-05-88  JCR   Added DLL _amblksiz support
*       02-10-88  JCR   Cleaned up white space
*       04-21-88  WAJ   Added _FAR_ to halloc/_fmalloc/_nmalloc
*       05-13-88  GJF   Added new heap functions
*       05-18-88  GJF   Removed #defines, added prototypes for _heapchk, _heapset
*                       and _heapwalk
*       05-25-88  GJF   Added _bheapseg
*       08-22-88  GJF   Modified to also work for the 386 (small model only,
*                       no far or based heap support)
*       12-07-88  JCR   DLL refers to _amlbksiz directly now
*       01-10-89  JCR   Removed sbrk() prototype
*       04-28-89  SKS   Put parentheses around negative constants
*       05-03-89  JCR   Added _INTERNAL_IFSTRIP for relinc usage
*       08-01-89  GJF   Cleanup, now specific to OS/2 2.0 (i.e., 386 flat model)
*       10-27-89  JCR   Removed near (_n) and _freect/memavl/memmax prototypes
*       10-30-89  GJF   Fixed copyright
*       11-02-89  JCR   Changed "DLL" to "_DLL"
*       03-01-90  GJF   Added #ifndef _INC_MALLOC and #include <cruntime.h>
*                       stuff. Also, removed some (now) useless preprocessor
*                       directives.
*       03-21-90  GJF   Replaced _cdecl with _CALLTYPE1 in prototypes.
*       04-10-90  GJF   Made stackavail() _CALLTYPE1, _amblksiz _VARTYPE1.
*       01-17-91  GJF   ANSI naming.
*       08-20-91  JCR   C++ and ANSI naming
*       09-23-91  JCR   stackavail() not supported in WIN32
*       09-28-91  JCR   ANSI names: DOSX32=prototypes, WIN32=#defines for now
*       01-18-92  JCR   put _CRTHEAP_ ifdefs in; this stuff is only needed
*                       for a heap implemented in the runtime (not OS)
*       08-05-92  GJF   Function calling type and variable type macros.
*       08-22-92  SRW   Add alloca intrinsic pragma for MIPS
*       09-03-92  GJF   Merged two changes above.
*       09-23-92  SRW   Change winheap code to call NT directly always
*       01-21-93  GJF   Removed support for C6-386's _cdecl.
*       02-02-93  SRW   Removed bogus semicolon on #pragma
*       04-06-93  SKS   Replace _CRTAPI1/2 with __cdecl, _CRTVAR1 with nothing
*       04-07-93  SKS   Add _CRTIMP keyword for CRT DLL model
*                       Use link-time aliases for old names, not #define's
*       04-20-93  SKS   _alloca is a compiler intrinsic so alloca must be
*                       #define-d, not aliased as link time using OLDNAMES.LIB.
*       09-27-93  GJF   Merged NT SDK and Cuda versions. Also, changed the
*                       value of _HEAP_MAXREQ to be more useful (smaller
*                       value to guarantee page-rounding will not overflow).
*       10-13-93  GJF   Replaced _MIPS_ with _M_MRX000.
*       12-13-93  SKS   Add _heapused().
*       04-12-94  GJF   Special definition for _amblksiz for _DLL. Also,
*                       conditionally include win32s.h for DLL_FOR_WIN32S.
*       05-03-94  GJF   Made special definition of _amblksiz for _DLL also
*                       conditional on _M_IX86.
*       10-02-94  BWT   Add PPC support.
*       11-03-94  GJF   Ensure 8 byte alignment.
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       05-22-95  GJF   Updated _HEAP_MAXREQ.
*       05-24-95  CFW   Add heap hook.
*       12-14-95  JWM   Add "#pragma once".
*       03-07-96  GJF   Added prototypes for small-block heap's get/set 
*                       threshold functions.
*       02-04-97  GJF   Cleaned out obsolete support for Win32s, _CRTAPI* and
*                       _NTSDK.
*       08-13-97  GJF   Strip __p__amblksiz prototype from release version.
*       09-30-97  JWM   Restored not-so-obsolete _CRTAPI1 support.
*       10-07-97  RDL   Added IA64.
*       12-15-98  GJF   Changes for 64-bit size_t.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*       10-06-99  PML   Add _W64 modifier to types which are 32 bits in Win32,
*                       64 bits in Win64.
*       11-08-99  GB    Add _aligned_malloc(), _aligned_realloc, _aligned_free()
*                       _aligned_offset_malloc() and _aligned_offset_realloc().
*       12-10-99  GB    Add _resetstkoflw().
*       12-16-99  GB    Changed HEAP_MAXREQ to 0xFFFFFFFFFFFFFFE0 for Win64
*       01-07-00  GB    Fixed macro _mm_free.
*       12-08-00  PML   Make _resetstkoflw() available to POSIX build.
*       04-17-01  PML   _resetstkoflw() now returns an int success code.
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_MALLOC
#define _INC_MALLOC

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _INTERNAL_IFSTRIP_
#include <cruntime.h>
#endif  /* _INTERNAL_IFSTRIP_ */

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300 /*IFSTRIP=IGN*/
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


/* Maximum heap request the heap manager will attempt */

#ifdef  _WIN64
#define _HEAP_MAXREQ    0xFFFFFFFFFFFFFFE0
#else
#define _HEAP_MAXREQ    0xFFFFFFE0
#endif

/* Constants for _heapchk/_heapset/_heapwalk routines */

#define _HEAPEMPTY      (-1)
#define _HEAPOK         (-2)
#define _HEAPBADBEGIN   (-3)
#define _HEAPBADNODE    (-4)
#define _HEAPEND        (-5)
#define _HEAPBADPTR     (-6)
#define _FREEENTRY      0
#define _USEDENTRY      1

#ifndef _HEAPINFO_DEFINED
typedef struct _heapinfo {
        int * _pentry;
        size_t _size;
        int _useflag;
        } _HEAPINFO;
#define _HEAPINFO_DEFINED
#endif

/* External variable declarations */
#ifndef _INTERNAL_IFSTRIP_
#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP unsigned int * __cdecl __p__amblksiz(void);
#endif
#endif  /* _INTERNAL_IFSTRIP_ */

extern unsigned int _amblksiz;

#define _mm_free(a)      _aligned_free(a)
#define _mm_malloc(a, b)    _aligned_malloc(a, b)

/* Function prototypes */

_CRTIMP void *  __cdecl calloc(size_t, size_t);
_CRTIMP void    __cdecl free(void *);
_CRTIMP void *  __cdecl malloc(size_t);
_CRTIMP void *  __cdecl realloc(void *, size_t);
_CRTIMP void    __cdecl _aligned_free(void *);
_CRTIMP void *  __cdecl _aligned_malloc(size_t, size_t);
_CRTIMP void *  __cdecl _aligned_offset_malloc(size_t, size_t, size_t);
_CRTIMP void *  __cdecl _aligned_realloc(void *, size_t, size_t);
_CRTIMP void *  __cdecl _aligned_offset_realloc(void *, size_t, size_t, size_t);
#ifdef _XBOX
#define _resetstkoflw() (1)
#else
_CRTIMP int     __cdecl _resetstkoflw (void);
#endif // XBOX

#ifndef _POSIX_

void *          __cdecl _alloca(size_t);
_CRTIMP void *  __cdecl _expand(void *, size_t);
_CRTIMP size_t  __cdecl _get_sbh_threshold(void);
_CRTIMP int     __cdecl _set_sbh_threshold(size_t);
_CRTIMP int     __cdecl _heapadd(void *, size_t);
_CRTIMP int     __cdecl _heapchk(void);
_CRTIMP int     __cdecl _heapmin(void);
_CRTIMP int     __cdecl _heapset(unsigned int);
_CRTIMP int     __cdecl _heapwalk(_HEAPINFO *);
_CRTIMP size_t  __cdecl _heapused(size_t *, size_t *);
_CRTIMP size_t  __cdecl _msize(void *);

#if     !__STDC__
/* Non-ANSI names for compatibility */
#define alloca  _alloca
#endif  /* __STDC__*/

#if     defined(_M_MRX000) || defined(_M_PPC) || defined(_M_ALPHA)
#pragma intrinsic(_alloca)
#endif

#endif  /* _POSIX_ */

#ifdef  HEAPHOOK
#ifndef _HEAPHOOK_DEFINED
/* hook function type */
typedef int (__cdecl * _HEAPHOOK)(int, size_t, void *, void **);
#define _HEAPHOOK_DEFINED
#endif  /* _HEAPHOOK_DEFINED */

/* set hook function */
_CRTIMP _HEAPHOOK __cdecl _setheaphook(_HEAPHOOK);

/* hook function must handle these types */
#define _HEAP_MALLOC    1
#define _HEAP_CALLOC    2
#define _HEAP_FREE      3
#define _HEAP_REALLOC   4
#define _HEAP_MSIZE     5
#define _HEAP_EXPAND    6
#endif  /* HEAPHOOK */


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MALLOC */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\h\math.h ===
/***
*math.h - definitions and declarations for math library
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains constant definitions and external subroutine
*       declarations for the math subroutine library.
*       [ANSI/System V]
*
*       [Public]
*
*Revision History:
*       10/20/87  JCR   Removed "MSC40_ONLY" entries
*       12-11-87  JCR   Added "_loadds" functionality
*       12-18-87  JCR   Added _FAR_ to declarations
*       02-10-88  JCR   Cleaned up white space
*       02-10-88  WAJ   Changed HUGE and HUGE_VAL definitions for DLL libraries
*       05-32-88  PHG   Added _CDECL and _NEAR for declaration of HUGE
*       08-22-88  GJF   Modified to also work with the 386 (small model only)
*       05-03-89  JCR   Added _INTERNAL_IFSTRIP for relinc usage
*       08-02-89  GJF   Cleanup, now specific to OS/2 2.0 (i.e., 386 flat model)
*       10-30-89  GJF   Fixed copyright
*       11-02-89  JCR   Changed "DLL" to "_DLL"
*       11-20-89  JCR   Routines are now _cdecl in both single and multi-thread
*       12-14-89  WAJ   Removed pascal from mthread version.
*       03-01-90  GJF   Added #ifndef _INC_MATH and #include <cruntime.h>
*                       stuff. Also, removed some (now) useless preprocessor
*                       directives.
*       03-29-90  GJF   Replaced _cdecl with _VARTYPE1, _CALLTYPE1 or
*                       _CALLTYPE2, as appropriate.
*       07-30-90  SBM   Removed special _DLL definitions of HUGE and HUGE_VAL
*       08-17-90  WAJ   Floating point routines now use _stdcall.
*       08-08-91  GJF   Added long double stuff. ANSI naming.
*       08-20-91  JCR   C++ and ANSI naming
*       09-28-91  JCR   ANSI names: DOSX32=prototypes, WIN32=#defines for now
*       10-03-91  GDP   Added #pragma function(...)
*                       No floating point intrinsics for WIN32/NT86
*       10-06-91  SRW   Removed long double stuff.
*       01-24-92  GJF   Fixed [_]HUGE for crtdll.dll.
*       01-30-92  GJF   Removed prototypes and macros for the ieee-to/from-
*                       msbin functions (they don't exist).
*       08-05-92  GJF   Function calling type and variable type macros.
*       12-18-92  GDP   Removed #pragma function(...)
*       01-21-93  GJF   Removed support for C6-386's _cdecl.
*       04-06-93  SKS   Replace _CRTAPI1/2 with __cdecl, _CRTVAR1 with nothing
*       04-07-93  SKS   Add _CRTIMP keyword for CRT DLL model
*                       Use link-time aliases for old names, not #define's
*       10-07-93  GJF   Merged NT and Cuda versions. Other fixes: Jonm's
*                       #define for _hypotl was wrong, added #define for
*                       _cabsl, added matherr to the 'oldnames' prototypes.
*       01-13-94  RDL   Added #ifndef _LANGUAGE_ASSEMBLY for asm includes.
*       01-24-94  GJF   Merged in 01-13 change above (from crt32 tree on
*                       \\orville\razzle).
*       08-05-94  GJF   Added support for user-supplied _matherr routine
*                       to msvcrt20.dll (Win32 and Win32s versions).
*       11-03-94  GJF   Ensure 8 byte alignment.
*       12-10-94  BWT   Add _CRTIMP to MIPS float math functions.
*       12-30-94  JCF   Merged with mac header.
*       01-05-95  JCF   Don't do the prototypes under _MAC_.
*       01-09-95  JCF   Don't do the prototypes only under _M_M68K.
*       01-11-95  RDL   Put #ifndef __assembler for asm includes back.
*       02-11-95  CFW   Add _CRTBLD to avoid users getting wrong headers.
*       02-14-95  CFW   Clean up Mac merge.
*       03-03-95  CFW   Remove bogus 'oldnames' 68k stuff.
*       03-10-95  SAH   add _CRTIMP to MIPS intrinsics
*       05-16-95  CFW   #define exception _exception removed - hoses class exception.
*       12-14-95  JWM   Add "#pragma once".
*       03-05-96  JWM   Added PlumHall modifications.
*       05-06-96  JWM   Inlines are now #ifndef _M_M68K.
*       05-15-96  JWM   Minor fix to remove a C4244 warning from the Pow_int template.
*       08-28-96  JWM   Added inline long __cdecl abs(long); also __cdecls to other inlines.
*       09-09-96  JWM   Inlines are now #ifndef _MSC_EXTENSIONS, i.e. -Za only.
*       09-17-96  RKP   Treat single precision routines on ALPHA like MIPS
*       10-06-96  JWM   _Pow_int template no longer #ifndef _MSC_EXTENSIONS.
*       01-24-96  RKP   Allow single precision routines to be used as intrinsics 
*       02-05-97  GJF   Deleted obsolete support for _CRTAPI* and _NTSDK. 
*                       Also, detab-ed.
*       06-23-97  GJF   Fixed typo introduced by DEC checkin.
*       09-30-97  JWM   Restored not-so-obsolete _CRTAPI1 support.
*       10-07-97  RDL   Added IA64.
*       11-19-97  JWM   Cleaned up _Pow_int to prevent C4146.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*       06-04-99  PML   modff and hypotf are intrinsics on IA64.
*       10-28-99  PML   Add #defines for useful constants
*       11-02-99  PML   Add extern "C++" around C++ definitions.
*       12-02-99  PML   add defined(_M_MRX000) check (vs7#65291)
*       02-07-01  GB    Place math constant defines under #ifdef (vs7#193177).
*       02-21-01  PML   Add _set_SSE2_enable().
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_MATH
#define _INC_MATH

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __assembler /* Protect from assembler */
#ifndef _INTERNAL_IFSTRIP_
#include <cruntime.h>
#endif  /* _INTERNAL_IFSTRIP_ */

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Definition of _exception struct - this struct is passed to the matherr
 * routine when a floating point exception is detected
 */

#ifndef _EXCEPTION_DEFINED
struct _exception {
        int type;       /* exception type - see below */
        char *name;     /* name of function where error occured */
        double arg1;    /* first argument to function */
        double arg2;    /* second argument (if any) to function */
        double retval;  /* value to be returned by function */
        } ;

#define _EXCEPTION_DEFINED
#endif


/* Definition of a _complex struct to be used by those who use cabs and
 * want type checking on their argument
 */

#ifndef _COMPLEX_DEFINED
struct _complex {
        double x,y; /* real and imaginary parts */
        } ;

#if     !__STDC__ && !defined (__cplusplus) /*IFSTRIP=IGN*/
/* Non-ANSI name for compatibility */
#define complex _complex
#endif

#define _COMPLEX_DEFINED
#endif
#endif  /* __assembler */


/* Constant definitions for the exception type passed in the _exception struct
 */

#define _DOMAIN     1   /* argument domain error */
#define _SING       2   /* argument singularity */
#define _OVERFLOW   3   /* overflow range error */
#define _UNDERFLOW  4   /* underflow range error */
#define _TLOSS      5   /* total loss of precision */
#define _PLOSS      6   /* partial