       


} 

#undef USE_SPEEDUP
I8_WMV negtab[100] = {-1,-2,-3,-4,-5,-6,-6,-5,-4,-3,-2,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
I8_WMV g_deblockTab[100] = {0,1,2,3,4,5,6,6,5,4,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
Void_WMV FilterVerticalEdge(U8_WMV* ppxlcCenter, I32_WMV iPixelDistance, I32_WMV iPixelIncrement, I32_WMV iEdgeLength, I32_WMV iStepSize)
{

    static const Int64 x80 = 0x8080808080808080;
    static const Int64 thr1 = (THR1 | (THR1 << 8) | (THR1 << 16) | (THR1 << 24) | ((Int64)THR1 << 32) | ((Int64)THR1 << 40) | ((Int64)THR1 << 48) | ((Int64)THR1 << 56)) ^ x80;
    static const Int64 thr2 = (THR2-1) | ((THR2-1) << 8) | ((THR2-1) << 16) | ((THR2-1) << 24) | ((Int64)(THR2-1) << 32) | ((Int64)(THR2-1) << 40) | ((Int64)(THR2-1) << 48) | ((Int64)(THR2-1) << 56);
    static const Int64 x01 = 0x0101010101010101;
  
    static const Int64 xFFFFFFFF00000000 = 0xFFFFFFFF00000000;
    static const Int64 x000000000000FFFF = 0x000000000000FFFF;
    static const Int64 xFFFF000000000000 = 0xFFFF000000000000;

    static const Int64 x0008 = 0x0008000800080008;
    static const Int64 s1 = 0xFFFB0002FFFB0002;
    static const Int64 s2 = 0xFFFE0005FFFE0005;
    static const Int64 s3 = 0xFFFE0005FFFB0002;
    static const Int64 x00000004 = 0x0000000400000004;       
    static const Int64 x00000005 = 0x0000000500000005;

    //For Long Filter
    static const Int64 m2226 = 0x0006000200020002;
    static const Int64 m2240 = 0x0000000400020002;
    static const Int64 m1221 = 0x0001000200020001;
    static const Int64 m6222 = 0x0002000200020006;
    static const Int64 m0422 = 0x0002000200040000;
    
    

       _asm {
            mov         esi,ppxlcCenter
            sub         esi,5
            mov         edi,iEdgeLength
MainLoop:
            
            //Determine Which Filter To Use Long or short    

#ifdef USE_SPEEDUP
            movzx       ebx,byte Ptr [esi+4]
            movzx       ecx,byte Ptr [esi+5]
            cmp         ebx,ecx
            jz          EndOfLoop
#endif
            movq        mm0,[esi]
            movq        mm1,[esi+1]

            movq        mm2,mm0
            psubusb     mm2,mm1
            psubusb     mm1,mm0
            por         mm2,mm1
            
            movq        mm3,x80
            movq        mm4,thr1
            pxor        mm2,mm3

            pcmpgtb     mm2,mm4
            pandn       mm2,x01
            movq        mm1,mm2
            psrlq       mm2,32
            paddb       mm2,mm1
            movq        mm1,mm2
            psrld       mm2,16
            paddb       mm2,mm1
            movq        mm1,mm2
            psrlw       mm2,8
            paddb       mm2,mm1

#ifndef USE_SPEEDUP
            movzx       eax,byte Ptr [esi+8]
            movzx       ebx,byte Ptr [esi+9]
            sub         eax,ebx
            cdq
            xor         eax,edx
            sub         eax,edx
            mov         ebx,eax
            sub         ebx,(THR1+1)
            sar         ebx,31
#endif

            movd        eax,mm2
            movzx       eax,al
#ifndef USE_SPEEDUP
            sub         eax,ebx
#endif
            cmp         eax,THR2
            jl          ShortFilter
  
            //Determine MIN & MAX values to see if filtering should be used
            
#ifndef USE_SPEEDUP
            movq        mm0,[esi+1]
            movq        mm4,x80
            pxor        mm0,mm4

            movq        mm1,mm0
            punpckldq   mm0,mm0
            punpckhdq   mm1,mm1

            movq        mm3,xFFFFFFFF00000000

            movq        mm2,mm0
            pcmpgtb     mm2,mm1
            pxor        mm2,mm3
            pand        mm0,mm2
            pandn       mm2,mm1
            por         mm0,mm2

            movq        mm1,mm0
            psrld       mm1,16
            movq        mm2,mm0
            pcmpgtb     mm2,mm1
            pxor        mm2,mm3
            pand        mm0,mm2
            pandn       mm2,mm1
            por         mm0,mm2

            movq        mm1,mm0
            psrlw       mm1,8
            movq        mm2,mm0
            pcmpgtb     mm2,mm1
            pxor        mm2,mm3
            pand        mm0,mm2
            pandn       mm2,mm1
            por         mm0,mm2
            pxor        mm0,mm4
            
            movq        mm2,mm0
            psrlq       mm2,32
            psubb       mm0,mm2
            
            movd        eax,mm0
            movzx       eax,al //max-min
            mov         edx,iStepSize
            shl         edx,1

            cmp         eax,edx
            jge         EndOfLoop
#else
            movzx       eax,byte Ptr [esi]      //Can probobly skip these lines if the speedup is necessary
            movzx       edx,byte Ptr [esi+9]
            sub         eax,edx
            cdq
            xor         eax,edx
            sub         eax,edx
            mov         edx,iStepSize
            shl         edx,1
            cmp         eax,edx
            jg          EndOfLoop
#endif

  
            pxor        mm7,mm7
  
            movq        mm5,[esi+1]
            movq        mm3,mm5
            punpcklbw   mm3,mm7
            movq        mm4,mm3
            paddw       mm3,mm3

            movq        mm2,mm5
            psrlq       mm2,8
            paddw       mm3,mm4
            movq        mm6,mm5
            punpcklbw   mm2,mm7
            paddw       mm4,mm2
            paddw       mm3,mm2

            psrlq       mm6,16
            movq        mm2,mm6
            punpcklbw   mm6,mm7
            paddw       mm6,mm6
                      
            psrlq       mm2,8
            paddw       mm4,mm6
            punpcklbw   mm2,mm7
            paddw       mm4,mm2
            paddw       mm3,mm4
            paddw       mm4,mm2

            movq        mm0,m6222
            punpckhbw   mm5,mm7
            paddw       mm3,mm5
            paddw       mm5,mm5                           
            paddw       mm4,mm5                           
            paddw       mm4,mm5

            movd        mm1,[esi]
            punpcklbw   mm1,mm7
            movq        mm2,mm1
#ifndef USE_SPEEDUP
            movzx       eax,byte Ptr [esi]
            movzx       edx,byte Ptr [esi+1]
            sub         eax,edx
            cdq
            xor         eax,edx
            sub         eax,edx
            mov         edx,iStepSize
            cmp         eax,edx
            jl          UseV0
            movq        mm5,x000000000000FFFF
            psrlq       mm2,16
            pand        mm2,mm5
            pandn       mm5,mm1
            por         mm2,mm5
            movq        mm1,mm2
UseV0:
#endif
            movq        mm5,m0422
            pmullw      mm1,mm0
            paddw       mm3,mm1
            
            movq        mm0,m1221
            psllq       mm2,16
            movq        mm1,mm2
            pmullw      mm2,mm5
            paddw       mm3,mm2

            movq        mm5,m2226
            psllq       mm1,16
            movq        mm2,mm1
            pmullw      mm1,mm0
            paddw       mm3,mm1

            psllq       mm2,16
            paddw       mm3,mm2

            movd        mm1,[esi+6]                
            punpcklbw   mm1,mm7
            movq        mm2,mm1
#ifndef USE_SPEEDUP
            movzx       eax,byte Ptr [esi+8]
            movzx       edx,byte Ptr [esi+9]
            sub         eax,edx
            cdq
            xor         eax,edx
            sub         eax,edx
            mov         edx,iStepSize
            cmp         eax,edx
            jl          UseV9
            movq        mm0,xFFFF000000000000
            psllq       mm2,16
            pand        mm2,mm0
            pandn       mm0,mm1
            por         mm2,mm0
            movq        mm1,mm2
            movq        mm0,m1221
UseV9:
#endif
            pmullw      mm1,mm5
            paddw       mm4,mm1

            movq        mm5,m2240
            psrlq       mm2,16
            movq        mm1,mm2
            pmullw      mm2,mm5
            paddw       mm4,mm2

            psrlq       mm1,16
            movq        mm2,mm1
            pmullw      mm1,mm0
            paddw       mm4,mm1

            movq        mm0,x0008
            psrlq       mm2,16
            paddw       mm4,mm2

            paddw       mm3,mm0
            psrlw       mm3,4
            paddw       mm4,mm0
            psrlw       mm4,4
            packuswb    mm3,mm4
            movq        [esi+1],mm3

            jmp         EndOfLoop

ShortFilter:
#ifdef USE_SPEEDUP
            movd        mm0,ecx
            movzx       eax,[esi+3]
            movzx       edx,[esi+6]
            sub         ecx,ebx
            shl         ecx,3
            sub         eax,edx
            mov         edx,eax
            shl         eax,1
            add         eax,edx
            add         eax,ecx
            sar         eax,4
            movd        ecx,mm0
            movzx       eax,byte Ptr [g_deblockTab+eax]
            add         ebx,eax
            sub         ecx,eax
            test        ebx,0xFF00
            jnz         Clip2
            mov         [esi+4],bl
Clip2Ret:   test        ecx,0xFF00
            jnz         Clip1
            mov         [esi+5],cl
Clip1Ret:
#else
            pxor        mm7,mm7
            movzx       ecx,byte Ptr [esi+4]
            mov         eax,ecx
            movzx       ebx,byte Ptr [esi+5]

            movq        mm0,[esi+1]
            movq        mm5,s1
            movq        mm6,s2
            movq        mm1,mm0
            punpcklbw   mm1,mm7   
            pmaddwd     mm1,mm5
            movq        mm2,mm0
            psrlq       mm2,16
            punpcklbw   mm2,mm7   
            movq        mm3,mm2
            pmaddwd     mm2,mm6
            paddd       mm1,mm2
            paddd       mm1,x00000004
            psrad       mm1,3
            
            pxor        mm6,mm6
            pcmpgtb     mm6,mm1                    
            pxor        mm1,mm6
            psubd       mm1,mm6

            movq        mm4,mm1
            psrlq       mm1,32
            
            movd        edx,mm1
            cmp         edx,iStepSize
            jge         EndOfLoop

            sub         eax,ebx
            cdq
            xor         eax,edx
            sub         eax,edx

            shr         eax,1

            test        eax,eax
            jz          EndOfLoop

            movq        mm3,mm0
            punpckhbw   mm3,mm7
            pmaddwd     mm3,s3
            movq        mm2,mm3
            psrlq       mm2,32
            paddd       mm3,mm2
            paddd       mm3,x00000004
            psrad       mm3,3
            movq        mm2,mm1

            //From here on could be done 2 or 4 at a time
            //mm2=a30
            //mm3=a32
            //mm4=a31

            pxor        mm5,mm5
            pcmpgtd     mm5,mm3
            pxor        mm3,mm5
            psubd       mm3,mm5

            movq        mm5,mm2
            pcmpgtd     mm5,mm3
            pand        mm3,mm5
            pandn       mm5,mm2
            por         mm3,mm5

            movq        mm5,mm4
            pcmpgtd     mm5,mm3
            pand        mm3,mm5
            pandn       mm5,mm4
            por         mm3,mm5

            psubd       mm3,mm1

            pxor        mm4,mm4
            pcmpgtd     mm4,mm3
            pxor        mm3,mm4
            psubd       mm3,mm4

            pmaddwd     mm3,x00000005
            psrad       mm3,3        

            pxor        mm3,mm4
            psubd       mm3,mm4

            psrlq       mm6,32
            pxor        mm3,mm6
            psubd       mm3,mm6

            movd        mm5,edx

            pxor        mm3,mm5
            psubd       mm3,mm5

            movd        mm0,eax
            movq        mm1,mm0
            pcmpgtd     mm1,mm3
            pand        mm3,mm1
            pandn       mm1,mm0
            por         mm3,mm1
            
            pxor        mm1,mm1
            pcmpgtd     mm1,mm3
            pandn       mm1,mm3

            pxor        mm1,mm5
            psubd       mm1,mm5

            movd        eax,mm1

            sub         ecx,eax
            add         ebx,eax

            test        ecx,0x100
            jnz         Clip1
            mov         [esi+4],cl          
            
Clip1Ret:   test        ebx,0x100
            jnz         Clip2
            mov         [esi+5],bl
Clip2Ret:
#endif
EndOfLoop:                
             mov        eax,iPixelIncrement
             add        esi,eax
             
             dec        edi
             jnz        MainLoop

            }
return;
        _asm {
Clip1:      cmp         ecx,0
            jl          Clip1Down
            mov         [esi+4],0xFF
            jmp         Clip1Ret
Clip1Down:  mov         [esi+4],0
            jmp         Clip1Ret

Clip2:      cmp         ebx,0
            jl          Clip2Down
            mov         [esi+5],0xFF
            jmp         Clip2Ret
Clip2Down:  mov         [esi+5],0
            jmp         Clip2Ret
        }
}


Void_WMV FilterHalfVerticalEdge(U8_WMV* ppxlcCenter, I32_WMV iPixelDistance, I32_WMV iPixelIncrement, I32_WMV iEdgeLength, I32_WMV iStepSize)
{

    static const Int64 x80 = 0x8080808080808080;
    static const Int64 thr1 = (THR1 | (THR1 << 8) | (THR1 << 16) | (THR1 << 24) | ((Int64)THR1 << 32) | ((Int64)THR1 << 40) | ((Int64)THR1 << 48) | ((Int64)THR1 << 56)) ^ x80;
    static const Int64 thr2 = (THR2-1) | ((THR2-1) << 8) | ((THR2-1) << 16) | ((THR2-1) << 24) | ((Int64)(THR2-1) << 32) | ((Int64)(THR2-1) << 40) | ((Int64)(THR2-1) << 48) | ((Int64)(THR2-1) << 56);
    static const Int64 x01 = 0x0101010101010101;
  
    static const Int64 xFFFFFFFF00000000 = 0xFFFFFFFF00000000;
    static const Int64 x000000000000FFFF = 0x000000000000FFFF;
    static const Int64 xFFFF000000000000 = 0xFFFF000000000000;

    static const Int64 x0008 = 0x0008000800080008;
    static const Int64 s1 = 0xFFFB0002FFFB0002;
    static const Int64 s2 = 0xFFFE0005FFFE0005;
    static const Int64 s3 = 0xFFFE0005FFFB0002;
    static const Int64 x00000004 = 0x0000000400000004;       
    static const Int64 x00000005 = 0x0000000500000005;

    //For Long Filter
    static const Int64 m2226 = 0x0006000200020002;
    static const Int64 m2240 = 0x0000000400020002;
    static const Int64 m1221 = 0x0001000200020001;
    static const Int64 m6222 = 0x0002000200020006;
    static const Int64 m0422 = 0x0002000200040000;
    
    

       _asm {
            mov         esi,ppxlcCenter
            sub         esi,5
            mov         edi,iEdgeLength
MainLoop:
            
            //Determine Which Filter To Use Long or short    

#ifdef USE_SPEEDUP
            movzx       ebx,byte Ptr [esi+4]
            movzx       ecx,byte Ptr [esi+5]
            cmp         ebx,ecx
            jz          EndOfLoop
#endif
            movq        mm0,[esi]
            movq        mm1,[esi+1]

            movq        mm2,mm0
            psubusb     mm2,mm1
            psubusb     mm1,mm0
            por         mm2,mm1
            
            movq        mm3,x80
            movq        mm4,thr1
            pxor        mm2,mm3

            pcmpgtb     mm2,mm4
            pandn       mm2,x01
            movq        mm1,mm2
            psrlq       mm2,32
            paddb       mm2,mm1
            movq        mm1,mm2
            psrld       mm2,16
            paddb       mm2,mm1
            movq        mm1,mm2
            psrlw       mm2,8
            paddb       mm2,mm1

#ifndef USE_SPEEDUP
            movzx       eax,byte Ptr [esi+8]
            movzx       ebx,byte Ptr [esi+9]
            sub         eax,ebx
            cdq
            xor         eax,edx
            sub         eax,edx
            xor         ebx,ebx
            cmp         eax,THR1
            jg          DontAdd1
            mov         ebx,1
DontAdd1:
#endif

            movd        eax,mm2
            movzx       eax,al
#ifndef USE_SPEEDUP
            add         eax,ebx
#endif
            cmp         eax,THR2
            jl          ShortFilter
  
            //Determine MIN & MAX values to see if filtering should be used
            
#ifndef USE_SPEEDUP
            movq        mm0,[esi+1]
            movq        mm4,x80
            pxor        mm0,mm4

            movq        mm1,mm0
            punpckldq   mm0,mm0
            punpckhdq   mm1,mm1

            movq        mm3,xFFFFFFFF00000000

            movq        mm2,mm0
            pcmpgtb     mm2,mm1
            pxor        mm2,mm3
            pand        mm0,mm2
            pandn       mm2,mm1
            por         mm0,mm2

            movq        mm1,mm0
            psrld       mm1,16
            movq        mm2,mm0
            pcmpgtb     mm2,mm1
            pxor        mm2,mm3
            pand        mm0,mm2
            pandn       mm2,mm1
            por         mm0,mm2

            movq        mm1,mm0
            psrlw       mm1,8
            movq        mm2,mm0
            pcmpgtb     mm2,mm1
            pxor        mm2,mm3
            pand        mm0,mm2
            pandn       mm2,mm1
            por         mm0,mm2
            pxor        mm0,mm4
            
            movq        mm2,mm0
            psrlq       mm2,32
            psubb       mm0,mm2
            
            movd        eax,mm0
            movzx       eax,al //max-min
            mov         edx,iStepSize
            shl         edx,1

            cmp         eax,edx
            jge         EndOfLoop
#else
            movzx       eax,byte Ptr [esi]
            movzx       edx,byte Ptr [esi+9]
            sub         eax,edx
            cdq
            xor         eax,edx
            sub         eax,edx
            mov         edx,iStepSize
            shl         edx,1
            cmp         eax,edx
            jg          EndOfLoop
#endif            
  
            pxor        mm7,mm7
  
            movq        mm5,[esi+1]
            movq        mm3,mm5
            punpcklbw   mm3,mm7
            movq        mm4,mm3
            paddw       mm3,mm3

            movq        mm2,mm5
            psrlq       mm2,8
            paddw       mm3,mm4
            movq        mm6,mm5
            punpcklbw   mm2,mm7
            paddw       mm4,mm2
            paddw       mm3,mm2

            psrlq       mm6,16
            movq        mm2,mm6
            punpcklbw   mm6,mm7
            paddw       mm6,mm6
                      
            psrlq       mm2,8
            paddw       mm4,mm6
            punpcklbw   mm2,mm7
            paddw       mm4,mm2
            paddw       mm3,mm4
            paddw       mm4,mm2

            movq        mm0,m6222
            punpckhbw   mm5,mm7
            paddw       mm3,mm5
            paddw       mm5,mm5                           
            paddw       mm4,mm5                           
            paddw       mm4,mm5

            movd        mm1,[esi]
            punpcklbw   mm1,mm7
            movq        mm2,mm1
#ifndef USE_SPEEDUP
            movzx       eax,byte Ptr [esi]
            movzx       edx,byte Ptr [esi+1]
            sub         eax,edx
            cdq
            xor         eax,edx
            sub         eax,edx
            mov         edx,iStepSize
            cmp         eax,edx
            jl          UseV0
            movq        mm5,x000000000000FFFF
            psrlq       mm2,16
            pand        mm2,mm5
            pandn       mm5,mm1
            por         mm2,mm5
            movq        mm1,mm2
UseV0:
#endif
            movq        mm5,m0422
            pmullw      mm1,mm0
            paddw       mm3,mm1
            
            movq        mm0,m1221
            psllq       mm2,16
            movq        mm1,mm2
            pmullw      mm2,mm5
            paddw       mm3,mm2

            movq        mm5,m2226
            psllq       mm1,16
            movq        mm2,mm1
            pmullw      mm1,mm0
            paddw       mm3,mm1

            psllq       mm2,16
            paddw       mm3,mm2

            movd        mm1,[esi+6]                
            punpcklbw   mm1,mm7
            movq        mm2,mm1
#ifndef USE_SPEEDUP
            movzx       eax,byte Ptr [esi+8]
            movzx       edx,byte Ptr [esi+9]
            sub         eax,edx
            cdq
            xor         eax,edx
            sub         eax,edx
            mov         edx,iStepSize
            cmp         eax,edx
            jl          UseV9
            movq        mm0,xFFFF000000000000
            psllq       mm2,16
            pand        mm2,mm0
            pandn       mm0,mm1
            por         mm2,mm0
            movq        mm1,mm2
            movq        mm0,m1221
UseV9:
#endif
            pmullw      mm1,mm5
            paddw       mm4,mm1

            movq        mm5,m2240
            psrlq       mm2,16
            movq        mm1,mm2
            pmullw      mm2,mm5
            paddw       mm4,mm2

            psrlq       mm1,16
            movq        mm2,mm1
            pmullw      mm1,mm0
            paddw       mm4,mm1

            movq        mm0,x0008
            psrlq       mm2,16
            paddw       mm4,mm2

            paddw       mm3,mm0
            psrlw       mm3,4
            paddw       mm4,mm0
            psrlw       mm4,4
            packuswb    mm3,mm4
            movd        [esi+1],mm3

            jmp         EndOfLoop

ShortFilter:
#ifdef USE_SPEEDUP
            movd        mm0,ecx
            movzx       eax,[esi+3]
            movzx       edx,[esi+6]
            sub         ecx,ebx
            shl         ecx,3
            sub         eax,edx
            mov         edx,eax
            shl         eax,1
            add         eax,edx
            add         eax,ecx
            sar         eax,4
            movd        ecx,mm0
            movzx       eax,byte Ptr [g_deblockTab+eax]
            add         ebx,eax
            sub         ecx,eax
            test        ebx,0xFF00
            jnz         Clip2
            mov         [esi+4],bl
#else
            pxor        mm7,mm7
            movzx       ecx,byte Ptr [esi+4]
            mov         eax,ecx
            movzx       ebx,byte Ptr [esi+5]

            movq        mm0,[esi+1]
            movq        mm5,s1
            movq        mm6,s2
            movq        mm1,mm0
            punpcklbw   mm1,mm7   
            pmaddwd     mm1,mm5
            movq        mm2,mm0
            psrlq       mm2,16
            punpcklbw   mm2,mm7   
            movq        mm3,mm2
            pmaddwd     mm2,mm6
            paddd       mm1,mm2
            paddd       mm1,x00000004
            psrad       mm1,3
            
            pxor        mm6,mm6
            pcmpgtb     mm6,mm1                    
            pxor        mm1,mm6
            psubd       mm1,mm6

            movq        mm4,mm1
            psrlq       mm1,32
            
            movd        edx,mm1
            cmp         edx,iStepSize
            jge         EndOfLoop

            sub         eax,ebx
            cdq
            xor         eax,edx
            sub         eax,edx

            shr         eax,1

            test        eax,eax
            jz          EndOfLoop

            movq        mm3,mm0
            punpckhbw   mm3,mm7
            pmaddwd     mm3,s3
            movq        mm2,mm3
            psrlq       mm2,32
            paddd       mm3,mm2
            paddd       mm3,x00000004
            psrad       mm3,3
            

            movq        mm2,mm1

            //From here on could be done 2 or 4 at a time
            
            //mm2=a30
            //mm3=a32
            //mm4=a31

            pxor        mm5,mm5
            pcmpgtd     mm5,mm3
            pxor        mm3,mm5
            psubd       mm3,mm5

            movq        mm5,mm2
            pcmpgtd     mm5,mm3
            pand        mm3,mm5
            pandn       mm5,mm2
            por         mm3,mm5

            movq        mm5,mm4
            pcmpgtd     mm5,mm3
            pand        mm3,mm5
            pandn       mm5,mm4
            por         mm3,mm5

            psubd       mm3,mm1

            pxor        mm4,mm4
            pcmpgtd     mm4,mm3
            pxor        mm3,mm4
            psubd       mm3,mm4

            pmaddwd     mm3,x00000005
            psrad       mm3,3        

            pxor        mm3,mm4
            psubd       mm3,mm4

            psrlq       mm6,32
            pxor        mm3,mm6
            psubd       mm3,mm6

            movd        mm5,edx

            pxor        mm3,mm5
            psubd       mm3,mm5

            movd        mm0,eax
            movq        mm1,mm0
            pcmpgtd     mm1,mm3
            pand        mm3,mm1
            pandn       mm1,mm0
            por         mm3,mm1
            
            pxor        mm1,mm1
            pcmpgtd     mm1,mm3
            pandn       mm1,mm3

            pxor        mm1,mm5
            psubd       mm1,mm5

            movd        eax,mm1

            sub         ecx,eax
            add         ebx,eax

            test        ecx,0x100
            jnz         Clip1
            mov         [esi+4],cl          
            
Clip1Ret: 
#endif
EndOfLoop:                
             mov        eax,iPixelIncrement
             add        esi,eax
             
             dec        edi
             jnz        MainLoop

            }
return;
#ifdef USE_SPEEDUP
        _asm {
Clip2:      cmp         ebx,0
            jl          Clip2Down
            mov         [esi+5],0xFF
            jmp         EndOfLoop
Clip2Down:  mov         [esi+5],0
            jmp         EndOfLoop
        }
#else
        _asm {
Clip1:      cmp         ecx,0
            jl          Clip1Down
            mov         [esi+4],0xFF
            jmp         Clip1Ret
Clip1Down:  mov         [esi+4],0
            jmp         Clip1Ret

        }
#endif
}


#define USE_SPEEDUP
Void_WMV FilterVerticalEdge_FASTEST(U8_WMV* ppxlcCenter, I32_WMV iPixelDistance, I32_WMV iPixelIncrement, I32_WMV iEdgeLength, I32_WMV iStepSize)
{

    static const Int64 x80 = 0x8080808080808080;
    static const Int64 thr1 = (THR1 | (THR1 << 8) | (THR1 << 16) | (THR1 << 24) | ((Int64)THR1 << 32) | ((Int64)THR1 << 40) | ((Int64)THR1 << 48) | ((Int64)THR1 << 56)) ^ x80;
    static const Int64 thr2 = (THR2-1) | ((THR2-1) << 8) | ((THR2-1) << 16) | ((THR2-1) << 24) | ((Int64)(THR2-1) << 32) | ((Int64)(THR2-1) << 40) | ((Int64)(THR2-1) << 48) | ((Int64)(THR2-1) << 56);
    static const Int64 x01 = 0x0101010101010101;
  
    static const Int64 xFFFFFFFF00000000 = 0xFFFFFFFF00000000;
    static const Int64 x000000000000FFFF = 0x000000000000FFFF;
    static const Int64 xFFFF000000000000 = 0xFFFF000000000000;

    static const Int64 x0008 = 0x0008000800080008;
    static const Int64 s1 = 0xFFFB0002FFFB0002;
    static const Int64 s2 = 0xFFFE0005FFFE0005;
    static const Int64 s3 = 0xFFFE0005FFFB0002;
    static const Int64 x00000004 = 0x0000000400000004;       
    static const Int64 x00000005 = 0x0000000500000005;

    //For Long Filter
    static const Int64 m2226 = 0x0006000200020002;
    static const Int64 m2240 = 0x0000000400020002;
    static const Int64 m1221 = 0x0001000200020001;
    static const Int64 m6222 = 0x0002000200020006;
    static const Int64 m0422 = 0x0002000200040000;
    
    

       _asm {
            mov         esi,ppxlcCenter
            sub         esi,5
            mov         edi,iEdgeLength
MainLoop:
            
            //Determine Which Filter To Use Long or short    

#ifdef USE_SPEEDUP
            movzx       ebx,byte Ptr [esi+4]
            movzx       ecx,byte Ptr [esi+5]
            cmp         ebx,ecx
            jz          EndOfLoop
#endif
            movq        mm0,[esi]
            movq        mm1,[esi+1]

            movq        mm2,mm0
            psubusb     mm2,mm1
            psubusb     mm1,mm0
            por         mm2,mm1
            
            movq        mm3,x80
            movq        mm4,thr1
            pxor        mm2,mm3

            pcmpgtb     mm2,mm4
            pandn       mm2,x01
            movq        mm1,mm2
            psrlq       mm2,32
            paddb       mm2,mm1
            movq        mm1,mm2
            psrld       mm2,16
            paddb       mm2,mm1
            movq        mm1,mm2
            psrlw       mm2,8
            paddb       mm2,mm1

#ifndef USE_SPEEDUP
            movzx       eax,byte Ptr [esi+8]
            movzx       ebx,byte Ptr [esi+9]
            sub         eax,ebx
            cdq
            xor         eax,edx
            sub         eax,edx
            mov         ebx,eax
            sub         ebx,(THR1+1)
            sar         ebx,31
#endif

            movd        eax,mm2
            movzx       eax,al
#ifndef USE_SPEEDUP
            sub         eax,ebx
#endif
            cmp         eax,THR2
            jl          ShortFilter
  
            //Determine MIN & MAX values to see if filtering should be used
            
#ifndef USE_SPEEDUP
            movq        mm0,[esi+1]
            movq        mm4,x80
            pxor        mm0,mm4

            movq        mm1,mm0
            punpckldq   mm0,mm0
            punpckhdq   mm1,mm1

            movq        mm3,xFFFFFFFF00000000

            movq        mm2,mm0
            pcmpgtb     mm2,mm1
            pxor        mm2,mm3
            pand        mm0,mm2
            pandn       mm2,mm1
            por         mm0,mm2

            movq        mm1,mm0
            psrld       mm1,16
            movq        mm2,mm0
            pcmpgtb     mm2,mm1
            pxor        mm2,mm3
            pand        mm0,mm2
            pandn       mm2,mm1
            por         mm0,mm2

            movq        mm1,mm0
            psrlw       mm1,8
            movq        mm2,mm0
            pcmpgtb     mm2,mm1
            pxor        mm2,mm3
            pand        mm0,mm2
            pandn       mm2,mm1
            por         mm0,mm2
            pxor        mm0,mm4
            
            movq        mm2,mm0
            psrlq       mm2,32
            psubb       mm0,mm2
            
            movd        eax,mm0
            movzx       eax,al //max-min
            mov         edx,iStepSize
            shl         edx,1

            cmp         eax,edx
            jge         EndOfLoop
#else
            movzx       eax,byte Ptr [esi]      //Can probobly skip these lines if the speedup is necessary
            movzx       edx,byte Ptr [esi+9]
            sub         eax,edx
            cdq
            xor         eax,edx
            sub         eax,edx
            mov         edx,iStepSize
            shl         edx,1
            cmp         eax,edx
            jg          EndOfLoop
#endif

  
            pxor        mm7,mm7
  
            movq        mm5,[esi+1]
            movq        mm3,mm5
            punpcklbw   mm3,mm7
            movq        mm4,mm3
            paddw       mm3,mm3

            movq        mm2,mm5
            psrlq       mm2,8
            paddw       mm3,mm4
            movq        mm6,mm5
            punpcklbw   mm2,mm7
            paddw       mm4,mm2
            paddw       mm3,mm2

            psrlq       mm6,16
            movq        mm2,mm6
            punpcklbw   mm6,mm7
            paddw       mm6,mm6
                      
            psrlq       mm2,8
            paddw       mm4,mm6
            punpcklbw   mm2,mm7
            paddw       mm4,mm2
            paddw       mm3,mm4
            paddw       mm4,mm2

            movq        mm0,m6222
            punpckhbw   mm5,mm7
            paddw       mm3,mm5
            paddw       mm5,mm5                           
            paddw       mm4,mm5                           
            paddw       mm4,mm5

            movd        mm1,[esi]
            punpcklbw   mm1,mm7
            movq        mm2,mm1
#ifndef USE_SPEEDUP
            movzx       eax,byte Ptr [esi]
            movzx       edx,byte Ptr [esi+1]
            sub         eax,edx
            cdq
            xor         eax,edx
            sub         eax,edx
            mov         edx,iStepSize
            cmp         eax,edx
            jl          UseV0
            movq        mm5,x000000000000FFFF
            psrlq       mm2,16
            pand        mm2,mm5
            pandn       mm5,mm1
            por         mm2,mm5
            movq        mm1,mm2
UseV0:
#endif
            movq        mm5,m0422
            pmullw      mm1,mm0
            paddw       mm3,mm1
            
            movq        mm0,m1221
            psllq       mm2,16
            movq        mm1,mm2
            pmullw      mm2,mm5
            paddw       mm3,mm2

            movq        mm5,m2226
            psllq       mm1,16
            movq        mm2,mm1
            pmullw      mm1,mm0
            paddw       mm3,mm1

            psllq       mm2,16
            paddw       mm3,mm2

            movd        mm1,[esi+6]                
            punpcklbw   mm1,mm7
            movq        mm2,mm1
#ifndef USE_SPEEDUP
            movzx       eax,byte Ptr [esi+8]
            movzx       edx,byte Ptr [esi+9]
            sub         eax,edx
            cdq
            xor         eax,edx
            sub         eax,edx
            mov         edx,iStepSize
            cmp         eax,edx
            jl          UseV9
            movq        mm0,xFFFF000000000000
            psllq       mm2,16
            pand        mm2,mm0
            pandn       mm0,mm1
            por         mm2,mm0
            movq        mm1,mm2
            movq        mm0,m1221
UseV9:
#endif
            pmullw      mm1,mm5
            paddw       mm4,mm1

            movq        mm5,m2240
            psrlq       mm2,16
            movq        mm1,mm2
            pmullw      mm2,mm5
            paddw       mm4,mm2

            psrlq       mm1,16
            movq        mm2,mm1
            pmullw      mm1,mm0
            paddw       mm4,mm1

            movq        mm0,x0008
            psrlq       mm2,16
            paddw       mm4,mm2

            paddw       mm3,mm0
            psrlw       mm3,4
            paddw       mm4,mm0
            psrlw       mm4,4
            packuswb    mm3,mm4
            movq        [esi+1],mm3

            jmp         EndOfLoop

ShortFilter:
#ifdef USE_SPEEDUP
            movd        mm0,ecx
            movzx       eax,[esi+3]
            movzx       edx,[esi+6]
            sub         ecx,ebx
            shl         ecx,3
            sub         eax,edx
            mov         edx,eax
            shl         eax,1
            add         eax,edx
            add         eax,ecx
            sar         eax,4
            movd        ecx,mm0
            movzx       eax,byte Ptr [g_deblockTab+eax]
            add         ebx,eax
            sub         ecx,eax
            test        ebx,0xFF00
            jnz         Clip2
            mov         [esi+4],bl
Clip2Ret:   test        ecx,0xFF00
            jnz         Clip1
            mov         [esi+5],cl
Clip1Ret:
#else
            pxor        mm7,mm7
            movzx       ecx,byte Ptr [esi+4]
            mov         eax,ecx
            movzx       ebx,byte Ptr [esi+5]

            movq        mm0,[esi+1]
            movq        mm5,s1
            movq        mm6,s2
            movq        mm1,mm0
            punpcklbw   mm1,mm7   
            pmaddwd     mm1,mm5
            movq        mm2,mm0
            psrlq       mm2,16
            punpcklbw   mm2,mm7   
            movq        mm3,mm2
            pmaddwd     mm2,mm6
            paddd       mm1,mm2
            paddd       mm1,x00000004
            psrad       mm1,3
            
            pxor        mm6,mm6
            pcmpgtb     mm6,mm1                    
            pxor        mm1,mm6
            psubd       mm1,mm6

            movq        mm4,mm1
            psrlq       mm1,32
            
            movd        edx,mm1
            cmp         edx,iStepSize
            jge         EndOfLoop

            sub         eax,ebx
            cdq
            xor         eax,edx
            sub         eax,edx

            shr         eax,1

            test        eax,eax
            jz          EndOfLoop

            movq        mm3,mm0
            punpckhbw   mm3,mm7
            pmaddwd     mm3,s3
            movq        mm2,mm3
            psrlq       mm2,32
            paddd       mm3,mm2
            paddd       mm3,x00000004
            psrad       mm3,3
            movq        mm2,mm1

            //From here on could be done 2 or 4 at a time
            //mm2=a30
            //mm3=a32
            //mm4=a31

            pxor        mm5,mm5
            pcmpgtd     mm5,mm3
            pxor        mm3,mm5
            psubd       mm3,mm5

            movq        mm5,mm2
            pcmpgtd     mm5,mm3
            pand        mm3,mm5
            pandn       mm5,mm2
            por         mm3,mm5

            movq        mm5,mm4
            pcmpgtd     mm5,mm3
            pand        mm3,mm5
            pandn       mm5,mm4
            por         mm3,mm5

            psubd       mm3,mm1

            pxor        mm4,mm4
            pcmpgtd     mm4,mm3
            pxor        mm3,mm4
            psubd       mm3,mm4

            pmaddwd     mm3,x00000005
            psrad       mm3,3        

            pxor        mm3,mm4
            psubd       mm3,mm4

            psrlq       mm6,32
            pxor        mm3,mm6
            psubd       mm3,mm6

            movd        mm5,edx

            pxor        mm3,mm5
            psubd       mm3,mm5

            movd        mm0,eax
            movq        mm1,mm0
            pcmpgtd     mm1,mm3
            pand        mm3,mm1
            pandn       mm1,mm0
            por         mm3,mm1
            
            pxor        mm1,mm1
            pcmpgtd     mm1,mm3
            pandn       mm1,mm3

            pxor        mm1,mm5
            psubd       mm1,mm5

            movd        eax,mm1

            sub         ecx,eax
            add         ebx,eax

            test        ecx,0x100
            jnz         Clip1
            mov         [esi+4],cl          
            
Clip1Ret:   test        ebx,0x100
            jnz         Clip2
            mov         [esi+5],bl
Clip2Ret:
#endif
EndOfLoop:                
             mov        eax,iPixelIncrement
             add        esi,eax
             
             dec        edi
             jnz        MainLoop

            }
return;
        _asm {
Clip1:      cmp         ecx,0
            jl          Clip1Down
            mov         [esi+4],0xFF
            jmp         Clip1Ret
Clip1Down:  mov         [esi+4],0
            jmp         Clip1Ret

Clip2:      cmp         ebx,0
            jl          Clip2Down
            mov         [esi+5],0xFF
            jmp         Clip2Ret
Clip2Down:  mov         [esi+5],0
            jmp         Clip2Ret
        }
}

Void_WMV FilterHalfVerticalEdge_FASTEST(U8_WMV* ppxlcCenter, I32_WMV iPixelDistance, I32_WMV iPixelIncrement, I32_WMV iEdgeLength, I32_WMV iStepSize)
{

    static const Int64 x80 = 0x8080808080808080;
    static const Int64 thr1 = (THR1 | (THR1 << 8) | (THR1 << 16) | (THR1 << 24) | ((Int64)THR1 << 32) | ((Int64)THR1 << 40) | ((Int64)THR1 << 48) | ((Int64)THR1 << 56)) ^ x80;
    static const Int64 thr2 = (THR2-1) | ((THR2-1) << 8) | ((THR2-1) << 16) | ((THR2-1) << 24) | ((Int64)(THR2-1) << 32) | ((Int64)(THR2-1) << 40) | ((Int64)(THR2-1) << 48) | ((Int64)(THR2-1) << 56);
    static const Int64 x01 = 0x0101010101010101;
  
    static const Int64 xFFFFFFFF00000000 = 0xFFFFFFFF00000000;
    static const Int64 x000000000000FFFF = 0x000000000000FFFF;
    static const Int64 xFFFF000000000000 = 0xFFFF000000000000;

    static const Int64 x0008 = 0x0008000800080008;
    static const Int64 s1 = 0xFFFB0002FFFB0002;
    static const Int64 s2 = 0xFFFE0005FFFE0005;
    static const Int64 s3 = 0xFFFE0005FFFB0002;
    static const Int64 x00000004 = 0x0000000400000004;       
    static const Int64 x00000005 = 0x0000000500000005;

    //For Long Filter
    static const Int64 m2226 = 0x0006000200020002;
    static const Int64 m2240 = 0x0000000400020002;
    static const Int64 m1221 = 0x0001000200020001;
    static const Int64 m6222 = 0x0002000200020006;
    static const Int64 m0422 = 0x0002000200040000;
    
    

       _asm {
            mov         esi,ppxlcCenter
            sub         esi,5
            mov         edi,iEdgeLength
MainLoop:
            
            //Determine Which Filter To Use Long or short    

#ifdef USE_SPEEDUP
            movzx       ebx,byte Ptr [esi+4]
            movzx       ecx,byte Ptr [esi+5]
            cmp         ebx,ecx
            jz          EndOfLoop
#endif
            movq        mm0,[esi]
            movq        mm1,[esi+1]

            movq        mm2,mm0
            psubusb     mm2,mm1
            psubusb     mm1,mm0
            por         mm2,mm1
            
            movq        mm3,x80
            movq        mm4,thr1
            pxor        mm2,mm3

            pcmpgtb     mm2,mm4
            pandn       mm2,x01
            movq        mm1,mm2
            psrlq       mm2,32
            paddb       mm2,mm1
            movq        mm1,mm2
            psrld       mm2,16
            paddb       mm2,mm1
            movq        mm1,mm2
            psrlw       mm2,8
            paddb       mm2,mm1

#ifndef USE_SPEEDUP
            movzx       eax,byte Ptr [esi+8]
            movzx       ebx,byte Ptr [esi+9]
            sub         eax,ebx
            cdq
            xor         eax,edx
            sub         eax,edx
            xor         ebx,ebx
            cmp         eax,THR1
            jg          DontAdd1
            mov         ebx,1
DontAdd1:
#endif

            movd        eax,mm2
            movzx       eax,al
#ifndef USE_SPEEDUP
            add         eax,ebx
#endif
            cmp         eax,THR2
            jl          ShortFilter
  
            //Determine MIN & MAX values to see if filtering should be used
            
#ifndef USE_SPEEDUP
            movq        mm0,[esi+1]
            movq        mm4,x80
            pxor        mm0,mm4

            movq        mm1,mm0
            punpckldq   mm0,mm0
            punpckhdq   mm1,mm1

            movq        mm3,xFFFFFFFF00000000

            movq        mm2,mm0
            pcmpgtb     mm2,mm1
            pxor        mm2,mm3
            pand        mm0,mm2
            pandn       mm2,mm1
            por         mm0,mm2

            movq        mm1,mm0
            psrld       mm1,16
            movq        mm2,mm0
            pcmpgtb     mm2,mm1
            pxor        mm2,mm3
            pand        mm0,mm2
            pandn       mm2,mm1
            por         mm0,mm2

            movq        mm1,mm0
            psrlw       mm1,8
            movq        mm2,mm0
            pcmpgtb     mm2,mm1
            pxor        mm2,mm3
            pand        mm0,mm2
            pandn       mm2,mm1
            por         mm0,mm2
            pxor        mm0,mm4
            
            movq        mm2,mm0
            psrlq       mm2,32
            psubb       mm0,mm2
            
            movd        eax,mm0
            movzx       eax,al //max-min
            mov         edx,iStepSize
            shl         edx,1

            cmp         eax,edx
            jge         EndOfLoop
#else
            movzx       eax,byte Ptr [esi]
            movzx       edx,byte Ptr [esi+9]
            sub         eax,edx
            cdq
            xor         eax,edx
            sub         eax,edx
            mov         edx,iStepSize
            shl         edx,1
            cmp         eax,edx
            jg          EndOfLoop
#endif            
  
            pxor        mm7,mm7
  
            movq        mm5,[esi+1]
            movq        mm3,mm5
            punpcklbw   mm3,mm7
            movq        mm4,mm3
            paddw       mm3,mm3

            movq        mm2,mm5
            psrlq       mm2,8
            paddw       mm3,mm4
            movq        mm6,mm5
            punpcklbw   mm2,mm7
            paddw       mm4,mm2
            paddw       mm3,mm2

            psrlq       mm6,16
            movq        mm2,mm6
            punpcklbw   mm6,mm7
            paddw       mm6,mm6
                      
            psrlq       mm2,8
            paddw       mm4,mm6
            punpcklbw   mm2,mm7
            paddw       mm4,mm2
            paddw       mm3,mm4
            paddw       mm4,mm2

            movq        mm0,m6222
            punpckhbw   mm5,mm7
            paddw       mm3,mm5
            paddw       mm5,mm5                           
            paddw       mm4,mm5                           
            paddw       mm4,mm5

            movd        mm1,[esi]
            punpcklbw   mm1,mm7
            movq        mm2,mm1
#ifndef USE_SPEEDUP
            movzx       eax,byte Ptr [esi]
            movzx       edx,byte Ptr [esi+1]
            sub         eax,edx
            cdq
            xor         eax,edx
            sub         eax,edx
            mov         edx,iStepSize
            cmp         eax,edx
            jl          UseV0
            movq        mm5,x000000000000FFFF
            psrlq       mm2,16
            pand        mm2,mm5
            pandn       mm5,mm1
            por         mm2,mm5
            movq        mm1,mm2
UseV0:
#endif
            movq        mm5,m0422
            pmullw      mm1,mm0
            paddw       mm3,mm1
            
            movq        mm0,m1221
            psllq       mm2,16
            movq        mm1,mm2
            pmullw      mm2,mm5
            paddw       mm3,mm2

            movq        mm5,m2226
            psllq       mm1,16
            movq        mm2,mm1
            pmullw      mm1,mm0
            paddw       mm3,mm1

            psllq       mm2,16
            paddw       mm3,mm2

            movd        mm1,[esi+6]                
            punpcklbw   mm1,mm7
            movq        mm2,mm1
#ifndef USE_SPEEDUP
            movzx       eax,byte Ptr [esi+8]
            movzx       edx,byte Ptr [esi+9]
            sub         eax,edx
            cdq
            xor         eax,edx
            sub         eax,edx
            mov         edx,iStepSize
            cmp         eax,edx
            jl          UseV9
            movq        mm0,xFFFF000000000000
            psllq       mm2,16
            pand        mm2,mm0
            pandn       mm0,mm1
            por         mm2,mm0
            movq        mm1,mm2
            movq        mm0,m1221
UseV9:
#endif
            pmullw      mm1,mm5
            paddw       mm4,mm1

            movq        mm5,m2240
            psrlq       mm2,16
            movq        mm1,mm2
            pmullw      mm2,mm5
            paddw       mm4,mm2

            psrlq       mm1,16
            movq        mm2,mm1
            pmullw      mm1,mm0
            paddw       mm4,mm1

            movq        mm0,x0008
            psrlq       mm2,16
            paddw       mm4,mm2

            paddw       mm3,mm0
            psrlw       mm3,4
            paddw       mm4,mm0
            psrlw       mm4,4
            packuswb    mm3,mm4
            movd        [esi+1],mm3

            jmp         EndOfLoop

ShortFilter:
#ifdef USE_SPEEDUP
            movd        mm0,ecx
            movzx       eax,[esi+3]
            movzx       edx,[esi+6]
            sub         ecx,ebx
            shl         ecx,3
            sub         eax,edx
            mov         edx,eax
            shl         eax,1
            add         eax,edx
            add         eax,ecx
            sar         eax,4
            movd        ecx,mm0
            movzx       eax,byte Ptr [g_deblockTab+eax]
            add         ebx,eax
            sub         ecx,eax
            test        ebx,0xFF00
            jnz         Clip2
            mov         [esi+4],bl
#else
            pxor        mm7,mm7
            movzx       ecx,byte Ptr [esi+4]
            mov         eax,ecx
            movzx       ebx,byte Ptr [esi+5]

            movq        mm0,[esi+1]
            movq        mm5,s1
            movq        mm6,s2
            movq        mm1,mm0
            punpcklbw   mm1,mm7   
            pmaddwd     mm1,mm5
            movq        mm2,mm0
            psrlq       mm2,16
            punpcklbw   mm2,mm7   
            movq        mm3,mm2
            pmaddwd     mm2,mm6
            paddd       mm1,mm2
            paddd       mm1,x00000004
            psrad       mm1,3
            
            pxor        mm6,mm6
            pcmpgtb     mm6,mm1                    
            pxor        mm1,mm6
            psubd       mm1,mm6

            movq        mm4,mm1
            psrlq       mm1,32
            
            movd        edx,mm1
            cmp         edx,iStepSize
            jge         EndOfLoop

            sub         eax,ebx
            cdq
            xor         eax,edx
            sub         eax,edx

            shr         eax,1

            test        eax,eax
            jz          EndOfLoop

            movq        mm3,mm0
            punpckhbw   mm3,mm7
            pmaddwd     mm3,s3
            movq        mm2,mm3
            psrlq       mm2,32
            paddd       mm3,mm2
            paddd       mm3,x00000004
            psrad       mm3,3
            

            movq        mm2,mm1

            //From here on could be done 2 or 4 at a time
            
            //mm2=a30
            //mm3=a32
            //mm4=a31

            pxor        mm5,mm5
            pcmpgtd     mm5,mm3
            pxor        mm3,mm5
            psubd       mm3,mm5

            movq        mm5,mm2
            pcmpgtd     mm5,mm3
            pand        mm3,mm5
            pandn       mm5,mm2
            por         mm3,mm5

            movq        mm5,mm4
            pcmpgtd     mm5,mm3
            pand        mm3,mm5
            pandn       mm5,mm4
            por         mm3,mm5

            psubd       mm3,mm1

            pxor        mm4,mm4
            pcmpgtd     mm4,mm3
            pxor        mm3,mm4
            psubd       mm3,mm4

            pmaddwd     mm3,x00000005
            psrad       mm3,3        

            pxor        mm3,mm4
            psubd       mm3,mm4

            psrlq       mm6,32
            pxor        mm3,mm6
            psubd       mm3,mm6

            movd        mm5,edx

            pxor        mm3,mm5
            psubd       mm3,mm5

            movd        mm0,eax
            movq        mm1,mm0
            pcmpgtd     mm1,mm3
            pand        mm3,mm1
            pandn       mm1,mm0
            por         mm3,mm1
            
            pxor        mm1,mm1
            pcmpgtd     mm1,mm3
            pandn       mm1,mm3

            pxor        mm1,mm5
            psubd       mm1,mm5

            movd        eax,mm1

            sub         ecx,eax
            add         ebx,eax

            test        ecx,0x100
            jnz         Clip1
            mov         [esi+4],cl          
            
Clip1Ret: 
#endif
EndOfLoop:                
             mov        eax,iPixelIncrement
             add        esi,eax
             
             dec        edi
             jnz        MainLoop

            }
return;
#ifdef USE_SPEEDUP
        _asm {
Clip2:      cmp         ebx,0
            jl          Clip2Down
            mov         [esi+5],0xFF
            jmp         EndOfLoop
Clip2Down:  mov         [esi+5],0
            jmp         EndOfLoop
        }
#else
        _asm {
Clip1:      cmp         ecx,0
            jl          Clip1Down
            mov         [esi+4],0xFF
            jmp         Clip1Ret
Clip1Down:  mov         [esi+4],0
            jmp         Clip1Ret

        }
#endif
}
#undef USE_SPEEDUP


//Find maxumum and minimum values in a 10x10 block
#pragma warning (disable:4799)
Void_WMV DetermineThreshold_MMX(U8_WMV *srcptr, I32_WMV *thr, I32_WMV *range, I32_WMV width) 
{
    static const Int64 x80               = 0x8080808080808080;
    static const Int64 x000000000000FFFF = 0x000000000000FFFF;
    static const Int64 xFFFFFFFF00000000 = 0xFFFFFFFF00000000;
    static const Int64 x00000000FFFFFFFF = 0x00000000FFFFFFFF;

    _asm {

        mov         eax,width           //Setup pointers
        mov         ebx,eax
        neg         ebx
        mov         esi,srcptr
        dec         esi
        lea         esi,[esi+eax]
        lea         edi,[esi+eax*4]
        add         edi,eax

        movq        mm7,x80
        movq        mm6,x000000000000FFFF

        movq        mm0,[esi+ebx*2]     //Load first line
        pxor        mm0,mm7
        movq        mm1,[esi+ebx]       //Load second line
        pxor        mm1,mm7
        
        movq        mm2,mm1             //Min Max first 2 lines
        pcmpgtb     mm2,mm0
        movq        mm4,mm0
        pand        mm0,mm2         
        pxor        mm4,mm0
        pandn       mm2,mm1
        pxor        mm1,mm2
        por         mm0,mm2
        por         mm1,mm4

        movq        mm2,[esi]           //Load third line
        pxor        mm2,mm7
        movq        mm3,[esi+eax]       //Load forth line
        pxor        mm3,mm7
        movq        mm4,mm3             //Min Max next 2 lines
        pcmpgtb     mm4,mm2
        movq        mm5,mm2
        pand        mm2,mm4         
        pxor        mm5,mm2
        pandn       mm4,mm3
        pxor        mm3,mm4
        por         mm2,mm4
        por         mm3,mm5
        
        movq        mm4,mm2             //Min first 2 pairs
        pcmpgtb     mm4,mm0
        pand        mm0,mm4
        pandn       mm4,mm2
        por         mm0,mm4

        movq        mm4,mm1             //Max first 2 pairs
        pcmpgtb     mm4,mm3
        pand        mm1,mm4
        pandn       mm4,mm3
        por         mm1,mm4

        movq        mm2,[esi+eax*2]     //Load fifth line
        pxor        mm2,mm7
        movq        mm3,[edi+ebx*2]     //Load sixth line
        pxor        mm3,mm7
        movq        mm4,mm3             //Min Max next 2 lines
        pcmpgtb     mm4,mm2
        movq        mm5,mm2
        pand        mm2,mm4         
        pxor        mm5,mm2
        pandn       mm4,mm3
        pxor        mm3,mm4
        por         mm2,mm4
        por         mm3,mm5
        
        movq        mm4,mm2             //Min last 2 pairs
        pcmpgtb     mm4,mm0
        pand        mm0,mm4
        pandn       mm4,mm2
        por         mm0,mm4

        movq        mm4,mm1             //Max last 2 pairs
        pcmpgtb     mm4,mm3
        pand        mm1,mm4
        pandn       mm4,mm3
        por         mm1,mm4

        movq        mm2,[edi+ebx]       //Load 7'th line
        pxor        mm2,mm7
        movq        mm3,[edi]           //Load 8'th line
        pxor        mm3,mm7
        movq        mm4,mm3             //Min Max next 2 lines
        pcmpgtb     mm4,mm2
        movq        mm5,mm2
        pand        mm2,mm4         
        pxor        mm5,mm2
        pandn       mm4,mm3
        pxor        mm3,mm4
        por         mm2,mm4
        por         mm3,mm5
        
        movq        mm4,mm2             //Min last 2 pairs
        pcmpgtb     mm4,mm0
        pand        mm0,mm4
        pandn       mm4,mm2
        por         mm0,mm4

        movq        mm4,mm1             //Max last 2 pairs
        pcmpgtb     mm4,mm3
        pand        mm1,mm4
        pandn       mm4,mm3
        por         mm1,mm4

        movq        mm2,[edi+eax]       //Load 9'th line
        pxor        mm2,mm7
        movq        mm3,[edi+eax*2]     //Load 10'th line
        pxor        mm3,mm7
        movq        mm4,mm3             //Min Max next 2 lines
        pcmpgtb     mm4,mm2
        movq        mm5,mm2
        pand        mm2,mm4         
        pxor        mm5,mm2
        pandn       mm4,mm3
        pxor        mm3,mm4
        por         mm2,mm4
        por         mm3,mm5
        
        movq        mm4,mm2             //Min last 2 pairs
        pcmpgtb     mm4,mm0
        pand        mm0,mm4
        pandn       mm4,mm2
        por         mm0,mm4

        movq        mm4,mm1             //Max last 2 pairs
        pcmpgtb     mm4,mm3
        pand        mm1,mm4
        pandn       mm4,mm3
        por         mm1,mm4
        
        movd        mm2,[esi+ebx*2+8]   //Load last 2 bytes of lines (0-8)
        movd        mm3,[esi+ebx+8]
        punpcklwd   mm2,mm3
        movd        mm3,[esi+8]
        movd        mm4,[esi+eax+8]
        punpcklwd   mm3,mm4
        punpckldq   mm2,mm3
        movd        mm3,[esi+eax*2+8]
        movd        mm4,[edi+ebx*2+8]
        punpcklwd   mm3,mm4
        movd        mm4,[edi+ebx+8]
        movd        mm5,[edi+8]
        punpcklwd   mm4,mm5
        punpckldq   mm3,mm4
        pxor        mm2,mm7             //Min Max last 2 bytes of each line
        pxor        mm3,mm7
        movq        mm4,mm3             
        pcmpgtb     mm4,mm2
        movq        mm5,mm2
        pand        mm2,mm4         
        pxor        mm5,mm2
        pandn       mm4,mm3
        pxor        mm3,mm4
        por         mm2,mm4
        por         mm3,mm5

        movq        mm4,mm2             //Min 
        pcmpgtb     mm4,mm0
        pand        mm0,mm4
        pandn       mm4,mm2
        por         mm0,mm4

        movq        mm4,mm1             //Max 
        pcmpgtb     mm4,mm3
        pand        mm1,mm4
        pandn       mm4,mm3
        por         mm1,mm4


        movq        mm5,x00000000FFFFFFFF

        movd        mm2,[edi+eax+8]     //Load last 2 bytes of last 2 lines
        movd        mm3,[edi+eax*2+8]
        punpcklwd   mm2,mm3
        punpckldq   mm2,mm2
        pxor        mm2,mm7

        movq        mm4,mm2             //Min
        pcmpgtb     mm4,mm0
        pand        mm0,mm4
        pandn       mm4,mm2
        por         mm0,mm4

        movq        mm4,mm2             //Max
        pcmpgtb     mm4,mm1
        pand        mm2,mm4
        pandn       mm4,mm1
        por         mm2,mm4
        
        movq        mm1,mm0             //Max values in high 1/2 min values in low 1/2
        punpckldq   mm0,mm2
        punpckhdq   mm1,mm2
        movq        mm2,mm1
        
        movq        mm6,xFFFFFFFF00000000
        
        movq        mm1,mm0
        pcmpgtb     mm1,mm2
        pxor        mm1,mm6
        pand        mm2,mm1
        pandn       mm1,mm0
        por         mm2,mm1

        movq        mm0,mm2
        psrld       mm0,16
        movq        mm1,mm0
        pcmpgtb     mm1,mm2
        pxor        mm1,mm5
        pand        mm0,mm1
        pandn       mm1,mm2
        por         mm0,mm1

        movq        mm2,mm0
        psrld       mm0,8
        movq        mm1,mm0
        pcmpgtb     mm1,mm2
        pxor        mm1,mm5
        pand        mm0,mm1
        pandn       mm1,mm2
        por         mm0,mm1

        pxor        mm0,mm7
        movd        eax,mm0
        psrlq       mm0,32
        and         eax,0xFF
        movd        edx,mm0
        and         edx,0xFF


        lea         ebx,[eax+edx+1]
        shr         ebx,1
        mov         esi,thr
        mov         [esi],ebx

        sub         edx,eax
        mov         esi,range
        mov         [esi],edx
    }
}    


Void_WMV ApplySmoothing_MMX(U8_WMV *pixel,I32_WMV width, I32_WMV max_diff,I32_WMV thr)
{

    static const Int64 x80   = 0x8080808080808080;
    static const Int64 xF7   = 0xF7F7F7F7F7F7F7F7;
    static const Int64 x0008 = 0x0008000800080008;
    static const Int64 x01   = 0x0101010101010101;

	I8_WMV alignedBuf1[16*16+32];
	I8_WMV alignedBuf2[3*8+8];

	Int64* pAlignedBuf1 = (Int64*)(((I32_WMV)alignedBuf1 + 31) & ~31); // TEST
	Int64* pAlignedBuf2 = (Int64*)(((I32_WMV)alignedBuf2 + 7) & ~7);

    _asm {
        mov         eax,width           //Setup pointers
        mov         ebx,eax
        neg         ebx
        mov         esi,pixel
        dec         esi
        lea         esi,[esi+eax]
        lea         edi,[esi+eax*4]
        add         edi,eax
        movq        mm6,x80
		mov			ecx,pAlignedBuf1

        movd        mm7,thr             //Broadcast Threshold
        punpcklbw   mm7,mm7
        punpcklwd   mm7,mm7
        punpckldq   mm7,mm7
        psubusb     mm7,x01
        pxor        mm7,mm6
          
        movq        mm0,[esi+ebx*2]     //Compare first line with threshold
        pxor        mm0,mm6
        pcmpgtb     mm0,mm7
        movq        [ecx],mm0
        movd        mm0,[esi+ebx*2+8]   
        pxor        mm0,mm6
        pcmpgtb     mm0,mm7
        movd        [ecx+8],mm0

        movq        mm0,[esi+ebx]       //Second Line
        pxor        mm0,mm6
        pcmpgtb     mm0,mm7
        movq        [ecx+16],mm0
        movq        mm0,[esi+ebx+8]
        pxor        mm0,mm6
        pcmpgtb     mm0,mm7
        movd        [ecx+24],mm0

        movq        mm0,[esi]           //Third Line
        pxor        mm0,mm6
        pcmpgtb     mm0,mm7
        movq        [ecx+32],mm0
        movq        mm0,[esi+8]
        pxor        mm0,mm6
        pcmpgtb     mm0,mm7
        movd        [ecx+40],mm0

        movq        mm0,[esi+eax]       //Forth Line
        pxor        mm0,mm6
        pcmpgtb     mm0,mm7
        movq        [ecx+48],mm0
        movq        mm0,[esi+eax+8]
        pxor        mm0,mm6
        pcmpgtb     mm0,mm7
        movd        [ecx+56],mm0

        movq        mm0,[esi+eax*2]     //Sixth Line
        pxor        mm0,mm6
        pcmpgtb     mm0,mm7
        movq        [ecx+64],mm0
        movq        mm0,[esi+eax*2+8]
        pxor        mm0,mm6
        pcmpgtb     mm0,mm7
        movd        [ecx+72],mm0

        movq        mm0,[edi+ebx*2]     //Sixth Line
        pxor        mm0,mm6
        pcmpgtb     mm0,mm7
        movq        [ecx+80],mm0
        movq        mm0,[edi+ebx*2+8]
        pxor        mm0,mm6
        pcmpgtb     mm0,mm7
        movd        [ecx+88],mm0

        movq        mm0,[edi+ebx]       //7'th Line
        pxor        mm0,mm6
        pcmpgtb     mm0,mm7
        movq        [ecx+96],mm0
        movq        mm0,[edi+ebx+8]
        pxor        mm0,mm6
        pcmpgtb     mm0,mm7
        movd        [ecx+104],mm0

        movq        mm0,[edi]           //8'th Line
        pxor        mm0,mm6
        pcmpgtb     mm0,mm7
        movq        [ecx+112],mm0
        movq        mm0,[edi+8]
        pxor        mm0,mm6
        pcmpgtb     mm0,mm7
        movd        [ecx+120],mm0

        movq        mm0,[edi+eax]       //9'th Line
        pxor        mm0,mm6
        pcmpgtb     mm0,mm7
        movq        [ecx+128],mm0
        movq        mm0,[edi+eax+8]
        pxor        mm0,mm6
        pcmpgtb     mm0,mm7
        movd        [ecx+136],mm0

        movq        mm0,[edi+eax*2]     //9'th Line
        pxor        mm0,mm6
        pcmpgtb     mm0,mm7
        movq        [ecx+144],mm0
        movq        mm0,[edi+eax*2+8]
        pxor        mm0,mm6
        pcmpgtb     mm0,mm7
        movd        [ecx+152],mm0

        lea         edx,[edi+eax*2]
        movq        mm0,[edx+eax]       //10'th Line
        pxor        mm0,mm6
        pcmpgtb     mm0,mm7
        movq        [ecx+160],mm0
        movq        mm0,[edx+eax+8]
        pxor        mm0,mm6
        pcmpgtb     mm0,mm7
        movd        [ecx+168],mm0

        //Smoothing Filter
        pxor        mm7,mm7

        movd        mm0,max_diff        //Broadcast max_diff
        punpcklbw   mm0,mm0
        punpcklwd   mm0,mm0
        punpckldq   mm0,mm0

        movq        mm1,[esi+ebx*2]     //Upper Left Pixel
        movq        mm2,mm1
        punpcklbw   mm1,mm7
        punpckhbw   mm2,mm7

        movq        mm3,[esi+ebx*2+1]   //Upper Middel Pixel
        movq        mm4,mm3
        punpcklbw   mm3,mm7
        punpckhbw   mm4,mm7
        paddw       mm1,mm3
        paddw       mm2,mm4
        paddw       mm1,mm3
        paddw       mm2,mm4

        movq        mm3,[esi+ebx*2+2]   //Upper Right Pixel
        movq        mm4,mm3
        punpcklbw   mm3,mm7
        punpckhbw   mm4,mm7
        paddw       mm1,mm3
        paddw       mm2,mm4

        movq        mm3,[esi+ebx]       //Center Left Pixel
        movq        mm4,mm3
        punpcklbw   mm3,mm7
        punpckhbw   mm4,mm7

        movq        mm5,[esi+ebx+1]     //Center Middel Pixel
        movq        mm6,mm5
        punpcklbw   mm5,mm7
        punpckhbw   mm6,mm7
        paddw       mm3,mm5
        paddw       mm4,mm6
        paddw       mm3,mm5
        paddw       mm4,mm6

        movq        mm5,[esi+ebx+2]     //Center Right Pixel
        movq        mm6,mm5
        punpcklbw   mm5,mm7
        punpckhbw   mm6,mm7
        paddw       mm3,mm5
        paddw       mm4,mm6
        
		mov			edi,pAlignedBuf2
        mov         edx,8

        movq        [edi],mm3           //Save for next loop itteration
        movq        [edi+8],mm4
        movq        [edi+16],mm0

SmoothingLoop:
        
        pxor        mm7,mm7
        movq        mm6,xF7             //Generate mask
        movq        mm0,[ecx]
        movq        mm5,[ecx+1]
        paddb       mm0,mm5
        movq        mm5,[ecx+2]
        paddb       mm0,mm5
        movq        mm5,[ecx+16]
        paddb       mm0,mm5
        movq        mm5,[ecx+17]
        paddb       mm0,mm5
        movq        mm5,[ecx+18]
        paddb       mm0,mm5
        movq        mm5,[ecx+32]
        paddb       mm0,mm5
        movq        mm5,[ecx+33]
        paddb       mm0,mm5
        movq        mm5,[ecx+34]
        paddb       mm0,mm5
        movq        mm5,mm0
        pcmpeqb     mm0,mm7
        pcmpeqb     mm5,mm6
        por         mm0,mm5

        paddw       mm1,mm3             //Top + 2*Center
        paddw       mm2,mm4
        paddw       mm1,mm3
        paddw       mm2,mm4

        movq        mm3,[esi]           //Bottom Left Pixel
        movq        mm4,mm3             
        punpcklbw   mm3,mm7             
        punpckhbw   mm4,mm7             
                                        
        movq        mm5,[esi+1]         //Bottom Middel Pixel
        movq        mm6,mm5             
        punpcklbw   mm5,mm7             
        punpckhbw   mm6,mm7             
        paddw       mm3,mm5             
        paddw       mm4,mm6             
        paddw       mm3,mm5             
        paddw       mm4,mm6             
                                        
        movq        mm5,[esi+2]         //Bottom Right Pixel
        movq        mm6,mm5             
        punpcklbw   mm5,mm7             
        punpckhbw   mm6,mm7             
        paddw       mm3,mm5             
        paddw       mm4,mm6             
                                        
        movq        mm5,x0008           //((Top + 2*Center) + Bottom + 8) >> 4
        paddw       mm1,mm3                 
        paddw       mm2,mm4
        paddw       mm1,mm5
        paddw       mm2,mm5
        psrlw       mm1,4
        psrlw       mm2,4
        packuswb    mm1,mm2
                                            
        movq        mm2,[esi+ebx+1]     //Move Masked

        movq        mm6,[edi+16]             //Compare diffrence with max_diff
        movq        mm7,mm2    
        psubusb     mm7,mm1
        movq        mm5,mm1    
        psubusb     mm5,mm2
        psubusb     mm7,mm6
        paddusb     mm1,mm7
        psubusb     mm5,mm6
        psubusb     mm1,mm5

        pand        mm1,mm0                 
        pandn       mm0,mm2                 
        por         mm0,mm1                 
        movq        [esi+ebx+1],mm0         
        
        movq        mm1,[edi]
        movq        mm2,[edi+8]

        movq        [edi],mm3           //Save for next loop itteration
        movq        [edi+8],mm4

        add         esi,eax             //Adjust Pointers  & Loop
        add         ecx,16                  
        dec         edx
        jnz         SmoothingLoop
    }
}

//////////////////////////// Katmai Versions /////////////////////////////////
Void_WMV DetermineThreshold_KNI(U8_WMV *ptr, I32_WMV *thr, I32_WMV *range, I32_WMV width) 
{
    I32_WMV max = 0;                                         
    I32_WMV min = 255;                                       
	I32_WMV asmRange, asmThr;
	U8_WMV * pPcStartPtr = ptr - 1 - width;

	__asm 
	{
		mov			esi, pPcStartPtr
		mov			edi, width
		pcmpeqw		mm4, mm4		// use for Min, 1st 8
		pcmpeqw		mm5, mm5		// use for Min, last 2
		pxor		mm6, mm6		// use for Max, 1st 8
		pxor		mm7, mm7		// use for Max, last 2
		mov			ecx, 5

	Compute:
		movq		mm0, [esi]		// row -1
		pminub		mm4_mm0
		pmaxub		mm6_mm0
		movd		mm1, [esi+8]
		pminub		mm5_mm1
		pmaxub		mm7_mm1

		movq		mm0, [esi][edi]		// row 0
		pminub		mm4_mm0
		pmaxub		mm6_mm0
		movd		mm1, [esi+8][edi]
		pminub		mm5_mm1
		pmaxub		mm7_mm1

		lea			esi, [esi+edi*2]
		dec			ecx
		jg			Compute

		movq		mm0, mm4		// min
		movq		mm1, mm6		// max

		psrlq		mm0, 32
		psrlq		mm1, 32

		pminub		mm4_mm0
		pmaxub		mm6_mm1

		movq		mm0, mm4		// min
		movq		mm1, mm6		// max

		psrld		mm0, 16
		psrld		mm1, 16

		pminub		mm4_mm0		    // only 2 now so factor in last 2
		pmaxub		mm6_mm1	    	// only 2 now so factor in last 2

		pminub		mm4_mm5
		pmaxub		mm6_mm7

		movq		mm0, mm4		// min
		movq		mm1, mm6		// max

		psrlw		mm0, 8
		psrlw		mm1, 8

		pminub		mm4_mm0 		// final min
		pmaxub		mm6_mm1 		// final max

		movq		mm7, mm6
		psubb		mm7, mm4		// range = max - min
		pavgb		mm6_mm4   		// thr = (max + min + 1) / 2;

		movd		eax, mm6
		movd		ebx, mm7
		movzx		eax, al
		movzx		ebx, bl			
		
		mov			asmThr, eax
		mov			asmRange, ebx
	}

    *thr = asmThr;					// (max + min + 1) / 2;
    *range = asmRange;				// max - min;
}    

Void_WMV FilterVerticalEdge_KNI(U8_WMV* ppxlcCenter, I32_WMV iPixelDistance, I32_WMV iPixelIncrement, I32_WMV iEdgeLength, I32_WMV iStepSize)
{

    static const Int64 x80 = 0x8080808080808080;
    static const Int64 thr1 = (THR1 | (THR1 << 8) | (THR1 << 16) | (THR1 << 24) | ((Int64)THR1 << 32) | ((Int64)THR1 << 40) | ((Int64)THR1 << 48) | ((Int64)THR1 << 56)) ^ x80;
    static const Int64 thr2 = (THR2-1) | ((THR2-1) << 8) | ((THR2-1) << 16) | ((THR2-1) << 24) | ((Int64)(THR2-1) << 32) | ((Int64)(THR2-1) << 40) | ((Int64)(THR2-1) << 48) | ((Int64)(THR2-1) << 56);
    static const Int64 x01 = 0x0101010101010101;
  
    static const Int64 xFFFFFFFF00000000 = 0xFFFFFFFF00000000;
    static const Int64 x000000000000FFFF = 0x000000000000FFFF;
    static const Int64 xFFFF000000000000 = 0xFFFF000000000000;

    static const Int64 x0008 = 0x0008000800080008;
    static const Int64 s1 = 0xFFFB0002FFFB0002;
    static const Int64 s2 = 0xFFFE0005FFFE0005;
    static const Int64 s3 = 0xFFFE0005FFFB0002;
    static const Int64 x00000004 = 0x0000000400000004;       
    static const Int64 x00000005 = 0x0000000500000005;

    //For Long Filter
    static const Int64 m2226 = 0x0006000200020002;
    static const Int64 m2240 = 0x0000000400020002;
    static const Int64 m1221 = 0x0001000200020001;
    static const Int64 m6222 = 0x0002000200020006;
    static const Int64 m0422 = 0x0002000200040000;
    
    

       _asm {
            mov         esi,ppxlcCenter
            sub         esi,5
            mov         edi,iEdgeLength
MainLoop:
            
            //Determine Which Filter To Use Long or short    

#ifdef USE_SPEEDUP
            movzx       ebx,byte Ptr [esi+4]
            movzx       ecx,byte Ptr [esi+5]
            cmp         ebx,ecx
            jz          EndOfLoop
#endif
            movq        mm0,[esi]
            movq        mm1,[esi+1]

            movq        mm2,mm0
            psubusb     mm2,mm1
            psubusb     mm1,mm0
            por         mm2,mm1
            
            movq        mm3,x80
            movq        mm4,thr1
            pxor        mm2,mm3

            pcmpgtb     mm2,mm4
            pxor        mm4,mm4
            pandn       mm2,x01
            psadbw      mm2_mm4
            movq        mm1,mm2
            psrlq       mm2,32
            paddb       mm2,mm1
            movq        mm1,mm2
            psrld       mm2,16
            paddb       mm2,mm1

#ifndef USE_SPEEDUP
            movzx       eax,byte Ptr [esi+8]
            movzx       ebx,byte Ptr [esi+9]
            sub         eax,ebx
            cdq
            xor         eax,edx
            sub         eax,edx
            mov         ebx,eax
            sub         ebx,(THR1+1)
            sar         ebx,31
#endif

            movd        eax,mm2
            movzx       eax,al
#ifndef USE_SPEEDUP
            sub         eax,ebx
#endif
            cmp         eax,THR2
            jl          ShortFilter
  
            //Determine MIN & MAX values to see if filtering should be used
            
#ifndef USE_SPEEDUP
            movq        mm0, [esi+1]
			movq		mm1, mm0
            punpckldq   mm0, mm0
            punpckhdq   mm1, mm1
			movq		mm2, mm0

			pmaxub		mm0_mm1
			pminub		mm2_mm1

			movq		mm1, mm0
			movq		mm3, mm2

			psrld		mm1, 16
			psrld		mm3, 16

			pmaxub		mm0_mm1
			pminub		mm2_mm3

			movq		mm1, mm0
			movq		mm3, mm2

			psrlw		mm1, 8
			psrlw		mm3, 8

			pmaxub		mm0_mm1
			pminub		mm2_mm3

            psubb       mm0,mm2
            
            movd        eax,mm0
            movzx       eax,al //max-min
            mov         edx,iStepSize
            shl         edx,1

            cmp         eax,edx
            jge         EndOfLoop
#else
            movzx       eax,byte Ptr [esi]      //Can probobly skip these lines if the speedup is necessary
            movzx       edx,byte Ptr [esi+9]
            sub         eax,edx
            cdq
            xor         eax,edx
            sub         eax,edx
            mov         edx,iStepSize
            shl         edx,1
            cmp         eax,edx
            jg          EndOfLoop
#endif

  
            pxor        mm7,mm7
  
            movq        mm5,[esi+1]
            movq        mm3,mm5
            punpcklbw   mm3,mm7
            movq        mm4,mm3
            paddw       mm3,mm3

            movq        mm2,mm5
            psrlq       mm2,8
            paddw       mm3,mm4
            movq        mm6,mm5
            punpcklbw   mm2,mm7
            paddw       mm4,mm2
            paddw       mm3,mm2

            psrlq       mm6,16
            movq        mm2,mm6
            punpcklbw   mm6,mm7
            paddw       mm6,mm6
                      
            psrlq       mm2,8
            paddw       mm4,mm6
            punpcklbw   mm2,mm7
            paddw       mm4,mm2
            paddw       mm3,mm4
            paddw       mm4,mm2

            movq        mm0,m6222
            punpckhbw   mm5,mm7
            paddw       mm3,mm5
            paddw       mm5,mm5                           
            paddw       mm4,mm5                           
            paddw       mm4,mm5

            movd        mm1,[esi]
            punpcklbw   mm1,mm7
            movq        mm2,mm1
#ifndef USE_SPEEDUP
            movzx       eax,byte Ptr [esi]
            movzx       edx,byte Ptr [esi+1]
            sub         eax,edx
            cdq
            xor         eax,edx
            sub         eax,edx
            mov         edx,iStepSize
            cmp         eax,edx
            jl          UseV0
            movq        mm5,x000000000000FFFF
            psrlq       mm2,16
            pand        mm2,mm5
            pandn       mm5,mm1
            por         mm2,mm5
            movq        mm1,mm2
UseV0:
#endif
            movq        mm5,m0422
            pmullw      mm1,mm0
            paddw       mm3,mm1
            
            movq        mm0,m1221
            psllq       mm2,16
            movq        mm1,mm2
            pmullw      mm2,mm5
            paddw       mm3,mm2

            movq        mm5,m2226
            psllq       mm1,16
            movq        mm2,mm1
            pmullw      mm1,mm0
            paddw       mm3,mm1

            psllq       mm2,16
            paddw       mm3,mm2

            movd        mm1,[esi+6]                
            punpcklbw   mm1,mm7
            movq        mm2,mm1
#ifndef USE_SPEEDUP
            movzx       eax,byte Ptr [esi+8]
            movzx       edx,byte Ptr [esi+9]
            sub         eax,edx
            cdq
            xor         eax,edx
            sub         eax,edx
            mov         edx,iStepSize
            cmp         eax,edx
            jl          UseV9
            movq        mm0,xFFFF000000000000
            psllq       mm2,16
            pand        mm2,mm0
            pandn       mm0,mm1
            por         mm2,mm0
            movq        mm1,mm2
            movq        mm0,m1221
UseV9:
#endif
            pmullw      mm1,mm5
            paddw       mm4,mm1

            movq        mm5,m2240
            psrlq       mm2,16
            movq        mm1,mm2
            pmullw      mm2,mm5
            paddw       mm4,mm2

            psrlq       mm1,16
            movq        mm2,mm1
            pmullw      mm1,mm0
            paddw       mm4,mm1

            movq        mm0,x0008
            psrlq       mm2,16
            paddw       mm4,mm2

            paddw       mm3,mm0
            psrlw       mm3,4
            paddw       mm4,mm0
            psrlw       mm4,4
            packuswb    mm3,mm4
            movq        [esi+1],mm3

            jmp         EndOfLoop

ShortFilter:
#ifdef USE_SPEEDUP
            movd        mm0,ecx
            movzx       eax,[esi+3]
            movzx       edx,[esi+6]
            sub         ecx,ebx
            shl         ecx,3
            sub         eax,edx
            mov         edx,eax
            shl         eax,1
            add         eax,edx
            add         eax,ecx
            sar         eax,4
            movd        ecx,mm0
            movzx       eax,byte Ptr [g_deblockTab+eax]
            add         ebx,eax
            sub         ecx,eax
            test        ebx,0xFF00
            jnz         Clip2
            mov         [esi+4],bl
Clip2Ret:   test        ecx,0xFF00
            jnz         Clip1
            mov         [esi+5],cl
Clip1Ret:
#else
            pxor        mm7,mm7
            movzx       ecx,byte Ptr [esi+4]
            mov         eax,ecx
            movzx       ebx,byte Ptr [esi+5]

            movq        mm0,[esi+1]
            movq        mm5,s1
            movq        mm6,s2
            movq        mm1,mm0
            punpcklbw   mm1,mm7   
            pmaddwd     mm1,mm5
            movq        mm2,mm0
            psrlq       mm2,16
            punpcklbw   mm2,mm7   
            movq        mm3,mm2
            pmaddwd     mm2,mm6
            paddd       mm1,mm2
            paddd       mm1,x00000004
            psrad       mm1,3
            
            pxor        mm6,mm6
            pcmpgtb     mm6,mm1                    
            pxor        mm1,mm6
            psubd       mm1,mm6

            movq        mm4,mm1
            psrlq       mm1,32
            
            movd        edx,mm1
            cmp         edx,iStepSize
            jge         EndOfLoop

            sub         eax,ebx
            cdq
            xor         eax,edx
            sub         eax,edx

            shr         eax,1

            test        eax,eax
            jz          EndOfLoop

            movq        mm3,mm0
            punpckhbw   mm3,mm7
            pmaddwd     mm3,s3
            movq        mm2,mm3
            psrlq       mm2,32
            paddd       mm3,mm2
            paddd       mm3,x00000004
            psrad       mm3,3
            movq        mm2,mm1

            //From here on could be done 2 or 4 at a time
            //mm2=a30
            //mm3=a32
            //mm4=a31

            pxor        mm5,mm5
            pcmpgtd     mm5,mm3
            pxor        mm3,mm5
            psubd       mm3,mm5

            movq        mm5,mm2
            pcmpgtd     mm5,mm3
            pand        mm3,mm5
            pandn       mm5,mm2
            por         mm3,mm5

            movq        mm5,mm4
            pcmpgtd     mm5,mm3
            pand        mm3,mm5
            pandn       mm5,mm4
            por         mm3,mm5

            psubd       mm3,mm1

            pxor        mm4,mm4
            pcmpgtd     mm4,mm3
            pxor        mm3,mm4
            psubd       mm3,mm4

            pmaddwd     mm3,x00000005
            psrad       mm3,3        

            pxor        mm3,mm4
            psubd       mm3,mm4

            psrlq       mm6,32
            pxor        mm3,mm6
            psubd       mm3,mm6

            movd        mm5,edx

            pxor        mm3,mm5
            psubd       mm3,mm5

            movd        mm0,eax
            movq        mm1,mm0
            pcmpgtd     mm1,mm3
            pand        mm3,mm1
            pandn       mm1,mm0
            por         mm3,mm1
            
            pxor        mm1,mm1
            pcmpgtd     mm1,mm3
            pandn       mm1,mm3

            pxor        mm1,mm5
            psubd       mm1,mm5

            movd        eax,mm1

            sub         ecx,eax
            add         ebx,eax

            test        ecx,0x100
            jnz         Clip1
            mov         [esi+4],cl          
            
Clip1Ret:   test        ebx,0x100
            jnz         Clip2
            mov         [esi+5],bl
Clip2Ret:
#endif
EndOfLoop:                
             mov        eax,iPixelIncrement
             add        esi,eax
             
             dec        edi
             jnz        MainLoop

            }
return;
        _asm {
Clip1:      cmp         ecx,0
            jl          Clip1Down
            mov         [esi+4],0xFF
            jmp         Clip1Ret
Clip1Down:  mov         [esi+4],0
            jmp         Clip1Ret

Clip2:      cmp         ebx,0
            jl          Clip2Down
            mov         [esi+5],0xFF
            jmp         Clip2Ret
Clip2Down:  mov         [esi+5],0
            jmp         Clip2Ret
        }
}


Void_WMV FilterHorizantalEdge_KNI(U8_WMV* ppxlcCenter, I32_WMV iPixelDistance, 
                              I32_WMV iPixelIncrement, I32_WMV iEdgeLength, I32_WMV iStepSize)
{
 
    static const Int64 thr1 = THR1 | (THR1 << 8) | (THR1 << 16) | (THR1 << 24) | ((Int64)THR1 << 32) | ((Int64)THR1 << 40) | ((Int64)THR1 << 48) | ((Int64)THR1 << 56);
    static const Int64 thr2 = (THR2-1) | ((THR2-1) << 8) | ((THR2-1) << 16) | ((THR2-1) << 24) | ((Int64)(THR2-1) << 32) | ((Int64)(THR2-1) << 40) | ((Int64)(THR2-1) << 48) | ((Int64)(THR2-1) << 56);
    static const Int64 x01 = 0x0101010101010101;
    static const Int64 x80 = 0x8080808080808080;
    static const Int64 x06 = 0x0006000600060006;
    static const Int64 x08 = 0x0008000800080008;
    static const Int64 x05 = 0x0005000500050005;
    static const Int64 x04 = 0x0004000400040004;
    static const Int64 x0001 = 0x0001000100010001;
    static const Int64 x0002 = 0x0002000200020002;

    Int64 act;
    Int64 iStepBroad;
    Int64 i2StepBroad;
    Int64 lminmax, lminmax2;
    Int64 mask;
    I32_WMV i;
    I32_WMV mytemp;
    U8_WMV* pV0 = ppxlcCenter - (iPixelDistance*5);
   
    _asm {

        sub esp, 64  // IW
        movd        mm0,iStepSize       //Broadcast iStepSize
        punpcklbw   mm0,mm0
  		pshufw		mm0_mm0 emit(0)	// broadcast

        movq        mm5,mm0
        psllq       mm0,1
        psubb       mm5,x01 
        movq        iStepBroad,mm5
        movq        i2StepBroad,mm0
        
        mov         eax,iPixelDistance
        mov         esi,pV0
        lea         esi,[esi+eax*2]

        mov         ecx,iEdgeLength
        shr         ecx,3
HLoop:
        mov         i,ecx

        mov         eax,iPixelDistance
        mov         ebx,eax
        neg         ebx
        lea         edi,[esi+eax*4]
        add         edi,eax

        movq        mm7,thr1
        movq        mm6,x01

        //phi(v0 - v1)
        movq        mm0,[esi+ebx*2]     //Load
        movq        mm1,[esi+ebx]
        psubb       mm0,mm1             //Subtract
        pxor        mm2,mm2             //Absolute Value
        pcmpgtb     mm2,mm0
        pxor        mm0,mm2
        psubb       mm0,mm2
        pcmpgtb     mm0,mm7	            //if (mm0 <= THR1) mm0 = 1 else mm0 = 0
        pandn       mm0,mm6

        //phi(v1 - v2)
        movq        mm2,[esi]
        psubb       mm1,mm2     
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm1
        pxor        mm1,mm3
        pand        mm3,mm6
        paddb       mm1,mm3
        pcmpgtb     mm1,mm7	    
        pandn       mm1,mm6
        paddb       mm0,mm1             

        //phi(v2 - v3)
        movq        mm1,[esi+eax]
        psubb       mm2,mm1 
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm2
        pxor        mm2,mm3
        psubb       mm2,mm3
        pcmpgtb     mm2,mm7	    
        pandn       mm2,mm6
        paddb       mm0,mm2             

        //phi(v3 - v4)
        movq        mm2,[esi+eax*2]
        psubb       mm1,mm2     
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm1
        pxor        mm1,mm3
        psubb       mm1,mm3
        pcmpgtb     mm1,mm7	    
        pandn       mm1,mm6
        paddb       mm0,mm1             

        //phi(v4 - v5)
        movq        mm1,[edi+ebx*2]
        psubb       mm2,mm1     
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm2
        pxor        mm2,mm3
        psubb       mm2,mm3
        pcmpgtb     mm2,mm7	    
        pandn       mm2,mm6
        paddb       mm0,mm2             

        //phi(v5 - v6)
        movq        mm2,[edi+ebx]
        psubb       mm1,mm2     
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm1
        pxor        mm1,mm3
        psubb       mm1,mm3
        pcmpgtb     mm1,mm7	    
        pandn       mm1,mm6
        paddb       mm0,mm1             
        
        //phi(v6 - v7)
        movq        mm1,[edi]
        psubb       mm2,mm1     
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm2
        pxor        mm2,mm3
        psubb       mm2,mm3
        pcmpgtb     mm2,mm7	    
        pandn       mm2,mm6
        paddb       mm0,mm2             
        
        //phi(v7 - v8)
        movq        mm2,[edi+eax]
        psubb       mm1,mm2     
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm1
        pxor        mm1,mm3
        psubb       mm1,mm3
        pcmpgtb     mm1,mm7	    
        pandn       mm1,mm6
        paddb       mm0,mm1             
        
        //phi(v8 - v9)
        movq        mm1,[edi+eax*2]
        psubb       mm2,mm1     
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm2
        pxor        mm2,mm3
        psubb       mm2,mm3
        pcmpgtb     mm2,mm7	    
        pandn       mm2,mm6
        paddb       mm0,mm2             
        
        pcmpgtb     mm0,thr2

        movq        act,mm0

        movq        mm1,mm0
        movq        mm2,mm0
        psrlq       mm2,32
        psrlq       mm1,32
        pand        mm2,mm0
        por         mm1,mm0

        
        movq        mask,mm0

        movd        ebx,mm2     //check for 8 using DC offset mode (long filter)
        cmp         ebx,0xFFFFFFFF
        jz          DcOffsetMode2

        movd        eax,mm0     //check for all 8 using default mode (short filter)
        test        eax,eax
        jz          DefaultMode //Default Mode for all 8

        movd        ebx,mm0    //check for 4 using DC offset mode (long filter)
        cmp         ebx,0xFFFFFFFF
        jz          DcOffsetMode //DC Offset Mode for all 4

        mov         eax,iPixelDistance  //Setup pointers
        call        MinMaxMask_KNI
        movq        lminmax,mm6

        movd        mm7,mask           
        call        MixedMode4_KNI 

        add         esi,4

        movq        mm0,act
        psrlq       mm0,32
//        movd        eax,mm0

        movd        eax,mm0     //check for all 8 using default mode (short filter)
        test        eax,eax
        jz          DefaultModeA //Default Mode for all 8
        
        movq        mm6,lminmax
        psrlq       mm6,32
        movq        lminmax,mm6

        movd        ebx,mm0    //check for 4 using DC offset mode (long filter)
        cmp         ebx,0xFFFFFFFF
        jz          DcOffsetModeA //DC Offset Mode for all 8
            
MixedModeA:

        mov         eax,iPixelDistance
        movq        mm6,lminmax
        movq        mm7,mask           
        psrlq       mm7,32
        call        MixedMode4_KNI 
        
        add         esi,4
        mov         ecx,i
        dec         ecx
        jnz         HLoop
        jmp         end

DcOffsetMode:    
        mov         eax,iPixelDistance  //Setup pointers
        call        MinMaxMask_KNI

        mov         eax,iPixelDistance
        movq        lminmax,mm6
        call        DcOffsetMode4_KNI

        add         esi,4

        movq        mm6,lminmax
        psrlq       mm6,32
        movq        lminmax,mm6

        movq        mm0,act
        psrlq       mm0,32
//        movd        eax,mm0

        movd        eax,mm0     //check for all 8 using default mode (short filter)
        test        eax,eax
        jz          DefaultModeA //Default Mode for all 8
       
        movd        ebx,mm0    //check for 4 using DC offset mode (long filter)
        cmp         ebx,0xFFFFFFFF
        jnz         MixedModeA
            
DcOffsetModeA:    
        mov         eax,iPixelDistance
        movq        mm6,lminmax
        call        DcOffsetMode4_KNI
        
        
        add         esi,4
        mov         ecx,i
        dec         ecx
        jnz         HLoop
        jmp         end

DcOffsetMode2:    

        call        MinMaxMask_KNI
        movq        lminmax,mm6
  
            
        mov         eax,iPixelDistance
        call        DcOffsetMode4_KNI
        
        add         esi,4

        movq        mm6,lminmax
        psrlq       mm6,32
        movq        lminmax,mm6

        mov         eax,iPixelDistance
        movq        mm6,lminmax
        call        DcOffsetMode4_KNI
        

        add         esi,4
        mov         ecx,i
        dec         ecx
        jnz         HLoop
        jmp         end

DefaultMode:
        mov         eax,iPixelDistance
        call        DefaultMode4_KNI

        add         esi,4

        movq        mm0,act
        psrlq       mm0,32
//        movd        eax,mm0

        movd        eax,mm0     //check for all 8 using default mode (short filter)
        test        eax,eax
        jz          DefaultModeA //Default Mode for all 8
    
        movd        mytemp,mm0

        mov         eax,iPixelDistance  //Setup pointers
        call        MinMaxMask_KNI
        movq        lminmax,mm6


        mov         ebx,mytemp    //check for 4 using DC offset mode (long filter)
        cmp         ebx,0xFFFFFFFF
        jz          DcOffsetModeA //DC Offset Mode for all 8
        
        jmp         MixedModeA

DefaultModeA:

        mov         eax,iPixelDistance
        call        DefaultMode4_KNI

        add         esi,4
        mov         ecx,i
        dec         ecx
        jnz         HLoop

end:    emms
        add esp, 64  // IW
        }
    return;

    _asm{
DefaultMode4_KNI:
        mov         ebx,eax
        neg         ebx
        lea         edi,[esi+eax*4]
        add         edi,eax

        pxor        mm7,mm7
        movq        mm6,x05
        movq        mm5,x04

        //calculate a3.1
        movd        mm0,[esi+ebx]
        punpcklbw   mm0,mm7
        paddw       mm0,mm0
        movd        mm1,[esi]
        punpcklbw   mm1,mm7
        pmullw      mm1,mm6
        psubw       mm0,mm1
        movd        mm1,[esi+eax]
        punpcklbw   mm1,mm7
        movq        mm2,mm1
        pmullw      mm1,mm6
        paddw       mm0,mm1
        movd        mm1,[esi+eax*2]
        punpcklbw   mm1,mm7
        psubw       mm0,mm1
        psubw       mm0,mm1
        paddw       mm0,mm5
        psraw       mm0,3

        //Calculate a3.0
        paddw       mm2,mm2
        pmullw      mm1,mm6
        psubw       mm2,mm1
        movd        mm1,[edi+ebx*2]
        punpcklbw   mm1,mm7
        movq        mm3,mm1
        pmullw      mm1,mm6
        paddw       mm1,mm2
        movd        mm2,[edi+ebx]
        punpcklbw   mm2,mm7
        psubw       mm1,mm2
        psubw       mm1,mm2
        paddw       mm1,mm5
        psraw       mm1,3

        //Calculate a3.2
        paddw       mm3,mm3
        pmullw      mm2,mm6
        psubw       mm3,mm2
        movd        mm2,[edi]
        punpcklbw   mm2,mm7
        pmullw      mm2,mm6
        paddw       mm2,mm3
        movd        mm3,[edi+eax]
        punpcklbw   mm3,mm7
        psubw       mm2,mm3
        psubw       mm2,mm3
        paddw       mm2,mm5
        psraw       mm2,3

        //SIGN(a30)
        movq        mm5,mm1
        psraw       mm5,16
       
        //MIN(abs(a30),abs(a31),abs(a32))
        movq        mm3,mm0  //abs(a3.1)
        psraw       mm3,16
        pxor        mm0,mm3
        psubw       mm0,mm3

        movq        mm3,mm1  //abs(a3.0)
        movq        mm4,mm1
        psraw       mm3,16
        pxor        mm4,mm3
        psubw       mm4,mm3

        movq        mm3,mm2  //abs(a3,1)
        psraw       mm3,16
        pxor        mm2,mm3
        psubw       mm2,mm3

		pminsw		mm0_mm4	  //if (abs(a3.0) < abs(a3.1)) mm0 = abs(a3.0) else mm0 = abs(a3.1)
		pminsw		mm0_mm2

        pxor        mm0,mm5  //a3.0' = mm0 = (mm0 * SIGN(a3.0))
        psubw       mm0,mm5

        //Broadcast iStepSize
        movd        mm5, iStepSize
		pshufw		mm5_mm5 emit(0)	// broadcast

        // d = CLIP( (5*(A30-a30)/8),0,  ((v4-v5)/2)   *   ((abs(a30) < iStepSize) ? 1 : 0)   );
        movq        mm6,mm5     // generate mask for  * ((abs(a30) < iStepSize) ? 1 : 0)
        pcmpgtw     mm6,mm4

        psubw       mm0,mm1     //d_temp = 5*(A30-a30)/8
        pmullw      mm0,x05
        movq        mm5,mm0
        psraw       mm5,16
        pxor        mm0,mm5
        psubw       mm0,mm5
        psraw       mm0,3
        pxor        mm0,mm5
        psubw       mm0,mm5
        
        movd        mm3,[esi+eax*2]  //max = (v4-v5)/2
        punpcklbw   mm3,mm7
        movq        mm4,mm3
        movd        mm2,[edi+ebx*2]
        punpcklbw   mm2,mm7
        movq        mm7,mm2
        psubw       mm3,mm2
        pxor        mm3,mm5
        psubw       mm3,mm5
        psraw       mm3,1
        pxor        mm3,mm5
        psubw       mm3,mm5
        
        movq        mm5,mm3         //abs(max)     
        psraw       mm5,16
        pxor        mm3,mm5
        psubw       mm3,mm5
        pxor        mm0,mm5         //if (max < 0) d_temp = d_temp*-1;
        psubw       mm0,mm5

		pminsw		mm0_mm3         //Clip to less than max

        pxor        mm2,mm2         //Clip to zero
        pcmpgtw     mm2,mm0
        pandn       mm2,mm0

        pxor        mm2,mm5         //Restore original sign
        psubw       mm2,mm5

        pand        mm2,mm6         //mask out 

        psubw       mm4,mm2
        paddw       mm7,mm2

        packuswb    mm4,mm4
        movd        [esi+eax*2],mm4
        packuswb    mm7,mm7
        movd        [edi+ebx*2],mm7

        ret
   }

   _asm{        
MixedMode4_KNI:
        movq        [esp+40],mm7
        pand        mm6,mm7
        movq        lminmax2,mm6

        mov         ebx,eax
        neg         ebx
        lea         edi,[esi+eax*4]
        add         edi,eax

        movq        mm7,x80
        movd        mm0,[esi+ebx*2]           //calculate value that will be used as v0
        movd        mm1,[esi+ebx]
        movq        mm2,mm0
        movq        mm3,mm1
        psubusb     mm2,mm1
        psubusb     mm3,mm0
        por         mm2,mm3
        movq        mm5,iStepBroad
        pxor        mm2,mm7
        pxor        mm5,mm7
        pcmpgtb     mm2,mm5
        pand        mm1,mm2
        pandn       mm2,mm0
        por         mm1,mm2             //if (abs(v1-v0) < iStepSize) mm1 = v0 else mm1 = v1

        movq        mm0,mm1

        pxor        mm7,mm7

        movq        mm2,x06             //6*v0
        punpcklbw   mm0,mm7             
        movq        mm5,mm0
        movq        mm4,mm0
        psllw       mm5,2
        pmullw      mm0,mm2
                                        
        movd        mm2,[esi+ebx]       //v1
        punpcklbw   mm2,mm7
        movq        mm3,mm2
        paddw       mm5,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        movq        mm6,mm4
        psllw       mm2,2
        paddw       mm0,mm2

        movd        mm2,[esi]           //v2 
        punpcklbw   mm2,mm7
        paddw       mm4,mm2
        paddw       mm3,mm2
        paddw       mm2,mm2
        paddw       mm6,mm2
        paddw       mm0,mm2
        paddw       mm2,mm2
        paddw       mm5,mm2

        movd        mm2,[esi+eax]       //v3
        punpcklbw   mm2,mm7
        paddw       mm2,mm2
        paddw       mm0,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2


        movd        mm2,[esi+eax*2]     //v4
        punpcklbw   mm2,mm7
        paddw       mm0,mm2
        paddw       mm4,mm2
        paddw       mm2,mm2
        paddw       mm5,mm2
        paddw       mm6,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2

        movd        mm2,[edi+ebx*2]     //v5
        punpcklbw   mm2,mm7
        paddw       mm0,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        paddw       mm4,mm4
        paddw       mm2,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2
        paddw       mm3,mm2

        paddw       mm0,x08
        psrlw       mm0,4
        packuswb    mm0,mm0

        movq        mm7,lminmax2          //Output masked  v1
        movd        mm2,[esi+ebx]
        pand        mm0,mm7
        pandn       mm7,mm2
        por         mm0,mm7
        movd        [esp+4],mm0
        pxor        mm7,mm7


        movd        mm2,[edi+ebx]         //+ v6
        punpcklbw   mm2,mm7
        paddw       mm5,mm2
        paddw       mm4,mm2
        paddw       mm2,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2
        movq        mm0,mm2

        paddw       mm5,x08
        psrlw       mm5,4
        packuswb    mm5,mm5

        movq        mm7,lminmax2          //Output masked  v2
        movd        mm2,[esi]
        pand        mm5,mm7
        pandn       mm7,mm2
        por         mm5,mm7
        movd        [esp+8],mm5    
        pxor        mm7,mm7


        movd        mm2,[edi]           //+v7     
        punpcklbw   mm2,mm7
        paddw       mm4,mm2
        paddw       mm6,mm2
        paddw       mm2,mm2
        paddw       mm3,mm2

        movq        mm5,mm2

        paddw       mm4,x08
        psrlw       mm4,4
        packuswb    mm4,mm4
        
        movq        mm7,lminmax2          //Output masked  v3
        movd        mm2,[esi+eax]
        pand        mm4,mm7
        pandn       mm7,mm2
        por         mm4,mm7
        movd        [esp+12],mm4    
  
        movq        mm7,mm0
        paddw       mm0,mm5
        movq        mm4,mm0
        paddw       mm0,mm7
        paddw       mm5,mm5
        paddw       mm5,mm7
        pxor        mm7,mm7
    
        movd        mm2,[edi+eax]      //v8
        punpcklbw   mm2,mm7
        paddw       mm6,mm2
        paddw       mm3,mm2
        paddw       mm2,mm2
        paddw       mm0,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        paddw       mm4,mm2

        paddw       mm6,x08
        psrlw       mm6,4
        packuswb    mm6,mm6
        
        movq        mm7,lminmax2          //Output masked   v4
        movd        mm2,[esi+eax*2]
        pand        mm6,mm7
        pandn       mm7,mm2
        por         mm6,mm7
        movd        [esp+16],mm6    
        movq        mm6,mm0

        movq        mm7,mm3             //calculate value that will be used as v9
        movd        mm1,[edi+eax*2]           
        movd        mm0,[edi+eax]
        movq        mm2,mm0
        movq        mm3,mm1
        psubusb     mm2,mm1
        psubusb     mm3,mm0
        por         mm2,mm3
        movq        mm3,mm7
        movq        mm7,iStepBroad
        pxor        mm7,x80
        pxor        mm2,x80
        pcmpgtb     mm2,mm7
        pand        mm0,mm2
        pandn       mm2,mm1
        por         mm0,mm2             //if (abs(v8-v9) < iStepSize) mm0 = v9 else mm0 = v8
        movq        mm1,mm3
        pxor        mm7,mm7

        movq        mm3,mm0             //v9
        punpcklbw   mm3,mm7
        paddw       mm1,mm3
        paddw       mm3,mm3
        paddw       mm6,mm3
        movq        mm2,x08
        paddw       mm5,mm3
        paddw       mm5,mm3
        paddw       mm4,mm3
        paddw       mm4,mm3
        paddw       mm4,mm3

        paddw       mm1,mm2
        psrlw       mm1,4
        packuswb    mm1,mm1

        movq        mm3,lminmax2          //Output masked   v5
        movd        mm0,[edi+ebx*2]
        pand        mm1,mm3
        pandn       mm3,mm0
        por         mm1,mm3
        movd        [esp+20],mm1

        movd        mm1,[esi]           //v2
        punpcklbw   mm1,mm7
        paddw       mm6,mm1

        movd        mm1,[esi+eax]       //v3
        punpcklbw   mm1,mm7
        paddw       mm6,mm1
        paddw       mm5,mm1

        movd        mm1,[esi+eax*2]     //v4
        punpcklbw   mm1,mm7
        paddw       mm5,mm1
        paddw       mm4,mm1
        paddw       mm1,mm1
        paddw       mm6,mm1
        
        movd        mm1,[edi+ebx*2]     //v5
        punpcklbw   mm1,mm7
        paddw       mm4,mm1
        paddw       mm1,mm1
        paddw       mm6,mm1
        paddw       mm5,mm1
        
        paddw       mm6,mm2
        psrlw       mm6,4
        packuswb    mm6,mm6

        movq        mm3,lminmax2          //Output masked v6
        movd        mm1,[edi+ebx]
        pand        mm6,mm3
        pandn       mm3,mm1
        por         mm6,mm3
        movd        [esp+24],mm6

        paddw       mm5,mm2
        psrlw       mm5,4
        packuswb    mm5,mm5

        movq        mm3,lminmax2          //Output masked v7
        movd        mm0,[edi]
        pand        mm5,mm3
        pandn       mm3,mm0
        por         mm5,mm3
        movd        [esp+28],mm5

        paddw       mm4,mm2
        psrlw       mm4,4
        packuswb    mm4,mm4
        
        movq        mm3,lminmax2          //Output masked  v8
        movd        mm0,[edi+eax]
        pand        mm4,mm3
        pandn       mm3,mm0
        por         mm4,mm3
        
        movd        [esp+32],mm4   

        movq        mm6,x05
        movq        mm5,x04

        //calculate a3.1
        movd        mm0,[esi+ebx]
        punpcklbw   mm0,mm7
        paddw       mm0,mm0
        movd        mm1,[esi]
        punpcklbw   mm1,mm7
        pmullw      mm1,mm6
        psubw       mm0,mm1
        movd        mm1,[esi+eax]
        punpcklbw   mm1,mm7
        movq        mm2,mm1
        pmullw      mm1,mm6
        paddw       mm0,mm1
        movd        mm1,[esi+eax*2]
        punpcklbw   mm1,mm7
        psubw       mm0,mm1
        psubw       mm0,mm1
        paddw       mm0,mm5
        psraw       mm0,3

        //Calculate a3.0
        paddw       mm2,mm2
        pmullw      mm1,mm6
        psubw       mm2,mm1
        movd        mm1,[edi+ebx*2]
        punpcklbw   mm1,mm7
        movq        mm3,mm1
        pmullw      mm1,mm6
        paddw       mm1,mm2
        movd        mm2,[edi+ebx]
        punpcklbw   mm2,mm7
        psubw       mm1,mm2
        psubw       mm1,mm2
        paddw       mm1,mm5
        psraw       mm1,3

        //Calculate a3.2
        paddw       mm3,mm3
        pmullw      mm2,mm6
        psubw       mm3,mm2
        movd        mm2,[edi]
        punpcklbw   mm2,mm7
        pmullw      mm2,mm6
        paddw       mm2,mm3
        movd        mm3,[edi+eax]
        punpcklbw   mm3,mm7
        psubw       mm2,mm3
        psubw       mm2,mm3
        paddw       mm2,mm5
        psraw       mm2,3
        
        //SIGN(a30)
        movq        mm5,mm1
        psraw       mm5,16
       
        //MIN(abs(a30),abs(a31),abs(a32))
        movq        mm3,mm0  //abs(a3.1)
        psraw       mm3,16
        pxor        mm0,mm3
        psubw       mm0,mm3

        movq        mm3,mm1  //abs(a3.0)
        movq        mm4,mm1
        psraw       mm3,16
        pxor        mm4,mm3
        psubw       mm4,mm3

        movq        mm3,mm2  //abs(a3,1)
        psraw       mm3,16
        pxor        mm2,mm3
        psubw       mm2,mm3

		pminsw		mm0_mm4	  //if (abs(a3.0) < abs(a3.1)) mm0 = abs(a3.0) else mm0 = abs(a3.1)
		pminsw		mm0_mm2

        pxor        mm0,mm5  //a3.0' = mm0 = (mm0 * SIGN(a3.0))
        psubw       mm0,mm5

        //Broadcast iStepSize
        movd        mm5, iStepSize
		pshufw		mm5_mm5 emit(0)	// broadcast

        // d = CLIP( (5*(A30-a30)/8),0,  ((v4-v5)/2)   *   ((abs(a30) < iStepSize) ? 1 : 0)   );
        movq        mm6,mm5     // generate mask for  * ((abs(a30) < iStepSize) ? 1 : 0)
        pcmpgtw     mm6,mm4

        psubw       mm0,mm1     //d_temp = 5*(A30-a30)/8
        pmullw      mm0,x05
        movq        mm5,mm0
        psraw       mm5,16
        pxor        mm0,mm5
        psubw       mm0,mm5
        psraw       mm0,3
        pxor        mm0,mm5
        psubw       mm0,mm5
        
        movd        mm3,[esi+eax*2]  //max = (v4-v5)/2
        punpcklbw   mm3,mm7
        movq        mm4,mm3
        movd        mm2,[edi+ebx*2]
        punpcklbw   mm2,mm7
        movq        mm7,mm2
        psubw       mm3,mm2
        pxor        mm3,mm5
        psubw       mm3,mm5
        psraw       mm3,1
        pxor        mm3,mm5
        psubw       mm3,mm5
        
        movq        mm5,mm3         //abs(max)     
        psraw       mm5,16
        pxor        mm3,mm5
        psubw       mm3,mm5
        pxor        mm0,mm5         //if (max < 0) d_temp = d_temp*-1;
        psubw       mm0,mm5

        pminsw		mm0_mm3         //Clip to less than max
        
        pxor        mm2,mm2         //Clip to zero
        pcmpgtw     mm2,mm0
        pandn       mm2,mm0

        pxor        mm2,mm5         //Restore original sign
        psubw       mm2,mm5

        pand        mm2,mm6         //mask out 

        psubw       mm4,mm2
        paddw       mm7,mm2

        movd        mm2,[esp+40]
        movq        mm3,mm2

        packuswb    mm4,mm4
        pandn       mm2,mm4
        
        packuswb    mm7,mm7
        pandn       mm3,mm7
        
        movd        mm0,[esp+4]           
        movd        [esi+ebx],mm0           //v1

        movd        mm0,[esp+8]
        movd        [esi],mm0               //v2

        movd        mm0,[esp+12]
        movd        [esi+eax],mm0           //v3

        movd        mm0,[esp+16]
        movd        mm1,[esp+40]
        pand        mm1,mm0
        por         mm1,mm2
        movd        [esi+eax*2],mm1         //v4

        movd        mm0,[esp+20]
        movd        mm1,[esp+40]
        pand        mm1,mm0
        por         mm1,mm3
        movd        [edi+ebx*2],mm1         //v5

        movd        mm0,[esp+24]           
        movd        [edi+ebx],mm0           //v6

        movd        mm0,[esp+28]           
        movd        [edi],mm0               //v7
        
        movd        mm0,[esp+32]           
        movd        [edi+eax],mm0           //v8

        ret
    }

    _asm{        
MinMaxMask_KNI:
        mov         ebx,eax
        neg         ebx
        lea         edi,[esi+eax*4]
        add         edi,eax
        movq        mm7,x80

        movq        mm0,[esi+ebx]       //Load first line
        movq        mm1,[esi]           //Load second line
		movq		mm2, mm0			
		pminub		mm0_mm1
		pmaxub		mm1_mm2
				
        movq        mm2,[esi+eax]       //Load third line
        movq        mm3,[esi+eax*2]     //Load forth line
		
		pminub		mm0_mm2
		pmaxub		mm1_mm2

		pminub		mm0_mm3
		pmaxub		mm1_mm3


        movq        mm2,[edi+ebx*2]     //Load fifth line
        movq        mm3,[edi+ebx]       //Load sixth line

		pminub		mm0_mm2
		pmaxub		mm1_mm2

		pminub		mm0_mm3
		pmaxub		mm1_mm3

        movq        mm2,[edi]           //Load 7'th line
        movq        mm3,[edi+eax]       //Load 8'th line
		
		pminub		mm0_mm2
		pmaxub		mm1_mm2

		pminub		mm0_mm3
		pmaxub		mm1_mm3

        psubb       mm1,mm0

        movq        mm0,i2StepBroad

        pxor        mm0,mm7
        pxor        mm1,mm7
        pcmpgtb     mm0,mm1             // (max-min) < 2*iStepSize

        movq        mm6,mm0
        ret
        }

    _asm {
DcOffsetMode4_KNI: //(/*esi=pV0,eax=iPixelDistance,mm6=minmax*/) -- really the same as DcOffsetMode4
        movq        lminmax2,mm6
        
        mov         ebx,eax
        neg         ebx
        lea         edi,[esi+eax*4]
        add         edi,eax
        
        movq        mm7,x80
        movd        mm1,[esi+ebx*2]           //calculate value that will be used as v0
        movd        mm0,[esi+ebx]
        movq        mm2,mm1
        movq        mm3,mm0
        psubusb     mm2,mm0
        psubusb     mm3,mm1
        por         mm2,mm3
        movq        mm5,iStepBroad
        pxor        mm2,mm7
        pxor        mm5,mm7
        pcmpgtb     mm2,mm5
        pand        mm0,mm2
        pandn       mm2,mm1
        por         mm0,mm2             //if (abs(v1-v0) < iStepSize) mm0 = v0 else mm0 = v1
        
        pxor        mm7,mm7
        
        movq        mm2,x06             //6*v0
        punpcklbw   mm0,mm7             
        movq        mm5,mm0
        movq        mm4,mm0
        psllw       mm5,2
        pmullw      mm0,mm2
        
        movd        mm2,[esi+ebx]       //v1
        punpcklbw   mm2,mm7
        movq        mm3,mm2
        paddw       mm5,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        movq        mm6,mm4
        psllw       mm2,2
        paddw       mm0,mm2
        
        movd        mm2,[esi]           //v2 
        punpcklbw   mm2,mm7
        paddw       mm4,mm2
        paddw       mm3,mm2
        paddw       mm2,mm2
        paddw       mm6,mm2
        paddw       mm0,mm2
        paddw       mm2,mm2
        paddw       mm5,mm2
        
        movd        mm2,[esi+eax]       //v3
        punpcklbw   mm2,mm7
        paddw       mm2,mm2
        paddw       mm0,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2
        
        movd        mm2,[esi+eax*2]     //v4
        punpcklbw   mm2,mm7
        paddw       mm0,mm2
        paddw       mm4,mm2
        paddw       mm2,mm2
        paddw       mm5,mm2
        paddw       mm6,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2
        
        movd        mm2,[edi+ebx*2]     //v5
        punpcklbw   mm2,mm7
        paddw       mm0,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        movq        mm1,x08
        paddw       mm4,mm4
        paddw       mm2,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2
        paddw       mm3,mm2
        
        paddw       mm0,mm1
        psrlw       mm0,4
        
        packuswb    mm0,mm0
        
        movq        mm7,lminmax2          //Output masked  v1
        movd        mm2,[esi+ebx]
        pand        mm0,mm7
        pandn       mm7,mm2
        por         mm0,mm7
        movd        [esi+ebx],mm0    
        pxor        mm7,mm7
        
        movd        mm2,[edi+ebx]       //+ v6
        punpcklbw   mm2,mm7
        paddw       mm5,mm2
        paddw       mm4,mm2
        paddw       mm2,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2
        movq        mm0,mm2
        
        paddw       mm5,mm1
        psrlw       mm5,4
        
        packuswb    mm5,mm5
        
        movq        mm7,lminmax2          //Output masked  v2
        movd        mm2,[esi]
        pand        mm5,mm7
        pandn       mm7,mm2
        por         mm5,mm7
        movd        [esp+8],mm5    
        pxor        mm7,mm7
        
        movd        mm2,[edi]           //+v7     
        punpcklbw   mm2,mm7
        paddw       mm4,mm2
        paddw       mm6,mm2
        paddw       mm2,mm2
        paddw       mm3,mm2
        
        movq        mm5,mm2
        
        paddw       mm4,mm1
        psrlw       mm4,4
        
        packuswb    mm4,mm4
        
        movq        mm7,lminmax2          //Output masked  v3
        movd        mm2,[esi+eax]
        pand        mm4,mm7
        pandn       mm7,mm2
        por         mm4,mm7
        movd        [esp+12],mm4    
        
        movq        mm7,mm0
        paddw       mm0,mm5
        movq        mm4,mm0
        paddw       mm0,mm7
        paddw       mm5,mm5
        paddw       mm5,mm7
        pxor        mm7,mm7
        
        movd        mm2,[edi+eax]       //v8
        punpcklbw   mm2,mm7
        paddw       mm6,mm2
        paddw       mm3,mm2
        paddw       mm2,mm2
        movq        mm7,x08
        paddw       mm0,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        paddw       mm4,mm2
        
        paddw       mm6,mm7
        psrlw       mm6,4
        
        packuswb    mm6,mm6
        
        movq        mm7,lminmax2          //Output masked   v4
        movd        mm2,[esi+eax*2]
        pand        mm6,mm7
        pandn       mm7,mm2
        por         mm6,mm7
        movd        [esp+16],mm6    
        movq        mm6,mm0
        
        movq        mm7,mm3                   //calculate value that will be used as v9
        movd        mm1,[edi+eax*2]           
        movd        mm0,[edi+eax]
        movq        mm2,mm0
        movq        mm3,mm1
        psubusb     mm2,mm1
        psubusb     mm3,mm0
        por         mm2,mm3
        movq        mm3,mm7
        movq        mm7,iStepBroad
        pxor        mm7,x80
        pxor        mm2,x80
        pcmpgtb     mm2,mm7
        pand        mm0,mm2
        pandn       mm2,mm1
        por         mm0,mm2             //if (abs(v8-v9) < iStepSize) mm0 = v9 else mm0 = v8
        movq        mm1,mm3
        pxor        mm7,mm7
        
        movq        mm3,mm0             //v9
        punpcklbw   mm3,mm7
        paddw       mm1,mm3
        paddw       mm3,mm3
        paddw       mm6,mm3
        paddw       mm5,mm3
        paddw       mm5,mm3
        paddw       mm4,mm3
        paddw       mm4,mm3
        paddw       mm4,mm3
        
        
        movd        mm0,[esi]           //v2
        punpcklbw   mm0,mm7
        paddw       mm6,mm0
        movd        mm0,[esp+8]
        movd        [esi],mm0    
        
        movd        mm0,[esi+eax]       //v3
        punpcklbw   mm0,mm7
        paddw       mm6,mm0
        paddw       mm5,mm0
        movd        mm0,[esp+12]
        movd        [esi+eax],mm0    
        
        movd        mm0,[esi+eax*2]     //v4
        punpcklbw   mm0,mm7
        paddw       mm5,mm0
        paddw       mm4,mm0
        paddw       mm0,mm0
        paddw       mm6,mm0
        movd        mm0,[esp+16]
        movd        [esi+eax*2],mm0    
        
        movd        mm0,[edi+ebx*2]     //v5
        punpcklbw   mm0,mm7
        paddw       mm4,mm0
        paddw       mm0,mm0
        movq        mm2,x08
        paddw       mm6,mm0
        paddw       mm5,mm0
        
        paddw       mm1,mm2
        psrlw       mm1,4
        
        packuswb    mm1,mm1
        
        movq        mm7,lminmax2          //Output masked v5
        movq        mm3,mm7
        movd        mm0,[edi+ebx*2]
        pand        mm1,mm3
        pandn       mm3,mm0
        por         mm1,mm3
        movd        [edi+ebx*2],mm1
        
        paddw       mm6,mm2
        psrlw       mm6,4
        
        packuswb    mm6,mm6
        
        movq        mm3,mm7             //Output masked v6
        movd        mm1,[edi+ebx]
        pand        mm6,mm3
        pandn       mm3,mm1
        por         mm6,mm3
        movd        [edi+ebx],mm6    
        
        paddw       mm5,mm2
        psrlw       mm5,4
        
        packuswb    mm5,mm5
        
        movq        mm3,mm7             //Output masked v7
        movd        mm1,[edi]
        pand        mm5,mm3
        pandn       mm3,mm1
        por         mm5,mm3
        movd        [edi],mm5    
        
        paddw       mm4,mm2
        psrlw       mm4,4
        
        packuswb    mm4,mm4
        
        movd        mm1,[edi+eax]        //Output masked v8
        pand        mm4,mm7
        pandn       mm7,mm1
        por         mm4,mm7
        movd        [edi+eax],mm4   
        
        ret
    }                           

} 
#pragma optimize ("",on)
#pragma warning (default:4799)
#endif // _WMV_TARGET_X86_

#if defined(_WMV_TARGET_X86_) || defined(_Embedded_x86)
Void_WMV DeblockMB_MMX (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV        *ppxliY,
    U8_WMV        *ppxliU,
    U8_WMV        *ppxliV,
    Bool_WMV                  bDoLeft,
    Bool_WMV                  bDoRightHalfEdge,
    Bool_WMV                  bDoTop,
    Bool_WMV                  bDoBottomHalfEdge,
    Bool_WMV                  bDoMiddle,
    I32_WMV                   iStepSize,
    I32_WMV                   iWidthPrevY,
    I32_WMV                   iWidthPrevUV
)
{

    if (bDoTop) {
        // Filter the top Y, U and V edges.
        FilterHorizantalEdge(ppxliY,iWidthPrevY,1,MB_SIZE,iStepSize);
        FilterHorizantalEdge(ppxliU,iWidthPrevUV,1,BLOCK_SIZE,iStepSize);
        FilterHorizantalEdge(ppxliV,iWidthPrevUV,1,BLOCK_SIZE,iStepSize);
    }

    if (bDoBottomHalfEdge) {
        // Filter the bottom Y, U and V edges.
        FilterHalfHorizantalEdge(ppxliY + (iWidthPrevY * MB_SIZE),iWidthPrevY,1,MB_SIZE,iStepSize);
        FilterHalfHorizantalEdge(ppxliU + (iWidthPrevUV * BLOCK_SIZE),iWidthPrevUV,1,BLOCK_SIZE,iStepSize);
        FilterHalfHorizantalEdge(ppxliV + (iWidthPrevUV * BLOCK_SIZE),iWidthPrevUV,1,BLOCK_SIZE,iStepSize);
    } 

    if (bDoMiddle) {
        // Filter the middle horizontal Y edge
        FilterHorizantalEdge(ppxliY+ iWidthPrevY * 8,iWidthPrevY,1,MB_SIZE,iStepSize);

        // Filter the middle vertical Y edge
        FilterVerticalEdge(ppxliY + 8,1,iWidthPrevY,MB_SIZE,iStepSize);     
    }

    if (bDoLeft) {
        // Filter the left vertical Y, U and V edges.
        FilterVerticalEdge(ppxliY,1,iWidthPrevY,MB_SIZE,iStepSize);
        FilterVerticalEdge(ppxliU,1,iWidthPrevUV,BLOCK_SIZE,iStepSize);
        FilterVerticalEdge(ppxliV,1,iWidthPrevUV,BLOCK_SIZE,iStepSize);
    }

    if (bDoRightHalfEdge) {
        // Filter the right vertical Y, U and V edges.
        FilterHalfVerticalEdge(ppxliY + MB_SIZE,1,iWidthPrevY,MB_SIZE,iStepSize);
        FilterHalfVerticalEdge(ppxliU + BLOCK_SIZE,1,iWidthPrevUV,BLOCK_SIZE,iStepSize);
        FilterHalfVerticalEdge(ppxliV + BLOCK_SIZE,1,iWidthPrevUV,BLOCK_SIZE,iStepSize);
    } 
}

Void_WMV DeblockMB_FASTEST_MMX (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV        *ppxliY,
    U8_WMV        *ppxliU,
    U8_WMV        *ppxliV,
    Bool_WMV                  bDoLeft,
    Bool_WMV                  bDoRightHalfEdge,
    Bool_WMV                  bDoTop,
    Bool_WMV                  bDoBottomHalfEdge,
    Bool_WMV                  bDoMiddle,
    I32_WMV                   iStepSize,
    I32_WMV                   iWidthPrevY,
    I32_WMV                   iWidthPrevUV
)
{

    if (bDoTop) {
        // Filter the top Y, U and V edges.
        FilterHorizantalEdge(ppxliY,iWidthPrevY,1,MB_SIZE,iStepSize);
        FilterHorizantalEdge(ppxliU,iWidthPrevUV,1,BLOCK_SIZE,iStepSize);
        FilterHorizantalEdge(ppxliV,iWidthPrevUV,1,BLOCK_SIZE,iStepSize);
    }

    if (bDoBottomHalfEdge) {
        // Filter the bottom Y, U and V edges.
        FilterHalfHorizantalEdge(ppxliY + (iWidthPrevY * MB_SIZE),iWidthPrevY,1,MB_SIZE,iStepSize);
        FilterHalfHorizantalEdge(ppxliU + (iWidthPrevUV * BLOCK_SIZE),iWidthPrevUV,1,BLOCK_SIZE,iStepSize);
        FilterHalfHorizantalEdge(ppxliV + (iWidthPrevUV * BLOCK_SIZE),iWidthPrevUV,1,BLOCK_SIZE,iStepSize);
    } 

    if (bDoMiddle) {
        // Filter the middle horizontal Y edge
        FilterHorizantalEdge(ppxliY+ iWidthPrevY * 8,iWidthPrevY,1,MB_SIZE,iStepSize);

        // Filter the middle vertical Y edge
        FilterVerticalEdge_FASTEST(ppxliY + 8,1,iWidthPrevY,MB_SIZE,iStepSize);     
    }

    if (bDoLeft) {
        // Filter the left vertical Y, U and V edges.
        FilterVerticalEdge_FASTEST(ppxliY,1,iWidthPrevY,MB_SIZE,iStepSize);
        FilterVerticalEdge_FASTEST(ppxliU,1,iWidthPrevUV,BLOCK_SIZE,iStepSize);
        FilterVerticalEdge_FASTEST(ppxliV,1,iWidthPrevUV,BLOCK_SIZE,iStepSize);
    }

    if (bDoRightHalfEdge) {
        // Filter the right vertical Y, U and V edges.
        FilterHalfVerticalEdge_FASTEST(ppxliY + MB_SIZE,1,iWidthPrevY,MB_SIZE,iStepSize);
        FilterHalfVerticalEdge_FASTEST(ppxliU + BLOCK_SIZE,1,iWidthPrevUV,BLOCK_SIZE,iStepSize);
        FilterHalfVerticalEdge_FASTEST(ppxliV + BLOCK_SIZE,1,iWidthPrevUV,BLOCK_SIZE,iStepSize);
    } 
}
#endif

#ifdef _WMV_TARGET_X86_

Void_WMV DeblockMB_KNI (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV        *ppxliY,
    U8_WMV        *ppxliU,
    U8_WMV        *ppxliV,
    Bool_WMV                  bDoLeft,
    Bool_WMV                  bDoRightHalfEdge,
    Bool_WMV                  bDoTop,
    Bool_WMV                  bDoBottomHalfEdge,
    Bool_WMV                  bDoMiddle,
    I32_WMV                   iStepSize,
    I32_WMV                   iWidthPrevY,
    I32_WMV                   iWidthPrevUV
)
{
    if (bDoTop) {
        // Filter the top Y, U and V edges.
        FilterHorizantalEdge_KNI(ppxliY,iWidthPrevY,1,MB_SIZE,iStepSize);
        FilterHorizantalEdge_KNI(ppxliU,iWidthPrevUV,1,BLOCK_SIZE,iStepSize);
        FilterHorizantalEdge_KNI(ppxliV,iWidthPrevUV,1,BLOCK_SIZE,iStepSize);
    }

    if (bDoBottomHalfEdge) {
        // Filter the bottom Y, U and V edges.
        FilterHalfHorizantalEdge(ppxliY + (iWidthPrevY * MB_SIZE),iWidthPrevY,1,MB_SIZE,iStepSize);
        FilterHalfHorizantalEdge(ppxliU + (iWidthPrevUV * BLOCK_SIZE),iWidthPrevUV,1,BLOCK_SIZE,iStepSize);
        FilterHalfHorizantalEdge(ppxliV + (iWidthPrevUV * BLOCK_SIZE),iWidthPrevUV,1,BLOCK_SIZE,iStepSize);
    } 

    if (bDoMiddle) {
        // Filter the middle horizontal Y edge
        FilterHorizantalEdge_KNI(ppxliY+ iWidthPrevY * 8,iWidthPrevY,1,MB_SIZE,iStepSize);

        // Filter the middle vertical Y edge
        FilterVerticalEdge_KNI(ppxliY + 8,1,iWidthPrevY,MB_SIZE,iStepSize);     
    }

    if (bDoLeft) {
        // Filter the left vertical Y, U and V edges.
        FilterVerticalEdge_KNI(ppxliY,1,iWidthPrevY,MB_SIZE,iStepSize);
        FilterVerticalEdge_KNI(ppxliU,1,iWidthPrevUV,BLOCK_SIZE,iStepSize);
        FilterVerticalEdge_KNI(ppxliV,1,iWidthPrevUV,BLOCK_SIZE,iStepSize);
    }

    if (bDoRightHalfEdge) {
        // Filter the right vertical Y, U and V edges.
        FilterHalfVerticalEdge(ppxliY + MB_SIZE,1,iWidthPrevY,MB_SIZE,iStepSize);
        FilterHalfVerticalEdge(ppxliU + BLOCK_SIZE,1,iWidthPrevUV,BLOCK_SIZE,iStepSize);
        FilterHalfVerticalEdge(ppxliV + BLOCK_SIZE,1,iWidthPrevUV,BLOCK_SIZE,iStepSize);
    } 
}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\spatialpredictor_wmv.cpp ===
//#define VERBOSE    // VERBOSE doesn't work with multiproc!!
/***********************************************************************************/

#include "bldsetup.h"

#include <stdlib.h>
#include <math.h>
#ifndef __arm
#   include <memory.h>
#else
#   include <memory>
#endif
#include "xplatform.h"
#include "typedef.hpp"
#include "wmvdec_api.h"
#include "spatialpredictor_wmv.hpp"
#ifdef _WMV_TARGET_X86_
#include "cpudetect.h"
#endif // _WMV_TARGET_X86_

/****************************************************************************************
  Array declarations
****************************************************************************************/

//  Bidirectional prediction weights
U16_WMV aNullPredWts_WMV[] = {
    640, 640, 669, 480, 708, 354, 748, 257, 792, 198, 760, 143, 808, 101, 772,  72,
    480, 669, 537, 537, 598, 416, 661, 316, 719, 250, 707, 185, 768, 134, 745,  97,
    354, 708, 416, 598, 488, 488, 564, 388, 634, 317, 642, 241, 716, 179, 706, 132,
    257, 748, 316, 661, 388, 564, 469, 469, 543, 395, 571, 311, 655, 238, 660, 180,
    198, 792, 250, 719, 317, 634, 395, 543, 469, 469, 507, 380, 597, 299, 616, 231,
    161, 855, 206, 788, 266, 710, 340, 623, 411, 548, 455, 455, 548, 366, 576, 288,
    122, 972, 159, 914, 211, 842, 276, 758, 341, 682, 389, 584, 483, 483, 520, 390,
    110, 1172, 144, 1107, 193, 1028, 254, 932, 317, 846, 366, 731, 458, 611, 499, 499
};

/****************************************************************************************
  Constructor for CSpatialPredictor
****************************************************************************************/
#ifndef _XBOX
Bool_WMV t_SpatialPredictor::m_bIsMMX = FALSE_WMV;
#endif

t_SpatialPredictor *t_SpatialPredictorConstruct ()
{
    t_SpatialPredictor  *pSp = (t_SpatialPredictor *) wmvalloc (sizeof(t_SpatialPredictor));
    if (!pSp)
        goto ERROR_EXIT;

    pSp->m_pNeighbors = (U8_WMV *) (wmvalloc (16 * 4)); // align to 4 byte (U32_WMV) and cast
    if (!pSp->m_pNeighbors)
        goto ERROR_EXIT;

    pSp->m_pBuffer16 = (I16_WMV *) wmvalloc (24 * 2);
    if (!pSp->m_pBuffer16)
        goto ERROR_EXIT;

    // tune accesses
    pSp->m_pLeft = pSp->m_pNeighbors + 31;
    pSp->m_pTop = pSp->m_pNeighbors + 32;

    // Set up sum arrays
    pSp->m_pTopSum = (pSp->m_pSums = (U16_WMV *) wmvalloc (32 * 4)) + 4;  // extra space for MMX setupZero
    if (!pSp->m_pSums)
        goto ERROR_EXIT;
    pSp->m_pLeftSum = pSp->m_pTopSum + 12;

    DEBUG_HEAP_ADD(3, sizeof(t_SpatialPredictor) + (16 * 4) + (24 * 2) + (32 * 4));

#ifdef _WMV_TARGET_X86_
#ifndef _XBOX
    if (g_SupportMMX()) {
        pSp->m_bIsMMX = TRUE;  // this variable is used for IDCT mode only
//        m_pDeblock = (g_SupportCMOV()) ? deblock_MMX : deblock_MMX_noCMOV;
    }
#endif // _XBOX
#endif // _WMV_TARGET_X86_

    return pSp;

ERROR_EXIT:
    t_SpatialPredictorDestruct (pSp);
    return NULL_WMV;
}

/****************************************************************************************
  Destructor for CSpatialPredictor
****************************************************************************************/
Void_WMV t_SpatialPredictorDestruct (t_SpatialPredictor *pSp)
{
    if ( pSp != NULL ) {
        if ( pSp->m_pSums != NULL )
            wmvfree (pSp->m_pSums);
        if ( pSp->m_pBuffer16 != NULL )
            wmvfree (pSp->m_pBuffer16);
        if ( pSp->m_pNeighbors != NULL )
            wmvfree (pSp->m_pNeighbors);
        wmvfree (pSp);
    }
    DEBUG_HEAP_SUB(3, sizeof(t_SpatialPredictor) + (16 * 4) + (24 * 2) + (32 * 4));
}

/****************************************************************************************
  Set up neighbors
****************************************************************************************/
/** old code
Void_WMV CSpatialPredictor::setupZeroPredictor_C_fast (Void_WMV)
{
    I16_WMV      *pTop  = m_pBuffer16 + 12;
    I16_WMV      *pLeft = m_pBuffer16;
    U16_WMV     *pTsum = m_pTopSum;
    U16_WMV     *pLsum = m_pLeftSum;

    I64  S1[5], S3[5], *pS1, *pS3;
    pS1 = S1;
    *pS1 = 0;
    pS3 = S3;

    for (I8_WMV i = 0; i < 12; i++) {
        pTop[i]  = I16_WMV  (m_pTop[i]);
        pLeft[i] = I16_WMV  (m_pLeft[-i - 1]);
    }
    // facilitate (increment sl only for k < 8)
    pLeft[8] = pLeft[9] = pLeft[10] = pLeft[11] = 0;

    I32_WMV     *pTop32 = (I32_WMV *) pTop;
    I32_WMV     *pLeft32 = (I32_WMV *) pLeft;
    I32_WMV     *pS3_32 = (I32_WMV *) pS3;
    I32_WMV     *pS1_32 = (I32_WMV *) pS1;

    {
        I32_WMV     iMM1t, iMM1l, iMM7t, iMM7l, iMM5t, iMM5l;
        I32_WMV     iMM2t, iMM2l, iMM6t, iMM6l, iMM4t, iMM4l;

        iMM1t = (pTop32[0] << 4);  iMM1l = (pLeft32[0] << 4);
        iMM7t = iMM1t;
        iMM7l = iMM1l;
        pS1_32[2] = iMM1l;  pS1_32[3] = iMM1t;

        iMM1t >>= 1;  iMM1l >>= 1;
        iMM6t = (pTop32[1] << 4);  iMM6l = (pLeft32[1] << 4);
        pS1_32[4] = iMM1l += iMM6l;  pS1_32[5] = iMM1t += iMM6t;

        iMM1t >>= 1;  iMM1l >>= 1;
        iMM5t = (pTop32[2] << 4);  iMM5l = (pLeft32[2] << 4);
        pS1_32[6] = iMM1l += iMM5l;  pS1_32[7] = iMM1t += iMM5t;

        iMM1t >>= 1;  iMM1l >>= 1;
        iMM2t = iMM4t = (pTop32[3] << 4);  iMM2l = iMM4l = (pLeft32[3] << 4);
        pS1_32[8] = iMM1l += iMM4l;  pS1_32[9] = iMM1t += iMM4t;

        iMM2t >>= 1;  iMM2l >>= 1;
        pS3_32[4] = iMM5l += iMM2l;  pS3_32[5] = iMM5t += iMM2t;

        iMM5t >>= 1;  iMM5l >>= 1;
        pS3_32[2] = iMM6l += iMM5l;  pS3_32[3] = iMM6t += iMM5t;

        iMM6t >>= 1;  iMM6l >>= 1;
        pS3_32[0] = iMM7l += iMM6l;  pS3_32[1] = iMM7t += iMM6t;

        iMM1t = (pTop32[4] << 3);
        pS3_32[6] = iMM4l;  pS3_32[7] = iMM4t += iMM1t;
        iMM1t += iMM1t;

        iMM4t = (pTop32[5] << 3);
        pS3_32[8] = 0;  pS3_32[9] = iMM1t += iMM4t;
    }

    for (I32_WMV iB = 0; iB < 10; iB += 2) {
        I16_WMV   *pS3l = (I16_WMV  *)(pS3_32 + iB);
        I16_WMV   *pS3t = pS3l + 2;

        I16_WMV   *pS1l = (I16_WMV  *)(pS1_32 + iB);
        I16_WMV   *pS1t = pS1l + 2;

        pLsum[iB - 1] = pS1l[1] + (pS3l[1] >> 1) + (((pS1l[0] + pS3l[0]) * 181 + 128) >> 8);
        pLsum[iB] = pS3l[0] + (pS1l[0] >> 1) + (((pS1l[1] + pS3l[1]) * 181 + 128) >> 8);

        pTsum[iB - 1]  = pS1t[1] + (pS3t[1] >> 1) + (((pS1t[0] + pS3t[0]) * 181 + 128) >> 8);
        pTsum[iB]  = pS3t[0] + (pS1t[0] >> 1) + (((pS1t[1] + pS3t[1]) * 181 + 128) >> 8);

    }
}
**/


/****************************************************************************************
  Spatial prediction function for decoder
****************************************************************************************/
Bool_WMV bMin_Max_LE_2QP (I32_WMV a,I32_WMV b,I32_WMV c,I32_WMV d,I32_WMV e,I32_WMV f,I32_WMV g,I32_WMV h, I32_WMV i2Qp)
{
    I32_WMV min, max;
    if (a >= h){ 
        min = h; max = a;
    }
    else{
        min = a; max = h;
    }
    if (min > c) min  = c;
    else if (c > max) max = c;
    if (min > e) min  = e;
    else if (e > max) max = e;

////////////// Run Experiement to see if it benefit.
    if (max - min >= i2Qp) return FALSE_WMV;

    if (min > b) min  = b;
    else if (b > max) max = b;
    if (min > d) min  = d;
    else if (d > max) max = d;
    if (min > f) min  = f;
    else if (f > max) max = f;
    if (min > g) min  = g;
    else if (g > max) max = g;

    return (Bool_WMV) (max - min < i2Qp);
}


#if !defined( OPT_X8_ARM )&& !defined(_MIPS_ASM_X8_OPT_)

#define phi1(a) ((U32_WMV)(a+iThr1) <= uThr2)

static Void_WMV FilterHorzEdgeX8 (PixelC* ppxlcCenter, I32_WMV iPixelDistance, I32_WMV iStepSize)
{
    const I32_WMV iThr1 = ((iStepSize + 10) >> 3);
    const U32_WMV uThr2 = iThr1<<1;
    
    for (I32_WMV i = 0; i < 8; ++i) {
        I32_WMV  v1, v2, v3, v4, v5, v6, v7, v8;
        PixelC* pVtmpR = ppxlcCenter;
        PixelC* pVtmpL = ppxlcCenter - iPixelDistance;

        v4 = *pVtmpL;
        v5 = *pVtmpR;
        pVtmpL -= iPixelDistance;
        pVtmpR += iPixelDistance;
        v3 = *pVtmpL;
        v6 = *pVtmpR;
        pVtmpL -= iPixelDistance;
        pVtmpR += iPixelDistance;
        v2 = *pVtmpL;
        v7 = *pVtmpR;
        pVtmpL -= iPixelDistance;
        pVtmpR += iPixelDistance;
        v1 = *pVtmpL;
        v8 = *pVtmpR;

        I32_WMV eq_cnt = phi1(v1 - v2) + phi1(v2 - v3) + phi1(v3 - v4) + phi1(v4 - v5);
        if (eq_cnt != 0)
            eq_cnt += phi1(pVtmpL[-iPixelDistance] - v1) + phi1(v5 - v6) + phi1(v6 - v7) + phi1(v7 - v8) + phi1(v8 - pVtmpR[iPixelDistance]);

        Bool_WMV bStrongFilter;
        if (eq_cnt >= 6) {
            bStrongFilter = bMin_Max_LE_2QP (v1, v2, v3, v4, v5, v6, v7, v8, iStepSize*2);        
        } else {
            bStrongFilter = FALSE;
        }
        
        if (bStrongFilter) {
            I32_WMV  v2plus7 = v2 + v7;            
            *(ppxlcCenter - 2*iPixelDistance) = (3 * (v2 + v3) + v2plus7 + 4) >> 3;                                                        
            *(ppxlcCenter + iPixelDistance) = (3 * (v7 + v6) + v2plus7 + 4) >> 3;
            v2plus7 <<= 1;
            *(ppxlcCenter - iPixelDistance) = (v2 + 3 * v4 + v2plus7 + 4) >> 3;                                                        
            *(ppxlcCenter) = (v7 + 3 * v5 + v2plus7 + 4) >> 3;                                                        
        }
        else {

            I32_WMV v4_v5 = v4 - v5;
            I32_WMV a30 = (2*(v3-v6) - 5*v4_v5 + 4) >> 3;
            I32_WMV absA30 = abs(a30);
            if (absA30 < iStepSize) {
                
                v2 -= v3;
                v6 -= v7;
                I32_WMV a31 = (2 * (v1-v4) - 5 * v2 + 4) >> 3;                                 
                I32_WMV a32 = (2 * (v5-v8) - 5 * v6 + 4) >> 3;
                
                I32_WMV iMina31_a32 = min(abs(a31),abs(a32)); 
                absA30 -= iMina31_a32;
                
                if ((absA30 > 0) && ((v4_v5 ^ a30) < 0)){

                    I32_WMV iSign = v4_v5 >> 31;
                    v4_v5 = abs(v4_v5) >> 1;

                    absA30 *= 5;
                    absA30 >>= 3;

                    if (absA30 > v4_v5)
                        absA30 = v4_v5;

                    absA30 ^= iSign;
                    absA30 -= iSign;

                    *(ppxlcCenter - iPixelDistance) = v4 - absA30;                                                                                         
                    *(ppxlcCenter) = v5 + absA30;
                }
            }        
        }        
        ppxlcCenter++;
    }
}

static Void_WMV FilterVertEdgeX8 (PixelC* ppxlcCenter, I32_WMV iPixelIncrement, I32_WMV iStepSize)
{
    const I32_WMV iThr1 = ((iStepSize + 10) >> 3);// + 1;
    const U32_WMV uThr2 = iThr1<<1;
    PixelC* pVh = ppxlcCenter - 5;
                
    for (I32_WMV i = 0; i < 8; ++i) {
        
        //I32_WMV v0 = pVh[0];                                                                    
        I32_WMV v1 = pVh[1];                                                                    
        I32_WMV v2 = pVh[2];                                                                    
        I32_WMV v3 = pVh[3];                                                                    
        I32_WMV v4 = pVh[4];                                                                    
        I32_WMV v5 = pVh[5];                                                                    
        I32_WMV v6 = pVh[6];                                                                    
        I32_WMV v7 = pVh[7];                                                                    
        I32_WMV v8 = pVh[8];                                                                    
        //I32_WMV v9 = pVh[9];                                                                    
                
        I32_WMV eq_cnt = phi1(v1 - v2) + phi1(v2 - v3) + phi1(v3 - v4) + phi1(v4 - v5);        
        if (eq_cnt != 0)
            eq_cnt += phi1(pVh[0] - v1) + phi1(v5 - v6) + phi1(v6 - v7) + phi1(v7 - v8) + phi1(v8 - pVh[9]);

        Bool_WMV bStrongFilter;
        if (eq_cnt >= 6) {
            bStrongFilter = bMin_Max_LE_2QP (v1, v2, v3, v4, v5, v6, v7, v8, iStepSize*2); 
            
        } else {
            bStrongFilter = FALSE;
        }
        
        if (bStrongFilter) {            
            I32_WMV  v2plus7 = v2 + v7;
            pVh[3] = (3 * (v2 + v3) + v2plus7 + 4) >> 3;                                                        
            pVh[6] = (3 * (v7 + v6) + v2plus7 + 4) >> 3;
            v2plus7 <<= 1;
            pVh[4] = (v2 + 3 * v4 + v2plus7 + 4) >> 3;                                                        
            pVh[5] = (v7 + 3 * v5 + v2plus7 + 4) >> 3;       
        }
        else {
            I32_WMV v4_v5 = v4 - v5;
            I32_WMV a30 = (2*(v3-v6) - 5*v4_v5 + 4) >> 3;
            I32_WMV absA30 = abs(a30);
            if (absA30 < iStepSize) {
                
                v2 -= v3;
                v6 -= v7;
                I32_WMV a31 = (2 * (v1-v4) - 5 * v2 + 4) >> 3;                                 
                I32_WMV a32 = (2 * (v5-v8) - 5 * v6 + 4) >> 3;                                 

                I32_WMV iMina31_a32 = min(abs(a31),abs(a32)); 
                absA30 -= iMina31_a32;
                
                if ((absA30 > 0) && ((v4_v5 ^ a30) < 0)){

                    I32_WMV iSign = v4_v5 >> 31;
                    v4_v5 = abs(v4_v5) >> 1;

                    absA30 *= 5;
                    absA30 >>= 3;

                    if (absA30 > v4_v5)
                        absA30 = v4_v5;

                    absA30 ^= iSign;
                    absA30 -= iSign;

                    pVh[4] = v4 - absA30;                                                                                         
                    pVh[5] = v5 + absA30;
                }
            }   
        }
        
        pVh += iPixelIncrement;
    }
}

#else   // OPT_X8_ARM

// defined in ASM
extern "C" Void_WMV FilterHorzEdgeX8 (PixelC* ppxlcCenter, I32_WMV iPixelDistance, I32_WMV iStepSize);
extern "C" Void_WMV FilterVertEdgeX8 (PixelC* ppxlcCenter, I32_WMV iPixelIncrement, I32_WMV iStepSize);

#   if defined(DEBUG) 
        // a easy breakpoint mechanism from within asm
        extern "C" void WMVAsmBreak( int r0, int r1 ) {
            volatile int i = r0 != r1;
        }
#   endif

#endif  // OPT_X8_ARM

/***************************************************************************
  Deblocking function
***************************************************************************/
Void_WMV X8Deblock(U8_WMV *pCenter, I32_WMV iStride, I32_WMV iStepSize,
                   I32_WMV blockX, I32_WMV blockY, Bool_WMV bResidual, I32_WMV iOrient)
{
    Bool_WMV  bFlag;

    FUNCTION_PROFILE_DECL_START(fp,DECODEIX8LOOPFILTER_PROFILE);

    bFlag = (blockY > 0) && (bResidual || (iOrient != 0 && iOrient != 4));
	if (bFlag)
        FilterHorzEdgeX8(pCenter, iStride, iStepSize);

    bFlag = (blockX > 0) && (bResidual || (iOrient != 0 && iOrient != 8));
    if (bFlag)
        FilterVertEdgeX8(pCenter, iStride, iStepSize);

    FUNCTION_PROFILE_STOP(&fp);
}

/***************************************************************************
  Context class global functions
***************************************************************************/
static U8_WMV fnMin(U8_WMV v1, U8_WMV v2, U8_WMV v3)
{
    return (v1<v2)?((v1<v3)?v1:v3):((v2<v3)?v2:v3);
}

/***************************************************************************
  Context class constructor and destructor
***************************************************************************/
t_ContextWMV *t_ContextWMVConstruct (I32_WMV iCol, I32_WMV iRow)
{
    t_ContextWMV *pContext = (t_ContextWMV *) wmvalloc (sizeof(t_ContextWMV));
    if ( pContext == NULL_WMV )
        return NULL_WMV;
    pContext->m_iRow = iRow;
    pContext->m_iCol = iCol;

    pContext->m_pData = (U8_WMV *) wmvalloc (iRow * iCol * sizeof(U8_WMV));
    if (pContext->m_pData == NULL_WMV)
        return NULL_WMV;

    DEBUG_HEAP_ADD(DHEAP_LOCALHUFF, sizeof(t_ContextWMV) + (iRow * iCol * sizeof(U8_WMV)));

    pContext->m_iColGt2 = (pContext->m_iCol > 2) ? 2 : 1;
    return pContext;
}

Void_WMV t_ContextWMVDestruct (t_ContextWMV *pContext)
{
    if ( pContext != NULL ) {
        DEBUG_HEAP_SUB(DHEAP_LOCALHUFF, sizeof(t_ContextWMV) + (pContext->m_iRow * pContext->m_iCol * sizeof(U8_WMV)));
        if ( pContext->m_pData != NULL )
            wmvfree ((Void_WMV *)(pContext->m_pData));
        wmvfree ((Void_WMV *) pContext);
    }
}

/***************************************************************************
  Context class joint functions (only decoder side is safe)
***************************************************************************/
Void_WMV t_ContextGetDec (t_ContextWMV *pContext, I32_WMV iX, I32_WMV iY,
                          I32_WMV iStepSize, I32_WMV *iPredOrient, I32_WMV *iEstRun)
{
    U8_WMV  *pData1 = pContext->m_pData + ((iY - 1) & 1) * pContext->m_iCol;
    U8_WMV  *pData0 = pContext->m_pData + (iY & 1) * pContext->m_iCol;

// predict orientation
    if ((iX | iY) == 0) {
        *iPredOrient = 0;
    }
    else if (iX == 0) {  // left edge (vertical)
// check if top far right orientation is checked in (at least 1 MB wide)
        *iPredOrient = 1;
        // following check not required at decoder
        // iPredOrient = ((pData1[m_iColGt2] & 0x3) == 0x3) ? 0xff : 1;
    }
    else if (iY == 0) {  // top edge  (horizontal)
// no check needed
        *iPredOrient = 2;
    }
    else {
// check top far right
        I32_WMV  iXfr = iX+2;
        I32_WMV iT, iL;
        if (iXfr >= pContext->m_iCol)  iXfr = pContext->m_iCol - 1;
        // following check not required at decoder
        //if ((pData1[iXfr] & 0x3) == 0x3) {
        //    iPredOrient = 0xff;
        //    return;
        //}
// all the rules
        
        iT = pData1[iX] & 0x3;
        iL = pData0[iX - 1] & 0x3;

        if (iT==iL)
            *iPredOrient =  iT;
        else if (iL==2 && iT==0)
            *iPredOrient =  iL;
        else if (iL==0 && iT==1)
            *iPredOrient =  iT;
        else if (iL==2 && iT==1)
            *iPredOrient =  iL;
        else if (iL==1 && iT==2) {
            I32_WMV iTL = pData1[iX - 1] & 0x3;
            if (iTL == iL)            *iPredOrient =  iT;
            else {
                if (iStepSize > 12)   *iPredOrient =  iT;
                else {
                    if (iTL == iT)    *iPredOrient =  iL;
                    else              *iPredOrient =  iTL;
                }
            }
        }
        else
            *iPredOrient =  0;
    }

    {
        U8_WMV v1, v2, v3;
        if (iX == 0) {
            v2 = v1 = (iY == 0) ?
                /*m_uDefault*/ 16 : (pData1[0] >> 2);
        }
        else {
            v1 = (pData0[iX - 1] >> 2);
            v2 = (iY == 0)?
                v1 : (pData1[iX] >> 2);
        }
        v3 = ((iY & iX) == 0) ? v2 : (pData1[iX - 1] >> 2);

        *iEstRun = fnMin (v1, v2, v3);
    }
    return;
}

/***************************************************************************
  Context class joint put (only decoder side is safe)
***************************************************************************/
static I8_WMV orientRemap[]={0,0,0,0,1,0,0,0,2,0,0,0};

Void_WMV t_ContextPutDec (t_ContextWMV *pContext, I32_WMV iX, I32_WMV iY,
                          I32_WMV iOrientContext, I32_WMV iRunContext)
{
    iOrientContext = orientRemap[iOrientContext] & 0x3;
    pContext->m_pData[(iY & 1) * pContext->m_iCol + iX]
        = iOrientContext | (iRunContext << 2);
}

/***************************************************************************
  Orientation predictor (joint, for Chroma)
***************************************************************************/
I32_WMV  t_ContextGetChromaDec (t_ContextWMV *pContext, I32_WMV iX, I32_WMV iY)
{
    if ((iX > 1) && (iY > 1))
        return pContext->m_pData[iX - 1] & 0x3;
    else if (iY > 1)
        return 1;   // vertical predictor
    else
        return 2;   // horizontal predictor (also for origin block)
}

/***************************************************************************
  END
***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\msaudio.c ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    MsAudio.cpp

Abstract:

    Implementation of public member functions for CAudioObject.

Author:

    Wei-ge Chen (wchen) 11-March-1998

Revision History:


*************************************************************************/

// Print out the target we're building for
#define COMMONMACROS_OUTPUT_TARGET

#include "bldsetup.h"

#if !defined (_WIN32_WCE) && !defined (HITACHI)
#include <time.h>
#endif  // _WIN32_WCE

#include <math.h>
#include <limits.h>
#include <stdio.h>
#include "msaudio.h"
#include "AutoProfile.h"
#include "macros.h"
#include "float.h"
#include "cpudetect.h"


#ifdef BUILD_INTEGER

#define SIN_START   pau->m_iSinRampUpStart
#define SIN1_START  pau->m_iSinRampUpPrior
#define COS_START   pau->m_iCosRampUpStart
#define COS1_START  pau->m_iCosRampUpPrior
#define SIN_STEP    pau->m_iSinRampUpStep

#else   // BUILD_INTEGER

#define SIN_START   *((Int*) &pau->m_fltSinRampUpStart)
#define SIN1_START  *((Int*) &pau->m_fltSinRampUpPrior)
#define COS_START   *((Int*) &pau->m_fltCosRampUpStart)
#define COS1_START  *((Int*) &pau->m_fltCosRampUpPrior)
#define SIN_STEP    *((Int*) &pau->m_fltSinRampUpStep)

#endif  // BUILD_INTEGER

//*****************************************************************************************
// Forward Function Declarations
//*****************************************************************************************

void prvInitDiscardSilence(CAudioObject *pau);
void prvDiscardSilence(CAudioObject *pau, U16 *pcSampleDecoded,
                       U16 iChannels, U8 *pbBuf);
void prvSetAdjustedValues(CAudioObject *pau, Int fQToo);
void prvFFT4DCT(CoefType data[], Int nLog2np, FftDirection fftDirection);


//*****************************************************************************************
//
// msaudioGetSamplePerFrame
//
//*****************************************************************************************
I32 msaudioGetSamplePerFrame (Int   cSamplePerSec, 
                              U32   dwBitPerSec, 
                              Int   cNumChannels,
                              Int   iVersion) 
{
    //return NEW samples coming into a frame; actual samples in a frame
    //should be * 2 due to 50% overlapping window
    I32 cSamplePerFrame;
    U32 dwBytesPerFrame;

        //don't know what to do
    if (dwBitPerSec == 0 || iVersion > 2)
        return 0;

    if (cSamplePerSec <= 8000)
        cSamplePerFrame = 512;
    else if (cSamplePerSec <= 11025)
        cSamplePerFrame = 512;
    else if (cSamplePerSec <= 16000) {
        cSamplePerFrame = 512;
    }
    else if (cSamplePerSec <= 22050) {
        cSamplePerFrame = 1024;
    }
    else if (cSamplePerSec <= 32000) {
        if(iVersion == 1)
            cSamplePerFrame = 1024;
        else
            cSamplePerFrame = 2048;
    }
    else if (cSamplePerSec <= 44100)
        cSamplePerFrame = 2048;
    else if (cSamplePerSec <= 48000)
        cSamplePerFrame = 2048;
    else
        return 0;
    dwBytesPerFrame = (U32) (((cSamplePerFrame*dwBitPerSec + cSamplePerSec/2)/cSamplePerSec + 7)/8);
    if ( dwBytesPerFrame==0 && (cSamplePerFrame*dwBitPerSec) == 0 ) {
        // this can happen when garbage data sets dwBitsPerSec to a very large number
        // avoid an infinite loop below
        dwBitPerSec = cSamplePerSec;
        dwBytesPerFrame = (U32) (((cSamplePerFrame*dwBitPerSec + cSamplePerSec/2)/cSamplePerSec + 7)/8);
    }
    if (dwBytesPerFrame <= 1) {   //silence mode
        while (dwBytesPerFrame == 0) {
            cSamplePerFrame *= 2;           //save more bits; quartz can't take too big a value
            dwBytesPerFrame = (U32) (((cSamplePerFrame*dwBitPerSec + cSamplePerSec/2)/cSamplePerSec + 7)/8);
        }
    }
    return cSamplePerFrame;
}

//*****************************************************************************************
//
// MaxSamplesPerPacket
//   Returns the largest possible number of PCM samples that the decoder can produce
//   from a single compressed packet.  
//
//*****************************************************************************************
U32 MaxSamplesPerPacket(U32 ulVersion, U32 ulSamplingRate, U32 ulChannels, U32 ulBitrate) {
   return (16 + 1) * msaudioGetSamplePerFrame(ulSamplingRate,ulBitrate,ulChannels,ulVersion);
}

//*****************************************************************************************
//
// mallocAligned & freeAligned
// allocates a buffer of size bytes aligned to iAlignToBytes bytes.
//
//*****************************************************************************************
void *mallocAligned(size_t size,Int iAlignToBytes){
    Int mask = -1;                                    //Initally set mask to 0xFFFFFFFF
    void *retBuffer;
    void *buffer = auMalloc(size+iAlignToBytes);        //allocate buffer + alignment bytes
    if(buffer == NULL)
    {
        TraceResult(WMA_E_OUTOFMEMORY);
        return NULL;
    }
    assert(iAlignToBytes > 0);
    assert(iAlignToBytes < 256);
    mask <<= LOG2(iAlignToBytes);                     //Generate mask to clear lsb's
    retBuffer = (void*)(((Int)((U8*)buffer+iAlignToBytes))&mask);//Generate aligned pointer
    ((U8*)retBuffer)[-1] = (U8)((U8*)retBuffer-(U8*)buffer);//Write offset to newPtr-1
    return retBuffer;
}

void freeAligned(void *ptr){
    U8* realBuffer = (U8*)ptr;
    U8 bytesBack;
    if (realBuffer == NULL) return; 
    bytesBack = ((U8*)ptr)[-1];      //Get offset to real pointer from -1 possition
    realBuffer -= bytesBack;    //Get original pointer address
    wmvfree(realBuffer);
}



// ----- Memory Allocation Functions -----
#ifdef STATIC_MEMALLOC
// Global vars
static MEMALLOCSTATE    g_maState = MAS_DELETE;
static U8              *g_pBuffer = NULL;
static I32              g_iBufRemaining = 0;
static I32              g_iAllocCount = 0;

I32 auMallocGetCount(void)
{
    return g_iAllocCount;
}


void auMallocSetState(const MEMALLOCSTATE maState, void *pBuf, const I32 iBufSize)
{
    switch (maState)
    {
        case MAS_ALLOCATE:
            assert(MAS_DELETE == g_maState);
            g_pBuffer = (U8 *) pBuf;
            g_iBufRemaining = iBufSize;
            g_maState = MAS_ALLOCATE;
            break;

        case MAS_LOCKED:
            assert(MAS_ALLOCATE == g_maState);
            g_maState = MAS_LOCKED;
            break;

        case MAS_DELETE:
            g_maState = MAS_DELETE;
            break;

        default:
            assert(WMAB_FALSE);
            break;
    }
}


void *auMalloc(const size_t iSize)
{
    WMARESULT   wmaResult = WMA_OK;
    void       *pResult = NULL;

    switch (g_maState)
    {
        case MAS_ALLOCATE:

            if (NULL == g_pBuffer)
            {
                pResult = wmvalloc(iSize);
                if (NULL == pResult)
                    wmaResult = TraceResult(WMA_E_OUTOFMEMORY);
            }
            else
            {
                if (iSize <= (U32) g_iBufRemaining)
                {
                    pResult = g_pBuffer;
                    g_pBuffer += iSize;
                    g_iBufRemaining -= iSize;
                }
                else
                {
                    wmaResult = TraceResult(WMA_E_OUTOFMEMORY);
                    assert(WMAB_FALSE);
                }
            }

            g_iAllocCount += iSize;
            break;

        default:
            wmaResult = TraceResult(WMA_E_FAIL);
            assert(WMAB_FALSE); // We should only be called during allocation
            break;
    }

    return pResult;
}

void auFree(void *pFree)
{
    assert(MAS_DELETE == g_maState);
    if (NULL == g_pBuffer)
        wmvfree(pFree);
}
#else   // STATIC_MEMALLOC

I32 auMallocGetCount(void)
{
    return 0;
}

void auMallocSetState(const MEMALLOCSTATE maState, void *pBuf, const I32 iBufSize)
{
}


void *auMalloc(const size_t iSize)
{
    return wmvalloc(iSize);
}


void auFree(void *pFree)
{
    wmvfree(pFree);
}

#endif  // STATIC_MEMALLOC


//*****************************************************************************************
//
// auNew
// create and initialize a CAudioObject
//
//*****************************************************************************************
CAudioObject* auNew ()
{
    CAudioObject* pau = (CAudioObject*) auMalloc (sizeof (CAudioObject));
    if ( pau == NULL )
    {
        TraceResult(WMA_E_OUTOFMEMORY);
        return pau;
    }

    memset(&pau->m_qstQuantStep, 0, sizeof(pau->m_qstQuantStep)); // May be struct or float/double
    // memset(pau->m_rgiQuantStepFract, 0, sizeof(pau->m_rgiQuantStepFract));
    pau->m_iPacketCurr = 0;
    pau->m_cBitPackedFrameSize = 0;
    pau->m_cBitPacketHeader = 0;
    pau->m_cdwPacketHeader = 0;
    pau->m_cBitPacketHeaderFractionDw = 0;
    pau->m_cBitPacketLength = 0;
    pau->m_cRunOfZeros = 0;
    pau->m_iLevel = 0; 
    pau->m_iSign = 0;
    pau->m_iHighCutOffCurr = 0;
    pau->m_iNextBarkIndex = 0;

    pau->m_fNoiseSub = WMAB_FALSE; 
    pau->m_fltBitsPerSample = 0;
    pau->m_fltWeightedBitsPerSample = 0;

    pau->m_iMaxEscSize = 9;
    pau->m_iMaxEscLevel = (1 << pau->m_iMaxEscSize) - 1;

    pau->m_iVersion = 0;
    pau->m_codecStatus = CODEC_NULL;
    pau->m_fSeekAdjustment = WMAB_FALSE;
    pau->m_fPacketLossAdj = WMAB_FALSE;
    pau->m_iSamplingRate = 0;
    pau->m_cChannel = 0;
    pau->m_cSubband = 0;

    pau->m_fAllowSuperFrame = WMAB_FALSE;
    pau->m_fAllowSubFrame = WMAB_FALSE;
    pau->m_iCurrSubFrame = 0;
    pau->m_fHeaderReset = WMAB_TRUE;
    pau->m_iSubFrameSizeWithUpdate = 0;
    pau->m_iMaxSubFrameDiv = 1;
    pau->m_cMinSubFrameSample = 0;
    pau->m_cMinSubFrameSampleHalf = 0;
    pau->m_cMinSubFrameSampleQuad = 0;
    pau->m_cPossibleWinSize = 0;
    pau->m_iIncr = 0;
    pau->m_cSubFrameSample = 0;
    pau->m_cSubFrameSampleHalf = 0;
    pau->m_cSubFrameSampleQuad = 0;
    memset(&pau->m_subfrmconfigPrev, 0, sizeof(pau->m_subfrmconfigPrev));
    memset(&pau->m_subfrmconfigCurr, 0, sizeof(pau->m_subfrmconfigCurr));
    memset(&pau->m_subfrmconfigNext, 0, sizeof(pau->m_subfrmconfigNext));

    pau->m_cBitsSubbandMax = 0;
    pau->m_cFrameSample = 0;
    pau->m_cFrameSampleHalf = 0;
    pau->m_cFrameSampleQuad = 0;

    pau->m_cLowCutOff = 0;
    pau->m_cHighCutOff = 0;
    pau->m_cLowCutOffLong = 0;
    pau->m_cHighCutOffLong = 0;

    pau->m_iWeightingMode = LPC_MODE;
    pau->m_stereoMode = STEREO_LEFTRIGHT;
    pau->m_iEntropyMode = 0;
    pau->m_fltDitherLevel = 0.04F;
    pau->m_iQuantStepSize = (MIN_QUANT + MAX_QUANT - 1) / 2;
    pau->m_fltFlatenFactor = 0.5F;
    pau->m_fltDctScale = 0;
    pau->m_cValidBarkBand = 0;
    pau->m_rgiBarkIndex = NULL;

#if defined(BUILD_INTEGER)
    pau->m_iSinRampUpStart = 0;
    pau->m_iCosRampUpStart = 0;
    pau->m_iSinRampUpPrior = 0;
    pau->m_iCosRampUpPrior = 0;
    pau->m_iSinRampUpStep = 0;
    pau->m_iSinRampDownStart = 0;
    pau->m_iCosRampDownStart = 0;
    pau->m_iSinRampDownPrior = 0;
    pau->m_iCosRampDownPrior = 0;
    pau->m_iSinRampDownStep = 0;
    memset(pau->m_iSinInit, 0, sizeof(pau->m_iSinInit));
    memset(pau->m_iCosInit, 0, sizeof(pau->m_iCosInit));
#endif

#if !defined(BUILD_INTEGER)
    pau->m_fltSinRampUpStart = 0;
    pau->m_fltCosRampUpStart = 0;
    pau->m_fltSinRampUpPrior = 0;
    pau->m_fltCosRampUpPrior = 0;
    pau->m_fltSinRampUpStep = 0;
    pau->m_fltSinRampDownStart = 0;
    pau->m_fltCosRampDownStart = 0;
    pau->m_fltSinRampDownPrior = 0;
    pau->m_fltCosRampDownPrior = 0;
    pau->m_fltSinRampDownStep = 0;
#endif
#ifdef USE_SIN_COS_TABLES
    //MMX tables
    pau->m_piSinForRecon2048 = NULL;
    pau->m_piSinForRecon1024 = NULL;
    pau->m_piSinForRecon512 = NULL;
    pau->m_piSinForRecon256 = NULL;
    pau->m_piSinForRecon128 = NULL;
    pau->m_piSinForRecon64 = NULL;
    pau->m_piSinForRecon = NULL;
    pau->m_piSinForSaveHistory = NULL;
#endif

    pau->m_iSizePrev = 0;
    pau->m_iSizeCurr = 0;
    pau->m_iSizeNext = 0;

    pau->m_iCoefRecurQ1 = 0;
    pau->m_iCoefRecurQ2 = 0;
    pau->m_iCoefRecurQ3 = 0;
    pau->m_iCoefRecurQ4 = 0;

    pau->m_rgiCoefQ = NULL;

    pau->m_rgpcinfo = NULL;
    pau->m_rgiCoefReconOrig = NULL;
    pau->m_rgiMaskQ = NULL;
    pau->m_rgcValidBarkBand = NULL;
    pau->m_rgiBarkIndexOrig = NULL;


    pau->m_piPrevOutput = NULL;
    pau->m_iDiscardSilence = 0;

#ifdef ENABLE_ALL_ENCOPT
    pau->m_fltFirstNoiseFreq = 0;
    pau->m_iFirstNoiseBand = 0;
    pau->m_iFirstNoiseIndex = 0;
    pau->m_iNoisePeakIgnoreBand = 1;

    pau->m_rgiFirstNoiseBand = NULL;
    pau->m_rgbBandNotCoded = NULL;
    pau->m_rgffltSqrtBWRatio = NULL;
    pau->m_rgiNoisePower = NULL;
    pau->m_rgfltBandWeight = NULL;

#if defined(_DEBUG) && defined(LPC_COMPARE)
    memset(pau->m_rgfltLpsSpecCos, 0, sizeof(pau->m_rgfltLpsSpecCos));
    memset(pau->m_rgfltLpsSpecSin, 0, sizeof(pau->m_rgfltLpsSpecSin));
#endif  // _DEBUG
#endif  // ENABLE_ALL_ENCOPT

    pau->m_rgfltWeightFactor = NULL;
    pau->m_rguiWeightFactor = NULL;

    pau->m_iFrameNumber = 0;

#if defined(INTERPOLATED_DOWNSAMPLE)
    pau->m_fLowPass = WMAB_FALSE;
    pau->m_fDownsample = WMAB_FALSE;
    pau->m_iInterpolSrcBlkSize = 0;
    pau->m_iInterpolDstBlkSize = 0;
    pau->m_iInterpolIncr = 0;
    pau->m_iInterpolCarry = 0;
    pau->m_iInterpolWeightIncr = 0;
    pau->m_iInterpolAddInterval = 0;
    pau->m_iInterpolNextAdd = 0;
#endif  // defined(INTERPOLATED_DOWNSAMPLE)

#if defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
    pau->m_fHalfTransform = WMAB_FALSE;
    pau->m_fUpsample = WMAB_FALSE;
    pau->m_fPad2XTransform = WMAB_FALSE;
    memset(pau->m_iPriorSample, 0, sizeof(pau->m_iPriorSample));
    //pau->m_htiHalfPrevState.m_fSaved = WMAB_FALSE;
    //pau->m_htiPad2XPrevState.m_fSaved = WMAB_FALSE;
    pau->m_cSubbandAdjusted = 0;
    pau->m_cFrameSampleAdjusted = 0; 
    pau->m_cFrameSampleHalfAdjusted = 0;
    pau->m_cSubFrameSampleAdjusted = 0;
    pau->m_cSubFrameSampleHalfAdjusted = 0;
    pau->m_cSubFrameSampleQuadAdjusted = 0;
    pau->m_cHighCutOffAdjusted = 0;
#endif  // defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)

#if !defined(BUILD_INTEGER) && !defined(UNDER_CE) && !defined(_Embedded_x86) && defined(WMA_TARGET_X86)
    pau->m_fIntelFFT = WMAB_FALSE;
#endif  // !defined(BUILD_INTEGER) && !defined(UNDER_CE) && defined(WMA_TARGET_X86)

#ifdef ENABLE_ALL_ENCOPT
    pau->aupfnInverseQuantize = prvInverseQuantizeMidRate;
#else
    pau->aupfnInverseQuantize = NULL;
#endif
    pau->aupfnCalcSqrtBWRatio = NULL;
    pau->prvpfnInverseTransformMono = NULL; // Not currently used
    pau->aupfnGetNextRun = NULL;

	RandStateClear(&(pau->m_tRandState));

    // OK, now verify the sizes of all fundamental type definitions
#ifndef __QNX__
    assert(sizeof(U64) == 8);
    assert(sizeof(I64) == 8);
#endif
    assert(sizeof(U32) == 4);
    assert(sizeof(I32) == 4);
    assert(sizeof(U16) == 2);
    assert(sizeof(I16) == 2);
    assert(sizeof(U8) == 1);
    assert(sizeof(I8) == 1);

    return pau;
}


//*****************************************************************************************
//
// auDelete
// delete a CAudioObject
//
//*****************************************************************************************
Void    auDelete (CAudioObject* pau)
{
    if (NULL == pau)
        return;

    DELETE_ARRAY (pau->m_rgpcinfo);

    DELETE_ARRAY (pau->m_piPrevOutput);

    {
        freeAligned(pau->m_rgiCoefReconOrig);
        DELETE_ARRAY (pau->m_rguiWeightFactor);
        pau->m_rgfltWeightFactor = NULL;
    }
    DELETE_ARRAY (pau->m_rgcValidBarkBand);
    DELETE_ARRAY (pau->m_rgiBarkIndexOrig);
    DELETE_ARRAY (pau->m_rgiMaskQ);

#ifdef ENABLE_ALL_ENCOPT
    {
#if defined(_DEBUG) && defined(LPC_COMPARE)
        Int i;
        for (i = 0; i < LPCORDER; i++)  {
            if ( pau->m_rgfltLpsSpecCos[i] != NULL )
                DELETE_ARRAY (pau->m_rgfltLpsSpecCos[i]);
            if ( pau->m_rgfltLpsSpecSin[i] != NULL )
                DELETE_ARRAY (pau->m_rgfltLpsSpecSin[i]);
        }
#endif
        DELETE_ARRAY (pau->m_rgiFirstNoiseBand);
        DELETE_ARRAY (pau->m_rgbBandNotCoded);
        DELETE_ARRAY (pau->m_rgffltSqrtBWRatio);
        DELETE_ARRAY (pau->m_rgiNoisePower);
        DELETE_ARRAY (pau->m_rgfltBandWeight);
    }
#endif //ENABLE_ALL_ENCOPT

    DELETE_ARRAY (pau->m_rgiCoefQ);

#if defined(WMA_TARGET_X86) && !(defined(BUILD_INTEGER) || defined(UNDER_CE) || defined(_Embedded_x86))
    if (pau->m_fIntelFFT)
    {
        WMARESULT wmaResult;

        wmaResult = auFreeIntelFFT(pau, INTELFFT_FREE_PROCESS);
        TraceError(wmaResult);
    }
#endif  // WMA_TARGET_X86 && !defined(BUILD_INTEGER)

    auFree (pau);

    DUMP_MONITOR_RANGES(0);
}


//*****************************************************************************************
//
// auInit
// initialize a CAudioObject based on information from input file or stream
//
//*****************************************************************************************
WMARESULT auInit (CAudioObject* pau, 
                Int iVersionNumber,
                Int cSubband, 
                Int cSamplePerSec, 
                U16 cChannel, 
                Int cBytePerSec, 
                Int cbPacketLength,
                U16 iEncodeOpt,
                U16 iPlayerOpt)
{
    U16 iNonSupportedPlayerOpt;
    WMARESULT   wmaResult = WMA_OK;

    //set up default pcinfo for noise sub

    static const char fOKOptions[16] = {
        // WinCE Player Option Combinations
        WMAB_TRUE,  // 0: normal
        WMAB_TRUE,  // 1: Device that does not support 32kHz sampling -> interpolated downsample to 22kHz
        WMAB_TRUE,  // 2: Background HalfTransform mode to save CPU cycles
        WMAB_TRUE,  // 3: Background HalfTransform mode on device that does not support 32kHz sampling, ends up at 11kHz
        WMAB_TRUE,  // 4: A slow CPU which does not support F0 but does support 2*F0
        WMAB_TRUE,  // 5: Device that does not support 32kHz sample nor 22kHz playback, plays 32kHz data via 22kHz quality at 44kHz
        WMAB_TRUE,  // 6: Background HalfTransform mode for device that does not support half sampling rate
        WMAB_TRUE,  // 7: Background with downsampling - why?
        WMAB_TRUE,  // 8: Hide HP-430's lack of a low-pass filter for 22kHz output
        WMAB_FALSE, // 9: not appropriate - would need to interpolate to 44kHz if appropriate
        WMAB_TRUE,  // A: Background HalfTransform mode on a HP-430 at 22kHz, decode as normal (neither half nor doubled)
        WMAB_TRUE,  // B: why but why not allow?? 
        WMAB_FALSE, // C: not appropriate
        WMAB_FALSE, // D: not appropriate
        WMAB_FALSE, // E: not appropriate
        WMAB_FALSE  // F: not appropriate
    };
    assert( PLAYOPT_DOWNSAMPLE32TO22==1 && PLAYOPT_HALFTRANSFORM==2 && PLAYOPT_UPSAMPLE==4 && PLAYOPT_PAD2XTRANSFORM==8 );

    pau->m_iVersion = iVersionNumber;

#   if defined(WMA_TARGET_MIPS) && defined(BUILD_INTEGER)
        if (pau->m_iVersion < 2 && cSamplePerSec >= 44100 ) {
            // bug 813 - mips integer code gets an integer overflow exception on V1 content 11/21/2000
            wmaResult = TraceResult(WMA_E_NOTSUPPORTED);
            goto exit;
        }
#   endif

    pau->m_iWeightingMode    = (iEncodeOpt & ENCOPT_BARK) ? BARK_MODE : LPC_MODE;
    pau->m_fV5Lpc = (iEncodeOpt & ENCOPT_V5LPC);
#ifndef ENABLE_LPC
    if (LPC_MODE == pau->m_iWeightingMode)
    {
        // This build of the codec does not support LPC!
        wmaResult = TraceResult(WMA_E_NOTSUPPORTED);
        goto exit;
    }
#endif  // ENABLE_LPC

    if ( cChannel>2 ) {
        // when we add 5.1 support, we don't want existing decoders to try to decode them
        wmaResult = TraceResult(WMA_E_NOTSUPPORTED);
        goto exit;
    }

    pau->m_fAllowSuperFrame  = !!(iEncodeOpt & ENCOPT_SUPERFRAME);
    pau->m_fAllowSubFrame    = pau->m_fAllowSuperFrame && !!(iEncodeOpt & ENCOPT_SUBFRAME);

    if (pau->m_fAllowSubFrame) {
        pau->m_iMaxSubFrameDiv = ((iEncodeOpt & ENCOPT_SUBFRAMEDIVMASK) >>
            ENCOPT_SUBFRAMEDIVSHR);
        if (cBytePerSec / cChannel >= 4000)
            pau->m_iMaxSubFrameDiv = (8 << pau->m_iMaxSubFrameDiv);
        else 
            pau->m_iMaxSubFrameDiv = (2 << pau->m_iMaxSubFrameDiv);
    }
    else 
        pau->m_iMaxSubFrameDiv = 1;
    if (pau->m_iMaxSubFrameDiv > cSubband / MIN_FRAME_SIZE)
        pau->m_iMaxSubFrameDiv = cSubband / MIN_FRAME_SIZE;

    // When using noise substitution for uncoded bark or frequency bands, 
    // m_fltDitherLevel sets an overall "gain" of the substitution noise
    if (pau->m_iWeightingMode == LPC_MODE)
        pau->m_fltDitherLevel = 0.04F;
    else // BARK_MODE
        pau->m_fltDitherLevel = 0.02F;

    // --- Handle player options ---
    // First, figure out if the player has asked us for an option that we
    // didn't build
    iNonSupportedPlayerOpt = ~0; // Turn everything on
    DOWNSAMPLE_ONLY(iNonSupportedPlayerOpt &= ~(PLAYOPT_DOWNSAMPLE32TO22));
    HALFTRANSFORM_ONLY(iNonSupportedPlayerOpt &= ~(PLAYOPT_HALFTRANSFORM));
    UPSAMPLE_ONLY(iNonSupportedPlayerOpt &= ~(PLAYOPT_UPSAMPLE));
    PAD2XTRANSFORM_ONLY(iNonSupportedPlayerOpt &= ~(PLAYOPT_PAD2XTRANSFORM));

    if ( (iNonSupportedPlayerOpt & iPlayerOpt) || !fOKOptions[iPlayerOpt&0xF] )
    {
        // Player has requested something that we didn't build 
        // or wants an unsupported combination of options
        wmaResult = TraceResult(WMA_E_NOTSUPPORTED);
        goto exit;
    }

    if ( (iPlayerOpt&(PLAYOPT_HALFTRANSFORM|PLAYOPT_PAD2XTRANSFORM))==(PLAYOPT_HALFTRANSFORM|PLAYOPT_PAD2XTRANSFORM) )
    {
        // if in pad2X mode and a shift into the background sets half transform mode, do neither
        iPlayerOpt &= ~(PLAYOPT_HALFTRANSFORM|PLAYOPT_PAD2XTRANSFORM);
    }

#if defined(INTERPOLATED_DOWNSAMPLE)
    pau->m_fLowPass = WMAB_FALSE;
    pau->m_fDownsample = WMAB_FALSE;
    // 16000->11025 produces ticking sounds in tough_16m_16.  32000->22050 also produces ticking, but is less pronounced.
    // if ((iPlayerOpt & PLAYOPT_DOWNSAMPLE32TO22) && (32000 == cSamplePerSec || 16000 == cSamplePerSec) )
    if ((iPlayerOpt & PLAYOPT_DOWNSAMPLE32TO22) && (32000 == cSamplePerSec) )
    {
        pau->m_fLowPass = WMAB_TRUE;
        pau->m_fDownsample = WMAB_TRUE;
        // This works out to 32000=>22050 or 16000=>11025
        prvInterpolateInit(pau, cSamplePerSec, 32000 == cSamplePerSec ? 22000 : 11000, 441); 
    }
#endif  // INTERPOLATED_DOWNSAMPLE

#if defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
    pau->m_fHalfTransform = WMAB_FALSE;
    if (iPlayerOpt & PLAYOPT_HALFTRANSFORM)
        pau->m_fHalfTransform = WMAB_TRUE;

    pau->m_fUpsample = WMAB_FALSE;
    if (iPlayerOpt & PLAYOPT_UPSAMPLE)
        pau->m_fUpsample = WMAB_TRUE;

    pau->m_fPad2XTransform = WMAB_FALSE;
    if ((iPlayerOpt & PLAYOPT_PAD2XTRANSFORM)  && 22050 == cSamplePerSec)
        pau->m_fPad2XTransform = WMAB_TRUE;
#endif  // defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)

    //assign some basic parameters/mode
    pau->m_iSamplingRate    = cSamplePerSec;
    pau->m_cChannel         = cChannel;
    pau->m_nBytePerSample   = sizeof (I16);
    pau->m_cSubband         = cSubband;
    pau->m_fltBitsPerSample  = (Float)(cBytePerSec*8.0f/(pau->m_iSamplingRate*pau->m_cChannel));    
    pau->m_fltWeightedBitsPerSample = pau->m_fltBitsPerSample;
    // With the same QuantStep, the stereo is equivant to the mono with 1.6 times the bitrate/ch.
    if (pau->m_cChannel > 1) 
        pau->m_fltWeightedBitsPerSample *= (Float) MSA_STEREO_WEIGHT;

    //decide secondary parameters
    //first the frame sizes
    pau->m_cFrameSample      = 2 * pau->m_cSubband;
    pau->m_cFrameSampleHalf  = pau->m_cSubband;
    pau->m_cFrameSampleQuad  = pau->m_cSubband / 2; 

    pau->m_cSubFrameSample      = pau->m_cFrameSample;
    pau->m_cSubFrameSampleHalf  = pau->m_cFrameSampleHalf;
    pau->m_cSubFrameSampleQuad  = pau->m_cFrameSampleQuad; 

    pau->m_iCoefRecurQ1 = 0;
    pau->m_iCoefRecurQ2 = pau->m_iCoefRecurQ3 = pau->m_cSubFrameSampleHalf;
    pau->m_iCoefRecurQ4 = pau->m_cSubFrameSample;

    //init now; but can be reassigned in each frame; if so, be careful with tran. det.
    pau->m_cMinSubFrameSample    = pau->m_cSubFrameSample / pau->m_iMaxSubFrameDiv;
    pau->m_cMinSubFrameSampleHalf= pau->m_cSubFrameSampleHalf / pau->m_iMaxSubFrameDiv;
    pau->m_cMinSubFrameSampleQuad= pau->m_cSubFrameSampleQuad / pau->m_iMaxSubFrameDiv; 
    pau->m_cPossibleWinSize = LOG2 ((U32)pau->m_iMaxSubFrameDiv) + 1;
    pau->m_cBitsSubbandMax = LOG2 ((U32)pau->m_cSubband);

    if(pau->m_iVersion == 1)
        pau->m_cLowCutOffLong    = LOW_CUTOFF_V1;                     //need investigation
    else
        pau->m_cLowCutOffLong    = LOW_CUTOFF;                        //need investigation
    pau->m_cHighCutOffLong       = pau->m_cSubband - 9 * pau->m_cSubband / 100; //need investigation

    //default
    pau->m_cLowCutOff            = pau->m_cLowCutOffLong;
    pau->m_cHighCutOff           = pau->m_cHighCutOffLong;

    //set up some global coding condtions based on bitrate
    pau->m_iEntropyMode = SIXTEENS_OB;                     //default

    if (pau->m_fltWeightedBitsPerSample < 0.72f) {
        if (pau->m_iSamplingRate >= 32000)
            pau->m_iEntropyMode = FOURTYFOURS_QB;
    }
    else if (pau->m_fltWeightedBitsPerSample < 1.16f) {
        if (pau->m_iSamplingRate >= 32000)   {
            pau->m_iEntropyMode = FOURTYFOURS_OB;
        }
    }

#if defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
    prvSetAdjustedValues(pau, WMAB_TRUE);
#endif

    TRACEWMA_EXIT(wmaResult, prvAllocate (pau));

    //initialize constants for packetization
    pau->m_cBitPacketLength  = cbPacketLength * BITS_PER_BYTE;
    pau->m_cBitPackedFrameSize = LOG2 ((U32)ROUNDF (pau->m_fltBitsPerSample * pau->m_cFrameSampleHalf / 8.0F)) + 2;
//pau->m_cBitPackedFrameSize += 1;
    pau->m_cBitPacketHeader   = NBITS_PACKET_CNT + NBITS_FRM_CNT + pau->m_cBitPackedFrameSize + 3;
    pau->m_cdwPacketHeader     = pau->m_cBitPacketHeader / BITS_PER_DWORD;
    pau->m_cBitPacketHeaderFractionDw = pau->m_cBitPacketHeader % BITS_PER_DWORD;
    pau->m_iPacketCurr = 0;

#ifdef ENABLE_ALL_ENCOPT
#ifdef ENABLE_LPC
    prvInitInverseQuadRootTable(pau);    
#endif  // ENABLE_LPC

    if (pau->m_iWeightingMode == BARK_MODE) 
    {
        if (!pau->m_fNoiseSub)   
            pau->aupfnInverseQuantize = NULL;
        else
            pau->aupfnInverseQuantize = prvInverseQuantizeMidRate;
    }
    else
        pau->aupfnInverseQuantize = prvInverseQuantizeLowRate;
#endif  // ENABLE_ALL_ENCOPT

    pau->m_iFrameNumber = 0;

    pau->aupfnReconstruct = auReconstruct;

#if !(defined( WMA_TARGET_MIPS ) && defined( BUILD_INTEGER ))
    pau->aupfnDctIV = auDctIV;
    pau->aupfnFFT = prvFFT4DCT;
#endif

    

#if defined(WMA_TARGET_X86) && !(defined(BUILD_INTEGER) || defined(UNDER_CE) || defined(_Embedded_x86))
    // auInitIntelFFT call checks CPU abilities for us (MMX, SIMD, etc)
    wmaResult = auInitIntelFFT(pau, INTELFFT_INIT_PROCESS);
    if (WMA_SUCCEEDED(wmaResult))
    {
        pau->aupfnFFT = prvFFT4DCT_INTEL;
        pau->m_fIntelFFT = WMAB_TRUE;
    }

    // Failure means no applicable optimizations. This isn't a fatal error, so suppress it.
    wmaResult = WMA_OK;

#endif  // WMA_TARGET_X86 && !BUILD_INTEGER

#ifdef USE_SIN_COS_TABLES
#ifdef WMA_TARGET_X86
#if 0 //def BUILD_INTEGER
      //This function has been removed because of a streaming mode bug that is can be reproduced
      //by setting the streaming mode buffer to 2003
    if (g_SupportMMX()){
        pau->aupfnReconstruct = auReconstruct_MMX;
    }
#endif //BUILD_INTEGER

#ifdef BUILD_INT_FLOAT

    pau->aupfnReconstruct = auReconstruct_X86;
    if (pau->m_cChannel==2) {
#ifdef _XBOX
        pau->aupfnReconstruct = auReconStereo_SIMDFP;
#else
        if (g_SupportMMX())
            pau->aupfnReconstruct = auReconStereo_MMX;

        if (g_SupportSSE1())
            pau->aupfnReconstruct = auReconStereo_SIMDFP;
#endif //XBOX
    }

#endif //BUILD_INT_FLOAT

#else
#pragma message( "Warning! USE_SIN_COS_TABLES defined but no functions are using them. See X86.c for prototype functions." )
#endif //WMA_TARGET_X86
#endif //USE_SIN_COS_TABLES

#ifdef WMA_TARGET_MIPS
#   ifdef BUILD_INTEGER
        auInitMIPS(pau);
#   endif //BUILD_INTEGER
#endif //WMA_TARGET_MIPS

        // This variable should be used only by the encoder
        pau->m_rgpcinfo[0].m_rgfMaskNeededForBark = NULL;
        if (pau->m_cChannel > 1)
            pau->m_rgpcinfo[1].m_rgfMaskNeededForBark = NULL;

exit:
    return wmaResult;
}
                                  


//*****************************************************************************************
//
// prvAllocate
// allocate arrays used by a CAudioObject
// part of auInit
//
//*****************************************************************************************
WMARESULT prvAllocate (CAudioObject* pau)
{
    WMARESULT   wmaResult = WMA_OK;

    const int c_iSizeOfPrevOutput = pau->m_nBytePerSample * DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf) * pau->m_cChannel;
#ifndef PREVOUTPUT_16BITS
    const int c_iSizeOfPrevOutputSign = DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf) * pau->m_cChannel / BITS_PER_BYTE 
                                        + pau->m_cChannel * pau->m_nBytePerSample; //wchen: not sure what this is for; but needed
#else 
    const int c_iSizeOfPrevOutputSign = 0;
#endif

    pau->m_rgpcinfo = (PerChannelInfo*) auMalloc (sizeof (PerChannelInfo) * pau->m_cChannel);
    if(pau->m_rgpcinfo == NULL)
    {
        wmaResult = TraceResult(WMA_E_OUTOFMEMORY);
        goto exit;
    }

    pau->m_piPrevOutput = (I16*) auMalloc (c_iSizeOfPrevOutput + c_iSizeOfPrevOutputSign);
    if (pau->m_piPrevOutput == NULL)
    {
        wmaResult = TraceResult(WMA_E_OUTOFMEMORY);
        goto exit;
    }
    memset (pau->m_piPrevOutput, 0, c_iSizeOfPrevOutput + c_iSizeOfPrevOutputSign);

    pau->m_rgiCoefReconOrig     = (Int*) mallocAligned (sizeof (Int) *
        DOUBLE(pau->m_fPad2XTransform,pau->m_cSubband) * pau->m_cChannel, 32);
    if (pau->m_rgiCoefReconOrig == NULL)
    {
        wmaResult = TraceResult(WMA_E_OUTOFMEMORY);
        goto exit;
    }
    memset (pau->m_rgiCoefReconOrig, 0, 
            sizeof (Int) * DOUBLE(pau->m_fPad2XTransform,pau->m_cSubband) * pau->m_cChannel);    

    pau->m_rgcValidBarkBand  = (Int*) auMalloc (sizeof (Int) * pau->m_cPossibleWinSize);
    if (pau->m_rgcValidBarkBand == NULL)
    {
        wmaResult = TraceResult(WMA_E_OUTOFMEMORY);
        goto exit;
    }

    pau->m_rgiBarkIndexOrig = (Int*) auMalloc (sizeof (Int) * (NUM_BARK_BAND + 1) * pau->m_cPossibleWinSize); //+1 : including bottom and top end
    if (pau->m_rgiBarkIndexOrig == NULL)
    {
        wmaResult = TraceResult(WMA_E_OUTOFMEMORY);
        goto exit;
    }
    
    prvSetBarkIndex (pau);
    pau->m_rgiMaskQ         = (Int*) auMalloc (sizeof (Int) * pau->m_cValidBarkBand * pau->m_cChannel);
    if (pau->m_rgiMaskQ == NULL)
    {
        wmaResult = TraceResult(WMA_E_OUTOFMEMORY);
        goto exit;
    }

    //for v2 it has to be dynamically decided
    if (pau->m_iVersion == 1) 
        pau->m_fltDctScale = (Float) sqrt (2.0 / pau->m_cSubbandAdjusted);


#ifdef ENABLE_ALL_ENCOPT
    // find the region to apply noise subsitution, in the frequencies...
    TRACEWMA_EXIT(wmaResult, prvInitNoiseSub (pau));

#if defined(_DEBUG) && defined(LPC_COMPARE)
    if (pau->m_iWeightingMode == LPC_MODE) {
        Int i;
        for (i = 0; i < LPCORDER; i++)  {
            pau->m_rgfltLpsSpecCos [i] = NULL;
            pau->m_rgfltLpsSpecSin [i] = NULL;
        }
    }
#endif

    if (pau->m_iWeightingMode == LPC_MODE && pau->m_rguiWeightFactor==NULL)
    {
        pau->m_rguiWeightFactor = (UInt*) auMalloc (sizeof (UInt) * DOUBLE(pau->m_fPad2XTransform,pau->m_cSubband) * pau->m_cChannel);
        if (pau->m_rguiWeightFactor == NULL)
        {
            wmaResult = TraceResult(WMA_E_OUTOFMEMORY);
            goto exit;
        }
    }

#endif // ENABLE_ALL_ENCOPT

#ifdef USE_SIN_COS_TABLES          
        pau->m_piSinForRecon2048 = (BP2Type*)g_SinTableForReconstruction;
        pau->m_piSinForRecon1024 = pau->m_piSinForRecon2048+2048;
        pau->m_piSinForRecon512  = pau->m_piSinForRecon1024+1024;
        pau->m_piSinForRecon256  = pau->m_piSinForRecon512+512;
        pau->m_piSinForRecon128  = pau->m_piSinForRecon256+256;
        pau->m_piSinForRecon64   = pau->m_piSinForRecon128+128;

        pau->m_piSinForSaveHistory = pau->m_piSinForRecon2048+2048;
#endif

exit:
    return wmaResult;
}


//*****************************************************************************************
//
// prvSetBarkIndex
// part of prvAllocate which is part of auInit
//
//*****************************************************************************************
Void prvSetBarkIndex (CAudioObject* pau)
{
    Int i, iWin;
    Float fltSamplingPeriod;

    Int *piBarkIndex;
    Int cFrameSample;
    Bool bCombined;

    //calculate index of each bark freq
    fltSamplingPeriod = 1.0F / pau->m_iSamplingRate;
    // wchen: we need to think what to do with the cut off frequencies: not include at all or include zeros.
    //for long window
    piBarkIndex = pau->m_rgiBarkIndexOrig;

    // for the v1 compatibility
    if(pau->m_iVersion == 1)
    {
        assert(pau->m_cPossibleWinSize == 1);

        // set up the bark index
        piBarkIndex[0] = 0;
        for (i = 0; i < NUM_BARK_BAND; i++)
        {
            piBarkIndex [i + 1] = (Int) (g_rgiBarkFreq [i] * pau->m_cFrameSample * 
                                         fltSamplingPeriod + 0.5f); //open end
            assert (piBarkIndex [i + 1]);
            if (piBarkIndex [i + 1] > pau->m_cFrameSample / 2)
            {
                piBarkIndex [i + 1] = pau->m_cFrameSample / 2;
                pau->m_rgcValidBarkBand [0] = i + 1;
                break;
            }
        }
    }
    else
    {
        for (iWin = 0; iWin < pau->m_cPossibleWinSize; iWin++)    {
            piBarkIndex  [0] = 0;
            cFrameSample = pau->m_cFrameSample / (1 << iWin);
            bCombined = WMAB_FALSE;
            if (pau->m_iSamplingRate >= 44100) {
                if(cFrameSample == 1024) { // winsize = 512
                    bCombined = WMAB_TRUE;
                    pau->m_rgcValidBarkBand[iWin] = 17;
                    piBarkIndex[1]  = 5;    piBarkIndex[2]  = 12;
                    piBarkIndex[3]  = 18;   piBarkIndex[4]  = 25;
                    piBarkIndex[5]  = 34;   piBarkIndex[6]  = 46;
                    piBarkIndex[7]  = 54;   piBarkIndex[8]  = 63;
                    piBarkIndex[9]  = 86;   piBarkIndex[10] = 102;
                    piBarkIndex[11] = 123;  piBarkIndex[12] = 149;
                    piBarkIndex[13] = 179;  piBarkIndex[14] = 221;
                    piBarkIndex[15] = 279;  piBarkIndex[16] = 360;
                    piBarkIndex[17] = 512;
                }
                else if(cFrameSample == 512) { // winsize = 256
                    bCombined = WMAB_TRUE;
                    pau->m_rgcValidBarkBand[iWin] = 15;
                    piBarkIndex[1]  = 5;    piBarkIndex[2]  = 11;
                    piBarkIndex[3]  = 17;   piBarkIndex[4]  = 23;
                    piBarkIndex[5]  = 31;   piBarkIndex[6]  = 37;
                    piBarkIndex[7]  = 43;   piBarkIndex[8]  = 51;
                    piBarkIndex[9]  = 62;   piBarkIndex[10] = 74;
                    piBarkIndex[11] = 89;   piBarkIndex[12] = 110;
                    piBarkIndex[13] = 139;  piBarkIndex[14] = 180;
                    piBarkIndex[15] = 256;
                }
                else if(cFrameSample == 256)  { // winsize = 128
                    bCombined = WMAB_TRUE;
                    pau->m_rgcValidBarkBand [iWin] = 12;
                    piBarkIndex[1]  = 4;   piBarkIndex[2]  = 9;
                    piBarkIndex[3]  = 12;  piBarkIndex[4]  = 16;
                    piBarkIndex[5]  = 21;  piBarkIndex[6]  = 26;
                    piBarkIndex[7]  = 37;  piBarkIndex[8]  = 45;
                    piBarkIndex[9]  = 55;  piBarkIndex[10] = 70;
                    piBarkIndex[11] = 90;  piBarkIndex[12] = 128;
                }
            }
            else if(pau->m_iSamplingRate >= 32000) {
                if(cFrameSample == 1024) { // winsize = 512
                    bCombined = WMAB_TRUE;
                    pau->m_rgcValidBarkBand[iWin] = 16;
                    piBarkIndex[1]  = 6;   piBarkIndex[2]  = 13;
                    piBarkIndex[3]  = 20;  piBarkIndex[4]  = 29;
                    piBarkIndex[5]  = 41;  piBarkIndex[6]  = 55;
                    piBarkIndex[7]  = 74;  piBarkIndex[8]  = 101;
                    piBarkIndex[9]  = 141; piBarkIndex[10] = 170;
                    piBarkIndex[11] = 205; piBarkIndex[12] = 246;
                    piBarkIndex[13] = 304; piBarkIndex[14] = 384;
                    piBarkIndex[15] = 496; piBarkIndex[16] = 512;
                }
                else if(cFrameSample == 512) { // winsize = 256
                    bCombined = WMAB_TRUE;
                    pau->m_rgcValidBarkBand[iWin] = 15;
                    piBarkIndex[1]  = 5;   piBarkIndex[2]  = 10;
                    piBarkIndex[3]  = 15;  piBarkIndex[4]  = 20;
                    piBarkIndex[5]  = 28;  piBarkIndex[6]  = 37;
                    piBarkIndex[7]  = 50;  piBarkIndex[8]  = 70;
                    piBarkIndex[9]  = 85;  piBarkIndex[10] = 102;
                    piBarkIndex[11] = 123; piBarkIndex[12] = 152;
                    piBarkIndex[13] = 192; piBarkIndex[14] = 248;
                    piBarkIndex[15] = 256;
                }
                else if(cFrameSample == 256)  { // winsize = 128
                    bCombined = WMAB_TRUE;
                    pau->m_rgcValidBarkBand [iWin] = 11;
                    piBarkIndex[1]  = 4;   piBarkIndex[2]  = 9;
                    piBarkIndex[3]  = 14;  piBarkIndex[4]  = 19;
                    piBarkIndex[5]  = 25;  piBarkIndex[6]  = 35;
                    piBarkIndex[7]  = 51;  piBarkIndex[8]  = 76;
                    piBarkIndex[9]  = 96;  piBarkIndex[10] = 124;
                    piBarkIndex[11] = 128;
                }
            }
            else if(pau->m_iSamplingRate >= 22050) {
                if(cFrameSample == 512) { // winsize = 256
                    bCombined = WMAB_TRUE;
                    pau->m_rgcValidBarkBand [iWin] = 14;
                    piBarkIndex[1]  = 5;   piBarkIndex[2]  = 12;
                    piBarkIndex[3]  = 18;  piBarkIndex[4]  = 25;
                    piBarkIndex[5]  = 34;  piBarkIndex[6]  = 46;
                    piBarkIndex[7]  = 63;  piBarkIndex[8]  = 86;
                    piBarkIndex[9]  = 102; piBarkIndex[10] = 123;
                    piBarkIndex[11] = 149; piBarkIndex[12] = 179;
                    piBarkIndex[13] = 221; piBarkIndex[14] = 256;
                }
                else if(cFrameSample == 256) { // winsize = 128
                    bCombined = WMAB_TRUE;
                    pau->m_rgcValidBarkBand [iWin] = 10;
                    piBarkIndex[1]  = 5;   piBarkIndex[2]  = 11;
                    piBarkIndex[3]  = 17;  piBarkIndex[4]  = 23;
                    piBarkIndex[5]  = 31;  piBarkIndex[6]  = 43;
                    piBarkIndex[7]  = 62;  piBarkIndex[8]  = 89;
                    piBarkIndex[9]  = 110; piBarkIndex[10] = 128;
                }
            }

            if(!bCombined)
            {
                Float fltTemp = cFrameSample*fltSamplingPeriod;
                Int iIndex;
                Int iFreqCurr = 0;
                Int iCurr = 1;
                while(WMAB_TRUE)
                {
                    iIndex = ((Int) ((g_rgiBarkFreq [iFreqCurr++]*fltTemp + 2.0f)/4.0f))*4; // open end

                    if(iIndex > piBarkIndex[iCurr - 1])
                        piBarkIndex[iCurr++] = iIndex;

                    if(iFreqCurr >= NUM_BARK_BAND ||
                       piBarkIndex[iCurr - 1] > cFrameSample/2)
                    {
                        piBarkIndex[iCurr - 1] = cFrameSample/2;
                        pau->m_rgcValidBarkBand[iWin] = iCurr - 1;
                        break;
                    }
                }
            }
            else
            {
                for (i = 0; i < pau->m_rgcValidBarkBand [iWin]; i++) {
                    piBarkIndex [i + 1] = ((piBarkIndex [i + 1] + 2) / 4) * 4;  //rounding
                    assert (piBarkIndex [i + 1] > piBarkIndex [i]);
                }
            }

            piBarkIndex +=  NUM_BARK_BAND + 1;
        }
    }
    //default
    pau->m_rgiBarkIndex = pau->m_rgiBarkIndexOrig;
    pau->m_cValidBarkBand = pau->m_rgcValidBarkBand [0];

#ifdef DEBUG
    // checking for multiples of 4!!!
    if(pau->m_iVersion != 1)
    {
        Int iWin, iBand;
        for(iWin = 0; iWin < pau->m_cPossibleWinSize; iWin++)
        {
            for(iBand = 0; iBand <= pau->m_rgcValidBarkBand[iWin]; iBand++)
            {
                i = pau->m_rgiBarkIndexOrig[iWin*(NUM_BARK_BAND + 1) + iBand];
                assert(i%4 == 0);
            }
        }
    }
#endif // DEBUG

}


#ifdef BUILD_INTEGER
#define COEF m_rgiCoefRecon
#else   // BUILD_INTEGER
#define COEF m_rgfltCoefRecon
#endif  // BUILD_INTEGER

Void auPreGetPCM (CAudioObject* pau, U16* pcSampleDecoded)
{
    I16 iChannel;
    Int iWinDiff;

    //set up for getPCM
    for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) 
    {
        PerChannelInfo* ppcinfo = pau->m_rgpcinfo + iChannel;
        ppcinfo->m_rgiCoefReconCurr = ((I32*) ppcinfo->COEF) + pau->m_cSubbandAdjusted /2;
        ppcinfo->m_iCurrGetPCM_SubFrame = 0;       //current position in a subframe
        ppcinfo->m_piPrevOutputCurr = ppcinfo->m_piPrevOutput;
        //start recursion
        ppcinfo->m_iSin  = SIN_START;
        ppcinfo->m_iCos  = COS_START;
        ppcinfo->m_iSin1 = SIN1_START;
        ppcinfo->m_iCos1 = COS1_START;
	    ppcinfo->m_iStep = SIN_STEP;
    }

    *pcSampleDecoded = (U16) pau->m_cSubFrameSampleHalfAdjusted;
    iWinDiff = pau->m_iSizeCurr - pau->m_iSizePrev;
    if (iWinDiff > 0)   {
        *pcSampleDecoded -= (U16)(iWinDiff >> 1);
        for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) 
        {
            PerChannelInfo* ppcinfo = pau->m_rgpcinfo + iChannel;
            ppcinfo->m_rgiCoefReconCurr += iWinDiff >> 1;
            ppcinfo->m_iCurrGetPCM_SubFrame += (I16)(iWinDiff >> 1);
            assert(0<=ppcinfo->m_iCurrGetPCM_SubFrame && ppcinfo->m_iCurrGetPCM_SubFrame<=pau->m_cSubFrameSampleHalfAdjusted);
        }
    }
    iWinDiff = pau->m_iSizeCurr - pau->m_iSizeNext;
    if (iWinDiff > 0)
        *pcSampleDecoded += (U16)(iWinDiff >> 1);

    if (CODEC_BEGIN == pau->m_codecStatus)
        prvInitDiscardSilence(pau);
    else if (pau->m_fPacketLossAdj == WMAB_TRUE) //being seeked
        pau->m_iDiscardSilence = pau->m_iCoefRecurQ2 - pau->m_iCoefRecurQ1;
    pau->m_fPacketLossAdj = WMAB_FALSE;

    // Check if the samples we just generated are to be discarded (silence)
    // We want to only return what the user should expect to get back from auGetPCM
    if (pau->m_iDiscardSilence)
    {
        U16         uSilence;
        Bool        fUpdateTrig;

        // Part or all of the samples just generated will be discarded.
        if (pau->m_iDiscardSilence >= *pcSampleDecoded)
        {
            // ALL of the samples just generated will be discarded

            uSilence = *pcSampleDecoded;
            *pcSampleDecoded = 0;
            fUpdateTrig = WMAB_FALSE;
        }
        else
        {
            // We don't want to overreport what user will get back from auGetPCM,
            // so subtract the silence.
            uSilence = (U16) pau->m_iDiscardSilence;
            *pcSampleDecoded -= (U16) pau->m_iDiscardSilence;

            // The trigonometry is going to be used after this to compute PCM
            // Update it now as if we had called auGetPCM
            fUpdateTrig = WMAB_TRUE;
        }

        // SIMULATE call to auGetPCM on behalf of the user to flush silence bits out
        // Avoid calling auGetPCM to discard silence because the temporary buffer
        // needed is objectionable to small devices

        // First, do things that auReconMono would normally do
        for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)
        {
            PerChannelInfo *ppcinfo = &pau->m_rgpcinfo[iChannel];
            const U16 uSilenceQ2MAX = (const U16) min(pau->m_iCoefRecurQ2 -
                ppcinfo->m_iCurrGetPCM_SubFrame, uSilence);
            Int iCoefCount;
            Int iCoefCountMAX;
            I32 iCoefPtrOffset;
            Int iCoefDelta;


            // Need to simulate movement of coefficient ptr in auGetPCM
            iCoefCount = ppcinfo->m_iCurrGetPCM_SubFrame;
            iCoefCountMAX = iCoefCount + uSilence;
            iCoefPtrOffset = 0;
            if (iCoefCount < pau->m_cSubFrameSampleQuadAdjusted)
            {
                iCoefDelta = min(iCoefCountMAX, pau->m_cSubFrameSampleQuadAdjusted) - iCoefCount;
                iCoefPtrOffset += iCoefDelta;
                iCoefCount += iCoefDelta;
            }

            if (iCoefCount < pau->m_iCoefRecurQ2)
            {
                iCoefDelta = min(iCoefCountMAX, pau->m_iCoefRecurQ2) - iCoefCount;
                iCoefPtrOffset -= iCoefDelta;
                iCoefCount += iCoefDelta;
            }

            if (iCoefCount < pau->m_iCoefRecurQ3)
            {
                iCoefDelta = min(iCoefCountMAX, pau->m_iCoefRecurQ3) - iCoefCount;
                iCoefPtrOffset -= iCoefDelta;
                iCoefCount = iCoefDelta;
            }

            assert(iCoefCount <= uSilence);
            ppcinfo->m_rgiCoefReconCurr += iCoefPtrOffset;
            ppcinfo->m_piPrevOutputCurr += uSilenceQ2MAX * pau->m_cChannel;
            ppcinfo->m_iCurrGetPCM_SubFrame += uSilence;

            if (fUpdateTrig)
            {
                Int         iSize;
                BP2Type     bpSinA;
                BP2Type     bpCosA;
                BP2Type     bpSinB;
                BP2Type     bpCosB;
                Int         iMultiplier;

                //if the adjacent size is bigger; just keep your own shape
                //otherwise a transition window is needed.
                if (pau->m_iSizePrev >= pau->m_iSizeCurr)
                {
                    //just forward copy curr
		            iSize = pau->m_iSizeCurr;
                }
                else
                {
                    //long start
		            iSize = pau->m_iSizePrev;
                }


                // It turns out that uSilenceQ2MAX is either equal to iSize
                // or equal to half of it. Our trig then simplifies to
                // sin(pi/(4*iSize) + pi/X) where X = 2 or 4.
                // Use trig ID's below to calculate these values.
                bpSinA = *((BP2Type*)(&ppcinfo->m_iSin));
                bpCosA = *((BP2Type*)(&ppcinfo->m_iCos));
                assert(uSilenceQ2MAX == iSize || uSilenceQ2MAX * 2 == iSize);
                iMultiplier = iSize / uSilenceQ2MAX;
                switch(iMultiplier)
                {
                    case 1:
                        bpSinB = BP2_FROM_FLOAT(1.0); // sin(pi/2)
                        bpCosB = BP2_FROM_FLOAT(0.0); // cos(pi/2)
                        break;

                    case 2:
                        bpSinB = BP2_FROM_FLOAT(0.70710678118654752440084436210485); // sin(pi/4)
                        bpCosB = BP2_FROM_FLOAT(0.70710678118654752440084436210485); // cos(pi/4)
                        break;

                    default:
                        assert(WMAB_FALSE);
                        break;
                }

                // Let A = start = pi/(4*iSize), B = pi/X where X = 2 or 4.
                // Trig ID's: sin(A+B) = sin(A)cos(B) + cos(A)sin(B)
                //            cos(A+B) = cos(A)cos(B) + sin(A)sin(B)
                // To get the prior step for recursion, note that subtracting
                // a step (step = 2*A) and simplifying gets us to
                // sin(pi/X - pi/(4*iSize)) where X = 2 or 4.
                *(BP2Type*)(&ppcinfo->m_iSin)  = MULT_BP2(bpSinA, bpCosB) +
                    MULT_BP2(bpCosA, bpSinB);
                *(BP2Type*)(&ppcinfo->m_iCos)  = MULT_BP2(bpCosA, bpCosB) -
                    MULT_BP2(bpSinA, bpSinB);
                *(BP2Type*)(&ppcinfo->m_iSin1) = MULT_BP2(bpSinB, bpCosA) -
                    MULT_BP2(bpCosB, bpSinA);
                *(BP2Type*)(&ppcinfo->m_iCos1) = MULT_BP2(bpCosB, bpCosA) +
                    MULT_BP2(bpSinB, bpSinA);

                // Check the accuracy
                assert(fabs(FLOAT_FROM_BP2(*((BP2Type*)(&ppcinfo->m_iSin))) -
                    sin(0.5 * PI / iSize / 2 * (2*uSilenceQ2MAX + 1))) <= 0.001);
                assert(fabs(FLOAT_FROM_BP2(*((BP2Type*)(&ppcinfo->m_iCos))) -
                    cos(0.5 * PI / iSize / 2 * (2*uSilenceQ2MAX + 1))) <= 0.001);
                assert(fabs(FLOAT_FROM_BP2(*((BP2Type*)(&ppcinfo->m_iSin1))) -
                    sin(0.5 * PI / iSize / 2 * (2*uSilenceQ2MAX - 1))) <= 0.001);
                assert(fabs(FLOAT_FROM_BP2(*((BP2Type*)(&ppcinfo->m_iCos1))) -
                    cos(0.5 * PI / iSize / 2 * (2*uSilenceQ2MAX - 1))) <= 0.001);

            }
        }

#ifdef USE_SIN_COS_TABLES
        if (fUpdateTrig && pau->m_rgpcinfo[0].m_iCurrGetPCM_SubFrame < pau->m_iCoefRecurQ2)
        {
            const U16 uSilenceQ2MAX = (const U16) min(pau->m_iCoefRecurQ2 -
                pau->m_rgpcinfo[0].m_iCurrGetPCM_SubFrame, uSilence);

            pau->m_piSinForRecon += uSilenceQ2MAX; // Shared by both channels
        }
#endif  // USE_SIN_COS_TABLES

        // Next, do the things that auGetPCM would normally do
        pau->m_iDiscardSilence -= uSilence;
        assert(pau->m_iDiscardSilence >= 0);
        if (CODEC_BEGIN == pau->m_codecStatus)
            pau->m_codecStatus = CODEC_STEADY;

    }
}


WMARESULT auReconstruct (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll){
    Int iChannel;
    WMARESULT hr;
    for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)
    {
        hr = (auReconMono) (pau, 
                          pau->m_rgpcinfo + iChannel, 
                          piOutput + iChannel,  
                          (I16*)pcSampleGet,
                          fForceTransformAll);
    }
    return hr;
}


WMARESULT auGetPCM (CAudioObject* pau, U16* pcSample, U8* pbDst, U32 cbDstLength)
{  
    Int cbDstUsed;
    Int* pcbDstUsed = &cbDstUsed;
    WMARESULT hr;
    I16* piOutput = (I16*) pbDst;

    U32 cSamplesLeft;
    I16 cSamplesREQ;

    cSamplesLeft = *pcSample;
    do
    {
        const U32 cMaxSamplesInDst = (cbDstLength / sizeof (I16) / pau->m_cChannel);

        // Limit requested number of bytes to fit within the buffer
        const U32 u32MaxSamplesReq = min(cSamplesLeft, cMaxSamplesInDst);

        // limit request to fit in I16
        cSamplesREQ = (I16) min(u32MaxSamplesReq, SHRT_MAX);

        hr = (*pau->aupfnReconstruct) (pau,
                          piOutput,
                          &cSamplesREQ,
                          WMAB_FALSE);

        cSamplesLeft -= cSamplesREQ;
        if (0 == cSamplesREQ)
            // No more samples to retrieve, the well is dry. Avoid infinite loop
            break;

        // Check if we just reconstructed silence that we need to toss
        if (pau->m_iDiscardSilence)
            prvDiscardSilence(pau, (unsigned short *)&cSamplesREQ, pau->m_cChannel, pbDst);

    } while (0 == cSamplesREQ && 0 != cSamplesLeft);

    if (CODEC_BEGIN == pau->m_codecStatus)
        pau->m_codecStatus = CODEC_STEADY;

    *pcSample = cSamplesREQ;
    *pcbDstUsed = (*pcSample) * pau->m_cChannel * sizeof (I16); // in bytes

#   ifdef INTERPOLATED_DOWNSAMPLE
        if (pau->m_fDownsample) {
            prvInterpolate(pau, piOutput, *pcbDstUsed, pau->m_cChannel,
                piOutput, pcbDstUsed, pcSample);
        }
#   endif  // INTERPOLATED_DOWNSAMPLE

#if defined(HALF_TRANSFORM)
    // interpolate 2X 
    // This simple linear interpolation is fast but does not remove aliasing 
    // So it should not be used with the HALF_TRANSFORM case if audio quality is important
    if (pau->m_fUpsample && *pcbDstUsed > 0)
    {
        // work from back of buffer to front so we do not overwrite any values we still need to use
        Int iChannel;
        Int iSamplesPerChannel = *pcbDstUsed / (sizeof(I16) * pau->m_cChannel);
        const int c_iDecr = pau->m_cChannel;

        for (iChannel = 0; iChannel < c_iDecr; iChannel++)
        {

            I16 *piInput = piOutput + iChannel + (iSamplesPerChannel - 1) * c_iDecr;
            I16 *piOutputx = piOutput + iChannel + (2 * iSamplesPerChannel - 1) * c_iDecr;
            I16 iNextInput, iPrevInput;

            iNextInput = *piInput;
            while (piOutputx > (piOutput + iChannel + 2))
            {
                assert(piOutputx >= piInput + iChannel);
                *piOutputx = iNextInput;
                piOutputx -= c_iDecr;

                iPrevInput = iNextInput;

                piInput  -= c_iDecr;
                assert(piInput >= (piOutput + iChannel));
                iNextInput = *piInput;

                assert(piOutputx >= piInput + iChannel);
                *piOutputx = (iPrevInput >> 1) + (iNextInput >> 1);
                assert(fabs((double)(*piOutputx) - ((double)iPrevInput +
                    (double)iNextInput)/2.0) <= 1);

                piOutputx -= c_iDecr;
            }

            // handle beginning of buffer case
            assert( piOutputx == piOutput + iChannel + 2);
            *piOutputx = iNextInput;
            piOutputx -= c_iDecr;

            iPrevInput = iNextInput;

            assert(piInput >= (piOutput + iChannel));
            iNextInput = pau->m_iPriorSample[iChannel];

            assert(piOutputx >= piInput);
            *piOutputx = (iPrevInput >> 1) + (iNextInput >> 1);
            assert(fabs((double)(*piOutputx) - ((double)iPrevInput +
                (double)iNextInput)/2.0) <= 1);

            pau->m_iPriorSample[iChannel] = *(piOutput + iChannel + (2 * iSamplesPerChannel - 1) * c_iDecr);

        }

        *pcSample   *= 2;
        *pcbDstUsed *= 2;
    }
#endif  // defined(HALF_TRANSFORM)

    //FUNCTION_PROFILE_STOP(&fp);
    return WMA_OK;

}

//*****************************************************************************************
//
// prvInverseTransformMono
//  transform, window and combine an overlapping subframe of audio data
//  called repeatedly for each subframe in a frame
// 
//  using abbreviated names, the process in outline form is as follows:
//  
//      pSrc points to someplace in current or previous time-domain Output array
//      pDst points to someplace in current or previous time-domain Output array
//      between each "upto" step below, these two points may change
//
//      Coef is an array of frequency-domain coefs
//
//      call DCT and transform Coef to time-domain
//      pCoef set to middle of the now time-domain coeffiecents
//
//      Window and combine the transformed Coef and pSrc into pDst as follows:
//
//      Window
//                  ________________
//                 /                \
//                /                  \
//               /                    \
//      ________/                      \_________
//      |       | | |       |      | | |         |
//      0       Q Q Q       H      Q 3 Q         F
//              1 u 2       a      3 Q 4         u
//                a         l        u           l
//                d         f        a           l
//                                   d
//      
//      upto Q1 (eg 0): 
//          Dst <- Src                              [[++pDst, ++pCoef, ++pSrc]]
//
//      upto cSubFrameSampleQuad (eg 1024):
//          Dst <- ( sin(a) * Coef + Src<<5 ) >> 5  [[++pDst, ++pCoef, ++pSrc, ++a]]
//
//      upto Q2 (eg 2048):
//          Dst <- ( sin(a) * Coef + Src<<5 ) >> 5  [[++pDst, --pCoef, ++pSrc, ++a]]
//
//      upto cSubFrameSampleHalf (eg 2048):
//          Dst <- Coef >> 5                        [[++pDst, --pCoef]]
//
//      upto Q3 (eg 2944):
//          Dst <- Coef >> 5                        [[++pDst, --pCoef]]
//
//      upto 3 * cSubFrameSampleQuad (eg 3072):
//          Dst <- ( sin(a) * Coef ) >> 5;          [[++pDst, --pCoef]]
//      
//      upto Q4 (eg 3200):
//          Dst <- ( sin(a) * Coef ) >> 5;          [[++pDst, ++pCoef]]
//
//
//  
//  Values decoding the first few frames of Tough_44m_64.cmp (9/22/99 12:08PM version)
//  where pDst is relative to piOutput when c. and to piPrevOutput when p.
//
//                          iCurrSubFrame       iSubFrmOffset   pDst prior to loop:
//              FrameSample         cSubFrameSample               Q1     Q2     Q3     Q4
//                              
//  Decode             4096
//    inverseTransform          0       4096           0        c....0 c.1024 p....0 p.1024
//  Decode             4096
///   inverseTransform          0       2048         512        c..512 c.1024 c.1536 p....0
//    inverseTransform          1        256        1984        c.1984 p....0 p...64 p..128
//    inverseTransform          2        256        2112        p...64 p. 128 p..192 p..256
//    inverseTransform          3        256        2240        p. 192 p. 256 p..320 p..384
//    inverseTransform          4        256        2368        p..320 p..320 p..448 p..512
//    inverseTransform          5       1024        2304        p..256 p..512 p..768 p.1024
//  Decode             4096
//    inverseTransform          0       4096           0        c....0 c.1024 p....0 p.1024
//  Decode             4096
//    inverseTransform          0       4096           0        c....0 c.1024 p....0 p.1024
//  Decode             4096
//    inverseTransform          0       4096           0        c....0 c.1024 p....0 p.1024
//  Decode             4096
//    inverseTransform          0       2048         512        c..512 c.1024 c.1536 p....0
//    inverseTransform          1        512        1920        c.1920 p....0 p..128 p..256
//    inverseTransform          2        256        2240        p..192 p..256 p..320 p..384
//    inverseTransform          3        256        2368        p..320 p..384 p..448 p..512
//    inverseTransform          4        256        2496        p..448 p..512 p..576 p..640
//    inverseTransform          5        256        2624        p..576 p..640 p..704 p..768
//    inverseTransform          6        512        2688        p..640 p..768 p..896 p.1024
//
//*****************************************************************************************

#if defined(_DEBUG)
// Debugging Macros to break at a particular output sample or when sample values are out of range or to print sin values
//
// set IT_BREAK_AT_SAMPLE to a non-negative value to break when that sample is about to be processed
//#define IT_BREAK_AT_SAMPLE -2049
//
// set IT_BREAK_OUT_OF_RANGE to a positive value to break when a sample is stored out of the range
//#define IT_BREAK_OUT_OF_RANGE 32767
//#define IT_BREAK_OUT_OF_RANGE_PAST_SAMPLE 475500
//
// set IT_SIN_PRINT_ALL to print out all sin values as they are used
//#define IT_SIN_PRINT_ALL
//
// set IT_SIN_PRINT_INIT to print out initial sin values as they are used
//#define IT_SIN_PRINT_INIT
//
// set IT_SAMPLE_PRINT to print out sample values as they are generated
//#define IT_SAMPLE_PRINT
// 
// set IT_FRAME_PRINT to print out sample values as they are generated
//#define IT_FRAME_PRINT
// 
#   if defined(IT_BREAK_AT_SAMPLE) || defined(IT_BREAK_OUT_OF_RANGE)|| defined(IT_SIN_PRINT_ALL) \
    || defined(IT_SIN_PRINT_INIT) || defined(IT_SAMPLE_PRINT) || defined(IT_FRAME_PRINT)
#       pragma COMPILER_MESSAGE(__FILE__ "(1101) : Warning - Inverse Transform Debug Code Enabled.")
#       if defined(IT_BREAK_AT_SAMPLE)
            static int nSampleBreak = IT_BREAK_AT_SAMPLE;
#       else
            static int nSampleBreak = -2049;
#       endif
        static int nSampleBreakIdx = -2048;             // correction factor for startup
        static int nSampleBreakFrameSample = 0;         // prior frame's sample size
        static int iSubFrmOffset = 0;                   // Needed to add after merging with wchen's 12/17/99 checkin ???
#   endif
#   define IT_NO_SIN 0x7FEDCBA9
    static double dIorF2F = INTEGER_OR_INT_FLOAT(1.0/NF2BP2,1.0);
#   if defined(IT_SIN_PRINT_ALL)
#       define IT_DO_SIN_PRINT(idx1,idx2,v)                                     \
            if (v != IT_NO_SIN)                                                 \
                printf("%8d %4d %+.10f\n", idx1, idx2, v*dIorF2F )
#   else
#       define IT_DO_SIN_PRINT(a,b,c)
#   endif
#   if defined(IT_SAMPLE_PRINT)
#       define IT_DO_SAMPLE_PRINT(idx1,idx2,v) \
                printf("%8d %4d %+10d\n", idx1, idx2, (I32)v )
#   else
#       define IT_DO_SAMPLE_PRINT(a,b,c)
#   endif
#   if defined(IT_FRAME_PRINT)
#       define IT_DO_FRAME_PRINT                                                \
            if ( pau->m_iFrameNumber==0 )                                       \
                printf("\n");                                                   \
            printf("Frame %4d  SubFrm %2d  SFSamples %4d\n", pau->m_iFrameNumber, pau->m_iCurrSubFrame, pau->m_cSubFrameSampleAdjusted )
#   else
#       define IT_DO_FRAME_PRINT
#   endif
#   if defined(IT_BREAK_AT_SAMPLE) && defined(IT_BREAK_OUT_OF_RANGE)
#       define DEBUG_IT_SAMPLE_BREAK(idx,Dst,iSin)                              \
            if ( (nSampleBreakIdx+idx+iSubFrmOffset) == nSampleBreak || Dst < -IT_BREAK_OUT_OF_RANGE || Dst > IT_BREAK_OUT_OF_RANGE ) \
                DEBUG_BREAK();                                                  \
            IT_DO_SIN_PRINT(nSampleBreakIdx+idx+iSubFrmOffset,idx,iSin);        \
            IT_DO_SAMPLE_PRINT(nSampleBreakIdx+idx+iSubFrmOffset,idx,Dst)
#   elif defined(IT_BREAK_AT_SAMPLE)
#       define DEBUG_IT_SAMPLE_BREAK(idx,Dst,iSin)                              \
            if ( (nSampleBreakIdx+idx+iSubFrmOffset) == nSampleBreak )          \
                DEBUG_BREAK();                                                  \
            IT_DO_SIN_PRINT(nSampleBreakIdx+idx+iSubFrmOffset,idx,iSin);        \
            IT_DO_SAMPLE_PRINT(nSampleBreakIdx+idx+iSubFrmOffset,idx,Dst)
#   elif defined(IT_BREAK_OUT_OF_RANGE)
#       define DEBUG_IT_SAMPLE_BREAK(idx,Dst,iSin)                              \
            if ( ( Dst < -IT_BREAK_OUT_OF_RANGE || Dst > IT_BREAK_OUT_OF_RANGE )\
                 && (nSampleBreakIdx+idx+iSubFrmOffset) > IT_BREAK_OUT_OF_RANGE_PAST_SAMPLE )  \
                DEBUG_BREAK();                                                  \
            IT_DO_SIN_PRINT(nSampleBreakIdx+idx+iSubFrmOffset,idx,iSin);        \
            IT_DO_SAMPLE_PRINT(nSampleBreakIdx+idx+iSubFrmOffset,idx,Dst)
#   else
#       define DEBUG_IT_SAMPLE_BREAK(idx,Dst,iSin)                              \
            IT_DO_SIN_PRINT(nSampleBreakIdx+idx+iSubFrmOffset,idx,iSin);        \
            IT_DO_SAMPLE_PRINT(nSampleBreakIdx+idx+iSubFrmOffset,idx,Dst)
#   endif
#   if defined(IT_SIN_PRINT_INIT)
#       define DEBUG_IT_SIN_INIT(n,a,b,c,d,e)   \
                printf("%d  %+.10f  %+.10f  %+.10f  %+.10f  %+.10f\n", n, a*dIorF2F, b*dIorF2F, c*dIorF2F, d*dIorF2F, e*dIorF2F )
#   else
#       define DEBUG_IT_SIN_INIT(n,a,b,c,d,e)
#   endif
#   if defined(IT_BREAK_AT_SAMPLE) || defined(IT_BREAK_OUT_OF_RANGE) || defined(IT_SIN_PRINT_ALL) || defined(IT_SIN_PRINT_INIT)
        // break when nSampleBreak is within subframe
#       define DEBUG_IT_FRAME_BREAK \
            if ( pau->m_iCurrSubFrame == 0 && ppcinfo == pau->m_rgpcinfo )      \
            {   /* on first subframe of left channel */                         \
                nSampleBreakIdx += nSampleBreakFrameSample;                     \
                nSampleBreakFrameSample = pau->m_cFrameSampleHalfAdjusted;      \
            }                                                                   \
            IT_DO_FRAME_PRINT;                                                  \
            if ( nSampleBreakIdx+iSubFrmOffset <= nSampleBreak && nSampleBreak < (nSampleBreakIdx+iSubFrmOffset+pau->m_cSubFrameSampleAdjusted) )   \
                DEBUG_BREAK();
#   else
#       define DEBUG_IT_FRAME_BREAK
#   endif
#else
#   define DEBUG_IT_FRAME_BREAK
#   define DEBUG_IT_SAMPLE_BREAK(a,b,c)
#   define IT_NO_SIN 0x40000000
#   define DEBUG_IT_SIN_INIT(n,a,b,c,d,e)
#endif

#if defined(WMA_TARGET_SH4) && defined(BUILD_INT_FLOAT) && !defined(PREVOUTPUT_16BITS) && !defined(V4V5_COMPARE_MODE)

// for this build config find auReconMono and auSaveHistoryMono in sh4\transform_sh4.c 

#elif defined(WMA_TARGET_SH3) && defined(BUILD_INTEGER) && !defined(PREVOUTPUT_16BITS) && !defined(V4V5_COMPARE_MODE)

// for this build config find auReconMono and auSaveHistoryMono in sh3\transform_sh3.c

#elif defined(WMA_TARGET_MIPS) && defined(BUILD_INTEGER) && !defined(PREVOUTPUT_16BITS) && !defined(V4V5_COMPARE_MODE)

// for this build config find auReconMono and auSaveHistoryMono in mips\transform_mips_*.c

#else


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
// auReconMono and auSaveHistoryMono for either Integer and Float

WMARESULT auReconMono ( CAudioObject* pau, 
                        PerChannelInfo* ppcinfo, 
                        I16* piOutput, 
                        I16* pcSampleGet,
                        Bool fForceTransformAll)
{
    //all starting from the begining of this frame
    //official starting of a subfrm (including leading zeros)
    //case 1 (Large -> Small):  starts later than what's been reconstructed w/o leading zeros
    //                          in this case dst should be skiped (this may mean memcpy from prev)
    //                          src and coef are fine
    //                          
    //case 2 (Small -> Large):  starts earler than what's been reconstructed but all leading zeros
    //                          in this case dst 

    BP2Type bp2SinT;     //temp sin value within recurrsion
    BP2Type bp2CosT;     //temp cos value within recurrsion
    CoefType *piCoef;   //floating vlaue = (float)*piCoef/(1<<5)  assuming TRANSFORM_FRACT_BITS = 5
    Int i, iEnd, iSegEnd;
    I16 *piSrc, *piDst; 
    I32 iResult;
    CoefType cfResult;
    // get local copies of these values which are used frequently or repeatedly (helps optimization)
    Int cChan = pau->m_cChannel;
    Int cSubFrameSampleHalf = pau->m_cSubFrameSampleHalfAdjusted;
    Int cSubFrameSampleQuad = pau->m_cSubFrameSampleQuadAdjusted;
    Int iCoefRecurQ2 = pau->m_iCoefRecurQ2;
    Int iCoefRecurQ3 = pau->m_iCoefRecurQ3;
    BP2Type bp2Sin  = *((BP2Type*)(&ppcinfo->m_iSin));
    BP2Type bp2Cos  = *((BP2Type*)(&ppcinfo->m_iCos));
    BP2Type bp2Sin1 = *((BP2Type*)(&ppcinfo->m_iSin1));
    BP2Type bp2Cos1 = *((BP2Type*)(&ppcinfo->m_iCos1));
    BP2Type bp2Step = *((BP2Type*)(&ppcinfo->m_iStep));
    int fTrigUpdated = 0;

#ifndef PREVOUTPUT_16BITS
    I16    *piSrcSign;
    U32     uiSignbitData;
    U32     uiSignbitCount;
#endif  // PREVOUTPUT_16BITS
#ifdef PROFILE
    FunctionProfile fp;
    FunctionProfileStart(&fp,RECON_MONO_PROFILE);
#endif
    DEBUG_IT_FRAME_BREAK;

    //persistent states
    i = ppcinfo->m_iCurrGetPCM_SubFrame;       //current position in a frame
    piCoef = (CoefType*)ppcinfo->m_rgiCoefReconCurr; 
    piSrc = ppcinfo->m_piPrevOutputCurr;

    //eventually we'll use piOutput directly
    piDst = piOutput;

    iEnd = i + *pcSampleGet;
    *pcSampleGet = 0;

    CALC_SIGN_OFFSETS(ppcinfo->m_piPrevOutput, piSrc, ppcinfo->m_piPrevOutputSign, piSrcSign, 
        uiSignbitData, uiSignbitCount, cChan)
    ASSERT_SIGNBIT_POINTER(piSrcSign);

#if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
    iSegEnd = 0;
    if (i < cSubFrameSampleQuad) iSegEnd = min (cSubFrameSampleQuad, iEnd);
    if (iSegEnd < iCoefRecurQ2)  iSegEnd = min (iCoefRecurQ2, iEnd);
    if (iSegEnd < iCoefRecurQ3)  iSegEnd = min (iCoefRecurQ3, iEnd);
    if ( i < iSegEnd )
        prvWmaShowFrames(pau, "RecMono", " %4d 0x%08x 0x%08x 0x%08x %4d %4d %4d %4d", 
            i, piCoef, piSrc, piDst, cSubFrameSampleQuad, iCoefRecurQ2, iCoefRecurQ3, iSegEnd);
#endif
    if (i < cSubFrameSampleQuad) 
    {
        DEBUG_IT_SIN_INIT(0,bp2Sin,bp2Cos,bp2Sin1,bp2Cos1,bp2Step);
        iSegEnd = min (cSubFrameSampleQuad, iEnd);
        if ( i < iSegEnd )
        {
            fTrigUpdated = 1;
            for (; i < iSegEnd; i++, (*pcSampleGet)++)    {

                COMBINE_SIGNBIT(iResult, *piSrc, piSrcSign, uiSignbitData,
                    uiSignbitCount);

                cfResult = INT_FROM_COEF( MULT_BP2(-bp2Sin,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );

                DEBUG_IT_SAMPLE_BREAK(i,  iResult, bp2Sin);

                piSrc += cChan;
                piDst += cChan;
                // sin(a+b) = sin(a-b) + 2*sin(b)*cos(a)
                // cos(a+b) = cos(a-b) - 2*sin(b)*sin(a)
                bp2SinT = bp2Sin1 + MULT_BP2(bp2Step,bp2Cos);
                bp2CosT = bp2Cos1 - MULT_BP2(bp2Step,bp2Sin);
                bp2Sin1 = bp2Sin;  bp2Sin = bp2SinT;
                bp2Cos1 = bp2Cos;  bp2Cos = bp2CosT;
            }
        }
    }
    if (i < iCoefRecurQ2)  
    {
        DEBUG_IT_SIN_INIT(1,bp2Sin,bp2Cos,bp2Sin1,bp2Cos1,bp2Step);
        iSegEnd = min (iCoefRecurQ2, iEnd);
        if ( i < iSegEnd )
        {
            fTrigUpdated = 1;
            for (; i < iSegEnd; i++,(*pcSampleGet)++)    {

                COMBINE_SIGNBIT(iResult, *piSrc, piSrcSign, uiSignbitData,
                    uiSignbitCount);

                cfResult = INT_FROM_COEF( MULT_BP2(bp2Sin,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );

                DEBUG_IT_SAMPLE_BREAK(i, iResult, bp2Sin);

                piSrc += cChan;
                piDst += cChan;

                bp2SinT = bp2Sin1 + MULT_BP2(bp2Step,bp2Cos);
                bp2CosT = bp2Cos1 - MULT_BP2(bp2Step,bp2Sin);
                bp2Sin1 = bp2Sin;  bp2Sin = bp2SinT;
                bp2Cos1 = bp2Cos;  bp2Cos = bp2CosT;
            }
        }
    }
    if (i < iCoefRecurQ3) 
    {
        iSegEnd = min (iCoefRecurQ3, iEnd);
        for (; i < iSegEnd; i++,(*pcSampleGet)++)    {
            cfResult = INT_FROM_COEF( *--piCoef );
            ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
            DEBUG_IT_SAMPLE_BREAK(i, iResult, IT_NO_SIN);
            piDst += cChan;
        }
    }

    SAVE_SIGNBIT_STATE(piSrcSign,uiSignbitData);
    if ( fTrigUpdated )
    {
        *(BP2Type*)(&ppcinfo->m_iSin)  = bp2Sin;
        *(BP2Type*)(&ppcinfo->m_iCos)  = bp2Cos;
        *(BP2Type*)(&ppcinfo->m_iSin1) = bp2Sin1;
        *(BP2Type*)(&ppcinfo->m_iCos1) = bp2Cos1;
    }
    ppcinfo->m_rgiCoefReconCurr = (Int*)piCoef;
    ppcinfo->m_iCurrGetPCM_SubFrame = (I16)i;
    ppcinfo->m_piPrevOutputCurr = piSrc;
#ifdef PROFILE
    FunctionProfileStop(&fp);
#endif
    return WMA_OK;
}

#if !defined(WMA_TARGET_X86) || !defined(USE_SIN_COS_TABLES) || defined(PREVOUTPUT_16BITS) || defined (BUILD_INTEGER)
WMARESULT auSaveHistoryMono (CAudioObject* pau, 
                            PerChannelInfo* ppcinfo, 
                            Bool fForceTransformAll)
{
    BP2Type bp2SinT;     //temp sin value within recurrsion
    BP2Type bp2CosT;     //temp cos value within recurrsion
    CoefType *piCoef;   //floating vlaue = (float)*piCoef/(1<<5)  assuming TRANSFORM_FRACT_BITS = 5
    
    Int i;      // , iEnd, iSegEnd;
    I16 *piDst; 
    I32 iResult;
    CoefType cfResult;

    // get local copies of these values which are used frequently or repeatedly (helps optimization)
    Int cChan = pau->m_cChannel;
    // HALF_TRANSFORM: the following member variables are not restored so continue to hold their halved values
    Int cSubFrameSample3Quad = 3 * pau->m_cSubFrameSampleQuadAdjusted;
    Int iCoefRecurQ4 = pau->m_iCoefRecurQ4;
    BP2Type bp2Sin  = INTEGER_OR_INT_FLOAT( pau->m_iSinRampDownStart, pau->m_fltSinRampDownStart );
    BP2Type bp2Cos  = INTEGER_OR_INT_FLOAT( pau->m_iCosRampDownStart, pau->m_fltCosRampDownStart );
    BP2Type bp2Sin1 = INTEGER_OR_INT_FLOAT( pau->m_iSinRampDownPrior, pau->m_fltSinRampDownPrior );
    BP2Type bp2Cos1 = INTEGER_OR_INT_FLOAT( pau->m_iCosRampDownPrior, pau->m_fltCosRampDownPrior );
    BP2Type bp2Step = INTEGER_OR_INT_FLOAT( pau->m_iSinRampDownStep,  pau->m_fltSinRampDownStep  );


#ifndef PREVOUTPUT_16BITS
    I16    *piDstSign = ppcinfo->m_piPrevOutputSign;
    U32     uiSignbitData = 0;
    U32     uiSignbitCount = 0;
#endif  // PREVOUTPUT_16BITS

#ifdef PROFILE
    FunctionProfile fp;
    FunctionProfileStart(&fp,SAVE_HISTORY_MONO_PROFILE);
#endif

    //all starting from the begining of this frame
    //official starting of a subfrm (including leading zeros)
    //case 1 (Large -> Small):  starts later than what's been reconstructed w/o leading zeros
    //                          in this case dst should be skiped (this may mean memcpy from prev)
    //                          src and coef are fine
    //                          
    //case 2 (Small -> Large):  starts earler than what's been reconstructed but all leading zeros
    //                          in this case dst 

    //eventually we'll use piOutput directly
    piDst = ppcinfo->m_piPrevOutput;

    DEBUG_IT_FRAME_BREAK;

    //persistent states
    i = ppcinfo->m_iCurrGetPCM_SubFrame;       //current position in a frame
    assert( (0<=i && i<=iCoefRecurQ4) || (i==CURRGETPCM_INVALID));
    piCoef = (CoefType*)ppcinfo->m_rgiCoefReconCurr; 
    ASSERT_SIGNBIT_POINTER(piDstSign);


#if defined(WMA_SHOW_FRAMES)  && defined(_DEBUG)
    prvWmaShowFrames(pau, "SavHist", " %4d 0x%08x 0x%08x %4d %4d", 
        i, piCoef, piDst, cSubFrameSample3Quad, iCoefRecurQ4);
#endif
    DEBUG_IT_SIN_INIT(3,bp2Sin,bp2Cos,bp2Sin1,bp2Cos1,bp2Step);
    for (; i < cSubFrameSample3Quad; i++)    {

        cfResult = INT_FROM_COEF( MULT_BP2(bp2Sin,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );

        DEBUG_IT_SAMPLE_BREAK(i, iResult, bp2Sin);
        piDst += cChan;

        RECORD_SIGNBIT(iResult, piDstSign, uiSignbitData,
            uiSignbitCount, 1);

        bp2SinT = bp2Sin1 + MULT_BP2(bp2Step,bp2Cos);
        bp2CosT = bp2Cos1 - MULT_BP2(bp2Step,bp2Sin);
        bp2Sin1 = bp2Sin;  bp2Sin = bp2SinT;
        bp2Cos1 = bp2Cos;  bp2Cos = bp2CosT;
    }

    for (; i < iCoefRecurQ4; i++)    {

        cfResult = INT_FROM_COEF( MULT_BP2(bp2Sin,*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );

        DEBUG_IT_SAMPLE_BREAK(i, iResult, bp2Sin);
        piDst += cChan;

        RECORD_SIGNBIT(iResult, piDstSign, uiSignbitData,
            uiSignbitCount, 1);

        bp2SinT = bp2Sin1 + MULT_BP2(bp2Step,bp2Cos);
        bp2CosT = bp2Cos1 - MULT_BP2(bp2Step,bp2Sin);
        bp2Sin1 = bp2Sin;  bp2Sin = bp2SinT;
        bp2Cos1 = bp2Cos;  bp2Cos = bp2CosT;
    }
    DEBUG_IT_SIN_INIT(5,bp2Sin,bp2Cos,bp2Sin1,bp2Cos1,bp2Step);

    ppcinfo->m_iCurrGetPCM_SubFrame = (I16)i;       //protect ourself from multiple calls

#ifdef PROFILE
    FunctionProfileStop(&fp);
#endif
    return WMA_OK;
}
#endif  // !defined(WMA_TARGET_X86) || defined(PREVOUTPUT_16BITS) || defined (BUILD_INTEGER)
#endif  // first SH4, then anything else



#if defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
void prvSetAdjustedValues(CAudioObject *pau, Int fQToo)
{
#if defined(HALF_TRANSFORM)
    if (pau->m_fHalfTransform)
    {
        pau->m_cSubbandAdjusted            = pau->m_cSubband>>1;
        pau->m_cFrameSampleAdjusted        = pau->m_cFrameSample>>1;
        pau->m_cFrameSampleHalfAdjusted    = pau->m_cFrameSampleHalf>>1;
        pau->m_cSubFrameSampleHalfAdjusted = pau->m_cSubFrameSampleHalf>>1;
        pau->m_cSubFrameSampleAdjusted     = pau->m_cSubFrameSample>>1;
        pau->m_cSubFrameSampleQuadAdjusted = pau->m_cSubFrameSampleQuad>>1;
        pau->m_cHighCutOffAdjusted         = pau->m_cHighCutOff>>1;
        pau->m_iSizePrev >>= 1;
        pau->m_iSizeCurr >>= 1;
        pau->m_iSizeNext >>= 1;
        if (fQToo)
        {   // normally only needed at initialization time
            pau->m_iCoefRecurQ1 >>= 1;
            pau->m_iCoefRecurQ2 >>= 1;
            pau->m_iCoefRecurQ3 >>= 1;
            pau->m_iCoefRecurQ4 >>= 1;
        }
    }
    else 
#endif // defined(HALF_TRANSFORM)
#if defined(PAD2X_TRANSFORM)
    if (pau->m_fPad2XTransform)
    {
        pau->m_cSubbandAdjusted            = pau->m_cSubband<<1;
        pau->m_cFrameSampleAdjusted        = pau->m_cFrameSample<<1;
        pau->m_cFrameSampleHalfAdjusted    = pau->m_cFrameSampleHalf<<1;
        pau->m_cSubFrameSampleHalfAdjusted = pau->m_cSubFrameSampleHalf<<1;
        pau->m_cSubFrameSampleAdjusted     = pau->m_cSubFrameSample<<1;
        pau->m_cSubFrameSampleQuadAdjusted = pau->m_cSubFrameSampleQuad<<1;
        pau->m_cHighCutOffAdjusted         = pau->m_cHighCutOff;    // unchanged
        pau->m_iSizePrev <<= 1;
        pau->m_iSizeCurr <<= 1;
        pau->m_iSizeNext <<= 1;
        if (fQToo)
        {   // normally only needed at initialization time
            pau->m_iCoefRecurQ1 <<= 1;
            pau->m_iCoefRecurQ2 <<= 1;
            pau->m_iCoefRecurQ3 <<= 1;
            pau->m_iCoefRecurQ4 <<= 1;
        }
    }
    else 
#endif // defined(PAD2X_TRANSFORM)
    {
        pau->m_cSubbandAdjusted            = pau->m_cSubband;
        pau->m_cFrameSampleAdjusted        = pau->m_cFrameSample; 
        pau->m_cFrameSampleHalfAdjusted    = pau->m_cFrameSampleHalf;
        pau->m_cSubFrameSampleAdjusted     = pau->m_cSubFrameSample;
        pau->m_cSubFrameSampleHalfAdjusted = pau->m_cSubFrameSampleHalf;
        pau->m_cSubFrameSampleQuadAdjusted = pau->m_cSubFrameSampleQuad;
        pau->m_cHighCutOffAdjusted         = pau->m_cHighCutOff;
    }
}
#endif // defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)


//*****************************************************************************************
//
// auAdaptToSubFrameConfig
// setup paramters for handling and transisting between varying size subframes
//
//*****************************************************************************************
WMARESULT auAdaptToSubFrameConfig (CAudioObject* pau)
{
    Int i, iTotal, iSizeCurr;
    PerChannelInfo* ppcinfo;
    WMARESULT   wmaResult = WMA_OK;

#ifdef PROFILE
    //FunctionProfile fp;
    //FunctionProfileStart(&fp,ADAPT_TO_SUB_FRAME_CONFIG_PROFILE);
#endif

    assert (pau->m_subfrmconfigCurr.m_cSubFrame <= 16);
    pau->m_iSizeCurr = iSizeCurr = pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame];

    if (pau->m_subfrmconfigCurr.m_cSubFrame > 1) {
        pau->m_iIncr = LOG2 ((U32)(pau->m_cFrameSampleHalf / iSizeCurr));
        if (pau->m_iIncr >= pau->m_cPossibleWinSize)   {
            assert (WMAB_FALSE);
            wmaResult = TraceResult(WMA_E_BROKEN_FRAME);
            goto exit;
        }
        i = 0;
        iTotal = 0;
        while (i < pau->m_iIncr) {iTotal += (pau->m_cFrameSampleQuad >> i); i++;}

        pau->m_cValidBarkBand = pau->m_rgcValidBarkBand [pau->m_iIncr];
        pau->m_rgiBarkIndex   = pau->m_rgiBarkIndexOrig + pau->m_iIncr * (NUM_BARK_BAND + 1);
    }
    else {
        pau->m_iIncr = 0;
        pau->m_cValidBarkBand       = pau->m_rgcValidBarkBand [0];
        pau->m_rgiBarkIndex         = pau->m_rgiBarkIndexOrig;
    }
    pau->m_cLowCutOff  = pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame]
                    * pau->m_cLowCutOffLong / pau->m_cFrameSampleHalf;    //proportional
    pau->m_cHighCutOff = pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame]
                    * pau->m_cHighCutOffLong / pau->m_cFrameSampleHalf;    //proportional

    pau->m_cSubFrameSampleHalf   = pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame];
    pau->m_cSubFrameSample       = pau->m_cSubFrameSampleHalf * 2;
    pau->m_cSubFrameSampleQuad   = pau->m_cSubFrameSampleHalf / 2; 
    pau->m_cSubband              = pau->m_cSubFrameSampleHalf;    //50% frame overlapping

    //init; could be modified by noise sub
    ppcinfo = pau->m_rgpcinfo;
    ppcinfo->m_cSubbandActual = pau->m_cHighCutOff - pau->m_cLowCutOff;

    if (pau->m_cChannel == 2)   {
        ppcinfo = pau->m_rgpcinfo + 1;
        ppcinfo->m_cSubbandActual = pau->m_rgpcinfo [0].m_cSubbandActual;
    }


#ifdef ENABLE_ALL_ENCOPT
    //update first noise index
    if (pau->m_fNoiseSub == WMAB_TRUE)    {
        pau->m_iFirstNoiseIndex = (Int) (0.5F + pau->m_fltFirstNoiseFreq * pau->m_cSubFrameSample 
            / ((Float) pau->m_iSamplingRate));  //open end
        if (pau->m_iFirstNoiseIndex > pau->m_cSubband) 
            pau->m_iFirstNoiseIndex = pau->m_cSubband;

        // use precalculated values
        pau->m_iFirstNoiseBand = pau->m_rgiFirstNoiseBand[pau->m_iIncr];
    }
#endif //ENABLE_ALL_ENCOPT

    //to decide the current window shape; look at sizes on the left and right

    pau->m_iSizePrev = (pau->m_iCurrSubFrame > 0) ? 
                        pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame - 1] :
                        pau->m_subfrmconfigPrev.m_rgiSubFrameSize [pau->m_subfrmconfigPrev.m_cSubFrame - 1];

    pau->m_iSizeNext = (pau->m_iCurrSubFrame < pau->m_subfrmconfigCurr.m_cSubFrame - 1) ? 
                        pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame + 1] :
                        pau->m_subfrmconfigNext.m_rgiSubFrameSize [0];


#if defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
    prvSetAdjustedValues(pau, WMAB_FALSE);
#endif

    //if the adjacent size is bigger; just keep your own shape
    //otherwise a transition window is needed.
    if (pau->m_iSizePrev >= pau->m_iSizeCurr) {
        //just forward copy curr
        pau->m_iCoefRecurQ1 = 0;
        pau->m_iCoefRecurQ2 = pau->m_iSizeCurr;
    }
    else  {
        //long start
        pau->m_iCoefRecurQ1 = (pau->m_iSizeCurr - pau->m_iSizePrev) / 2;
        pau->m_iCoefRecurQ2 = (pau->m_iSizeCurr + pau->m_iSizePrev) / 2;
    }

    if (pau->m_iSizeNext >= pau->m_iSizeCurr) {
        pau->m_iCoefRecurQ3 = pau->m_cSubFrameSampleHalfAdjusted;
        pau->m_iCoefRecurQ4 = pau->m_cSubFrameSampleAdjusted;
    }
    else    {
        //just backward copy curr
        pau->m_iCoefRecurQ3 = pau->m_cSubFrameSampleHalfAdjusted + (pau->m_iSizeCurr - pau->m_iSizeNext) / 2;
        pau->m_iCoefRecurQ4 = pau->m_cSubFrameSampleHalfAdjusted + (pau->m_iSizeCurr + pau->m_iSizeNext) / 2;
    }

    prvAdaptTrigToSubframeConfig(pau);

exit:
#ifdef PROFILE
    //FunctionProfileStop(&fp);
#endif
    return wmaResult;
}



#if defined(BUILD_INTEGER)
WMARESULT prvAdaptTrigToSubframeConfig_INT(CAudioObject *pau)
{
    WMARESULT wmaResult = WMA_OK;
    const SinCosTable*  pSinCosTable;
    Int                 iSize;


    //if the adjacent size is bigger; just keep your own shape
    //otherwise a transition window is needed.
    if (pau->m_iSizePrev >= pau->m_iSizeCurr)
        iSize = pau->m_iSizeCurr;  //just forward copy curr
    else
        iSize = pau->m_iSizePrev;  //long start

#if 0 //def USE_SIN_COS_TABLES 
//marchold:I removed this code as I do not bieleve it to be necessary
    switch (iSize){
        case 2048:
            pau->m_piSinForRecon = pau->m_piSinForRecon2048;
            break;
        case 1024:
            pau->m_piSinForRecon = pau->m_piSinForRecon1024;
            break;
        case 512 :
            pau->m_piSinForRecon = pau->m_piSinForRecon512;
            break;
        case 256 :
            pau->m_piSinForRecon = pau->m_piSinForRecon256;
            break;
        case 128 :
            pau->m_piSinForRecon = pau->m_piSinForRecon128;
            break;
        case 64  :
            pau->m_piSinForRecon = pau->m_piSinForRecon64;
            break;
        default: 
            assert (0);
            return (TraceResult (WMA_E_BROKEN_FRAME));
    }
#endif  //maby else out next section

    // Use lookup-tables if we can
    if (iSize >= 64 && iSize <= 2048)
    {
        pSinCosTable = rgSinCosTables[iSize>>7];

        // START = sin( PI/(4*cSB) ) and cos( PI/(4*cSB) )
        pau->m_iSinRampUpStart =  pSinCosTable->sin_PIby4cSB>>1;    //(Int) (sin (0.5 * PI / iSizeCurr / 2) * 0x3FFFFFFF);
        pau->m_iCosRampUpStart =  pSinCosTable->cos_PIby4cSB>>1;    //(Int) (cos (0.5 * PI / iSizeCurr / 2) * 0x3FFFFFFF);

        // PRIOR should be sin(PI/(4*cSB) - PI/(2*cSB) ) = sin( -PI/(4*cSB) )
        pau->m_iSinRampUpPrior = -pSinCosTable->sin_PIby4cSB>>1;
        pau->m_iCosRampUpPrior =  pSinCosTable->cos_PIby4cSB>>1;
        pau->m_iSinRampUpStep  =  pSinCosTable->sin_PIby2cSB;   // STEP = 2 * sin (PI / 2 / iSizeCurr) * 0x3FFFFFFF;
    }
    else
    {
        pau->m_iSinRampUpStart =  (I32) (sin (0.5 * PI / iSize / 2) * NF2BP2);
        pau->m_iCosRampUpStart =  (I32) (cos (0.5 * PI / iSize / 2) * NF2BP2);
        pau->m_iSinRampUpPrior =  (I32) -(sin(0.5 * PI / iSize / 2) * NF2BP2);
        pau->m_iCosRampUpPrior =  (I32) (cos (0.5 * PI / iSize / 2) * NF2BP2);
        pau->m_iSinRampUpStep  =  (I32) (sin (PI / 2 / iSize) * NF2BP1);
    }

    // Include the next code-block to verify changes to the lookup-table
#ifdef _DEBUG
    assert(abs(pau->m_iSinRampUpStart - ((I32) (sin (0.5 * PI / iSize / 2) * NF2BP2))) <= 10000);
    assert(abs(pau->m_iCosRampUpStart - ((I32) (cos (0.5 * PI / iSize / 2) * NF2BP2))) <= 10000);
    assert(abs(pau->m_iSinRampUpPrior - ((I32) -(sin(0.5 * PI / iSize / 2) * NF2BP2))) <= 10000);
    assert(abs(pau->m_iCosRampUpPrior - ((I32) (cos (0.5 * PI / iSize / 2) * NF2BP2))) <= 10000);
    assert(abs(pau->m_iSinRampUpStep  - ((I32) (sin (PI / 2 / iSize) * NF2BP1))) <= 10000); // STEP = 2 * 
#endif


    
    if (pau->m_iSizeNext >= pau->m_iSizeCurr)
        iSize = pau->m_iSizeCurr;
    else
        iSize = pau->m_iSizeNext;  //just backward copy curr


    // Use lookup-tables if we can
    if (iSize >= 64 && iSize <= 2048)
    {
        pSinCosTable = rgSinCosTables[iSize>>7];

        // START = sin ((0.5 + cSB) * PI / (2*cSB) )
        //       = sin ( PI/(4*cSB) + PI/2 ) =  cos( PI/(4*cSB) )
        //         cos ((0.5 + cSB) * PI / (2*cSB) )
        //       = cos ( PI/(4*cSB) + PI/2 ) = -sin( PI/(4*cSB) )
        pau->m_iSinRampDownStart =  pSinCosTable->cos_PIby4cSB>>1;  //(Int) sin ((0.5 + iSizeNext) * PI / iSizeNext / 2);
        pau->m_iCosRampDownStart = -pSinCosTable->sin_PIby4cSB>>1;  //(Int) cos ((0.5 + iSizeNext) * PI / iSizeNext / 2);
        // PRIOR = sin ((0.5 + cSB) * PI / (2*cSB) -PI/(2*cSB) )
        //       = sin ( PI/(4*cSB) + PI/2 - PI/(2*cSB) ) = cos( -PI/(4*cSB) ) = cos( PI/(4*cSB) )
        //         cos ((0.5 + cSB) * PI / (2*cSB) -PI/(2*cSB) )
        //       = cos ( PI/(4*cSB) + PI/2 - PI/(2*cSB) ) =  -sin( -PI/(4*cSB) ) = sin( PI/(4*cSB) )
        pau->m_iSinRampDownPrior =  pSinCosTable->cos_PIby4cSB>>1;
        pau->m_iCosRampDownPrior =  pSinCosTable->sin_PIby4cSB>>1;
        pau->m_iSinRampDownStep  =  pSinCosTable->sin_PIby2cSB;     // STEP = 2 * sin (PI / 2 / iSizeCurr) * 0x3FFFFFFF;
    }
    else
    {
        pau->m_iSinRampDownStart =  (I32) (cos (0.5 * PI / iSize / 2) * NF2BP2);
        pau->m_iCosRampDownStart =  (I32) (-sin(0.5 * PI / iSize / 2) * NF2BP2);
        pau->m_iSinRampDownPrior =  (I32) (cos(0.5 * PI / iSize / 2) * NF2BP2);
        pau->m_iCosRampDownPrior =  (I32) (sin(0.5 * PI / iSize / 2) * NF2BP2);
        pau->m_iSinRampDownStep  =  (I32) (sin (PI / (2 * iSize)) * NF2BP1);
    }

    // Include the next code-block to verify changes to the lookup-table
#ifdef _DEBUG
    assert(abs(pau->m_iSinRampDownStart - ((I32) (cos (0.5 * PI / iSize / 2) * NF2BP2))) <= 10000);
    assert(abs(pau->m_iCosRampDownStart - ((I32) (-sin(0.5 * PI / iSize / 2) * NF2BP2))) <= 10000);
    assert(abs(pau->m_iSinRampDownPrior - ((I32) (cos(0.5 * PI / iSize / 2) * NF2BP2))) <= 10000);
    assert(abs(pau->m_iCosRampDownPrior - ((I32) (sin(0.5 * PI / iSize / 2) * NF2BP2))) <= 10000);
    assert(abs(pau->m_iSinRampDownStep  - ((I32) (sin (PI / (2 * iSize)) * NF2BP1))) <= 10000);
#endif
    return wmaResult;
}
#endif  // defined(BUILD_INTEGER)


#ifdef BUILD_INTEGER
WMARESULT prvAdaptTrigToSubframeConfig(CAudioObject *pau)
{
    WMARESULT wmaResult;
    ASSERTWMA_EXIT (wmaResult, prvAdaptTrigToSubframeConfig_INT(pau));
exit:
    return wmaResult;
}
#endif  // BUILD_INTEGER

//*****************************************************************************************
//
// auUpdateMaxEsc
//
//*****************************************************************************************
Void    auUpdateMaxEsc(CAudioObject* pau, Int iQuantStepSize)
{
    // HongCho: Adjust the max Tunstall level according to the quantization step...
    //          Matching if's in the decoder...
    //          Too many?  Maybe...
    // HongCho: Note...  For 22.05kHz, even with all 15bits, the bells don't ring...
    if(iQuantStepSize < 5)       pau->m_iMaxEscSize = 13;
    else if(iQuantStepSize < 15) pau->m_iMaxEscSize = 13;
    else if(iQuantStepSize < 32) pau->m_iMaxEscSize = 12;
    else if(iQuantStepSize < 40) pau->m_iMaxEscSize = 11;
    else if(iQuantStepSize < 45) pau->m_iMaxEscSize = 10;
    else if(iQuantStepSize < 55) pau->m_iMaxEscSize =  9;
    else                         pau->m_iMaxEscSize =  9;
    pau->m_iMaxEscLevel = (1<<pau->m_iMaxEscSize) - 1;
}


#if defined(INTERPOLATED_DOWNSAMPLE)

// Stolen from Algorithms in C, Sedgewick
Int GCD (Int u, Int v)
{
    Int t;

    while (u > 0)
    {
        if (u < v)
        {
            // Swap 'em
            t = u;
            u = v;
            v = t;
        }

        u = u - v;
    }

    return v;
}


void prvInterpolateInit(CAudioObject *pau, Int iSrcSampleRate,
                        Int iDstSampleRate, Int iAddInterval)
{
    Int iGCD;

    pau->m_iInterpolSrcBlkSize = iSrcSampleRate;
    pau->m_iInterpolDstBlkSize = iDstSampleRate;

    // Calculate the greatest common divisor between iSrcSampleRate
    // and iDstSampleRate and use to reduce iSrcBlkSize, iDstBlkSize
    iGCD = GCD(iSrcSampleRate, iDstSampleRate);
    if (0 != iGCD)
    {
        pau->m_iInterpolSrcBlkSize /= iGCD;
        pau->m_iInterpolDstBlkSize /= iGCD;
    }

    // Calculate pointer and difference increments to avoid div/mod ops
    pau->m_iInterpolIncr = pau->m_iInterpolSrcBlkSize / pau->m_iInterpolDstBlkSize;
    pau->m_iInterpolCarry = pau->m_iInterpolSrcBlkSize % pau->m_iInterpolDstBlkSize;

    // Calculate fixed-point increment to interpolation weight (x2 - x')
    pau->m_iInterpolWeightIncr = (I32) (-((float)pau->m_iInterpolSrcBlkSize /
        (float)pau->m_iInterpolDstBlkSize) * (1 << INTERPOL_FRACTBITS));

    pau->m_iInterpolAddInterval = iAddInterval;
    pau->m_iInterpolNextAdd = iAddInterval;
}


#ifdef BUILD_INTEGER
void auLowPass(CAudioObject *pau, Int *rgCoef, Int iNumCoefs)
{
    Int    *pEnd = rgCoef + iNumCoefs * 2; // Re and Im coefs (so times 2)
    Int    *pCurr;
#else   // BUILD_INTEGER
void auLowPass(CAudioObject *pau, Float *rgCoef, Int iNumCoefs)
{
    Float  *pEnd = rgCoef + iNumCoefs * 2; // Re and Im coefs (so times 2)
    Float  *pCurr;
#endif  // BUILD_INTEGER

    Int     iPassThruCoefs;

    // Figure out how many coefficients will pass through untouched
    iPassThruCoefs = (pau->m_iInterpolDstBlkSize * iNumCoefs) / 
        pau->m_iInterpolSrcBlkSize;
    pCurr = rgCoef + (2 * iPassThruCoefs);   // Re and Im coefs (so times 2)
    iNumCoefs -= iPassThruCoefs;

    while (iNumCoefs > 0)
    {
        *pCurr++ = 0;       // Re coef
        *pCurr++ = 0;       // Im coef
        iNumCoefs -= 1;
    }

    assert(pCurr == pEnd);
}
#endif  // defined(INTERPOLATED_DOWNSAMPLE)


#ifdef INTERPOLATED_DOWNSAMPLE
// We assume piSrc and piDst point to I16, channel-interleaved buffers
void prvInterpolate(CAudioObject *pau, I16 *piSourceBuffer, Int iNumSrcBytes,
                    Int iChannels, I16 *piDestBuffer, Int *piNumDstBytes, U16* pcSamples)
{
    Int iCurrChannel;
    Int iNewNextAdd = pau->m_iInterpolNextAdd;

    // Check if source buffer is a multiple of indivisible src blk size
    assert(0 == (iNumSrcBytes % pau->m_iInterpolSrcBlkSize));

    *piNumDstBytes = 0;
    *pcSamples = 0;
    for (iCurrChannel = 0; iCurrChannel < iChannels; iCurrChannel += 1)
    {
        const Int c_iInterpolationBlks = iNumSrcBytes /
            (iChannels * pau->m_iInterpolSrcBlkSize * sizeof(I16));

        I16    *piPrevSrc = piSourceBuffer + iCurrChannel;
        I16    *piSrc = piSourceBuffer + iCurrChannel + iChannels;
        I16    *piDst = piDestBuffer + iCurrChannel;
        Int     iNextAdd = pau->m_iInterpolNextAdd;
        Int     i;
        Bool    fAddExtraSample;

        // If we are not to add extra samples, set us up so iNextAdd never hits 0
        if (0 == iNextAdd)
        {
            iNextAdd = (c_iInterpolationBlks * pau->m_iInterpolDstBlkSize) + 1;
            fAddExtraSample = WMAB_FALSE;
        }
        else
            fAddExtraSample = WMAB_TRUE;

        for (i = 0; i < c_iInterpolationBlks; i++)
        {
            I32     fiWeight = (1 << INTERPOL_FRACTBITS);
            Int     iPtrIncrCarry = 0;
            Int     j;

#ifdef _DEBUG
            const Float c_fltWeightIncr = -((float)pau->m_iInterpolSrcBlkSize /
                (float)pau->m_iInterpolDstBlkSize);
            Float   fltWeight = 1.0f;
            Float   fltResult;
            Float   fltDiff;
            Float   fltRelErr;

            fltDiff = c_fltWeightIncr - ((float) pau->m_iInterpolWeightIncr /
                (float) (1 << INTERPOL_FRACTBITS));
            fltRelErr = fltDiff / c_fltWeightIncr;
            assert(0 == fltDiff || fltRelErr < 0.1f);
#endif  // _DEBUG

            for (j = 0; j < pau->m_iInterpolDstBlkSize; j++)
            {
                Int iSrcIncr;

                // Pre-read prev and next src to help compiler optimization
                // and to allow debug code to verify, since interpolation is in-place
                const I16   iPrevSrc = *piPrevSrc;
                const I16   iNextSrc = *piSrc;

                // Interpolate output sample (No rounding. I tried rounding but
                // it makes little difference and it adds 2% to computation time)
                *piDst = (I16) (MULT_HI_DWORD(fiWeight, (iPrevSrc -
                    iNextSrc) << (32 - INTERPOL_FRACTBITS)) + iNextSrc);

                // Add an extra sample if it's time to do so
                iNextAdd -= 1;
                if (iNextAdd <= 0)
                {
                    assert(iNextAdd == 0);
                    assert(fAddExtraSample);
                    *(piDst + iChannels) = *piDst;
                    piDst += iChannels;
                    iNextAdd = pau->m_iInterpolAddInterval;
                }

#ifdef _DEBUG
                fltResult = (I16) ROUNDF(fltWeight * (iPrevSrc - iNextSrc) + iNextSrc);
                fltDiff = fltResult - *piDst;
                fltRelErr = fltDiff / fltResult;
                assert(fabs(fltDiff) <= 1.0f || fabs(fltRelErr) < 0.1f);
#endif  // _DEBUG

                // Check if we need to carry
                iSrcIncr = pau->m_iInterpolIncr;
                iPtrIncrCarry += pau->m_iInterpolCarry;
                if (iPtrIncrCarry >= pau->m_iInterpolDstBlkSize)
                {
                    // Perform carry
                    iSrcIncr += 1;
                    iPtrIncrCarry -= pau->m_iInterpolDstBlkSize;
                }

                // Update pointers and vars
                piPrevSrc += iSrcIncr * iChannels;
                piSrc += iSrcIncr * iChannels;
                piDst += iChannels;

                // Now calculate the next weighting
                fiWeight += pau->m_iInterpolWeightIncr + (iSrcIncr << INTERPOL_FRACTBITS);

#ifdef _DEBUG
                fltWeight += c_fltWeightIncr + iSrcIncr;
                fltDiff = fltWeight - ((float)fiWeight / (float)(1 << INTERPOL_FRACTBITS));
                fltRelErr = fltDiff / fltWeight;
                assert(0 == fltDiff || fabs(fltRelErr) < 0.1f);
#endif  // _DEBUG

            } // for (interpolation block)
        } // for (entire source block)

        // Output number of samples outputted after interpolation
        *piNumDstBytes += sizeof(I16) * (piDst - iCurrChannel - piDestBuffer) / iChannels;

        // Record new countdown to next extra sample, unless we're not to add new samples
        if (0 == iCurrChannel && fAddExtraSample)
            iNewNextAdd = iNextAdd;

        assert(WMAB_FALSE == fAddExtraSample || iNextAdd == iNewNextAdd);

    } // for (all channels)

    *pcSamples = (*piNumDstBytes) / ( sizeof(I16) * iChannels );
    assert(*piNumDstBytes % (iChannels * sizeof(I16)) == 0);
    assert( *piNumDstBytes == (Int)(sizeof(I16) * (*pcSamples) * iChannels) );
    pau->m_iInterpolNextAdd = iNewNextAdd;

} // prvInterpolate

#endif  // INTERPOLATED_DOWNSAMPLE



//*****************************************************************************************
//
// qstCalcQuantStep
// like auCalcQuantStep but returns a QuantStepType which is either:
//   a FastFloat (for integer builds), a Float (Decoder) or a Double(Encoder)
//
//*****************************************************************************************
QuantStepType qstCalcQuantStep(Int iQSS) 
{
    QuantStepType qstQuantStep;

#if defined(BUILD_INTEGER)
    if ( iQSS < DBPOWER_TABLE_OFFSET )
    {   // This happens when iPower==0, not an important case, but return 10^(1/20) with 28 FractBits
        // It can also happen with a small NoisePower (-13 has been seen)
        if ( iQSS < 0 )
        {   // negative values of iQSS are being generated in the V5 encoder (LowRate in particular)
            qstQuantStep.iFraction = (I32)(0.382943866392*(1<<QUANTSTEP_FRACT_BITS)),      // Average Fraction
            qstQuantStep.iFracBits = QUANTSTEP_FRACT_BITS - ((-iQSS>>3)+1);                // Approximate Exponent
        }
        else
        {
            qstQuantStep.iFraction = (I32)(0.869439785679*(1<<QUANTSTEP_FRACT_BITS));     // Average Fraction
            qstQuantStep.iFracBits = QUANTSTEP_FRACT_BITS - ((iQSS>>3)+1);                // Approximate Exponent
        }
    }
    else if ( iQSS < (DBPOWER_TABLE_OFFSET+DBPOWER_TABLE_SIZE) )
    {   
        // *** normal case ***
        qstQuantStep.iFraction = rgDBPower10[ iQSS - DBPOWER_TABLE_OFFSET ];
        qstQuantStep.iFracBits = QUANTSTEP_FRACT_BITS - ((iQSS>>3)+4);    // implied FractBit scale for rgiDBPower table
        NormUInt( (UInt*)(&qstQuantStep.iFraction), &qstQuantStep.iFracBits, 0x3FFFFFFF );
    }
    else
    {   // This branch can handle out-of-range cases. 
        // rare - but used in some cases by encoder - e.g. Tough_16m_16, Tough_22m_22(?).
        const double    c_dblTenExpToTwo = 3.3219280948873623478703194294894; // ln(10)/ln(2);
        const double    c_dblPointNineNine = (1.0 - DBL_EPSILON);
        double  dblQuantStep,  dblExponent;
        Int     iNumWholeBits,  iNumFractBits;
        dblExponent = (double)(iQSS/(Float)QUANTSTEP_DENOMINATOR);
        dblQuantStep = pow (10, dblExponent);
        iNumWholeBits = (Int)(dblExponent * c_dblTenExpToTwo + c_dblPointNineNine); // Round UP
        iNumWholeBits = max(iNumWholeBits, 5);
        iNumFractBits = max(31 - iNumWholeBits, TRANSFORM_FRACT_BITS);
        if (dblQuantStep * (1 << iNumFractBits) <= UINT_MAX)
            qstQuantStep.iFraction = (I32)(dblQuantStep * (1 << iNumFractBits));
        else
            qstQuantStep.iFraction = UINT_MAX;      // iQSS of 218 seen in encoding Tough 16kHz Stereo 16kbps
        qstQuantStep.iFracBits = iNumFractBits;
        NormUInt( (UInt*)(&qstQuantStep.iFraction), &qstQuantStep.iFracBits, 0x3FFFFFFF );
    }
    MONITOR_RANGE( gMR_qstQuantStep, (qstQuantStep.iFraction)/(Double)(1 << qstQuantStep.iFracBits) );    

#else   // must be BUILD_INT_FLOAT or float encoder

    if ( iQSS < DBPOWER_TABLE_OFFSET )
    {   // This happens when iPower==0, not an important case, but return 10^(1/20) with 28 FractBits
        // It can also happen with a small NoisePower (-13 has been seen)
        if ( iQSS < 0 )
        {   // negative values of iQSS are being generated in the V5 encoder (LowRate in particular)
            qstQuantStep = 0.382943866392f,      // Average Fraction
            qstQuantStep /= (Float)(1<<((-iQSS>>3)+1));                // Approximate Exponent
        }
        else
        {
            qstQuantStep = 0.869439785679f;             // Average Fraction
            qstQuantStep *= (Float)(1<<((iQSS>>3)+1));      // Approximate Exponent
        }
    }
    else if ( iQSS < (DBPOWER_TABLE_OFFSET+DBPOWER_TABLE_SIZE) )
    {   // *** normal case ***
        // implied FractBit scale for rgiDBPower table
        qstQuantStep = rgDBPower10[ iQSS - DBPOWER_TABLE_OFFSET ] * rgfltDBPowerExponentScale[iQSS>>3];
    }
    else
    {   // This branch can handle out-of-range cases. 
        // rare - but used in some cases by encoder - e.g. Tough_16m_16.
        // iQSS of 218 seen in encoding Tough 16kHz Stereo 16kbps
        qstQuantStep = (QuantStepType)pow (10, (double)(iQSS/(Float)QUANTSTEP_DENOMINATOR) );
    }
    MONITOR_RANGE( gMR_qstQuantStep, qstQuantStep );

#endif

    return( qstQuantStep );
}


//*****************************************************************************************
//
// prvWeightedQuantization
// calculate 10^( (MaskQ-MaxMaskQ)*2.5*0.5/20 ) * 10^( QuantStepSize/20 )
//         = (10^(1/16))^( MaskQ-MaxMaskQ )     * (10^(1/20)^QuantStepSize
//*****************************************************************************************
QuantFloat prvWeightedQuantization(CAudioObject *pau, PerChannelInfo *ppcinfo, Int iBark)
{
    Int iIndex = ppcinfo->m_iMaxMaskQ - ppcinfo->m_rgiMaskQ[iBark];
    QuantFloat qfltRMS;
    assert( 0 <= iIndex );

    if (iIndex >= MASK_MINUS_POWER_TABLE_SIZE)
        iIndex = MASK_MINUS_POWER_TABLE_SIZE-1;
#if defined(BUILD_INTEGER)
    {
        Int uiFraction, iFracBits;
        uiFraction = rgiMaskMinusPower10[ iIndex ];     // with MASK_POWER_FRAC_BITS==28 fractional bits
        iFracBits = MASK_POWER_FRAC_BITS+(iIndex>>2);
        MONITOR_RANGE(gMR_WeightRatio,(float)uiFraction/pow(2,iFracBits));
#       ifdef _DEBUG
        {
            Float realRMS = (Float)pow(10,(float)(ppcinfo->m_rgiMaskQ[iBark] - ppcinfo->m_iMaxMaskQ)/(1<<4));
            Float Calculated = (float)uiFraction/(float)pow(2,iFracBits); 
            Float diff = (Float)fabs(realRMS-Calculated);
            Float rel = (Float)fabs(diff/realRMS);
            if (rel > .00002)
                DEBUG_BREAK();
        }
#       endif
        qfltRMS.iFraction = MULT_HI(pau->m_qstQuantStep.iFraction,uiFraction);  
        qfltRMS.iFracBits = pau->m_qstQuantStep.iFracBits + iFracBits - 31;
        Norm4FastFloat( &qfltRMS );
    }

#else

    qfltRMS = rgiMaskMinusPower10[ iIndex ] / (Float)(1<<(iIndex>>2));
    MONITOR_RANGE(gMR_WeightRatio,qfltRMS);
    qfltRMS *= FLOAT_FROM_QUANTSTEPTYPE( pau->m_qstQuantStep );  

#endif

    return qfltRMS;
}

//*****************************************************************************************
//
// VERIFY_DECODED_COEFFICENT
//
// define VERIFY_DECODED_COEFS and set fltCoefIntFloatThreshold
//
//*****************************************************************************************
//#define VERIFY_DECODED_COEFS
#if defined(_DEBUG) && defined(VERIFY_DECODED_COEFS)
#   pragma COMPILER_MESSAGE(__FILE__ "(1235) : Warning - Decode Coef HighRate Debug Code Enabled.")
// define threshold ((it can be changed from debugger))
static Float fltCoefIntFloatThreshold = 0.00075F;
static void VerifyDecodedCoefficentHR(CAudioObject* pau, PerChannelInfo* ppcinfo, 
                                          Int iBark, CoefType iRecon, I16 iLevel, CoefType ctCoefRecon) {
    Float ff, f3, dif, rel, fltRecon;
    static Float fltReconMin = 1.0e30F;
    static Float fltReconMax = -1;
    Double dblQuantStep = DOUBLE_FROM_QUANTSTEPTYPE(pau->m_qstQuantStep);
    Float fltWeightFactor = ((float)ppcinfo->m_rgiWeightFactor[iBark])  / (1<<WEIGHTFACTOR_FRACT_BITS);     // divide by 1024.
    Float fltInvMaxWeight = 1.0F / ((float)ppcinfo->m_iMaxWeight / (1<<WEIGHTFACTOR_FRACT_BITS));           // didive by 1024.
    fltRecon = FLOAT_FROM_COEF(ctCoefRecon);                                                                // divide by 32.
    // This is the statement in float.c we are to match
    // rgfltCoefRecon [iRecon] = ((Float) rgiCoefQ [iCoefQ]) * rgfltWeightFactor [iBark] * ((Float) dblQuantStep) * fltInvMaxWeight;
    ff = fltWeightFactor * ((Float) dblQuantStep) * fltInvMaxWeight;
    f3 = ((Float) iLevel) * ff;
    dif = (float) fabs(f3 - fltRecon);  
    rel = (float) fabs(dif/f3); 
    // was ((iRecon < pau->m_cHighCutOff) && (dif > 2) && rel > 0.2)
    // fltRecon seems to range from 1e7 down to about 1.0, small values seem to be less accurate
    // consider using the same comparison as used with MidRate (See LowRate.c)
   if ( rel > (f3 > 100 ? fltCoefIntFloatThreshold : (fltCoefIntFloatThreshold*100/f3)) )   
        DEBUG_BREAK();
}
#define VERIFY_DECODED_COEFFICENT(idxBark) VerifyDecodedCoefficentHR(pau, ppcinfo, idxBark, iRecon, iLevel, ctCoefRecon)
#else
#define VERIFY_DECODED_COEFFICENT(idxBark)
#endif


// *************************************************************************************
// DEBUG_BREAK at a particular Frame in auReconCoefficentsHighRate
//
//#define DECODE_COEF_AT_FRAME 435
//#define DECODE_COEF_AT_SUBFRAME 0
//
#if defined(_DEBUG) && ( defined(DECODE_COEF_AT_FRAME) || defined(DECODE_COEF_AT_SUBFRAME) )
#   pragma COMPILER_MESSAGE(__FILE__ "(1154) : Warning - Decode Coefficient Debug Code Enabled.")
#   if defined(DECODE_COEF_AT_FRAME) && defined(DECODE_COEF_AT_SUBFRAME)
#       define DEBUG_BREAK_AT_FRAME_DECODE                                                          \
            if (  ( pau->m_iFrameNumber == DECODE_COEF_AT_FRAME || DECODE_COEF_AT_FRAME < 0 )       \
                &&( pau->m_iCurrSubFrame == DECODE_COEF_AT_SUBFRAME || DECODE_COEF_AT_SUBFRAME < 0 ) ) \
                DEBUG_BREAK();              
#   elif defined(DECODE_COEF_AT_FRAME)
#       define DEBUG_BREAK_AT_FRAME_DECODE                                                          \
            if ( pau->m_iFrameNumber == DECODE_COEF_AT_FRAME || DECODE_COEF_AT_FRAME < 0 )          \
                DEBUG_BREAK();              
#   else
#       define DEBUG_BREAK_AT_FRAME_DECODE                                                          \
            if ( pau->m_iCurrSubFrame == DECODE_COEF_AT_SUBFRAME || DECODE_COEF_AT_SUBFRAME < 0 )   \
                DEBUG_BREAK();
#   endif               
#else   // defined(_DEBUG) && defined(DECODE_COEF_AT_FRAME)
#   define DEBUG_BREAK_AT_FRAME_DECODE
#endif  // defined(_DEBUG) && defined(DECODE_COEF_AT_FRAME)


//#define RL_PRINT_SRC
#if defined(_DEBUG) && defined(RL_PRINT_SRC) && !defined(WMA_MONITOR)
#   define DBG_RUNLEVEL(a,b,c,d,e)                          \
        if(e) {                                             \
            printf("%d %d %d %d\n", a, b, c, d+1);          \
            fflush (stdout);                                \
        }
#elif defined(_DEBUG) && defined(RL_PRINT_SRC) && defined(WMA_MONITOR)
#   define DBG_RUNLEVEL(a,cRunOfZeros,iLevel,iSign,e)                       \
        if(e) {                                                             \
            printf("%d %d %d %d\n", a, b, c, d+1);                          \
            fflush (stdout);                                                \
        }                                                                   \
        MONITOR_RANGE(gMR_iCoefQ,(iLevel^iSign)-iSign);                     \
        MONITOR_COUNT_CONDITIONAL(cRunOfZeros>0,gMC_0CoefQ,cRunOfZeros);    \
        {   int ii;                                                         \
            for( ii = 0; ii < cRunOfZeros; ii++ )                           \
                MONITOR_RANGE(gMR_CoefRecon,0);                             \
            MONITOR_COUNT(gMC_zeroCoefRecon,cRunOfZeros);                   \
        }
#elif defined(_DEBUG) && !defined(RL_PRINT_SRC) && defined(WMA_MONITOR)
#   define DBG_RUNLEVEL(a,cRunOfZeros,iLevel,iSign,e)                       \
        MONITOR_RANGE(gMR_iCoefQ,(iLevel^iSign)-iSign);                     \
        MONITOR_COUNT_CONDITIONAL(cRunOfZeros>0,gMC_0CoefQ,cRunOfZeros);    \
        {   int ii;                                                         \
            for( ii = 0; ii < cRunOfZeros; ii++ )                           \
                MONITOR_RANGE(gMR_CoefRecon,0);                             \
            MONITOR_COUNT(gMC_zeroCoefRecon,cRunOfZeros);                   \
        }
#else
#   define DBG_RUNLEVEL(a,b,c,d,e)
#endif 


// DecodeCoefsHighRate with combined INTEGER and INT_FLOAT code

#ifdef BUILD_INTEGER

#define MULT_QUANT(iLevel,ffltQuantizer) MULT_HI(((iLevel)<<16),ffltQuantizer.iFraction)

// SCALE_COEF_RECON shifts CoefRecon to give it TRANSFORM_FRACT_BITS==5 fractional bits
#if defined(PLATFORM_OPTIMIZATION_MINIMIZE_BRANCHING)
    // This SCALE_COEF_RECON macro requires 6 ops and no branches
    // This MAKE_MASK_FOR_SCALING requires 5 ops plus 1 branch.
    // SCALE_COEFFICENT gets executed 25x as often as MAKE_MASK_FOR_SCALING, so this method requires 6.2 ops plus 0.04 branches per SCALE_COEFFICENT
#   define SCALE_COEF_RECON(iCR) (((iCR>>iShift) & iMask2) | ((iCR<<-iShift) & iMask1))
#   define MAKE_MASK_FOR_SCALING(iFB) iShift=iFB-(TRANSFORM_FRACT_BITS+31-16);                      \
                                      iMask2 = 0xFFFFFFFF ^ (iMask1 = (iShift<0) ? 0xFFFFFFFF : 0);
#else
    // When branching is not a high penaty activity, do it the simplier way
    //   iCoefRecon = (t=iFracBits-5)<0 ? iCoefRecon>>-t : iCoefRecon<<t
    // This SCALE_COEF_RECON requires 3 ops plus 1 branch or 2 ops plus 1 branch.  
    // This MAKE_MASK_FOR_SCALING requires 2 ops
    // SCALE_COEFFICENT gets executed 25x as often as MAKE_MASK_FOR_SCALING, so this method requires 2.58 ops plus 0.04 branches per SCALE_COEFFICENT
    // On one test on a 500 MHz Pentium 686, This way saves 1% execution time over masking.
#   define SCALE_COEF_RECON(iCR) (iShift<0) ? (iCR)<<-iShift : (iCR)>>iShift
#   define MAKE_MASK_FOR_SCALING(iFB) iShift=iFB+(16-31-TRANSFORM_FRACT_BITS)
#endif

#else

#define MULT_QUANT(iLevel,ffltQuantizer) (iLevel*ffltQuantizer)
#define SCALE_COEF_RECON(iCR) (iCR)
#define MAKE_MASK_FOR_SCALING(iFB)

#endif


///*****************************************************************************************
//
// auReconCoefficentsHighRate  - Integer or IntFloat Version
//
//*****************************************************************************************
//wchen: this function is not threadsafe!!
WMARESULT auReconCoefficentsHighRate (CAudioObject* pau, Void* pcaller,
                                      PerChannelInfo* ppcinfo, Int* piBitCnt)
{
    WMARESULT   wmaResult = WMA_OK;

    CoefType* rgiCoefRecon   = (CoefType*) ppcinfo->m_rgiCoefRecon;
    CoefType ctCoefRecon;
    Int iMaskResampleRatio, cValidBarkBandLatestUpdate;
    Int iBark = 0;
    I16* piRecon = &pau->m_iCurrReconCoef;
#if defined(PLATFORM_OPTIMIZATION_MINIMIZE_BRANCHING)
    Int iMask1,iMask2;
#endif
    INTEGER_ONLY( Int iShift; )
    Int iMaskResampleRatioPow;
    const Int *rgiBarkIndex;
    Int *piHighCutOff = &pau->m_iHighCutOffCurr;
    Int iHighToBeZeroed;
    QuantFloat qfltQuantizer;   // eithe a FastFloat or a Float, as appropriate to the build.
    Bool fPrint = WMAB_FALSE;
#ifdef PROFILE
    FunctionProfile fp;
    FunctionProfileStart(&fp,DECODE_COEFFICENTS_HIGH_RATE_PROFILE);
#endif

    assert (!pau->m_fNoiseSub &&  pau->m_iWeightingMode == BARK_MODE);
    assert (pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame] != 0);
    assert (pau->m_cFrameSampleHalf <= (1<<12));                                            
    assert (pau->m_iSubFrameSizeWithUpdate != 0);
    DEBUG_BREAK_AT_FRAME_DECODE;

    if (pau->m_iSubFrameSizeWithUpdate <= 0 || pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame] <= 0)
        wmaResult = WMA_E_BROKEN_FRAME;
    CHECKWMA_EXIT (wmaResult);

    iMaskResampleRatio = (pau->m_iSubFrameSizeWithUpdate << 12) /                           
                          pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame];    
    iMaskResampleRatioPow = LOG2(iMaskResampleRatio);
    rgiBarkIndex       = pau->m_rgiBarkIndexOrig + (NUM_BARK_BAND + 1) *                    
                         LOG2 (pau->m_cFrameSampleHalf / pau->m_iSubFrameSizeWithUpdate);   
    cValidBarkBandLatestUpdate = pau->m_rgcValidBarkBand [LOG2 (pau->m_cFrameSampleHalf / pau->m_iSubFrameSizeWithUpdate)];

    //// DEBUG NOTES below are preceeded by four slashes and typically allow cut and paste so you can view scaled integers as floats
    //// They are on the line below where the calculation occurs - of course, with BUILD_INT_FLOAT, they are unnecessary

    // zero all coefs so we can just skip the many zero ones as we detect them below
    // note 70% of coefficents are zero in High Rate
    // wchen: moved to outside
    //memset (rgiCoefRecon , 0, sizeof (CoefType) * pau->m_cHighCutOff);//(iRun+pau->m_cLowCutOff));                     

    iBark = 0;
    pau->m_iLevel = 0;
    *piHighCutOff = ppcinfo->m_cSubbandActual-1;//values need to be offset by -1 too 
    pau->m_iNextBarkIndex = -1; 

    //Scan for the first bark index = note iRecon is 0 and rgiBarkIndex[1] ==0 for 16000 Hz and 11025 Hz frames with 128 oir 64 samples
    while ((((*piRecon) * iMaskResampleRatio) >> 12) >= rgiBarkIndex [iBark+1]) 
        ++iBark;
        
    TRACEWMA_EXIT (wmaResult, (*pau->aupfnGetNextRun) (pcaller, ppcinfo, piBitCnt));
    DBG_RUNLEVEL(g_cBitGet-21,pau->m_cRunOfZeros,pau->m_iLevel,pau->m_iSign,fPrint);
    *piRecon += (I16) pau->m_cRunOfZeros+1;

    while (*piRecon < *piHighCutOff && iBark < cValidBarkBandLatestUpdate) {

        //Search for the next bark index
        while ((((*piRecon) * iMaskResampleRatio) >> 12) >= rgiBarkIndex [iBark+1]) 
            ++iBark;

        if ( iBark >= cValidBarkBandLatestUpdate )
        {
            assert( iBark < cValidBarkBandLatestUpdate );
            break;
        }

        // Get the quantStep * (10^(1/16))^(MaxMaskQ-MaskQ[iRecon])
        // as qfltQuantizer.fraction/(1<<(23-qfltQuantizer.exponent))
        // then scale coefficent to give it five FracBits
        if (*piRecon == pau->m_iNextBarkIndex) {                               
            //Reconstruct the coefficent before getting the next weighting factor if it lies at the end of a bark band        
            ctCoefRecon = MULT_QUANT(pau->m_iLevel,qfltQuantizer);

            //// Unsigned Float CoefRecon = ctCoefRecon/(1.0F*(1<<(qfltQuantizer.iFracBits+16-31)))
            INTEGER_ONLY( ctCoefRecon = SCALE_COEF_RECON(ctCoefRecon) );
            //// Unsigned Float CoefRecon = ctCoefRecon/32.0F
            VERIFY_DECODED_COEFFICENT(iBark-1);
            qfltQuantizer = prvWeightedQuantization(pau,ppcinfo,iBark);

            //// Float Quantizer = qfltQuantizer.iFraction/(1024.0F*(1<<(qfltQuantizer-10)))
            MAKE_MASK_FOR_SCALING(qfltQuantizer.iFracBits);
        } else {
            //Otherwize get the next weighting factor first
            assert( *piRecon > pau->m_iNextBarkIndex );
            qfltQuantizer = prvWeightedQuantization(pau,ppcinfo,iBark);

            //// Float Quantizer = qfltQuantizer.iFraction/(1024.0F*(1<<(qfltQuantizer-10)))
            MAKE_MASK_FOR_SCALING(qfltQuantizer.iFracBits);
            ctCoefRecon = MULT_QUANT(pau->m_iLevel,qfltQuantizer);

            //// Unsigned Float CoefRecon = ctCoefRecon/(1.0F*(1<<(qfltQuantizer.iFracBits+16-31)))
            INTEGER_ONLY( ctCoefRecon = SCALE_COEF_RECON(ctCoefRecon) );
            //// Unsigned Float CoefRecon = ctCoefRecon/32.0F
            VERIFY_DECODED_COEFFICENT(iBark);
        }

        //Calculate the index of the end of this bark band
        if (iMaskResampleRatioPow > 12){
            pau->m_iNextBarkIndex = (rgiBarkIndex [iBark + 1] + (1<<(iMaskResampleRatioPow-13))) >> (iMaskResampleRatioPow-12);
        } else {
            pau->m_iNextBarkIndex = (rgiBarkIndex [iBark + 1] << (12-iMaskResampleRatioPow));
        }
        pau->m_iNextBarkIndex--; //correct by -1
        if (pau->m_iNextBarkIndex > *piHighCutOff) 
            pau->m_iNextBarkIndex = *piHighCutOff;

        do {
            rgiCoefRecon [*piRecon] = INTEGER_OR_INT_FLOAT( (ctCoefRecon^pau->m_iSign)-pau->m_iSign, 
                                    pau->m_iSign ? -ctCoefRecon : ctCoefRecon );

            //// Float CoefRecon = rgiCoefRecon [iRecon]/32.0F
            MONITOR_RANGE(gMR_CoefRecon,FLOAT_FROM_COEF(rgiCoefRecon[*piRecon]));
            MONITOR_COUNT_CONDITIONAL(rgiCoefRecon[*piRecon]==0,gMC_zeroCoefRecon,pau->m_cRunOfZeros);
            TRACEWMA_EXIT (wmaResult, (*pau->aupfnGetNextRun) (pcaller, ppcinfo, piBitCnt));
            DBG_RUNLEVEL(g_cBitGet-21,pau->m_cRunOfZeros,pau->m_iLevel,pau->m_iSign,fPrint);
            *piRecon += (I16) pau->m_cRunOfZeros+1;
            if (*piRecon >= pau->m_iNextBarkIndex) 
                break;
            ctCoefRecon = MULT_QUANT(pau->m_iLevel,qfltQuantizer);

            INTEGER_ONLY( ctCoefRecon = SCALE_COEF_RECON(ctCoefRecon) );
            VERIFY_DECODED_COEFFICENT(iBark);
        } while (WMAB_TRUE);   
        iBark++;
    }
    if (*piRecon == *piHighCutOff) {
        if ( *piRecon >= pau->m_iNextBarkIndex  )
        {   // skipped here via a cRunOfZeros past one or more iBark increments
            while ( ((iBark-1) < cValidBarkBandLatestUpdate) && (((*piRecon) * iMaskResampleRatio) >> 12) >= rgiBarkIndex [iBark] ) 
                ++iBark;
            if ( (iBark-1) <= cValidBarkBandLatestUpdate )
            {   
                qfltQuantizer = prvWeightedQuantization(pau,ppcinfo,iBark-1);

                //// Float Quantizer = qfltQuantizer.iFraction/(1024.0F*(1<<(qfltQuantizer-10)))
                MAKE_MASK_FOR_SCALING(qfltQuantizer.iFracBits);
            }
        }
        else
        {
            assert(WMAB_FALSE);
        }
        ctCoefRecon = MULT_QUANT(pau->m_iLevel,qfltQuantizer);

        //// Unsigned Float CoefRecon = ctCoefRecon/(1.0F*(1<<(qfltQuantizer.iFracBits+16-31)))
        INTEGER_ONLY( ctCoefRecon = SCALE_COEF_RECON(ctCoefRecon) );
        //// Unsigned Float CoefRecon = ctCoefRecon/32.0F
        VERIFY_DECODED_COEFFICENT(iBark-1);
        rgiCoefRecon [*piRecon] = INTEGER_OR_INT_FLOAT( (ctCoefRecon^pau->m_iSign)-pau->m_iSign, 
                                pau->m_iSign ? -ctCoefRecon : ctCoefRecon );

        //// Float CoefRecon = rgiCoefRecon [iRecon]/32.0F
        MONITOR_RANGE(gMR_CoefRecon,FLOAT_FROM_COEF(rgiCoefRecon[*piRecon]));
        MONITOR_COUNT_CONDITIONAL(rgiCoefRecon[*piRecon]==0,gMC_zeroCoefRecon,pau->m_cRunOfZeros);
    }
    assert (*piRecon <= pau->m_cSubband); 
    assert (iBark <=  cValidBarkBandLatestUpdate );

    // do low cutoff here so there is less branching in the above loop
    if ( pau->m_cLowCutOff > 0 )
    {
        memset (rgiCoefRecon, 0, sizeof (Int) * pau->m_cLowCutOff);

#       if defined(_DEBUG) && defined(WMA_MONITOR)
        {   int ii;
            for( ii = 0; ii < pau->m_cLowCutOff; ii++ )
                MONITOR_RANGE(gMR_CoefRecon,0);
        }
#       endif
    }

    //do high cutoff here 
    iHighToBeZeroed = sizeof(CoefType) * (pau->m_cSubbandAdjusted - pau->m_cHighCutOffAdjusted);
    memset (rgiCoefRecon + pau->m_cHighCutOffAdjusted, 0, iHighToBeZeroed);

#   if defined(_DEBUG) && defined(WMA_MONITOR)
    {   
    int ii;
    for( ii = 0; ii < iHighToBeZeroed; ii += sizeof(Int) )
        MONITOR_RANGE(gMR_CoefRecon,0);
    }
#   endif

exit:
#ifdef PROFILE
    FunctionProfileStop(&fp);
#endif
    return wmaResult;
}

#undef SCALE_COEFFICENT 
#undef MAKE_MASK_FOR_SCALING
#undef MULT_QUANT


void prvInitDiscardSilence(CAudioObject *pau)
{
    // If this is the very first frame, we need to determine if we are at the
    // start-of-file, rather than seeking. If so, we need to discard the silence
    // frames. If not, we need to only discard half a subframe. NOTE that for
    // V4 encoded streams, WE WILL GUESS INCORRECTLY. Our justification for accepting
    // this is that V4 never had timestamps and so sync was never guaranteed anyway.
    Bool fStartOfStream = WMAB_TRUE;
    int i;

    assert(CODEC_BEGIN == pau->m_codecStatus);

    // Due to SCRUNCH bug #32, v5 encoder forces fMaskUpdate to TRUE and
    // all channels' m_iPower to 1 in the very first frame only. If we find that
    // fMaskUpdate, m_iPower are all TRUE but in fact there is no power here,
    // then we know this is a v5-encoded file and this is start-of-file
    if (WMAB_FALSE == pau->m_subfrmconfigCurr.m_rgfMaskUpdate[0])
        fStartOfStream = WMAB_FALSE;

    for (i = 0; i < pau->m_cChannel; i++)
    {
        if (0 == pau->m_rgpcinfo[i].m_iPower)
            fStartOfStream = WMAB_FALSE;
    }

    if (fStartOfStream)
    {
        int iChan;
            
        // Bitstream has forced update, claims non-zero power for all channels.
        // Verify that claim.
        for (iChan = 0; iChan < pau->m_cChannel; iChan++)
        {
            if (0 != pau->m_rgpcinfo[iChan].m_iActualPower)
                fStartOfStream = WMAB_FALSE;
        } // for (channels)
    }

    // Finally the moment of truth: set m_iDiscardSilence
    pau->m_fSeekAdjustment = WMAB_FALSE;
    if (fStartOfStream)
        pau->m_iDiscardSilence = pau->m_cFrameSampleAdjusted;
    else
    {
        pau->m_iDiscardSilence = pau->m_iCoefRecurQ2 - pau->m_iCoefRecurQ1;
        assert(pau->m_iDiscardSilence >= 0);
        pau->m_fSeekAdjustment = WMAB_TRUE;
    }
}


void prvDiscardSilence(CAudioObject *pau, U16 *pcSampleDecoded,
                       U16 iChannels, U8 *pbBuf)
{
    if (*pcSampleDecoded > pau->m_iDiscardSilence)
    {
        // We decoded more than we intend to discard.
        // Discard samples and collapse remaining samples to start of buffer
        memmove(pbBuf, pbBuf + (pau->m_iDiscardSilence * iChannels),
            (*pcSampleDecoded - pau->m_iDiscardSilence) * iChannels);
        *pcSampleDecoded -= (U16) pau->m_iDiscardSilence;
        pau->m_iDiscardSilence = 0;
    }
    else
    {
        // We intend to discard the entire output
        pau->m_iDiscardSilence -= *pcSampleDecoded;
        *pcSampleDecoded = 0;
    }
}



void SetActualPower(const I16 *piCoefQ, const int iCount,
                    PerChannelInfo *ppcinfo, const Status codecStatus)
{
    int i;

    ppcinfo->m_iActualPower = 0;
    if (CODEC_BEGIN != codecStatus || 0 == ppcinfo->m_iPower || NULL == piCoefQ)
        return;

    for (i = 0; i < iCount; i++)
    {
        if (0 != piCoefQ[i])
        {
            ppcinfo->m_iActualPower = 1;
            break;
        }
    }
}



void SetActualPowerHighRate(const I32 *piCoefRecon, const int iCount,
                            PerChannelInfo *ppcinfo, const Status codecStatus)
{
    int i;

    ppcinfo->m_iActualPower = 0;
    if (CODEC_BEGIN != codecStatus || 0 == ppcinfo->m_iPower || NULL == piCoefRecon)
        return;

    for (i = 0; i < iCount; i++)
    {
        if (0 != piCoefRecon[i])
        {
            ppcinfo->m_iActualPower = 1;
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\share.cpp ===
/*************************************************************************

Copyright (c) 1996  Microsoft Corporation

Module Name:

        vopSes.cpp

Abstract:

        Base class for the encoder for one VOP session.

Author:

        Ming-Chieh Lee (mingcl@microsoft.com) 20-March-1996
        Chuang Gu (chuanggu@microsoft.com) 10-December-1999

Revision History:

*************************************************************************/
#include "bldsetup.h"

#include "xplatform.h"
#include "typedef.hpp"
#include "wmvdec_member.h"
#include "wmvdec_function.h"
#include <stdlib.h>
#include "motioncomp_wmv.h"
#include "tables_wmv.h"
#if defined(macintosh) && defined(_MAC_VEC_OPT)
#include "motioncomp_altivec.h"
#endif

#ifdef _WMV_TARGET_X86_
#include "opcodes.h"
#endif 

#ifndef OPT_REPEATPAD_ARM 
Void_WMV g_RepeatRef0Y (
	U8_WMV* ppxlcRef0Y,
	CoordI  iStart, 
    CoordI  iEnd,
	I32_WMV     iOldLeftOffet,
	Bool_WMV    fTop, 
    Bool_WMV    fBottom,
    I32_WMV     iWidthY,
    I32_WMV     iWidthYPlusExp,
    I32_WMV     iWidthPrevY
)
{
	const U8_WMV* ppxliOldLeft = ppxlcRef0Y + iOldLeftOffet;
	const U8_WMV* ppxliOldRight = ppxliOldLeft + iWidthY - 1;
	const U8_WMV* ppxliOldTopLn = ppxliOldLeft - EXPANDY_REFVOP;
	U8_WMV* ppxliNew = (U8_WMV*) ppxliOldTopLn;
	U8_WMV* ppxliNewPlusWidth;
    I32_WMV iResidue = iWidthPrevY - iWidthYPlusExp;
	
	CoordI y;
#ifndef HITACHI	
	for (y = iStart; y < iEnd; y++) { // x-direction interpolation
		U32_WMV uipadValueLeft;
		U32_WMV uipadValueRight;
        I32_WMV x;
		uipadValueLeft = *ppxliOldLeft;	
		uipadValueRight = *ppxliOldRight;
		uipadValueLeft |= (uipadValueLeft << 8);
		uipadValueRight |= (uipadValueRight << 8);
		uipadValueLeft |= (uipadValueLeft << 16);
		uipadValueRight |= (uipadValueRight << 16);
//		uipadValueLeft |= (uipadValueLeft << 32);
//		uipadValueRight |= (uipadValueRight << 32);
		ppxliNewPlusWidth = ppxliNew + iWidthYPlusExp;
		for (x = 0; x < EXPANDY_REFVOP; x += 4) {
			*(U32_WMV *)(ppxliNew + x) = uipadValueLeft;
			*(U32_WMV *)(ppxliNewPlusWidth + x) = uipadValueRight;
		}
		ppxliNew += iWidthYPlusExp;
		ppxliNew += iResidue;
		ppxliOldLeft += iWidthPrevY;
		ppxliOldRight += iWidthPrevY;
	}
#else
	for (y = iStart; y < iEnd; y++) { // x-direction interpolation
		U64 uipadValueLeft;
		U64 uipadValueRight;
        I32_WMV x;
		uipadValueLeft.dwLo = (DWORD)*ppxliOldLeft;	
		uipadValueRight.dwLo = (DWORD)*ppxliOldRight;
		uipadValueLeft.dwLo |= (uipadValueLeft.dwLo << 8);
		uipadValueRight.dwLo |= (uipadValueRight.dwLo << 8);
		uipadValueLeft.dwLo |= (uipadValueLeft.dwLo << 16);
		uipadValueRight.dwLo |= (uipadValueRight.dwLo << 16);
		uipadValueLeft.dwHi = (uipadValueLeft.dwLo );
		uipadValueRight.dwHi = (uipadValueRight.dwLo );
		ppxliNewPlusWidth = ppxliNew + iWidthYPlusExp;
		for (x = 0; x < EXPANDY_REFVOP; x += 8) {
			*(U64 *)(ppxliNew + x) = uipadValueLeft;
			*(U64 *)(ppxliNewPlusWidth + x) = uipadValueRight;
		}
		ppxliNew += iWidthYPlusExp;
		ppxliNew += iResidue;
		ppxliOldLeft += iWidthPrevY;
		ppxliOldRight += iWidthPrevY;
	}
#endif
    {
	    I32_WMV iWidthPrevYDiv8 = iWidthPrevY >> 3;
	    U8_WMV* ppxliSrc;
	    U8_WMV* ppxliDst;
	    if (fTop) {
		    U8_WMV* ppxliLeftTop = ppxlcRef0Y;
		    for (y = 0; y < EXPANDY_REFVOP; y++) {
                I32_WMV x;
			    //memcpy (ppxliLeftTop, ppxliOldTopLn, iWidthPrevY);
			    ppxliSrc = (U8_WMV*) ppxliOldTopLn;
			    ppxliDst = (U8_WMV*) ppxliLeftTop;
			    for (x = 0; x < iWidthPrevYDiv8; x++) {
				    *(U64 *) ppxliDst = *(U64 *) ppxliSrc;
				    ppxliSrc += 8;
				    ppxliDst += 8;
			    }
			    ppxliLeftTop += iWidthPrevY;
		    }
	    }
	    if (fBottom) {
		    const U8_WMV* ppxliOldBotLn = ppxliNew - iWidthPrevY;
            I32_WMV iHeightYPadded = (iEnd + 15) & ~15;
            I32_WMV iBotExtend = iHeightYPadded - iEnd + EXPANDY_REFVOP;
		    for (y = 0; y < iBotExtend; y++) {
                I32_WMV x;
			    //memcpy (ppxliNew, ppxliOldBotLn, iWidthPrevY);
			    ppxliSrc = (U8_WMV*) ppxliOldBotLn;
			    ppxliDst = (U8_WMV*) ppxliNew;
			    for (x = 0; x < iWidthPrevYDiv8; x++) {
				    *(U64 *) ppxliDst = *(U64 *) ppxliSrc;
				    ppxliSrc += 8;
				    ppxliDst += 8;
			    }
			    ppxliNew += iWidthPrevY;
		    }
	    }
    }
}

Void_WMV g_RepeatRef0UV (
	U8_WMV* ppxlcRef0U,
	U8_WMV* ppxlcRef0V,
	CoordI  iStart, CoordI iEnd,
	I32_WMV     iOldLeftOffet,
	Bool_WMV    fTop, 
    Bool_WMV    fBottom,
    I32_WMV     iWidthUV,
    I32_WMV     iWidthUVPlusExp,
    I32_WMV     iWidthPrevUV
)
{
	const U8_WMV* ppxliOldLeftU = ppxlcRef0U + iOldLeftOffet;
	const U8_WMV* ppxliOldLeftV = ppxlcRef0V + iOldLeftOffet;
	const U8_WMV* ppxliOldRightU = ppxliOldLeftU + iWidthUV - 1;
	const U8_WMV* ppxliOldRightV = ppxliOldLeftV + iWidthUV - 1;
	const U8_WMV* ppxliOldTopLnU = ppxliOldLeftU - EXPANDUV_REFVOP;
	const U8_WMV* ppxliOldTopLnV = ppxliOldLeftV - EXPANDUV_REFVOP;
	U8_WMV* ppxliNewU = (U8_WMV*) ppxliOldTopLnU;
	U8_WMV* ppxliNewV = (U8_WMV*) ppxliOldTopLnV;
	U8_WMV* ppxliNewUPlusWidth;
	U8_WMV* ppxliNewVPlusWidth;
    I32_WMV iResidue = iWidthPrevUV - iWidthUVPlusExp;

	CoordI y;
#ifndef HITACHI
	for (y = iStart; y < iEnd; y++) { // x-direction interpolation
        I32_WMV x;
		U32_WMV uipadValueLeftU, uipadValueLeftV;
		U32_WMV uipadValueRightU, uipadValueRightV;
		uipadValueLeftU = *ppxliOldLeftU;
		uipadValueLeftV = *ppxliOldLeftV;
		uipadValueLeftU |= (uipadValueLeftU << 8);
		uipadValueLeftV |= (uipadValueLeftV << 8);
		uipadValueLeftU |= (uipadValueLeftU << 16);
		uipadValueLeftV |= (uipadValueLeftV << 16);
	//	uipadValueLeftU |= (uipadValueLeftU << 32);
	//	uipadValueLeftV |= (uipadValueLeftV << 32);
		uipadValueRightU = *ppxliOldRightU;
		uipadValueRightV = *ppxliOldRightV;
		uipadValueRightU |= (uipadValueRightU << 8);
		uipadValueRightV |= (uipadValueRightV << 8);
		uipadValueRightU |= (uipadValueRightU << 16);
		uipadValueRightV |= (uipadValueRightV << 16);
	//	uipadValueRightU |= (uipadValueRightU << 32);
	//	uipadValueRightV |= (uipadValueRightV << 32);
		ppxliNewUPlusWidth = ppxliNewU + iWidthUVPlusExp;
		ppxliNewVPlusWidth = ppxliNewV + iWidthUVPlusExp;
		for (x = 0; x < EXPANDUV_REFVOP; x += 4) {
			*(U32_WMV *)(ppxliNewU + x) = uipadValueLeftU;
			*(U32_WMV *)(ppxliNewV + x) = uipadValueLeftV;
			*(U32_WMV *)(ppxliNewUPlusWidth + x) = uipadValueRightU;
			*(U32_WMV *)(ppxliNewVPlusWidth + x) = uipadValueRightV;
		}

		ppxliNewU += iWidthUVPlusExp;		
		ppxliNewV += iWidthUVPlusExp;
		ppxliNewU += iResidue;		
		ppxliNewV += iResidue;		
		ppxliOldLeftU += iWidthPrevUV;
		ppxliOldLeftV += iWidthPrevUV;
		ppxliOldRightU += iWidthPrevUV;
		ppxliOldRightV += iWidthPrevUV;
	}
#else
	for (y = iStart; y < iEnd; y++) { // x-direction interpolation
        I32_WMV x;
		U64 uipadValueLeftU, uipadValueLeftV;
		U64 uipadValueRightU, uipadValueRightV;
		uipadValueLeftU.dwLo = (DWORD)*ppxliOldLeftU;
		uipadValueLeftV.dwLo = (DWORD)*ppxliOldLeftV;
		uipadValueLeftU.dwLo |= (uipadValueLeftU.dwLo << 8);
		uipadValueLeftV.dwLo |= (uipadValueLeftV.dwLo << 8);
		uipadValueLeftU.dwLo |= (uipadValueLeftU.dwLo << 16);
		uipadValueLeftV.dwLo |= (uipadValueLeftV.dwLo << 16);
		uipadValueLeftU.dwHi = (uipadValueLeftU.dwLo);
		uipadValueLeftV.dwHi = (uipadValueLeftV.dwLo);
		uipadValueRightU.dwLo = (DWORD)*ppxliOldRightU;
		uipadValueRightV.dwLo = (DWORD)*ppxliOldRightV;
		uipadValueRightU.dwLo |= (uipadValueRightU.dwLo << 8);
		uipadValueRightV.dwLo |= (uipadValueRightV.dwLo << 8);
		uipadValueRightU.dwLo |= (uipadValueRightU.dwLo << 16);
		uipadValueRightV.dwLo |= (uipadValueRightV.dwLo << 16);
		uipadValueRightU.dwHi = (uipadValueRightU.dwLo );
		uipadValueRightV.dwHi = (uipadValueRightV.dwLo);
		ppxliNewUPlusWidth = ppxliNewU + iWidthUVPlusExp;
		ppxliNewVPlusWidth = ppxliNewV + iWidthUVPlusExp;
		for (x = 0; x < EXPANDUV_REFVOP; x += 8) {
			*(U64 *)(ppxliNewU + x) = uipadValueLeftU;
			*(U64 *)(ppxliNewV + x) = uipadValueLeftV;
			*(U64 *)(ppxliNewUPlusWidth + x) = uipadValueRightU;
			*(U64 *)(ppxliNewVPlusWidth + x) = uipadValueRightV;
		}
		ppxliNewU += iWidthUVPlusExp;		
		ppxliNewV += iWidthUVPlusExp;
		ppxliNewU += iResidue;		
		ppxliNewV += iResidue;		
		ppxliOldLeftU += iWidthPrevUV;
		ppxliOldLeftV += iWidthPrevUV;
		ppxliOldRightU += iWidthPrevUV;
		ppxliOldRightV += iWidthPrevUV;
	}
#endif
    {
        I32_WMV iWidthPrevUVDiv8 = iWidthPrevUV >> 3;
        U8_WMV* ppxliSrcU;
        U8_WMV* ppxliSrcV;
        U8_WMV* ppxliDstU;
        U8_WMV* ppxliDstV;
        if (fTop) {
            U8_WMV* ppxliLeftTopU = ppxlcRef0U;
            U8_WMV* ppxliLeftTopV = ppxlcRef0V;
            for (y = 0; y < EXPANDUV_REFVOP; y++) {
                I32_WMV x;
                ppxliSrcU = (U8_WMV*) ppxliOldTopLnU;
                ppxliSrcV = (U8_WMV*) ppxliOldTopLnV;
                ppxliDstU = ppxliLeftTopU;
                ppxliDstV = ppxliLeftTopV;
                for (x = 0; x < iWidthPrevUVDiv8; x++) {
                    *(U64 *) ppxliDstU = *(U64 *) ppxliSrcU;
                    ppxliSrcU += 8;
                    ppxliDstU += 8;
                    *(U64 *) ppxliDstV = *(U64 *) ppxliSrcV;
                    ppxliSrcV += 8;
                    ppxliDstV += 8;
                }
                ppxliLeftTopU += iWidthPrevUV;
                ppxliLeftTopV += iWidthPrevUV;
            }
        }
        if (fBottom) {
            const U8_WMV* ppxliOldBotLnU = ppxliNewU - iWidthPrevUV;
            const U8_WMV* ppxliOldBotLnV = ppxliNewV - iWidthPrevUV;
            I32_WMV iHeightUVPadded = ((iEnd * 2 + 15) & ~15)/2;
            I32_WMV iBotExtend = iHeightUVPadded - iEnd + EXPANDUV_REFVOP;       
            for (y = 0; y < iBotExtend; y++) {
                I32_WMV x;
                ppxliSrcU = (U8_WMV*) ppxliOldBotLnU;
                ppxliSrcV = (U8_WMV*) ppxliOldBotLnV;
                ppxliDstU = ppxliNewU;
                ppxliDstV = ppxliNewV;
                for (x = 0; x < iWidthPrevUVDiv8; x++) {
                    *(U64 *) ppxliDstU = *(U64 *) ppxliSrcU;
                    ppxliSrcU += 8;
                    ppxliDstU += 8;
                    *(U64 *) ppxliDstV = *(U64 *) ppxliSrcV;
                    ppxliSrcV += 8;
                    ppxliDstV += 8;
                }
                ppxliNewU += iWidthPrevUV;
                ppxliNewV += iWidthPrevUV;
            }
        }
    }
}
#endif //OPT_REPEATPAD_ARM

//THR1 = the threshold before we consider neighboring pixels to be "diffrent"
#define THR1_TMP 2
//THR2 = the total number of "diffrent" pixels under which we use stronger filter
#define THR2_TMP 6

#define phi(a) ((abs(a) <= THR1_TMP) ? 1 : 0)

#if !defined(_ARM_ASM_LOOPFILTER_OPT_)&&!defined(_MIPS_ASM_LOOPFILTER_OPT_)&&!defined(_SH4_ASM_LOOPFILTER_OPT_)

Void_WMV g_FilterHorizontalEdge_WMV(U8_WMV* pV5, I32_WMV iPixelDistance, I32_WMV iStepSize, 
                            I32_WMV iNumPixel)
{
    // Filter horizontal line        
    for (I32_WMV i = 0; i < iNumPixel; ++i) {                                                                                                                                                                                                    
        I32_WMV v1, v2, v3, v4, v5, v6, v7, v8;
        I32_WMV v4_v5, a30, absA30;
        U8_WMV *pVtmp = pV5;

        v5 = *pV5;
        pVtmp -= iPixelDistance;
        v4 = *pVtmp;
        pVtmp -= iPixelDistance;
        v3 = *pVtmp;
        pVtmp -= iPixelDistance;
        v2 = *pVtmp;
        pVtmp -= iPixelDistance;
        v1 = *pVtmp;
        pVtmp = pV5 + iPixelDistance;
        v6 = *pVtmp;        
        pVtmp += iPixelDistance;
        v7 = *pVtmp;
        pVtmp += iPixelDistance;
        v8 = *pVtmp;

        v4_v5 = v4 - v5;
        a30 = (2*(v3-v6) - 5*v4_v5 + 4) >> 3;
        absA30 = abs(a30);
        if (absA30 < iStepSize) {

            I32_WMV v2_v3 = v2 - v3;
            I32_WMV v6_v7 = v6 - v7;
            I32_WMV a31 = (2 * (v1-v4) - 5 * v2_v3 + 4) >> 3;                                 
            I32_WMV a32 = (2 * (v5-v8) - 5 * v6_v7 + 4) >> 3;                                 
            I32_WMV iMina31_a32 = min(abs(a31),abs(a32)); 

            if (iMina31_a32 < absA30){
                I32_WMV a, c;                
                c = v4_v5/2;
               
                if (0 < c) {
                    if (a30 < 0) {
                        I32_WMV dA30;
                        dA30 = absA30 - iMina31_a32 ;  // > 0
                        a = (5 * dA30) >> 3; // >= 0
                        if (a > c) a = c;
                        *(pV5 - iPixelDistance) = v4 - a;                                                                                         
                        *(pV5) = v5 + a;
                    } 
                } else if (c < 0) {
                    if (a30 >= 0) {                       
                        I32_WMV dA30;
                        dA30 =  iMina31_a32 - absA30; // < 0
                        a = (5 * dA30 + 7) >> 3; // <= 0
                        if (a < c) a = c;
                        *(pV5 - iPixelDistance) = v4 - a;                                                                                         
                        *(pV5) = v5 + a;
                    }
                }
            }
        }        
        pV5 ++;
    }
}


Void_WMV g_FilterVerticalEdge_WMV(U8_WMV* pVhstart, I32_WMV iPixelDistance, I32_WMV iStepSize, 
                          I32_WMV iNumPixel)
{
    U8_WMV *pVh;
    // Filter vertical line
    for (int i = 0; i < iNumPixel; ++i) {
        
        I32_WMV v1, v2, v3, v4, v5, v6, v7, v8;  
        I32_WMV v4_v5, a30, absA30;
        pVh = pVhstart;            

        v1 = pVh[1]; 
        v2 = pVh[2];
        v3 = pVh[3]; 
        v4 = pVh[4];
        v5 = pVh[5];
        v6 = pVh[6]; 
        v7 = pVh[7]; 
        v8 = pVh[8]; 

        v4_v5 = v4 - v5;
        a30 = (2*(v3-v6) - 5*v4_v5 + 4) >> 3;
        absA30 = abs(a30);
        if (absA30 < iStepSize) {

            I32_WMV v2_v3 = v2 - v3;
            I32_WMV v6_v7 = v6 - v7;
            I32_WMV a31 = (2 * (v1-v4) - 5 * v2_v3 + 4) >> 3;                                 
            I32_WMV a32 = (2 * (v5-v8) - 5 * v6_v7 + 4) >> 3;                                 
            I32_WMV iMina31_a32 = min(abs(a31),abs(a32)); 

            if (iMina31_a32 < absA30){
                I32_WMV a, c;                
                c = v4_v5/2;
               
                if (0 < c) {
                    if (a30 < 0) {
                        I32_WMV dA30;
                        dA30 = absA30 - iMina31_a32 ;  // > 0
                        a = (5 * dA30) >> 3; // >= 0
                        if (a > c) a = c;
                        pVh[4] = v4 - a;                                                                                         
                        pVh[5] = v5 + a;
                    } 
                } else if (c < 0) {
                    if (a30 >= 0) {                       
                        I32_WMV dA30;
                        dA30 =  iMina31_a32 - absA30; // < 0
                        a = (5 * dA30 + 7) >> 3; // <= 0
                        if (a < c) a = c;
                        pVh[4] = v4 - a;                                                                                         
                        pVh[5] = v5 + a;
                    }
                }
            }
        }       
        pVhstart += iPixelDistance;                
    }
}

#endif

Void_WMV FilterEdgeShortTagMBRow(
    tWMVDecInternalMember *pWMVDec, 
    U8_WMV* ppxlcCenter, 
    I32_WMV iPixelDistance, 
    I32_WMV iStepSize, 
    I32_WMV iMBsPerRow, 
    Bool_WMV bFirst, 
    Bool_WMV bLast
    )
{
    U8_WMV* pVhstart;
    U8_WMV* pV5 = ppxlcCenter;
    U8_WMV* pV5x = pV5 + 8*iPixelDistance;

    I32_WMV iVertSize = 16;
    I32_WMV iVertOffset = -4;
    I32_WMV imbX;

    assert(bFirst == FALSE);

    if (bLast)
        iVertSize += 4;

    (*pWMVDec->m_pFilterHorizontalEdge)(pV5, iPixelDistance, iStepSize, 4);
    pV5 += 4;
    (*pWMVDec->m_pFilterHorizontalEdge)(pV5x, iPixelDistance, iStepSize, 4);    
    pV5x += 4;

    // Loop through the macroblocks in the row filtering horiz. line first then vertical
    pVhstart = ppxlcCenter + iVertOffset*iPixelDistance + 3;

    for (imbX = 0; imbX < iMBsPerRow - 1; imbX++) {
        (*pWMVDec->m_pFilterHorizontalEdge)(pV5, iPixelDistance, iStepSize, 16);
        pV5 += 16;//iPixelDistance*8;          
        (*pWMVDec->m_pFilterHorizontalEdge)(pV5x, iPixelDistance, iStepSize, 16);
        pV5x += 16;

        (*pWMVDec->m_pFilterVerticalEdge)(pVhstart, iPixelDistance, iStepSize, iVertSize);
        (*pWMVDec->m_pFilterVerticalEdge)(pVhstart + 8, iPixelDistance, iStepSize, iVertSize);
        pVhstart += 16;
    }

    (*pWMVDec->m_pFilterHorizontalEdge)(pV5, iPixelDistance, iStepSize, 12);
    (*pWMVDec->m_pFilterHorizontalEdge)(pV5x, iPixelDistance, iStepSize, 12);
}

Void_WMV FilterEdgeShortTagBlockRow(tWMVDecInternalMember *pWMVDec, U8_WMV* ppxlcCenter, I32_WMV iPixelDistance, I32_WMV iStepSize, I32_WMV iBlocksPerRow, Bool_WMV bFirst, Bool_WMV bLast)
{    
    U8_WMV *pVhstart;
    U8_WMV *pV5 = ppxlcCenter;

    I32_WMV iVertSize = 8;
    I32_WMV iVertOffset = -4;
    I32_WMV iblkX;

    if (bFirst)
    {
        iVertSize = 12;
        iVertOffset = -8;
    }
    if (bLast)
        iVertSize += 4;

    pVhstart = ppxlcCenter + iPixelDistance*iVertOffset + 3;

    (*pWMVDec->m_pFilterHorizontalEdge)(pV5, iPixelDistance, iStepSize, 4);
    pV5 += 4;

    // Loop through the blocks in the row filtering horiz line first then vertical
    for (iblkX = 0; iblkX < iBlocksPerRow - 1; iblkX++) {
        (*pWMVDec->m_pFilterHorizontalEdge)(pV5, iPixelDistance, iStepSize, 8);
        pV5 += 8;
        (*pWMVDec->m_pFilterVerticalEdge)(pVhstart, iPixelDistance, iStepSize,  iVertSize);        
        pVhstart += 8;
    }

    // Filter last four pixels in the horizontal line
    (*pWMVDec->m_pFilterHorizontalEdge)(pV5, iPixelDistance, iStepSize, 4);

}

Void_WMV DeblockSLFrame (
    tWMVDecInternalMember *pWMVDec, 
    U8_WMV* ppxliY, U8_WMV* ppxliU, U8_WMV* ppxliV,
    Bool_WMV bMultiThread, U32_WMV iThreadID, I32_WMV iMBStartX, I32_WMV iMBEndX, I32_WMV iMBStartY, I32_WMV iMBEndY
) // Frame-based deblocking
{
    FUNCTION_PROFILE_DECL_START(fp,DEBLOCKSLFRAME_PROFILE);
	U8_WMV* ppxliPost;
	I32_WMV iblkSizeXWidthPrevY = pWMVDec->m_iMBSizeXWidthPrevY / 2;
    I32_WMV iMBStartUV = iMBStartY;
    I32_WMV iVertSize = (iMBEndY - iMBStartY) * MB_SIZE;
    I32_WMV iblkY;

    if (iThreadID == pWMVDec->m_uiNumProcessors - 1)
    {
        iMBEndY--;
        iVertSize += 4;
    }
    if (iThreadID == 0)
        iMBStartUV = 2;

    // Deblock Y
    if (iThreadID == 0) {
        FilterEdgeShortTagBlockRow (pWMVDec, ppxliY + iblkSizeXWidthPrevY, pWMVDec->m_iWidthPrevY, pWMVDec->m_iStepSize, 2*iMBEndX, TRUE_WMV, FALSE);
    }
    ppxliPost = ppxliY + iMBStartY * pWMVDec->m_iMBSizeXWidthPrevY;
    for (iblkY = iMBStartY; iblkY < iMBEndY; iblkY++) {
        FilterEdgeShortTagMBRow(pWMVDec, ppxliPost, pWMVDec->m_iWidthPrevY, pWMVDec->m_iStepSize, iMBEndX, FALSE, FALSE);
        ppxliPost += pWMVDec->m_iMBSizeXWidthPrevY;
    }
    if (iThreadID == pWMVDec->m_uiNumProcessors - 1)
        FilterEdgeShortTagMBRow(pWMVDec, ppxliPost, pWMVDec->m_iWidthPrevY, pWMVDec->m_iStepSize, iMBEndX, FALSE, TRUE_WMV);

    (*pWMVDec->m_pFilterVerticalEdge)(ppxliY + (iMBStartY * MB_SIZE - 4) * pWMVDec->m_iWidthPrevY + (iMBEndX * MB_SIZE) - 8 - (5*1 /* adjust to point to the top i.e. pV1)*/), pWMVDec->m_iWidthPrevY, pWMVDec->m_iStepSize, iVertSize);
    // Deblock U
    if (iThreadID == 0) {
        FilterEdgeShortTagBlockRow (pWMVDec, ppxliU + pWMVDec->m_iBlkSizeXWidthPrevUV, pWMVDec->m_iWidthPrevUV, pWMVDec->m_iStepSize, iMBEndX, TRUE_WMV, FALSE);
    }
    ppxliPost = ppxliU + iMBStartUV * pWMVDec->m_iBlkSizeXWidthPrevUV;
    for (iblkY = iMBStartUV; iblkY < iMBEndY; iblkY++) {
        FilterEdgeShortTagBlockRow(pWMVDec, ppxliPost, pWMVDec->m_iWidthPrevUV, pWMVDec->m_iStepSize, iMBEndX, FALSE, FALSE);
        ppxliPost += pWMVDec->m_iBlkSizeXWidthPrevUV;
    }
    if (iThreadID == pWMVDec->m_uiNumProcessors - 1)
        FilterEdgeShortTagBlockRow(pWMVDec, ppxliPost, pWMVDec->m_iWidthPrevUV, pWMVDec->m_iStepSize, iMBEndX, FALSE, TRUE_WMV);

    // Deblock V
    if (iThreadID == 0) {
        FilterEdgeShortTagBlockRow (pWMVDec, ppxliV + pWMVDec->m_iBlkSizeXWidthPrevUV, pWMVDec->m_iWidthPrevUV, pWMVDec->m_iStepSize, iMBEndX, TRUE_WMV, FALSE);
    }
    ppxliPost = ppxliV + iMBStartUV * pWMVDec->m_iBlkSizeXWidthPrevUV;
    for (iblkY = iMBStartUV; iblkY < iMBEndY; iblkY++) {
        FilterEdgeShortTagBlockRow(pWMVDec, ppxliPost, pWMVDec->m_iWidthPrevUV, pWMVDec->m_iStepSize, iMBEndX, FALSE, FALSE);
        ppxliPost += pWMVDec->m_iBlkSizeXWidthPrevUV;
    }
    if (iThreadID == pWMVDec->m_uiNumProcessors - 1)
        FilterEdgeShortTagBlockRow(pWMVDec, ppxliPost, pWMVDec->m_iWidthPrevUV, pWMVDec->m_iStepSize, iMBEndX, FALSE, TRUE_WMV);
    FUNCTION_PROFILE_STOP(&fp);
}

I32_WMV BlkAvgX8(const U8_WMV* ppxlcCurrRecnMB, I32_WMV iWidthPrev, I32_WMV iStepSize)
{
	I32_WMV iSum = 0;
	for (I32_WMV i = 0; i < BLOCK_SIZE; i++){
		for (I32_WMV j = 0; j < BLOCK_SIZE; j++){
			iSum += ppxlcCurrRecnMB[i* iWidthPrev + j];
		}
	}
	return ((iSum + 4) >> 3) / iStepSize;  // iSum / 64 * 8
}


Void_WMV g_InitDecGlobalVars ()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\strmdec_wma.c ===
/*************************************************************************

Copyright (C) 1996-1999  Microsoft Corporation

Module Name:

	strmdec_wma.c

Abstract:

	Decoder BitStream

Author:

	Craig Dowell (craigdo@microsoft.com) 10-December-1996
	Ming-Chieh Lee (mingcl@microsoft.com) 10-December-1996
	Bruce Lin (blin@microsoft.com) 10-December-1996

Revision History:
    Wei-ge Chen (wchen@microsoft.com) 20-July-1999
    Make it in C.


*************************************************************************/

#include "bldsetup.h"

#include <stdio.h>
#include <stdlib.h>
#include "macros.h"
#include "strmdec_wma.h"
#include "msaudiodec.h"

#ifndef S_SUNOS5
const UInt getMask[33] = {
    0x00000000,
    0x00000001,
    0x00000003,
    0x00000007,
    0x0000000f,
    0x0000001f,
    0x0000003f,
    0x0000007f,
    0x000000ff,
    0x000001ff,
    0x000003ff,
    0x000007ff,
    0x00000fff,
    0x00001fff,
    0x00003fff,
    0x00007fff,
    0x0000ffff,
    0x0001ffff,
    0x0003ffff,
    0x0007ffff,
    0x000fffff,
    0x001fffff,
    0x003fffff,
    0x007fffff,
    0x00ffffff,
    0x01ffffff,
    0x03ffffff,
    0x07ffffff,
    0x0fffffff,
    0x1fffffff,
    0x3fffffff,
    0x7fffffff,
    0xffffffff
};
#endif

Void ibstrmInit (CWMAInputBitStream* pibstrm, Bool fAllowPackets)
{
    //added for streaming mode
    pibstrm->m_pfnGetMoreData = NULL;
    pibstrm->m_dwUser  = 0;
    pibstrm->m_dwOwner = 0;    
    pibstrm->m_dwHeaderBuf   = 0;
    pibstrm->m_pBufferBegin  = NULL;
    pibstrm->m_cbBuflenBegin = 0;    // used in association of m_pBufferBegin	
    //end of streaming mode

    pibstrm->m_pBuffer = NULL;
    pibstrm->m_cbBuflen = 0;
    pibstrm->m_dwDot = 0;
    pibstrm->m_dwBitsLeft = 0;
    pibstrm->m_iPrevPacketNum = (1 << NBITS_PACKET_CNT) - 1; // Keep -1 spacing w/ curr pkt num
    pibstrm->m_fAllowPackets = fAllowPackets;
    pibstrm->m_fSuppressPacketLoss = WMAB_TRUE; // Suppress first packet from loss detection
}

Void ibstrmReset(CWMAInputBitStream *pibstrm)
{
    pibstrm->m_dwDot = 0;
    pibstrm->m_dwBitsLeft = 0;
    pibstrm->m_cbBuflen = 0;
    pibstrm->m_fSuppressPacketLoss = WMAB_TRUE;
}

Void ibstrmAttach(CWMAInputBitStream *pibstrm, U32 dwDot, U32 dwBitsLeft, U8* pbSrc, I32 cbSrc)
{
    //added for streaming mode
    pibstrm->m_dwHeaderBuf   = 0;
    pibstrm->m_pBufferBegin  = NULL;
    pibstrm->m_cbBuflenBegin = 0;    // used in association of m_pBufferBegin	
    //end of streaming mode

    pibstrm->m_pBuffer = pbSrc;
    pibstrm->m_cbBuflen = cbSrc;
    pibstrm->m_dwDot = dwDot;
    pibstrm->m_dwBitsLeft = dwBitsLeft;
}

//this peekbits doens't generate ON_HOLD signal
WMARESULT ibstrmPeekBitsNonStop (CWMAInputBitStream *pibstrm, register UInt dwNumBits,
                          U32 *piRetBits)
{
    I16 cBitExtra;
    WMARESULT   wmaResult = WMA_OK;

    assert (dwNumBits <= 24); //only works for sure under this
    //make sure there is enougth data in dwDot for peek
    while (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen > 0) {
        pibstrm->m_dwDot <<= 8;
        pibstrm->m_dwDot |= *(pibstrm->m_pBuffer)++;
        --(pibstrm->m_cbBuflen);
        pibstrm->m_dwBitsLeft += 8;    
    }
    if (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen <= 0)
    {
        U32         iBufLen;
        TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData (pibstrm, &iBufLen));
    }

    //if enough take the data and go home; else take what ever is left
    if (pibstrm->m_dwBitsLeft < dwNumBits)
        dwNumBits = pibstrm->m_dwBitsLeft;
    cBitExtra = (I16) pibstrm->m_dwBitsLeft - (I16) dwNumBits;

    assert(NULL != piRetBits); // Avoid conditionals
    *piRetBits = (pibstrm->m_dwDot >> cBitExtra) << (32 - dwNumBits);

exit:
    return wmaResult;
}

WMARESULT ibstrmPeekBits (CWMAInputBitStream *pibstrm, register UInt dwNumBits,
                          U32 *piRetBits)
{
    I16 cBitExtra;
    WMARESULT   wmaResult = WMA_OK;

    assert (dwNumBits <= 24); //only works for sure under this
    //make sure there is enougth data in dwDot for peek
    while (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen > 0) {
        pibstrm->m_dwDot <<= 8;
        pibstrm->m_dwDot |= *(pibstrm->m_pBuffer)++;
        --(pibstrm->m_cbBuflen);
        pibstrm->m_dwBitsLeft += 8;    
    }
    if (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen <= 0)
    {
        U32         iBufLen;
        TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData (pibstrm, &iBufLen));
    }

    //if enough take the data and go home; else take what ever is left
    if (pibstrm->m_dwBitsLeft < dwNumBits)
    {
        wmaResult = WMA_E_ONHOLD;
        TraceResult(wmaResult);
        goto exit;
    }

    cBitExtra = (I16) pibstrm->m_dwBitsLeft - (I16) dwNumBits;
    assert(NULL != piRetBits); // Avoid conditionals
    *piRetBits = (pibstrm->m_dwDot >> cBitExtra) << (32 - dwNumBits);

exit:
    return wmaResult;
}

WMARESULT ibstrmLookForBits (CWMAInputBitStream *pibstrm, UInt dwNumBits)
{
    U32         iBufLen;
    WMARESULT   wmaResult = WMA_OK;

    assert (dwNumBits <= 32); //only case that works for certain
    if (dwNumBits > pibstrm->m_dwBitsLeft + pibstrm->m_cbBuflen * 8) 
    {
        //load up everything
        while (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen > 0) {
            pibstrm->m_dwDot <<= 8;
            pibstrm->m_dwDot |= *(pibstrm->m_pBuffer)++;
            --(pibstrm->m_cbBuflen);
            pibstrm->m_dwBitsLeft += 8;    
        }
        TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData (pibstrm, &iBufLen));
    }

    if (dwNumBits > pibstrm->m_dwBitsLeft + pibstrm->m_cbBuflen * 8 )
    {
        wmaResult = WMA_E_ONHOLD;
        TraceResult(wmaResult);
        goto exit;
    }

exit:
    return wmaResult;
}

WMARESULT ibstrmFlushBits (CWMAInputBitStream *pibstrm, register UInt dwNumBits) 
{
 
    WMARESULT wmaResult = WMA_OK;

#if defined(_DEBUG) || defined(BITRATE_REPORT)
    g_cBitGet += dwNumBits;
#endif  // _DEBUG || BITRATE_REPORT

    assert (dwNumBits <= 24); //only works for sure under this
    //make sure there is enougth data in dwDot for peek
    while (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen > 0) {
        pibstrm->m_dwDot <<= 8;
        pibstrm->m_dwDot |= *(pibstrm->m_pBuffer)++;
        --(pibstrm->m_cbBuflen);
        pibstrm->m_dwBitsLeft += 8;    
    }
    if (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen <= 0)
    {
        U32 iBufLen;

        TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData (pibstrm, &iBufLen));
    }

    //take the data and go home; or we have to pause
    if (dwNumBits <= pibstrm->m_dwBitsLeft)
        pibstrm->m_dwBitsLeft -= dwNumBits; 
    else 
        TRACEWMA_EXIT (wmaResult, WMA_E_ONHOLD);

exit:
    return wmaResult;
}

WMARESULT prvFinalLoad(CWMAInputBitStream* pibstrm,
                       UInt             dwRetval,
                       UInt             dwBitsToAdd,
                       U32             *piResult)
{
    WMARESULT   wmaResult = WMA_OK;
    U32         iBufLen;
    UInt        dwPosition = 4;

    pibstrm->m_dwDot = 0;
    pibstrm->m_dwBitsLeft = 0;

    for (; pibstrm->m_cbBuflen>0;) {
        pibstrm->m_dwDot <<= 8;
        pibstrm->m_dwDot |= *(pibstrm->m_pBuffer)++;
        --(pibstrm->m_cbBuflen);
        pibstrm->m_dwBitsLeft += 8;
    }

    TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData (pibstrm, &iBufLen));

    if (iBufLen != 0) 
    { 
        while (pibstrm->m_dwBitsLeft < dwBitsToAdd) 
        {
            pibstrm->m_dwDot <<= 8;
            pibstrm->m_dwDot |= *(pibstrm->m_pBuffer)++;
            --(pibstrm->m_cbBuflen);
            pibstrm->m_dwBitsLeft += 8;
            assert (pibstrm->m_dwBitsLeft <= 32);
        }
    }

exit:
    dwRetval <<= dwBitsToAdd;
    dwRetval |= (pibstrm->m_dwDot >> (pibstrm->m_dwBitsLeft - dwBitsToAdd)) & getMask[dwBitsToAdd];
    pibstrm->m_dwBitsLeft -= dwBitsToAdd;
    *piResult = dwRetval;

    return wmaResult; // bugbug: propagating the error screws up many things. FIX LATER
    //return WMA_OK;
}


WMARESULT ibstrmGetMoreData(CWMAInputBitStream *pibs, U32 *piBufLen)
{
    //a new packet
    I32 iFirstBit = 0;
    U8 temp;

    WMARESULT   wmaResult;
    Bool        fNewPacket;

    assert (pibs->m_cbBuflen == 0);
    TRACEWMA_EXIT(wmaResult, pibs->m_pfnGetMoreData(&pibs->m_pBuffer,
        (U32 *)&pibs->m_cbBuflen, pibs->m_dwUser));
    fNewPacket = (wmaResult == WMA_S_NEWPACKET);

    assert(NULL != piBufLen); // Cut down on expensive conditionals
    if(pibs->m_cbBuflen == 0)
    {
        WMA_set_fNoMoreData(pibs->m_dwOwner, 1);
        *piBufLen = 0;
        wmaResult = WMA_OK;
        goto exit;
    }
    WMA_set_fNoMoreData(pibs->m_dwOwner, 0);

#ifdef WMA2CMP
    {   // write out bits to a .cmp file
        extern FILE *pfWma2Cmp;       // file (and flag) to output .cmp file
        if (pfWma2Cmp != NULL)
        {
            size_t uWritten = fwrite(pibs->m_pBuffer,pibs->m_cbBuflen,1,pfWma2Cmp);
            // Asserts are a lousy way to report errors, but this is for internal test purposes only
            assert( uWritten == 1 );
        }
    }
#endif

    if (fNewPacket)
    {
        pibs->m_pBufferBegin = pibs->m_pBuffer;
        pibs->m_cbBuflenBegin = pibs->m_cbBuflen;
    }

    if (WMAB_FALSE == pibs->m_fAllowPackets)
    {
        // In non-superframe mode, provide a running packet count that wraps around (to avoid I32 vs. U32 issues)
        if (fNewPacket)
        {
            assert(((~(NONSUPER_WRAPAROUND - 1) << 1) & NONSUPER_WRAPAROUND) == 0); // assert Pwr of 2
            pibs->m_dwHeaderBuf = (pibs->m_dwHeaderBuf + 1) & (NONSUPER_WRAPAROUND - 1);
        }
    }
    else if (fNewPacket) //set up packet header in superframe mode
    {
        Int iPrevPacketNum, iNextPacketNum;
        unsigned char nHdrBits = WMA_get_nHdrBits(pibs->m_dwOwner); // this only updates per file
        const int cPacketNumBitsRS = (BITS_PER_DWORD - NBITS_PACKET_CNT);

        iFirstBit = nHdrBits % 8;
        assert (pibs->m_pBuffer != NULL); //always get a valid one
        pibs->m_dwHeaderBuf = 0;
        pibs->m_dwHeaderBuf = (pibs->m_pBuffer[0]<<24)|(pibs->m_pBuffer[1]<<16)|(pibs->m_pBuffer[2]<<8)|pibs->m_pBuffer[3];
        pibs->m_pBuffer += nHdrBits / 8;
        pibs->m_cbBuflen -= nHdrBits / 8;
        assert (nHdrBits < BITS_PER_DWORD);
        assert (pibs->m_dwBitsLeft <= 24);  //so that we have enough to save the fractional byte that would otherwise be lost

        // Now we should check that we didn't lose a packet
        iNextPacketNum = (pibs->m_dwHeaderBuf >> cPacketNumBitsRS);
        iPrevPacketNum = pibs->m_iPrevPacketNum;
        pibs->m_iPrevPacketNum = iNextPacketNum;
        if (WMAB_FALSE == pibs->m_fSuppressPacketLoss)
        {
            if (WMAB_FALSE == (iNextPacketNum - iPrevPacketNum == 1 || 
//                iNextPacketNum - iPrevPacketNum == 0 ||
                iNextPacketNum - iPrevPacketNum + (1 << NBITS_PACKET_CNT) == 1))
            {
                // PACKET LOSS: Return error. Next call to DecodeInfo will cue to next frame
                *piBufLen = 0;
				pibs->m_pBuffer = pibs->m_pBufferBegin + 4;
				pibs->m_cbBuflen = pibs->m_cbBuflenBegin - 4;

				pibs->m_dwDot = pibs->m_dwHeaderBuf;
				assert (nHdrBits <= 32);
				pibs->m_dwBitsLeft = 32 - nHdrBits;

                TRACEWMA_EXIT (wmaResult, WMA_E_LOSTPACKET);
            }
        }
        else
            // Avoid checking for packet loss, eg, after a seek
            pibs->m_fSuppressPacketLoss = WMAB_FALSE;
    }

    while (pibs->m_cbBuflen > 0 && pibs->m_dwBitsLeft <= 24)    {
        temp = (*pibs->m_pBuffer++);
        pibs->m_cbBuflen--;

        //zeros out the top (not valid) bits
        temp = temp<<iFirstBit;
        temp = temp>>iFirstBit;
        pibs->m_dwDot = (pibs->m_dwDot<<(8 - iFirstBit))|temp;

        pibs->m_dwBitsLeft += (8 - iFirstBit);
        iFirstBit = 0;
    }
    *piBufLen = pibs->m_cbBuflen;

exit:
    return wmaResult;
}

Void ibstrmResetPacket(CWMAInputBitStream *pibs)
{
    U8 nHdrBits = WMA_get_nHdrBits(pibs->m_dwOwner); // this only updates per file
    I32 iFirstBit;
    U8 temp;

    assert (pibs->m_pBuffer != 0);
    assert (WMA_get_fNoMoreData(pibs->m_dwOwner) == WMAB_FALSE);
    //skip the packet header
    iFirstBit = nHdrBits % 8;
    pibs->m_pBuffer = pibs->m_pBufferBegin;
    pibs->m_pBuffer += nHdrBits / 8;
    pibs->m_cbBuflen = pibs->m_cbBuflenBegin - nHdrBits / 8;

    temp = (*pibs->m_pBuffer++);
    pibs->m_cbBuflen--;

    //zeros out the top (not valid) bits
    temp = temp<<iFirstBit;
    temp = temp>>iFirstBit;
    pibs->m_dwDot = temp;
    pibs->m_dwBitsLeft = (8 - iFirstBit);
}

WMARESULT ibstrmGetBits (CWMAInputBitStream* pibstrm, register UInt dwNumBits,
                         U32 *piResult)
{
    WMARESULT   wmaResult = WMA_OK;
    register UInt dwRetval;
    register UInt dwShift;

#if defined(_DEBUG) || defined(BITRATE_REPORT)
    g_cBitGet += dwNumBits;
#endif  // _DEBUG || BITRATE_REPORT

    if (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen <= 0)
    {
        U32         iBufLen;
        TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData (pibstrm, &iBufLen));
    }

    //
    // This is a little unwieldly, but make sure the end-of-file test falls
    // through in the usual (not end-of-file) case to avoid CPU pipeline stalls
    // due to a branch (or mispredictions on more sophisticated processors).
    //
    if (((UInt) (pibstrm->m_cbBuflen << 3) >= dwNumBits || 
        pibstrm->m_dwBitsLeft + (pibstrm->m_cbBuflen << 3) >= dwNumBits)) {
        //
        // Do the most common case first.  If this doesn't play, we have one branch
        // to get to the next most common case (usually 1/32 of the time in the case
        // of the codec doing a huffman decode).  Note that we use a mask array to
        // avoid a special case branch when the bitcount is 32 (even though this is
        // relatively unlikely) since a left shift operation where the shift count
        // is equal to or greater than the number of bits in the destination is
        // undefined.
        //
        if (dwNumBits <= pibstrm->m_dwBitsLeft) {
            pibstrm->m_dwBitsLeft -= dwNumBits;
			*piResult = (pibstrm->m_dwDot >> pibstrm->m_dwBitsLeft) & getMask[dwNumBits];
            wmaResult = WMA_OK;
            goto exit;
        }
        //
        // The next most common case is when we have lots of data left in the buffer.
        // and we can fully load (i.e., all 32-bits) our accumulator.  This is
        // hard-wired to allow an optimizer to go crazy with all of the constants.
        // Note that the data is byte-swapped on the way in.
        //
        dwRetval = pibstrm->m_dwDot & getMask[pibstrm->m_dwBitsLeft];
        dwShift = dwNumBits - pibstrm->m_dwBitsLeft;

        if (pibstrm->m_cbBuflen >= 4) {
            register UInt     dwAcc;

            dwAcc = (UInt)pibstrm->m_pBuffer[3];
            dwAcc |= (UInt)(pibstrm->m_pBuffer[2]) << 8;
            dwAcc |= (UInt)(pibstrm->m_pBuffer[1]) << 16;
            dwAcc |= (UInt)(pibstrm->m_pBuffer[0]) << 24;
            pibstrm->m_dwDot = dwAcc;
            pibstrm->m_pBuffer += 4;
            pibstrm->m_cbBuflen -= 4;
            dwRetval <<= dwShift;
            dwRetval |= (dwAcc >> (32 - dwShift));// & getMask[dwShift];
            pibstrm->m_dwBitsLeft = 32 - dwShift;
            *piResult = dwRetval;
            wmaResult = WMA_OK;
            goto exit;
        }
        //
        // The final, and least likely case, is when we're at the end of the buffer.
        // Since there's really no point in having this inlined since it'll only
        // happen once, I'll call a function to make it happen and save the space
        // in the inline instances of getBits().
        //
		wmaResult = prvFinalLoad(pibstrm, dwRetval, dwShift, piResult);
        TraceError(wmaResult);
        goto exit;
    }
	else {
        *piResult = 0;
        TRACEWMA_EXIT (wmaResult, WMA_E_ONHOLD);
    }

exit:
    return wmaResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\tables_wmv.cpp ===
#include "bldsetup.h"

#include "xplatform.h"
#include "wmvdec_api.h"
#include "typedef.hpp"
#include "tables_wmv.h"

//Bool_WMV g_bSupportMMX;

I8_WMV gmvUVtableNew [128] = {
-31,-31,-31,-30,-29,-29,-29,-28,-27,-27,-27,-26,-25,-25,-25,-24,
-23,-23,-23,-22,-21,-21,-21,-20,-19,-19,-19,-18,-17,-17,-17,-16,
-15,-15,-15,-14,-13,-13,-13,-12,-11,-11,-11,-10, -9, -9, -9, -8,
 -7, -7, -7, -6, -5, -5, -5, -4, -3, -3, -3, -2, -1, -1, -1,  0,
  1,  1,  1,  2,  3,  3,  3,  4,  5,  5,  5,  6,  7,  7,  7,  8,
  9,  9,  9, 10, 11, 11, 11, 12, 13, 13, 13, 14, 15, 15, 15, 16,
 17, 17, 17, 18, 19, 19, 19, 20, 21, 21, 21, 22, 23, 23, 23, 24,
 25, 25, 25, 26, 27, 27, 27, 28, 29, 29, 29, 30, 31, 31, 31,0
};

I8_WMV* gmvUVtable4 = gmvUVtableNew + 63;

//New designed ZIGZAG matrix. 
//grgiZigzagInv is matrix for P,
//grgiZigzagInv_I and _Horizontal and _Vertical are matrixes for I,
// the following 3 are for decoder only

U8_WMV grgiHorizontalZigzagInvRotated_NEW [BLOCK_SQUARE_SIZE] = {
    0,  8,  1, 16, 24,  9,  2,  3,
   10, 17, 32, 40, 25, 18, 11,  4,
    5,  6, 12, 19, 26, 33, 48, 56,
   41, 34, 27, 20, 13,  7, 14, 15,
   21, 28, 35, 42, 49, 57, 50, 43,
   36, 29, 22, 23, 30, 37, 44, 51,
   58, 59, 52, 45, 38, 31, 39, 46,
   53, 60, 61, 54, 47, 55, 62, 63,
};
U8_WMV grgiVerticalZigzagInvRotated_NEW [BLOCK_SQUARE_SIZE] = {
     0,  1,  2,  8,  3,  4,  5,  9,
    16, 24, 17, 10, 11,  6,  7, 13,
    12, 19, 18, 25, 32, 40, 33, 26,
    27, 20, 14, 15, 22, 21, 28, 35,
    34, 41, 48, 56, 49, 42, 43, 36,
    29, 30, 23, 31, 38, 37, 44, 51,
    50, 57, 58, 59, 52, 45, 39, 46,
    53, 60, 61, 54, 47, 55, 62, 63,
};

U8_WMV grgiZigzagInvRotated_NEW_I [BLOCK_SQUARE_SIZE+1] = {
  0,  1,  8, 16,  9,  2,  3, 10,
 17, 24, 32, 25, 18, 11,  4,  5,
 12,  6, 19, 26, 33, 40, 48, 41,
 34, 27, 20, 13,  7, 14, 15, 21,
 28, 35, 42, 49, 56, 57, 50, 43,
 36, 29, 22, 23, 30, 31, 37, 44,
 51, 58, 59, 52, 45, 38, 39, 46,
 47, 53, 60, 61, 54, 55, 62, 63,0
};
U8_WMV grgiZigzagInvRotated_NEW [BLOCK_SQUARE_SIZE] = {
  0,  1,  8, 16,  9,  2,  3, 10,
 17, 24, 32, 25, 18, 11,  4,  5,
  6,  7, 13, 12, 19, 26, 33, 40,
 48, 41, 34, 27, 20, 14, 15, 23,
 22, 21, 28, 35, 42, 49, 56, 57,
 50, 43, 36, 29, 30, 31, 39, 38,
 37, 44, 51, 58, 59, 52, 45, 46,
 47, 55, 54, 53, 60, 61, 62, 63,
};
U8_WMV grgiZigzagInv_NEW [BLOCK_SQUARE_SIZE+1] = {
    0,    8,    1,    2,    9,   16,   24,   17,
   10,    3,    4,   11,   18,   25,   32,   40,
   48,   56,   41,   33,   26,   19,   12,    5,
    6,   13,   20,   27,   34,   49,   57,   58,
   50,   42,   35,   28,   21,   14,    7,   15,
   22,   29,   36,   43,   51,   59,   60,   52,
   44,   37,   30,   23,   31,   38,   45,   53,
   61,   62,   54,   46,   39,   47,   55,   63,0
};

U8_WMV grgiZigzagInv_NEW_I [BLOCK_SQUARE_SIZE+1] = {
    0,    8,    1,    2,    9,   16,   24,   17,
   10,    3,    4,   11,   18,   25,   32,   40,
   33,   48,   26,   19,   12,    5,    6,   13,
   20,   27,   34,   41,   56,   49,   57,   42,
   35,   28,   21,   14,    7,   15,   22,   29,
   36,   43,   50,   58,   51,   59,   44,   37,
   30,   23,   31,   38,   45,   52,   60,   53,
   61,   46,   39,   47,   54,   62,   55,   63, 0
};

U8_WMV grgiHorizontalZigzagInv_NEW [BLOCK_SQUARE_SIZE] = {
    0,    1,    8,    2,    3,    9,   16,   24,
   17,   10,    4,    5,   11,   18,   25,   32,
   40,   48,   33,   26,   19,   12,    6,    7,
   13,   20,   27,   34,   41,   56,   49,   57,
   42,   35,   28,   21,   14,   15,   22,   29,
   36,   43,   50,   58,   51,   44,   37,   30,
   23,   31,   38,   45,   52,   59,   60,   53,
   46,   39,   47,   54,   61,   62,   55,   63,
};
U8_WMV grgiVerticalZigzagInv_NEW [BLOCK_SQUARE_SIZE] = {
    0,    8,   16,    1,   24,   32,   40,    9,
    2,    3,   10,   17,   25,   48,   56,   41,
   33,   26,   18,   11,    4,    5,   12,   19,
   27,   34,   49,   57,   50,   42,   35,   28,
   20,   13,    6,    7,   14,   21,   29,   36,
   43,   51,   58,   59,   52,   44,   37,   30,
   22,   15,   23,   31,   38,   45,   60,   53,
   46,   39,   47,   54,   61,   62,   55,   63,
};
U8_WMV grgi8x4ZigzagInv[33] = { 
    0,    1,    2,    8,    3,    9,   10,   16, 
    4,   11,   17,   24,   18,   12,    5,   19,
   25,   13,   20,   26,   27,    6,   21,   28, 
   14,   22,   29,    7,   30,   15,   23,   31, 0
};
U8_WMV grgi4x8ZigzagInv[33] = {   
    0,    4,    1,    8,    5,   12,    9,    2, 
   16,    6,   13,   20,   10,   24,   17,   14, 
   28,   21,   18,    3,   25,   29,    7,   22, 
   11,   26,   15,   30,   19,   23,   27,   31, 0
};
U8_WMV grgi8x4ZigzagInvRotated[33] = { 
    0,    4,    8,    1,   12,    5,    9,    2, 
   16,   13,    6,    3,   10,   17,   20,   14,
    7,   21,   18,   11,   15,   24,   22,   19, 
   25,   26,   23,   28,   27,   29,   30,   31, 0
};
U8_WMV grgi4x8ZigzagInvRotated[33] = {   
    0,    1,    8,    2,    9,    3,   10,   16, 
    4,   17,   11,    5,   18,    6,   12,   19, 
    7,   13,   20,   24,   14,   15,   25,   21, 
   26,   22,   27,   23,   28,   29,   30,   31, 0
};

//MPEG4 Zigzag matrix
U8_WMV grgiZigzagInvRotated [BLOCK_SQUARE_SIZE] = {
	0,	8,  1,	2,	9,	16,	24,	17,	
	10,	3,	4,	11,	18,	25,	32,	40,	
	33,	26,	19,	12,	5,	6,  13, 20,
    27, 34, 41, 48, 56, 49, 42, 35,
    28, 21, 14, 7,	15, 22,	29,	36,
    43,	50,	57,	58,	51,	44,	37,	30,
    23,	31,	38,	45,	52,	59,	60,	53,
    46,	39,	47,	54,	61,	62,	55,	63,
};


U8_WMV grgiZigzagInv [BLOCK_SQUARE_SIZE+1] = {
	0,	1,	8,	16,	9,	2,	3,	10,	
	17,	24,	32,	25,	18,	11,	4,	5,	
	12,	19,	26,	33,	40,	48,	41,	34,	
	27,	20,	13,	6,	7,	14,	21,	28,	
	35,	42,	49,	56,	57,	50,	43,	36,	
	29,	22,	15,	23,	30,	37,	44,	51,	
	58,	59,	52,	45,	38,	31,	39,	46,	
	53,	60,	61,	54,	47,	55,	62,	63, 0,
};

U8_WMV grgiHorizontalZigzagInv [BLOCK_SQUARE_SIZE] = {
	0, 1, 2, 3, 8, 9, 16, 17, 
	10, 11, 4, 5, 6, 7, 15, 14, 
	13, 12, 19, 18, 24, 25, 32, 33, 
	26, 27, 20, 21, 22, 23, 28, 29, 
	30, 31, 34, 35, 40, 41, 48, 49, 
	42, 43, 36, 37, 38, 39, 44, 45, 
	46, 47, 50, 51, 56, 57, 58, 59, 
	52, 53, 54, 55, 60, 61, 62, 63
};
U8_WMV grgiVerticalZigzagInv [BLOCK_SQUARE_SIZE] = {
	0, 8, 16, 24, 1, 9, 2, 10, 
	17, 25, 32, 40, 48, 56, 57, 49, 
	41, 33, 26, 18, 3, 11, 4, 12, 
	19, 27, 34, 42, 50, 58, 35, 43, 
	51, 59, 20, 28, 5, 13, 6, 14, 
	21, 29, 36, 44, 52, 60, 37, 45, 
	53, 61, 22, 30, 7, 15, 23, 31, 
	38, 46, 54, 62, 39, 47, 55, 63
};


// sys_c

/// Tables for HighMotion
//#define numSampleNotLastIntraY 31
//#define numSampleLastIntraY 38
U8_WMV sm_rgIfNotLastNumOfLevelAtRunIntraY_HghMt [31] = { 
   19,   15,   12,   11,    6,    5,    4,    4,    4,    4,    3,
    3,    3,    3,    3,    3,    2,    2,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,
};
U8_WMV sm_rgIfLastNumOfLevelAtRunIntraY_HghMt [38] = { 
    6,    5,    4,    4,    3,    2,    2,    2,    2,    2,    2,
    2,    2,    2,    2,    2,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,
   };
U8_WMV sm_rgIfNotLastNumOfRunAtLevelIntraY_HghMt [20] = {
  -1,  30,  17,  15,   9,   5,   4,   3,   3,   3,   3,
   3,   2,   1,   1,   1,   0,   0,   0,   0,
};
U8_WMV sm_rgIfLastNumOfRunAtLevelIntraY_HghMt [7] = {
  -1,  37,  15,   4,   3,   1,   0,
};

//#define numSampleNotLast 27
//#define numSampleLast 37
U8_WMV sm_rgIfNotLastNumOfLevelAtRun_HghMt [27] = {
  23,   11,    8,    7,    5,    5,    4,    4,    3,    3,    3,
    3,    2,    2,    2,    2,    2,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,
};
U8_WMV sm_rgIfLastNumOfLevelAtRun_HghMt [37] = { 
    9,    5,    4,    4,    3,    3,    3,    2,    2,    2,    2,
    2,    2,    2,    2,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,
};
U8_WMV sm_rgIfNotLastNumOfRunAtLevel_HghMt [24] = {
  -1,  26,  16,  11,   7,   5,   3,   3,   2,   1,   1,
   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,
};
U8_WMV sm_rgIfLastNumOfRunAtLevel_HghMt [10] = {
  -1,  36,  14,   6,   3,   1,   0,   0,   0,   0,
};



/// Tables for __TALKING_DCTAC
//#define numSampleNotLastIntraY 21
//#define numSampleLastIntraY 27
U8_WMV sm_rgIfNotLastNumOfLevelAtRunIntraY_Talking [21] = { 
   16,   11,    8,    7,    5,    4,    4,    3,    3,    3,    3,
    3,    3,    3,    2,    2,    1,    1,    1,    1,    1,
};
U8_WMV sm_rgIfLastNumOfLevelAtRunIntraY_Talking [27] = { 
    4,    4,    3,    3,    2,    2,    2,    2,    2,    2,    2,
    2,    2,    2,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,
};
U8_WMV sm_rgIfNotLastNumOfRunAtLevelIntraY_Talking [17] = {
	-1, 20, 15, 13, 6, 4, 3, 3, 2, 1, 1,
	 1,  0, 0, 0, 0, 0,
};

U8_WMV sm_rgIfLastNumOfRunAtLevelIntraY_Talking [5] = {
	 -1, 26, 13, 3, 1,
};

//int numSampleNotLast = 30;
//int numSampleLast = 44;
U8_WMV sm_rgIfNotLastNumOfLevelAtRun_Talking [30] = {
  14,    9,    5,    4,    4,    4,    3,    3,    3,    3,    3,
   3,    3,    2,    2,    2,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,
};

U8_WMV sm_rgIfLastNumOfLevelAtRun_Talking [44] = {
   5,    4,    3,    3,    2,    2,    2,    2,    2,    2,    2,
   2,    2,    2,    2,    2,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
};
U8_WMV sm_rgIfNotLastNumOfRunAtLevel_Talking [15] = {
	-1, 29, 15, 12, 5, 2, 1, 1, 1, 1, 0,
	 0,  0,  0, 0, 
};

U8_WMV sm_rgIfLastNumOfRunAtLevel_Talking [6] = {
	 -1, 43, 15, 3, 1, 0,
};


/// Tables for __MPEG4
//#define numSampleNotLastIntraY 15
//#define numSampleLastIntraY 21

U8_WMV sm_rgIfNotLastNumOfLevelAtRunIntraY_MPEG4 [15] = {
	27, 10, 5, 4, 3, 3, 3, 3, 2, 2, 1,
	 1, 1, 1, 1
};

U8_WMV sm_rgIfLastNumOfLevelAtRunIntraY_MPEG4 [21] = {
	 8, 3, 2, 2, 2, 2, 2, 1, 1, 1, 1,
	 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
};

U8_WMV sm_rgIfNotLastNumOfRunAtLevelIntraY_MPEG4 [28] = {
	-1, 14, 9, 7, 3, 2, 1, 1, 1, 1,
	 1,  0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0,  0, 0, 0, 0, 0, 0, 0
};

U8_WMV sm_rgIfLastNumOfRunAtLevelIntraY_MPEG4 [9] = {
	 -1, 20, 6, 1, 0, 0, 0, 0, 0
};

//int numSampleNotLast = 27;
//int numSampleLast = 41;
U8_WMV sm_rgIfNotLastNumOfLevelAtRun_MPEG4 [27] = {
	12, 6, 4, 3, 3, 3, 3, 2, 2, 2, 2,
	 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	 1, 1, 1, 1, 1
};

U8_WMV sm_rgIfLastNumOfLevelAtRun_MPEG4 [41] = {
	 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	 1, 1, 1, 1, 1, 1, 1, 1
};
// 0th element is NA. Level = 1..12
U8_WMV sm_rgIfNotLastNumOfRunAtLevel_MPEG4 [13] = {
	-1, 26, 10, 6, 2, 1, 1,
	 0,  0,  0, 0, 0, 0  
};
// 0th element is NA. Level = 1..3
U8_WMV sm_rgIfLastNumOfRunAtLevel_MPEG4 [4] = { 
	 -1, 40, 1, 0
};

const U8_WMV g_rgiClapTabDecWMV [1024] = {
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 
160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 
192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 
224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,
255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\vopdec_mp4x.cpp ===
#include "bldsetup.h"

#include "xplatform.h"
#include "typedef.hpp"
#include "wmvdec_member.h"
#include "wmvdec_function.h"
#include "strmdec_wmv.hpp"
#include "codehead.h"
#include "dectable_mp4x.hpp"

#ifdef DO_BOE
#define BOE DebugBreak()
#else
#define BOE	
#endif


#ifdef _WMVONLY_
    // Dummy MP4X's routines.
    tWMVDecodeStatus DecodeIMBAcPred_MP4X(tWMVDecInternalMember *pWMVDec, CWMVMBMode* pmbmd, U8_WMV* ppxliTextureQMBY, U8_WMV* ppxliTextureQMBU, U8_WMV* ppxliTextureQMBV, 
        I16_WMV* piQuanCoefACPred, I16_WMV** piQuanCoefACPredTable, Bool_WMV bLeftMB, Bool_WMV bTopMB, Bool_WMV bLeftTopMB){return WMV_Succeeded;};
    Void_WMV decodeIntraDCAcPred (tWMVDecInternalMember *pWMVDec, tWMVDecodeStatus* pError, U8_WMV DecodeCodeTableIntraDC[], I32_WMV iMaxCodeWordLngIntraDC){};
    tWMVDecodeStatus decodeMBOverheadOfIVOP_New (tWMVDecInternalMember *pWMVDec, CWMVMBMode* pmbmd, I32_WMV imbX, I32_WMV imbY){return WMV_Succeeded;};
    tWMVDecodeStatus decodeMBOverheadOfPVOP_New (tWMVDecInternalMember *pWMVDec, CWMVMBMode* pmbmd){return WMV_Succeeded;};
    tWMVDecodeStatus decodeMV (tWMVDecInternalMember *pWMVDec, CVector* pmv, const CWMVMBMode* pmbmd, Bool_WMV bLeftBndry, Bool_WMV bRightBndry, Bool_WMV bTopBndry){return WMV_Succeeded;};
    I32_WMV checkResyncMarker(tWMVDecInternalMember *pWMVDec){return FALSE_WMV;};
    tWMVDecodeStatus decodeMBOverheadOfIVOP_MPEG4 (tWMVDecInternalMember *pWMVDec, CWMVMBMode* pmbmd, I32_WMV imbX, I32_WMV imbY){return WMV_Succeeded;};
    tWMVDecodeStatus decodeMBOverheadOfPVOP_MPEG4 (tWMVDecInternalMember *pWMVDec, CWMVMBMode* pmbmd){return WMV_Succeeded;};
    Void_WMV decodeIntraDCAcPred_MPEG4 (tWMVDecInternalMember *pWMVDec, tWMVDecodeStatus* pError, U8_WMV DecodeCodeTableIntraDC[], I32_WMV iMaxCodeWordLngIntraDC){};
    tWMVDecodeStatus DecodeInverseInterBlockQuantizeEscCode_MPEG4(tWMVDecInternalMember *pWMVDec, CDCTTableInfo_Dec* InterDCTTableInfo_Dec, U8_WMV *pZigzagInv, I32_WMV iXformMode){return WMV_Succeeded;};
    tWMVDecodeStatus DecodeInverseInterBlockQuantizeEscCode_MMX_MPEG4(tWMVDecInternalMember *pWMVDec, CDCTTableInfo_Dec* InterDCTTableInfo_Dec, U8_WMV *pZigzagInv, I32_WMV iXformMode){return WMV_Succeeded;};
    tWMVDecodeStatus DecodeInverseIntraBlockQuantizeAcPred_MPEG4 (tWMVDecInternalMember *pWMVDec, CDCTTableInfo_Dec* IntraDCTTableInfo_Dec, Bool_WMV CBP, I16_WMV* pDct, U8_WMV* piZigzagInv){return WMV_Succeeded;};
    tWMVDecodeStatus decodeVOLHeadMP4S(tWMVDecInternalMember *pWMVDec){return WMV_Succeeded;};

    I32_WMV	decodeVideoPacketHeader(tWMVDecInternalMember *pWMVDec, I32_WMV& iCurrentQP){return	TRUE_WMV;};
#else
// -------- MP4S - MP43
#define MAXCODEWORDLNGMV 13
#define MAXCODEWORDLNGMCBPCintra 9
#define MAXCODEWORDLNGMCBPCintra_New 3
#define MAXCODEWORDLNGMCBPY 6
#define MAXCODEWORDLNGMCBPCinter 9
#define MAXCODEWORDLNGMCBPCinter_New 7
#define MAXCODEWORDLNGMCBPY 6


#define MAXCODEWORDLNGIntraDCy 7
#define MAXCODEWORDLNGIntraDCc 8
#define MAXCODEWORDLNGIntraDCMPEG4y 11
#define MAXCODEWORDLNGIntraDCMPEG4c 12
#define INTRADCYTCOEF_ESCAPE_MSV 119							// see table.13/H.263
#define INTRADCUVTCOEF_ESCAPE_MSV 119							// see table.13/H.263

#define sign(x) ((x) > 0 ? 1 : -1)

I32_WMV divroundnearest(I32_WMV i, I32_WMV iDenom)
{
    assert(iDenom>0);
    if(i>=0)
        return (i+(iDenom>>1))/iDenom;
    else
        return (i-(iDenom>>1))/iDenom;
}


tWMVDecodeStatus DecodeIMBAcPred_MP4X (
    tWMVDecInternalMember *pWMVDec, 
    CWMVMBMode*            pmbmd, 
    U8_WMV*      ppxliTextureQMBY,
    U8_WMV*      ppxliTextureQMBU, 
    U8_WMV*      ppxliTextureQMBV, 
    I16_WMV*                piQuanCoefACPred, 
    I16_WMV**                piQuanCoefACPredTable, 
    Bool_WMV                bLeftMB, 
    Bool_WMV                bTopMB, 
    Bool_WMV                bLeftTopMB)
{
    CDCTTableInfo_Dec* pInterDCTTableInfo_Dec;
    CDCTTableInfo_Dec* pIntraDCTTableInfo_Dec;
    tWMVDecodeStatus tWMVStatus;
    U8_WMV * ppxliCodedBlkY = ppxliTextureQMBY;
    Bool_WMV bPredPattern;
    I16_WMV* pRef; 
    Bool_WMV bMBPattern[4] = {bLeftTopMB, bTopMB, bLeftMB, bLeftTopMB};
    U32_WMV ib;

    if (pWMVDec->m_bDCTTable_MB){
        pInterDCTTableInfo_Dec = pWMVDec->m_pInterDCTTableInfo_Dec_Set[pmbmd-> m_iDCTTable_MB_Index];
	    pIntraDCTTableInfo_Dec = pWMVDec->m_pIntraDCTTableInfo_Dec_Set[pmbmd-> m_iDCTTable_MB_Index];
    }
    else{
        pInterDCTTableInfo_Dec = pWMVDec->m_pInterDCTTableInfo_Dec;
        pIntraDCTTableInfo_Dec = pWMVDec->m_pIntraDCTTableInfo_Dec;
    }

    // Y-blocks first (4 blocks)
    for (ib = 0; ib < 4; ib++) {
        if (pWMVDec->m_cvCodecVersion >= MP43){
            decodeIntraDCAcPredMSV (pWMVDec, &tWMVStatus, pWMVDec->m_pHufDCTDCyDec, INTRADCYTCOEF_ESCAPE_MSV);
        }
        else{
            if(pWMVDec->m_cvCodecVersion == MP42) 
                decodeIntraDCAcPred (pWMVDec, &tWMVStatus, gDecodeCodeTableIntraDCy, MAXCODEWORDLNGIntraDCy);
            else
                decodeIntraDCAcPred_MPEG4 (pWMVDec, &tWMVStatus, gDecodeCodeTableIntraDCMPEG4y, MAXCODEWORDLNGIntraDCMPEG4y);
        }
        if (WMV_Succeeded != tWMVStatus) {
            return tWMVStatus;
        }

        pRef = decodeDiffDCTCoef(pWMVDec, piQuanCoefACPredTable, bLeftMB, bTopMB, bMBPattern[ib], bPredPattern);
        if (pWMVDec->m_cvCodecVersion != MP4S) {
            piQuanCoefACPred [0] = pWMVDec->m_rgiCoefRecon[0] + pRef [0];
            pWMVDec->m_rgiCoefRecon[0] = (piQuanCoefACPred [0] * pWMVDec->m_iDCStepSize);
        }
        else {
            piQuanCoefACPred [0] = pWMVDec->m_rgiCoefRecon[0] + divroundnearest(pRef[0], pWMVDec->m_iDCStepSize);
            pWMVDec->m_rgiCoefRecon[0] = piQuanCoefACPred [0] = piQuanCoefACPred[0] * pWMVDec->m_iDCStepSize;
        }
        tWMVStatus = decodeIntraBlockAcPred (
            pWMVDec, 
			pIntraDCTTableInfo_Dec,
            pmbmd, 
            ppxliCodedBlkY, 
            pWMVDec->m_iWidthPrevY,
            ib,
            piQuanCoefACPred,
            pRef,
            bPredPattern
            );
        if (WMV_Succeeded != tWMVStatus) {
            return tWMVStatus;
        }
        ppxliCodedBlkY += (ib != 1) ? BLOCK_SIZE : pWMVDec->m_iWidthPrevYxBlkMinusBlk;
        piQuanCoefACPred += BLOCK_SIZE_TIMES2;
        piQuanCoefACPredTable += 6;
    }

    // U-blocks
    if (pWMVDec->m_cvCodecVersion >= MP43){
        decodeIntraDCAcPredMSV (pWMVDec, &tWMVStatus, pWMVDec->m_pHufDCTDCcDec, INTRADCUVTCOEF_ESCAPE_MSV);
    }
    else{
        if (pWMVDec->m_cvCodecVersion == MP42) 
            decodeIntraDCAcPred (pWMVDec, &tWMVStatus, gDecodeCodeTableIntraDCc, MAXCODEWORDLNGIntraDCc);
        else
            decodeIntraDCAcPred_MPEG4 (pWMVDec, &tWMVStatus, gDecodeCodeTableIntraDCMPEG4c, MAXCODEWORDLNGIntraDCMPEG4c);
    }
    if (WMV_Succeeded != tWMVStatus) {
        return tWMVStatus;
    }

    pRef = decodeDiffDCTCoef(pWMVDec, piQuanCoefACPredTable, bLeftMB, bTopMB, bLeftTopMB,bPredPattern);
    if(pWMVDec->m_cvCodecVersion != MP4S) {
        piQuanCoefACPred [0] = pWMVDec->m_rgiCoefRecon[0] + pRef [0];
        pWMVDec->m_rgiCoefRecon[0] = (piQuanCoefACPred [0] * pWMVDec->m_iDCStepSizeC);
    }
    else {
        piQuanCoefACPred [0] = pWMVDec->m_rgiCoefRecon[0] + divroundnearest(pRef[0], pWMVDec->m_iDCStepSizeC);
        pWMVDec->m_rgiCoefRecon[0] = piQuanCoefACPred [0] = piQuanCoefACPred[0] * pWMVDec->m_iDCStepSizeC;
    }

    if (pWMVDec->m_cvCodecVersion != MP4S)
        tWMVStatus = decodeIntraBlockAcPred (
            pWMVDec, 
		    pInterDCTTableInfo_Dec,
            pmbmd,
            ppxliTextureQMBU,
            pWMVDec->m_iWidthPrevUV,
            4,
            piQuanCoefACPred,
            pRef,
            bPredPattern
            );
    else
        tWMVStatus = decodeIntraBlockAcPred (
            pWMVDec, 
		    pIntraDCTTableInfo_Dec,
            pmbmd,
            ppxliTextureQMBU,
            pWMVDec->m_iWidthPrevUV,
            4,
            piQuanCoefACPred,
            pRef,
            bPredPattern
            );
    if (WMV_Succeeded != tWMVStatus) {
        return tWMVStatus;
    }
    piQuanCoefACPred += BLOCK_SIZE_TIMES2;
    piQuanCoefACPredTable += 6;

    // V-blocks
    if (pWMVDec->m_cvCodecVersion >= MP43){
        decodeIntraDCAcPredMSV (pWMVDec, &tWMVStatus, pWMVDec->m_pHufDCTDCcDec, INTRADCUVTCOEF_ESCAPE_MSV);
    }
    else{
        if(pWMVDec->m_cvCodecVersion == MP42)
            decodeIntraDCAcPred (pWMVDec, &tWMVStatus, gDecodeCodeTableIntraDCc, MAXCODEWORDLNGIntraDCc);
        else 
            decodeIntraDCAcPred_MPEG4 (pWMVDec, &tWMVStatus, gDecodeCodeTableIntraDCMPEG4c, MAXCODEWORDLNGIntraDCMPEG4c);
    }
    if (WMV_Succeeded != tWMVStatus) {
        return tWMVStatus;
    }

    pRef = decodeDiffDCTCoef(pWMVDec, piQuanCoefACPredTable, bLeftMB, bTopMB, bLeftTopMB,bPredPattern);
    if(pWMVDec->m_cvCodecVersion != MP4S) {
        piQuanCoefACPred [0] = pWMVDec->m_rgiCoefRecon[0] + pRef [0];
        pWMVDec->m_rgiCoefRecon[0] = (pWMVDec, piQuanCoefACPred [0] * pWMVDec->m_iDCStepSizeC);
    }
    else {
        piQuanCoefACPred [0] = pWMVDec->m_rgiCoefRecon[0] + divroundnearest(pRef[0], pWMVDec->m_iDCStepSizeC);
        pWMVDec->m_rgiCoefRecon[0] =  piQuanCoefACPred [0] = piQuanCoefACPred[0] * pWMVDec->m_iDCStepSizeC;
    }

    if (pWMVDec->m_cvCodecVersion != MP4S)
        tWMVStatus = decodeIntraBlockAcPred (
            pWMVDec, 
		    pInterDCTTableInfo_Dec,
            pmbmd,
            ppxliTextureQMBV,
            pWMVDec->m_iWidthPrevUV,
            5,
            piQuanCoefACPred,
            pRef,
            bPredPattern
            );
    else
        tWMVStatus = decodeIntraBlockAcPred (
            pWMVDec, 
		    pIntraDCTTableInfo_Dec,
            pmbmd,
            ppxliTextureQMBV,
            pWMVDec->m_iWidthPrevUV,
            5,
            piQuanCoefACPred,
            pRef,
            bPredPattern
            );

    if (WMV_Succeeded != tWMVStatus) {
        return tWMVStatus;
    }

    return WMV_Succeeded;
}

/// MV
tWMVDecodeStatus decodeMV (tWMVDecInternalMember *pWMVDec, CVector* pmv, const CWMVMBMode* pmbmd, Bool_WMV bLeftBndry, Bool_WMV bRightBndry, Bool_WMV bTopBndry)
{
    pWMVDec->m_iMixedPelMV = pWMVDec->m_iMvResolution = 0;
    CVector vctPred;
	find16x16MVpred (pWMVDec, vctPred, pmv, pmbmd, bLeftBndry, bRightBndry, bTopBndry);

    if (pWMVDec->m_cvCodecVersion != MP4S) {
        I32_WMV iVLC;
        I32_WMV lSymbol = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGMV,gDecodeCodeTableMV);
	    if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
	    	return WMV_CorruptedBits;
    	}
	    iVLC = lSymbol - 32 + vctPred.x;
    	if (iVLC > pWMVDec->m_iMVRightBound)
	    	pmv->x = iVLC - 64;
    	else if (iVLC < pWMVDec->m_iMVLeftBound)
	    	pmv->x = iVLC + 64;
    	else
		    pmv->x = (I8_WMV) iVLC;

	    lSymbol = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGMV,gDecodeCodeTableMV);
    	if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
	    	return WMV_CorruptedBits;
    	}
	    iVLC = lSymbol - 32 + vctPred.y;
    	if (iVLC > pWMVDec->m_iMVRightBound)
	    	pmv->y = iVLC - 64;
    	else if (iVLC < pWMVDec->m_iMVLeftBound)
		    pmv->y = iVLC + 64;
	    else
		    pmv->y = (I8_WMV) iVLC;
        return WMV_Succeeded;
    }
    else {
        CVector vctDiff, vctDecode;
        getDiffMV(pWMVDec, vctDiff);
        vctDecode.x = vctDiff.x + vctPred.x;
        vctDecode.y = vctDiff.y + vctPred.y;
        fitMvInRange (vctDecode, pWMVDec->iRange);
        pmv->x = vctDecode.x;
        pmv->y = vctDecode.y;
        return WMV_Succeeded;
    }
}

Void_WMV decodeIntraDCAcPred (tWMVDecInternalMember *pWMVDec, tWMVDecodeStatus* pError, U8_WMV DecodeCodeTableIntraDC[], I32_WMV iMaxCodeWordLngIntraDC)//CHuffmanDecoder* pentrdecIntraDC)
{
    I8_WMV lSzDiffIntraDC;
	lSzDiffIntraDC = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, iMaxCodeWordLngIntraDC, DecodeCodeTableIntraDC);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);
    if (BS_invalid ( pWMVDec->m_pbitstrmIn))
        goto Error;
    if (lSzDiffIntraDC)	{
        U8_WMV chDiffIntraDC = (U8_WMV) BS_getBits  ( pWMVDec->m_pbitstrmIn, lSzDiffIntraDC);
        if (BS_invalid ( pWMVDec->m_pbitstrmIn))
            goto Error;
	    *pError = WMV_Succeeded;
        if ((1 << (lSzDiffIntraDC - 1)) & chDiffIntraDC)
            pWMVDec->m_rgiCoefRecon [0] = chDiffIntraDC;
		else
            pWMVDec->m_rgiCoefRecon [0] = (chDiffIntraDC - (1 << lSzDiffIntraDC) + 1);
    }
	else{
		*pError = WMV_Succeeded;
		pWMVDec->m_rgiCoefRecon [0] = 0;
	}
	return;

Error:
    *pError = WMV_CorruptedBits;
	pWMVDec->m_rgiCoefRecon [0] = 0;
}

tWMVDecodeStatus decodeMBOverheadOfIVOP_New (tWMVDecInternalMember *pWMVDec, CWMVMBMode* pmbmd, I32_WMV imbX, I32_WMV imbY)
{
	I32_WMV iCBPY = 0;
	I32_WMV iCBPC = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGMCBPCintra_New, gDecodeCodeTableMCBPCintra_New);

	if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
		return WMV_CorruptedBits;
	}

	if (iCBPC < 0 || iCBPC > 3) {
		return WMV_CorruptedBits;
	}

	pmbmd-> m_rgbDCTCoefPredPattern = (U8_WMV) BS_getBit (pWMVDec->m_pbitstrmIn);
	if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
		return WMV_CorruptedBits;
	}

	pmbmd-> m_bSkip = FALSE_WMV;
	pmbmd-> m_dctMd = INTRA;
	iCBPY = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGMCBPY, gDecodeCodeTableCBPY);
	if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
		return WMV_CorruptedBits;
    }

    pmbmd->m_rgbCodedBlockPattern = (iCBPY << 2) | iCBPC;

	return WMV_Succeeded;
}
tWMVDecodeStatus decodeMBOverheadOfPVOP_New (tWMVDecInternalMember *pWMVDec, CWMVMBMode* pmbmd)
{
    I32_WMV iMCBPC = 0;
    I32_WMV iCBPC = 0;
    I32_WMV iCBPY = 0;
    I32_WMV iMBtype;

	if (pWMVDec->m_bCODFlagOn) {
		pmbmd-> m_bSkip = BS_getBit (pWMVDec->m_pbitstrmIn);
		if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
			return WMV_CorruptedBits;
		}

		if (pmbmd-> m_bSkip) {
            pmbmd-> m_rgbCodedBlockPattern = 0;
			pmbmd-> m_dctMd = INTER;
			return WMV_Succeeded;
		}
	}
	else
		pmbmd-> m_bSkip = FALSE_WMV; // might be reset later
	iMCBPC = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGMCBPCinter_New, gDecodeCodeTableMCBPCinter_New);
	if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
		return WMV_CorruptedBits;
	}

	if (iMCBPC < 0 || iMCBPC > 7) {
		return WMV_CorruptedBits;
	}

	iMBtype = iMCBPC >> 2;
	iCBPC = iMCBPC % 4;
	switch (iMBtype) {			
	case 0:
		pmbmd-> m_dctMd = INTER;
		if (iCBPC == 3)
			iCBPY = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGMCBPY,gDecodeCodeTableCBPY);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);
		else
			iCBPY = 15 - BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGMCBPY,gDecodeCodeTableCBPY);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);
		pmbmd-> m_bCBPAllZero = (iCBPC == 0 && iCBPY == 0);
		break;
	case 1:
        pmbmd-> m_dctMd = INTRA;
		pmbmd-> m_rgbDCTCoefPredPattern = (U8_WMV) BS_getBit (pWMVDec->m_pbitstrmIn);
		if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
			return WMV_CorruptedBits;
		}
		iCBPY = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGMCBPY, gDecodeCodeTableCBPY);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);
        break;
    default:
        return WMV_CorruptedBits;
    }

	if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
		return WMV_CorruptedBits;
	}

	if (iCBPY < 0 || iCBPY > 15) {
		return WMV_CorruptedBits;
    }

    pmbmd->m_rgbCodedBlockPattern = (iCBPY << 2) | iCBPC;
    //  Make it work with WMV2 codes
    pmbmd-> m_iMVPredDirection = 2;
    
    return WMV_Succeeded;
}


//// MPEG4_ISO


tWMVDecodeStatus decodeMBOverheadOfIVOP_MPEG4 (tWMVDecInternalMember *pWMVDec, CWMVMBMode* pmbmd, I32_WMV imbX, I32_WMV imbY)
{
	I32_WMV iCBPY = 0;
	I32_WMV iCBPC = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGMCBPCintra,gDecodeCodeTableMCBPCintra);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);


	if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
		return WMV_CorruptedBits;
	}

	if (iCBPC < 0 || iCBPC > 20) {
		return WMV_CorruptedBits;
	}


	pmbmd-> m_rgbDCTCoefPredPattern = (U8_WMV) BS_getBit (pWMVDec->m_pbitstrmIn);
	if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
		return WMV_CorruptedBits;
	}

	pmbmd-> m_bSkip = FALSE_WMV;
	pmbmd-> m_dctMd = INTRA;
	iCBPY = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGMCBPY, gDecodeCodeTableCBPY);
	if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
		return WMV_CorruptedBits;
    }

    pmbmd->m_rgbCodedBlockPattern = (iCBPY << 2) | iCBPC;

	return WMV_Succeeded;
}

tWMVDecodeStatus decodeMBOverheadOfPVOP_MPEG4 (tWMVDecInternalMember *pWMVDec, CWMVMBMode* pmbmd)
{
    I32_WMV iMCBPC = 0;
    I32_WMV iCBPC = 0;
    I32_WMV iCBPY = 0;
    I32_WMV iMBtype;

	pmbmd-> m_bSkip = BS_getBit (pWMVDec->m_pbitstrmIn);
	if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
		return WMV_CorruptedBits;
	}

	if (pmbmd-> m_bSkip) {
        pmbmd-> m_rgbCodedBlockPattern = 0;
		pmbmd-> m_dctMd = INTER;
		return WMV_Succeeded;
	}
	else
		pmbmd-> m_bSkip = FALSE_WMV; // might be reset later
	iMCBPC = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGMCBPCinter,gDecodeCodeTableMCBPCinter);
	if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
		return WMV_CorruptedBits;
	}

	if (iMCBPC < 0 || iMCBPC > 20) {
		return WMV_CorruptedBits;
	}

    iMBtype = iMCBPC >> 2;
	iCBPC = iMCBPC % 4;
	switch (iMBtype) {			
	case 0:
		pmbmd-> m_dctMd = INTER;
			iCBPY = 15 - BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGMCBPY,gDecodeCodeTableCBPY);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);
		pmbmd-> m_bCBPAllZero = (iCBPC == 0 && iCBPY == 0);
		break;
	case 3:
        pmbmd-> m_dctMd = INTRA;
		pmbmd-> m_rgbDCTCoefPredPattern = (U8_WMV) BS_getBit (pWMVDec->m_pbitstrmIn);
		if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
			return WMV_CorruptedBits;
		}
		iCBPY = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGMCBPY, gDecodeCodeTableCBPY);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);
        break;
    default:
        return WMV_CorruptedBits;
    }

	if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
		return WMV_CorruptedBits;
	}

	if (iCBPY < 0 || iCBPY > 15) {
		return WMV_CorruptedBits;
    }

    pmbmd->m_rgbCodedBlockPattern = (iCBPY << 2) | iCBPC;


//  Make it work with WMV2 codes
    pmbmd-> m_iMVPredDirection = 2;
    return WMV_Succeeded;
}

I32_WMV checkResyncMarker(tWMVDecInternalMember *pWMVDec)
{
    I32_WMV nBitsPeeked;
    I32_WMV iStuffedBits;
    if (pWMVDec->m_bResyncDisable)
        return FALSE_WMV;

	
	iStuffedBits = BS_peekBitsTillByteAlign ( pWMVDec->m_pbitstrmIn, nBitsPeeked);
	assert (nBitsPeeked > 0 && nBitsPeeked <= 8);
	if (iStuffedBits == ((1 << (nBitsPeeked - 1)) - 1))
		return (BS_peekBitsFromByteAlign (pWMVDec->m_pbitstrmIn, NUMBITS_VP_RESYNC_MARKER + pWMVDec->uiFCode - 1)
				== RESYNC_MARKER);
	return FALSE_WMV;
}

I32_WMV	decodeVideoPacketHeader(tWMVDecInternalMember *pWMVDec, I32_WMV& iCurrentQP)
{
    U32_WMV uiResyncMarker;
    I32_WMV	NumOfMB;
    I32_WMV iVal;
    I32_WMV iLengthOfMBNumber;
    U32_WMV uiMBNumber;
    I32_WMV stepDecoded;
    U32_WMV uiHEC;

	BS_flushMPEG4(pWMVDec->m_pbitstrmIn, 8);
	uiResyncMarker = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_VP_RESYNC_MARKER+pWMVDec->uiFCode - 1);

	NumOfMB = pWMVDec->m_uintNumMBX * pWMVDec->m_uintNumMBY;
	assert (NumOfMB>0);

	iVal = NumOfMB - 1;
	iLengthOfMBNumber = 0;
	for(; iVal; iLengthOfMBNumber++)
		iVal>>=1;

	uiMBNumber = 0;
	if(NumOfMB>1)
		uiMBNumber = BS_getBits  ( pWMVDec->m_pbitstrmIn, iLengthOfMBNumber);
	
	pWMVDec->m_iVPMBnum = uiMBNumber;

    stepDecoded = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_VP_QUANTIZER);
    iCurrentQP = stepDecoded; 

	uiHEC = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_VP_HEC);
	if (uiHEC){

		// Time reference and VOP_pred_type
		I32_WMV iModuloInc = 0;
        Time tCurrSec, tVopIncr;
        U32_WMV uiMarker;
        tFrameType_WMV tFrameType;
        I32_WMV	iIntraDcSwitchThr; 
        
		while (BS_getBits  ( pWMVDec->m_pbitstrmIn, 1) != 0)
			iModuloInc++;
		tCurrSec = iModuloInc + pWMVDec->m_tOldModuloBaseDecd;
		uiMarker = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
		assert(uiMarker == 1);
		tVopIncr = BS_getBits  ( pWMVDec->m_pbitstrmIn, pWMVDec->m_iNumBitsTimeIncr);
		uiMarker = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
		assert(uiMarker == 1);
		// this is bogus - swinder.
		//assert (pWMVDec->m_t == tCurrSec * 60 + tVopIncr * 60 / pWMVDec->m_volmd.iClockRate); //in terms of 60Hz clock ticks

		tFrameType = (tFrameType_WMV) BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_VP_PRED_TYPE);

		iIntraDcSwitchThr = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_VP_INTRA_DC_SWITCH_THR);
			if (pWMVDec->m_tFrmType == PVOP) {
				U32_WMV uiFCode = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_VOP_FCODE);
			}
	}
	return	TRUE_WMV;
}

/// MV


I32_WMV deScaleMV (I32_WMV iVLC, I32_WMV iResidual, I32_WMV iScaleFactor)
{
    if (iVLC == 0 && iResidual == 0)
        return 0;
    else if (iScaleFactor == 1)
        return (iVLC);
    else {
        I32_WMV iAbsDiffMVcomponent = abs (iVLC) * iScaleFactor + iResidual - iScaleFactor + 1; //changed a'c to enc
        return (sign (iVLC) * iAbsDiffMVcomponent);
    }
}

Void_WMV fitMvInRange (CVector& vctSrc, I32_WMV iMvRange)
{
    if (vctSrc.x < -1 * iMvRange)                   //* 2 to get length of [-range, range]
        vctSrc.x += 2 * iMvRange;
    else if (vctSrc.x >= iMvRange)
        vctSrc.x  -= 2 * iMvRange;

    if (vctSrc.y < -1 * iMvRange)
        vctSrc.y += 2 * iMvRange;
    else if (vctSrc.y >= iMvRange)
        vctSrc.y  -= 2 * iMvRange;
}

Void_WMV getDiffMV (tWMVDecInternalMember *pWMVDec, CVector& vctDiffMV)     //get half pel
{
    I32_WMV iResidual;
    I32_WMV lSymbol = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGMV,gDecodeCodeTableMV);
    I32_WMV iVLC = lSymbol - 32;
    if (iVLC != 0)
        iResidual = BS_getBits  ( pWMVDec->m_pbitstrmIn, pWMVDec->uiFCode - 1);
    else
        iResidual = 0;
    vctDiffMV.x  = (I8_WMV) deScaleMV (iVLC, iResidual, pWMVDec->iScaleFactor);

    lSymbol = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGMV,gDecodeCodeTableMV);
    iVLC = lSymbol - 32;
    if (iVLC != 0)
        iResidual = BS_getBits  ( pWMVDec->m_pbitstrmIn, pWMVDec->uiFCode - 1);
    else
        iResidual = 0;
    vctDiffMV.y  = (I8_WMV) deScaleMV (iVLC, iResidual, pWMVDec->iScaleFactor);
}


Void_WMV decodeIntraDCAcPred_MPEG4 (tWMVDecInternalMember *pWMVDec, tWMVDecodeStatus* pError, U8_WMV DecodeCodeTableIntraDC[], I32_WMV iMaxCodeWordLngIntraDC)//CHuffmanDecoder* pentrdecIntraDC)
{
    I8_WMV lSzDiffIntraDC;
	lSzDiffIntraDC = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, iMaxCodeWordLngIntraDC, DecodeCodeTableIntraDC);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);
    if (BS_invalid ( pWMVDec->m_pbitstrmIn))
        goto Error;
    if (lSzDiffIntraDC!=0)	{
        if(lSzDiffIntraDC <= 8) {
            U8_WMV chDiffIntraDC = (U8_WMV) BS_getBits  ( pWMVDec->m_pbitstrmIn, lSzDiffIntraDC);
            if (BS_invalid ( pWMVDec->m_pbitstrmIn))
                goto Error;
            *pError = WMV_Succeeded;
            if (!((1 << (lSzDiffIntraDC - 1)) & chDiffIntraDC))
                pWMVDec->m_rgiCoefRecon [0] = -1 * (( 0x00FF >> (8 - lSzDiffIntraDC)) & (~chDiffIntraDC));
	        else
                pWMVDec->m_rgiCoefRecon [0] = (I32_WMV)chDiffIntraDC;
        }
        else {
            U32_WMV uiDiffIntraDC =
                (U32_WMV) BS_getBits  ( pWMVDec->m_pbitstrmIn, lSzDiffIntraDC);
            if (BS_invalid ( pWMVDec->m_pbitstrmIn))
                goto Error;
            *pError = WMV_Succeeded;
            if (!((1 << (lSzDiffIntraDC - 1)) & uiDiffIntraDC))
                pWMVDec->m_rgiCoefRecon [0] = -1 * ((0xFFFF >> (16 - lSzDiffIntraDC)) & (~uiDiffIntraDC));
            else
                pWMVDec->m_rgiCoefRecon [0] = (I32_WMV) uiDiffIntraDC;
            BS_getBit (pWMVDec->m_pbitstrmIn); // get marker bit
        }
    }
	else{
		*pError = WMV_Succeeded;
		pWMVDec->m_rgiCoefRecon [0] = 0;
	}
//     fprintf(fp_head,"dc=%d %d ", pWMVDec->m_rgiCoefRecon[0], lSzDiffIntraDC);
	return;

Error:
    *pError = WMV_CorruptedBits;
	pWMVDec->m_rgiCoefRecon [0] = 0;
}

tWMVDecodeStatus DecodeInverseIntraBlockQuantizeAcPred_MPEG4 (
    tWMVDecInternalMember *pWMVDec, 
	CDCTTableInfo_Dec* IntraDCTTableInfo_Dec, 
	Bool_WMV CBP, 
	I16_WMV* pDct, 
	U8_WMV* piZigzagInv 	
)
{
	Huffman_WMV* hufDCTACDec = IntraDCTTableInfo_Dec->hufDCTACDec;
	I8_WMV* rgLevelAtIndx = IntraDCTTableInfo_Dec->pcLevelAtIndx;
	U8_WMV* rgRunAtIndx = IntraDCTTableInfo_Dec->puiRunAtIndx;
//  Change iStartIndxOfLastRun to iStartIndxOfLastRunMinus1 and <= to <
//	iStartIndxOfLastRun = IntraDCTTableInfo_Dec->iStartIndxOfLastRunMinus1;
	U8_WMV* rgIfNotLastNumOfLevelAtRunIntra = IntraDCTTableInfo_Dec->puiNotLastNumOfLevelAtRun;
	U8_WMV* rgIfLastNumOfLevelAtRunIntra = IntraDCTTableInfo_Dec->puiLastNumOfLevelAtRun; 
	U8_WMV* rgIfNotLastNumOfRunAtLevelIntra = IntraDCTTableInfo_Dec->puiNotLastNumOfRunAtLevel;
	U8_WMV* rgIfLastNumOfRunAtLevelIntra = IntraDCTTableInfo_Dec->puiLastNumOfRunAtLevel;
	U32_WMV iStartIndxOfLastRun = IntraDCTTableInfo_Dec->iStartIndxOfLastRunMinus1 + 1;
	I32_WMV iTCOEF_ESCAPE = IntraDCTTableInfo_Dec->iTcoef_ESCAPE;

    Bool_WMV bIsLastRun = FALSE_WMV;
    U32_WMV uiRun; // = 0;
    I32_WMV iLevel; // = 0;
    U32_WMV uiCoefCounter = 1;
    U8_WMV   lIndex;
    I32_WMV iDoubleStepSize = pWMVDec->m_iDoubleStepSize;
    I32_WMV iStepMinusStepIsEven = pWMVDec->m_iStepMinusStepIsEven;
    I32_WMV i;

	if (CBP) {
        I32_WMV iMaxAC = (1<<11) -1; 
		do {
			lIndex = (U8_WMV) Huffman_WMV_get (hufDCTACDec, pWMVDec->m_pbitstrmIn);
			//lIndex = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, iMAXCODEWORDLNGDCT,decodeCodeTableDCT);
            assert(lIndex <= iTCOEF_ESCAPE);
			if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
				return WMV_CorruptedBits;
			}
			if (lIndex != iTCOEF_ESCAPE)	{
				bIsLastRun = (lIndex >= iStartIndxOfLastRun);
				uiRun = rgRunAtIndx[lIndex];
				iLevel = (BS_getBit (pWMVDec->m_pbitstrmIn)) ? - rgLevelAtIndx[lIndex] :
					rgLevelAtIndx[lIndex];
				if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
					return WMV_CorruptedBits;
				}
			}
			else {
				if (BS_getBit (pWMVDec->m_pbitstrmIn)==0){
                    if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
    					BOE;
                        return WMV_CorruptedBits;
                    }
					// ESC + '0' + VLC
					//lIndex = (U8_WMV) hufDCTACDec->get (pWMVDec->m_pbitstrmIn);
                    lIndex = (U8_WMV) Huffman_WMV_get (hufDCTACDec, pWMVDec->m_pbitstrmIn);
					//lIndex = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, iMAXCODEWORDLNGDCT, decodeCodeTableDCT);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);
                    if (BS_invalid ( pWMVDec->m_pbitstrmIn) || lIndex == iTCOEF_ESCAPE) { // ESC + 1 + ESC :  bits corrupted
			            return WMV_CorruptedBits;
		            }
					uiRun = rgRunAtIndx [lIndex];
					iLevel = rgLevelAtIndx[lIndex];
					if (lIndex >= iStartIndxOfLastRun){
						bIsLastRun = TRUE_WMV;
						iLevel += (I8_WMV) rgIfLastNumOfLevelAtRunIntra[uiRun];
					}
					else
						iLevel += (I8_WMV) rgIfNotLastNumOfLevelAtRunIntra[uiRun];
					if (BS_getBit (pWMVDec->m_pbitstrmIn)) 
						iLevel = -iLevel;
                    if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
                        return WMV_CorruptedBits;
                    }
				}
				else if (BS_getBit (pWMVDec->m_pbitstrmIn)==0){
                    if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {    					
                        return WMV_CorruptedBits;
                    }
					// ESC + '10' + VLC
					//lIndex = (U8_WMV) hufDCTACDec->get (pWMVDec->m_pbitstrmIn);
                    lIndex = (U8_WMV) Huffman_WMV_get (hufDCTACDec, pWMVDec->m_pbitstrmIn);
					//lIndex = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, iMAXCODEWORDLNGDCT, decodeCodeTableDCT);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);
                    if (BS_invalid ( pWMVDec->m_pbitstrmIn) || lIndex == iTCOEF_ESCAPE) { // ESC + 1 + ESC :  bits corrupted
			            return WMV_CorruptedBits;
		            }
					uiRun = rgRunAtIndx [lIndex];
					iLevel = rgLevelAtIndx[lIndex];
					if (lIndex >= iStartIndxOfLastRun){
						bIsLastRun = TRUE_WMV;
						uiRun += (rgIfLastNumOfRunAtLevelIntra[iLevel]+1);
					}
					else
						uiRun += (rgIfNotLastNumOfRunAtLevelIntra[iLevel]+1);
					if (BS_getBit (pWMVDec->m_pbitstrmIn)) 
						iLevel = -iLevel;
                    if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
                        return WMV_CorruptedBits;
                    }
				}
				else{
					// ESC + '11' + FLC
					bIsLastRun = (Bool_WMV) BS_getBit (pWMVDec->m_pbitstrmIn); // escape decoding
					uiRun = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_ESC_RUN);			
				    BS_getBit (pWMVDec->m_pbitstrmIn); // marker bit
					iLevel = (I32_WMV) BS_getBits  ( pWMVDec->m_pbitstrmIn, 12);
                    assert (iLevel != iMaxAC +1);
                    if(iLevel > iMaxAC)
                        iLevel -= (1<<12);
                    assert (iLevel != 0);
				    BS_getBit (pWMVDec->m_pbitstrmIn); // marker bit
		            if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
			            return WMV_CorruptedBits;
		            }
				}
			}
//             fprintf(fp_head,"(%d %d)", uiRun,iLevel);
            assert(uiRun<= 63);
			uiCoefCounter += uiRun;

			if (uiCoefCounter >= BLOCK_SQUARE_SIZE) {
				return WMV_CorruptedBits;
			}
			// Use 8x8 for each blcok to aVoid_WMV IFs. 
			if ((piZigzagInv[uiCoefCounter] & 0xfffffff8) == 0)  // cnt >= 0(1) && <=7
				pDct[piZigzagInv[uiCoefCounter]] = iLevel + pDct[piZigzagInv[uiCoefCounter]];
			else if ((piZigzagInv[uiCoefCounter] & 0x00000007) == 0) // cnt mod 8 == 0
				pDct[BLOCK_SIZE + (piZigzagInv[uiCoefCounter] >> 3)] = iLevel + pDct[BLOCK_SIZE + (piZigzagInv [uiCoefCounter] >> 3)];
			else {
				if (iLevel > 0)
//					pWMVDec->m_rgiCoefRecon[piZigzagInv[uiCoefCounter]] = (PixelI32) ((pWMVDec->m_iStepSize * (iLevel * 2 + 1)) - pWMVDec->m_bStepSizeIsEven);
					pWMVDec->m_rgiCoefRecon[piZigzagInv[uiCoefCounter]] = iDoubleStepSize * iLevel + iStepMinusStepIsEven;
				else // iLevel < 0 (note: iLevel != 0)
//					pWMVDec->m_rgiCoefRecon[piZigzagInv[uiCoefCounter]] = (PixelI32) ((pWMVDec->m_iStepSize * (iLevel * 2 - 1)) + pWMVDec->m_bStepSizeIsEven);
					pWMVDec->m_rgiCoefRecon[piZigzagInv[uiCoefCounter]] = iDoubleStepSize * iLevel - iStepMinusStepIsEven;
			}
			uiCoefCounter++;
		} while (!bIsLastRun);
	}
//     fprintf(fp_head,"\n");
	for (i = 1; i < 8; i++){
		I32_WMV iLevel1 = pDct [i];
		if (iLevel1 == 0)
			pWMVDec->m_rgiCoefRecon [i] = 0;
        else if (iLevel1 > 0)
//            pWMVDec->m_rgiCoefRecon [i] = (PixelI32) ((pWMVDec->m_iStepSize * (iLevel1 * 2 + 1)) - pWMVDec->m_bStepSizeIsEven);
            pWMVDec->m_rgiCoefRecon [i] = iDoubleStepSize * iLevel1 + iStepMinusStepIsEven;
		else
//            pWMVDec->m_rgiCoefRecon [i] = (PixelI32) ((pWMVDec->m_iStepSize * (iLevel1 * 2 - 1)) + pWMVDec->m_bStepSizeIsEven);
            pWMVDec->m_rgiCoefRecon [i] = iDoubleStepSize * iLevel1 - iStepMinusStepIsEven;
		
        iLevel1 = pDct [i + BLOCK_SIZE];
		if (iLevel1 == 0)
			pWMVDec->m_rgiCoefRecon [i << 3] = 0;
        else if (iLevel1 > 0)
//            pWMVDec->m_rgiCoefRecon [i << 3] = (PixelI32) ((pWMVDec->m_iStepSize * (iLevel1 * 2 + 1)) - pWMVDec->m_bStepSizeIsEven);
            pWMVDec->m_rgiCoefRecon [i << 3] = iDoubleStepSize * iLevel1 + iStepMinusStepIsEven;
		else
//            pWMVDec->m_rgiCoefRecon [i << 3] = (PixelI32) ((pWMVDec->m_iStepSize * (iLevel1 * 2 - 1)) + pWMVDec->m_bStepSizeIsEven);
            pWMVDec->m_rgiCoefRecon [i << 3] = iDoubleStepSize * iLevel1 - iStepMinusStepIsEven;
	}
	
    return WMV_Succeeded;
}

tWMVDecodeStatus DecodeInverseInterBlockQuantizeEscCode_MMX_MPEG4(tWMVDecInternalMember *pWMVDec, CDCTTableInfo_Dec* InterDCTTableInfo_Dec, U8_WMV *pZigzagInv, I32_WMV iXformMode)
{
	Huffman_WMV* hufDCTACDec = InterDCTTableInfo_Dec->hufDCTACDec;
	I8_WMV* rgLevelAtIndx = InterDCTTableInfo_Dec->pcLevelAtIndx;
	U8_WMV* rgRunAtIndx = InterDCTTableInfo_Dec->puiRunAtIndx;
//  Change iStartIndxOfLastRun to iStartIndxOfLastRunMinus1 and <= to <
//	iStartIndxOfLastRun = InterDCTTableInfo_Dec->iStartIndxOfLastRunMinus1;
	U8_WMV* rgIfNotLastNumOfLevelAtRun = InterDCTTableInfo_Dec->puiNotLastNumOfLevelAtRun;
	U8_WMV* rgIfLastNumOfLevelAtRun = InterDCTTableInfo_Dec->puiLastNumOfLevelAtRun; 
	U8_WMV* rgIfNotLastNumOfRunAtLevel = InterDCTTableInfo_Dec->puiNotLastNumOfRunAtLevel;
	U8_WMV* rgIfLastNumOfRunAtLevel = InterDCTTableInfo_Dec->puiLastNumOfRunAtLevel;
	U32_WMV iStartIndxOfLastRun = InterDCTTableInfo_Dec->iStartIndxOfLastRunMinus1 + 1;
	I32_WMV  iTCOEF_ESCAPE = InterDCTTableInfo_Dec->iTcoef_ESCAPE;

    Bool_WMV bIsLastRun = FALSE_WMV;
	U32_WMV uiRun; // = 0;
    I32_WMV	 iLevel; // = 0;
    U32_WMV uiCoefCounter = 0;
    U8_WMV   lIndex;
    I32_WMV iDoubleStepSize = pWMVDec->m_iDoubleStepSize;
    I32_WMV iStepMinusStepIsEven = pWMVDec->m_iStepMinusStepIsEven;
    //Align on cache line
//    I16_WMV *rgiCoefRecon = (I16_WMV*)(((I32_WMV)pWMVDec->m_rgiCoefRecon+32)&0xFFFFFFE0);
    I16_WMV *rgiCoefRecon = (I16_WMV*)pWMVDec->m_rgiCoefRecon;
	register I32_WMV iDCTHorzFlags = 0;

    memset (pWMVDec->m_rgiCoefRecon, 0, (size_t) MB_SQUARE_SIZE);
    I32_WMV iMaxAC = (1<<11) -1; 
    do {
		//lIndex = (U8_WMV) hufDCTACDec->get (pWMVDec->m_pbitstrmIn);
        lIndex = (U8_WMV) Huffman_WMV_get (hufDCTACDec, pWMVDec->m_pbitstrmIn);
		//lIndex = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGDCT,gDecodeCodeTableDCT);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);
		if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
			return WMV_CorruptedBits;
		}
        //lIndex = pWMVDec->m_pentrdecDCT->decodeSymbol();
        // if Huffman
        if (lIndex != iTCOEF_ESCAPE)	{
			if (lIndex >= iStartIndxOfLastRun)
				bIsLastRun = TRUE_WMV;
            uiRun = rgRunAtIndx[lIndex];
            iLevel = (BS_getBit (pWMVDec->m_pbitstrmIn)) ? - rgLevelAtIndx[lIndex] :
                rgLevelAtIndx[lIndex];
            if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
                return WMV_CorruptedBits;
            }
        } 
		else {
			if (BS_getBit (pWMVDec->m_pbitstrmIn)==0){
                if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
                    return WMV_CorruptedBits;
                }
				// ESC + '0' + VLC
        		//lIndex = (U8_WMV) hufDCTACDec->get (pWMVDec->m_pbitstrmIn);
                lIndex = (U8_WMV) Huffman_WMV_get (hufDCTACDec, pWMVDec->m_pbitstrmIn);
				//lIndex = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGDCT,gDecodeCodeTableDCT);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);
                if (BS_invalid ( pWMVDec->m_pbitstrmIn) || lIndex == iTCOEF_ESCAPE) { // ESC + 1 + ESC :  bits corrupted
			        return WMV_CorruptedBits;
		        }
				uiRun = rgRunAtIndx[lIndex];
				iLevel = rgLevelAtIndx[lIndex];
				if (lIndex >= iStartIndxOfLastRun){
					bIsLastRun = TRUE_WMV;
					iLevel += (I8_WMV) rgIfLastNumOfLevelAtRun[uiRun];
				}
				else
					iLevel += (I8_WMV) rgIfNotLastNumOfLevelAtRun[uiRun];
				if (BS_getBit (pWMVDec->m_pbitstrmIn)) 
					iLevel = -iLevel;
                if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
                    return WMV_CorruptedBits;
                }
			}
			else if (BS_getBit (pWMVDec->m_pbitstrmIn)==0){
                if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
                    return WMV_CorruptedBits;
                }
				// ESC + '10' + VLC
        		//lIndex = (U8_WMV) hufDCTACDec->get (pWMVDec->m_pbitstrmIn);
                lIndex = (U8_WMV) Huffman_WMV_get (hufDCTACDec, pWMVDec->m_pbitstrmIn);
				//lIndex = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGDCT,gDecodeCodeTableDCT);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);
                if (BS_invalid ( pWMVDec->m_pbitstrmIn) || lIndex == iTCOEF_ESCAPE) { // ESC + 1 + ESC :  bits corrupted
			        return WMV_CorruptedBits;
		        }
				uiRun = rgRunAtIndx[lIndex];
				iLevel = rgLevelAtIndx[lIndex];
				if (lIndex >= iStartIndxOfLastRun){
					bIsLastRun = TRUE_WMV;
					uiRun += (rgIfLastNumOfRunAtLevel[iLevel]+1);
				}
				else
					uiRun += (rgIfNotLastNumOfRunAtLevel[iLevel]+1);
				if (BS_getBit (pWMVDec->m_pbitstrmIn)) 
					iLevel = -iLevel;
                if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
                    return WMV_CorruptedBits;
                }
			}
			else{
				// ESC + '11' + FLC
				bIsLastRun = (Bool_WMV) BS_getBit (pWMVDec->m_pbitstrmIn); // escape decoding
				uiRun =	BS_getBits (pWMVDec->m_pbitstrmIn,NUMBITS_ESC_RUN);			
				BS_getBit (pWMVDec->m_pbitstrmIn); // marker bit
				iLevel = (I32_WMV) BS_getBits  ( pWMVDec->m_pbitstrmIn, 12);
                assert (iLevel != iMaxAC +1);
                if(iLevel > iMaxAC)
                    iLevel -= (1<<12);
				BS_getBit (pWMVDec->m_pbitstrmIn); // marker bit
		        if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
			        return WMV_CorruptedBits;
		        }
			}
        }
//        fprintf(fp_head,"(%d %d)", uiRun,iLevel);
        uiCoefCounter += uiRun;

		if (uiCoefCounter >= BLOCK_SQUARE_SIZE) {
			BOE;
			return WMV_CorruptedBits;
        }
        register I32_WMV iIndex = pWMVDec->m_pZigzagInv [uiCoefCounter];
		if (iIndex & 0x7)
			iDCTHorzFlags |= (1<<((iIndex & 0x38)>>3));

		if (iLevel == 1)
			rgiCoefRecon [pZigzagInv [uiCoefCounter]] = (I16_WMV) pWMVDec->m_i2DoublePlusStepSize;
		else if (iLevel == -1)
			rgiCoefRecon [pZigzagInv [uiCoefCounter]] = (I16_WMV) pWMVDec->m_i2DoublePlusStepSizeNeg;
		else if (iLevel > 0)
//			I32_WMV iCoefRecon = pWMVDec->m_iStepSize * ((iLevel << 1) + 1) - pWMVDec->m_bStepSizeIsEven;
			rgiCoefRecon [pZigzagInv [uiCoefCounter]] = iDoubleStepSize * iLevel + iStepMinusStepIsEven;
		else
//			I32_WMV iCoefRecon = pWMVDec->m_bStepSizeIsEven - pWMVDec->m_iStepSize * (1 - (iLevel << 1));
			rgiCoefRecon [pZigzagInv [uiCoefCounter]] = iDoubleStepSize * iLevel - iStepMinusStepIsEven;
		uiCoefCounter++;
    } while (!bIsLastRun);
    pWMVDec->m_iDCTHorzFlags = iDCTHorzFlags;
    return WMV_Succeeded;
}

tWMVDecodeStatus DecodeInverseInterBlockQuantizeEscCode_MPEG4(tWMVDecInternalMember *pWMVDec, CDCTTableInfo_Dec* InterDCTTableInfo_Dec, U8_WMV *pZigzagInv, I32_WMV iXformMode)
{
	Huffman_WMV* hufDCTACDec = InterDCTTableInfo_Dec->hufDCTACDec;
	I8_WMV* rgLevelAtIndx = InterDCTTableInfo_Dec->pcLevelAtIndx;
	U8_WMV* rgRunAtIndx = InterDCTTableInfo_Dec->puiRunAtIndx;
//  Change iStartIndxOfLastRun to iStartIndxOfLastRunMinus1 and <= to <
//	iStartIndxOfLastRun = InterDCTTableInfo_Dec->iStartIndxOfLastRunMinus1;
	U8_WMV* rgIfNotLastNumOfLevelAtRun = InterDCTTableInfo_Dec->puiNotLastNumOfLevelAtRun;
	U8_WMV* rgIfLastNumOfLevelAtRun = InterDCTTableInfo_Dec->puiLastNumOfLevelAtRun; 
	U8_WMV* rgIfNotLastNumOfRunAtLevel = InterDCTTableInfo_Dec->puiNotLastNumOfRunAtLevel;
	U8_WMV* rgIfLastNumOfRunAtLevel = InterDCTTableInfo_Dec->puiLastNumOfRunAtLevel;
	U32_WMV iStartIndxOfLastRun = InterDCTTableInfo_Dec->iStartIndxOfLastRunMinus1 + 1;
	I32_WMV  iTCOEF_ESCAPE = InterDCTTableInfo_Dec->iTcoef_ESCAPE;

    Bool_WMV bIsLastRun = FALSE_WMV;
	U32_WMV uiRun; // = 0;
    I32_WMV	 iLevel; // = 0;
    U32_WMV uiCoefCounter = 0;
    U8_WMV   lIndex;
    I32_WMV iDoubleStepSize = pWMVDec->m_iDoubleStepSize;
    I32_WMV iStepMinusStepIsEven = pWMVDec->m_iStepMinusStepIsEven;
	register I32_WMV iDCTHorzFlags = 0;

#if !defined(_WIN32) && !defined(_Embedded_x86)
    assert(BLOCK_SQUARE_SIZE_2 <= UINT_MAX);
#endif
    memset (pWMVDec->m_rgiCoefRecon, 0, (size_t) MB_SQUARE_SIZE);
    I32_WMV iMaxAC = (1<<11) -1; 
    do {
		//lIndex = (U8_WMV) hufDCTACDec->get (pWMVDec->m_pbitstrmIn);
        lIndex = (U8_WMV) Huffman_WMV_get (hufDCTACDec, pWMVDec->m_pbitstrmIn);
		//lIndex = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGDCT,gDecodeCodeTableDCT);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);
		if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
			return WMV_CorruptedBits;
		}
        //lIndex = pWMVDec->m_pentrdecDCT->decodeSymbol();
        // if Huffman
        if (lIndex != iTCOEF_ESCAPE)	{
			if (lIndex >= iStartIndxOfLastRun)
				bIsLastRun = TRUE_WMV;
            uiRun = rgRunAtIndx[lIndex];
            iLevel = (BS_getBit (pWMVDec->m_pbitstrmIn)) ? - rgLevelAtIndx[lIndex] :
                rgLevelAtIndx[lIndex];
            if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
                return WMV_CorruptedBits;
            }
        } 
		else {
			if (BS_getBit (pWMVDec->m_pbitstrmIn)==0){
                if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
                    return WMV_CorruptedBits;
                }
				// ESC + '0' + VLC
        		//lIndex = (U8_WMV) hufDCTACDec->get (pWMVDec->m_pbitstrmIn);
                lIndex = (U8_WMV) Huffman_WMV_get (hufDCTACDec, pWMVDec->m_pbitstrmIn);
				//lIndex = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGDCT,gDecodeCodeTableDCT);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);
                if (BS_invalid ( pWMVDec->m_pbitstrmIn) || lIndex == iTCOEF_ESCAPE) { // ESC + 1 + ESC :  bits corrupted
			        return WMV_CorruptedBits;
		        }
				uiRun = rgRunAtIndx[lIndex];
				iLevel = rgLevelAtIndx[lIndex];
				if (lIndex >= iStartIndxOfLastRun){
					bIsLastRun = TRUE_WMV;
					iLevel += (I8_WMV) rgIfLastNumOfLevelAtRun[uiRun];
				}
				else
					iLevel += (I8_WMV) rgIfNotLastNumOfLevelAtRun[uiRun];
				if (BS_getBit (pWMVDec->m_pbitstrmIn)) 
					iLevel = -iLevel;
                if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
                    return WMV_CorruptedBits;
                }
			}
			else if (BS_getBit (pWMVDec->m_pbitstrmIn)==0){
                if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
                    return WMV_CorruptedBits;
                }
				// ESC + '10' + VLC
                //lIndex = (U8_WMV) hufDCTACDec->get (pWMVDec->m_pbitstrmIn);
                lIndex = (U8_WMV) Huffman_WMV_get (hufDCTACDec, pWMVDec->m_pbitstrmIn);
				//lIndex = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGDCT,gDecodeCodeTableDCT);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);
                if (BS_invalid ( pWMVDec->m_pbitstrmIn) || lIndex == iTCOEF_ESCAPE) { // ESC + 1 + ESC :  bits corrupted
			        return WMV_CorruptedBits;
		        }
				uiRun = rgRunAtIndx[lIndex];
				iLevel = rgLevelAtIndx[lIndex];
				if (lIndex >= iStartIndxOfLastRun){
					bIsLastRun = TRUE_WMV;
					uiRun += (rgIfLastNumOfRunAtLevel[iLevel]+1);
				}
				else
					uiRun += (rgIfNotLastNumOfRunAtLevel[iLevel]+1);
				if (BS_getBit (pWMVDec->m_pbitstrmIn)) 
					iLevel = -iLevel;
                if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
                    return WMV_CorruptedBits;
                }
			}
			else{
				// ESC + '11' + FLC
				bIsLastRun = (Bool_WMV) BS_getBit (pWMVDec->m_pbitstrmIn); // escape decoding
				uiRun =	BS_getBits (pWMVDec->m_pbitstrmIn,NUMBITS_ESC_RUN);			
				BS_getBit (pWMVDec->m_pbitstrmIn); // marker bit
				iLevel = (I32_WMV) BS_getBits  ( pWMVDec->m_pbitstrmIn, 12);
                assert (iLevel != iMaxAC +1);
                if(iLevel > iMaxAC)
                    iLevel -= (1<<12);
				BS_getBit (pWMVDec->m_pbitstrmIn); // marker bit
		        if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
			        return WMV_CorruptedBits;
		        }
			}
        }
        uiCoefCounter += uiRun;
//         fprintf(fp_head,"(%d %d)", uiRun,iLevel);

		if (uiCoefCounter >= BLOCK_SQUARE_SIZE) {
			return WMV_CorruptedBits;
        }

        register I32_WMV iIndex = pWMVDec->m_pZigzagInv [uiCoefCounter];
		if (iIndex & 0x7)
			iDCTHorzFlags |= (1<<((iIndex & 0x38)>>3));

		if (iLevel == 1)
			pWMVDec->m_rgiCoefRecon [pZigzagInv [uiCoefCounter]] = pWMVDec->m_i2DoublePlusStepSize;
		else if (iLevel == -1)
			pWMVDec->m_rgiCoefRecon [pZigzagInv [uiCoefCounter]] = pWMVDec->m_i2DoublePlusStepSizeNeg;
		else if (iLevel > 0)
//			I32_WMV iCoefRecon = pWMVDec->m_iStepSize * ((iLevel << 1) + 1) - pWMVDec->m_bStepSizeIsEven;
			pWMVDec->m_rgiCoefRecon [pZigzagInv [uiCoefCounter]] = iDoubleStepSize * iLevel + iStepMinusStepIsEven;
		else
//			I32_WMV iCoefRecon = pWMVDec->m_bStepSizeIsEven - pWMVDec->m_iStepSize * (1 - (iLevel << 1));
			pWMVDec->m_rgiCoefRecon [pZigzagInv [uiCoefCounter]] = iDoubleStepSize * iLevel - iStepMinusStepIsEven;

		uiCoefCounter++;
    } while (!bIsLastRun);
    pWMVDec->m_iDCTHorzFlags = iDCTHorzFlags;
#ifdef __MACVIDEO__
    pWMVDec->m_iDCTHorzFlags = 0xffffffff;
#endif
    return WMV_Succeeded;
}

tWMVDecodeStatus decodeVOLHeadMP4S(tWMVDecInternalMember *pWMVDec)
{
//	assert (pWMVDec->m_cvCodecVersion == MP4S || pWMVDec->m_cvCodecVersion == mp4s);

    I32_WMV iCodeWord, iMarkerBit;
    U32_WMV uiVoStartCode, uiVoID, uiVolStartCode, volID, uiOLType, uiOLI;
    U32_WMV iAspectRatio, uiCTP, uiAUsage, uiTimeIncrRes, uiSprite;
    Bool_WMV bRandom, bFixFrameRate, bInterlaced, bOBMCDisable, bNot8BitVideo;
    I32_WMV iQuantizer, bScalability;
    Bool_WMV bComplexityEstDisable, bDummyDP;

    iCodeWord = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_START_CODE_PREFIX);
    if (iCodeWord != START_CODE_PREFIX)
        return WMV_CorruptedBits;

    uiVoStartCode = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_VO_START_CODE);
    if (uiVoStartCode != VO_START_CODE) 
        return WMV_CorruptedBits;

    uiVoID = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_VO_ID);
    
    iCodeWord = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_START_CODE_PREFIX);
    if (iCodeWord != START_CODE_PREFIX)
        return WMV_CorruptedBits;

    uiVolStartCode = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_VOL_START_CODE);
    if (uiVolStartCode != VOL_START_CODE) 
        return WMV_CorruptedBits;
    volID = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_VOL_ID);

    bRandom = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
    if (bRandom != FALSE)  // randopWMVDec->m_access
        return WMV_CorruptedBits;
    uiOLType = BS_getBits  ( pWMVDec->m_pbitstrmIn, 8); //VOL_Type_Indication
    uiOLI = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1); // iis-Object-layer-identifier
    if (uiOLI != 0) 
        return WMV_CorruptedBits;
    iAspectRatio = BS_getBits  ( pWMVDec->m_pbitstrmIn, 4); // aspect ratio
    if (iAspectRatio != 1) 
        return WMV_CorruptedBits;
    uiCTP = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1); // control parameter
    if (uiCTP != 0) 
        return WMV_CorruptedBits;
    uiAUsage = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_VOL_SHAPE);

    iMarkerBit = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1); // marker bit
    if (iMarkerBit != 1) 
        return WMV_CorruptedBits;

    uiTimeIncrRes = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_TIME_RESOLUTION);
	if (uiTimeIncrRes == 0)
		return WMV_CorruptedBits;
	pWMVDec->m_iClockRate = uiTimeIncrRes;
	// changed this back to old way because we cant change encoder - swinder
	for (pWMVDec->m_iNumBitsTimeIncr = 1; pWMVDec->m_iNumBitsTimeIncr < 16; pWMVDec->m_iNumBitsTimeIncr++) {
		if (uiTimeIncrRes == 1)
			break;
		uiTimeIncrRes >>= 1;
	}

    iMarkerBit = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1); // marker bit
    if (iMarkerBit != 1) 
        return WMV_CorruptedBits;
    bFixFrameRate = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1); // fixed_vop_rate
    if (bFixFrameRate != FALSE) 
        return WMV_CorruptedBits;
    iMarkerBit = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1); // marker bit
    if (iMarkerBit != 1) 
        return WMV_CorruptedBits;
    pWMVDec->m_iFrmWidthSrc = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_VOP_WIDTH);
    iMarkerBit  = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
    if (iMarkerBit != 1) 
        return WMV_CorruptedBits;
    pWMVDec->m_iFrmHeightSrc = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_VOP_HEIGHT);
    iMarkerBit  = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
    if (iMarkerBit != 1) 
        return WMV_CorruptedBits;
    
    bInterlaced = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1); // interlace
    if (bInterlaced != FALSE) 
        return WMV_CorruptedBits;
  
    bOBMCDisable = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1); // obmc-disable
    if (bOBMCDisable != TRUE_WMV) 
        return WMV_CorruptedBits;

    uiSprite = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_SPRITE_USAGE); // sprite used?
    if (uiSprite != 0) 
        return WMV_CorruptedBits;
 
    bNot8BitVideo = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1); // 8-bit video
    if (bNot8BitVideo != FALSE) 
        return WMV_CorruptedBits;

    if (bNot8BitVideo != FALSE) 
        return WMV_CorruptedBits;
//    else
//        pWMVDec->m_volmd.uiQuantPrecision = 5;
    
    iQuantizer = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
    if (iQuantizer  == TRUE_WMV) // loadable quant table
        return WMV_CorruptedBits;
    
    bComplexityEstDisable = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1); // 
    if (bComplexityEstDisable == FALSE) 
        return WMV_CorruptedBits;

	pWMVDec->m_bResyncDisable = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1); //  resync marker
	bDummyDP = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
    if (bDummyDP == TRUE_WMV)
        return WMV_CorruptedBits;

    bScalability = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1); //  scalable? 0
    if (bScalability == TRUE_WMV) 
        return WMV_CorruptedBits;

    BS_flushMPEG4 (pWMVDec->m_pbitstrmIn);
    setSliceCode (pWMVDec, 0);
    return WMV_Succeeded;
}
#endif


#ifdef _MPG4_
/// V1
I32_WMV CVideoObjectDecoder::DecodeIMB (
    tWMVDecInternalMember *pWMVDec, 
    const Bool_WMV*         rgCBP,
    U8_WMV*      ppxliTextureQMBY,
    U8_WMV*      ppxliTextureQMBU,
    U8_WMV*      ppxliTextureQMBV)
{
    CDCTTableInfo_Dec* pInterDCTTableInfo_Dec = pWMVDec->m_pInterDCTTableInfo_Dec;
    CDCTTableInfo_Dec* pIntraDCTTableInfo_Dec = pWMVDec->m_pIntraDCTTableInfo_Dec;
    //CDCTTableInfo_Dec* pInterDCTTableInfo_Dec = &InterDCTTableInfo_Dec_MPEG4;
    //CDCTTableInfo_Dec* pIntraDCTTableInfo_Dec = &IntraDCTTableInfo_Dec_MPEG4;

    I32_WMV result;

    // Y-blocks first (4 blocks)
    U8_WMV * ppxliCodedBlkY = ppxliTextureQMBY;
    for (U32_WMV ib = 0; ib < 4; ib++) {
        decodeIntraDCY(&result);
        if (ICERR_OK != result) {
            BOE;
            return result;
        }
        pWMVDec->m_rgiCoefRecon [0] = (PixelI32)(pWMVDec->m_rgiDCRef [0] * pWMVDec->m_iDCStepSize);

        result = decodeIntraBlock (
            pIntraDCTTableInfo_Dec,
            rgCBP[ib],
            ppxliCodedBlkY,
            pWMVDec->m_iWidthPrevY
            );

        //result = decodeIntraBlock (rgCBP[ib], ppxliCodedBlkY, pWMVDec->m_iWidthPrevY, pWMVDec->m_pentrdecDCTY, grgLevelAtIndxOfIntraY, grgRunAtIndxOfIntraY, STARTINDEXOFLASTRUNOFINTRAY);
        if (ICERR_OK != result) {
            BOE;
            return result;
        }
        ppxliCodedBlkY += (ib != 1) ? BLOCK_SIZE : pWMVDec->m_iWidthPrevYxBlkMinusBlk;
    }

    // U-blocks
    decodeIntraDCU (&result);
    if (ICERR_OK != result) {
        BOE;
        return result;
    }

    pWMVDec->m_rgiCoefRecon [0] = (PixelI32) (pWMVDec->m_rgiDCRef [1] << 3);

    result = decodeIntraBlock(
        pInterDCTTableInfo_Dec,
        rgCBP [4],
        ppxliTextureQMBU,
        pWMVDec->m_iWidthPrevUV
        );

    //result = decodeIntraBlock(rgCBP [4], ppxliTextureQMBU, pWMVDec->m_iWidthPrevUV, pWMVDec->m_pentrdecDCT, grgLevelAtIndx, grgRunAtIndx, STARTINDEXOFLASTRUN);
    if (ICERR_OK != result) {
        BOE;
        return result;
    }

    // V-blocks
    decodeIntraDCV (&result);

    if (ICERR_OK != result) {
        BOE;
        return result;
    }

    pWMVDec->m_rgiCoefRecon [0] = (PixelI32) (pWMVDec->m_rgiDCRef [2] << 3);

    result = decodeIntraBlock(
        pInterDCTTableInfo_Dec,
        rgCBP [5],
        ppxliTextureQMBV,
        pWMVDec->m_iWidthPrevUV
        );

    //result = decodeIntraBlock(rgCBP [5], ppxliTextureQMBV, pWMVDec->m_iWidthPrevUV, pWMVDec->m_pentrdecDCT, grgLevelAtIndx, grgRunAtIndx, STARTINDEXOFLASTRUN);

    if (ICERR_OK != result) {
        BOE;
        return result;
    }

    return ICERR_OK;
}

I32_WMV CVideoObjectDecoder::decodeMBOverheadOfIVOP_Old (tWMVDecInternalMember *pWMVDec, CMBMode* pmbmd, I32_WMV imbX, I32_WMV imbY)
{
    I32_WMV iCBPC = 0;
    I32_WMV iCBPY = 0;
	I32_WMV iMCBPC = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGMCBPCintra,gDecodeCodeTableMCBPCintra);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);

	if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
		BOE;
		return ICERR_ERROR;
	}
	if (iMCBPC < 0 || iMCBPC > 7) {
		BOE;
		return ICERR_ERROR;
	}

    pmbmd-> m_bSkip = FALSE_WMV;
	pmbmd-> m_dctMd = INTRA;
	iCBPC = iMCBPC % 4;
	iCBPY = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGMCBPY,gDecodeCodeTableCBPY);
	if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
		BOE;
		return ICERR_ERROR;
    }

    pmbmd->m_rgbCodedBlockPattern = (iCBPY << 2) | iCBPC;


	return ICERR_OK;
}

I32_WMV CVideoObjectDecoder::decodeMBOverheadOfPVOP_Old (tWMVDecInternalMember *pWMVDec, CMBMode* pmbmd)
{
    I32_WMV iMCBPC = 0;
    I32_WMV iCBPC = 0;
    I32_WMV iCBPY = 0;
    pmbmd-> m_bSkip = BS_getBit (pWMVDec->m_pbitstrmIn);
    if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
        BOE;
        return ICERR_ERROR;
    }

	if (pmbmd-> m_bSkip) {
        pmbmd-> m_rgbCodedBlockPattern = 0;
		pmbmd-> m_dctMd = INTER;
		return ICERR_OK;
	}
	else {
		iMCBPC = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGMCBPCinter,gDecodeCodeTableMCBPCinter);
		if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
			BOE;
			return ICERR_ERROR;
		}

		if (iMCBPC < 0 || iMCBPC > 20) {
			BOE;
			return ICERR_ERROR;
		}
		pmbmd-> m_dctMd = (DCTMode) (iMCBPC >> 2);
        iCBPC = iMCBPC % 4;
		iCBPY = 15 - BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGMCBPY,gDecodeCodeTableCBPY);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);
		if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
			BOE;
			return ICERR_ERROR;
		}
		if (iCBPY < 0 || iCBPY > 15) {
			BOE;
			return ICERR_ERROR;
		}
	}

    pmbmd->m_rgbCodedBlockPattern = (iCBPY << 2) | iCBPC;
  
    return ICERR_OK;
}

I32_WMV CVideoObjectDecoder::decodeIntraBlock (
    tWMVDecInternalMember *pWMVDec, 
	CDCTTableInfo_Dec* IntraDCTTableInfo_Dec, 
    Bool_WMV         CBP,                    //= 0 if no AC coef
    U8_WMV *ppxliTextureQMB,        //place to set the pixels
    I32_WMV          iOffsetToNextRowForDCT
)
{
    I32_WMV result;

	if (CBP) {
#if !defined(_WIN32)
        assert(BLOCK_SQUARE_SIZE_2MINUS2 <= UINT_MAX);
#endif
        memset (pWMVDec->m_rgiCoefReconPlus1, 0, (size_t) BLOCK_SQUARE_SIZE_2MINUS2);
        result = DecodeInverseIntraBlockQuantize (IntraDCTTableInfo_Dec);							//get the quantized block	
		if (ICERR_OK != result) {
			BOE;
			return result;
		}
		(*pWMVDec->m_pIntraIDCT_Dec) (ppxliTextureQMB, iOffsetToNextRowForDCT, pWMVDec->m_rgiCoefRecon);
	}
	else {
		//I32_WMV iWidth = iOffsetToNextRowForDCT;
		// loop through ppxliTextureQMBV 0 replaced by a const
		// Take another look at negative rounding. /blin
		U8_WMV tmp = (U8_WMV) ((pWMVDec->m_rgiCoefRecon [0] + 4) >> 3);
		for (U8_WMV i = 0; i < BLOCK_SIZE; i++) {
#if !defined(_WIN32)
			assert(BLOCK_SIZE <= UINT_MAX);
#endif
			memset (ppxliTextureQMB, tmp, (size_t) BLOCK_SIZE);
			ppxliTextureQMB += iOffsetToNextRowForDCT;
		}
	}
    return ICERR_OK;
}

I32_WMV CVideoObjectDecoder::DecodeInverseIntraBlockQuantize (tWMVDecInternalMember *pWMVDec, CDCTTableInfo_Dec* IntraDCTTableInfo_Dec)
{
	Huffman* hufDCTACDec = IntraDCTTableInfo_Dec->hufDCTACDec;
	I8_WMV* rgLevelAtIndx = IntraDCTTableInfo_Dec->pcLevelAtIndx;
	U8_WMV* rgRunAtIndx = IntraDCTTableInfo_Dec->puiRunAtIndx;
//  Change iStartIndxOfLastRun to iStartIndxOfLastRunMinus1 and <= to <
//	iStartIndxOfLastRun = IntraDCTTableInfo_Dec->iStartIndxOfLastRunMinus1;
	U32_WMV iStartIndxOfLastRun = IntraDCTTableInfo_Dec->iStartIndxOfLastRunMinus1 + 1;
	I32_WMV iTCOEF_ESCAPE = IntraDCTTableInfo_Dec->iTcoef_ESCAPE;

    Bool_WMV bIsLastRun;
    U32_WMV uiRun; // = 0;
    I8_WMV iLevel; // = 0;
    U32_WMV uiCoefCounter = 1;
    U8_WMV   lIndex;
    I32_WMV iDoubleStepSize = pWMVDec->m_iDoubleStepSize;
    I32_WMV iStepMinusStepIsEven = pWMVDec->m_iStepMinusStepIsEven;

    do {
		//lIndex = hufDCTACDec->get (pWMVDec->m_pbitstrmIn);
        lIndex = (U8_WMV) Huffman_WMV_get (hufDCTACDec, pWMVDec->m_pbitstrmIn);
		//lIndex = BS_getMaxBits ( pWMVDec->m_pbitstrmIn, MAXCODEWORDLNGDCT, decodeCodeTableDCT);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);
		if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
            BOE;
            return ICERR_ERROR;
        }
        if (lIndex != iTCOEF_ESCAPE)	{
            bIsLastRun = (lIndex >= iStartIndxOfLastRun);
            uiRun = rgRunAtIndx [lIndex];
            iLevel = (BS_getBit (pWMVDec->m_pbitstrmIn)) ? -rgLevelAtIndx [lIndex] :
                rgLevelAtIndx[lIndex];
            if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
                BOE;
                return ICERR_ERROR;
            }
        }
		else {
            bIsLastRun = (Bool_WMV) BS_getBit (pWMVDec->m_pbitstrmIn); // escape decoding
            uiRun = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_ESC_RUN);			
			iLevel = (I8_WMV) BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_ESC_LEVEL);
			if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
				BOE;
				return ICERR_ERROR;
			}
        }
        uiCoefCounter += uiRun;

        if (uiCoefCounter >= BLOCK_SQUARE_SIZE) {
            BOE;
            return ICERR_ERROR;
        }

		if (iLevel > 0)
//			I32_WMV iCoefRecon = pWMVDec->m_iStepSize * ((iLevel << 1) + 1) - pWMVDec->m_bStepSizeIsEven;
            pWMVDec->m_rgiCoefRecon [grgiZigzagInv [uiCoefCounter]] = iDoubleStepSize * iLevel + iStepMinusStepIsEven;
        else 
//			I32_WMV iCoefRecon = pWMVDec->m_bStepSizeIsEven - pWMVDec->m_iStepSize * (1 - (iLevel << 1));
			pWMVDec->m_rgiCoefRecon [grgiZigzagInv [uiCoefCounter]] = iDoubleStepSize * iLevel - iStepMinusStepIsEven;
        uiCoefCounter++;
    } while (!bIsLastRun);

    return ICERR_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\wmadecS_api.c ===
#include "bldsetup.h"

#include "wmadecS_api.h"
#include "macros.h"
#include "msaudio.h"
#include "msaudiodec.h"

typedef struct WMARawDecStruct
{
    CAudioObjectDecoder *pAudDecoder;
} WMARawDecStruct;

//#define WMAMEM_SIZE 27280 // for high bitrate
//#define WMAMEM_SIZE 27840 // for all rates
//U8_WMARawDec rgWMAMem [WMAMEM_SIZE];

WMARESULT WMARawDecInit (
    WMARawDecHandle* phWMARawDec,
    U32_WMARawDec dwUserData,
    U16_WMARawDec iVersionNumber,
    U16_WMARawDec cSamplesPerBlock, 
    U16_WMARawDec cSamplesPerSecond, 
    U16_WMARawDec cChannel, 
    U16_WMARawDec cBytePerSec, 
    U16_WMARawDec cPacketLength,
    U16_WMARawDec cEncodeOpt,
    U16_WMARawDec cPlayerOpt
) {
    WMARESULT hr;
    WMARawDecStruct* pWMARawDec;

//    phWMARawDec = NULL; // initialize as NULL for later checking
    pWMARawDec = (WMARawDecStruct*) wmvalloc (sizeof (WMARawDecStruct));
    if (pWMARawDec == NULL)
        return WMA_E_OUTOFMEMORY;


    pWMARawDec->pAudDecoder = audecNew (NULL, 0);
//    pWMARawDec->pAudDecoder = audecNew (rgWMAMem, WMAMEM_SIZE);
    if (pWMARawDec->pAudDecoder == NULL)
        return WMA_E_OUTOFMEMORY;

    hr = audecInit (
        pWMARawDec->pAudDecoder,
        (Int) iVersionNumber,
        cSamplesPerBlock,
        cSamplesPerSecond,
        cChannel,
        cBytePerSec,
        cPacketLength,
        cEncodeOpt,
        cPlayerOpt,
        WMARawDecCBGetData, 
        dwUserData,
        NULL
    );
// for unsupported formats

	if (hr == 0x80040000)
		return WMA_E_NOTSUPPORTED;
    
	if (WMA_FAILED (hr))
        return WMA_E_FAIL;

    *phWMARawDec = (WMARawDecHandle) pWMARawDec;
    return WMA_OK;
}
    
WMARESULT WMARawDecClose (WMARawDecHandle* phWMARawDec)
{
    WMARawDecStruct* pWMARawDec;

    pWMARawDec = (WMARawDecStruct*) (*phWMARawDec);
    if (pWMARawDec != NULL) {
        if (pWMARawDec->pAudDecoder != NULL) {
            audecDelete (pWMARawDec->pAudDecoder);
            pWMARawDec->pAudDecoder = NULL;
        }
        wmvfree (pWMARawDec);
        *phWMARawDec = NULL;
    }
    phWMARawDec = NULL;
    return WMA_OK;
}

WMARESULT WMARawDecReset (WMARawDecHandle hWMARawDec)
{
    WMARawDecStruct* pWMARawDec;
    pWMARawDec = (WMARawDecStruct*) hWMARawDec;

    if (pWMARawDec == NULL || pWMARawDec->pAudDecoder == NULL)
        return WMA_E_INVALIDARG;
    else
        return (audecReset (pWMARawDec->pAudDecoder));
}

WMARESULT WMARawDecStatus (WMARawDecHandle hWMARawDec)
{
    WMARawDecStruct* pWMARawDec;
    pWMARawDec = (WMARawDecStruct*) hWMARawDec;

    if (pWMARawDec == NULL || pWMARawDec->pAudDecoder == NULL)
        return WMA_E_INVALIDARG;
    else
        return (audecDecodeInfo (pWMARawDec->pAudDecoder));
}

WMARESULT WMARawDecDecodeData (WMARawDecHandle hWMARawDec, U32_WMARawDec *pnDecodedSamples)
{
    WMARawDecStruct* pWMARawDec;
    pWMARawDec = (WMARawDecStruct*) hWMARawDec;

    if (pWMARawDec == NULL || pWMARawDec->pAudDecoder == NULL)
        return WMA_E_INVALIDARG;
    else
        return (audecDecodeData (pWMARawDec->pAudDecoder, (U16_WMARawDec*) pnDecodedSamples));
}

WMARESULT WMARawDecGetPCM (WMARawDecHandle hWMARawDec, U16_WMARawDec* pcSampleReady, U8_WMARawDec* pbDst, U32_WMARawDec cbDstBufferLength)
{
    WMARawDecStruct* pWMARawDec;
    pWMARawDec = (WMARawDecStruct*) hWMARawDec;
    if (pWMARawDec == NULL || pWMARawDec->pAudDecoder == NULL)
        return WMA_E_INVALIDARG;
    else 
        return (audecGetPCM (pWMARawDec->pAudDecoder, pcSampleReady, pbDst, cbDstBufferLength));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\strmdec_wmv.cpp ===
/*************************************************************************

Copyright (C) 1996, 1997  Microsoft Corporation

Module Name:

    strmdec.cpp

Abstract:

    Decoder BitStream

Author:

    Craig Dowell (craigdo@microsoft.com) 10-December-1996
    Ming-Chieh Lee (mingcl@microsoft.com) 10-December-1996
    Bruce Lin (blin@microsoft.com) 10-December-1996

Revision History:

*************************************************************************/
#include "bldsetup.h"

#include <stdio.h>
#include <stdlib.h>
#include "xplatform.h"
#include "typedef.hpp"
#include "strmdec_wmv.hpp"
#include "wmvdec_api.h"
#include "wmvdec_member.h"
#include "wmvdec_function.h"

#ifdef OPT_HUFFMAN_DBGDMP
U32_WMV opt_huffman_dbgdmp[0x20000];
int opt_huffman_dbgdmp_idx;
#endif

#if DBG
DWORD g_TotalBits;
#endif

Void_WMV BS_construct (CInputBitStream_WMV * pThis, U32_WMV uiUserData)
{
    pThis->m_pBuffer = NULL_WMV;
    pThis->m_cbBuflen = 0;
#ifdef OPT_HUFFMAN_GET_WMV
    pThis->m_currBits=0;
    pThis->m_nextBits=0;
    pThis->m_BMS8.m_wBitsLeft = 0;
    pThis->m_BMS8.m_wNextBitsSkip=32;
    pThis->m_BMS8.m_fStreamStaus = VALID;
#else
    pThis->m_dwDot = 0;
    pThis->m_dwBitsLeft = 0;
    pThis->m_fStreamStaus = VALID;
#endif
    
    pThis->m_uiUserData = uiUserData;
}

Void_WMV BS_destruct (CInputBitStream_WMV * pThis)
{
}

#ifndef OPT_HUFFMAN_GET_WMV
U32_WMV GetMask_WMV[33] = {
    0x00000000,
    0x00000001,
    0x00000003,
    0x00000007,
    0x0000000f,
    0x0000001f,
    0x0000003f,
    0x0000007f,
    0x000000ff,
    0x000001ff,
    0x000003ff,
    0x000007ff,
    0x00000fff,
    0x00001fff,
    0x00003fff,
    0x00007fff,
    0x0000ffff,
    0x0001ffff,
    0x0003ffff,
    0x0007ffff,
    0x000fffff,
    0x001fffff,
    0x003fffff,
    0x007fffff,
    0x00ffffff,
    0x01ffffff,
    0x03ffffff,
    0x07ffffff,
    0x0fffffff,
    0x1fffffff,
    0x3fffffff,
    0x7fffffff,
    0xffffffff
};
#endif
#ifdef OPT_HUFFMAN_GET_WMV

#ifndef _EMB_ASM_ARM_STRMHUFF_


I32_WMV BS_getBits2(CInputBitStream_WMV * pThis, I32_WMV dwNumBits)
{

#if DBG
g_TotalBits += dwNumBits;
#endif

    BS_updateCurrNext(pThis);

    I32_WMV wBitsLeft;
    
    if ((wBitsLeft=(pThis->m_BMS8.m_wBitsLeft-(I16_WMV)dwNumBits))>=0) 
    {
                // result=(m_currBits >> m_dwBitsLeft) & GetMask[dwNumBits];
                //HUFFMANGET_DBG_DMP((m_currBits >> m_BMS8.m_wBitsLeft) & (((U32)0xffffffff)>>(32-dwNumBits)),0,0,0);
        pThis->m_BMS8.m_wBitsLeft=wBitsLeft;
        I32_WMV result=(pThis->m_currBits >> wBitsLeft) & (((U32_WMV)0xffffffff)>>(32-dwNumBits));
     //   BS_updateCurrNext(pThis);
        return result;
    }
    else
    {
        pThis->m_BMS8.m_wBitsLeft=0;
        pThis->m_BMS8.m_fStreamStaus = END_OF_FILE;
        pThis->m_cbBuflen=0;
        pThis->m_currBits=pThis->m_nextBits=0;
        pThis->m_BMS8.m_wNextBitsSkip=32;


    }

	return 0;

                    


}

#endif
Void_WMV BS_updateCurrNextEof(CInputBitStream_WMV * pThis, I32_WMV nextbits_shift, I32_WMV currBits);

#ifndef _EMB_ASM_ARM_STRMHUFF_
Void_WMV BS_updateCurrNext(CInputBitStream_WMV * pThis)
{


    register I32_WMV currBits, wBitsLeft, wNextBitsSkip, minus_nextbits_shift, minus1=-1;

    wBitsLeft=pThis->m_BNS16.m_BNS_base16L&0xff;
    wNextBitsSkip=pThis->m_BNS16.m_BNS_base16L>>8;
  
    currBits=(pThis->m_currBits<<(31-wBitsLeft))<<1;
    I32_WMV nextbits_shift=wBitsLeft-wNextBitsSkip;
    if(nextbits_shift>0) // nextBits contains enough bits for this shift.
    {
        pThis->m_currBits=currBits|((pThis->m_nextBits>>nextbits_shift)&(minus1>>wBitsLeft));
        pThis->m_BNS16.m_BNS_base16L=0x2020-(nextbits_shift<<8);
        return;
    }

    minus_nextbits_shift=-nextbits_shift;
    currBits|=(pThis->m_nextBits&(((U32_WMV)minus1)>>wNextBitsSkip))<<(minus_nextbits_shift);
    if(pThis->m_cbBuflen>=4)
    {           

        pThis->m_nextBits = ReadIntNBO(pThis->m_pBuffer);
        pThis->m_pBuffer += 4;
        pThis->m_cbBuflen-=4;
	
	    pThis->m_currBits=currBits|((pThis->m_nextBits>>(31+nextbits_shift))>>1); 

        pThis->m_BNS16.m_BNS_base16L=((minus_nextbits_shift)<<8)+32;
	
        return;
    }
 

    BS_updateCurrNextEof(pThis, nextbits_shift,currBits);


  return;
}
#endif
#ifdef __STREAMING_MODE_DECODE_
I32_WMV BS_streaming_update(CInputBitStream_WMV * pThis);
#endif

Void_WMV BS_updateCurrNextEof(CInputBitStream_WMV * pThis, I32_WMV nextbits_shift, I32_WMV  currBits)
{

            int i, num_bits;

            pThis->m_nextBits=0;
            nextbits_shift=-nextbits_shift;
            pThis->m_currBits=currBits;

            if((pThis->m_BMS8.m_wBitsLeft<0)||(pThis->m_BMS8.m_wBitsLeft>=128))
            {
                assert(0);
                pThis->m_BMS8.m_wBitsLeft=0;
                pThis->m_BMS8.m_fStreamStaus = END_OF_FILE;
                pThis->m_cbBuflen=0;
                pThis->m_currBits=pThis->m_nextBits=0;
                pThis->m_BMS8.m_wNextBitsSkip=32;
                return;


            }

            for(i=0;i<pThis->m_cbBuflen;i++)
            {
                pThis->m_nextBits<<=8;
                pThis->m_nextBits|=*pThis->m_pBuffer++;
            }
                
            num_bits=(pThis->m_cbBuflen<<3);
            if(num_bits>=nextbits_shift)
            {
                pThis->m_currBits|=pThis->m_nextBits>>(num_bits-nextbits_shift);
                pThis->m_BMS8.m_wNextBitsSkip=32-(num_bits-nextbits_shift);
                pThis->m_BMS8.m_wBitsLeft=32;
                pThis->m_cbBuflen=0;
			
#ifdef __STREAMING_MODE_DECODE_
				BS_streaming_update(pThis);
#endif
            }
            else
            {
                pThis->m_currBits|=pThis->m_nextBits<<(nextbits_shift-num_bits);
                pThis->m_currBits=pThis->m_currBits>>(nextbits_shift-num_bits);
				int tmp=32-(nextbits_shift-num_bits);
				
                pThis->m_BMS8.m_wBitsLeft=tmp;
                pThis->m_cbBuflen=0;
                pThis->m_BMS8.m_wNextBitsSkip=32;
				
#ifdef __STREAMING_MODE_DECODE_
				if(TRUE_WMV==BS_streaming_update(pThis))
				{
					BS_updateCurrNext(pThis);
				}
#endif
            }

}

I32_WMV BS_getMaxBits2(CInputBitStream_WMV * pThis, I32_WMV dwNumBits, U8_WMV* rgCodeSymSize)
{



    U32_WMV iBitPattern;
    I32_WMV bitsshift, result;
    
    BS_updateCurrNext(pThis);

    bitsshift=pThis->m_BMS8.m_wBitsLeft-dwNumBits;
    if(bitsshift>=0)
    {

        iBitPattern = ((pThis->m_currBits >> bitsshift) & (((U32_WMV)0xffffffff)>>(32-dwNumBits)))<<1; //0x00000fff;
        pThis->m_BMS8.m_wBitsLeft -= rgCodeSymSize[iBitPattern];
        result=rgCodeSymSize [iBitPattern+1];
        if (result == 255)
        {
                pThis->m_BMS8.m_wBitsLeft=0;
                pThis->m_BMS8.m_wNextBitsSkip=32;
                pThis->m_cbBuflen=0;
                pThis->m_BMS8.m_fStreamStaus = ILLEGAL_PATTERN;
        }

        HUFFMANGET_DBG_CACHE(rgCodeSymSize,iBitPattern,2);
        HUFFMANGET_DBG_DMP(result,rgCodeSymSize,iBitPattern+1,1);
        return result;
    }

    assert(pThis->m_BMS8.m_wNextBitsSkip==32);
    assert(pThis->m_cbBuflen==0);

    
    iBitPattern = ((pThis->m_currBits << (-bitsshift)) & (((U32_WMV)0xffffffff)>>(32-dwNumBits)))<<1; //0x00000fff;
    pThis->m_BMS8.m_wBitsLeft -= rgCodeSymSize[iBitPattern];
    result=rgCodeSymSize [iBitPattern+1];
    if (result == 255)
    {
        pThis->m_BMS8.m_wBitsLeft=0;
        pThis->m_BMS8.m_wNextBitsSkip=32;
        pThis->m_cbBuflen=0;
        pThis->m_BMS8.m_fStreamStaus = ILLEGAL_PATTERN;
    }
    else if((pThis->m_BMS8.m_wBitsLeft<0)||(pThis->m_BMS8.m_wBitsLeft>=128))
    {
        pThis->m_BMS8.m_wBitsLeft=0;
        pThis->m_BMS8.m_fStreamStaus = END_OF_FILE;
        result=255;
    }

    HUFFMANGET_DBG_CACHE(rgCodeSymSize,iBitPattern,2);
    HUFFMANGET_DBG_DMP(result,rgCodeSymSize,iBitPattern+1,1);
    return result;

}


 
#endif

#ifndef OPT_HUFFMAN_GET_WMV
U32_WMV BS_finalLoad( CInputBitStream_WMV * pThis, U32_WMV    dwRetval, U32_WMV       dwBitsToAdd)
{
    if ((pThis->m_cbBuflen << 3) < (I32_WMV)dwBitsToAdd) {
        pThis->m_fStreamStaus = END_OF_FILE;
        return 0;
    }

    U32_WMV              dwPosition = 4;
    pThis->m_dwDot = 0;
    pThis->m_dwBitsLeft = 0;

    for (; pThis->m_cbBuflen;) {
        pThis->m_dwDot <<= 8;
        pThis->m_dwDot |= *pThis->m_pBuffer++;
        --pThis->m_cbBuflen;
        pThis->m_dwBitsLeft += 8;
    }

    dwRetval <<= dwBitsToAdd;
    dwRetval |= (pThis->m_dwDot >> (pThis->m_dwBitsLeft - dwBitsToAdd)) & GetMask_WMV[dwBitsToAdd];
    pThis->m_dwBitsLeft -= dwBitsToAdd;
    return dwRetval;

}

#endif
#ifdef __STREAMING_MODE_DECODE_

#ifdef OPT_HUFFMAN_GET_WMV
I32_WMV BS_streaming_update(CInputBitStream_WMV * pThis)
{
	if (pThis->m_bNotEndOfFrame) 
	{
        Bool_WMV bNotEndOfFrame;
        U32_WMV  dwBufferLen;
        U8_WMV*  pBuffer;
        WMVDecCBGetData (pThis->m_uiUserData, 0, (U8_WMV**) &pBuffer, 4, &dwBufferLen, &bNotEndOfFrame);
                    //getVideoData(m_cbBuflen, &pBuffer, &dwBufferLen, &bNotEndOfFrame);
		if (bNotEndOfFrame){
			if (dwBufferLen == 0 || pBuffer == NULL){
				BS_setInvalid(pThis);
				return FALSE_WMV;
			}
		}

		pThis->m_pBuffer = pBuffer;
		pThis->m_cbBuflen = dwBufferLen;
		pThis->m_BMS8.m_fStreamStaus = VALID;
		pThis->m_bNotEndOfFrame = bNotEndOfFrame;

		if(pThis->m_BMS8.m_wNextBitsSkip==32)
		{
			if(pThis->m_cbBuflen>=4)
			{
				pThis->m_nextBits=ReadIntNBO(pThis->m_pBuffer);
				pThis->m_pBuffer+=4;
				pThis->m_cbBuflen-=4;
				pThis->m_BMS8.m_wNextBitsSkip=0;
			}
			else
			{
				int i;

				pThis->m_nextBits=0;
				for(i=0;i<pThis->m_cbBuflen;i++)
				{
					pThis->m_nextBits<<=8;
					pThis->m_nextBits|=*pThis->m_pBuffer++;
				}
				pThis->m_BMS8.m_wNextBitsSkip=32-(pThis->m_cbBuflen<<3);
                        
				pThis->m_cbBuflen=0;   
			}
        }

		return TRUE_WMV;
	}

	return FALSE_WMV;

}
#else
Void_WMV
BS_addDataToBuffer(
    CInputBitStream_WMV * pThis,
    U8_WMV          *pBuffer,
    U32_WMV        dwBuflen,
    Bool_WMV        bNotEndOfFrame
    )
{
    pThis->m_pBuffer = pBuffer;
    pThis->m_cbBuflen = dwBuflen;
    pThis->m_fStreamStaus = VALID;
    pThis->m_bNotEndOfFrame = bNotEndOfFrame;
}
#endif


#endif


Void_WMV
BS_reset(
    CInputBitStream_WMV * pThis,
    U8_WMV          *pBuffer,
    U32_WMV        dwBuflen,
    Bool_WMV        bNotEndOfFrame
    )
{
    pThis->m_pBuffer = pBuffer;
    pThis->m_cbBuflen = dwBuflen;


#ifdef OPT_HUFFMAN_GET_WMV

    pThis->m_BMS8.m_fStreamStaus = VALID;
	pThis->m_BMS8.m_wBitsLeft=0;
	pThis->m_BMS8.m_wNextBitsSkip=32;


    if(pThis->m_cbBuflen>=4)
    {
        pThis->m_currBits=ReadIntNBO(pBuffer);
        pThis->m_pBuffer+=4;
        pThis->m_cbBuflen-=4;

        pThis->m_BMS8.m_wBitsLeft=32;
        if(pThis->m_cbBuflen>=4)
        {
            pThis->m_nextBits=ReadIntNBO(pThis->m_pBuffer);
            pThis->m_pBuffer+=4;
            pThis->m_cbBuflen-=4;
            pThis->m_BMS8.m_wNextBitsSkip=0;
        }
        else
        {
            int i;

            pThis->m_nextBits=0;
            for(i=0;i<pThis->m_cbBuflen;i++)
            {
                pThis->m_nextBits<<=8;
                pThis->m_nextBits|=*pThis->m_pBuffer++;
            }
            pThis->m_BMS8.m_wNextBitsSkip=32-(pThis->m_cbBuflen<<3);
                        
            pThis->m_cbBuflen=0;   
        }
    }
    else
    {
        int i;
        pThis->m_currBits=0;
        for(i=0;i<pThis->m_cbBuflen;i++)
        {
            pThis->m_currBits<<=8;
            pThis->m_currBits|=*pThis->m_pBuffer++;
        }
        pThis->m_BMS8.m_wBitsLeft=(pThis->m_cbBuflen<<3);

        pThis->m_BMS8.m_wNextBitsSkip=32;
                        
        pThis->m_cbBuflen=0;   


    }


#else
    pThis->m_fStreamStaus = VALID;
    pThis->m_dwDot = 0;
    pThis->m_dwBitsLeft = 0;
#endif
    
#ifdef __STREAMING_MODE_DECODE_
    pThis->m_bNotEndOfFrame = bNotEndOfFrame;
#endif
}

U32_WMV BS_peekBitsTillByteAlign (CInputBitStream_WMV * pThis, I32_WMV& nBitsToPeek)
{
#ifdef OPT_HUFFMAN_GET_WMV
    register U32_WMV uiBitsLeftMode8 = ((U8_WMV)pThis->m_BMS8.m_wBitsLeft) % 8u;
#else
    register U32_WMV uiBitsLeftMode8 = pThis->m_dwBitsLeft % 8u;
#endif
    nBitsToPeek = (uiBitsLeftMode8 == 0) ? 8 : uiBitsLeftMode8;
    return BS_peekBits(pThis, nBitsToPeek);
}

#ifdef OPT_HUFFMAN_GET_WMV
U32_WMV BS_peekBits2 (CInputBitStream_WMV * pThis, const U32_WMV numBits)
{
#ifndef _CASIO_VIDEO_
    assert (numBits <= 32);
#endif

    I32_WMV tmp_dwBitsLeft;

    BS_updateCurrNext(pThis);

    if ((tmp_dwBitsLeft=(pThis->m_BMS8.m_wBitsLeft-numBits))>=0) 
    {
            // result= (m_currBits >> tmp_dwBitsLeft) & GetMask[numBits];
            return (pThis->m_currBits >> tmp_dwBitsLeft) & (((U32_WMV)0xffffffff)>>(32-numBits));
    }
        
    return  (pThis->m_currBits << (-tmp_dwBitsLeft)) & (((U32_WMV)0xffffffff)>>(32-numBits));

}
#else
U32_WMV BS_finalLoadPeek(
    CInputBitStream_WMV * pThis,
    U32_WMV              dwRetval,
    U32_WMV              dwBitsToAdd);

U32_WMV BS_peekBits (CInputBitStream_WMV * pThis, const U32_WMV numBits)
{
#ifndef _CASIO_VIDEO_
    assert (numBits <= 32);
#endif
    int result;

    U32_WMV iBitsToRet;

    if (pThis->m_fStreamStaus == VALID && ((U32_WMV) (pThis->m_dwBitsLeft + (pThis->m_cbBuflen << 3)) >= numBits)) {
        if (numBits <= pThis->m_dwBitsLeft)
            iBitsToRet = (pThis->m_dwDot >> (pThis->m_dwBitsLeft-numBits)) & GetMask_WMV[numBits];
        else {
            U32_WMV nBitsToPeek = numBits - pThis->m_dwBitsLeft;
            iBitsToRet = (pThis->m_dwDot) & GetMask_WMV[pThis->m_dwBitsLeft];
         
            if (pThis->m_cbBuflen >= 4) { // assume always true  for MPEG4-compliance
                register U32_WMV     dwAcc;

                dwAcc = (U32_WMV)pThis->m_pBuffer[3];
                dwAcc |= (U32_WMV)(pThis->m_pBuffer[2]) << 8;
                dwAcc |= (U32_WMV)(pThis->m_pBuffer[1]) << 16;
                dwAcc |= (U32_WMV)(pThis->m_pBuffer[0]) << 24;
                U32_WMV dwDotTmp = dwAcc;
                iBitsToRet = (iBitsToRet << nBitsToPeek) | ((dwDotTmp >> (32 - nBitsToPeek)) & GetMask_WMV[nBitsToPeek]);
                HUFFMANGET_DBG_DMP(iBitsToRet,0,0,0);
                return iBitsToRet;
            }
            result= BS_finalLoadPeek (pThis, iBitsToRet, nBitsToPeek);
            HUFFMANGET_DBG_DMP(result,0,0,0);
            return result;
        }
    }
    else {
        HUFFMANGET_DBG_DMP(0,0,0,0);
        return 0;
    }
    HUFFMANGET_DBG_DMP(iBitsToRet,0,0,0);
    return iBitsToRet;

}
#endif

U32_WMV  BS_peekBitsFromByteAlign(CInputBitStream_WMV * pThis, I32_WMV nBitsToPeek)
{
#ifdef OPT_HUFFMAN_GET_WMV
    Bool_WMV bAligned = ((((U8_WMV)pThis->m_BMS8.m_wBitsLeft) % 8u)==0);
    I32_WMV iBitsToPeek;
    if(bAligned)
        iBitsToPeek = nBitsToPeek + 8;
    else
        iBitsToPeek = nBitsToPeek + (((U8_WMV)pThis->m_BMS8.m_wBitsLeft) % 8u);
    U32_WMV nBitsRet = BS_peekBits(pThis, iBitsToPeek);
#else
    Bool_WMV bAligned = ((pThis->m_dwBitsLeft % 8)==0);
    I32_WMV iBitsToPeek;
    if(bAligned)
        iBitsToPeek = nBitsToPeek + 8;
    else
        iBitsToPeek = nBitsToPeek + (pThis->m_dwBitsLeft % 8u);
    U32_WMV nBitsRet = BS_peekBits(pThis, iBitsToPeek);
#endif
#ifdef OPT_HUFFMAN_GET_WMV
    return (nBitsRet & (((U32_WMV)0xffffffff)>>(32-nBitsToPeek)));
#else
    return (nBitsRet & GetMask_WMV[nBitsToPeek]);
#endif
}

#ifndef OPT_HUFFMAN_GET_WMV
U32_WMV BS_finalLoadPeek(
    CInputBitStream_WMV * pThis,
    U32_WMV              dwRetval,
    U32_WMV              dwBitsToAdd)
{
    U32_WMV              dwPosition = 4;

    U32_WMV dwDot = 0;
    U32_WMV dwBitsLeft = 0;
    I32_WMV cbBuflen = pThis->m_cbBuflen;
    U8_WMV *pBuffer = pThis->m_pBuffer;

    for (; cbBuflen;) {
        dwDot <<= 8;
        dwDot |= *pBuffer++;
        --cbBuflen;
        dwBitsLeft += 8;
    }

    dwRetval <<= dwBitsToAdd;
    dwRetval |= (dwDot >> (dwBitsLeft - dwBitsToAdd)) & GetMask_WMV[dwBitsToAdd];
    dwBitsLeft -= dwBitsToAdd;
    return dwRetval;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\wmaos.c ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    WmaOS.c

Abstract:

    Functions that should work under any generic OS.

Author:

    Raymond Cheng (raych)       September 27, 1999

Revision History:


*************************************************************************/

#include "bldsetup.h"

#include "msaudio.h"
#include "macros.h"
#include "AutoProfile.h"
#include <stdio.h>
#if defined(_DEBUG) && defined(WMA_MONITOR)
#	include <math.h>
#endif
#if defined(HEAP_DEBUG_TEST) && defined(_DEBUG)
#include <malloc.h>
#endif
#if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
#include <stdarg.h>
#endif

#ifndef PLATFORM_SPECIFIC_PERFTIMER

#include <time.h>

typedef struct tagPERFTIMERINFO
{
    int     fFirstTime;         // Used to record total time spent in decode loop
    clock_t cDecodeTime;        // Time spent decoding only (running total)
    clock_t cTotalDecLoopTime;  // Total time spent in decode loop
    clock_t cDecodeStart;       // Could be easily optimized out but it's not worth it
    long    lSamplesPerSec;     // Samples per second, counting all channels
    long    lPlaybackTime;      // Time required for playback (running total)
} PERFTIMERINFO;

PERFTIMERINFO *PerfTimerNew(long lSamplesPerSecOutput)
{
    PERFTIMERINFO  *pInfo;

    pInfo = (PERFTIMERINFO*)(wmvalloc(sizeof(PERFTIMERINFO)));
    if (NULL == pInfo)
        return NULL;

    pInfo->fFirstTime = WMAB_TRUE;
    pInfo->cDecodeTime = 0;
    pInfo->cTotalDecLoopTime = 0;
    pInfo->cDecodeStart = 0;
    pInfo->lSamplesPerSec = lSamplesPerSecOutput;
    pInfo->lPlaybackTime = 0;

    return pInfo;
}

void PerfTimerStart(PERFTIMERINFO *pInfo)
{
    pInfo->cDecodeStart = clock();

    if (pInfo->fFirstTime)
    {
        pInfo->cTotalDecLoopTime = pInfo->cDecodeStart;
        pInfo->fFirstTime = WMAB_FALSE;
    }
}

void PerfTimerStop(PERFTIMERINFO *pInfo, long lSamplesDecoded)
{
    clock_t cDecodeTime;

    cDecodeTime = clock() - pInfo->cDecodeStart;
    pInfo->cDecodeTime += cDecodeTime;

    // Record output playback time from this decode call, in clock() ticks
    pInfo->lPlaybackTime += lSamplesDecoded * CLOCKS_PER_SEC / pInfo->lSamplesPerSec;
}

void PerfTimerStopElapsed(PERFTIMERINFO *pInfo)
{
    pInfo->cTotalDecLoopTime = clock() - pInfo->cTotalDecLoopTime;
}

void PerfTimerReport(PERFTIMERINFO *pInfo)
{
    char    sz[256];
    float   fltDecodeTime;
    float   fltEntireDecodeTime;
    float   fltDecodeTimeFraction;
    float   fltPlaybackTime;

    sprintf(sz, "\n\n** Ticks per second (clock resolution): %ld.\n", CLOCKS_PER_SEC);
    OUTPUT_DEBUG_STRING(sz);

    fltDecodeTime = (float) pInfo->cDecodeTime / (float) CLOCKS_PER_SEC;
    fltEntireDecodeTime = (float) pInfo->cTotalDecLoopTime /
        (float) CLOCKS_PER_SEC;
    sprintf(sz, "** Decode time: %f sec. Entire decode time: %f sec.\n",
        fltDecodeTime, fltEntireDecodeTime);
    OUTPUT_DEBUG_STRING(sz);

    fltPlaybackTime = (float) pInfo->lPlaybackTime / (float) CLOCKS_PER_SEC;
    sprintf(sz, "** Playback time : %f sec.\n",
        fltPlaybackTime);
    OUTPUT_DEBUG_STRING(sz);

    fltDecodeTimeFraction = (float)pInfo->cDecodeTime / (float) pInfo->lPlaybackTime;
    sprintf(sz, "** Percentage of playback time spent decoding: %f%%.\n",
        fltDecodeTimeFraction * 100);
    OUTPUT_DEBUG_STRING(sz);
#	if defined(WMA_MONITOR)
		fprintf(stderr,"%s\n",sz);
#	endif

    sprintf(sz, "** Minimum MHz for realtime playback: %f of current CPU speed.\n",
        fltDecodeTimeFraction);
    OUTPUT_DEBUG_STRING(sz);

    sprintf(sz, "** This CPU is %f times faster than required.\n\n",
        (float)1.0 / fltDecodeTimeFraction);
    OUTPUT_DEBUG_STRING(sz);

}

float fltPerfTimerDecodeTime(PERFTIMERINFO *pInfo)
{
    return (float) pInfo->cDecodeTime / (float) CLOCKS_PER_SEC;
}

void PerfTimerFree(PERFTIMERINFO *pInfo)
{
    wmvfree(pInfo);
}

#endif  // PLATFORM_SPECIFIC_PERFTIMER


#if !defined(PLATFORM_SPECIFIC_DEBUGINFRASTRUCTURE) && defined(_DEBUG)
#include <stdarg.h>
void TraceInfoHelper(const char *pszFile, int iLine, const char *pszFmt, ...)
{
    char    sz[512];
    va_list vargs;
    Int     iCharsWritten;

    // Prepend file/line identifier and "*** INFO ***" to get attention
    iCharsWritten = sprintf(sz, "%s(%d) : *** INFO *** ", pszFile, iLine);

    va_start(vargs, pszFmt);
    iCharsWritten += vsprintf(sz + iCharsWritten, pszFmt, vargs);
    va_end(vargs);

    // Append a newline and print it!
    sprintf(sz + iCharsWritten, "\n");
    OUTPUT_DEBUG_STRING(sz);
}

WMARESULT MyOutputDbgStr(WMARESULT wmaReturn, const char *pszFmt, ...)
{
    char    sz[512];
    va_list vargs;

    va_start(vargs, pszFmt);
    vsprintf(sz, pszFmt, vargs);
    va_end(vargs);

    OUTPUT_DEBUG_STRING(sz);
    return wmaReturn;
}
#endif  // !!defined(PLATFORM_SPECIFIC_DEBUGINFRASTRUCTURE) && defined(_DEBUG)



#if defined(_DEBUG) && defined(WMA_MONITOR)

#define DECL_MONITOR_RANGE(a) extern double a[4] = { 1.0e30, -1.0e30, 0, 0 };  extern long lc##a = 0;

// declare and define some range monitors in _DEBUG mode when WMA_MONITOR is defined
DECL_MONITOR_RANGE(gMR_iQuantStepSize)
DECL_MONITOR_RANGE(gMR_qstQuantStep)
DECL_MONITOR_RANGE(gMR_iCoefQ);
DECL_MONITOR_RANGE(gMC_0CoefQ);
DECL_MONITOR_RANGE(gMR_rgiMaskQ)
DECL_MONITOR_RANGE(gMR_rgiNoisePower)				// only for LowRate and MidRate
DECL_MONITOR_RANGE(gMR_rgiLspFreqQ)					// only for LowRate, e.g. LPC
DECL_MONITOR_RANGE(gMR_rgfltLspFreq)				// only for LowRate, e.g. LPC
DECL_MONITOR_RANGE(gMR_fltLPC_F)					// only for LowRate, e.g. LPC
DECL_MONITOR_RANGE(gMR_fltLPC_F1)					// only for LowRate, e.g. LPC
DECL_MONITOR_RANGE(gMR_fltLPC_F2)					// only for LowRate, e.g. LPC
DECL_MONITOR_RANGE(gMR_fltLPC_F3)					// only for LowRate, e.g. LPC
DECL_MONITOR_RANGE(gMR_rgfltWeightFactor)
DECL_MONITOR_RANGE(gMR_WeightRatio)
DECL_MONITOR_RANGE(gMR_rgfltBandWeight)				// only for MidRate and LowRate
DECL_MONITOR_RANGE(gMR_rgffltSqrtBWRatio)
DECL_MONITOR_RANGE(gMR_CoefRecon)
DECL_MONITOR_RANGE(gMC_zeroCoefRecon)
DECL_MONITOR_RANGE(gMR_DCTCoefIntoFFT)
DECL_MONITOR_RANGE(gMR_DCTCoefOut)
DECL_MONITOR_RANGE(gMC_ScalePowerToRMS)
DECL_MONITOR_RANGE(gMC_ScaleInverseQuadRoot)
DECL_MONITOR_RANGE(gMC_IQ)
//DECL_MONITOR_RANGE(gMC_IQ_iFractionBitsQuantStep)
DECL_MONITOR_RANGE(gMC_IQ_cQSIMWFracBits)
DECL_MONITOR_RANGE(gMR_QuantStepXInvMaxWeight)
DECL_MONITOR_RANGE(gMR_QuantStepXMaxWeightXWeightFactor)
DECL_MONITOR_RANGE(gMC_IQ_cWFFracBits)
DECL_MONITOR_RANGE(gMR_weightFactor)
DECL_MONITOR_RANGE(gMC_IQ_scale)
DECL_MONITOR_RANGE(gMC_IQ_scale2)
DECL_MONITOR_RANGE(gMC_IQ_Float)
DECL_MONITOR_RANGE(gMC_IQ_fltNoisePowCount)
DECL_MONITOR_RANGE(gMC_GBW_floats)

#if defined(WMA_MONITOR_FILE)
#	if defined(OUTPUT_DEBUG_STRING)
#		undef DUMP_MONITOR_RANGE
#		define DUMP_MONITOR_RANGE(a) if (lc##a>0) { sprintf(sz,"%14.6g %14.6g %14.6g %14.6g %8ld " #a "\n", a[0], a[1], a[2]/lc##a, sqrt((lc##a*a[3]-a[2]*a[2])/(((double)lc##a)*(lc##a-1))), lc##a ); OUTPUT_DEBUG_STRING(sz); }
#	else
#		undef DUMP_MONITOR_RANGE
#		define DUMP_MONITOR_RANGE(a) if (lc##a>0) fprintf(fp,"%14.6g %14.6g %14.6g %14.6g %8ld " #a "\n", a[0], a[1], a[2]/lc##a, sqrt((lc##a*a[3]-a[2]*a[2])/(((double)lc##a)*(lc##a-1))), lc##a );
#	endif
#endif

void DumpMonitorRanges(int fAppend) {
	FILE* fp = NULL;
#	if defined(WMA_MONITOR_FILE)
#		if defined(OUTPUT_DEBUG_STRING)
			char sz[256];
			int bODX = 0;
			if ( stricmp(WMA_MONITOR_FILE,"OutputDebugString")
				bODS = 1;
			else 
#		endif	// defined(OUTPUT_DEBUG_STRING)
		if ( stricmp(WMA_MONITOR_FILE,"stdout")
			fp = stdout;
		else
			fp = fopen(WMA_MONITOR_FILE,fAppend ? "w+" : "w");
#	else
		fp = stdout;
#	endif		

#	if defined(OUTPUT_DEBUG_STRING)
		if ( bODX )
			OUTPUT_DEBUG_STRING("\n       Minimum        Maximum           Mean StandDeviation    Count Variable\n");
		else
#	endif
		fprintf(fp,"\n       Minimum        Maximum           Mean StandDeviation    Count Variable\n");

	DUMP_MONITOR_RANGE(gMR_iQuantStepSize);
	DUMP_MONITOR_RANGE(gMR_qstQuantStep);
	DUMP_MONITOR_RANGE(gMR_iCoefQ);
	DUMP_MONITOR_RANGE(gMC_0CoefQ);
	DUMP_MONITOR_RANGE(gMR_rgiMaskQ);
#	ifdef ENABLE_LPC
		DUMP_MONITOR_RANGE(gMR_rgiLspFreqQ);
#		ifndef BUILD_INTEGER
			DUMP_MONITOR_RANGE(gMR_rgfltLspFreq);
#		endif
		DUMP_MONITOR_RANGE(gMR_fltLPC_F1);
		DUMP_MONITOR_RANGE(gMR_fltLPC_F2);
		DUMP_MONITOR_RANGE(gMR_fltLPC_F3);
#	endif
	DUMP_MONITOR_RANGE(gMR_rgiNoisePower);
	DUMP_MONITOR_RANGE(gMR_rgfltWeightFactor);
	DUMP_MONITOR_RANGE(gMR_WeightRatio);
	DUMP_MONITOR_RANGE(gMR_rgfltBandWeight);
	DUMP_MONITOR_RANGE(gMR_rgffltSqrtBWRatio);
	DUMP_MONITOR_RANGE(gMR_CoefRecon);
	DUMP_MONITOR_RANGE(gMC_zeroCoefRecon);
	DUMP_MONITOR_RANGE(gMR_DCTCoefIntoFFT);
	DUMP_MONITOR_RANGE(gMR_DCTCoefOut);
	DUMP_MONITOR_RANGE(gMR_QuantStepXInvMaxWeight);
	DUMP_MONITOR_RANGE(gMR_QuantStepXMaxWeightXWeightFactor);

	DUMP_MONITOR_RANGE(gMR_weightFactor);

	DUMP_MONITOR_RANGE(gMC_ScalePowerToRMS);
	DUMP_MONITOR_RANGE(gMC_ScaleInverseQuadRoot);
	DUMP_MONITOR_RANGE(gMC_IQ);
	//DUMP_MONITOR_RANGE(gMC_IQ_iFractionBitsQuantStep);
	DUMP_MONITOR_RANGE(gMC_IQ_cQSIMWFracBits);
	DUMP_MONITOR_RANGE(gMC_IQ_cWFFracBits);
	DUMP_MONITOR_RANGE(gMC_IQ_scale);
	DUMP_MONITOR_RANGE(gMC_IQ_scale2);
	DUMP_MONITOR_RANGE(gMC_IQ_Float);
	DUMP_MONITOR_RANGE(gMC_IQ_fltNoisePowCount);
	DUMP_MONITOR_RANGE(gMC_GBW_floats);
	if ( fp != NULL && fp != stdout )
		fclose(fp);
}
#	pragma COMPILER_MESSAGE(__FILE__ "(302) : Warning - WMA_MONITOR Debug Code Enabled.")
#endif


#if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)

static FILE* fileShowFrames = NULL;

void prvWmaShowFrames(CAudioObject* pau, const char* pszID, const char* pszFmt, ...) {
#ifdef UNDER_CE
    if ( fileShowFrames == NULL )
        fileShowFrames = fopen("ShowFrames.txt","wt");
    if ( fileShowFrames == NULL )
        return;
#else
	fileShowFrames = stderr;
#endif
    fprintf(fileShowFrames,"%7s %3d.%d [%4d %4d %4d]",
        pszID,
        pau->m_iFrameNumber,
        pau->m_iCurrSubFrame,
        pau->m_cFrameSampleAdjusted,
        pau->m_cSubFrameSampleAdjusted,
        pau->m_cSubbandAdjusted
    );
    if ( pszFmt != NULL )
    {
        char    sz[512];
        va_list vargs;

        va_start(vargs, pszFmt);
        vsprintf(sz, pszFmt, vargs);
        va_end(vargs);

        fprintf(fileShowFrames,"%s",sz);
    }
    fprintf(fileShowFrames,"\n" );
}

#	pragma COMPILER_MESSAGE(__FILE__ "(341) : Warning - SHOW_FRAMES Debug Code Enabled.")
#endif

#if defined(BUILD_INT_FLOAT) && ( defined(WMA_TARGET_SH3) || defined(WMA_TARGET_MIPS) )
#	pragma COMPILER_MESSAGE(__FILE__ "(345) : Warning - Integer Float Build.")
#endif
#ifdef PROFILE
#	pragma COMPILER_MESSAGE(__FILE__ "(348) : Warning - PROFILE Enabled.")
#endif
#if defined(SDE_WANTS_ASSERTS) && defined(_DEBUG)
#	pragma COMPILER_MESSAGE(__FILE__ "(351) : Warning - Asserts are enabled - for SDE use only!")
#endif

#if defined(HEAP_DEBUG_TEST) && defined(_DEBUG)
// check the heap - see macros in msaudio.h
// _heapchk does not seem to be available under WinCE
void HeapDebugCheck()
	{ int  heapstatus;
	   /* Check heap status */
	   heapstatus = _heapchk();
	   switch( heapstatus )
	   {
	   case _HEAPOK:
		  //printf(" OK - heap is fine\n" );
		  break;
	   case _HEAPEMPTY:
		  printf(" OK - heap is empty\n" );
		  break;
	   case _HEAPBADBEGIN:
		  printf( "ERROR - bad start of heap\n" );
		  break;
	   case _HEAPBADNODE:
		  printf( "ERROR - bad node in heap\n" );
		  break;
	   }
	}
#endif

#ifdef UNDER_CE
// se need to define at least one public symbol
extern void wmaos_pacify(void) {}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\wavfileio.c ===
/* -------------------------------------------------------------------------
 *
 *  Microsoft Windows Media
 *
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:       wavfileio.c
 *
 * ---------------------------------------------------------------------- */

#include "bldsetup.h"

#include <stdlib.h>
#include <memory.h>
#include "wavfileio.h"

#if defined(UNDER_CE) && defined(WIN32_PLATFORM_PSPC)
	// Palm-size PC 2.11 needs this, H/PC Pro 2.11 does not
#   pragma warning( disable : 4273 )
	FILE *fopen( const char *filename, const char *mode );
	int fseek( FILE *stream, long offset, int origin );
	size_t fread( void *buffer, size_t size, size_t count, FILE *stream );
	size_t fwrite( const void *buffer, size_t size, size_t count, FILE *stream );
	int fclose( FILE *stream );
	int ferror( FILE *stream );
	int fflush( FILE *stream );
#endif // UNDER_CE

#ifndef mmioFOURCC
#  if WFIO_LITTLE_ENDIAN
#    define mmioFOURCC(ch0, ch1, ch2, ch3)  ((U32)(U8)(ch0)|((U32)(U8)(ch1)<<8)|((U32)(U8)(ch2)<<16)|((U32)(U8)(ch3)<<24))
#  else  /* WFIO_LITTLE_ENDIAN */
#    define mmioFOURCC(ch0, ch1, ch2, ch3)  ((U32)(U8)(ch3)|((U32)(U8)(ch2)<<8)|((U32)(U8)(ch1)<<16)|((U32)(U8)(ch0)<<24))
#  endif /* WFIO_LITTLE_ENDIAN */
#endif /* mmioFOURCC */

#define WFIO_FOURCC_RIFF    mmioFOURCC('R', 'I', 'F', 'F')
#define WFIO_FOURCC_WAVE    mmioFOURCC('W', 'A', 'V', 'E')
#define WFIO_FOURCC_fmt     mmioFOURCC('f', 'm', 't', ' ')
#define WFIO_FOURCC_data    mmioFOURCC('d', 'a', 't', 'a')
#define WFIO_FOURCC_fact    mmioFOURCC('f', 'a', 'c', 't')

/* forward declarations */
static I32 wfioReadHeaders(WavFileIO *pwfio);
static I32 wfioWriteHeaders(WavFileIO *pwfio, WAVEFORMATEX *pFormat, U32 cbFormat);
static I32 wfioCleanUpRead(WavFileIO *pwfio);
static I32 wfioCleanUpWrite(WavFileIO *pwfio);


/* utility functions */

U16
adjustByteOrder16(U16 val)
{
#if WFIO_LITTLE_ENDIAN
    return val;
#else  /* WFIO_LITTLE_ENDIAN */
    U8 *p = (U8 *)&val;
    return ((U16)p[0])|((U16)p[1]<<8);
#endif /* WFIO_LITTLE_ENDIAN */
}

U32
adjustByteOrder32(U32 val)
{
#if WFIO_LITTLE_ENDIAN
    return val;
#else  /* WFIO_LITTLE_ENDIAN */
    U8 *p = (U8 *)&val;
    return ((U32)p[0])|((U32)p[1]<<8)|((U32)p[2]<<16)|((U32)p[3]<<24);
#endif /* WFIO_LITTLE_ENDIAN */
}


WavFileIO *
wfioNew()
{
    WavFileIO *pwfio = (WavFileIO *)wmvalloc(sizeof(WavFileIO));
    if(pwfio == NULL)
        return NULL;

    pwfio->m_mode = wfioModeRead;
#if WFIO_NO_WIN32
    pwfio->m_fpWav = NULL;
    pwfio->m_posRiffLength = 0;
    pwfio->m_posDataLength = 0;
#else   /* WFIO_NO_WIN32 */
    pwfio->m_hmmio = NULL;
#endif  /* WFIO_NO_WIN32 */
    pwfio->m_pFormat = NULL;
    pwfio->m_sizeFormat = 0;
    pwfio->m_sizeData = 0;
    pwfio->m_posDataStart = 0;

#if !WFIO_NO_WIN32
    memset(&pwfio->m_mmioinfo, 0, sizeof(pwfio->m_mmioinfo));
    memset(&pwfio->m_ckWave, 0, sizeof(pwfio->m_ckWave));
    memset(&pwfio->m_ck, 0, sizeof(pwfio->m_ck));
#endif  /* WFIO_NO_WIN32 */

    return pwfio;
}


void
wfioDelete(WavFileIO *pwfio)
{
    wfioClose(pwfio);
    wmvfree(pwfio);
}


I32
wfioOpen(WavFileIO *pwfio,
         const char *szFile,
         WAVEFORMATEX *pFormat,
         U32 cbFormat,
         I32 mode)
{
    I32 lr;

    if(pwfio == NULL)
        return MMSYSERR_ERROR;

#if WFIO_NO_WIN32

    if(pwfio->m_fpWav)
        return MMSYSERR_ERROR;

    pwfio->m_mode = mode;

    if(pwfio->m_mode == wfioModeWrite)
    {
        /* open the file for writing */
        pwfio->m_fpWav = fopen(szFile, "wb");
        if(pwfio->m_fpWav == NULL)
        {
            lr = MMSYSERR_ERROR;
            goto lerror;
        }

        /* write the header info */
        lr = wfioWriteHeaders(pwfio, pFormat, cbFormat);
        if(lr != MMSYSERR_NOERROR)
            goto lerror;
    }
    else
    {
        /* open the file for reading */
        pwfio->m_fpWav = fopen(szFile, "rb");
        if(pwfio->m_fpWav == NULL)
        {
            lr = MMSYSERR_ERROR;
            goto lerror;
        }

        /* read the hearder info */
        lr = wfioReadHeaders(pwfio);
        if(lr != MMSYSERR_NOERROR)
            goto lerror;

        /* seek to the beginning */
        wfioSeek(pwfio, 0, SEEK_CUR);
    }

#else  /* WFIO_NO_WIN32 */

    if(pwfio->m_hmmio)
        return MMSYSERR_ERROR;

    pwfio->m_mode = mode;

    /* slightly different for READ and WRITE */
    if(pwfio->m_mode == wfioModeRead)
    {
        /* open the file for read */
        pwfio->m_hmmio = mmioOpen((LPSTR)szFile, NULL, MMIO_READ/*|MMIO_DENYWRITE*/);
        if(pwfio->m_hmmio == NULL)
        {
            lr = MMSYSERR_ERROR;
            goto lerror;
        }

        /* read the header info */
        lr = wfioReadHeaders(pwfio);
        if(lr != MMSYSERR_NOERROR)
            goto lerror;

        /* seek to the beginning */
        wfioSeek(pwfio, 0, SEEK_CUR);
  }
  else
  {
      /* open the file for write */
      pwfio->m_hmmio = mmioOpen((LPSTR)szFile, NULL, MMIO_READWRITE|MMIO_CREATE|MMIO_ALLOCBUF/*|MMIO_DENYWRITE*/);
      if(pwfio->m_hmmio == NULL)
      {
          lr = MMSYSERR_ERROR;
          goto lerror;
      }

      lr = wfioWriteHeaders(pwfio, pFormat, cbFormat);
      if(lr != MMSYSERR_NOERROR)
          goto lerror;
  }

#endif /* WFIO_NO_WIN32 */

  return MMSYSERR_NOERROR;

lerror:
  wfioClose(pwfio);
  return lr;
}


void
wfioClose(WavFileIO *pwfio)
{
    if(pwfio == NULL)
        return;

#if WFIO_NO_WIN32

    if(pwfio->m_fpWav)
    {
        if(pwfio->m_mode == wfioModeWrite)
            wfioCleanUpWrite(pwfio);
        else
            wfioCleanUpRead(pwfio);

        fclose(pwfio->m_fpWav);
        pwfio->m_fpWav = NULL;
    }

    if(pwfio->m_pFormat)
    {
        wmvfree(pwfio->m_pFormat);
        pwfio->m_pFormat = NULL;

        pwfio->m_sizeFormat = 0;
    }

    pwfio->m_sizeData = 0;
    pwfio->m_posDataStart = 0;

    /* just for the safety... */
    pwfio->m_posRiffLength = 0;
    pwfio->m_posDataLength = 0;

#else  /* WFIO_NO_WIN32 */

    if(pwfio->m_hmmio)
    {
        if(pwfio->m_mode == wfioModeWrite)
            wfioCleanUpWrite(pwfio);
        else
            wfioCleanUpRead(pwfio);

        mmioClose(pwfio->m_hmmio, 0);
        pwfio->m_hmmio = NULL;
    }

    if(pwfio->m_pFormat)
    {
        wmvfree(pwfio->m_pFormat);
        pwfio->m_pFormat = NULL;

        pwfio->m_sizeFormat = 0;
    }

    pwfio->m_sizeData = 0;
    pwfio->m_posDataStart = 0;

    /* just for safety... */
    memset(&pwfio->m_mmioinfo, 0, sizeof(pwfio->m_mmioinfo));
    memset(&pwfio->m_ckWave, 0, sizeof(pwfio->m_ckWave));
    memset(&pwfio->m_ck, 0, sizeof(pwfio->m_ck));

#endif /* WFIO_NO_WIN32 */
}


I32
wfioSeek(WavFileIO *pwfio,
         I32 position,
         I32 origin)
{
    if(pwfio == NULL)
        return -1;

    /* only for reading... */
    if(pwfio->m_mode != wfioModeRead)
        return -1;

#if WFIO_NO_WIN32

    switch(origin)
    {
    case SEEK_SET:
        return fseek(pwfio->m_fpWav, pwfio->m_posDataStart + position, SEEK_SET);

    case SEEK_CUR:
        return fseek(pwfio->m_fpWav, position, SEEK_CUR);

    case SEEK_END:
        return fseek(pwfio->m_fpWav, pwfio->m_posDataStart + pwfio->m_sizeData - position, SEEK_SET);
    }

#else  /* WFIO_NO_WIN32 */

    switch(origin)
    {
    case SEEK_SET:
        return mmioSeek(pwfio->m_hmmio, pwfio->m_posDataStart + position, SEEK_SET);

    case SEEK_CUR:
        return mmioSeek(pwfio->m_hmmio, position, SEEK_CUR);

    case SEEK_END:
        return mmioSeek(pwfio->m_hmmio, pwfio->m_posDataStart + pwfio->m_sizeData - position, SEEK_SET);
    }

#endif /* WFIO_NO_WIN32 */

  return -1;
}


I32
wfioRead(WavFileIO *pwfio,
         U8 *pBuf,
         I32 cbBuf)
{
#if WFIO_NO_WIN32

    size_t ret;

    if(pwfio == NULL)
        return (I32)-1;

    if(pwfio->m_fpWav == NULL
       || pwfio->m_mode != wfioModeRead
       || pBuf == NULL)
        return (I32)-1;

    /* in alignment units... */
    cbBuf = (cbBuf/pwfio->m_pFormat->nBlockAlign)*pwfio->m_pFormat->nBlockAlign;

#if !WFIO_LITTLE_ENDIAN

    /* have to swap bytes... */

    if(pwfio->m_pFormat->wBitsPerSample == 16)
    {
        I32 i;
        U16 *p = (U16 *)pBuf;
        for(i = cbBuf/2; i > 0; i--, p++)
            *p = adjustByteOrder16(*p);
    }

#endif  /* WFIO_LITTLE_ENDIAN */

    ret = fread(pBuf, 1, cbBuf, pwfio->m_fpWav);
    if(ferror(pwfio->m_fpWav))
        return (I32)-1;

    return (I32)ret;

#else  /* WFIO_NO_WIN32 */

    if(pwfio == NULL)
        return (I32)-1;

    return mmioRead(pwfio->m_hmmio, (HPSTR)pBuf, cbBuf);

#endif /* WFIO_NO_WIN32 */
}


I32
wfioWrite(WavFileIO *pwfio,
          U8 *pBuf,
          I32 cbBuf)
{
#if WFIO_NO_WIN32

    size_t ret;

    if(pwfio == NULL)
        return (I32)-1;

    if(pwfio->m_fpWav == NULL
       || pwfio->m_mode != wfioModeWrite
       || pBuf == NULL)
        return (I32)-1;

    /* in alignment units... */
    cbBuf = (cbBuf/pwfio->m_pFormat->nBlockAlign)*pwfio->m_pFormat->nBlockAlign;

#if !WFIO_LITTLE_ENDIAN

    /* have to swap bytes... */

    if(pwfio->m_pFormat->wBitsPerSample == 16)
    {
        I32 i;
        U16 *p = (U16 *)pBuf;
        for(i = cbBuf/2; i > 0; i--, p++)
            *p = adjustByteOrder16(*p);
    }

#endif  /* WFIO_LITTLE_ENDIAN */

    ret = fwrite(pBuf, 1, cbBuf, pwfio->m_fpWav);
    if(ferror(pwfio->m_fpWav))
        return (I32)-1;

    pwfio->m_sizeData += ret;

    return ret;

#else  /* WFIO_NO_WIN32 */

    /* buffered write (MMIO_ALLOCBUF used for opening) */

    I32 lr;
    I32 cbBlock;
    I32 cbWritten = 0;

    if(pwfio == NULL)
        return (I32)-1;

    if(pBuf == NULL)
        return 0;

    while(cbBuf > 0)
    {
        /* check if we need to advance to the next buffer */
        if(pwfio->m_mmioinfo.pchNext == pwfio->m_mmioinfo.pchEndWrite)
        {
            pwfio->m_mmioinfo.dwFlags |= MMIO_DIRTY;
            lr = mmioAdvance(pwfio->m_hmmio, &pwfio->m_mmioinfo, MMIO_WRITE);
            if(lr != MMSYSERR_NOERROR)
                goto lerror;
        }

        /* copy in blocks */
        cbBlock = pwfio->m_mmioinfo.pchEndWrite - pwfio->m_mmioinfo.pchNext;
        if(cbBlock > cbBuf)
            cbBlock = cbBuf;
        CopyMemory(pwfio->m_mmioinfo.pchNext, pBuf, cbBlock);

        /* update pointers and counters */
        pBuf                      += cbBlock;
        pwfio->m_mmioinfo.pchNext += cbBlock;
        cbWritten                 += cbBlock;
        cbBuf                     -= cbBlock;

        /* update global stat members */
        pwfio->m_sizeData += cbBlock;
    }

lerror:
    return cbWritten;

#endif /* WFIO_NO_WIN32 */
}


WAVEFORMATEX *
wfioGetFormat(WavFileIO *pwfio)
{
    if(pwfio == NULL)
        return NULL;

    return pwfio->m_pFormat;
}


U32
wfioGetFormatLength(WavFileIO *pwfio)
{
    if(pwfio == NULL || pwfio->m_pFormat == NULL)
        return 0;

    return sizeof(WAVEFORMATEX) + pwfio->m_pFormat->cbSize;
}


U32
wfioGetSampleSize(WavFileIO *pwfio)
{
    if(pwfio == NULL || pwfio->m_pFormat == NULL)
        return 0;

    return pwfio->m_pFormat->nBlockAlign;
}


U32
wfioGetDataLength(WavFileIO *pwfio)
{
    if(pwfio == NULL)
        return 0;

    return pwfio->m_sizeData;
}


I32
wfioGetMode(WavFileIO *pwfio)
{
    if(pwfio == NULL)
        return 0;

    return pwfio->m_mode;
}


I32
wfioIsOpened(WavFileIO *pwfio)
{
#if WFIO_NO_WIN32
    return pwfio && pwfio->m_fpWav != NULL;
#else   /* WFIO_NO_WIN32 */
    return pwfio && pwfio->m_hmmio != NULL;
#endif  /* WFIO_NO_WIN32 */
}


I32
wfioReadHeaders(WavFileIO *pwfio)
{
    I32 lr;
    Bool fFmtChunkFound  = WMAB_FALSE;  
    Bool fDataChunkFound = WMAB_FALSE;
    
#if WFIO_NO_WIN32
    
    size_t ret;
    size_t offset = 0;
    size_t offSeek;
    
    U32 dwTemp;
    U32 dwSize;
    U32 dwHead;
    
    if(pwfio == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    
    if(pwfio->m_fpWav == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    
    /* -----------------------------------------------------------------------
    * find the RIFF/WAVE chunk
    */
    
    /* read "RIFF" */
    
    ret = fread(&dwHead, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_READERROR;
        goto lerror;
    }
    offset += ret;
    
    if(dwHead != WFIO_FOURCC_RIFF)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    
    /* read "RIFF" length */
    
    pwfio->m_posRiffLength = offset;
    
    ret = fread(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_READERROR;
        goto lerror;
    }
    offset += ret;
    dwSize = adjustByteOrder32(dwTemp); //Ignored
    
    /* read "WAVE" */
    
    ret = fread(&dwHead, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_READERROR;
        goto lerror;
    }
    offset += ret;
    
    if(dwHead != WFIO_FOURCC_WAVE)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    
    offSeek = offset;
    
    /* -----------------------------------------------------------------------
    * find the FMT chunk: skip over unknown chunks
    */
    
    /* read "fmt " */
    fFmtChunkFound = WMAB_FALSE;  
    do {
        // Read chunk header
        ret = fread(&dwHead, 1, sizeof(U32), pwfio->m_fpWav);
        if(ret != sizeof(U32))
        {
            lr = MMSYSERR_READERROR;
            goto lerror;
        }
        offset += ret;
        
        if(dwHead == WFIO_FOURCC_fmt)
            fFmtChunkFound = WMAB_TRUE;
        
        /* read chunk length */
        ret = fread(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
        if(ret != sizeof(U32))
        {
            lr = MMSYSERR_READERROR;
            goto lerror;
        }
        offset += ret;
        
        dwSize = adjustByteOrder32(dwTemp);
        if (!fFmtChunkFound) {
            /* read-off dwSize bytes */
            offset += dwSize;
            ret = fseek(pwfio->m_fpWav, offset, SEEK_SET);
            if ( ret ) {
                lr = MMSYSERR_READERROR;
                goto lerror;
            } 
        }  
    } while (!fFmtChunkFound);
    
    /* "fmt " length was read earlier */
    /* prepare the format buffer */
    
    pwfio->m_sizeFormat = dwSize;
    if(pwfio->m_sizeFormat < sizeof(WAVEFORMATEX))
        pwfio->m_sizeFormat = sizeof(WAVEFORMATEX);
    
    pwfio->m_pFormat = (WAVEFORMATEX *)wmvalloc(pwfio->m_sizeFormat);
    if(pwfio->m_pFormat == NULL)
    {
        lr = MMSYSERR_NOMEM;
        goto lerror;
    }
    memset(pwfio->m_pFormat, 0, pwfio->m_sizeFormat);
    
    /* read the format chunk */
    
    ret = fread(pwfio->m_pFormat, 1, dwSize, pwfio->m_fpWav);
    if(ret != dwSize)
    {
        lr = MMSYSERR_READERROR;
        goto lerror;
    }
    offset += ret;
    
    /* HongCho: I can convert the fields into the correct order here,
    *          but since I don't know the layouts of all the possible
    *          formats, only the fields in WAVEFORMATEX will be
    *          converted.
    */
    
    pwfio->m_pFormat->wFormatTag      = adjustByteOrder16(pwfio->m_pFormat->wFormatTag);
    pwfio->m_pFormat->nChannels       = adjustByteOrder16(pwfio->m_pFormat->nChannels);
    pwfio->m_pFormat->nSamplesPerSec  = adjustByteOrder32(pwfio->m_pFormat->nSamplesPerSec);
    pwfio->m_pFormat->nAvgBytesPerSec = adjustByteOrder32(pwfio->m_pFormat->nAvgBytesPerSec);
    pwfio->m_pFormat->nBlockAlign     = adjustByteOrder16(pwfio->m_pFormat->nBlockAlign);
    pwfio->m_pFormat->wBitsPerSample  = adjustByteOrder16(pwfio->m_pFormat->wBitsPerSample);
    pwfio->m_pFormat->cbSize          = adjustByteOrder16(pwfio->m_pFormat->cbSize);
    
#if !WFIO_LITTLE_ENDIAN
    /* only PCM for big-endian platforms */
    if(pwfio->m_pFormat->wFormatTag != WAVE_FORMAT_PCM)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
#endif /* WFIO_LITTLE_ENDIAN */
    
    /* the format chunk for PCM on WAVE files are WAVEFORMAT */
    if(pwfio->m_pFormat->wFormatTag == WAVE_FORMAT_PCM)
        pwfio->m_pFormat->cbSize = 0;
    
        /* -----------------------------------------------------------------------
        * find the DATA chunk: skip over other unknown chunks
    */
    fDataChunkFound = WMAB_FALSE;
    
    do {  
        /* Read Chunk Header */
        ret = fread(&dwHead, 1, sizeof(U32), pwfio->m_fpWav);
        if(ret != sizeof(U32))
        {
            lr = MMSYSERR_READERROR;
            goto lerror;
        }
        offset += ret;
        
        fDataChunkFound = (dwHead == WFIO_FOURCC_data);
        
        if (!fDataChunkFound)
        {
            /* Read chunk length */
            ret = fread(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
            if(ret != sizeof(U32))
            {
                lr = MMSYSERR_READERROR;
                goto lerror;
            }
            offset += ret;
            
            dwSize = adjustByteOrder32(dwTemp);
            offset += dwSize;
            
            // Unknown/ un-needed chunk. Skip over it.
            /* read-off dwSize bytes */
            ret = fseek(pwfio->m_fpWav, offset, SEEK_SET);
            if ( ret) {
                lr = MMSYSERR_READERROR;
                goto lerror;
            }
        }
    } while (!fDataChunkFound);
    
    /* read "data" length */
    
    pwfio->m_posDataLength = offset;
    
    ret = fread(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_READERROR;
        goto lerror;
    }
    offset += ret;
    
    pwfio->m_sizeData   = adjustByteOrder32(dwTemp);
    
    pwfio->m_posDataStart = offset;
    
#else  /* WFIO_NO_WIN32 */
    
    MMCKINFO ck;
    
    U32 cksize;
    
    if(pwfio == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    
    if(pwfio->m_hmmio == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    
    /* find the wave info chunk */
    pwfio->m_ckWave.fccType = WFIO_FOURCC_WAVE;
    lr = mmioDescend(pwfio->m_hmmio, &pwfio->m_ckWave, NULL, MMIO_FINDRIFF);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;
    
    /* find FMT chunk */
    ck.ckid = WFIO_FOURCC_fmt;
    lr = mmioDescend(pwfio->m_hmmio, &ck, &pwfio->m_ckWave, MMIO_FINDCHUNK);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;
    
    cksize = ck.cksize;
    if(cksize < sizeof(WAVEFORMATEX))
        cksize = sizeof(WAVEFORMATEX);
    
    /* prepare the format buffer */
    pwfio->m_sizeFormat = cksize;
    pwfio->m_pFormat = (WAVEFORMATEX *)wmvalloc(pwfio->m_sizeFormat);
    if(pwfio->m_pFormat == NULL)
    {
        lr = MMSYSERR_NOMEM;
        goto lerror;
    }
    memset(pwfio->m_pFormat, 0, pwfio->m_sizeFormat);
    
    /* read the format chunk */
    lr = mmioRead(pwfio->m_hmmio, (HPSTR)pwfio->m_pFormat, ck.cksize);
    if(lr != (I32)ck.cksize)
    {
        lr = MMSYSERR_READERROR;
        goto lerror;
    }
    
    /* the format chunk for PCM on WAV files are WAVEFORMAT */
    if(pwfio->m_pFormat->wFormatTag == WAVE_FORMAT_PCM)
        pwfio->m_pFormat->cbSize = 0;
    
    /* ascend out of FMT */
    lr = mmioAscend(pwfio->m_hmmio, &ck, 0);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;
    
    /* find DATA chunk */
    pwfio->m_ck.ckid = WFIO_FOURCC_data;
    lr = mmioDescend(pwfio->m_hmmio, &pwfio->m_ck, &pwfio->m_ckWave, MMIO_FINDCHUNK);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;
    
    pwfio->m_sizeData     = pwfio->m_ck.cksize;
    
    pwfio->m_posDataStart = pwfio->m_ck.dwDataOffset;
    
    /* get info */
    lr = mmioGetInfo(pwfio->m_hmmio, &pwfio->m_mmioinfo, 0);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;
    
#endif /* WFIO_NO_WIN32 */
    
    return MMSYSERR_NOERROR;
    
lerror:
    if(pwfio->m_pFormat)
    {
        wmvfree(pwfio->m_pFormat);
        pwfio->m_pFormat = NULL;
        
        pwfio->m_sizeFormat = 0;
    }
    return lr;
}


I32
wfioWriteHeaders(WavFileIO *pwfio,
                 WAVEFORMATEX *pFormat,
                 U32 cbFormat)
{
    I32 lr;

#if WFIO_NO_WIN32

    size_t ret;
    size_t offset = 0;

    U32 dwTemp;

    WAVEFORMATEX *pWavFormat = NULL;

    if(pwfio == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }

    if(pwfio->m_fpWav == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    if(pFormat == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    if(cbFormat < sizeof(WAVEFORMATEX))
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }

    /* copy the format locally */

    if(pwfio->m_pFormat)
    {
        wmvfree(pwfio->m_pFormat);
        pwfio->m_pFormat = NULL;

        pwfio->m_sizeFormat = 0;
    }
    pwfio->m_sizeFormat = cbFormat;
    pwfio->m_pFormat = (WAVEFORMATEX *)wmvalloc(pwfio->m_sizeFormat);
    if(pwfio->m_pFormat == NULL)
    {
        lr = MMSYSERR_NOMEM;
        goto lerror;
    }
    memcpy(pwfio->m_pFormat, pFormat, pwfio->m_sizeFormat);

    /* format in the right format... */
    pWavFormat = (WAVEFORMATEX *)wmvalloc(pwfio->m_sizeFormat);
    if(pWavFormat == NULL)
    {
        lr = MMSYSERR_NOMEM;
        goto lerror;
    }
    memcpy(pWavFormat, pFormat, pwfio->m_sizeFormat);

#if !WFIO_LITTLE_ENDIAN
    /* only PCM for big-endian platforms... */
    if(pFormat->wFormatTag != WAVE_FORMAT_PCM)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
#endif /* WFIO_LITTLE_ENDIAN */

    pWavFormat->wFormatTag      = adjustByteOrder16(pWavFormat->wFormatTag);
    pWavFormat->nChannels       = adjustByteOrder16(pWavFormat->nChannels);
    pWavFormat->nSamplesPerSec  = adjustByteOrder32(pWavFormat->nSamplesPerSec);
    pWavFormat->nAvgBytesPerSec = adjustByteOrder32(pWavFormat->nAvgBytesPerSec);
    pWavFormat->nBlockAlign     = adjustByteOrder16(pWavFormat->nBlockAlign);
    pWavFormat->wBitsPerSample  = adjustByteOrder16(pWavFormat->wBitsPerSample);
    pWavFormat->cbSize          = adjustByteOrder16(pWavFormat->cbSize);

    /* -----------------------------------------------------------------------
     * create RIFF/WAVE chunk
     */

    /* write "RIFF" */

    dwTemp = WFIO_FOURCC_RIFF;
    ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_WRITEERROR;
        goto lerror;
    }
    offset += ret;

    /* write "RIFF" length, temporarily */

    pwfio->m_posRiffLength = offset;

    dwTemp = 0;   /* temporary */
    ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_WRITEERROR;
        goto lerror;
    }
    offset += ret;

    /* write "WAVE" */

    dwTemp = WFIO_FOURCC_WAVE;
    ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_WRITEERROR;
        goto lerror;
    }
    offset += ret;

    /* -----------------------------------------------------------------------
     * create FMT chunk
     */

    /* write "fmt " */

    dwTemp = WFIO_FOURCC_fmt;
    ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_WRITEERROR;
        goto lerror;
    }
    offset += ret;

    /* write "fmt " length */

    dwTemp = adjustByteOrder32(cbFormat);
    ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_WRITEERROR;
        goto lerror;
    }
    offset += ret;

    /* write actual format */

    ret = fwrite(pWavFormat, 1, cbFormat, pwfio->m_fpWav);
    if(ret != cbFormat)
    {
        lr = MMSYSERR_WRITEERROR;
        goto lerror;
    }
    offset += ret;

    /* -----------------------------------------------------------------------
     * create DATA chunk
     */

    /* write "data" */

    dwTemp = WFIO_FOURCC_data;
    ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_WRITEERROR;
        goto lerror;
    }
    offset += ret;

    /* write "data" length */

    pwfio->m_posDataLength = offset;

    dwTemp = 0;
    ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_WRITEERROR;
        goto lerror;
    }
    offset += ret;

    pwfio->m_sizeData   = 0;

    pwfio->m_posDataStart = offset;

    if(pWavFormat)
    {
        wmvfree(pWavFormat);
        pWavFormat = NULL;
    }

    return MMSYSERR_NOERROR;

lerror:
    if(pwfio->m_pFormat)
    {
        wmvfree(pwfio->m_pFormat);
        pwfio->m_pFormat = NULL;

        pwfio->m_sizeFormat = 0;
    }

    if(pWavFormat)
    {
        wmvfree(pWavFormat);
        pWavFormat = NULL;
    }

    return lr;

#else  /* WFIO_NO_WIN32 */

    if(pwfio == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    if(pwfio->m_hmmio == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    if(pwfio->m_mode != wfioModeWrite)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    if(pFormat == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    if(cbFormat < sizeof(WAVEFORMATEX))
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }

    /* copy the format locally */
    if(pwfio->m_pFormat)
    {
        wmvfree(pwfio->m_pFormat);
        pwfio->m_pFormat = NULL;

        pwfio->m_sizeFormat = 0;
    }
    pwfio->m_sizeFormat = cbFormat;
    pwfio->m_pFormat = (WAVEFORMATEX *)wmvalloc(pwfio->m_sizeFormat);
    if(pwfio->m_pFormat == NULL)
    {
        lr = MMSYSERR_NOMEM;
        goto lerror;
    }
    CopyMemory(pwfio->m_pFormat, pFormat, pwfio->m_sizeFormat);

    /* create WAVE chunk */
    pwfio->m_ckWave.fccType = WFIO_FOURCC_WAVE;
    pwfio->m_ckWave.cksize  = 0;
    lr = mmioCreateChunk(pwfio->m_hmmio, &pwfio->m_ckWave, MMIO_CREATERIFF);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;

    /* create FMT chunk */
    pwfio->m_ck.ckid   = WFIO_FOURCC_fmt;
    pwfio->m_ck.cksize = pwfio->m_sizeFormat;
    lr = mmioCreateChunk(pwfio->m_hmmio, &pwfio->m_ck, 0);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;

    /* copy out the format */
    lr = mmioWrite(pwfio->m_hmmio, (HPSTR)pwfio->m_pFormat, pwfio->m_sizeFormat);
    if(lr != (I32)pwfio->m_sizeFormat)
    {
        lr = MMSYSERR_WRITEERROR;
        goto lerror;
    }

    /* ascend out of FMT */
    lr = mmioAscend(pwfio->m_hmmio, &pwfio->m_ck, 0);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;

    /* create DATA chunk */

    pwfio->m_ck.ckid   = WFIO_FOURCC_data;
    pwfio->m_ck.cksize = 0;
    lr = mmioCreateChunk(pwfio->m_hmmio, &pwfio->m_ck, 0);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;

    /* get info */
    lr = mmioGetInfo(pwfio->m_hmmio, &pwfio->m_mmioinfo, 0);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;

    if(pwfio->m_pFormat)
    {
        wmvfree(pwfio->m_pFormat);
        pwfio->m_pFormat = NULL;

        pwfio->m_sizeFormat = 0;
    }

    return MMSYSERR_NOERROR;

lerror:
    if(pwfio->m_pFormat)
    {
        wmvfree(pwfio->m_pFormat);
        pwfio->m_pFormat = NULL;

        pwfio->m_sizeFormat = 0;
    }
    return lr;

#endif /* WFIO_NO_WIN32 */
}


I32
wfioCleanUpRead(WavFileIO *pwfio)
{
    if(pwfio == NULL)
        return MMSYSERR_ERROR;

    /* for a historic reason... */
    return MMSYSERR_NOERROR;
}


I32
wfioCleanUpWrite(WavFileIO *pwfio)
{
    I32 lr;

#if WFIO_NO_WIN32

    size_t ret;

    U32 dwTemp;

    if(pwfio == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    if(pwfio->m_fpWav == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    if(pwfio->m_mode != wfioModeWrite)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }

    /* flush it first */

    fflush(pwfio->m_fpWav);

    /* write back the data length */

    ret = fseek(pwfio->m_fpWav, pwfio->m_posDataLength, SEEK_SET);
    if(ret != 0)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }

    dwTemp = adjustByteOrder32(pwfio->m_sizeData);
    ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_WRITEERROR;
        goto lerror;
    }

    /* write back the riff length */

    ret = fseek(pwfio->m_fpWav, pwfio->m_posRiffLength, SEEK_SET);
    if(ret != 0)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }

    dwTemp = pwfio->m_sizeData + pwfio->m_posDataStart - 8; /* "RIFF" and its size (4 + 4 bytes) */
    dwTemp = adjustByteOrder32(dwTemp);
    ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_WRITEERROR;
        goto lerror;
    }

    /* flush again... */

    fflush(pwfio->m_fpWav);

#else   /* WFIO_NO_WIN32 */

    if(pwfio == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    if(pwfio->m_hmmio == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    if(pwfio->m_mode != wfioModeWrite)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }

    /* write back the info */
    pwfio->m_mmioinfo.dwFlags |= MMIO_DIRTY;
    lr = mmioSetInfo(pwfio->m_hmmio, &pwfio->m_mmioinfo, 0);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;

    /* ascend out of DATA.  this will cause the write-out. */
    lr = mmioAscend(pwfio->m_hmmio, &pwfio->m_ck, 0);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;

    /* ascend out of RIFF.  this will cause the file write-out, probably. */
    lr = mmioAscend(pwfio->m_hmmio, &pwfio->m_ckWave, 0);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;

#endif  /* WFIO_NO_WIN32 */

    return MMSYSERR_NOERROR;

lerror:
    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\win32.c ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Win32.c

Abstract:

    Win32-specific functions.

Author:

    Raymond Cheng (raych)       Aug 25, 1999

Revision History:
  
    Thumpudi Naveen (tnaveen)   May 9, 2000    Added NT specific timer.

*************************************************************************/

#include "bldsetup.h"

#include "macros.h"


// Only build these functions for WIN32
#ifdef WMA_OSTARGET_WIN32

// **************************************************************************
// COMMON FUNCTIONS
// **************************************************************************

#ifdef WMA_TARGET_ANSI
#include "ansiwin.h"
#else   // WMA_TARGET_ANSI

#ifndef _WIN32
#define _WIN32  // We need this when including windows.h
#endif  // !_WIN32

#include "windows.h"
#endif  // WMA_TARGET_ANSI


#ifdef PLATFORM_SPECIFIC_OUTPUTDEBUGSTRING
#define OUTPUT_DEBUG_STRING(sz) OutputDebugString(sz)
#endif  // PLATFORM_SPECIFIC_OUTPUTDEBUGSTRING

#ifdef UNICODE
#define SPRINTF swprintf
#else   // UNICODE
#define SPRINTF sprintf
#endif  // UNICODE

#ifdef PLATFORM_SPECIFIC_PERFTIMER

#include <stdio.h>

typedef struct tagPERFTIMERINFO
{
    int             fFirstTime;         // Used to record total time spent in decode loop
    LARGE_INTEGER   cDecodeTime;        // Time spent decoding only (running total)
    LARGE_INTEGER   cTotalDecLoopTime;  // Total time spent in decode loop
    LARGE_INTEGER   cDecodeStart;       // Could be easily optimized out but it's not worth it
    long            lSamplesPerSec;     // Samples per second, counting all channels
    LARGE_INTEGER   cPlaybackTime;      // Time required for playback (running total)
    LARGE_INTEGER   cPerfFrequency;     // Frequency of PerformanceCounter
    
    Bool            bIsWindowsNT;       // GetProcessTime available
} PERFTIMERINFO;


PERFTIMERINFO *PerfTimerNew(long lSamplesPerSecOutput)
{
    PERFTIMERINFO  *pInfo;
    Bool            fResult;
    OSVERSIONINFO   osVersionInfo;
    
    pInfo = (PERFTIMERINFO*) wmvalloc(sizeof(PERFTIMERINFO));
    if (NULL == pInfo)
        return NULL;
    
    pInfo->fFirstTime = WMAB_TRUE;
    pInfo->cDecodeTime.QuadPart = 0;
    pInfo->cTotalDecLoopTime.QuadPart  = 0;
    pInfo->cDecodeStart.QuadPart  = 0;
    pInfo->lSamplesPerSec = lSamplesPerSecOutput;
    pInfo->cPlaybackTime.QuadPart  = 0;
    
    // Determine if we are running on NT
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    // Default: Not NT
    pInfo->bIsWindowsNT = WMAB_FALSE;

#if !defined(USE_QUERY_TIMER)
    if (GetVersionEx(&osVersionInfo)) 
        pInfo->bIsWindowsNT = (osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
#endif // USE_QUERY_TIMER
    
    if (pInfo->bIsWindowsNT) {
        pInfo->cPerfFrequency.QuadPart = 10000000; // Ticks are hard coded to be 100ns
    } else {
        fResult = QueryPerformanceFrequency(&pInfo->cPerfFrequency);
        if (WMAB_FALSE == fResult)
            pInfo->cPerfFrequency.QuadPart = -1;
    }
    
    return pInfo;
}

void PerfTimerStart(PERFTIMERINFO *pInfo)
{
    Bool     fResult;
    
#ifndef UNDER_CE
    if (pInfo->bIsWindowsNT) 
    {
        // Measures user time. Aggregate of all threads in the process. 
        // Should we measure wall clock time? Should we add kernel time
        // to the user time?
        // Get pseudo handle of the current process. No need to close
        // pseudo-handles.
        HANDLE   hProcess;
        FILETIME ftCreationTime, ftExitTime, ftKernelTime, ftUserTime;
        hProcess = GetCurrentProcess();
        fResult = GetProcessTimes(hProcess, &ftCreationTime, 
            &ftExitTime, &ftKernelTime, &ftUserTime);
        if (WMAB_FALSE == fResult) 
            pInfo->cDecodeStart.QuadPart = 0;
        else
        {
            pInfo->cDecodeStart.LowPart = ftUserTime.dwLowDateTime;
            pInfo->cDecodeStart.HighPart = ftUserTime.dwHighDateTime;
        }
    } 
    else 
    {
        fResult = QueryPerformanceCounter(&pInfo->cDecodeStart);
        if (WMAB_FALSE == fResult)
            pInfo->cDecodeStart.QuadPart = 0;
    }
#else   // UNDER_CE
    fResult = QueryPerformanceCounter(&pInfo->cDecodeStart);
    if (WMAB_FALSE == fResult)
        pInfo->cDecodeStart.QuadPart = 0;
#endif  // UNDER_CE
    
    if (pInfo->fFirstTime)
    {
        pInfo->cTotalDecLoopTime.QuadPart = pInfo->cDecodeStart.QuadPart;
        pInfo->fFirstTime = WMAB_FALSE;
    }
}

void PerfTimerStop(PERFTIMERINFO *pInfo, long lSamplesDecoded)
{
    LARGE_INTEGER   cEndTime;
    Bool            fResult;
    
#ifndef UNDER_CE
    if (pInfo->bIsWindowsNT) 
    { 
        // Measures user time. Aggregate of all threads in the process
        // Should we measure wall clock time? Should we add kernel time
        // to the user time?
        // Get pseudo handle of the current process. No need to close
        // pseudo-handles.
        HANDLE          hProcess;
        FILETIME        ftCreationTime, ftExitTime, ftKernelTime, ftUserTime;
        hProcess = GetCurrentProcess();
        fResult = GetProcessTimes(hProcess, &ftCreationTime, 
            &ftExitTime, &ftKernelTime, &ftUserTime);
        if (WMAB_FALSE == fResult) 
            cEndTime.QuadPart = 0;
        else
        {
            cEndTime.LowPart = ftUserTime.dwLowDateTime;
            cEndTime.HighPart = ftUserTime.dwHighDateTime;
        }
    }
    else 
    {
        fResult = QueryPerformanceCounter(&cEndTime);
        if (WMAB_FALSE == fResult)
            cEndTime.QuadPart = 0;
    }
#else   // UNDER_CE
    fResult = QueryPerformanceCounter(&cEndTime);
    if (WMAB_FALSE == fResult)
        cEndTime.QuadPart = 0;
#endif  // UNDER_CE
    
    pInfo->cDecodeTime.QuadPart += cEndTime.QuadPart -
        pInfo->cDecodeStart.QuadPart;
    
    // Record output playback time from this decode call, in clock() ticks
    pInfo->cPlaybackTime.QuadPart += lSamplesDecoded *
        pInfo->cPerfFrequency.QuadPart / pInfo->lSamplesPerSec;
}

void PerfTimerStopElapsed(PERFTIMERINFO *pInfo)
{
    LARGE_INTEGER   cEndElapsedTime;
    Bool            fResult;
    
#ifndef UNDER_CE
    if (pInfo->bIsWindowsNT) 
    { 
        // Measures user time. Aggregate of all threads in the process
        // Should we measure wall clock time? Should we add kernel time
        // to the user time?
        // Get pseudo handle of the current process. No need to close
        // pseudo-handles.
        HANDLE          hProcess;
        FILETIME        ftCreationTime, ftExitTime, ftKernelTime, ftUserTime;
        hProcess = GetCurrentProcess();
        fResult = GetProcessTimes(hProcess, &ftCreationTime, 
            &ftExitTime, &ftKernelTime, &ftUserTime);
        if (WMAB_FALSE == fResult) 
            cEndElapsedTime.QuadPart = 0;
        else
        {
            cEndElapsedTime.LowPart = ftUserTime.dwLowDateTime;
            cEndElapsedTime.HighPart = ftUserTime.dwHighDateTime;
        }
    }
    else 
    {
        fResult = QueryPerformanceCounter(&cEndElapsedTime);
        if (WMAB_FALSE == fResult)
            cEndElapsedTime.QuadPart = 0;
    }
#else   // UNDER_CE
    fResult = QueryPerformanceCounter(&cEndElapsedTime);
    if (WMAB_FALSE == fResult)
        cEndElapsedTime.QuadPart = 0;
#endif  // UNDER_CE
    pInfo->cTotalDecLoopTime.QuadPart = cEndElapsedTime.QuadPart -
        pInfo->cTotalDecLoopTime.QuadPart;
}

void PerfTimerReport(PERFTIMERINFO *pInfo)
{
    TCHAR           sz[256];
    float           fltDecodeTime;
    float           fltEntireDecodeTime;
    float           fltDecodeTimeFraction;
    float           fltPlaybackTime;
    
    if (pInfo->bIsWindowsNT) {
        SPRINTF(sz, TEXT("\n** Reporting aggregate of user time in all threads (NT)\n"));
        OUTPUT_DEBUG_STRING(sz);
    }
    
    SPRINTF(sz, TEXT("\n\n** Ticks per second (clock resolution): %f.\n"),
        (float)pInfo->cPerfFrequency.QuadPart);
    OUTPUT_DEBUG_STRING(sz);
    
    fltDecodeTime = (float) pInfo->cDecodeTime.QuadPart /
        (float) pInfo->cPerfFrequency.QuadPart;
    fltEntireDecodeTime = (float) pInfo->cTotalDecLoopTime.QuadPart /
        (float) pInfo->cPerfFrequency.QuadPart;
    SPRINTF(sz, TEXT("** Decode time: %f sec. Entire decode time: %f sec.\n"),
        fltDecodeTime, fltEntireDecodeTime);
    OUTPUT_DEBUG_STRING(sz);
    
    fltPlaybackTime = (float) pInfo->cPlaybackTime.QuadPart /
        (float) pInfo->cPerfFrequency.QuadPart;
    SPRINTF(sz, TEXT("** Playback time : %f sec.\n"),
        fltPlaybackTime);
    OUTPUT_DEBUG_STRING(sz);
    
    fltDecodeTimeFraction = (float)pInfo->cDecodeTime.QuadPart /
        (float) pInfo->cPlaybackTime.QuadPart;
    SPRINTF(sz, TEXT("** Percentage of playback time spent decoding: %f%%.\n"),
        fltDecodeTimeFraction * 100);
    OUTPUT_DEBUG_STRING(sz);
#       if defined(WMA_MONITOR)
    fprintf(stderr,"%s\n",sz);
#       endif
    
    SPRINTF(sz, TEXT("** Minimum MHz for realtime playback: %f of current CPU speed.\n"),
        fltDecodeTimeFraction);
    OUTPUT_DEBUG_STRING(sz);
    
    SPRINTF(sz, TEXT("** This CPU is %f times faster than required.\n\n"),
        (float)1.0 / fltDecodeTimeFraction);
    OUTPUT_DEBUG_STRING(sz);
    
#ifdef WRITE_TIME_TO_FILE
    {
        FILE*   fOut;
        
        fOut = fopen("time.txt", "wt");
        if (fOut != NULL) 
        { 
            fprintf(fOut, "%f\n", (float) fltDecodeTime);
            fclose(fOut);
            fOut = NULL;
        }
    }
#endif  //WRITE_TIME_TO_FILE
    
}


float fltPerfTimerDecodeTime(PERFTIMERINFO *pInfo)
{
    return (float) pInfo->cDecodeTime.QuadPart /
        (float) pInfo->cPerfFrequency.QuadPart;
}


void PerfTimerFree(PERFTIMERINFO *pInfo)
{
    wmvfree(pInfo);
}

#endif  // PLATFORM_SPECIFIC_PERFTIMER



//---------------------------------------------------------------------------
// Debug Infrastructure
//---------------------------------------------------------------------------
#if defined(PLATFORM_SPECIFIC_DEBUGINFRASTRUCTURE) && defined(_DEBUG)
#include <stdarg.h>
void TraceInfoHelper(const char *pszFile, int iLine, const char *pszFmt, ...)
{
    char    sz[512];
    va_list vargs;
    Int     iCharsWritten;

    // Prepend file/line identifier and "*** INFO ***" to get attention
    iCharsWritten = sprintf(sz, "%s(%d) : *** INFO *** ", pszFile, iLine);

    va_start(vargs, pszFmt);
    iCharsWritten += vsprintf(sz + iCharsWritten, pszFmt, vargs);
    va_end(vargs);

    // Append a newline and print it!
    sprintf(sz + iCharsWritten, "\n");
#if defined(_UNICODE) || defined(UNICODE)
    // let this do the string to unicode conversion
    MyOutputDbgStr(0,sz);
#else
    OUTPUT_DEBUG_STRING(sz);
#endif
}

WMARESULT MyOutputDbgStr(WMARESULT wmaReturn, const char *pszFmt, ...)
{
    TCHAR   sz[512];
    va_list vargs;
#if defined(_UNICODE) || defined(UNICODE)
    WCHAR wcsFmt[512];
    const WCHAR* pszFormat = wcsFmt;
    mbstowcs( wcsFmt, pszFmt, strlen(pszFmt)+1 );
#else
    const char* pszFormat = pszFmt;
#endif
    
    va_start(vargs, pszFmt);
    wvsprintf(sz, pszFormat, vargs);
    va_end(vargs);
    
    OUTPUT_DEBUG_STRING(sz);
    return wmaReturn;
}
#endif  // defined(PLATFORM_SPECIFIC_DEBUGINFRASTRUCTURE) && defined(_DEBUG)



#ifdef UNDER_CE
#	ifndef _CLOCK_T_DEFINED
		typedef long clock_t;
#		define _CLOCK_T_DEFINED
#	endif

	clock_t __cdecl clock(void) { 
		return (clock_t)GetTickCount(); 
	}

#	ifndef _TIME_T_DEFINED
		typedef long time_t;        /* time value */
#		define _TIME_T_DEFINED     /* avoid multiple def's of time_t */
#	endif

	time_t __cdecl time(time_t * pt) {
		SYSTEMTIME stNowTime;
		SYSTEMTIME st1970 = { 1970, 1, 0, 1, 0, 0, 0, 0 };
		FILETIME   ftNowTime, ft1970;
		ULARGE_INTEGER ulNowTime, ul1970;
		time_t tNowTime;	// seconds since 1/1/1970
		GetSystemTime( &stNowTime );
		if ( SystemTimeToFileTime( &stNowTime, &ftNowTime ) && SystemTimeToFileTime( &st1970, &ft1970 ) )
		{
			ulNowTime.HighPart = ftNowTime.dwHighDateTime;
			ulNowTime.LowPart  = ftNowTime.dwLowDateTime;
			ul1970.HighPart    = ft1970.dwHighDateTime;
			ul1970.LowPart     = ft1970.dwLowDateTime;
			tNowTime = (time_t)( (ulNowTime.QuadPart - ul1970.QuadPart)/10000000 );
		} else 
		{
			tNowTime = (time_t)clock();
		}
		if ( pt != NULL )
			*pt = tNowTime;
		return tNowTime;
	}
#endif


#endif  // WMA_OSTARGET_WIN32
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\wmcguid.cpp ===
#define INITGUID_WMC

#include "bldsetup.h"

#include "stdio.h"
#include "wmc_type.h"
#include "wmcguids.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\wmf.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       wma.c
//
//--------------------------------------------------------------------------

#include "bldsetup.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define _HRESULT_DEFINED
#include "wmf.h"
#undef _HRESULT_DEFINED

#if defined (macintosh) || defined (HITACHI)
#ifndef __LONG_DEFINED__
#define __LONG_DEFINED__
typedef I32_WMC LONG; 
#endif
#include "wmMacSp.h" 
#endif //macintosh
#define __BASICTYPEDEFINED__

#include "wmfdec.h"
#include "wmcguids.h"
#include "wmfparse.h"
#include "wmf_loadstuff.h"
#include "wmadecS_api.h"
#ifndef __NO_SCREEN__
#include "wmscreendec_api.h"
#endif

#ifndef __NO_SPEECH__
#include "wmsdec_api.h"
#endif

#ifndef _ASFPARSE_ONLY_
#include "wmvdec_api.h"
#endif


#define CHECK_FRAMERATE		6

tWMCDecStatus WMCDecUpdateNewPayload(HWMCDECODER hDecoder, tMediaType_WMC MediaType, U16_WMC Index);
tWMCDecStatus WMCDecDecodeFrameX( HWMCDECODER hDecoder, U16_WMC * pbDecoded, U32_WMC* pnNumberOfSamples,tMediaType_WMC MediaType, U16_WMC Index );
tWMCDecStatus WMCDecParseVirtualPacketHeader(HWMCDECODER hDecoder, U32_WMC cbCurrentPacketOffset, PACKET_PARSE_INFO_EX* pParseInfoEx);
tWMCDecStatus WMCDecParseVirtualPayloadHeader(HWMCDECODER hDecoder, U32_WMC cbCurrentPacketOffset, PACKET_PARSE_INFO_EX *pParseInfoEx, PAYLOAD_MAP_ENTRY_EX *pPayload);
tWMCDecStatus WMScDecodeData (HWMCDECODER hWMCDec, U16_WMC wIndex );
tWMCDecStatus WMCDecGetMediaType (HWMCDECODER hWMCDec, U16_WMC wStreamId, tMediaType_WMC * pMediaType);
tWMCDecStatus WMCRawGetVideoData (U8_WMC *pBuffer, U32_WMC *pcbBuffer, HWMCDECODER hDecoder, U32_WMC cbDstBufferLength);
tWMCDecStatus WMCRawGetBinaryData (U8_WMC *pBuffer, U32_WMC *pcbBuffer, HWMCDECODER hDecoder, U32_WMC cbDstBufferLength);
tWMCDecStatus WMCRawGetData (U8_WMC *pBuffer, U32_WMC *pcbBuffer, HWMCDECODER hDecoder, U32_WMC cbDstBufferLength);


/****************************************************************************/
/*static Void_WMC WMADecoderCleanUp(WMFDecoderEx *pDecoder)
{
    U16_WMC i=0;

    if(pDecoder)
    {
        for(i=0; i<pDecoder->tHeaderInfo.wNoOfAudioStreams; i++ )
        {
            if(pDecoder->tAudioStreamInfo[i]->hMSA !=NULL)
            {
    			WMARawDecClose(&(pDecoder->tAudioStreamInfo[i]->hMSA));
                pDecoder->tAudioStreamInfo[i]->hMSA = NULL;
            }
            if(pDecoder->tAudioStreamInfo[i]->pbAudioBuffer !=NULL)
            {
    			wmvfree(pDecoder->tAudioStreamInfo[i]->pbAudioBuffer);
                pDecoder->tAudioStreamInfo[i]->pbAudioBuffer = NULL;
            }
            pDecoder->tAudioStreamInfo[i] = NULL;
        }
        
        if(pDecoder->pszType != NULL)
        {
            wmvfree(pDecoder->pszType);
        }

        if(pDecoder->pszKeyID != NULL)
        {
            wmvfree(pDecoder->pszKeyID);
        }
        if(pDecoder->m_pLicData != NULL)
        {
            wmvfree(pDecoder->m_pLicData);
        }
//        memset(pDecoder, 0, sizeof(WMFDecoderEx));
    }
}
*/

/****************************************************************************/

#ifdef _ZMDRM_

tWMCDecStatus WMCDecInitZMDRM(HWMCDECODER hDecoder ,U32_WMC Rights)
{
    HRESULT hr;
    WMFDecoderEx *pDecoder;

#ifdef GLOBAL_SECRET
        ERROR: GLOBAL_SECRET must not be defined for ZapMedia linux port
#endif

	printf("INFO: In %s \n", __FILE__ );	// rajn


    pDecoder = (WMFDecoderEx *) (hDecoder);

    if (pDecoder->cbEnhData == 0)
    {
		printf("ERROR: In %s:%d, cbEnhData is 0\n", __FILE__, __LINE__);	// rajn
        return WMCDec_DRMFail;
    }


    hr = WMFSetRights(pDecoder->hDRM, Rights);
    if ( hr != 0 )
    {
        printf("ERROR: WMFSetRights - hr = 0x%x\n", hr);
        return WMCDec_DRMFail;
    }


    hr = WMFSetEnhancedData(pDecoder->hDRM, pDecoder->cbEnhData, pDecoder->pbEnhData );
    if ( hr != 0 )
    {
        printf("ERROR: WMFSetEnhancedData - hr = 0x%x\n", hr);
        return WMCDec_DRMFail;
    }


	// rajn -- debug
	{
		U32_WMC i;	
		printf("\nINFO: ---< V2Hdr (%d bytes)>---\n", pDecoder->cbEnhData);
		for(i=0; i < pDecoder->cbEnhData; i += 2 )
		{
			// cheap unicode printf
			printf("%c", pDecoder->pbEnhData[i] );						
	
		}
		printf("\n---< End of V2Hdr >--\n");
	}




    hr = WMFCanDecrypt(pDecoder->hDRM);
//    hr = WMFCanDecrypt(pDecoder->hDRM,pDecoder->cbSecData, pDecoder->pbSecData);

    if ( hr == 0 ) // S_OK
    {
        return WMCDec_Succeeded;
    }

    if ( hr == 1 ) // S_FALSE
    {
        return WMCDec_DRMInitFail;
    }

    // hr == E_FAIL ...
    return WMCDec_DRMFail;

}
#else
U8_WMC pDrmBuffer[2048];
#endif

/****************************************************************************/
tWMCDecStatus WMFDecTimeToOffset(
                    HWMCDECODER hDecoder,
                    U32_WMC msSeek,
                    U64_WMC *pcbPacketOffset )
{
    U32_WMC nPacket;
    WMFDecoderEx *pDecoder;

    if( ( NULL == hDecoder ) || ( NULL == pcbPacketOffset ) )
    {
        return( WMCDec_InValidArguments );
    }


    pDecoder = (WMFDecoderEx *) hDecoder;

  if( msSeek > pDecoder->tHeaderInfo.msDuration )
    {
        return( WMCDec_InValidArguments );
    }

    nPacket = 0;
    if( pDecoder->tHeaderInfo.msDuration > 0 )
    {
        nPacket = ( msSeek * pDecoder->tHeaderInfo.cPackets ) / pDecoder->tHeaderInfo.msDuration;
    }

    *pcbPacketOffset = (U64_WMC)pDecoder->tHeaderInfo.cbHeader + ( (U64_WMC)nPacket * (U64_WMC)pDecoder->tHeaderInfo.cbPacketSize );

    return( WMCDec_Succeeded );
}


/****************************************************************************/
tWMCDecStatus WMFCloseDecoder (HWMCDECODER  *hDecoder)
{
    WMFDecoderEx *pDecoder;

    if( NULL == hDecoder )
    {
        return( WMCDec_InValidArguments );
    }

    pDecoder = (WMFDecoderEx *) (*hDecoder);

//    WMADecoderCleanUp(pDecoder);
    wmvfree( pDecoder );
    pDecoder = NULL;

    return( WMCDec_Succeeded );
}

#ifndef WMFAPI_NO_DRM
/****************************************************************************/
tWMCDecStatus WMFDecDRM (HWMCDECODER hDecoder, U32_WMC *pfDRM)
{
    if(hDecoder == NULL || pfDRM == NULL)
    {
        return WMCDec_InValidArguments;
    }

    *pfDRM = ((WMFDecoderEx *)hDecoder)->hDRM != NULL;

    return WMCDec_Succeeded;
}

#endif

/****************************************************************************/
tWMCDecStatus WMCReadIndex (HWMCDECODER  *hDecoder)
{
    
    tWMCDecStatus err = WMCDec_Succeeded;
//    const U8_WMC *pbTemp;
    GUID objId;
    U64_WMC qwSize;
    U8_WMC *pbBuffer= NULL;
    U64_WMC dwIndexOffset =0;
    U8_WMC i=0;
    U32_WMC cbActual =0;
    U32_WMC cbWanted =0;
    U8_WMC *pData = NULL;
    U32_WMC dwSize =0;

    
    WMFDecoderEx *pDecoder;

    if( NULL == hDecoder )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *) (*hDecoder);
    if (pDecoder->tHeaderInfo.wNoOfVideoStreams == 0)
        return WMCDec_Succeeded;

    dwIndexOffset = pDecoder->tHeaderInfo.cbLastPacketOffset + pDecoder->tHeaderInfo.cbPacketSize;

    do
    {
 //       err = WMFCBDecodeGetData (*hDecoder, Header, 24, dwIndexOffset, &cbRead);
        cbWanted =24;

        cbActual = WMCDecCBGetData(*hDecoder, dwIndexOffset, cbWanted, &pData,pDecoder->u32UserData );

	    if (cbActual != cbWanted) 
        {
		    return WMCDec_Succeeded;
	    }

//        pbTemp = Header;

        LoadGUID( objId, pData );
        LoadQWORD( qwSize, pData );
        dwSize = *((U32_WMC*) &qwSize);

        if( IsEqualGUID_WMC( &CLSID_CAsfIndexObjectV2, &objId ) )
        {
/*            pbBuffer = (U8_WMC *)wmvalloc(*((U32_WMC*) &qwSize));
            if (pbBuffer == NULL)
                return WMCDec_BadMemory;
    
            err = WMFCBDecodeGetData (hDecoder, pbBuffer, *((U32_WMC*) &qwSize), dwIndexOffset, &cbRead);
	        if (cbRead != *((U32_WMC*) &qwSize) || err !=WMCDec_Succeeded) 
            {
                wmvfree(pbBuffer);
                pbBuffer = NULL;
                return WMCDec_Fail;
	        }
*/
            LoadIndexObject(hDecoder,dwIndexOffset,dwSize , pDecoder->tVideoStreamInfo[i]->wStreamId, &pDecoder->tIndexInfo[pDecoder->cTotalIndexs]);
            i++;
            pDecoder->cTotalIndexs+=1;

 //           wmvfree(pbBuffer);
 //           pbBuffer = NULL;

        }

        dwIndexOffset+=(*((U32_WMC*) &qwSize));

    }while(pDecoder->tHeaderInfo.wNoOfVideoStreams > pDecoder->cTotalIndexs );



    return( WMCDec_Succeeded );
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/****************************************************************************/
tWMCDecStatus WMCInitnParseHeader(HWMCDECODER *phDecoder
#ifdef _ZMDRM_
                    ,HDRMMGR *phDRM
                    ,U8_WMC *pAppCert
                    ,U32_WMC Rights
                    ,const U8_WMC *pbHwId
                    ,U32_WMC cbHwId
#endif
                    )
{
    WMFDecoderEx *pDecoder;
    tWMCDecStatus rc = WMCDec_Succeeded;
//    U32_WMC u32UserContext =0;
//	I32_WMC i32PostProc =0;

    pDecoder = NULL;

    do
    {
        pDecoder = (WMFDecoderEx *) (*phDecoder);

        if( NULL == pDecoder )
        {
            rc = WMCDec_BadMemory;
            break;
        }

      /*  u32UserContext = pDecoder->u32UserData;
		i32PostProc = pDecoder->i32PostProc;
        memset( pDecoder, 0, sizeof( WMFDecoderEx ) );

        pDecoder->u32UserData = u32UserContext;
		
		pDecoder->i32PostProc = i32PostProc;*/

        pDecoder->m_pExtendedContentDesc = NULL;
        pDecoder->m_pScriptCommand = NULL;
        pDecoder->m_pMarkers = NULL;
        pDecoder->m_pContentDesc = NULL;

        rc = ParseAsfHeader(phDecoder, (U8_WMC) 1);
        if( WMCDec_Succeeded != rc )
			break;

    }while(0);


    if( WMCDec_Succeeded != rc )
    {
        WMCDecClose(phDecoder);
        *phDecoder = NULL;
        // wmvfree( pDecoder );

		return rc;
    }

    pDecoder->tHeaderInfo.cbLastPacketOffset = pDecoder->tHeaderInfo.cbFirstPacketOffset;
    if (pDecoder->tHeaderInfo.cPackets > 0)
        pDecoder->tHeaderInfo.cbLastPacketOffset += (pDecoder->tHeaderInfo.cPackets - 1)*pDecoder->tHeaderInfo.cbPacketSize;

	pDecoder->tHeaderInfo.cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbHeader;// Added by amit
    pDecoder->tHeaderInfo.cbNextPacketOffset = pDecoder->tHeaderInfo.cbHeader;
    pDecoder->parse_state = csWMCNewAsfPacket;

    return( rc );
}


/****************************************************************************/

#ifdef WMC_NO_BUFFER_MODE

tWMCDecStatus WMCDecGetAndDecode (HWMCDECODER hWMCDec, U32_WMC* pnStreamReadyForOutput, U32_WMC* pnNumberOfSamples)
{
    tWMCDecStatus err = WMCDec_Succeeded;
    WMFDecoderEx *pDecoder = NULL;    
    I32_WMC lBytesWritten =0;
    U64_WMC cbPacketOffset=0;
    I32_WMC i;
	Bool_WMC	bAllDone = FALSE_WMC;
    U32_WMC     dwMinPresTime=0xffffffff;
    U32_WMC     dwMinAudioPresTime=0xffffffff;
    U32_WMC     dwMinVideoPresTime=0xffffffff;
    U32_WMC     dwMinBinaryPresTime=0xffffffff;
    U16_WMC     wMinAudioIndex = 0xffff;
    U16_WMC     wMinVideoIndex = 0xffff;
    U16_WMC     wMinBinaryIndex = 0xffff;
    U16_WMC		Index =0;
    tMediaType_WMC MediaType = Audio_WMC;

	Bool_WMC	bGotAtLeastOneVideoOutput = FALSE_WMC;	
	Bool_WMC	bGotAtLeastOneBinaryOutput = FALSE_WMC;
	Bool_WMC	bGotAtLeastOneVideoStreamToOutput = FALSE_WMC;	
	Bool_WMC	bGotAtLeastOneBinaryStreamToOutput = FALSE_WMC;


    if(hWMCDec==NULL_WMC)
        return WMCDec_InValidArguments;
    
    pDecoder = (WMFDecoderEx*) hWMCDec;

    if (pDecoder->bParsed != TRUE_WMC)
        return WMCDec_InValidArguments;

    if (pDecoder->tPlannedOutputInfo.wTotalOutput == 0)
        return WMCDec_DecodeComplete;


    for (i=0; i< pDecoder->tPlannedOutputInfo.wTotalOutput; i++ )
    {
        Index = pDecoder->tPlannedOutputInfo.tPlannedId[i].wStreamIndex;

        switch(pDecoder->tPlannedOutputInfo.tPlannedId[i].tMediaType)
        {
        case Audio_WMC:
			if (pDecoder->tAudioStreamInfo[Index]->bTobeDecoded == FALSE_WMC)
			{
			
				if (pDecoder->tAudioStreamInfo[Index]->bOutputisReady == TRUE_WMC) // Last output is not taken out
				{
					//Fix buffers
					U8_WMC TempOutBuff[1024];
					U32_WMC cbBuffer=0;
					do
					{
						WMCRawGetData (TempOutBuff, &cbBuffer, hWMCDec, (U32_WMC) 1024);
					}while(cbBuffer>0);

					pDecoder->tAudioStreamInfo[Index]->bOutputisReady = FALSE_WMC;
				}
			}
/*			else
			{
				if (pDecoder->tAudioStreamInfo[Index]->bOutputisReady == TRUE_WMC)
				{
					I16_WMC TempOutBuff[4096];
					U32_WMC cbBuffer=0;
					I64_WMC  tPresentationTime=0;
					do
					{
						WMCDecGetAudioOutput(hWMCDec, (I16_WMC*)&TempOutBuff[0], (I16_WMC*)NULL_WMC,(U32_WMC)1024, &cbBuffer, &tPresentationTime )	;					WMCRawGetData (TempOutBuff, &cbBuffer, hDecoder, (U32_WMC) 1024);
					}while(cbBuffer>0);
				
					pDecoder->tAudioStreamInfo[Index]->bOutputisReady = FALSE_WMC;
				}
			
			}*/

            break;
        case Video_WMC:
			if ((pDecoder->tVideoStreamInfo[Index]->bHasGivenAnyOutput == TRUE_WMC)&&(pDecoder->tVideoStreamInfo[Index]->bStopReading == FALSE_WMC))
				bGotAtLeastOneVideoOutput = TRUE_WMC;
			
			if ((pDecoder->tVideoStreamInfo[Index]->bWantOutput == TRUE_WMC)&&(pDecoder->tVideoStreamInfo[Index]->bStopReading == FALSE_WMC))
				bGotAtLeastOneVideoStreamToOutput = TRUE_WMC;

			if (pDecoder->tVideoStreamInfo[Index]->bTobeDecoded == FALSE_WMC)
			{
				if (pDecoder->tVideoStreamInfo[Index]->bOutputisReady == TRUE_WMC) // Last output is not taken out
				{
					//Fix buffers
					U8_WMC TempOutBuff[1024];
					U32_WMC cbBuffer=0;
					do
					{
						WMCRawGetVideoData (TempOutBuff, &cbBuffer, hWMCDec, (U32_WMC) 1024);
					}while(cbBuffer>0);
	
					pDecoder->tVideoStreamInfo[Index]->bOutputisReady = FALSE_WMC;
				
				}
			}
            break;
        case Binary_WMC:
			if ((pDecoder->tBinaryStreamInfo[Index]->bHasGivenAnyOutput == TRUE_WMC)&&(pDecoder->tBinaryStreamInfo[Index]->bStopReading == FALSE_WMC))
				bGotAtLeastOneBinaryOutput = TRUE_WMC;

			if ((pDecoder->tBinaryStreamInfo[Index]->bWantOutput == TRUE_WMC)&&(pDecoder->tBinaryStreamInfo[Index]->bStopReading == FALSE_WMC))
				bGotAtLeastOneBinaryStreamToOutput = TRUE_WMC;

			if (pDecoder->tBinaryStreamInfo[Index]->bOutputisReady == TRUE_WMC) // Last output is not taken out
			{
				//Fix buffers
				U8_WMC TempOutBuff[1024];
				U32_WMC cbBuffer=0;
				do
				{
					WMCRawGetBinaryData (TempOutBuff, &cbBuffer, hWMCDec, (U32_WMC) 1024);
				}while(cbBuffer>0);
			
				pDecoder->tBinaryStreamInfo[Index]->bOutputisReady = FALSE_WMC;
			}
        }
    }


	Index =0;

	do
	{
		
		for (i=0; i< pDecoder->tPlannedOutputInfo.wTotalOutput; i++ )
		{
		   Index = pDecoder->tPlannedOutputInfo.tPlannedId[i].wStreamIndex;
		   
		   MediaType = pDecoder->tPlannedOutputInfo.tPlannedId[i].tMediaType;
		   
		   switch(pDecoder->tPlannedOutputInfo.tPlannedId[i].tMediaType)
			{
			case Audio_WMC:
				if ((pDecoder->tAudioStreamInfo[Index]->parse_state != csWMCEnd )/*&&(pDecoder->tAudioStreamInfo[Index]->cbNextPacketOffset <=pDecoder->tHeaderInfo.cbLastPacketOffset)*/)
				{
					if (pDecoder->tAudioStreamInfo[Index]->parse_state != csWMCDecodeLoopStart)
					{
						err = WMCDecUpdateNewPayload(hWMCDec, MediaType, Index);
					}
					if (pDecoder->tAudioStreamInfo[Index]->parse_state != csWMCEnd )
					{
						if (dwMinAudioPresTime > (U32_WMC)pDecoder->tAudioStreamInfo[Index]->dwAudioTimeStamp)
						{
							dwMinAudioPresTime = (U32_WMC)(pDecoder->tAudioStreamInfo[Index]->dwAudioTimeStamp);
							wMinAudioIndex = Index;
						}
					}
					else
						pDecoder->tPlannedOutputInfo.tPlannedId[i].bDone = TRUE_WMC;

				}
				else
					pDecoder->tPlannedOutputInfo.tPlannedId[i].bDone = TRUE_WMC;

                if (pDecoder->tPlannedOutputInfo.tPlannedId[i].bDone == TRUE_WMC)
                {
                    dwMinAudioPresTime = 0xffffffff;
                    pDecoder->tAudioStreamInfo[Index]->dwAudioBufCurOffset =0;
                    pDecoder->tAudioStreamInfo[Index]->dwAudioBufDecoded =0;
                    pDecoder->tAudioStreamInfo[Index]->parse_state = csWMCEnd;
                }


				break;
			case Video_WMC:
				if ((pDecoder->tVideoStreamInfo[Index]->parse_state != csWMCEnd )/*&&(pDecoder->tVideoStreamInfo[Index]->cbNextPacketOffset <= pDecoder->tHeaderInfo.cbLastPacketOffset)*/)
				{
					if (pDecoder->tVideoStreamInfo[Index]->dwNextVideoTimeStamp > pDecoder->tVideoStreamInfo[Index]->dwVideoTimeStamp)
						pDecoder->tVideoStreamInfo[Index]->dwVideoTimeStamp = pDecoder->tVideoStreamInfo[Index]->dwNextVideoTimeStamp;
					if (pDecoder->tVideoStreamInfo[Index]->parse_state != csWMCDecodeLoopStart)
					{
						err = WMCDecUpdateNewPayload(hWMCDec, MediaType, Index);
					}
					if (pDecoder->tVideoStreamInfo[Index]->parse_state != csWMCEnd )
					{
						if ((dwMinVideoPresTime > (U32_WMC)pDecoder->tVideoStreamInfo[Index]->dwVideoTimeStamp)&&((pDecoder->tVideoStreamInfo[Index]->bStopReading == FALSE_WMC) || (bGotAtLeastOneVideoOutput == FALSE_WMC)))
						{
							dwMinVideoPresTime = (U32_WMC)(pDecoder->tVideoStreamInfo[Index]->dwVideoTimeStamp);
							wMinVideoIndex = Index;
						}
						else if((dwMinVideoPresTime == (U32_WMC)pDecoder->tVideoStreamInfo[Index]->dwVideoTimeStamp ) && (pDecoder->tVideoStreamInfo[Index]->bStopReading == FALSE_WMC))
						{
							dwMinVideoPresTime = (U32_WMC)pDecoder->tVideoStreamInfo[Index]->dwVideoTimeStamp;
							wMinVideoIndex = Index;
						}

					}
					else
						pDecoder->tPlannedOutputInfo.tPlannedId[i].bDone = TRUE_WMC;

				}
				else
					pDecoder->tPlannedOutputInfo.tPlannedId[i].bDone = TRUE_WMC;

                if ((pDecoder->tVideoStreamInfo[Index]->bStopReading == TRUE_WMC) && (bGotAtLeastOneVideoOutput == TRUE_WMC) || (pDecoder->tPlannedOutputInfo.tPlannedId[i].bDone == TRUE_WMC))
				{
					//Dont Read and decode this stream.
					pDecoder->tVideoStreamInfo[Index]->bNowStopReadingAndDecoding = TRUE_WMC;
					
					dwMinVideoPresTime = 0xffffffff;
					pDecoder->tVideoStreamInfo[Index]->dwVideoBufCurOffset =0;
					pDecoder->tVideoStreamInfo[Index]->dwVideoBufDecoded =0;
					pDecoder->tVideoStreamInfo[Index]->parse_state = csWMCEnd; 
				}

				break;
			case Binary_WMC:
			   if ((pDecoder->tBinaryStreamInfo[Index]->parse_state != csWMCEnd )/* && (pDecoder->tBinaryStreamInfo[Index]->cbNextPacketOffset <=pDecoder->tHeaderInfo.cbLastPacketOffset)*/)
				{
					if (pDecoder->tBinaryStreamInfo[Index]->dwNextBinaryTimeStamp > pDecoder->tBinaryStreamInfo[Index]->dwBinaryTimeStamp)
						pDecoder->tBinaryStreamInfo[Index]->dwBinaryTimeStamp = pDecoder->tBinaryStreamInfo[Index]->dwNextBinaryTimeStamp;
					if (pDecoder->tBinaryStreamInfo[Index]->parse_state != csWMCDecodeLoopStart)
					{
						err = WMCDecUpdateNewPayload(hWMCDec, MediaType, Index);
					}
					if (pDecoder->tBinaryStreamInfo[Index]->parse_state != csWMCEnd )
					{
						if ((dwMinBinaryPresTime > (U32_WMC)pDecoder->tBinaryStreamInfo[Index]->dwBinaryTimeStamp)&&((pDecoder->tBinaryStreamInfo[Index]->bStopReading == FALSE_WMC) || (bGotAtLeastOneBinaryOutput == FALSE_WMC)))
						{
							dwMinBinaryPresTime = (U32_WMC)(pDecoder->tBinaryStreamInfo[Index]->dwBinaryTimeStamp);
							wMinBinaryIndex = Index;
						}
						else if((dwMinBinaryPresTime == (U32_WMC)pDecoder->tBinaryStreamInfo[Index]->dwBinaryTimeStamp ) && (pDecoder->tBinaryStreamInfo[Index]->bStopReading == FALSE_WMC))
						{
							dwMinBinaryPresTime = (U32_WMC)pDecoder->tBinaryStreamInfo[Index]->dwBinaryTimeStamp;
							wMinBinaryIndex = Index;
						}
					}
					else
						pDecoder->tPlannedOutputInfo.tPlannedId[i].bDone = TRUE_WMC;
				}
			   else
				   pDecoder->tPlannedOutputInfo.tPlannedId[i].bDone = TRUE_WMC;

                if ((pDecoder->tBinaryStreamInfo[Index]->bStopReading == TRUE_WMC) && (bGotAtLeastOneBinaryOutput == TRUE_WMC)|| (pDecoder->tPlannedOutputInfo.tPlannedId[i].bDone == TRUE_WMC))
				{
					//Dont Read and decode this stream.
					pDecoder->tBinaryStreamInfo[Index]->bNowStopReadingAndDecoding = TRUE_WMC;
					
					dwMinBinaryPresTime = 0xffffffff;
					pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufCurOffset =0;
					pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufDecoded =0;
					pDecoder->tBinaryStreamInfo[Index]->parse_state = csWMCEnd; 
				}

				break;
	//        default:
	//            bReadyForOutput = FALSE_WMC;

			}
		}



		for (i=0; i< pDecoder->tPlannedOutputInfo.wTotalOutput; i++ )
		{
			if (pDecoder->tPlannedOutputInfo.tPlannedId[i].bDone == TRUE_WMC)
			{
				bAllDone = TRUE_WMC;
			}
			else
			{
				bAllDone = FALSE_WMC;
				break;
			}

		}

		if (bAllDone == TRUE_WMC)
		{
			*pnStreamReadyForOutput = 0xff;
			return WMCDec_Succeeded;
		}
   
		
		// Findout Minimum of all 3..... and select which stream to decode
		
		
		dwMinPresTime = dwMinAudioPresTime;
		MediaType = Audio_WMC;
		Index = wMinAudioIndex;

		if (dwMinVideoPresTime < dwMinPresTime)
		{
			dwMinPresTime = dwMinVideoPresTime;
			MediaType = Video_WMC;
	 		Index = wMinVideoIndex;
	   }
		if (dwMinBinaryPresTime < dwMinPresTime)
		{
			dwMinPresTime = dwMinBinaryPresTime;
			MediaType = Binary_WMC;
	 		Index = wMinBinaryIndex;
		}

		if (dwMinPresTime == 0xffffffff)
		{
		 // No stream is ready to get decoded;
    
			*pnStreamReadyForOutput = 0xff;
			return WMCDec_Succeeded;
		}

		err = WMCDecDecodeFrameX(hWMCDec, (U16_WMC*)pnStreamReadyForOutput, pnNumberOfSamples, MediaType, Index );
		if ((err == WMCDec_Succeeded)&&(*pnStreamReadyForOutput == 0xff))
			continue;
		
		return err;
	
	}while(1);
            
}
/***********************************************************************************************************/
tWMCDecStatus WMCDecUpdateNewPayload(HWMCDECODER hDecoder, tMediaType_WMC MediaType, U16_WMC Index)
{

	tWMCDecStatus err = WMCDec_Succeeded;
    WMFDecoderEx *pDecoder =NULL;
	tMediaType_WMC LocalMediaType;
	U32_WMC cbWanted =0;
	U32_WMC cbActual =0;
	U8_WMC *pData = NULL;
	
    if (NULL == hDecoder)
        return WMCDec_InValidArguments;

    pDecoder = (WMFDecoderEx *) (hDecoder);
    
	switch(MediaType)
	{
	
	case Audio_WMC:
		do
		{
			switch(pDecoder->tAudioStreamInfo[Index]->parse_state)
			{
				case csWMCNewAsfPacket:

					if(pDecoder->tAudioStreamInfo[Index]->cbNextPacketOffset > pDecoder->tHeaderInfo.cbLastPacketOffset)
					{
						pDecoder->tAudioStreamInfo[Index]->parse_state = csWMCEnd;
						return WMCDec_DecodeComplete;
					}

					pDecoder->tAudioStreamInfo[Index]->cbCurrentPacketOffset = pDecoder->tAudioStreamInfo[Index]->cbNextPacketOffset;
					pDecoder->tAudioStreamInfo[Index]->cbNextPacketOffset += pDecoder->tHeaderInfo.cbPacketSize;

					err = WMCDecParseVirtualPacketHeader( hDecoder, (U32_WMC)pDecoder->tAudioStreamInfo[Index]->cbCurrentPacketOffset, &(pDecoder->tAudioStreamInfo[Index]->ppex));

					if(err != WMCDec_Succeeded)
					{
						return WMCDec_BadPacketHeader;
					}

					if (pDecoder->tAudioStreamInfo[Index]->ppex.fEccPresent && pDecoder->tAudioStreamInfo[Index]->ppex.fParityPacket)
					{
						break;
					}

					pDecoder->tAudioStreamInfo[Index]->parse_state = csWMCDecodePayloadStart;
					pDecoder->tAudioStreamInfo[Index]->iPayload = 0;
					break;

				case csWMCDecodePayloadStart:

					if (pDecoder->tAudioStreamInfo[Index]->iPayload >= pDecoder->tAudioStreamInfo[Index]->ppex.cPayloads)
					{
						pDecoder->tAudioStreamInfo[Index]->parse_state = csWMCNewAsfPacket;
						break;//return WMCDec_Succeeded; // Return after taking full packet
					}

					err = WMCDecParseVirtualPayloadHeader(hDecoder, (U32_WMC)pDecoder->tAudioStreamInfo[Index]->cbCurrentPacketOffset, &(pDecoder->tAudioStreamInfo[Index]->ppex), &(pDecoder->tAudioStreamInfo[Index]->payload));
					if(err != WMCDec_Succeeded)
					{
						pDecoder->tAudioStreamInfo[Index]->parse_state = csWMCDecodePayloadEnd;
						break;
					}
					err = WMCDecGetMediaType (hDecoder,  pDecoder->tAudioStreamInfo[Index]->payload.bStreamId, &LocalMediaType);
					if (err != WMCDec_Succeeded)
					{
						pDecoder->parse_state = csWMCDecodePayloadEnd;
						break;
					}
					if ((LocalMediaType != Audio_WMC)|| (pDecoder->tAudioStreamInfo[Index]->wStreamId != pDecoder->tAudioStreamInfo[Index]->payload.bStreamId))
					{
						pDecoder->tAudioStreamInfo[Index]->parse_state = csWMCDecodePayloadEnd;
						break;
					}

					pDecoder->tAudioStreamInfo[Index]->wPayStart = pDecoder->tAudioStreamInfo[Index]->payload.cbPacketOffset + pDecoder->tAudioStreamInfo[Index]->payload.cbTotalSize  - pDecoder->tAudioStreamInfo[Index]->payload.cbPayloadSize;

					if( pDecoder->tAudioStreamInfo[Index]->payload.cbRepData != 1 )
					{
						pDecoder->tAudioStreamInfo[Index]->parse_state = csWMCDecodePayload;
						pDecoder->tAudioStreamInfo[Index]->payload.bIsCompressedPayload =0; // Amit to take care of compressed payloads.
						break;
					}
					else if( pDecoder->tAudioStreamInfo[Index]->payload.cbRepData == 1)    // Amit to take care of compressed payloads.
					{
						pDecoder->tAudioStreamInfo[Index]->parse_state = csWMCDecodeCompressedPayload;
						pDecoder->tAudioStreamInfo[Index]->payload.bIsCompressedPayload =1;
						break;
					}
 
				case csWMCDecodePayload:
					if((pDecoder->tAudioStreamInfo[Index]->bWantOutput == TRUE_WMC) &&(pDecoder->tAudioStreamInfo[Index]->bStopReading == FALSE_WMC))
					{
						if(pDecoder->tAudioStreamInfo[Index]->dwAudioTimeStamp == 0)
							pDecoder->tAudioStreamInfo[Index]->dwAudioTimeStamp = (U32_WMC) pDecoder->tAudioStreamInfo[Index]->payload.msObjectPres;
						pDecoder->tAudioStreamInfo[Index]->dwAudPayloadPresTime = (U32_WMC) pDecoder->tAudioStreamInfo[Index]->payload.msObjectPres;
						pDecoder->tAudioStreamInfo[Index]->dwPayloadOffset = (U32_WMC)pDecoder->tAudioStreamInfo[Index]->cbCurrentPacketOffset + pDecoder->tAudioStreamInfo[Index]->wPayStart;
						pDecoder->tAudioStreamInfo[Index]->bBlockStart     = TRUE_WMC;
						pDecoder->tAudioStreamInfo[Index]->dwBlockLeft     = pDecoder->tAudioStreamInfo[Index]->nBlockAlign;
						pDecoder->tAudioStreamInfo[Index]->dwFrameSize = pDecoder->tAudioStreamInfo[Index]->payload.cbObjectSize; 
						pDecoder->tAudioStreamInfo[Index]->dwPayloadLeft = pDecoder->tAudioStreamInfo[Index]->payload.cbPayloadSize - pDecoder->tAudioStreamInfo[Index]->dwBlockLeft;
					}
     				pDecoder->tAudioStreamInfo[Index]->parse_state = csWMCDecodeLoopStart ;//csWMCDecodePayloadEnd;
		//			break;
		            return WMCDec_Succeeded;

				case csWMCDecodePayloadEnd:
					pDecoder->tAudioStreamInfo[Index]->iPayload++;
					pDecoder->tAudioStreamInfo[Index]->parse_state = csWMCDecodePayloadStart;
					break;

				case csWMCDecodeCompressedPayload: // Added by Amit to take care of compressed payloads
					if((pDecoder->tAudioStreamInfo[Index]->bWantOutput == TRUE_WMC) &&(pDecoder->tAudioStreamInfo[Index]->bStopReading == FALSE_WMC))
					{
						if(pDecoder->tAudioStreamInfo[Index]->dwAudioTimeStamp == 0)
							pDecoder->tAudioStreamInfo[Index]->dwAudioTimeStamp = (U32_WMC) pDecoder->tAudioStreamInfo[Index]->payload.msObjectPres;
						pDecoder->tAudioStreamInfo[Index]->dwAudPayloadPresTime = (U32_WMC) pDecoder->tAudioStreamInfo[Index]->payload.msObjectPres;

						pDecoder->tAudioStreamInfo[Index]->dwPayloadOffset = (U32_WMC)pDecoder->tAudioStreamInfo[Index]->cbCurrentPacketOffset + pDecoder->tAudioStreamInfo[Index]->wPayStart;

						pDecoder->tAudioStreamInfo[Index]->bBlockStart     = TRUE_WMC;
						pDecoder->tAudioStreamInfo[Index]->dwBlockLeft     = pDecoder->tAudioStreamInfo[Index]->nBlockAlign;
//						pDecoder->tAudioStreamInfo[Index]->dwPayloadLeft = pDecoder->tAudioStreamInfo[Index]->payload.cbPayloadSize - pDecoder->tAudioStreamInfo[Index]->dwBlockLeft;
						pDecoder->tAudioStreamInfo[Index]->payload.wBytesRead =0;
						pDecoder->tAudioStreamInfo[Index]->payload.bSubPayloadState =1;

						cbWanted = 1; //to read subpayload length
						cbActual = WMCDecCBGetData(hDecoder, pDecoder->tAudioStreamInfo[Index]->dwPayloadOffset, cbWanted, &pData, pDecoder->u32UserData);

						if(cbActual != cbWanted)
						{
							return WMCDec_BufferTooSmall;
						}
						
						
						pDecoder->tAudioStreamInfo[Index]->dwFrameSize = pData[0];

					}

     				pDecoder->tAudioStreamInfo[Index]->parse_state = csWMCDecodeLoopStart ;//csWMCDecodePayloadEnd;
		//			break;
		            return WMCDec_Succeeded;
//				default:
			}
            
        
		}while(1);

		break;

	case Video_WMC:
		do
		{
			switch(pDecoder->tVideoStreamInfo[Index]->parse_state)
			{
				case csWMCNewAsfPacket:

					if(pDecoder->tVideoStreamInfo[Index]->cbNextPacketOffset > pDecoder->tHeaderInfo.cbLastPacketOffset)
					{
						pDecoder->tVideoStreamInfo[Index]->parse_state = csWMCEnd;
						return WMCDec_DecodeComplete;
					}

					pDecoder->tVideoStreamInfo[Index]->cbCurrentPacketOffset = pDecoder->tVideoStreamInfo[Index]->cbNextPacketOffset;
					pDecoder->tVideoStreamInfo[Index]->cbNextPacketOffset += pDecoder->tHeaderInfo.cbPacketSize;

					err = WMCDecParseVirtualPacketHeader( hDecoder, (U32_WMC)pDecoder->tVideoStreamInfo[Index]->cbCurrentPacketOffset, &(pDecoder->tVideoStreamInfo[Index]->ppex));

					if(err != WMCDec_Succeeded)
					{
						return WMCDec_BadPacketHeader;
					}

					if (pDecoder->tVideoStreamInfo[Index]->ppex.fEccPresent && pDecoder->tVideoStreamInfo[Index]->ppex.fParityPacket)
					{
						break;
					}

					pDecoder->tVideoStreamInfo[Index]->parse_state = csWMCDecodePayloadStart;
					pDecoder->tVideoStreamInfo[Index]->iPayload = 0;
					break;

				case csWMCDecodePayloadStart:

					if (pDecoder->tVideoStreamInfo[Index]->iPayload >= pDecoder->tVideoStreamInfo[Index]->ppex.cPayloads)
					{
						pDecoder->tVideoStreamInfo[Index]->parse_state = csWMCNewAsfPacket;
						break; //return WMCDec_Succeeded; // Return after taking full packet
					}

					err = WMCDecParseVirtualPayloadHeader(hDecoder, (U32_WMC)pDecoder->tVideoStreamInfo[Index]->cbCurrentPacketOffset, &(pDecoder->tVideoStreamInfo[Index]->ppex), &(pDecoder->tVideoStreamInfo[Index]->payload));
					if(err != WMCDec_Succeeded)
					{
						pDecoder->tVideoStreamInfo[Index]->parse_state = csWMCDecodePayloadEnd;
						break;
					}


					err = WMCDecGetMediaType (hDecoder,  pDecoder->tVideoStreamInfo[Index]->payload.bStreamId, &LocalMediaType);
					if (err != WMCDec_Succeeded)
					{
						pDecoder->parse_state = csWMCDecodePayloadEnd;
						break;
					}
					if ((LocalMediaType != Video_WMC) || (pDecoder->tVideoStreamInfo[Index]->wStreamId != pDecoder->tVideoStreamInfo[Index]->payload.bStreamId))
					{
						pDecoder->tVideoStreamInfo[Index]->parse_state = csWMCDecodePayloadEnd;
						break;
					}

					pDecoder->tVideoStreamInfo[Index]->wPayStart = pDecoder->tVideoStreamInfo[Index]->payload.cbPacketOffset + pDecoder->tVideoStreamInfo[Index]->payload.cbTotalSize  - pDecoder->tVideoStreamInfo[Index]->payload.cbPayloadSize;

					if( pDecoder->tVideoStreamInfo[Index]->payload.cbRepData != 1 )
					{
						pDecoder->tVideoStreamInfo[Index]->parse_state = csWMCDecodePayload;
						pDecoder->tVideoStreamInfo[Index]->payload.bIsCompressedPayload =0; // Amit to take care of compressed payloads.
						break;
					}
					else if( pDecoder->tVideoStreamInfo[Index]->payload.cbRepData == 1)    // Amit to take care of compressed payloads.
					{
						pDecoder->tVideoStreamInfo[Index]->parse_state = csWMCDecodeCompressedPayload;
						pDecoder->tVideoStreamInfo[Index]->payload.bIsCompressedPayload =1;
						break;
					}
 
				case csWMCDecodePayload:
		// In this case store payload in buffer and dont return. Return only after one packet is finished

					if((pDecoder->tVideoStreamInfo[Index]->bWantOutput == TRUE_WMC) &&(pDecoder->tVideoStreamInfo[Index]->bNowStopReadingAndDecoding == FALSE_WMC))
					{
						pDecoder->tVideoStreamInfo[Index]->dwPayloadOffset = (U32_WMC) (pDecoder->tVideoStreamInfo[Index]->cbCurrentPacketOffset + pDecoder->tVideoStreamInfo[Index]->wPayStart);
                    
//						if(pDecoder->tVideoStreamInfo[Index]->dwVideoTimeStamp == 0)
							pDecoder->tVideoStreamInfo[Index]->dwVideoTimeStamp = (U32_WMC) pDecoder->tVideoStreamInfo[Index]->payload.msObjectPres;

						// Keep data about frame size, offset, frame used etc... 
						if (0 == pDecoder->tVideoStreamInfo[Index]->payload.cbObjectOffset) 
						{ // New Frame starts
							if (!(pDecoder->tVideoStreamInfo[Index]->bFirst)) 
							{
								if (pDecoder->tVideoStreamInfo[Index]->payload.bIsKeyFrame == 0) 
								{
									pDecoder->tVideoStreamInfo[Index]->parse_state = csWMCDecodePayloadEnd;
									break;
								}
								pDecoder->tVideoStreamInfo[Index]->bFirst = 1;
							
							}

							pDecoder->tVideoStreamInfo[Index]->cbUsed = pDecoder->tVideoStreamInfo[Index]->payload.cbPayloadSize;
							pDecoder->tVideoStreamInfo[Index]->cbFrame = pDecoder->tVideoStreamInfo[Index]->dwNbFrames;
							pDecoder->tVideoStreamInfo[Index]->dwNbFrames += 1;
							pDecoder->tVideoStreamInfo[Index]->dwFrameSize = pDecoder->tVideoStreamInfo[Index]->payload.cbObjectSize; 
							pDecoder->tVideoStreamInfo[Index]->bIsKeyFrame = pDecoder->tVideoStreamInfo[Index]->payload.bIsKeyFrame;
							pDecoder->tVideoStreamInfo[Index]->dwPayloadOffset = (U32_WMC)pDecoder->tVideoStreamInfo[Index]->cbCurrentPacketOffset + pDecoder->tVideoStreamInfo[Index]->wPayStart;
							pDecoder->tVideoStreamInfo[Index]->dwBlockLeft     = pDecoder->tVideoStreamInfo[Index]->payload.cbPayloadSize;
							pDecoder->tVideoStreamInfo[Index]->dwPayloadLeft = pDecoder->tVideoStreamInfo[Index]->payload.cbPayloadSize - pDecoder->tVideoStreamInfo[Index]->dwBlockLeft;
							pDecoder->tVideoStreamInfo[Index]->dwFrameLeft = pDecoder->tVideoStreamInfo[Index]->dwFrameSize;
						} 
						else 
						{   // old frame cont....
							if ( pDecoder->tVideoStreamInfo[Index]->cbUsed ==0)
							{
								pDecoder->tVideoStreamInfo[Index]->parse_state = csWMCDecodePayloadEnd;
								break;
							}

							if (pDecoder->tVideoStreamInfo[Index]->cbUsed == pDecoder->tVideoStreamInfo[Index]->payload.cbObjectOffset) 
							{ // Packet cont...				
								// store payload
								pDecoder->tVideoStreamInfo[Index]->dwPayloadOffset = (U32_WMC)pDecoder->tVideoStreamInfo[Index]->cbCurrentPacketOffset + pDecoder->tVideoStreamInfo[Index]->wPayStart;
								pDecoder->tVideoStreamInfo[Index]->dwBlockLeft     = pDecoder->tVideoStreamInfo[Index]->payload.cbPayloadSize;
								pDecoder->tVideoStreamInfo[Index]->dwPayloadLeft = pDecoder->tVideoStreamInfo[Index]->payload.cbPayloadSize - pDecoder->tVideoStreamInfo[Index]->dwBlockLeft;

								pDecoder->tVideoStreamInfo[Index]->cbUsed += pDecoder->tVideoStreamInfo[Index]->payload.cbPayloadSize;
							}
							else // Broken packet
							{
								pDecoder->tVideoStreamInfo[Index]->cbUsed = 0;
								pDecoder->tVideoStreamInfo[Index]->dwFrameLeft =0;
							}
						}
                
					}


					pDecoder->tVideoStreamInfo[Index]->parse_state = csWMCDecodeLoopStart ;//csWMCDecodePayloadEnd;
				//	break;
					return WMCDec_Succeeded;

				case csWMCDecodePayloadEnd:
					pDecoder->tVideoStreamInfo[Index]->iPayload++;
					pDecoder->tVideoStreamInfo[Index]->parse_state = csWMCDecodePayloadStart;
					break;

				case csWMCDecodeCompressedPayload: // Added by Amit to take care of compressed payloads
					// In this case store payload in buffer and dont return. Return only after one packet is finished
					
					if((pDecoder->tVideoStreamInfo[Index]->bWantOutput == TRUE_WMC) &&(pDecoder->tVideoStreamInfo[Index]->bNowStopReadingAndDecoding == FALSE_WMC))
					{
						if (!(pDecoder->tVideoStreamInfo[Index]->bFirst)) 
						{
							if (pDecoder->tVideoStreamInfo[Index]->payload.bIsKeyFrame == 0) 
							{
								pDecoder->tVideoStreamInfo[Index]->parse_state = csWMCDecodePayloadEnd;
								break;
							}
							pDecoder->tVideoStreamInfo[Index]->bFirst = 1;
						
						}
                    
//						if(pDecoder->tVideoStreamInfo[Index]->dwVideoTimeStamp == 0)
							pDecoder->tVideoStreamInfo[Index]->dwVideoTimeStamp = (U32_WMC) pDecoder->tVideoStreamInfo[Index]->payload.msObjectPres;
						pDecoder->tVideoStreamInfo[Index]->dwPayloadOffset = (U32_WMC)pDecoder->tVideoStreamInfo[Index]->cbCurrentPacketOffset + pDecoder->tVideoStreamInfo[Index]->wPayStart;
						pDecoder->tVideoStreamInfo[Index]->cbUsed = 0;
						pDecoder->tVideoStreamInfo[Index]->cbFrame = pDecoder->tVideoStreamInfo[Index]->dwNbFrames;
						pDecoder->tVideoStreamInfo[Index]->dwFrameSize = 0; 
						pDecoder->tVideoStreamInfo[Index]->bIsKeyFrame = pDecoder->tVideoStreamInfo[Index]->payload.bIsKeyFrame;

						pDecoder->tVideoStreamInfo[Index]->dwPayloadOffset = (U32_WMC)pDecoder->tVideoStreamInfo[Index]->cbCurrentPacketOffset + pDecoder->tVideoStreamInfo[Index]->wPayStart;

//						pDecoder->tAudioStreamInfo[Index]->dwBlockLeft     = pDecoder->tAudioStreamInfo[Index]->nBlockAlign;
//						pDecoder->tAudioStreamInfo[Index]->dwPayloadLeft = pDecoder->tAudioStreamInfo[Index]->payload.cbPayloadSize - pDecoder->tAudioStreamInfo[Index]->dwBlockLeft;
						pDecoder->tVideoStreamInfo[Index]->payload.wBytesRead =0;
						pDecoder->tVideoStreamInfo[Index]->payload.bSubPayloadState =1;
					
						cbWanted = 1; //to read subpayload length
						cbActual = WMCDecCBGetData(hDecoder, pDecoder->tVideoStreamInfo[Index]->dwPayloadOffset, cbWanted, &pData, pDecoder->u32UserData);

						if(cbActual != cbWanted)
						{
							return WMCDec_BufferTooSmall;
						}
						
						
						pDecoder->tVideoStreamInfo[Index]->dwFrameSize = pData[0];

					}
					
					pDecoder->tVideoStreamInfo[Index]->parse_state = csWMCDecodeLoopStart;//csWMCDecodePayloadEnd;
				//	break;
					return WMCDec_Succeeded;

//				default:

			}
		}while(1);

		break;

	case Binary_WMC:
		do
		{
			switch(pDecoder->tBinaryStreamInfo[Index]->parse_state)
			{
				case csWMCNewAsfPacket:

					if(pDecoder->tBinaryStreamInfo[Index]->cbNextPacketOffset > pDecoder->tHeaderInfo.cbLastPacketOffset)
					{
						pDecoder->tBinaryStreamInfo[Index]->parse_state = csWMCEnd;
						return WMCDec_DecodeComplete;
					}

					pDecoder->tBinaryStreamInfo[Index]->cbCurrentPacketOffset = pDecoder->tBinaryStreamInfo[Index]->cbNextPacketOffset;
					pDecoder->tBinaryStreamInfo[Index]->cbNextPacketOffset += pDecoder->tHeaderInfo.cbPacketSize;

					err = WMCDecParseVirtualPacketHeader( hDecoder, (U32_WMC)pDecoder->tBinaryStreamInfo[Index]->cbCurrentPacketOffset, &(pDecoder->tBinaryStreamInfo[Index]->ppex));

					if(err != WMCDec_Succeeded)
					{
						return WMCDec_BadPacketHeader;
					}

					if (pDecoder->tBinaryStreamInfo[Index]->ppex.fEccPresent && pDecoder->tBinaryStreamInfo[Index]->ppex.fParityPacket)
					{
						break;
					}

					pDecoder->tBinaryStreamInfo[Index]->parse_state = csWMCDecodePayloadStart;
					pDecoder->tBinaryStreamInfo[Index]->iPayload = 0;
					break;

				case csWMCDecodePayloadStart:

					if (pDecoder->tBinaryStreamInfo[Index]->iPayload >= pDecoder->tBinaryStreamInfo[Index]->ppex.cPayloads)
					{
						pDecoder->tBinaryStreamInfo[Index]->parse_state = csWMCNewAsfPacket;
						break;//return WMCDec_Succeeded; // Return after taking full packet
					}

					err = WMCDecParseVirtualPayloadHeader(hDecoder, (U32_WMC)pDecoder->tBinaryStreamInfo[Index]->cbCurrentPacketOffset, &(pDecoder->tBinaryStreamInfo[Index]->ppex), &(pDecoder->tBinaryStreamInfo[Index]->payload));
					if(err != WMCDec_Succeeded)
					{
						pDecoder->tBinaryStreamInfo[Index]->parse_state = csWMCDecodePayloadEnd;
						break;
					}

					err = WMCDecGetMediaType (hDecoder,  pDecoder->tBinaryStreamInfo[Index]->payload.bStreamId, &LocalMediaType);
					if (err != WMCDec_Succeeded)
					{
						pDecoder->parse_state = csWMCDecodePayloadEnd;
						break;
					}
					if ((LocalMediaType != Binary_WMC)|| (pDecoder->tBinaryStreamInfo[Index]->wStreamId != pDecoder->tBinaryStreamInfo[Index]->payload.bStreamId))
					{
						pDecoder->tBinaryStreamInfo[Index]->parse_state = csWMCDecodePayloadEnd;
						break;
					}
					pDecoder->tBinaryStreamInfo[Index]->wPayStart = pDecoder->tBinaryStreamInfo[Index]->payload.cbPacketOffset + pDecoder->tBinaryStreamInfo[Index]->payload.cbTotalSize  - pDecoder->tBinaryStreamInfo[Index]->payload.cbPayloadSize;

					if( pDecoder->tBinaryStreamInfo[Index]->payload.cbRepData != 1 )
					{
						pDecoder->tBinaryStreamInfo[Index]->parse_state = csWMCDecodePayload;
						pDecoder->tBinaryStreamInfo[Index]->payload.bIsCompressedPayload =0; // Amit to take care of compressed payloads.
						break;
					}
					else if( pDecoder->tBinaryStreamInfo[Index]->payload.cbRepData == 1)    // Amit to take care of compressed payloads.
					{
						pDecoder->tBinaryStreamInfo[Index]->parse_state = csWMCDecodeCompressedPayload;
						pDecoder->tBinaryStreamInfo[Index]->payload.bIsCompressedPayload =1;
						break;
					}
 
				case csWMCDecodePayload:
		// In this case store payload in buffer and dont return. Return only after one packet is finished

					if((pDecoder->tBinaryStreamInfo[Index]->bWantOutput == TRUE_WMC) &&(pDecoder->tBinaryStreamInfo[Index]->bNowStopReadingAndDecoding == FALSE_WMC))
					{
						pDecoder->tBinaryStreamInfo[Index]->dwPayloadOffset = (U32_WMC)pDecoder->tBinaryStreamInfo[Index]->cbCurrentPacketOffset + pDecoder->tBinaryStreamInfo[Index]->wPayStart;
//						if(pDecoder->tBinaryStreamInfo[Index]->dwBinaryTimeStamp == 0)
							pDecoder->tBinaryStreamInfo[Index]->dwBinaryTimeStamp = (U32_WMC) pDecoder->tBinaryStreamInfo[Index]->payload.msObjectPres;

						// Keep data about frame size, offset, frame used etc... 
						if (0 == pDecoder->tBinaryStreamInfo[Index]->payload.cbObjectOffset) 
						{ // New Frame starts

							
							pDecoder->tBinaryStreamInfo[Index]->cbUsed = pDecoder->tBinaryStreamInfo[Index]->payload.cbPayloadSize;
							pDecoder->tBinaryStreamInfo[Index]->cbFrame = pDecoder->tBinaryStreamInfo[Index]->dwNbFrames;
							pDecoder->tBinaryStreamInfo[Index]->dwNbFrames += 1;
							pDecoder->tBinaryStreamInfo[Index]->dwFrameSize = pDecoder->tBinaryStreamInfo[Index]->payload.cbObjectSize; 
							pDecoder->tBinaryStreamInfo[Index]->dwPayloadOffset = (U32_WMC)pDecoder->tBinaryStreamInfo[Index]->cbCurrentPacketOffset + pDecoder->tBinaryStreamInfo[Index]->wPayStart;
							pDecoder->tBinaryStreamInfo[Index]->dwBlockLeft     = pDecoder->tBinaryStreamInfo[Index]->payload.cbPayloadSize;
							pDecoder->tBinaryStreamInfo[Index]->dwPayloadLeft = pDecoder->tBinaryStreamInfo[Index]->payload.cbPayloadSize - pDecoder->tBinaryStreamInfo[Index]->dwBlockLeft;
							pDecoder->tBinaryStreamInfo[Index]->dwFrameLeft = pDecoder->tBinaryStreamInfo[Index]->dwFrameSize;
						} 
						else 
						{   // old frame cont....
							if ( pDecoder->tBinaryStreamInfo[Index]->cbUsed ==0)
							{
								pDecoder->tBinaryStreamInfo[Index]->parse_state = csWMCDecodePayloadEnd;
								break;
							}

							if (pDecoder->tBinaryStreamInfo[Index]->cbUsed == pDecoder->tBinaryStreamInfo[Index]->payload.cbObjectOffset) 
							{ // Packet cont...				
								pDecoder->tBinaryStreamInfo[Index]->dwPayloadOffset = (U32_WMC)pDecoder->tBinaryStreamInfo[Index]->cbCurrentPacketOffset + pDecoder->tBinaryStreamInfo[Index]->wPayStart;
								pDecoder->tBinaryStreamInfo[Index]->dwBlockLeft     = pDecoder->tBinaryStreamInfo[Index]->payload.cbPayloadSize;
								pDecoder->tBinaryStreamInfo[Index]->dwPayloadLeft = pDecoder->tBinaryStreamInfo[Index]->payload.cbPayloadSize - pDecoder->tBinaryStreamInfo[Index]->dwBlockLeft;
								pDecoder->tBinaryStreamInfo[Index]->cbUsed += pDecoder->tBinaryStreamInfo[Index]->payload.cbPayloadSize;
							}
							else // Broken packet
							{
								pDecoder->tBinaryStreamInfo[Index]->cbUsed = 0;
								pDecoder->tBinaryStreamInfo[Index]->dwFrameLeft =0;
							}
						}
                
					}
            
     				pDecoder->tBinaryStreamInfo[Index]->parse_state = csWMCDecodeLoopStart;//csWMCDecodePayloadEnd;
			//		break;
		            return WMCDec_Succeeded;

				case csWMCDecodePayloadEnd:
					pDecoder->tBinaryStreamInfo[Index]->iPayload++;
					pDecoder->tBinaryStreamInfo[Index]->parse_state = csWMCDecodePayloadStart;
					break;

				case csWMCDecodeCompressedPayload: // Added by Amit to take care of compressed payloads
					// In this case store payload in buffer and dont return. Return only after one packet is finished
            
					if((pDecoder->tBinaryStreamInfo[Index]->bWantOutput == TRUE_WMC) &&(pDecoder->tBinaryStreamInfo[Index]->bNowStopReadingAndDecoding == FALSE_WMC))
					{
//						if(pDecoder->tBinaryStreamInfo[Index]->dwBinaryTimeStamp == 0)
							pDecoder->tBinaryStreamInfo[Index]->dwBinaryTimeStamp = (U32_WMC) pDecoder->tBinaryStreamInfo[Index]->payload.msObjectPres;
						pDecoder->tBinaryStreamInfo[Index]->dwPayloadOffset = (U32_WMC)pDecoder->tBinaryStreamInfo[Index]->cbCurrentPacketOffset + pDecoder->tBinaryStreamInfo[Index]->wPayStart;
						pDecoder->tBinaryStreamInfo[Index]->cbUsed = 0;
						pDecoder->tBinaryStreamInfo[Index]->cbFrame = pDecoder->tBinaryStreamInfo[Index]->dwNbFrames;
						pDecoder->tBinaryStreamInfo[Index]->dwFrameSize = 0; 

						pDecoder->tBinaryStreamInfo[Index]->dwPayloadOffset = (U32_WMC)pDecoder->tBinaryStreamInfo[Index]->cbCurrentPacketOffset + pDecoder->tBinaryStreamInfo[Index]->wPayStart;

//						pDecoder->tBinaryStreamInfo[Index]->dwBlockLeft     = pDecoder->tBinaryStreamInfo[Index]->nBlockAlign;
//						pDecoder->tBinaryStreamInfo[Index]->dwPayloadLeft = pDecoder->tBinaryStreamInfo[Index]->payload.cbPayloadSize - pDecoder->tBinaryStreamInfo[Index]->dwBlockLeft;
						pDecoder->tBinaryStreamInfo[Index]->payload.wBytesRead =0;
						pDecoder->tBinaryStreamInfo[Index]->payload.bSubPayloadState =1;

						cbWanted = 1; //to read subpayload length
						cbActual = WMCDecCBGetData(hDecoder, pDecoder->tBinaryStreamInfo[Index]->dwPayloadOffset, cbWanted, &pData, pDecoder->u32UserData);

						if(cbActual != cbWanted)
						{
							return WMCDec_BufferTooSmall;
						}
						
						
						pDecoder->tBinaryStreamInfo[Index]->dwFrameSize = pData[0];
                
					}
     				pDecoder->tBinaryStreamInfo[Index]->parse_state = csWMCDecodeLoopStart;//csWMCDecodePayloadEnd;
			//		break;
		            return WMCDec_Succeeded;

	//            default:
			}
        
		}while(1);
		break;
	}

    return err;
}


/*********************************************************************************************************/

tWMCDecStatus WMCDecDecodeFrameX( HWMCDECODER hDecoder, U16_WMC * pbDecoded, U32_WMC* pnNumberOfSamples,tMediaType_WMC MediaType, U16_WMC Index )
{
	tWMCDecStatus err = WMCDec_Succeeded;
    WMFDecoderEx *pDecoder;
    tWMVDecodeStatus  VidStatus;

    WMARESULT wmar = WMA_OK;
#ifndef __NO_SPEECH__
    WMSRESULT wmsr = WMS_OK;
#endif

    *pnNumberOfSamples =0;
    
    if (NULL == hDecoder)
        return WMCDec_InValidArguments;

    pDecoder = (WMFDecoderEx *) (hDecoder);

    switch(MediaType)
    {
    case Audio_WMC:
        if (pDecoder->tAudioStreamInfo[Index]->parse_state != csWMCEnd)
        {
            pDecoder->i32CurrentAudioStreamIndex = Index;
		   
            if (pDecoder->tAudioStreamInfo[Index]->bTobeDecoded == TRUE_WMC)
            {
        
                if (pDecoder->tAudioStreamInfo[Index]->nVersion >0 && pDecoder->tAudioStreamInfo[Index]->nVersion <4)
                {
                    if (pDecoder->tAudioStreamInfo[Index]->wmar != WMA_OK)
				    {
					    if (pDecoder->tAudioStreamInfo[Index]->wmar > 0)
					    {
                            if (pDecoder->tAudioStreamInfo[Index]->wmar == WMA_S_NO_MORE_FRAME)
                            {
                                wmar = WMARawDecStatus (pDecoder->tAudioStreamInfo[Index]->hMSA);
                            }
					    }
						else
					    {
						    WMARawDecReset (pDecoder->tAudioStreamInfo[Index]->hMSA);
						    pDecoder->tAudioStreamInfo[Index]->dwAudioBufDecoded = pDecoder->tAudioStreamInfo[Index]->dwAudioBufDecoded + pDecoder->tAudioStreamInfo[Index]->dwBlockLeft;
						    pDecoder->tAudioStreamInfo[Index]->dwBlockLeft =0;
						    wmar = WMARawDecStatus (pDecoder->tAudioStreamInfo[Index]->hMSA);
					    }
				    }
                    *pnNumberOfSamples = 8000;
                    wmar = WMARawDecDecodeData (pDecoder->tAudioStreamInfo[Index]->hMSA, (U32_WMARawDec *)pnNumberOfSamples
#ifdef _V9WMADEC_
                        , (I32_WMARawDec *)0
#endif
                        );
                    if (wmar == WMA_E_BROKEN_FRAME) 
				    {
					    WMARawDecReset (pDecoder->tAudioStreamInfo[Index]->hMSA);
					    pDecoder->tAudioStreamInfo[Index]->dwAudioBufDecoded = pDecoder->tAudioStreamInfo[Index]->dwAudioBufDecoded + pDecoder->tAudioStreamInfo[Index]->dwBlockLeft;
					    pDecoder->tAudioStreamInfo[Index]->dwBlockLeft =0;
					    wmar = WMARawDecStatus(pDecoder->tAudioStreamInfo[Index]->hMSA);
					    wmar = WMA_OK;
                    }

				    if (wmar == WMA_E_ONHOLD) 
				    {
					    wmar = WMA_OK;
                    }
                    if (wmar == WMA_E_LOSTPACKET) 
				    {
					    wmar = WMA_OK;
                    }
    
                    *pbDecoded = pDecoder->tAudioStreamInfo[Index]->wStreamId;
                    pDecoder->tAudioStreamInfo[Index]->wmar = wmar;
                }
#ifndef __NO_SPEECH__
                else if(pDecoder->tAudioStreamInfo[Index]->nVersion ==4 )//Speech Codec
                {
/*                       if (pDecoder->tAudioStreamInfo[Index]->wmsr != WMS_OK)
				    {
					    if (pDecoder->tAudioStreamInfo[Index]->wmsr > 0)
					    {
                            if (pDecoder->tAudioStreamInfo[Index]->wmsr == WMS_S_NO_MORE_FRAME)
                            {
                                wmsr = WMSRawDecStatus (pDecoder->tAudioStreamInfo[Index]->hMSA);
                            }
					    }
						else
					    {
						    WMSRawDecReset (pDecoder->tAudioStreamInfo[Index]->hMSA);
						    pDecoder->tAudioStreamInfo[Index]->dwAudioBufDecoded = pDecoder->tAudioStreamInfo[Index]->dwAudioBufDecoded + pDecoder->tAudioStreamInfo[Index]->dwBlockLeft;
						    pDecoder->tAudioStreamInfo[Index]->dwBlockLeft =0;
						    wmsr = WMSRawDecStatus (pDecoder->tAudioStreamInfo[Index]->hMSA);
					    }
				    }
*/                  
					*pnNumberOfSamples = 0;
                    wmsr = WMSRawDecDecodeData (pDecoder->tAudioStreamInfo[Index]->hMSA, (U32_WMARawDec *)pnNumberOfSamples);
                    if (wmsr == WMS_E_BROKEN_FRAME) 
				    {
					    WMSRawDecReset (pDecoder->tAudioStreamInfo[Index]->hMSA);
					    pDecoder->tAudioStreamInfo[Index]->dwAudioBufDecoded = pDecoder->tAudioStreamInfo[Index]->dwAudioBufDecoded + pDecoder->tAudioStreamInfo[Index]->dwBlockLeft;
					    pDecoder->tAudioStreamInfo[Index]->dwBlockLeft =0;
					    wmsr = WMARawDecStatus(pDecoder->tAudioStreamInfo[Index]->hMSA);
					    wmsr = WMS_OK;
                    }

				    if (wmsr == WMS_E_ONHOLD) 
				    {
					    wmsr = WMS_OK;
                    }
                    if (wmsr == WMS_E_LOSTPACKET) 
				    {
					    wmsr = WMS_OK;
                    }
    
                    *pbDecoded = pDecoder->tAudioStreamInfo[Index]->wStreamId;
//                        pDecoder->tAudioStreamInfo[Index]->wmsr = wmsr;
                }
#endif
            }
            else
            {
                *pbDecoded = pDecoder->tAudioStreamInfo[Index]->wStreamId;
//            	memcpy (pnNumberOfSamples,(pDecoder->tAudioStreamInfo[Index]->pbAudioBuffer + pDecoder->tAudioStreamInfo[Index]->dwAudioBufDecoded + sizeof(U32_WMC) ), sizeof(U32_WMC));

				if (pDecoder->tAudioStreamInfo[Index]->bOutputisReady == TRUE_WMC) // Last output is not taken out
				{
					//Fix buffers
					U8_WMC TempOutBuff[1024];
					U32_WMC cbBuffer=0;
					do
					{
						WMCRawGetData (TempOutBuff, &cbBuffer, hDecoder, (U32_WMC) 1024);
					}while(cbBuffer>0);
				
				}
				
				pDecoder->tAudioStreamInfo[Index]->bOutputisReady = TRUE_WMC;
				pDecoder->tAudioStreamInfo[Index]->bGotCompOutput = FALSE_WMC;

                *pnNumberOfSamples =pDecoder->tAudioStreamInfo[Index]->dwFrameSize;  
            }
        }
        else
        {
            *pbDecoded = 0xff;
			pDecoder->tAudioStreamInfo[Index]->dwAudioTimeStamp = (Double_WMC)0xffffffff;
			pDecoder->tAudioStreamInfo[Index]->dwAudPayloadPresTime = 0xffffffff;

        }
        break;
    case Video_WMC:
        if (pDecoder->tVideoStreamInfo[Index]->parse_state != csWMCEnd)
        {
            pDecoder->i32CurrentVideoStreamIndex = Index;
			if (pDecoder->tVideoStreamInfo[Index]->bTobeDecoded == TRUE_WMC)
            {
                if ((pDecoder->bSkipToNextI) && (pDecoder->tVideoStreamInfo[Index]->payload.bIsKeyFrame)) {
                        pDecoder->bSkipToNextI = FALSE_WMC;
                };
		                        
                if (pDecoder->bSkipToNextI) {
                    Bool_WMV bNotEndOfFrame = TRUE_WMV;
                    U8_WMV * pchBuffer = NULL;
                    U32_WMV uintActualBufferLength = 0;
                    while ((bNotEndOfFrame == TRUE_WMV)) {
                        WMVDecCBGetData ( (U32_WMV) pDecoder, 0,
                            &pchBuffer,
                            4,
                            &uintActualBufferLength,
                            &bNotEndOfFrame );
                        if ((pchBuffer == NULL) || (uintActualBufferLength ==0) )
                            bNotEndOfFrame = FALSE_WMV;
                    }
                    *pnNumberOfSamples = 0;
                    *pbDecoded = pDecoder->tVideoStreamInfo[Index]->wStreamId;
                    if (pDecoder->tVideoStreamInfo[Index]->parse_state == csWMCEnd)
                    {
                        *pbDecoded =0xff;
                        pDecoder->tVideoStreamInfo[Index]->dwNextVideoTimeStamp = 0xffffffff;
                        pDecoder->tVideoStreamInfo[Index]->dwVideoTimeStamp = 0xffffffff;
                        return WMCDec_Succeeded;
                    }
                }
                else 
                {

                    if(
                        pDecoder->tVideoStreamInfo[Index]->biCompression == FOURCC_WMV2 ||
                        pDecoder->tVideoStreamInfo[Index]->biCompression == FOURCC_WMV1 ||
                        pDecoder->tVideoStreamInfo[Index]->biCompression == FOURCC_WMS2 ||
                        pDecoder->tVideoStreamInfo[Index]->biCompression == FOURCC_WMS1 ||
                        pDecoder->tVideoStreamInfo[Index]->biCompression == FOURCC_M4S2 ||
                        pDecoder->tVideoStreamInfo[Index]->biCompression == FOURCC_MP4S ||
                        pDecoder->tVideoStreamInfo[Index]->biCompression == FOURCC_MP43 ||
                        pDecoder->tVideoStreamInfo[Index]->biCompression == FOURCC_MP42 ||
                        pDecoder->tVideoStreamInfo[Index]->biCompression == FOURCC_MPG4 )
                    
                    {    
                    
                    
                        VidStatus = WMVideoDecDecodeData ((HWMVDecoder)pDecoder->tVideoStreamInfo[Index]->pVDec, (U16_WMV *)pnNumberOfSamples);
                        if (WMV_Succeeded == VidStatus)
                        {
                            *pbDecoded = pDecoder->tVideoStreamInfo[Index]->wStreamId;
                            *pnNumberOfSamples =1;
                        }
                        else
                        {
                            if (pDecoder->tVideoStreamInfo[Index]->parse_state == csWMCEnd)
							{
								*pbDecoded =0xff;
								pDecoder->tVideoStreamInfo[Index]->dwNextVideoTimeStamp = 0xffffffff;
								pDecoder->tVideoStreamInfo[Index]->dwVideoTimeStamp = 0xffffffff;
								return WMCDec_Succeeded;
							}
										

							//WMVideoDecReset((HWMVDecoder)pDecoder->tVideoStreamInfo[Index]->pVDec);
						    pDecoder->tVideoStreamInfo[Index]->dwVideoBufDecoded += pDecoder->tVideoStreamInfo[Index]->dwBlockLeft;
						    pDecoder->tVideoStreamInfo[Index]->dwBlockLeft =0;
							*pbDecoded = pDecoder->tVideoStreamInfo[Index]->wStreamId;
							switch(VidStatus)
							{
							case WMV_Failed :
								return WMVDec_Failed;
							case WMV_BadMemory:
								return WMVDec_BadMemory;
							case WMV_NoKeyFrameDecoded:
								return WMVDec_NoKeyFrameDecoded;
							case WMV_CorruptedBits:
								return WMVDec_CorruptedBits;
							case WMV_BrokenFrame:
								return WMVDec_BrokenFrame;
							default:
								return WMVDec_Failed; 
							}
                        }
                    }
#ifndef __NO_SCREEN__
                    else if(pDecoder->tVideoStreamInfo[Index]->biCompression == FOURCC_MSS1 ||
					        pDecoder->tVideoStreamInfo[Index]->biCompression == FOURCC_MSS2)
                    {
                        
                        tWMCDecStatus TempStatus;
                        TempStatus = WMScDecodeData (hDecoder, Index);
                        if (WMCDec_Succeeded == TempStatus)
                        {
                            *pbDecoded = pDecoder->tVideoStreamInfo[Index]->wStreamId;
                            *pnNumberOfSamples =1;
                        }
                        else
                        {
                            if (pDecoder->tVideoStreamInfo[Index]->parse_state == csWMCEnd)
							{
								*pbDecoded =0xfe;
								pDecoder->tVideoStreamInfo[Index]->dwNextVideoTimeStamp = 0xffffffff;
								pDecoder->tVideoStreamInfo[Index]->dwVideoTimeStamp = 0xffffffff;
								return WMCDec_Succeeded;
							}
                        
                            *pbDecoded = pDecoder->tVideoStreamInfo[Index]->wStreamId;
						    pDecoder->tVideoStreamInfo[Index]->dwVideoBufDecoded += pDecoder->tVideoStreamInfo[Index]->dwBlockLeft;
						    pDecoder->tVideoStreamInfo[Index]->dwBlockLeft =0;
                            return WMVDec_Failed; 
                        }
                    
                    }
#endif
                }
            }
            else
            {
                *pbDecoded = pDecoder->tVideoStreamInfo[Index]->wStreamId;
				if (pDecoder->tVideoStreamInfo[Index]->bOutputisReady == TRUE_WMC) // Last output is not taken out
				{
					//Fix buffers
					U8_WMC TempOutBuff[1024];
					U32_WMC cbBuffer=0;
					do
					{
						WMCRawGetVideoData (TempOutBuff, &cbBuffer, hDecoder, (U32_WMC) 1024);
					}while(cbBuffer>0);
				
				}
				
				pDecoder->tVideoStreamInfo[Index]->bGotCompOutput = FALSE_WMC;
				pDecoder->tVideoStreamInfo[Index]->bOutputisReady = TRUE_WMC;

				//                   *pnNumberOfSamples =1;  // To be changed. Should be no of bytes
//		        memcpy (pnNumberOfSamples,(pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer + pDecoder->tVideoStreamInfo[Index]->dwVideoBufDecoded + 2*sizeof(U32_WMC) ), sizeof(U32_WMC));
                *pnNumberOfSamples = pDecoder->tVideoStreamInfo[Index]->dwFrameSize;//pDecoder->tVideoStreamInfo[Index]->payload.cbObjectSize;
            }


        }
        else
        {
            *pbDecoded = 0xff;
			pDecoder->tVideoStreamInfo[Index]->dwNextVideoTimeStamp = 0xffffffff;
			pDecoder->tVideoStreamInfo[Index]->dwVideoTimeStamp = 0xffffffff;
        }
        
		pDecoder->tVideoStreamInfo[Index]->bHasGivenAnyOutput = TRUE_WMC;
//		pDecoder->tVideoStreamInfo[Index]->dwVideoTimeStamp = dwMinVideoPresTime;
        break;
    case Binary_WMC:
        if (pDecoder->tBinaryStreamInfo[Index]->parse_state != csWMCEnd)
        {
            *pbDecoded = pDecoder->tBinaryStreamInfo[Index]->wStreamId;
            pDecoder->i32CurrentBinaryStreamIndex = Index;
//                *pnNumberOfSamples =1;  // To be changed. Should be no of bytes
//		    memcpy (pnNumberOfSamples,(pDecoder->tBinaryStreamInfo[Index]->pbBinaryBuffer + pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufDecoded + sizeof(U32_WMC) ), sizeof(U32_WMC));

			if (pDecoder->tBinaryStreamInfo[Index]->bOutputisReady == TRUE_WMC) // Last output is not taken out
			{
				//Fix buffers
				U8_WMC TempOutBuff[1024];
				U32_WMC cbBuffer=0;
				do
				{
					WMCRawGetBinaryData (TempOutBuff, &cbBuffer, hDecoder, (U32_WMC) 1024);
				}while(cbBuffer>0);
			
			}
			
			
			pDecoder->tBinaryStreamInfo[Index]->bGotCompOutput = FALSE_WMC;
			pDecoder->tBinaryStreamInfo[Index]->bOutputisReady = TRUE_WMC;
            *pnNumberOfSamples = pDecoder->tBinaryStreamInfo[Index]->dwFrameSize;

        }
        else
        {
			pDecoder->tBinaryStreamInfo[Index]->dwBinaryTimeStamp = 0xffffffff;
            *pbDecoded = 0xff;
        }
		pDecoder->tBinaryStreamInfo[Index]->bHasGivenAnyOutput = TRUE_WMC;
        break;
    default:
        *pbDecoded = 0xff;        
    }
    return WMCDec_Succeeded;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



tWMCDecStatus WMCDecGetStreamToSpecificPosition (HWMCDECODER hWMCDec, U16_WMC wStreamId, U64_WMC u64TimeRequest, U64_WMC* pu64TimeReturn)
{
	U64_WMC cbPacketOffset =0;
    U8_WMC i=0, j=0;
	tWMCDecStatus rc = WMCDec_Succeeded;
    U32_WMC dwToIndexEntry =0;
    WMCINDEXENTRIES* pTempIndexEntry = NULL_WMC;
    U32_WMC dwPacketToGo =0;
    U32_WMC dwNewPacketToGo =0;
    tMediaType_WMC MediaType;
	U32_WMC cbCurrentPacketOffset =0;
	PACKET_PARSE_INFO_EX ParseInfoEx;
	PAYLOAD_MAP_ENTRY_EX Payload;
	U32_WMC iPayload =0;
	U64_WMC u64LocalTimeRequest =0;
	U64_WMC u64LastPresTime = 0;
	Bool_WMC bFirst = FALSE_WMC;
	Bool_WMC bDone = FALSE_WMC;
	U16_WMC Index = 0;
	Bool_WMC bGotIndex = FALSE_WMC;


    WMFDecoderEx* pDecoder = (WMFDecoderEx*) hWMCDec;
    if (pDecoder == NULL_WMC || pu64TimeReturn == NULL_WMC)
        return WMCDec_InValidArguments;


	rc = WMCDecGetMediaType (hWMCDec, (U16_WMC) wStreamId, &MediaType);
	if (WMCDec_Succeeded !=rc)
		return WMCDec_InValidArguments;
	
	
	switch(MediaType)
	{
	case Audio_WMC:
		for(j=0; j<pDecoder->tHeaderInfo.wNoOfAudioStreams; j++)
		{
			if( pDecoder->tAudioStreamInfo[j]->wStreamId == wStreamId)
			{
				Index =j;
				bGotIndex = TRUE_WMC;
			}
		}
		break;
	case Video_WMC:
		for(j=0; j<pDecoder->tHeaderInfo.wNoOfVideoStreams; j++)
		{
			if(pDecoder->tVideoStreamInfo[j]->wStreamId == wStreamId)
			{
				Index = j;
				bGotIndex = TRUE_WMC;
			}

		}
		break;
	case Binary_WMC:
		for(j=0; j<pDecoder->tHeaderInfo.wNoOfBinaryStreams; j++)
		{
			if(pDecoder->tBinaryStreamInfo[j]->wStreamId == wStreamId)
			{
				Index = j;
				bGotIndex = TRUE_WMC;
			}
		}
		break;
	default:
		return WMCDec_InValidArguments;
	}

	if (bGotIndex == FALSE_WMC )
		return WMCDec_InValidArguments;


	memset(&ParseInfoEx, 0, sizeof (PACKET_PARSE_INFO_EX));
	memset(&Payload, 0, sizeof (PAYLOAD_MAP_ENTRY_EX));

	*pu64TimeReturn = 0;
	
	u64TimeRequest= u64TimeRequest + (U64_WMC)pDecoder->tHeaderInfo.msPreroll ;
    if (pDecoder->cTotalIndexs >0)
    {
		for(i=0; i< pDecoder->cTotalIndexs ; i++)
		{
			if (pDecoder->tIndexInfo[i].nStreamId == wStreamId)
			{
				rc = WMCDecGetMediaType (hWMCDec, (U16_WMC) wStreamId, &MediaType);
				if (WMCDec_Succeeded !=rc)
					return rc;
 
				switch(MediaType)
				{
				case Audio_WMC:
					for(j=0; j<pDecoder->tHeaderInfo.wNoOfAudioStreams; j++)
					{
					
						if( pDecoder->tIndexInfo[i].nStreamId == wStreamId)
						{
                    
							u64LocalTimeRequest = u64TimeRequest;
							dwToIndexEntry = (U32_WMC)(u64LocalTimeRequest/pDecoder->tIndexInfo[i].time_deltaMs);
							if (dwToIndexEntry > pDecoder->tIndexInfo[i].num_entries )
								return WMCDec_InValidArguments;
							pTempIndexEntry = pDecoder->tIndexInfo[i].pIndexEntries;
							pTempIndexEntry+=dwToIndexEntry;
							dwPacketToGo = pTempIndexEntry->dwPacket;
							if (dwPacketToGo > pDecoder->tHeaderInfo.cPackets)
								return WMCDec_InValidArguments;
						}
					}
					break;
				case Video_WMC:
					for(j=0; j<pDecoder->tHeaderInfo.wNoOfVideoStreams; j++)
					{
						if(pDecoder->tIndexInfo[i].nStreamId == wStreamId)
						{
							u64LocalTimeRequest = u64TimeRequest /*+(U64_WMC)pDecoder->tIndexInfo[i].time_deltaMs*999/1000*/;
							dwToIndexEntry = (U32_WMC)(u64LocalTimeRequest/pDecoder->tIndexInfo[i].time_deltaMs);
							if (dwToIndexEntry > pDecoder->tIndexInfo[i].num_entries )
								return WMCDec_InValidArguments;
							pTempIndexEntry = pDecoder->tIndexInfo[i].pIndexEntries;
							pTempIndexEntry+=dwToIndexEntry;
							dwPacketToGo = pTempIndexEntry->dwPacket;
							if (dwPacketToGo > pDecoder->tHeaderInfo.cPackets)
								return WMCDec_InValidArguments;
						}
        
					}
					break;
				case Binary_WMC:
					for(j=0; j<pDecoder->tHeaderInfo.wNoOfBinaryStreams; j++)
					{
						if(pDecoder->tIndexInfo[i].nStreamId == wStreamId)
						{
							u64LocalTimeRequest = u64TimeRequest;
							dwToIndexEntry = (U32_WMC)(u64LocalTimeRequest/pDecoder->tIndexInfo[i].time_deltaMs);
							if (dwToIndexEntry > pDecoder->tIndexInfo[i].num_entries )
								return WMCDec_InValidArguments;
							pTempIndexEntry = pDecoder->tIndexInfo[i].pIndexEntries;
							pTempIndexEntry+=dwToIndexEntry;
							dwPacketToGo = pTempIndexEntry->dwPacket;
							if (dwPacketToGo > pDecoder->tHeaderInfo.cPackets)
								return WMCDec_InValidArguments;
						}
					}
					break;
				default:
					return WMCDec_InValidArguments;

				}
			}
		}
		
		if (dwPacketToGo >0)
			dwPacketToGo-=1;
    }


	do
	
	{
		U32_WMC dwCompPresTime =0;
	    U8_WMC *pData = NULL;
		U32_WMC dwOffset =0;
		U8_WMC bNextSubPayloadSize=0;
		U16_WMC wBytesRead=0;
		U32_WMC cbActual =0;
		
		cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbHeader  + (dwPacketToGo * pDecoder->tHeaderInfo.cbPacketSize);
		rc = WMCDecParseVirtualPacketHeader(hWMCDec, cbCurrentPacketOffset, &ParseInfoEx);


		for (iPayload = 0; iPayload < ParseInfoEx.cPayloads; iPayload++)
		{
        
			rc = WMCDecParseVirtualPayloadHeader(hWMCDec, cbCurrentPacketOffset, &ParseInfoEx, &Payload);
			if (rc != WMCDec_Succeeded)
				return rc;

			if (wStreamId == Payload.bStreamId)
			{
				if (bFirst == FALSE_WMC)
				{
					u64LastPresTime = (U64_WMC) Payload.msObjectPres;
					bFirst = TRUE_WMC;
				}
				
				
				if (Payload.cbRepData == 1)
				{
				
					dwOffset = Payload.cbPacketOffset + Payload.cbTotalSize - Payload.cbPayloadSize;
				    cbActual = WMCDecCBGetData(hWMCDec, cbCurrentPacketOffset + dwOffset, Payload.cbPayloadSize, &pData, pDecoder->u32UserData);

					dwCompPresTime = Payload.msObjectPres;
					bNextSubPayloadSize = pData [0];
					pData +=1;
//					if (pPay->wTotalDataBytes < bNextSubPayloadSize)
//						return WMPERR_FAIL;

					if( Payload.wTotalDataBytes > bNextSubPayloadSize)
						wBytesRead = bNextSubPayloadSize+1;
					else if (Payload.wTotalDataBytes == bNextSubPayloadSize)
						wBytesRead = bNextSubPayloadSize;
										
					while (Payload.wTotalDataBytes >= wBytesRead) 
					{

						if (dwCompPresTime >= u64TimeRequest)
						{
							*pu64TimeReturn = u64LastPresTime - (U64_WMC)pDecoder->tHeaderInfo.msPreroll;
							bDone = TRUE_WMC;
							break;
						}
						else
						{
							u64LastPresTime = (U64_WMC) dwCompPresTime;
						//	continue;
						}
						pData += bNextSubPayloadSize;
						bNextSubPayloadSize = pData[0];
						wBytesRead+=bNextSubPayloadSize+1;
						pData+=1;
						dwCompPresTime+=Payload.dwDeltaPresTime;
					}
					
					if (bDone == TRUE_WMC)
						break;
				}				
				else
				{
					if (Payload.msObjectPres >= u64TimeRequest)
					{
						*pu64TimeReturn = u64LastPresTime - (U64_WMC)pDecoder->tHeaderInfo.msPreroll;
						bDone = TRUE_WMC;
						break;
					}
					else
					{
						u64LastPresTime = (U64_WMC) Payload.msObjectPres;
						continue;
					}
				}
			}

		}
		dwPacketToGo++;
	}while((bDone == FALSE_WMC) && (dwNewPacketToGo <=pDecoder->tHeaderInfo.cPackets));


	if (bDone == TRUE_WMC)
	{

		switch(MediaType)
		{
		case Audio_WMC:

//			pDecoder->tAudioStreamInfo[Index]->cbPacketOffset = cbCurrentPacketOffset;
			pDecoder->tAudioStreamInfo[Index]->cbCurrentPacketOffset = cbCurrentPacketOffset;
			pDecoder->tAudioStreamInfo[Index]->cbNextPacketOffset = cbCurrentPacketOffset;
			pDecoder->tAudioStreamInfo[Index]->parse_state = csWMCNewAsfPacket;
			break;
		case Video_WMC:
//			pDecoder->tVideoStreamInfo[Index]->cbPacketOffset = cbCurrentPacketOffset;
			pDecoder->tVideoStreamInfo[Index]->cbCurrentPacketOffset = cbCurrentPacketOffset;
			pDecoder->tVideoStreamInfo[Index]->cbNextPacketOffset = cbCurrentPacketOffset;
			pDecoder->tVideoStreamInfo[Index]->parse_state = csWMCNewAsfPacket;
			break;
		case Binary_WMC:
//			pDecoder->tBinaryStreamInfo[Index]->cbPacketOffset = cbCurrentPacketOffset;
			pDecoder->tBinaryStreamInfo[Index]->cbCurrentPacketOffset = cbCurrentPacketOffset;
			pDecoder->tBinaryStreamInfo[Index]->cbNextPacketOffset = cbCurrentPacketOffset;
			pDecoder->tBinaryStreamInfo[Index]->parse_state = csWMCNewAsfPacket;
			break;
		default:
			return WMCDec_InValidArguments;
		}
	}
	
	return rc;

}









#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\AutoProfile.h ===
#if !defined(_AUTO_PROFILE_INCLUDED_)
#define _AUTO_PROFILE_INCLUDED_

#if defined(PROFILE) 

#define WIN32_LEAN_AND_MEAN

#pragma warning( disable : 4103 4142 )
#include <windows.h>   
#pragma warning( default : 4103 4142 )
#include <stdlib.h>
#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

#define MAX_FUNCTIONS_TO_PROFILE 100

typedef struct  
{
    int id;
    TCHAR name[80];
}ProfileFunctionDeffinitionType;

extern ProfileFunctionDeffinitionType functionDefintions[MAX_FUNCTIONS_TO_PROFILE];
extern int Profiler_functionCountCalls[];


#define FFT_PROFILE 1
#define INVERSE_QUAN_HIGH_RATE_PROFILE 2
#define INVERSE_TRANSFORM_AND_RECON_PROFILE 3
#define INVERSE_OUANTIZE_SPECTRUM_PROFILE 4
#define DCTIV_PROFILE 5
#define POWER_TO_RMS_PROFILE 6 
#define ADAPT_TO_SUB_FRAME_CONFIG_PROFILE 7
#define INVERSE_TRANSFORM_MONO_PROFILE 8
#define DECODE_FRAME_HEADER_PROFILE 9
#define DECODE_COEFFICENT_MONO_PROFILE 10
#define DECODE_COEFFICENT_STEREO_PROFILE 11
#define DECODE_RUN_LEVEL_PROFILE 12
#define SET_DET_TABLE_PROFILE 13
#define DECODE_SUB_FRAME_PROFILE 14
#define UPDATE_SUB_FRAME_CONFIG_PROFILE 15
#define CALC_QUANT_STEP_PROFILE 16
#define DECODE_FRAME_PROFILE 17
#define DECODE_PACKET_PROFILE 18 
#define DECODE_PROFILE 19
#define CONVERT_SD_TO_LR_PROFILE 20
#define HUFF_DEC_GET_PROFILE 21
#define MSAC_DECODE_PROFILE 22
#define INVERSE_QUAN_HIGH_SDTOLR_PROFILE 23
#define SAVE_HISTORY_MONO_PROFILE 24

#define FRAME_HEADER_LPC_PROFILE 25
#define FRAME_HEADER_NOISE_SUB_PROFILE 26
#define GET_BAND_WEIGHTS_PROFILE 27
#define INVERSE_QUAN_LOW_RATE_PROFILE 28
#define INVERSE_QUAN_MID_RATE_PROFILE 29

#define WMA_FILE_DECODE_DATA_PROFILE 30
#define AU_GET_PCM_PROFILE 31
#define RECON_MONO_PROFILE 32
#define AUDEC_DECODE_DATA_PROFILE 33
#define WMA_FILE_GET_PCM_PROFILE 34
#define DECODE_COEFFICENTS_HIGH_RATE_PROFILE 35
#define DECODE_SUB_FRAME_HIGH_RATE_PROFILE 36
#define LPC_TO_SPECTRUM_PROFILE 37
#define FFT32_PROFILE 38

#if 1
#define Profiler_getTimer(ptime64) QueryPerformanceCounter((LARGE_INTEGER*)ptime64)
#else
__inline __int64 Profiler_getTimer(__int64 *time64)
{
    __int64 time;
    QueryPerformanceCounter((LARGE_INTEGER*)&time);
    *time64 = time;
    return time;
}
#endif
 
extern void Profiler_init(TCHAR* szFileName);
extern void Profiler_initEX(TCHAR* szFileName,int fAppend);
extern void Profiler_close();
extern void Profiler_closeEX(unsigned int Duration, DWORD TotalTime, TCHAR* szMsg);
extern void Profiler_print(TCHAR* szMsg);

typedef struct 
{
    __int64 StartTime;
    int functionIndex;
    void *parent;
}FunctionProfile;

extern __int64 Profiler_functionTimings[MAX_FUNCTIONS_TO_PROFILE];
extern __int64 Profiler_functionPlusChildTimings[MAX_FUNCTIONS_TO_PROFILE];
extern __int64 Profiler_totalTime;
extern __int64 profileStartTime;
extern HANDLE hProfile;
extern FunctionProfile *Profiler_lastFunctionProfiler;



void Profile_print(TCHAR* fmt);


__inline void FunctionProfileStart(FunctionProfile *fp, int FunctionID) 
{
    Profiler_getTimer(&fp->StartTime);
    fp->functionIndex = FunctionID;
    fp->parent = Profiler_lastFunctionProfiler;
    Profiler_lastFunctionProfiler = fp;
	Profiler_functionCountCalls[FunctionID]++;
};

__inline void FunctionProfileStop(FunctionProfile *fp){
    __int64 endTime;
    __int64 time;
    Profiler_getTimer(&endTime);
    time = (int)(endTime-fp->StartTime);
    
    Profiler_functionTimings[fp->functionIndex] += time;

    if (fp->parent != NULL) {
        Profiler_functionTimings[((FunctionProfile*)(fp->parent))->functionIndex] -= time;
    } else {
        Profiler_totalTime+=time; 
    }

    Profiler_functionPlusChildTimings[fp->functionIndex] += time;
    Profiler_lastFunctionProfiler = ((FunctionProfile*)(fp->parent));
}

#define FUNCTION_PROFILE(fp) FunctionProfile fp;
#define FUNCTION_PROFILE_START(fp,id) FunctionProfileStart(fp,id)
#define FUNCTION_PROFILE_STOP(fp) FunctionProfileStop(fp)

#ifdef __cplusplus
}
#endif

#else	// !PROFILE

#define FUNCTION_PROFILE(fp)
#define FUNCTION_PROFILE_START(fp,id)
#define FUNCTION_PROFILE_STOP(fp)

#endif	// !PROFILE

#endif  // !defined(_AUTO_PROFILE_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\wmvdec.cpp ===
#include "bldsetup.h"

#include "xplatform.h"
#include "wmvdec_api.h"
#include "wmvdec_member.h"
#include "wmvdec_function.h"
#include "constants_wmv.h"
#include "tables_wmv.h"

#include "stdlib.h"
#include "malloc.h"

#ifdef UNDER_CE
#undef assert
#define assert ASSERT
#else
#include "assert.h"
#endif

#include "memory.h"

#ifdef _WMV_TARGET_X86_
#include "cpudetect.h"
#endif // _WMV_TARGET_X86_
#include "math.h"

// ===========================================================================
// private functions
// ===========================================================================
#include "strmdec_wmv.hpp"
#include "repeatpad_wmv.h"

Void_WMV (*g_pRepeatRef0Y) (RepeatRef0YArgs);
Void_WMV (*g_pRepeatRef0UV) (RepeatRef0UVArgs);

// mingcl: don't delete these two.  These are for hacking the display of the video info in the player.
int g_iIFrame = 0;
int g_iQP = 0;

tWMVDecodeStatus WMVideoDecInit (
    HWMVDecoder* phWMVDecoder,
    U32_WMV uiUserData,
    U32_WMV uiFOURCCCompressed,
    Float_WMV fltFrameRate,
    Float_WMV fltBitRate,
    I32_WMV iWidthSource,
    I32_WMV iHeightSource,
    I32_WMV iPostFilterLevel
) 
{
    tWMVDecodeStatus tWMVStatus = WMV_Succeeded;
    tWMVDecInternalMember *pWMVDec; 


    pWMVDec = (tWMVDecInternalMember*) wmvalloc (sizeof (tWMVDecInternalMember));
//    pWMVDec = (tWMVDecInternalMember*) new tWMVDecInternalMember;
    if (pWMVDec == NULL_WMV) {
        *phWMVDecoder = NULL_WMV;
        return WMV_BadMemory;
    }

//    pWMVDec -> m_pInputBitstream = new CInputBitStream_WMV (uiUserData);
    pWMVDec -> m_pInputBitstream = (CInputBitStream_WMV *)wmvalloc(sizeof( CInputBitStream_WMV));
    if (!pWMVDec -> m_pInputBitstream ) {
        return WMV_BadMemory;
    }
    DEBUG_HEAP_ADD( 0, sizeof(CInputBitStream_WMV) ); 

    BS_construct(pWMVDec -> m_pInputBitstream, uiUserData);

    //memset (pWMVDec, 0, sizeof (tWMVDecInternalMember));
    tWMVStatus = WMVInternalMemberInit (
        pWMVDec, 
        uiUserData,
        uiFOURCCCompressed,
        fltFrameRate,
        fltBitRate,
        iWidthSource,
        iHeightSource,
        iPostFilterLevel
    );

    if (tWMVStatus == WMV_Succeeded)
        *phWMVDecoder = (HWMVDecoder) pWMVDec;
    else 
        *phWMVDecoder = NULL_WMV;

    return tWMVStatus;
}


tWMVDecodeStatus WMVideoDecClose (HWMVDecoder phWMVDecoder)
{
    tWMVDecodeStatus tWMVStatus = WMV_Succeeded;
    tWMVDecInternalMember *pWMVDec; 

    if (phWMVDecoder == NULL_WMV)
        return WMV_InValidArguments;
    pWMVDec = (tWMVDecInternalMember*) phWMVDecoder;
    tWMVStatus = WMVInternalMemberDestroy (pWMVDec);
    // NOTE (JHarding, 1/14/02): This pointer was allocated w/ "wmvalloc"
    // above, but released with "delete" right here.
    wmvfree( pWMVDec );
    // delete pWMVDec;

    if (tWMVStatus == WMV_Succeeded) {
        phWMVDecoder = NULL_WMV;
    }

    return tWMVStatus;
}


tWMVDecodeStatus WMVideoDecDecodeSequenceHeader (HWMVDecoder hWMVDecoder)
{

    tWMVDecodeStatus tWMVStatus = WMV_Succeeded;
    tWMVDecInternalMember *pWMVDec;
//    I32_WMV iTmp;
    U32_WMV uiBufferLengthFromCaller;
    U8_WMV* pucBufferBits;
    Bool_WMV bNotEndOfFrame = TRUE;

    if (hWMVDecoder == NULL_WMV)
        return WMV_InValidArguments;
    pWMVDec = (tWMVDecInternalMember*) (hWMVDecoder);
	
	WMVDecCBGetData (pWMVDec->m_uiUserData, 0, (U8_WMV**) &pucBufferBits, 4, &uiBufferLengthFromCaller, &bNotEndOfFrame);
    if (bNotEndOfFrame){
        if (uiBufferLengthFromCaller == 0 || pucBufferBits == NULL){
            return WMV_BrokenFrame;
        }
    }
    BS_reset(pWMVDec->m_pInputBitstream, (U8_WMV*)pucBufferBits, uiBufferLengthFromCaller, bNotEndOfFrame);
    if (pWMVDec->m_cvCodecVersion == WMV2)
        decodeVOLHead (pWMVDec);
    else // MP4S
        decodeVOLHeadMP4S (pWMVDec);

/*
    assert (uiBufferLengthFromCaller == 4); // expect to get 4 bytes since this is small.
    StreamParserAttach (pucBufferBits, uiBufferLengthFromCaller);
    iTmp = StreamParse (pWMVDec->m_pStrmParse, 5);
    if (pWMVDec->m_fltFrameRate == 0.0F)
        pWMVDec->m_fltFrameRate = (Float_WMV) iTmp;
    iTmp = StreamParse (pWMVDec->m_pStrmParse, 11);
    if (pWMVDec->m_fltBitRate == 0.0F)
        pWMVDec->m_fltBitRate = (Float_WMV) iTmp;

    pWMVDec->m_bMixedPel = StreamParse (pWMVDec->m_pStrmParse, 1);
    pWMVDec->m_bLoopFilter = StreamParse (pWMVDec->m_pStrmParse, 1);
    pWMVDec->m_bXformSwitch = StreamParse (pWMVDec->m_pStrmParse, 1);
    pWMVDec->m_bXintra8Switch = StreamParse (pWMVDec->m_pStrmParse, 1);
    pWMVDec->m_bFrmHybridMVOn = StreamParse (pWMVDec->m_pStrmParse, 1);

    // DCTTABLE S/W at MB level for WMV2.
    pWMVDec->m_bDCTTable_MB_ENABLED = StreamParse (pWMVDec->m_pStrmParse, 1);
    pWMVDec->m_iSliceCode = StreamParse (pWMVDec->m_pStrmParse, NUMBITS_SLICE_SIZE_WMV2);
*/
    return tWMVStatus;
}

tWMVDecodeStatus WMVideoDecReset (HWMVDecoder hWMVDecoder)
{
    tWMVDecodeStatus tWMVStatus = WMV_Succeeded;
    tWMVDecInternalMember *pWMVDec; 

    if (hWMVDecoder == NULL_WMV)
        return WMV_InValidArguments;
    pWMVDec = (tWMVDecInternalMember*) (hWMVDecoder);

    return WMV_Succeeded;
}

#ifdef _COUNT_CYCLES_
__int64 DecodeAndLockTmr = 0;
__int64 HrTmrGet (void)
{
  __asm rdtsc;
}
#endif

tWMVDecodeStatus WMVideoDecDecodeData (HWMVDecoder hWMVDecoder, U16_WMV* puiNumDecodedFrames)
{
#ifdef _COUNT_CYCLES_
    DecodeAndLockTmr -= HrTmrGet ();
#endif

    *puiNumDecodedFrames = 0;
    tWMVDecodeStatus tWMVStatus = WMV_Succeeded;
    tWMVDecInternalMember *pWMVDec; 
    U32_WMV uiBufferLengthFromCaller;
    U8_WMV* pucBufferBits;
	Bool_WMV bNotEndOfFrame = TRUE;

    if (hWMVDecoder == NULL_WMV)
        return WMV_InValidArguments;
    pWMVDec = (tWMVDecInternalMember*) (hWMVDecoder);

    FUNCTION_PROFILE_DECL_START(fp,WMVDECODEDATA_PROFILE);

    WMVDecCBGetData (pWMVDec->m_uiUserData, 0, (U8_WMV**) &pucBufferBits, 4, &uiBufferLengthFromCaller, &bNotEndOfFrame);
    if (bNotEndOfFrame){
        if (uiBufferLengthFromCaller == 0 || pucBufferBits == NULL){
            return WMV_BrokenFrame;
        }
    }
    BS_reset(pWMVDec -> m_pInputBitstream, (U8_WMV*)pucBufferBits, uiBufferLengthFromCaller, bNotEndOfFrame);

    tWMVStatus = WMVideoDecDecodeFrameHead (pWMVDec);
    if (tWMVStatus != WMV_Succeeded){
        FUNCTION_PROFILE_STOP(&fp);
        return tWMVStatus;
    }
    pWMVDec->m_bFirstEscCodeInFrame = TRUE_WMV;
    // Can't do anything unless we've seen an I-Picture go by
    if (pWMVDec->m_tFrmType == IVOP)
        pWMVDec->m_fDecodedI = TRUE_WMV;
    else if (!pWMVDec->m_fDecodedI) {
        FUNCTION_PROFILE_STOP(&fp);
        return WMV_NoKeyFrameDecoded;
    }
g_iQP = pWMVDec->m_iStepSize;

    if (pWMVDec->m_tFrmType == IVOP) {
g_iIFrame = 1;

#ifdef _SUPPORT_POST_FILTERS_ 
#ifdef _WMV_TARGET_X86_
        WMVDecideDeblokLevel (pWMVDec, pWMVDec->m_iWidthY, pWMVDec->m_iHeightY);
#else
        if (pWMVDec->m_iPostFilterLevel < 0 || pWMVDec->m_iPostFilterLevel >= 5)
            pWMVDec->m_iPostFilterLevel = 0;
        pWMVDec->m_iPostProcessMode = pWMVDec->m_iPostFilterLevel;
#endif
        AssignDeblokRoutines (pWMVDec);
#endif

        if (pWMVDec->m_bXintra8)
            tWMVStatus = WMVideoDecDecodeI_X8 (pWMVDec);
        else
            tWMVStatus = pWMVDec->m_pDecodeI (pWMVDec); //WMVideoDecDecodeI (pWMVDec);
        if (tWMVStatus != WMV_Succeeded) {
            FUNCTION_PROFILE_STOP(&fp);
            return tWMVStatus;
        }
        if (pWMVDec->m_cvCodecVersion != MP4S) { //m_uiFOURCCCompressed 
            if (pWMVDec->m_cvCodecVersion == MP42 || pWMVDec->m_cvCodecVersion == MP43) 
                tWMVStatus = WMVideoDecDecodeClipInfo (pWMVDec);
            if (tWMVStatus != WMV_Succeeded) {
                FUNCTION_PROFILE_STOP(&fp);
                return tWMVStatus;
            }
        }
    }
    else { // P-VOP
g_iIFrame = 0;
        WMVideoDecAssignMotionCompRoutines (pWMVDec);
        WMVideoDecSwapCurrAndRef (pWMVDec);
        if(EXPANDY_REFVOP!=0)
        {
            (*g_pRepeatRef0Y) (pWMVDec->m_ppxliRef0Y,0,pWMVDec->m_iHeightYRepeatPad,pWMVDec->m_iWidthPrevYXExpPlusExp,TRUE_WMV,TRUE_WMV,pWMVDec->m_iWidthYRepeatPad,pWMVDec->m_iWidthYPlusExp,pWMVDec->m_iWidthPrevY);
#ifndef OUTPUT_GRAY4
            (*g_pRepeatRef0UV) (pWMVDec->m_ppxliRef0U,pWMVDec->m_ppxliRef0V,0,pWMVDec->m_iHeightUVRepeatPad,pWMVDec->m_iWidthPrevUVXExpPlusExp,TRUE_WMV,TRUE_WMV,pWMVDec->m_iWidthUVRepeatPad,pWMVDec->m_iWidthUVPlusExp,pWMVDec->m_iWidthPrevUV);
#endif
        }

        tWMVStatus = pWMVDec->m_pDecodeP (pWMVDec); //WMVideoDecDecodeP (pWMVDec);
        if (tWMVStatus != WMV_Succeeded) {
            FUNCTION_PROFILE_STOP(&fp);
            return tWMVStatus;
        }
    }
    pWMVDec->m_uiNumFramesLeftForOutput = 1; // 1 frame ready to output after decoding.
    *puiNumDecodedFrames = 1;
#ifdef _DUMPFRAME_
        pWMVDec->m_pfrmCurrQ->dump_minuspadding(fpDump);
#endif

#ifdef _COUNT_CYCLES_
    DecodeAndLockTmr += HrTmrGet ();
#endif

    FUNCTION_PROFILE_STOP(&fp);

#ifdef _WMV_TARGET_X86_
    if (g_bSupportMMX_WMV)
        _asm emms; //Make sure floating point calc works for building the table
#endif
    return WMV_Succeeded;
}


tWMVDecodeStatus WMVideoDecGetOutput (
    HWMVDecoder     hWMVDecoder,
    U32_WMV         uiFOURCCOutput,
    U16_WMV         uiBitsPerPixelOutput,
    U8_WMV*         pucDecodedOutput
){
    tWMVDecodeStatus tWMVStatus = WMV_Succeeded;
    tWMVDecInternalMember *pWMVDec; 

    if (hWMVDecoder == NULL_WMV)
        return WMV_InValidArguments;
    pWMVDec = (tWMVDecInternalMember*) (hWMVDecoder);
	
	if (pucDecodedOutput == NULL )
		pWMVDec->m_uiNumFramesLeftForOutput =0;

    if (pWMVDec->m_uiNumFramesLeftForOutput == 0)
        return WMV_NoMoreOutput;
    if (pucDecodedOutput == NULL_WMV) {
        pWMVDec->m_bRefreshBMP = TRUE_WMV; // repaint next frame if this frame is NULL
        return WMV_Succeeded;
    }

    FUNCTION_PROFILE_DECL_START(fp,WMVDECGETOUTPUT);

    // initializing BMP info
    if (1){//!pWMVDec->m_bBMPInitialized) {
        pWMVDec->m_uiFOURCCOutput = uiFOURCCOutput;
        pWMVDec->m_uiBitsPerPixelOutput = uiBitsPerPixelOutput;
        WMVideoDecInitBMPInfo (pWMVDec);
        pWMVDec->m_bBMPInitialized = TRUE_WMV;
    }

#ifdef COMBINE_LOOPFILTER_RENDERING
    if(pWMVDec->m_bLoopFilter==TRUE_WMV)
    {
        tWMVStatus=combine_loopfilter_rendering(pWMVDec, pucDecodedOutput);
    }
    else
        tWMVStatus = WMVideoDecColorConvert (pWMVDec, pucDecodedOutput);

    if (tWMVStatus != WMV_Succeeded) {
        FUNCTION_PROFILE_STOP(&fp);
        return tWMVStatus;
    }
#else
    tWMVStatus = WMVideoDecColorConvert (pWMVDec, pucDecodedOutput);
    if (tWMVStatus != WMV_Succeeded) {
        FUNCTION_PROFILE_STOP(&fp);
        return tWMVStatus;
    }
#endif
    pWMVDec->m_uiNumFramesLeftForOutput--;

    FUNCTION_PROFILE_STOP(&fp);
#ifdef _WMV_TARGET_X86_
    if (g_bSupportMMX_WMV)
        _asm emms; //Make sure floating point calc works for building the table
#endif
    return WMV_Succeeded;
}

// ===========================================================================
// private functions, inits
// ===========================================================================

tWMVDecodeStatus WMVInternalMemberInit (
    tWMVDecInternalMember *pWMVDec,
    U32_WMV uiUserData,
    U32_WMV uiFOURCCCompressed,
    Float_WMV fltFrameRate,
    Float_WMV fltBitRate,
    I32_WMV iWidthSource,
    I32_WMV iHeightSource,
    I32_WMV iPostFilterLevel
) {
    tWMVDecodeStatus tWMVStatus = WMV_Succeeded;

    pWMVDec->m_uiUserData = uiUserData;
    tWMVStatus = VodecConstruct (pWMVDec, uiFOURCCCompressed, (I32_WMV) fltFrameRate, iWidthSource, iHeightSource, pWMVDec -> m_pInputBitstream );
    if (tWMVStatus != WMV_Succeeded)
        return tWMVStatus;
    //g_InitDstBMP_WMV ();
#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_GRAY4) || defined (OUTPUT_RGB8) || defined (OUTPUT_RGB12) || defined (OUTPUT_RGB16) || defined (OUTPUT_RGB24) || defined (OUTPUT_RGB32)
    tWMVStatus = g_InitDstTables_WMV (pWMVDec);
    if (tWMVStatus != WMV_Succeeded)
        return tWMVStatus;
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB8) || defined (OUTPUT_RGB16) || defined (OUTPUT_RGB24) || defined (OUTPUT_RGB32)

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB8)
    g_InitDstDitherMap_WMV ();
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB8)

    pWMVDec->m_uiNumFramesLeftForOutput = 0;
    pWMVDec->m_uiFOURCCCompressed = uiFOURCCCompressed;
    pWMVDec->m_fltFrameRate = fltFrameRate;
    pWMVDec->m_fltBitRate = fltBitRate;
    pWMVDec->m_iPostFilterLevel = iPostFilterLevel;

    // size info
    pWMVDec->m_iWidthSource = pWMVDec->m_iFrmWidthSrc;
    pWMVDec->m_iHeightSource = pWMVDec->m_iFrmHeightSrc;

    pWMVDec->m_iWidthInternal = pWMVDec->m_iWidthPrevY;
    pWMVDec->m_iWidthInternalUV = pWMVDec->m_iWidthPrevUV; 
    pWMVDec->m_iHeightInternal = pWMVDec->m_iHeightPrevY;
    pWMVDec->m_iHeightInternalUV = pWMVDec->m_iHeightPrevUV;
    pWMVDec->m_iWidthInternalTimesMB = pWMVDec->m_iWidthInternal * MB_SIZE;
    pWMVDec->m_iWidthInternalUVTimesBlk = pWMVDec->m_iWidthInternalUV * BLOCK_SIZE;
    pWMVDec->m_bSizeMBAligned = (pWMVDec->m_iWidthSource == pWMVDec->m_iWidthInternal && pWMVDec->m_iHeightSource == pWMVDec->m_iHeightInternal);

    pWMVDec->m_uiNumMBX = pWMVDec->m_iWidthY >> 4; // divided by 16, MB size
    pWMVDec->m_uiNumMBY = pWMVDec->m_iHeightY >> 4;
    pWMVDec->m_uiNumMB = pWMVDec->m_uiNumMBX * pWMVDec->m_uiNumMBY;

    // tables
    pWMVDec->m_rgiClapTabDec = &(g_rgiClapTabDecWMV [384]); // 384 + 256 + 384 = 1024 (256 is the valid region).

#ifdef DYNAMIC_EDGEPAD
    edgePadInit(pWMVDec, &pWMVDec->m_tEdgePad );
#endif

    // picture/frame init
//    pWMVDec->m_pfrCurr = (tYUV420Frame_WMV*) wmvalloc (sizeof (tYUV420Frame_WMV));
//    if (pWMVDec->m_pfrCurr == NULL_WMV)
//        return WMV_BadMemory;
//    memset (pWMVDec->m_pfrCurr, 0, sizeof (tYUV420Frame_WMV));
//    pWMVDec->m_pfrCurr->m_pucYPlane = (U8_WMV*) wmvalloc (pWMVDec->m_iWidthInternal * pWMVDec->m_iHeightInternal);
//    if (pWMVDec->m_pfrCurr->m_pucYPlane == NULL_WMV)
//        return WMV_BadMemory;
//    pWMVDec->m_pfrCurr->m_pucUPlane = (U8_WMV*) wmvalloc (pWMVDec->m_iWidthInternalUV * pWMVDec->m_iHeightInternalUV);
//    if (pWMVDec->m_pfrCurr->m_pucUPlane == NULL_WMV)
//        return WMV_BadMemory;
//    pWMVDec->m_pfrCurr->m_pucVPlane = (U8_WMV*) wmvalloc (pWMVDec->m_iWidthInternalUV * pWMVDec->m_iHeightInternalUV);
//    if (pWMVDec->m_pfrCurr->m_pucVPlane == NULL_WMV)
//        return WMV_BadMemory;
//
//    pWMVDec->m_pfrPrev = (tYUV420Frame_WMV*) wmvalloc (sizeof (tYUV420Frame_WMV));
//    if (pWMVDec->m_pfrPrev == NULL_WMV)
//        return WMV_BadMemory;
//    memset (pWMVDec->m_pfrPrev, 0, sizeof (tYUV420Frame_WMV));
//    pWMVDec->m_pfrPrev->m_pucYPlane = (U8_WMV*) wmvalloc (pWMVDec->m_iWidthInternal * pWMVDec->m_iHeightInternal);
//    if (pWMVDec->m_pfrPrev->m_pucYPlane == NULL_WMV)
//        return WMV_BadMemory;
//    pWMVDec->m_pfrPrev->m_pucUPlane = (U8_WMV*) wmvalloc (pWMVDec->m_iWidthInternalUV * pWMVDec->m_iHeightInternalUV);
//    if (pWMVDec->m_pfrPrev->m_pucUPlane == NULL_WMV)
//        return WMV_BadMemory;
//    pWMVDec->m_pfrPrev->m_pucUPlane = (U8_WMV*) wmvalloc (pWMVDec->m_iWidthInternalUV * pWMVDec->m_iHeightInternalUV);
//    if (pWMVDec->m_pfrPrev->m_pucUPlane == NULL_WMV)
//        return WMV_BadMemory;
/*
    // Huffmane decoder init
    pWMVDec->m_pHuffDec = (tHuffmanDecoder_WMV*) wmvalloc (sizeof (tHuffmanDecoder_WMV));
    if (pWMVDec->m_pHuffDec == NULL_WMV)
        return WMV_BadMemory;
    memset (pWMVDec->m_pHuffDec, 0, sizeof (tHuffmanDecoder_WMV));
    tWMVStatus = HuffmanDecodeInit (pWMVDec->m_pHuffDec);
    if (tWMVStatus != WMV_Succeeded)
        return tWMVStatus; 

    // Stream parser init
    pWMVDec->m_pStrmParse = (tStreamParser_WMV*) wmvalloc (sizeof (tStreamParser_WMV));
    if (pWMVDec->m_pStrmParse == NULL_WMV)
        return WMV_BadMemory;
    memset (pWMVDec->m_pStrmParse, 0, sizeof (tStreamParser_WMV));
    tWMVStatus = StreamParserInit (pWMVDec->m_pStrmParse);
    if (tWMVStatus != WMV_Succeeded)
        return tWMVStatus; 
*/
    // picture encoding mode
//    pWMVDec->m_bRndCtrlOn = TRUE_WMV;

    // MB data
    
    return tWMVStatus;
}

tWMVDecodeStatus WMVInternalMemberDestroy (tWMVDecInternalMember *pWMVDec)
{
#if defined (_6BIT_COLORCONV_OPT_) || defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB12) || defined (OUTPUT_GRAY4)
    g_EndDstTables_WMV (pWMVDec);
#endif
#ifdef DYNAMIC_EDGEPAD
    edgePadDestroy(&pWMVDec->m_tEdgePad );
#endif
    tWMVDecodeStatus tWMVStatus = WMV_Succeeded;
    tWMVStatus = VodecDestruct(pWMVDec);
    return tWMVStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\wmfdecode.c ===
#include "bldsetup.h"

#if !defined(_Embedded_x86) && !defined(HITACHI)
#ifdef macintosh
#include <MacTypes.h>
#include <Errors.h>
#include <Endian.h>
#include <MacMemory.h>
#define BIGENDIAN
#elif defined(_XBOX)
#include <xtl.h>
#else
#include <windows.h>
#include <memory.h>
#include <mmsystem.h>
#endif
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "wmcdecode.h"
#ifdef _XBOX
#include "wmf.h"
#include "wmfdec.h"
#endif
#if defined(_Embedded_x86) || defined(_XBOX)
#define BYTE U8_WMC
#define VOID void
#define DWORD U32_WMC
#define HRESULT long
//typedef Bool_WMC BOOL;
#endif // linux
#ifdef UNDER_CE
#define assert ASSERT
#else
#include <assert.h>
#endif
#define NO_FRAMERATE

#ifdef HITACHI
#include "wmmacsp.h"
#endif

#include "wmfparse.h"

#ifndef _XBOX
#include "wmf.h"
#include "wmfdec.h"
#endif
#include "wmfparse.h"
#ifndef __NO_SCREEN__
#include "wmscreendec_api.h"
#endif

#ifndef __NO_SPEECH__
#include "wmsdec_api.h"
#endif

#ifndef _ASFPARSE_ONLY_
#include "wmvdec_api.h"
#else
typedef enum tagWMVDecodeStatus
{
    WMV_Succeeded = 0,
    WMV_Failed,
    WMV_BadMemory,
    WMV_NoKeyFrameDecoded,
    WMV_CorruptedBits,
    WMV_UnSupportedOutputPixelFormat,
    WMV_UnSupportedCompressedFormat,
    WMV_InValidArguments,
    WMV_BadSource,

    WMV_NoMoreOutput,
    WMV_EndOfFrame,
    WMV_BrokenFrame
} tWMVDecodeStatus;

#endif

#define MIN_HEADER_SIZE     0x80
#define NORMAL_HEADER_SIZE  0x8000
#define WMFDEMO_TIME        60000


#if( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

typedef struct tbitmapPalette
{
	BITMAPINFOHEADER	BitmapHdr;
    U8_WMC              bPlaette[1024];
}BITMAPPALETTE;

#ifndef __NO_SPEECH__
//BOOL InitNSPLibWMSP(ULONG fdwReason);
#include "intelFFT.h"
int MyInitNSP(int fdwReason);
#endif

const U8_WMC StandardPalette[3*256] =

    // These are the first ten standard VGA colours WARNING RGBQUAD defines
    // the fields in BGR ordering NOT RGB ! The odd looking entries further
    // down are entered to ensure that we get an identity palette with GDI
    // If we entered an all zero palette entry for example it would be taken
    // out and GDI would use a slow internal mapping table to generate it

    {   0,   0,   0 ,     // 0 Sys Black
       0,   0, 128 ,     // 1 Sys Dk Red
       0, 128,   0 ,     // 2 Sys Dk Green
       0, 128, 128 ,     // 3 Sys Dk Yellow
     128,   0,   0 ,     // 4 Sys Dk Blue
     128,   0, 128 ,     // 5 Sys Dk Violet
     128, 128,   0 ,     // 6 Sys Dk Cyan
     192, 192, 192 ,     // 7 Sys Lt Grey
     192, 220, 192 ,     // 8 Sys 8
     240, 202, 166 ,     // 9 Sys 9

       1,   1,   1 ,
       1,   1,  51 ,
       1,   1, 102 ,
       1,   1, 153 ,
       1,   1, 204 ,
       1,   1, 254 ,
       1,  51,   1 ,
       1,  51,  51 ,
       1,  51, 102 ,
       1,  51, 153 ,
       1,  51, 204 ,
       1,  51, 254 ,
       1, 102,   1 ,
       1, 102,  51 ,
       1, 102, 102 ,
       1, 102, 153 ,
       1, 102, 204 ,
       1, 102, 254 ,
       1, 153,   1 ,
       1, 153,  51 ,
       1, 153, 102 ,
       1, 153, 153 ,
       1, 153, 204 ,
       1, 153, 254 ,
       1, 204,   1 ,
       1, 204,  51 ,
       1, 204, 102 ,
       1, 204, 153 ,
       1, 204, 204 ,
       1, 204, 254 ,
       1, 254,   1 ,
       1, 254,  51 ,
       1, 254, 102 ,
       1, 254, 153 ,
       1, 254, 204 ,
       1, 254, 254 ,

      51,   1,   1 ,
      51,   1,  51 ,
      51,   1, 102 ,
      51,   1, 153 ,
      51,   1, 204 ,
      51,   1, 254 ,
      51,  51,   1 ,
      51,  51,  51 ,
      51,  51, 102 ,
      51,  51, 153 ,
      51,  51, 204 ,
      51,  51, 254 ,
      51, 102,   1 ,
      51, 102,  51 ,
      51, 102, 102 ,
      51, 102, 153 ,
      51, 102, 204 ,
      51, 102, 254 ,
      51, 153,   1 ,
      51, 153,  51 ,
      51, 153, 102 ,
      51, 153, 153 ,
      51, 153, 204 ,
      51, 153, 254 ,
      51, 204,   1 ,
      51, 204,  51 ,
      51, 204, 102 ,
      51, 204, 153 ,
      51, 204, 204 ,
      51, 204, 254 ,
      51, 254,   1 ,
      51, 254,  51 ,
      51, 254, 102 ,
      51, 254, 153 ,
      51, 254, 204 ,
      51, 254, 254 ,

     102,   1,   1 ,
     102,   1,  51 ,
     102,   1, 102 ,
     102,   1, 153 ,
     102,   1, 204 ,
     102,   1, 254 ,
     102,  51,   1 ,
     102,  51,  51 ,
     102,  51, 102 ,
     102,  51, 153 ,
     102,  51, 204 ,
     102,  51, 254 ,
     102, 102,   1 ,
     102, 102,  51 ,
     102, 102, 102 ,
     102, 102, 153 ,
     102, 102, 204 ,
     102, 102, 254 ,
     102, 153,   1 ,
     102, 153,  51 ,
     102, 153, 102 ,
     102, 153, 153 ,
     102, 153, 204 ,
     102, 153, 254 ,
     102, 204,   1 ,
     102, 204,  51 ,
     102, 204, 102 ,
     102, 204, 153 ,
     102, 204, 204 ,
     102, 204, 254 ,
     102, 254,   1 ,
     102, 254,  51 ,
     102, 254, 102 ,
     102, 254, 153 ,
     102, 254, 204 ,
     102, 254, 254 ,

     153,   1,   1 ,
     153,   1,  51 ,
     153,   1, 102 ,
     153,   1, 153 ,
     153,   1, 204 ,
     153,   1, 254 ,
     153,  51,   1 ,
     153,  51,  51 ,
     153,  51, 102 ,
     153,  51, 153 ,
     153,  51, 204 ,
     153,  51, 254 ,
     153, 102,   1 ,
     153, 102,  51 ,
     153, 102, 102 ,
     153, 102, 153 ,
     153, 102, 204 ,
     153, 102, 254 ,
     153, 153,   1 ,
     153, 153,  51 ,
     153, 153, 102 ,
     153, 153, 153 ,
     153, 153, 204 ,
     153, 153, 254 ,
     153, 204,   1 ,
     153, 204,  51 ,
     153, 204, 102 ,
     153, 204, 153 ,
     153, 204, 204 ,
     153, 204, 254 ,
     153, 254,   1 ,
     153, 254,  51 ,
     153, 254, 102 ,
     153, 254, 153 ,
     153, 254, 204 ,
     153, 254, 254 ,

     204,   1,   1 ,
     204,   1,  51 ,
     204,   1, 102 ,
     204,   1, 153 ,
     204,   1, 204 ,
     204,   1, 254 ,
     204,  51,   1 ,
     204,  51,  51 ,
     204,  51, 102 ,
     204,  51, 153 ,
     204,  51, 204 ,
     204,  51, 254 ,
     204, 102,   1 ,
     204, 102,  51 ,
     204, 102, 102 ,
     204, 102, 153 ,
     204, 102, 204 ,
     204, 102, 254 ,
     204, 153,   1 ,
     204, 153,  51 ,
     204, 153, 102 ,
     204, 153, 153 ,
     204, 153, 204 ,
     204, 153, 254 ,
     204, 204,   1 ,
     204, 204,  51 ,
     204, 204, 102 ,
     204, 204, 153 ,
     204, 204, 204 ,
     204, 204, 254 ,
     204, 254,   1 ,
     204, 254,  51 ,
     204, 254, 102 ,
     204, 254, 153 ,
     204, 254, 204 ,
     204, 254, 254 ,

     254,   1,   1 ,
     254,   1,  51 ,
     254,   1, 102 ,
     254,   1, 153 ,
     254,   1, 204 ,
     254,   1, 254 ,
     254,  51,   1 ,
     254,  51,  51 ,
     254,  51, 102 ,
     254,  51, 153 ,
     254,  51, 204 ,
     254,  51, 254 ,
     254, 102,   1 ,
     254, 102,  51 ,
     254, 102, 102 ,
     254, 102, 153 ,
     254, 102, 204 ,
     254, 102, 254 ,
     254, 153,   1 ,
     254, 153,  51 ,
     254, 153, 102 ,
     254, 153, 153 ,
     254, 153, 204 ,
     254, 153, 254 ,
     254, 204,   1 ,
     254, 204,  51 ,
     254, 204, 102 ,
     254, 204, 153 ,
     254, 204, 204 ,
     254, 204, 254 ,
     254, 254,   1 ,
     254, 254,  51 ,
     254, 254, 102 ,
     254, 254, 153 ,
     254, 254, 204 ,
     254, 254, 254 };

int g_iVideoFrameSize = 0;

tWMCDecStatus WMCDecInit_All (HWMCDECODER* phWMCDec, tVideoFormat_WMC tVideoOutputFormat, Bool_WMC bDiscardIndex, U32_WMC u32UserData, I32_WMC i32PostProc);

tWMCDecStatus WMCInitnParseHeader(HWMCDECODER *phDecoder
#ifdef _ZMDRM_
                    ,HDRMMGR *phDRM
                    ,U8_WMC *pAppCert
                    ,U32_WMC Rights
                    ,const U8_WMC *pbHwId
                    ,U32_WMC cbHwId
#endif
                    );

#define SAFEMEMFREE(x) { if (x != NULL_WMC) wmvfree(x); x= NULL_WMC; }	
tWMCDecStatus WMCDecGetMediaType (HWMCDECODER hWMCDec, U16_WMC wStreamId, tMediaType_WMC * pMediaType);
tWMCDecStatus WMCRawGetVideoData (U8_WMC *pBuffer, U32_WMC *pcbBuffer, HWMCDECODER hDecoder, U32_WMC cbDstBufferLength);
tWMCDecStatus WMCRawGetBinaryData (U8_WMC *pBuffer, U32_WMC *pcbBuffer, HWMCDECODER hDecoder, U32_WMC cbDstBufferLength);
tWMCDecStatus WMCReadIndex (HWMCDECODER  *hDecoder);
tWMCDecStatus WMCDecStorePayload( HWMCDECODER hDecoder, U32_WMC cbPayloadSize, tMediaType_WMC MediaType, U32_WMC PresTime, I32_WMC cbFrame, U16_WMC Index, Bool_WMC bWriteHeader, Bool_WMC bIsCompressed);
tWMCDecStatus WMCDecParseVirtualPacketHeader(HWMCDECODER hDecoder, U32_WMC cbCurrentPacketOffset, PACKET_PARSE_INFO_EX* pParseInfoEx);
tWMCDecStatus WMCDecParseVirtualPayloadHeader(HWMCDECODER hDecoder, U32_WMC cbCurrentPacketOffset, PACKET_PARSE_INFO_EX *pParseInfoEx, PAYLOAD_MAP_ENTRY_EX *pPayload);
tWMCDecStatus WMCDecGetPreviousFrameTime (HWMCDECODER hWMCDec, U16_WMC wStreamId, U64_WMC u64TimeRequest, U64_WMC* pu64TimeReturn);
tWMCDecStatus WMCDecUpdateNewPayload(HWMCDECODER hDecoder, tMediaType_WMC MediaType, U16_WMC Index);
tWMCDecStatus WMCDecGetAndDecode (HWMCDECODER hWMCDec, U32_WMC* pnStreamReadyForOutput, U32_WMC* pnNumberOfSamples);
tWMCDecStatus WMCDecGetStreamToSpecificPosition (HWMCDECODER hWMCDec, U16_WMC wStreamId, U64_WMC u64TimeRequest, U64_WMC* pu64TimeReturn);
#ifndef __NO_SCREEN__
tWMCDecStatus WMScDecodeData (HWMCDECODER hWMCDec, U16_WMC wIndex );
tWMCDecStatus WMScGetOutData (HWMCDECODER hWMCDec, U8_WMC *pu8VideoOutBuffer, U32_WMC u32VideoOutBufferSize, U16_WMC wIndex );
#endif

/******************************************************************************/

tWMCDecStatus WMCDecInit (HWMCDECODER* phWMCDec, tVideoFormat_WMC tVideoOutputFormat, Bool_WMC bDiscardIndex, I32_WMC i32PostProc)

{   
    WMFDecoderEx *pDecoder = NULL_WMC;

    if( (NULL_WMC == phWMCDec)||(i32PostProc < -1) || (i32PostProc >4))
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(*phWMCDec);

	pDecoder->i32PostProc = i32PostProc;
	
	return WMCDecInit_All (phWMCDec, tVideoOutputFormat, bDiscardIndex, pDecoder->u32UserData, i32PostProc);
}


/******************************************************************************/
tWMCDecStatus WMCDecGetNumberOfMarkers (HWMCDECODER hWMCDec, U16_WMC *pu16NumMarkers)
//U16_WMC WMCDecGetNumberOfMarkers (HWMCDECODER hWMCDec)  
{
 	WMFDecoderEx* pDecoder = (WMFDecoderEx*) hWMCDec;

    if((hWMCDec == NULL_WMC) || (pu16NumMarkers == NULL_WMC))
    {
        return WMCDec_InValidArguments;
    }

    if(pDecoder->m_pMarkers == NULL_WMC) 
	{
        *pu16NumMarkers = 0;
    }
    else  
	{
        *pu16NumMarkers = (U16_WMC)pDecoder->m_dwMarkerNum;
    }
	return WMCDec_Succeeded;
}

/*******************************************************************************/
tWMCDecStatus WMCDecGetMarker (HWMCDECODER hWMCDec, U16_WMC iIndex, WMCMarkerEntry *pEntry) 
{
 	WMFDecoderEx* pDecoder = (WMFDecoderEx*) hWMCDec;

    if((hWMCDec == NULL_WMC) || (pEntry == NULL_WMC))
    {
        return WMCDec_InValidArguments;
    }

    if (iIndex >= pDecoder->m_dwMarkerNum)
    {
        memset(pEntry, 0, sizeof(WMCCodecEntry));
        return WMCDec_InvalidIndex;
    }

    if(pDecoder->m_pMarkers == NULL_WMC) {
        memset(pEntry, 0, sizeof(WMCMarkerEntry));
        return WMCDec_Fail;
    }
    else  {
        *pEntry = *(pDecoder->m_pMarkers + iIndex);
        return WMCDec_Succeeded;
    }
}


/*******************************************************************************/
tWMCDecStatus WMCDecGetCodecEntry (HWMCDECODER hWMCDec, U16_WMC iIndex, WMCCodecEntry *pEntry) 
{
 	WMFDecoderEx* pDecoder = (WMFDecoderEx*) hWMCDec;

    if((hWMCDec == NULL_WMC) || (pEntry == NULL_WMC))
    {
        return WMCDec_InValidArguments;
    }

    if (iIndex >= pDecoder->m_dwNumCodec)
    {
        memset(pEntry, 0, sizeof(WMCCodecEntry));
        return WMCDec_InvalidIndex;
    }

    if(pDecoder->m_pCodecEntry == NULL_WMC)
    {
        memset(pEntry, 0, sizeof(WMCCodecEntry));
        return WMCDec_Fail;
    }
    else  {
        *pEntry = *(pDecoder->m_pCodecEntry + iIndex);
        return WMCDec_Succeeded;
    }
}

/*******************************************************************************/

tWMCDecStatus WMCDecGetCodecCount (HWMCDECODER hWMCDec, U32_WMC * pnNumCodec)
{
 	WMFDecoderEx* pDecoder = (WMFDecoderEx*) hWMCDec;

    if((hWMCDec == NULL_WMC) || (pnNumCodec == NULL_WMC))
    {
        return WMCDec_InValidArguments;
    }

    if(pDecoder->m_pCodecEntry != NULL_WMC)
	{
        *pnNumCodec = pDecoder->m_dwNumCodec; 
    }
	else
        *pnNumCodec = 0;
	
    return WMCDec_Succeeded;

}



/******************************************************************************/
tWMCDecStatus WMCDecGetContentDesc (HWMCDECODER hWMCDec, const WMCContentDescription **pDesc)
{

 	WMFDecoderEx* pDecoder = (WMFDecoderEx*) hWMCDec;

    if ((hWMCDec == NULL_WMC) || (pDesc == NULL_WMC))
        return WMCDec_InValidArguments;

    if(pDecoder->m_pContentDesc == NULL_WMC)
        *pDesc = NULL_WMC;
    else 
        *pDesc = pDecoder->m_pContentDesc;

    return WMCDec_Succeeded;
}

/******************************************************************************/
tWMCDecStatus WMCDecGetExtendedContentDesc (HWMCDECODER hWMCDec, const WMCExtendedContentDesc **pECDesc)
{

 	WMFDecoderEx* pDecoder = (WMFDecoderEx*) hWMCDec;

    if ((hWMCDec == NULL_WMC) || (pECDesc == NULL_WMC))
        return WMCDec_InValidArguments;

    if(pDecoder->m_pExtendedContentDesc == NULL_WMC)
        *pECDesc = NULL_WMC;
    else
        *pECDesc = pDecoder->m_pExtendedContentDesc;

    return WMCDec_Succeeded;
}

/******************************************************************************/
tWMCDecStatus WMCGetScriptCommand (HWMCDECODER hDecoder, const WMCScriptCommand **pSCObject)
{

 	WMFDecoderEx* pDecoder = (WMFDecoderEx*) hDecoder;

    if ((hDecoder == NULL_WMC) || (pSCObject == NULL_WMC))
        return WMCDec_InValidArguments;

    if(pDecoder->m_pScriptCommand == NULL_WMC)
        *pSCObject = NULL_WMC;
    else
        *pSCObject = pDecoder->m_pScriptCommand;

    return WMCDec_Succeeded;
}


//////////////////////////////////////////////////New Code ///////////////////////////////////////////////////////////////////////////////////////////

/******************************************************************************/



tWMCDecStatus WMCDecInit_All (HWMCDECODER* phWMCDec, tVideoFormat_WMC tVideoOutputFormat, Bool_WMC bDiscardIndex, U32_WMC u32UserData, I32_WMC i32PostProc)
{   
    tWMCDecStatus Status = WMCDec_Succeeded;
    U16_WMC i=0;
    WMFDecoderEx *pDecoder = NULL_WMC;

    if( NULL_WMC == phWMCDec )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(*phWMCDec);


    memset( pDecoder, 0, sizeof( WMFDecoderEx ) );

	pDecoder->u32UserData = u32UserData;
	pDecoder->i32PostProc = i32PostProc;


    do
    {
       Status = WMCInitnParseHeader (phWMCDec);
        if( WMCDec_Succeeded != Status )
			break;

        Status = WMCDecSetVideoOutputFormat (*phWMCDec, tVideoOutputFormat);
        if( WMCDec_Succeeded != Status )
			break;
        if (bDiscardIndex == FALSE_WMC)
		{
			Status = WMCReadIndex (phWMCDec);
			if( WMCDec_Succeeded != Status )
				break;
		}
        pDecoder->bParsed = TRUE_WMC;


 	}  while (0);

  
    return Status;
}
/******************************************************************************/

HWMCDECODER WMCDecCreate(U32_WMC u32UserData)
{   WMFDecoderEx *pDecoder;

    pDecoder = (WMFDecoderEx *) wmvalloc( sizeof( WMFDecoderEx ) );
    memset(pDecoder, 0, sizeof(WMFDecoderEx));
    pDecoder->u32UserData = u32UserData;

    return pDecoder;
}


/******************************************************************************/


tWMCDecStatus WMCDecGetStreamInfo (HWMCDECODER hWMCDec, U32_WMC* pnNumStreams, tStreamIdnMediaType_WMC** pptMediaTypeStreams)
{
    tWMCDecStatus Status = WMCDec_Succeeded;
    U16_WMC     wNoOfStreams =0;
    U16_WMC     wNoOfAudioStreams =0;
    U16_WMC     wNoOfVideoStreams =0;
    U16_WMC     wNoOfBinaryStreams =0;
    U16_WMC     i=0;
    tStreamIdnMediaType_WMC *pStream = NULL_WMC;
    WMFDecoderEx *pDecoder = NULL_WMC;
    
    if( (NULL_WMC == hWMCDec) || (NULL_WMC == pptMediaTypeStreams) || (NULL_WMC == pnNumStreams))
        return( WMCDec_InValidArguments );

    *pptMediaTypeStreams = NULL_WMC;

    pDecoder = (WMFDecoderEx *)(hWMCDec);
 
    if (pDecoder->bParsed != TRUE_WMC) 
        return( WMCDec_InValidArguments );
    
    wNoOfStreams = pDecoder->tHeaderInfo.wNoOfStreams;
    wNoOfAudioStreams = pDecoder->tHeaderInfo.wNoOfAudioStreams;
    wNoOfVideoStreams = pDecoder->tHeaderInfo.wNoOfVideoStreams;
    wNoOfBinaryStreams = pDecoder->tHeaderInfo.wNoOfBinaryStreams;

    assert(wNoOfStreams ==(wNoOfAudioStreams + wNoOfVideoStreams + wNoOfBinaryStreams));

    *pptMediaTypeStreams = (tStreamIdnMediaType_WMC*)wmvalloc(wNoOfStreams*sizeof(tStreamIdnMediaType_WMC));
    pStream = *pptMediaTypeStreams;
    pDecoder->pStreamIdnMediaType = *pptMediaTypeStreams; 

    *pnNumStreams = wNoOfStreams;

    for(i=0;  i< wNoOfAudioStreams; i++)
    {
        pStream->wStreamId =  pDecoder->tAudioStreamInfo[i]->wStreamId;
        pStream->MediaType = Audio_WMC;
        pStream++;
    }

    for(i=0; i< wNoOfVideoStreams; i++)
    {
        pStream->wStreamId =  pDecoder->tVideoStreamInfo[i]->wStreamId;
        pStream->MediaType = Video_WMC;
        pStream++;
    }

    for(i=0; i< wNoOfBinaryStreams; i++)
    {
        pStream->wStreamId =  pDecoder->tBinaryStreamInfo[i]->wStreamId;
        pStream->MediaType = Binary_WMC;
        pStream++;
    }

    return Status;

}

/******************************************************************************/

tWMCDecStatus WMCDecGetAudioInfo (HWMCDECODER hWMCDec, U32_WMC nStreamNum, strAudioInfo_WMC* pstrAudioInfo)
{
    tWMCDecStatus Status = WMCDec_Succeeded;
    U16_WMC     wNoOfAudioStreams =0;
    U16_WMC     i=0;
    Bool_WMC    bDone = FALSE_WMC;
    WMFDecoderEx *pDecoder = NULL_WMC;
    
    if( (NULL_WMC == hWMCDec) || (NULL_WMC == pstrAudioInfo))
        return( WMCDec_InValidArguments );


    pDecoder = (WMFDecoderEx *)(hWMCDec);

    if (pDecoder->bParsed != TRUE_WMC) 
        return( WMCDec_InValidArguments );
    
    memset(pstrAudioInfo, 0, sizeof(strAudioInfo_WMC));

    wNoOfAudioStreams = pDecoder->tHeaderInfo.wNoOfAudioStreams;

    for(i=0; i< wNoOfAudioStreams; i++)
    {
        if (pDecoder->tAudioStreamInfo[i]->wStreamId == (U16_WMC)nStreamNum)
        {
            pstrAudioInfo->u16FormatTag = pDecoder->tAudioStreamInfo[i]->wFormatTag;
            pstrAudioInfo->u32BitsPerSecond =  (pDecoder->tAudioStreamInfo[i]->nAvgBytesPerSec)*8;
            pstrAudioInfo->u16BitsPerSample = (U16_WMC)pDecoder->tAudioStreamInfo[i]->nBitsPerSample;
            pstrAudioInfo->u16NumChannels = (U16_WMC)pDecoder->tAudioStreamInfo[i]->nChannels;
            pstrAudioInfo->u16SamplesPerSecond = (U16_WMC)pDecoder->tAudioStreamInfo[i]->nSamplesPerSec;
            pstrAudioInfo->u32BlockSize = (U32_WMC)pDecoder->tAudioStreamInfo[i]->nBlockAlign;
            pstrAudioInfo->u16ValidBitsPerSample =  (U16_WMC)pDecoder->tAudioStreamInfo[i]->wValidBitsPerSample;
            pstrAudioInfo->u32ChannelMask = (U32_WMC)pDecoder->tAudioStreamInfo[i]->dwChannelMask;
            pstrAudioInfo->u16StreamId = pDecoder->tAudioStreamInfo[i]->wStreamId ;

            bDone = TRUE_WMC;
            break;
        }
    }

    if (bDone != TRUE_WMC)
        Status = WMCDec_InValidArguments;

    return Status;
}

/******************************************************************************/

tWMCDecStatus WMCDecGetVideoInfo (HWMCDECODER hWMCDec, U32_WMC nStreamNum, strVideoInfo_WMC* pstrVideoInfo)
{
    tWMCDecStatus Status = WMCDec_Succeeded;
    U16_WMC     wNoOfVideoStreams =0;
    U16_WMC     i=0;
    Bool_WMC    bDone = FALSE_WMC;
    WMFDecoderEx *pDecoder = NULL_WMC;
    
    if( (NULL_WMC == hWMCDec) || (NULL_WMC == pstrVideoInfo))
        return( WMCDec_InValidArguments );


    pDecoder = (WMFDecoderEx *)(hWMCDec);
    
    if (pDecoder->bParsed != TRUE_WMC) 
        return( WMCDec_InValidArguments );
    
    memset(pstrVideoInfo, 0, sizeof(strVideoInfo_WMC));
 
    wNoOfVideoStreams = pDecoder->tHeaderInfo.wNoOfVideoStreams;

    for(i=0; i< wNoOfVideoStreams; i++)
    {
        if (pDecoder->tVideoStreamInfo[i]->wStreamId == (U16_WMC)nStreamNum)
        {
            
            if (pDecoder->tHeaderInfo.bHasBitRateInfo == TRUE_WMC)
            {
                U16_WMC j=0;
                for (j=0; j< pDecoder->tHeaderInfo.wNoOfStreams; j++ )
                {
                    if (pDecoder->tHeaderInfo.tBitRateInfo[j].wStreamId == (U16_WMC)nStreamNum)
                    {
                        pstrVideoInfo->u32BitsPerSecond  = pDecoder->tHeaderInfo.tBitRateInfo[j].dwBitRate;
                        break;
                    }
                }
            }
            else
            {
                // Guess Bitrate
                pstrVideoInfo->u32BitsPerSecond = pDecoder->tHeaderInfo.dwMaxBitrate;
                if (pDecoder->tHeaderInfo.wNoOfAudioStreams >0)
                    pstrVideoInfo->u32BitsPerSecond -= ((pDecoder->tAudioStreamInfo[0]->nAvgBytesPerSec)*8);
                
                pstrVideoInfo->u32BitsPerSecond = pstrVideoInfo->u32BitsPerSecond*9/10; //10% for asf overhead
            }

            pstrVideoInfo->fltFramesPerSecond =0;
            pstrVideoInfo->i32Height = pDecoder->tVideoStreamInfo[i]->biHeight;
            pstrVideoInfo->i32Width  = pDecoder->tVideoStreamInfo[i]->biWidth;
            pstrVideoInfo->u32Compression  = pDecoder->tVideoStreamInfo[i]->biCompression;
            pstrVideoInfo->u16StreamId = pDecoder->tVideoStreamInfo[i]->wStreamId ;
            pstrVideoInfo->u32VideoOutputPixelType = pDecoder->tVideoStreamInfo[i]->biCompressionOut;
            pstrVideoInfo->u16VideoOutputBitCount  = pDecoder->tVideoStreamInfo[i]->biBitCountOut;
            if(8==pDecoder->tVideoStreamInfo[i]->biBitCountOut)
            {
               if (
                    pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_WMV2 ||
                    pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_WMV1 ||
                    pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MP4S ||
                    pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MP43 ||
                    pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MP42 
#ifndef __NO_SCREEN__
				
					||
                    pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MSS1 ||
                    pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MSS2 
#endif					
					)
                    memcpy(pstrVideoInfo->bPalette, StandardPalette, 3*256);  
//                else if(pDecoder->biCompression == FOURCC_MSS1)
//                    memcpy(pstrVideoInfo->bPalette, pDecoder->tVideoStreamInfo[i]->bPalette, 3*256);  
            }

            bDone = TRUE_WMC;
            break;
        }
    }

    if (bDone != TRUE_WMC)
        Status = WMCDec_InValidArguments;

    return Status;
}
/******************************************************************************/

tWMCDecStatus WMCDecGetBinaryInfo (HWMCDECODER hWMCDec, U32_WMC nStreamNum, strBinaryInfo_WMC* pstrBinaryInfo)
{
    tWMCDecStatus Status = WMCDec_Succeeded;
    U16_WMC     wNoOfBinaryStreams =0;
    U16_WMC     i=0;
    Bool_WMC    bDone = FALSE_WMC;
    WMFDecoderEx *pDecoder = NULL_WMC;
   
    if( (NULL_WMC == hWMCDec) || (NULL_WMC == pstrBinaryInfo))
        return( WMCDec_InValidArguments );


    pDecoder = (WMFDecoderEx *)(hWMCDec);

    if (pDecoder->bParsed != TRUE_WMC) 
        return( WMCDec_InValidArguments );
    
    wNoOfBinaryStreams = pDecoder->tHeaderInfo.wNoOfBinaryStreams;
    for(i=0; i< wNoOfBinaryStreams; i++)
    {
        if (pDecoder->tBinaryStreamInfo[i]->wStreamId == (U16_WMC)nStreamNum)
        {
            pstrBinaryInfo->u16StreamId = pDecoder->tBinaryStreamInfo[i]->wStreamId ;
            bDone = TRUE_WMC;
            break;
        }
        
    }

    if (bDone != TRUE_WMC)
        Status = WMCDec_InValidArguments;

    return Status;
}

/******************************************************************************/

tWMCDecStatus WMCDecGetHeaderInfo (HWMCDECODER hWMCDec, strHeaderInfo_WMC* pstrHeaderInfo)
{
    tWMCDecStatus Status = WMCDec_Succeeded;
    WMFDecoderEx *pDecoder = NULL_WMC;
    
    if( (NULL_WMC == hWMCDec) || (NULL_WMC == pstrHeaderInfo))
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(hWMCDec);
    
    if (pDecoder->bParsed != TRUE_WMC) 
        return( WMCDec_InValidArguments );
    
    memset(pstrHeaderInfo, 0, sizeof(strHeaderInfo_WMC));

    pstrHeaderInfo->u32MaxBitrate = pDecoder->tHeaderInfo.dwMaxBitrate;
    pstrHeaderInfo->u32PlayDuration = pDecoder->tHeaderInfo.msDuration;
    pstrHeaderInfo->u32Preroll  = pDecoder->tHeaderInfo.msPreroll;
    pstrHeaderInfo->u32SendDuration  = pDecoder->tHeaderInfo.msSendDuration;
    pstrHeaderInfo->u8HasDRM = pDecoder->bHasDRM;
    pstrHeaderInfo->u32PacketSize = pDecoder->tHeaderInfo.cbPacketSize;


    return Status;
}

/******************************************************************************/

tWMCDecStatus WMCDecSetDecodePatternForStreams (HWMCDECODER* phWMCDec, const tStreamIdPattern_WMC* ptStreamDecodePattern)
{
    // Set Pattern and if the stream is decodable and user wants output create decoders and keep handles
    tWMCDecStatus Status = WMCDec_Succeeded;
    WMFDecoderEx *pDecoder = NULL_WMC;
    tStreamIdPattern_WMC* pPattern = NULL_WMC;
    U16_WMC i=0, j=0;
    tMediaType_WMC MediaType;
#ifndef __NO_SCREEN__    
    Void_WMC* hSCdec =NULL_WMC;
#endif    

#ifdef WMC_NO_BUFFER_MODE
	U32_WMC Index=0;
	U32_WMC dwPresTime=0;
	U64_WMC u64TimeReturn=0;
#endif



    if( (NULL_WMC == phWMCDec) || (NULL_WMC == ptStreamDecodePattern))
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(*phWMCDec);
    
    if (pDecoder->bParsed != TRUE_WMC) 
        return( WMCDec_InValidArguments );



#ifdef WMC_NO_BUFFER_MODE

// Get the Maximum pres time if it is called while decoding


    for (i=0; i< pDecoder->tPlannedOutputInfo.wTotalOutput; i++ )
    {
        Index = pDecoder->tPlannedOutputInfo.tPlannedId[i].wStreamIndex;

        switch(pDecoder->tPlannedOutputInfo.tPlannedId[i].tMediaType)
        {
        case Audio_WMC:
            if (dwPresTime < (U32_WMC)pDecoder->tAudioStreamInfo[Index]->dwAudioTimeStamp)
                dwPresTime = (U32_WMC)pDecoder->tAudioStreamInfo[Index]->dwAudioTimeStamp;
            break;
        case Video_WMC:
            if (dwPresTime < pDecoder->tVideoStreamInfo[Index]->dwVideoTimeStamp )
                dwPresTime = pDecoder->tVideoStreamInfo[Index]->dwVideoTimeStamp;
            break;
        case Binary_WMC:
            if (dwPresTime < pDecoder->tBinaryStreamInfo[Index]->dwBinaryTimeStamp )
                dwPresTime = dwPresTime;
			break;
        }
    }
    
	if (dwPresTime >= pDecoder->tHeaderInfo.msPreroll)
		dwPresTime -= pDecoder->tHeaderInfo.msPreroll;

#endif	


    pPattern = (tStreamIdPattern_WMC*)ptStreamDecodePattern;
    
    for (i=0; i<pDecoder->tHeaderInfo.wNoOfStreams; i++)
    {
        Status = WMCDecGetMediaType(*phWMCDec,pPattern->wStreamId, &MediaType);
        if (WMCDec_Succeeded !=Status)
            return Status;

        switch(MediaType)
        {
        case Audio_WMC:
            for(j=0; j<pDecoder->tHeaderInfo.wNoOfAudioStreams; j++)
            {
                if(pPattern->wStreamId == pDecoder->tAudioStreamInfo[j]->wStreamId)
                {
                    switch(pPattern->tPattern)
                    {
                    case Discard_WMC:
						if (pDecoder->tAudioStreamInfo[j]->bWantOutput == FALSE_WMC)
						{
							pDecoder->tAudioStreamInfo[j]->bTobeDecoded = FALSE_WMC;
//							pDecoder->tAudioStreamInfo[j]->bWantOutput = FALSE_WMC;
						}
						pDecoder->tAudioStreamInfo[j]->bStopReading = TRUE_WMC;
                        break;
                    case Compressed_WMC:
						if (pDecoder->tAudioStreamInfo[j]->bWantOutput == FALSE_WMC)
						{

	#ifndef WMC_NO_BUFFER_MODE
							pDecoder->tAudioStreamInfo[j]->dwAudioBufSize = (U32_WMC)((pDecoder->tHeaderInfo.dwMaxBitrate/8.0)*((Double_WMC)pDecoder->tHeaderInfo.msPreroll/1000.0));
							if (pDecoder->tAudioStreamInfo[j]->dwAudioBufSize < (pDecoder->tHeaderInfo.dwMaxBitrate/8)*3)
								pDecoder->tAudioStreamInfo[j]->dwAudioBufSize = (pDecoder->tHeaderInfo.dwMaxBitrate/8)*3;

							pDecoder->tAudioStreamInfo[j]->pbAudioBuffer = (U8_WMC*) wmvalloc(pDecoder->tAudioStreamInfo[j]->dwAudioBufSize);
							if (pDecoder->tAudioStreamInfo[j]->pbAudioBuffer == NULL_WMC)
								Status = WMCDec_BadMemory;
	#endif

	#ifdef WMC_NO_BUFFER_MODE
							pDecoder->tAudioStreamInfo[j]->cbPacketOffset = pDecoder->tHeaderInfo.cbPacketOffset;
							pDecoder->tAudioStreamInfo[j]->cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbFirstPacketOffset;
							pDecoder->tAudioStreamInfo[j]->cbNextPacketOffset = pDecoder->tHeaderInfo.cbNextPacketOffset;
							pDecoder->tAudioStreamInfo[j]->parse_state = csWMCNewAsfPacket;
							WMCDecGetStreamToSpecificPosition (*phWMCDec,pDecoder->tAudioStreamInfo[j]->wStreamId, (U64_WMC) dwPresTime, &u64TimeReturn);
	#endif
                        
							pDecoder->tAudioStreamInfo[j]->wmar = WMA_S_NO_MORE_FRAME;
							pDecoder->tAudioStreamInfo[j]->bTobeDecoded = FALSE_WMC;
							pDecoder->tAudioStreamInfo[j]->bWantOutput = TRUE_WMC;
						
							pDecoder->tAudioStreamInfo[j]->dwAudioBufCurOffset = 0;
							pDecoder->tAudioStreamInfo[j]->cbNbFramesAudBuf = 0;
							pDecoder->tAudioStreamInfo[j]->dwAudioBufDecoded = 0;
							pDecoder->tAudioStreamInfo[j]->bBlockStart = 0;
							pDecoder->tAudioStreamInfo[j]->dwBlockLeft = 0;
							pDecoder->tAudioStreamInfo[j]->dwPayloadLeft = 0;
							pDecoder->tAudioStreamInfo[j]->dwAudPayloadPresTime = 0;
							pDecoder->tAudioStreamInfo[j]->dwAudioTimeStamp = 0.0;
						}
						pDecoder->tAudioStreamInfo[j]->bStopReading = FALSE_WMC;

                        break;
#ifndef _ASFPARSE_ONLY_
                    case Decompressed_WMC:
						if (pDecoder->tAudioStreamInfo[j]->hMSA == NULL_WMC)
						{
							if(pDecoder->tAudioStreamInfo[j]->bIsDecodable == TRUE_WMC)
							{
								if (pDecoder->tAudioStreamInfo[j]->nVersion > 0 && pDecoder->tAudioStreamInfo[j]->nVersion <4)
								{
									WMARESULT wmar = WMA_OK ;
#ifdef _V9WMADEC_								
									WMAPlayerInfo tPlayerInfo;
									U16_WMC z =0;
									U8_WMC Peak[] = {'P',0x00,'e',0x00,'a',0x00,'k',0x00,'V',0x00,'a',0x00,'l',0x00,'u',0x00,'e', 0x00, 0x00, 0x00};
									U8_WMC Average[] = {'A',0x00,'v',0x00,'e',0x00,'r',0x00,'a',0x00,'g',0x00,'e',0x00,'L',0x00,'e', 0x00, 'v',0x00,'e', 0x00,'l',0x00, 0x00, 0x00};
									memset(&tPlayerInfo, 0, sizeof(WMAPlayerInfo));

									if (pDecoder->tMetaDataEntry.pDescRec !=NULL)
									{
										for(z = 0; z < (U16_WMC)pDecoder->tMetaDataEntry.m_wDescRecordsCount; z++)
										{ 
											if ((pDecoder->tMetaDataEntry.pDescRec[z].wStreamNumber == pDecoder->tAudioStreamInfo[j]->wStreamId) ||( pDecoder->tMetaDataEntry.pDescRec[i].wStreamNumber ==0))
											{
												if (0==memcmp(Peak,pDecoder->tMetaDataEntry.pDescRec[z].pwName, pDecoder->tMetaDataEntry.pDescRec[z].wNameLenth))
												{
													tPlayerInfo.wPeakAmplitude = (U16_WMARawDec) (*(U32_WMC *)pDecoder->tMetaDataEntry.pDescRec[z].pData);
												
												}
													
												else if (0==memcmp(Average,pDecoder->tMetaDataEntry.pDescRec[z].pwName, pDecoder->tMetaDataEntry.pDescRec[z].wNameLenth))
												{
													tPlayerInfo.wRmsAmplitude = (U16_WMARawDec) (*(U32_WMC *)pDecoder->tMetaDataEntry.pDescRec[z].pData);
												
												}
											
											
											}
										
										}
									
									}
								
#endif									
									wmar = WMARawDecInit (
										&(pDecoder->tAudioStreamInfo[j]->hMSA),
										(U32_WMARawDec) pDecoder,
										(U16_WMARawDec) pDecoder->tAudioStreamInfo[j]->nVersion,
										(U16_WMARawDec) pDecoder->tAudioStreamInfo[j]->nSamplesPerBlock,
										(U16_WMARawDec) pDecoder->tAudioStreamInfo[j]->nSamplesPerSec,
										(U16_WMARawDec) pDecoder->tAudioStreamInfo[j]->nChannels,
	#ifdef _V9WMADEC_
										(U32_WMARawDec) (pDecoder->tAudioStreamInfo[j]->nBitsPerSample/8),
										(U16_WMARawDec) pDecoder->tAudioStreamInfo[j]->wValidBitsPerSample,
										(U32_WMARawDec) pDecoder->tAudioStreamInfo[j]->dwChannelMask,
	#endif

										(U16_WMARawDec) pDecoder->tAudioStreamInfo[j]->nAvgBytesPerSec,
										(U16_WMARawDec) pDecoder->tAudioStreamInfo[j]->nBlockAlign,
										(U16_WMARawDec) (pDecoder->tAudioStreamInfo[j]->nEncodeOpt /*| 0x0080*/),
	#if defined (_V9WMADEC_)
										(WMAPlayerInfo*) &tPlayerInfo
	#else
										0
	#endif
									);
									
									if (wmar == WMA_E_NOTSUPPORTED)
									{
										Status =  WMADec_UnSupportedCompressedFormat;
									}
									if (wmar != WMA_OK)
									{
										Status = WMADec_Failed;
									}
                            
	#ifndef WMC_NO_BUFFER_MODE
									pDecoder->tAudioStreamInfo[j]->dwAudioBufSize = (U32_WMC)((pDecoder->tHeaderInfo.dwMaxBitrate/8.0)*((Double_WMC)pDecoder->tHeaderInfo.msPreroll/1000.0));
									if (pDecoder->tAudioStreamInfo[j]->dwAudioBufSize < (pDecoder->tHeaderInfo.dwMaxBitrate/8)*3)
										pDecoder->tAudioStreamInfo[j]->dwAudioBufSize = (pDecoder->tHeaderInfo.dwMaxBitrate/8)*3;

                                pDecoder->tAudioStreamInfo[j]->pbAudioBuffer = (U8_WMC*) wmvalloc(pDecoder->tAudioStreamInfo[j]->dwAudioBufSize);
                                if (pDecoder->tAudioStreamInfo[j]->pbAudioBuffer == NULL_WMC)
                                    Status =  WMCDec_BadMemory;
	#endif

									pDecoder->tAudioStreamInfo[j]->wmar = WMA_S_NO_MORE_FRAME;

									pDecoder->tAudioStreamInfo[j]->bTobeDecoded = TRUE_WMC;
									pDecoder->tAudioStreamInfo[j]->bWantOutput = TRUE_WMC;
									pDecoder->tAudioStreamInfo[j]->bStopReading = FALSE_WMC;
									
								
								}
	#ifndef __NO_SPEECH__

								else if(pDecoder->tAudioStreamInfo[j]->nVersion ==4) //Speech codec
								{
                                
									WMSRESULT wmsr = WMS_OK ;

									// Initialize the Intel Library
	//	                            if( !InitNSPLibWMSP(DLL_PROCESS_ATTACH) )
									if( !MyInitNSP(INTELFFT_INIT_PROCESS) )
									{
										Status = WMADec_Failed;;
									}

	//	                            if( !InitNSPLibWMSP(DLL_THREAD_ATTACH) )
									if( !MyInitNSP(INTELFFT_INIT_THREAD) )
									{
										Status =  WMADec_Failed;
									}
                                
									wmsr = WMSRawDecInit (
											(WMSRawDecHandle*) &(pDecoder->tAudioStreamInfo[j]->hMSA),
											(U32_WMSRawDec) pDecoder,
											(U32_WMSRawDec) pDecoder->tAudioStreamInfo[j]->nSamplesPerSec, 
											(U32_WMSRawDec) pDecoder->tAudioStreamInfo[j]->nAvgBytesPerSec, 
											(U16_WMSRawDec) pDecoder->tAudioStreamInfo[j]->nChannels, 
											(U16_WMSRawDec) 5
										);

                                    
									if (wmsr == WMS_E_NOTSUPPORTED)
									{
										Status = WMADec_UnSupportedCompressedFormat;
									}
									if (wmsr != WMS_OK)
									{
										Status = WMADec_Failed;
									}

	#ifndef WMC_NO_BUFFER_MODE
									pDecoder->tAudioStreamInfo[j]->dwAudioBufSize = (U32_WMC)((pDecoder->tHeaderInfo.dwMaxBitrate/8.0)*((Double_WMC)pDecoder->tHeaderInfo.msPreroll/1000.0));
									if (pDecoder->tAudioStreamInfo[j]->dwAudioBufSize < (pDecoder->tHeaderInfo.dwMaxBitrate/8)*3)
										pDecoder->tAudioStreamInfo[j]->dwAudioBufSize = (pDecoder->tHeaderInfo.dwMaxBitrate/8)*3;

									pDecoder->tAudioStreamInfo[j]->pbAudioBuffer = (U8_WMC*) wmvalloc(pDecoder->tAudioStreamInfo[j]->dwAudioBufSize);
									if (pDecoder->tAudioStreamInfo[j]->pbAudioBuffer == NULL_WMC)
										Status =  WMCDec_BadMemory;

	#endif

						   //         pDecoder->tAudioStreamInfo[j]->wmar = WMA_S_NO_MORE_FRAME;

									pDecoder->tAudioStreamInfo[j]->bTobeDecoded = TRUE_WMC;
									pDecoder->tAudioStreamInfo[j]->bWantOutput = TRUE_WMC;
									pDecoder->tAudioStreamInfo[j]->bStopReading = FALSE_WMC;
								}
	#endif
	#ifdef WMC_NO_BUFFER_MODE
								pDecoder->tAudioStreamInfo[j]->cbPacketOffset = pDecoder->tHeaderInfo.cbPacketOffset;
								pDecoder->tAudioStreamInfo[j]->cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbFirstPacketOffset;
								pDecoder->tAudioStreamInfo[j]->parse_state = csWMCNewAsfPacket;
								pDecoder->tAudioStreamInfo[j]->cbNextPacketOffset = pDecoder->tHeaderInfo.cbNextPacketOffset;
								WMCDecGetStreamToSpecificPosition (*phWMCDec,pDecoder->tAudioStreamInfo[j]->wStreamId, (U64_WMC) dwPresTime, &u64TimeReturn);
	#endif
								pDecoder->tAudioStreamInfo[j]->dwAudioBufCurOffset = 0;
								pDecoder->tAudioStreamInfo[j]->cbNbFramesAudBuf = 0;
								pDecoder->tAudioStreamInfo[j]->dwAudioBufDecoded = 0;
								pDecoder->tAudioStreamInfo[j]->bBlockStart = 0;
								pDecoder->tAudioStreamInfo[j]->dwBlockLeft = 0;
								pDecoder->tAudioStreamInfo[j]->dwPayloadLeft = 0;
								pDecoder->tAudioStreamInfo[j]->dwAudPayloadPresTime = 0;
								pDecoder->tAudioStreamInfo[j]->dwAudioTimeStamp = 0.0;

							}
							else
							{
								pDecoder->tAudioStreamInfo[j]->bTobeDecoded = FALSE_WMC;
								pDecoder->tAudioStreamInfo[j]->bWantOutput = FALSE_WMC;
								pDecoder->tAudioStreamInfo[j]->bStopReading = TRUE_WMC;
								Status = WMADec_UnSupportedCompressedFormat;

							}
						}
                        break;
#endif //_ASFPARSE_ONLY_
                    default:
                        pDecoder->tAudioStreamInfo[j]->bTobeDecoded = FALSE_WMC;
                        pDecoder->tAudioStreamInfo[j]->bWantOutput = FALSE_WMC;
						pDecoder->tAudioStreamInfo[j]->bStopReading = TRUE_WMC;
                    }
                    
                    pDecoder->tAudioStreamInfo[j]->bFirstTime = FALSE_WMC;

					if (pDecoder->tAudioStreamInfo[j]->bWantOutput == TRUE_WMC )
                    {
                        U16_WMC k =0;
						Bool_WMC bExists = FALSE_WMC;

						for (k=0; k< pDecoder->tPlannedOutputInfo.wTotalOutput; k++)
						{
							if( (pDecoder->tPlannedOutputInfo.tPlannedId[k].wStreamIndex == j)&&(pDecoder->tPlannedOutputInfo.tPlannedId[k].tMediaType == Audio_WMC))
							{
								bExists = TRUE_WMC;
								break;
							}
						
						}
						
						
						if (bExists == FALSE_WMC)
						{
							pDecoder->tPlannedOutputInfo.tPlannedId[pDecoder->tPlannedOutputInfo.wTotalOutput].wStreamIndex = j;
							pDecoder->tPlannedOutputInfo.tPlannedId[pDecoder->tPlannedOutputInfo.wTotalOutput].tMediaType = Audio_WMC;
							pDecoder->tPlannedOutputInfo.wTotalOutput+=1;
						}
                    }
                    break;
                }
            
            }
            break;
        case Video_WMC:
            for(j=0; j<pDecoder->tHeaderInfo.wNoOfVideoStreams; j++)
            {
                if(pPattern->wStreamId == pDecoder->tVideoStreamInfo[j]->wStreamId)
                {
                    switch(pPattern->tPattern)
                    {
                    case Discard_WMC:
						if (pDecoder->tVideoStreamInfo[j]->bWantOutput == FALSE_WMC)
						{
							pDecoder->tVideoStreamInfo[j]->bTobeDecoded = FALSE_WMC;
//							pDecoder->tVideoStreamInfo[j]->bWantOutput = FALSE_WMC;
						}
						pDecoder->tVideoStreamInfo[j]->bStopReading = TRUE_WMC;
                        break;
                    case Compressed_WMC:
						if (pDecoder->tVideoStreamInfo[j]->bWantOutput == FALSE_WMC)
						{

	#ifndef WMC_NO_BUFFER_MODE
							pDecoder->tVideoStreamInfo[j]->dwVideoBufSize = (U32_WMC)((pDecoder->tHeaderInfo.dwMaxBitrate/8.0)*((Double_WMC)pDecoder->tHeaderInfo.msPreroll/1000.0 ));
							if (pDecoder->tVideoStreamInfo[j]->dwVideoBufSize < (pDecoder->tHeaderInfo.dwMaxBitrate/8)*3)
								pDecoder->tVideoStreamInfo[j]->dwVideoBufSize = (pDecoder->tHeaderInfo.dwMaxBitrate/8)*3;

							pDecoder->tVideoStreamInfo[j]->pbVideoBuffer = (U8_WMC*) wmvalloc(pDecoder->tVideoStreamInfo[j]->dwVideoBufSize);
							if (pDecoder->tVideoStreamInfo[j]->pbVideoBuffer == NULL_WMC)
								return WMCDec_BadMemory;            
	#endif
							pDecoder->tVideoStreamInfo[j]->bTobeDecoded = FALSE_WMC;
							pDecoder->tVideoStreamInfo[j]->bWantOutput = TRUE_WMC;
	#ifdef WMC_NO_BUFFER_MODE
							pDecoder->tVideoStreamInfo[j]->cbPacketOffset = pDecoder->tHeaderInfo.cbPacketOffset;
							pDecoder->tVideoStreamInfo[j]->cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbFirstPacketOffset;
							pDecoder->tVideoStreamInfo[j]->cbNextPacketOffset = pDecoder->tHeaderInfo.cbNextPacketOffset;
							pDecoder->tVideoStreamInfo[j]->parse_state = csWMCNewAsfPacket;
							pDecoder->tVideoStreamInfo[j]->dwNextVideoTimeStamp = 0;
							WMCDecGetStreamToSpecificPosition (*phWMCDec,pDecoder->tVideoStreamInfo[j]->wStreamId, (U64_WMC) dwPresTime, &u64TimeReturn);
	#endif
							pDecoder->tVideoStreamInfo[j]->dwBlockLeft =0;
							pDecoder->tVideoStreamInfo[j]->dwVideoBufCurOffset =0;
							pDecoder->tVideoStreamInfo[j]->cbNbFramesVidBuf =0;
							pDecoder->tVideoStreamInfo[j]->dwVideoBufDecoded =0;
							pDecoder->tVideoStreamInfo[j]->bFirst = FALSE_WMC;
							pDecoder->tVideoStreamInfo[j]->dwPayloadLeft = 0;
							pDecoder->tVideoStreamInfo[j]->dwVideoTimeStamp = 0;
							pDecoder->tVideoStreamInfo[j]->dwNbFrames = 0;
							pDecoder->tVideoStreamInfo[j]->cbUsed = 0;
							pDecoder->tVideoStreamInfo[j]->dwFrameSize = 0; 
							pDecoder->tVideoStreamInfo[j]->cbFrame = 0;

						}
						pDecoder->tVideoStreamInfo[j]->bStopReading = FALSE_WMC;
                        break;
                    case Decompressed_WMC:
						if (pDecoder->tVideoStreamInfo[j]->tOutVideoFormat != IYUV_WMV    &&
							pDecoder->tVideoStreamInfo[j]->tOutVideoFormat != I420_WMV    &&
							pDecoder->tVideoStreamInfo[j]->tOutVideoFormat != YUY2_WMV    &&
							pDecoder->tVideoStreamInfo[j]->tOutVideoFormat != UYVY_WMV    &&
							pDecoder->tVideoStreamInfo[j]->tOutVideoFormat != YVYU_WMV    &&
							pDecoder->tVideoStreamInfo[j]->tOutVideoFormat != RGB24_WMV   &&
							pDecoder->tVideoStreamInfo[j]->tOutVideoFormat != RGB555_WMV  &&
							pDecoder->tVideoStreamInfo[j]->tOutVideoFormat != RGB565_WMV  &&
							pDecoder->tVideoStreamInfo[j]->tOutVideoFormat != RGB32_WMV   &&
							pDecoder->tVideoStreamInfo[j]->tOutVideoFormat != YVU9_WMV    &&
							pDecoder->tVideoStreamInfo[j]->tOutVideoFormat != RGB8_WMV)
						{
							Status = WMVDec_UnSupportedOutputFormat;
							break;
						}
						
						
						if(pDecoder->tVideoStreamInfo[j]->pVDec == NULL_WMC)
						{
							if(pDecoder->tVideoStreamInfo[j]->bIsDecodable == TRUE_WMC)
							{

								{
									if(
										pDecoder->tVideoStreamInfo[j]->biCompression == FOURCC_WMV2 ||
										pDecoder->tVideoStreamInfo[j]->biCompression == FOURCC_WMV1 ||
										pDecoder->tVideoStreamInfo[j]->biCompression == FOURCC_MP4S ||
										pDecoder->tVideoStreamInfo[j]->biCompression == FOURCC_MP43 ||
										pDecoder->tVideoStreamInfo[j]->biCompression == FOURCC_MP42 )
									{
                                    
										U32_WMC   dwBitRate = 0;
										U32_WMC x=0;
#ifndef _ASFPARSE_ONLY_
										tWMVDecodeStatus VideoStatus;
#endif
										if (pDecoder->tHeaderInfo.bHasBitRateInfo == TRUE_WMC)
										{
											for (x=0; x< pDecoder->tHeaderInfo.wNoOfStreams; x++)
											{
												if (pDecoder->tHeaderInfo.tBitRateInfo[x].wStreamId == pPattern->wStreamId)
												{
													dwBitRate = pDecoder->tHeaderInfo.tBitRateInfo[x].dwBitRate;
													break;
                                            
												}
											}
                                    
                                    
										}
                                    
                                    
	//                                    tWMVDecodeStatus VideoStatus;
									  //  hWMVDec = WMVideo8DecoderCreate ();
#ifndef _ASFPARSE_ONLY_
										 VideoStatus = WMVideoDecInit (
											(HWMVDecoder*)&(pDecoder->tVideoStreamInfo[j]->pVDec),
											(U32_WMC)pDecoder,
											pDecoder->tVideoStreamInfo[j]->biCompression,
											0.0,
											(Float_WMV)dwBitRate,
											pDecoder->tVideoStreamInfo[j]->biWidth,
											pDecoder->tVideoStreamInfo[j]->biHeight,
											(I32_WMV)pDecoder->i32PostProc
										);

										if (VideoStatus != WMV_Succeeded)
											Status = WMVDec_Failed;

#endif
#ifndef WMC_NO_BUFFER_MODE
										pDecoder->tVideoStreamInfo[j]->dwVideoBufSize = (U32_WMC)((pDecoder->tHeaderInfo.dwMaxBitrate/8.0)*((Double_WMC)pDecoder->tHeaderInfo.msPreroll/1000.0));
										if (pDecoder->tVideoStreamInfo[j]->dwVideoBufSize < (pDecoder->tHeaderInfo.dwMaxBitrate/8)*5)
											pDecoder->tVideoStreamInfo[j]->dwVideoBufSize = (pDecoder->tHeaderInfo.dwMaxBitrate/8)*5;
#else
										pDecoder->tVideoStreamInfo[j]->dwVideoBufSize = (U32_WMC)(pDecoder->tVideoStreamInfo[j]->biSizeImage);
#endif
										pDecoder->tVideoStreamInfo[j]->pbVideoBuffer = (U8_WMC*) wmvalloc(pDecoder->tVideoStreamInfo[j]->dwVideoBufSize);
										if (pDecoder->tVideoStreamInfo[j]->pbVideoBuffer == NULL_WMC)
											Status = WMCDec_BadMemory;            

                                    
										if (pDecoder->tVideoStreamInfo[j]->biCompression  == FOURCC_MP4S || pDecoder->tVideoStreamInfo[j]->biCompression == FOURCC_WMV2)
										{
											pDecoder->i32CurrentVideoStreamIndex = j;
											pDecoder->tVideoStreamInfo[j]->bInitStage = TRUE_WMC;
#ifndef WMC_NO_BUFFER_MODE
											memcpy(pDecoder->tVideoStreamInfo[j]->pbVideoBuffer, pDecoder->tVideoStreamInfo[j]->bAdditionalInfo, pDecoder->tVideoStreamInfo[j]->biSize - sizeof (BITMAPINFOHEADER) );
											pDecoder->tVideoStreamInfo[j]->dwVideoBufCurOffset = pDecoder->tVideoStreamInfo[j]->biSize - sizeof (BITMAPINFOHEADER);
#endif
#ifndef _ASFPARSE_ONLY_
											VideoStatus =  WMVideoDecDecodeSequenceHeader ((HWMVDecoder) pDecoder->tVideoStreamInfo[j]->pVDec);

											if (VideoStatus != WMV_Succeeded)
												Status = WMVDec_Failed;
#endif
											//WMVideo8DecoderSetExtendedFormat (hWMVDec, pDecoder->bAdditionalInfo , pDecoder->biSize  - sizeof (BITMAPINFOHEADER)); //////////////////
										}
										// Reset all vars again    

										
										pDecoder->tVideoStreamInfo[j]->bInitStage = FALSE_WMC;
										pDecoder->tVideoStreamInfo[j]->bBlockStart = TRUE_WMC;
										pDecoder->tVideoStreamInfo[j]->dwBlockLeft =0;
										pDecoder->tVideoStreamInfo[j]->dwVideoBufCurOffset =0;
										pDecoder->tVideoStreamInfo[j]->cbNbFramesVidBuf =0;
										pDecoder->tVideoStreamInfo[j]->dwVideoBufDecoded =0;
										pDecoder->tVideoStreamInfo[j]->bFirst = FALSE_WMC;
										pDecoder->tVideoStreamInfo[j]->dwPayloadLeft = 0;
										pDecoder->tVideoStreamInfo[j]->dwVideoTimeStamp = 0;
										pDecoder->tVideoStreamInfo[j]->dwNbFrames = 0;
										pDecoder->tVideoStreamInfo[j]->cbUsed = 0;
										pDecoder->tVideoStreamInfo[j]->dwFrameSize = 0; 
										pDecoder->tVideoStreamInfo[j]->cbFrame = 0;
										


	#ifdef WMC_NO_BUFFER_MODE
										pDecoder->tVideoStreamInfo[j]->cbPacketOffset = pDecoder->tHeaderInfo.cbPacketOffset;
										pDecoder->tVideoStreamInfo[j]->cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbFirstPacketOffset;
										pDecoder->tVideoStreamInfo[j]->cbNextPacketOffset = pDecoder->tHeaderInfo.cbNextPacketOffset;
										pDecoder->tVideoStreamInfo[j]->parse_state = csWMCNewAsfPacket;
										pDecoder->tVideoStreamInfo[j]->dwNextVideoTimeStamp = 0;
										WMCDecGetStreamToSpecificPosition (*phWMCDec,pDecoder->tVideoStreamInfo[j]->wStreamId, (U64_WMC) dwPresTime, &u64TimeReturn);
	#endif
                                  
										pDecoder->tVideoStreamInfo[j]->bTobeDecoded = TRUE_WMC;
										pDecoder->tVideoStreamInfo[j]->bWantOutput = TRUE_WMC;
										pDecoder->tVideoStreamInfo[j]->bStopReading = FALSE_WMC;
									}
	///////////////////////////////////////////////////
	#ifndef __NO_SCREEN__
									else if(pDecoder->tVideoStreamInfo[j]->biCompression == FOURCC_MSS1 ||
											pDecoder->tVideoStreamInfo[j]->biCompression == FOURCC_MSS2)
									{
										LPBITMAPINFOHEADER    lpbiSrc = NULL_WMC;
										BITMAPINFOHEADER      BitmapInfo;  
										HRESULT hr;

										hSCdec = WMScreenDecoderCreate();
										pDecoder->tVideoStreamInfo[j]->pVDec = hSCdec;
										pDecoder->tVideoStreamInfo[j]->bTobeDecoded = TRUE_WMC;
										pDecoder->tVideoStreamInfo[j]->bWantOutput = TRUE_WMC;



										memset(&BitmapInfo,0,sizeof(BITMAPINFOHEADER));

										pDecoder->tVideoStreamInfo[j]->bIsDecodable = TRUE_WMC;
										pDecoder->tVideoStreamInfo[j]->biSizeImageOut = (pDecoder->tVideoStreamInfo[j]->biWidth)*(pDecoder->tVideoStreamInfo[j]->biHeight)*(pDecoder->tVideoStreamInfo[j]->biBitCountOut)/8;

										BitmapInfo.biBitCount = pDecoder->tVideoStreamInfo[j]->biBitCountOut;
										BitmapInfo.biCompression  = pDecoder->tVideoStreamInfo[j]->biCompressionOut;
										BitmapInfo.biHeight  = pDecoder->tVideoStreamInfo[j]->biHeight;
										BitmapInfo.biWidth  = pDecoder->tVideoStreamInfo[j]->biWidth;
										BitmapInfo.biSizeImage = pDecoder->tVideoStreamInfo[j]->biSizeImageOut;
										BitmapInfo.biSize  = sizeof (BITMAPINFOHEADER);


										lpbiSrc = &BitmapInfo;
										hr = WMScreenDecoderInit( pDecoder->tVideoStreamInfo[j]->pVDec, 
											pDecoder->tVideoStreamInfo[j]->bAdditionalInfo,
											pDecoder->tVideoStreamInfo[j]->biSize  - sizeof (BITMAPINFOHEADER),
											lpbiSrc);

										if (FAILED(hr))
										{
											pDecoder->tVideoStreamInfo[j]->biBitCountOut = pDecoder->tVideoStreamInfo[i]->biBitCount;
											pDecoder->tVideoStreamInfo[j]->biCompressionOut = pDecoder->tVideoStreamInfo[i]->biCompression;
											pDecoder->tVideoStreamInfo[j]->biSizeImageOut = pDecoder->tVideoStreamInfo[i]->biSizeImage;

											pDecoder->tVideoStreamInfo[j]->bIsDecodable = FALSE_WMC;
											pDecoder->tVideoStreamInfo[j]->bTobeDecoded = FALSE_WMC;
											Status =  WMVDec_Failed;
										}

										pDecoder->tVideoStreamInfo[j]->pSCInBuffer = wmvalloc(pDecoder->tVideoStreamInfo[j]->biSizeImageOut);
										pDecoder->tVideoStreamInfo[j]->pSCOutBuffer = wmvalloc(pDecoder->tVideoStreamInfo[j]->biSizeImageOut);

										if(pDecoder->tVideoStreamInfo[j]->pSCInBuffer == NULL_WMC || pDecoder->tVideoStreamInfo[j]->pSCOutBuffer == NULL_WMC)
										{
											Status =  WMCDec_BadMemory;
                
										}

	#ifndef WMC_NO_BUFFER_MODE
										pDecoder->tVideoStreamInfo[j]->dwVideoBufSize = (U32_WMC)((pDecoder->tHeaderInfo.dwMaxBitrate/8.0)*((Double_WMC)pDecoder->tHeaderInfo.msPreroll/1000.0));
										if (pDecoder->tVideoStreamInfo[j]->dwVideoBufSize < (pDecoder->tHeaderInfo.dwMaxBitrate/8)*5)
											pDecoder->tVideoStreamInfo[j]->dwVideoBufSize = (pDecoder->tHeaderInfo.dwMaxBitrate/8)*5;

	#else
										pDecoder->tVideoStreamInfo[j]->dwVideoBufSize = (U32_WMC)(pDecoder->tVideoStreamInfo[j]->biSizeImage);
	#endif

										pDecoder->tVideoStreamInfo[j]->pbVideoBuffer = (U8_WMC*)wmvalloc(pDecoder->tVideoStreamInfo[j]->dwVideoBufSize);
										if (pDecoder->tVideoStreamInfo[j]->pbVideoBuffer == NULL_WMC)
											Status =  WMCDec_BadMemory;            

										pDecoder->tVideoStreamInfo[j]->bTobeDecoded = TRUE_WMC;
										pDecoder->tVideoStreamInfo[j]->bWantOutput = TRUE_WMC;
										pDecoder->tVideoStreamInfo[j]->bStopReading = FALSE_WMC;
										pDecoder->tVideoStreamInfo[j]->bInitStage = FALSE_WMC;
										pDecoder->tVideoStreamInfo[j]->bBlockStart = TRUE_WMC;
										pDecoder->tVideoStreamInfo[j]->dwBlockLeft =0;
										pDecoder->tVideoStreamInfo[j]->dwVideoBufCurOffset =0;
										pDecoder->tVideoStreamInfo[j]->cbNbFramesVidBuf =0;
										pDecoder->tVideoStreamInfo[j]->dwVideoBufDecoded =0;
										pDecoder->tVideoStreamInfo[j]->bFirst = FALSE_WMC;
										pDecoder->tVideoStreamInfo[j]->dwPayloadLeft = 0;
										pDecoder->tVideoStreamInfo[j]->dwVideoTimeStamp = 0;
										pDecoder->tVideoStreamInfo[j]->dwNbFrames = 0;
										pDecoder->tVideoStreamInfo[j]->cbUsed = 0;
										pDecoder->tVideoStreamInfo[j]->dwFrameSize = 0; 
										pDecoder->tVideoStreamInfo[j]->cbFrame = 0;

	#ifdef WMC_NO_BUFFER_MODE
										pDecoder->tVideoStreamInfo[j]->cbPacketOffset = pDecoder->tHeaderInfo.cbPacketOffset;
										pDecoder->tVideoStreamInfo[j]->cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbFirstPacketOffset;
										pDecoder->tVideoStreamInfo[j]->cbNextPacketOffset = pDecoder->tHeaderInfo.cbNextPacketOffset;
										pDecoder->tVideoStreamInfo[j]->parse_state = csWMCNewAsfPacket;
										pDecoder->tVideoStreamInfo[j]->dwNextVideoTimeStamp = 0;
										WMCDecGetStreamToSpecificPosition (*phWMCDec,pDecoder->tVideoStreamInfo[j]->wStreamId, (U64_WMC) dwPresTime, &u64TimeReturn);
	#endif
									}
	#endif            
	//////////////////////////////////////////////////								
									
									else
									{
										pDecoder->tVideoStreamInfo[j]->bTobeDecoded = FALSE_WMC;
										pDecoder->tVideoStreamInfo[j]->bStopReading = FALSE_WMC;
										pDecoder->tVideoStreamInfo[j]->bWantOutput = TRUE_WMC;
										Status = WMVDec_UnSupportedCompressedFormat;
									}
								}
                            
							}
							else
							{
								pDecoder->tVideoStreamInfo[j]->bTobeDecoded = FALSE_WMC;
								pDecoder->tVideoStreamInfo[j]->bWantOutput = FALSE_WMC;
								pDecoder->tVideoStreamInfo[j]->bStopReading = TRUE_WMC;
								Status = WMVDec_UnSupportedCompressedFormat;
							}
						}
                        break;
                    default:
                        pDecoder->tVideoStreamInfo[j]->bTobeDecoded = FALSE_WMC;
                        pDecoder->tVideoStreamInfo[j]->bWantOutput = FALSE_WMC;
						pDecoder->tVideoStreamInfo[j]->bStopReading = TRUE_WMC;
                    
                    }
                    if (pDecoder->tVideoStreamInfo[j]->bWantOutput == TRUE_WMC )
                    {
                        U16_WMC k =0;
						Bool_WMC bExists = FALSE_WMC;

						for (k=0; k< pDecoder->tPlannedOutputInfo.wTotalOutput; k++)
						{
							if ((pDecoder->tPlannedOutputInfo.tPlannedId[k].wStreamIndex == j)&&(pDecoder->tPlannedOutputInfo.tPlannedId[k].tMediaType == Video_WMC))
							{
								bExists = TRUE_WMC;
								break;
							}
						
						}
						if (bExists == FALSE_WMC)
						{
							pDecoder->tPlannedOutputInfo.tPlannedId[pDecoder->tPlannedOutputInfo.wTotalOutput].wStreamIndex = j;
							pDecoder->tPlannedOutputInfo.tPlannedId[pDecoder->tPlannedOutputInfo.wTotalOutput].tMediaType = Video_WMC;
							pDecoder->tPlannedOutputInfo.wTotalOutput+=1;
						}
                    }
                    break;
                }
				pDecoder->tVideoStreamInfo[j]->bHasGivenAnyOutput = FALSE_WMC;
				pDecoder->tVideoStreamInfo[j]->bNowStopReadingAndDecoding = FALSE_WMC;
            
            }
            break;
        case Binary_WMC:
            for(j=0; j<pDecoder->tHeaderInfo.wNoOfBinaryStreams; j++)
            {
                if(pPattern->wStreamId == pDecoder->tBinaryStreamInfo[j]->wStreamId)
                {
                    switch(pPattern->tPattern)
                    {
                    case Discard_WMC:
//						if (pDecoder->tBinaryStreamInfo[j]->bWantOutput == FALSE_WMC)
//							pDecoder->tBinaryStreamInfo[j]->bWantOutput = FALSE_WMC;
						pDecoder->tBinaryStreamInfo[j]->bStopReading = TRUE_WMC;
                        break;
                    case Compressed_WMC:
                    case Decompressed_WMC:
						if (pDecoder->tBinaryStreamInfo[j]->bWantOutput != TRUE_WMC)
						{
	#ifndef WMC_NO_BUFFER_MODE
						pDecoder->tBinaryStreamInfo[j]->dwBinaryBufSize = (U32_WMC)((pDecoder->tHeaderInfo.dwMaxBitrate/8.0)*((Double_WMC)pDecoder->tHeaderInfo.msPreroll/1000.0));
						if (pDecoder->tBinaryStreamInfo[j]->dwBinaryBufSize < (pDecoder->tHeaderInfo.dwMaxBitrate/8)*3)
							pDecoder->tBinaryStreamInfo[j]->dwBinaryBufSize = (pDecoder->tHeaderInfo.dwMaxBitrate/8)*3;

						pDecoder->tBinaryStreamInfo[j]->pbBinaryBuffer = (U8_WMC*)wmvalloc(pDecoder->tBinaryStreamInfo[j]->dwBinaryBufSize);
						if (pDecoder->tBinaryStreamInfo[j]->pbBinaryBuffer == NULL_WMC)
							Status = WMCDec_BadMemory;            
	#endif
							pDecoder->tBinaryStreamInfo[j]->bWantOutput = TRUE_WMC;
	#ifdef WMC_NO_BUFFER_MODE
								pDecoder->tBinaryStreamInfo[j]->cbPacketOffset = pDecoder->tHeaderInfo.cbPacketOffset;
								pDecoder->tBinaryStreamInfo[j]->cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbFirstPacketOffset;
								pDecoder->tBinaryStreamInfo[j]->cbNextPacketOffset = pDecoder->tHeaderInfo.cbNextPacketOffset;
								pDecoder->tBinaryStreamInfo[j]->parse_state = csWMCNewAsfPacket;
								pDecoder->tBinaryStreamInfo[j]->dwNextBinaryTimeStamp = 0;
								WMCDecGetStreamToSpecificPosition (*phWMCDec,pDecoder->tBinaryStreamInfo[j]->wStreamId, (U64_WMC) dwPresTime, &u64TimeReturn);
	#endif
								pDecoder->tBinaryStreamInfo[j]->bWantOutput = TRUE_WMC;
								pDecoder->tBinaryStreamInfo[j]->bStopReading = FALSE_WMC;

								pDecoder->tBinaryStreamInfo[j]->dwBlockLeft =0;
								pDecoder->tBinaryStreamInfo[j]->dwBinaryBufCurOffset =0;
								pDecoder->tBinaryStreamInfo[j]->cbNbFramesBinBuf =0;
								pDecoder->tBinaryStreamInfo[j]->dwBinaryBufDecoded =0;
								pDecoder->tBinaryStreamInfo[j]->dwPayloadLeft = 0;
								pDecoder->tBinaryStreamInfo[j]->dwBinaryTimeStamp = 0;
								pDecoder->tBinaryStreamInfo[j]->dwNbFrames = 0;
								pDecoder->tBinaryStreamInfo[j]->cbUsed = 0;
								pDecoder->tBinaryStreamInfo[j]->dwFrameSize = 0; 
								pDecoder->tBinaryStreamInfo[j]->cbFrame = 0;

						}
                        break;
                    default:
                        pDecoder->tBinaryStreamInfo[j]->bWantOutput = FALSE_WMC;
						pDecoder->tBinaryStreamInfo[j]->bStopReading = TRUE_WMC;
                    
                    }
                    if (pDecoder->tBinaryStreamInfo[j]->bWantOutput == TRUE_WMC )
                    {
                        U16_WMC k =0;
						Bool_WMC bExists = FALSE_WMC;

						for (k=0; k< pDecoder->tPlannedOutputInfo.wTotalOutput; k++)
						{
							if ((pDecoder->tPlannedOutputInfo.tPlannedId[k].wStreamIndex == j)&&(pDecoder->tPlannedOutputInfo.tPlannedId[k].tMediaType == Binary_WMC))
							{
								bExists = TRUE_WMC;
								break;
							}
						
						}
						if (bExists == FALSE_WMC)
						{
							pDecoder->tPlannedOutputInfo.tPlannedId[pDecoder->tPlannedOutputInfo.wTotalOutput].wStreamIndex = j;
							pDecoder->tPlannedOutputInfo.tPlannedId[pDecoder->tPlannedOutputInfo.wTotalOutput].tMediaType = Binary_WMC;
							pDecoder->tPlannedOutputInfo.wTotalOutput+=1;
						}
                    }
                    
                    break;
                }
				pDecoder->tBinaryStreamInfo[j]->bHasGivenAnyOutput = FALSE_WMC;
				pDecoder->tBinaryStreamInfo[j]->bNowStopReadingAndDecoding = FALSE_WMC;
            }
            break;
        default:
            return WMCDec_InValidArguments;

        }
    
        pPattern++;
    }

/*	#ifdef WMC_NO_BUFFER_MODE

		if (dwPresTime >= pDecoder->tHeaderInfo.msPreroll)
			dwPresTime -= pDecoder->tHeaderInfo.msPreroll;

		Status = WMCDecSeek(*phWMCDec, (U64_WMC) dwPresTime, &u64TimeReturn );

	#endif

*/
	if ((0 == pDecoder->tPlannedOutputInfo.wTotalOutput) && (Status ==WMCDec_Succeeded))
	{
		Status = WMCDec_NoOutput;
	}
	else if ((Status == WMVDec_UnSupportedCompressedFormat) || (Status == WMADec_UnSupportedCompressedFormat))
	{
		Status = WMCDec_UnSupportedCompressedFormats;
	}

    return Status;
}


/******************************************************************************/

tWMCDecStatus WMCDecGetMediaType (HWMCDECODER hWMCDec, U16_WMC wStreamId, tMediaType_WMC * pMediaType)
{
    tWMCDecStatus Status = WMCDec_Succeeded;
    WMFDecoderEx *pDecoder = NULL_WMC;
    tStreamIdnMediaType_WMC* pStreamIdnMediaType = NULL_WMC;
    U16_WMC i=0;
    Bool_WMC bDone = FALSE_WMC;

    if( (NULL_WMC == hWMCDec) || (NULL_WMC == pMediaType))
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(hWMCDec);
    
    if (pDecoder->bParsed != TRUE_WMC) 
        return( WMCDec_InValidArguments );

    pStreamIdnMediaType = pDecoder->pStreamIdnMediaType;

    for (i=0; i<pDecoder->tHeaderInfo.wNoOfStreams; i++)
    {
        if(wStreamId == pStreamIdnMediaType->wStreamId)
        {
            *pMediaType = pStreamIdnMediaType->MediaType;
            bDone = TRUE_WMC;
            break;
        }

        pStreamIdnMediaType++;
    }

    if (bDone != TRUE_WMC)
        Status = WMCDec_InvalidStreamType;

    return Status;

}

/******************************************************************************/
typedef struct WmaGetDataParam
{
	U32_WMC  m_dwUser;
	Bool_WMC m_fTimeIsValid;
	I64_WMC  m_iTime;
} WmaGetDataParam;

WMARESULT WMARawDecCBGetData (U8_WMARawDec **ppBuffer, U32_WMARawDec *pcbBuffer, U32_WMARawDec dwUserData)
{
    
	tWMCDecStatus err = WMCDec_Succeeded;
    WMFDecoderEx *pDecoder =NULL_WMC;
	HWMCDECODER hWMCDec;
    U32_WMARawDec cbData = 128;//MIN_WANTED
    U16_WMC AudioStreamIndex = 0;
#ifdef WMC_NO_BUFFER_MODE
    U32_WMC cbWanted=0;
    U32_WMC cbActual=0;
    U8_WMC *pData= NULL;
    tWMCParseState  parse_state;
#endif

#ifdef _V9WMADEC_
    WmaGetDataParam *pWmaGetDataParam = (WmaGetDataParam *)dwUserData;
	hWMCDec = (HWMCDECODER)(pWmaGetDataParam->m_dwUser);

//    pDecoder = (WMFDecoderEx *)(pWmaGetDataParam->m_dwUser);
    pWmaGetDataParam->m_fTimeIsValid = 0;
#else
	hWMCDec = (HWMCDECODER)(dwUserData);
#endif

    pDecoder = (WMFDecoderEx *)hWMCDec;

    if(pDecoder == NULL_WMC || ppBuffer == NULL_WMC || pcbBuffer == NULL_WMC)
    {
        if(ppBuffer != NULL_WMC)
            *ppBuffer = NULL_WMC;
        if(pcbBuffer != NULL_WMC)
            *pcbBuffer = 0;

        return WMA_E_INVALIDARG;
    }

    *ppBuffer = NULL_WMC;
    *pcbBuffer = 0;
    
    AudioStreamIndex = (U16_WMC)pDecoder->i32CurrentAudioStreamIndex; 

#ifndef WMC_NO_BUFFER_MODE

	if ((pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft ==0) && (pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft == 0)) // New Payload
	{

		if(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded > 0)
		{
			if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufCurOffset > pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded)
			{
				pDecoder->tAudioStreamInfo[AudioStreamIndex]->cbNbFramesAudBuf-=1;
				memmove(pDecoder->tAudioStreamInfo[AudioStreamIndex]->pbAudioBuffer, pDecoder->tAudioStreamInfo[AudioStreamIndex]->pbAudioBuffer + pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded,(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufCurOffset - pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded));
				pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufCurOffset = pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufCurOffset - pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded;//pDecoder->dwAudioBufDecoded; 
				pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded=0;
			}

		}
		
		
		memcpy (&(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudPayloadPresTime),(pDecoder->tAudioStreamInfo[AudioStreamIndex]->pbAudioBuffer + pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded), sizeof(U32_WMC));
		memcpy (&(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft),(pDecoder->tAudioStreamInfo[AudioStreamIndex]->pbAudioBuffer + pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded + sizeof(U32_WMC) ), sizeof(U32_WMC));
		pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded += 2*sizeof(U32_WMC);
//		pDecoder->dwAudioTimeStamp = pDecoder->dwAudPayloadPresTime;
        if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->bFirstTime == FALSE_WMC)
		{
			pDecoder->tAudioStreamInfo[AudioStreamIndex]->bFirstTime = TRUE_WMC;
		}
		else
			pDecoder->tAudioStreamInfo[AudioStreamIndex]->bTimeToChangex = TRUE_WMC; 

#ifdef _V9WMADEC_
        pDecoder = (WMFDecoderEx *)(pWmaGetDataParam->m_dwUser);
        pWmaGetDataParam->m_fTimeIsValid = 1;
        pWmaGetDataParam->m_iTime = (I64_WMC)(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudPayloadPresTime - pDecoder->tHeaderInfo.msPreroll)* 10000;
        pDecoder->tAudioStreamInfo[AudioStreamIndex]->bTimeToChangex = FALSE_WMC; 
#endif
    }

	if(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft == 0)
	{
		pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart = 1;
		pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft = pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign;
		pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft = pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft - pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign;
	}

	if (cbData > pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft )
		cbData = pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft;

	if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded + cbData > pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufCurOffset)
	{
		*ppBuffer = NULL_WMC;
		*pcbBuffer = 0;
		return WMA_S_NEWPACKET;
	}
	

	memcpy(pDecoder->tAudioStreamInfo[AudioStreamIndex]->bAudioBuffer,  pDecoder->tAudioStreamInfo[AudioStreamIndex]->pbAudioBuffer + pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded, cbData);
	*ppBuffer = pDecoder->tAudioStreamInfo[AudioStreamIndex]->bAudioBuffer; 
	*pcbBuffer = cbData;
	pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft-=cbData;

	pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded += (U32_WMC)cbData;

	if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart == 1)
	{
		pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart=0;
		return WMA_S_NEWPACKET;
	}

#else
	do
	{
		switch (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bIsCompressedPayload)
		{

		case 1:
			{
				do
				{
					switch (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bSubPayloadState)
					{
					case 1: // Compressed payload just started
						cbWanted = 1; //to read subpayload length
						cbActual = WMCDecCBGetData(hWMCDec, pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset, cbWanted, &pData, pDecoder->u32UserData);

						if(cbActual != cbWanted)
						{
							return WMCDec_BufferTooSmall;
						}

						pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset += cbWanted;
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart = TRUE_WMC;
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft = pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign;
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubCount =0;
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize = pData[0];
						
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft = pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize;
						if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft > 0)
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft -= (U16_WMC)pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft;

						if( pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wTotalDataBytes > pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize)
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wBytesRead = pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize+1;
						else if ( pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wTotalDataBytes == pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize)
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wBytesRead = pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize;

						pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bSubPayloadState = 2;
				        pDecoder->tAudioStreamInfo[AudioStreamIndex]->bTimeToChangex = TRUE_WMC; 

						break;
					case 2: // Subpayload started
						if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft == 0 && pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft == 0)
						{
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bSubPayloadState =3;
							break;
						}
						else
						{
							if(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft == 0)
							{
								if (/*pInt->dwPayloadLeft*/pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft == 0) /* done with the file */
									return WMA_S_NEWPACKET;

								if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft > 0)
									pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft -= (U16_WMC) pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign;
								pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart = TRUE_WMC;
								pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft = pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign;
							}
							if(cbData > pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft)
								cbData = pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft;

							*pcbBuffer = WMCDecCBGetData(hWMCDec, pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset, cbData, &pData, pDecoder->u32UserData);
                            if (*pcbBuffer != cbData )
                                return WMA_E_NOMOREINPUT;

							memcpy(pDecoder->tAudioStreamInfo[AudioStreamIndex]->bAudioBuffer, pData, cbData);

							*ppBuffer = pDecoder->tAudioStreamInfo[AudioStreamIndex]->bAudioBuffer;

							pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset+=*pcbBuffer;
							//pInt->payload.wSubpayloadLeft -= *pcbBuffer;
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft     -= *pcbBuffer;
                

							if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart) 
							{
								if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft == pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize - pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign)
								{
#ifdef _V9WMADEC_
									pWmaGetDataParam->m_fTimeIsValid = 1;
									pWmaGetDataParam->m_iTime = 10000 * (I64_WMC)( (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.msObjectPres - pDecoder->tHeaderInfo.msPreroll) + pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.dwDeltaPresTime * pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubCount);
#endif
									pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubCount++;
								}
								pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart = FALSE_WMC;
								return WMA_S_NEWPACKET;
							}

							return WMA_OK;
						}

						break;
					case 3: // Subpayload finished
						if ( pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wTotalDataBytes > pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wBytesRead)
						{ // there are payloads to decode
							cbWanted = 1; //to read subpayload length
							cbActual = WMCDecCBGetData(hWMCDec, pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset, cbWanted, &pData, pDecoder->u32UserData);

							if(cbActual != cbWanted)
							{
								return WMCDec_BufferTooSmall;
							}

							pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset += cbWanted;
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart     = TRUE_WMC;
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft     = pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign;
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioTimeStamp += (Double_WMC)pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.dwDeltaPresTime;
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->bTimeToChangex = TRUE_WMC; 

                    
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize = pData[0];
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft = pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize;
							if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft > 0)
								pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft -= (U16_WMC)pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft;
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wBytesRead+= (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize+1);
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bSubPayloadState =2;                
						}
						else
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bSubPayloadState =4; // all subpayloads finished
						break;

					case 4: // All Subpayloads finished

						parse_state = pDecoder->tAudioStreamInfo[AudioStreamIndex]->parse_state;
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bSubPayloadState =0;
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft =0;
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bIsCompressedPayload =0;

						pDecoder->tAudioStreamInfo[AudioStreamIndex]->parse_state = csWMCDecodePayloadEnd;
						
						err = WMCDecUpdateNewPayload(hWMCDec, Audio_WMC, AudioStreamIndex);
						if (err != WMCDec_Succeeded)
						{
							*pcbBuffer = 0;
                            pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bSubPayloadState =4;
							return WMA_OK;
						}

						pDecoder->tAudioStreamInfo[AudioStreamIndex]->parse_state = parse_state;  //restore 
						if((err != WMCDec_Succeeded)) 
							return WMA_S_NEWPACKET;
						break;
					default:
						break;

					}
				} while(pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bIsCompressedPayload);

				break;
			}          
		default :
			{
				if(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft == 0 && pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft == 0)
				{

					parse_state = pDecoder->tAudioStreamInfo[AudioStreamIndex]->parse_state;

					pDecoder->tAudioStreamInfo[AudioStreamIndex]->parse_state = csWMCDecodePayloadEnd;
					err = WMCDecUpdateNewPayload(hWMCDec, Audio_WMC, AudioStreamIndex);
					if (err != WMCDec_Succeeded)
					{
						*pcbBuffer = 0;
                        pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bSubPayloadState =4;
						return WMA_OK;
					}
					pDecoder->tAudioStreamInfo[AudioStreamIndex]->parse_state = parse_state; /* restore */
					pDecoder->tAudioStreamInfo[AudioStreamIndex]->bTimeToChangex = TRUE_WMC; 
					
					if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bIsCompressedPayload ==1)
						break;
					if(err != WMCDec_Succeeded)
						return WMA_S_NEWPACKET;
				}

				/* return as much as we currently have left */

				if(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft == 0)
				{
					if(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft == 0)
					{
						/* done with the file */
						return WMA_S_NEWPACKET;
					}

					pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft -= pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign;
					pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart = TRUE_WMC;
					pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft = pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign;
				}
				if(cbData > pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft)
					cbData = pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft;

				*pcbBuffer = WMCDecCBGetData(hWMCDec, pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset, cbData, &pData, pDecoder->u32UserData);

                if (*pcbBuffer != cbData )
                    return WMA_E_NOMOREINPUT;

				memcpy(pDecoder->tAudioStreamInfo[AudioStreamIndex]->bAudioBuffer, pData, cbData);

				*ppBuffer = pDecoder->tAudioStreamInfo[AudioStreamIndex]->bAudioBuffer;

				pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset+=*pcbBuffer;
				//pInt->payload.wSubpayloadLeft -= *pcbBuffer;
				pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft     -= *pcbBuffer;


				if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart) {
					pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart = FALSE_WMC;
                    //hopefully the following test if the beginning of a payload
                    if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft == pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.cbPayloadSize - pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign)
                    {
#ifdef _V9WMADEC_
						pWmaGetDataParam->m_fTimeIsValid = 1;
						pWmaGetDataParam->m_iTime = 10000 * (I64_WMC)( (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.msObjectPres - pDecoder->tHeaderInfo.msPreroll) );
#endif
                    }
					return WMA_S_NEWPACKET;
				}

				return WMA_OK;
			}
		}


	}while(1);

#endif
	return WMA_OK;
}

/***********************************************************************/
// For Arm CE 
int WMA_GetMoreData(unsigned char **ppBuffer, unsigned int *pcbBufLen,
                    unsigned int user_data)
{
    WMARESULT      wmasResult;

    wmasResult = WMARawDecCBGetData (ppBuffer, (unsigned long*)pcbBufLen, (unsigned long)user_data);

    return wmasResult;

}
/******************************************************************************/
#ifndef __NO_SPEECH__
WMSRESULT WMSRawDecCBGetData( U8_WMSRawDec  **ppBuffer, U32_WMSRawDec *pcbBuffer, U32_WMSRawDec dwUserData)
{
    
	tWMCDecStatus err = WMCDec_Succeeded;
    WMFDecoderEx *pDecoder =NULL_WMC;
	U32_WMARawDec cbData = MIN_WANTED;
    U16_WMC AudioStreamIndex = 0;
#ifdef WMC_NO_BUFFER_MODE
    U32_WMC cbWanted=0;
    U32_WMC cbActual=0;
    U8_WMC *pData= NULL;
    tWMCParseState  parse_state;
#endif
    pDecoder = (WMFDecoderEx *)dwUserData;


    if(pDecoder == NULL_WMC || ppBuffer == NULL_WMC || pcbBuffer == NULL_WMC)
    {
        if(ppBuffer != NULL_WMC)
            *ppBuffer = NULL_WMC;
        if(pcbBuffer != NULL_WMC)
            *pcbBuffer = 0;

        return WMS_E_INVALIDARG;
    }

    *ppBuffer = NULL_WMC;
    *pcbBuffer = 0;
    
    AudioStreamIndex = (U16_WMC)pDecoder->i32CurrentAudioStreamIndex; 

#ifndef WMC_NO_BUFFER_MODE

	if ((pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft ==0) && (pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft == 0)) // New Payload
	{

		if(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded > 0)
		{
			if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufCurOffset > pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded)
			{
				pDecoder->tAudioStreamInfo[AudioStreamIndex]->cbNbFramesAudBuf-=1;
				memmove(pDecoder->tAudioStreamInfo[AudioStreamIndex]->pbAudioBuffer, pDecoder->tAudioStreamInfo[AudioStreamIndex]->pbAudioBuffer + pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded,(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufCurOffset - pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded));
				pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufCurOffset = pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufCurOffset - pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded;//pDecoder->dwAudioBufDecoded; 
				pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded=0;
			}

		}
		
		
		memcpy (&(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudPayloadPresTime),(pDecoder->tAudioStreamInfo[AudioStreamIndex]->pbAudioBuffer + pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded), sizeof(U32_WMC));
		memcpy (&(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft),(pDecoder->tAudioStreamInfo[AudioStreamIndex]->pbAudioBuffer + pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded + sizeof(U32_WMC) ), sizeof(U32_WMC));
		pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded += 2*sizeof(U32_WMC);
//		pDecoder->dwAudioTimeStamp = pDecoder->dwAudPayloadPresTime;
        pDecoder->tAudioStreamInfo[AudioStreamIndex]->bTimeToChangex = TRUE_WMC; 
    }

	if(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft == 0)
	{
		pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart = 1;
		pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft = pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign;
		pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft = pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft - pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign;
	}

	if (cbData > pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft )
		cbData = pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft;

	if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded + cbData > pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufCurOffset)
	{
		*ppBuffer = NULL_WMC;
		*pcbBuffer = 0;
		return WMS_S_NEWPACKET;
	}
	

	memcpy(pDecoder->tAudioStreamInfo[AudioStreamIndex]->bAudioBuffer,  pDecoder->tAudioStreamInfo[AudioStreamIndex]->pbAudioBuffer + pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded, cbData);
	*ppBuffer = pDecoder->tAudioStreamInfo[AudioStreamIndex]->bAudioBuffer; 
	*pcbBuffer = cbData;
	pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft-=cbData;

	pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded += (U32_WMC)cbData;

	if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart == 1)
	{
		pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart=0;
		return WMS_OK;//WMA_S_NEWPACKET;
	}
#else
	do
	{
		switch (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bIsCompressedPayload)
		{

		case 1:
			{
				do
				{
					switch (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bSubPayloadState)
					{
					case 1: // Compressed payload just started
						cbWanted = 1; //to read subpayload length
						cbActual = WMCDecCBGetData((HWMCDECODER)dwUserData, pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset, cbWanted, &pData, pDecoder->u32UserData);

						if(cbActual != cbWanted)
						{
							return WMS_S_NEWPACKET;
						}

						pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset += cbWanted;
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart = TRUE_WMC;
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft = pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign;
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubCount =0;
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize = pData[0];
						
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft = pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize;
						if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft > 0)
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft -= (U16_WMC)pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft;

						if( pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wTotalDataBytes > pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize)
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wBytesRead = pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize+1;
						else if ( pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wTotalDataBytes == pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize)
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wBytesRead = pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize;

						pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bSubPayloadState = 2;
				        pDecoder->tAudioStreamInfo[AudioStreamIndex]->bTimeToChangex = TRUE_WMC; 

						break;
					case 2: // Subpayload started
						if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft == 0 && pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft == 0)
						{
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bSubPayloadState =3;
							break;
						}
						else
						{
							if(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft == 0)
							{
								if (/*pInt->dwPayloadLeft*/pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft == 0) /* done with the file */
									return WMS_S_NEWPACKET;

								if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft > 0)
									pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft -= (U16_WMC) pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign;
								pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart = TRUE_WMC;
								pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft = pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign;
							}
							if(cbData > pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft)
								cbData = pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft;

							*pcbBuffer = WMCDecCBGetData((HWMCDECODER)dwUserData, pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset, cbData, &pData, pDecoder->u32UserData);
                            if (*pcbBuffer != cbData )
                                return WMS_S_NO_MORE_SRCDATA;

							memcpy(pDecoder->tAudioStreamInfo[AudioStreamIndex]->bAudioBuffer, pData, cbData);

							*ppBuffer = pDecoder->tAudioStreamInfo[AudioStreamIndex]->bAudioBuffer;

							pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset+=*pcbBuffer;
							//pInt->payload.wSubpayloadLeft -= *pcbBuffer;
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft     -= *pcbBuffer;
                

							if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart) 
							{
								if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft == pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize - pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign)
								{
									pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubCount++;
								}
								pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart = FALSE_WMC;
								return WMS_OK;
							}

							return WMS_OK;
						}

						break;
					case 3: // Subpayload finished
						if ( pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wTotalDataBytes > pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wBytesRead)
						{ // there are payloads to decode
							cbWanted = 1; //to read subpayload length
							cbActual = WMCDecCBGetData((HWMCDECODER)dwUserData, pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset, cbWanted, &pData, pDecoder->u32UserData);

							if(cbActual != cbWanted)
							{
								return WMS_S_NEWPACKET;
							}

							pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset += cbWanted;
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart     = TRUE_WMC;
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft     = pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign;
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioTimeStamp += (Double_WMC)pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.dwDeltaPresTime;
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->bTimeToChangex = TRUE_WMC; 

                    
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize = pData[0];
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft = pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize;
							if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft > 0)
								pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft -= (U16_WMC)pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft;
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wBytesRead+= (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize+1);
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bSubPayloadState =2;                
						}
						else
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bSubPayloadState =4; // all subpayloads finished
						break;

					case 4: // All Subpayloads finished

						parse_state = pDecoder->tAudioStreamInfo[AudioStreamIndex]->parse_state;
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bSubPayloadState =0;
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft =0;
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bIsCompressedPayload =0;

						pDecoder->tAudioStreamInfo[AudioStreamIndex]->parse_state = csWMCDecodePayloadEnd;
						
						err = WMCDecUpdateNewPayload((HWMCDECODER)dwUserData, Audio_WMC, AudioStreamIndex);
						if (err != WMCDec_Succeeded)
						{
							*pcbBuffer = 0;
                            pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bSubPayloadState =4;
							return WMS_S_NEWPACKET;
						}

						pDecoder->tAudioStreamInfo[AudioStreamIndex]->parse_state = parse_state;  //restore 
						if((err != WMCDec_Succeeded)) 
							return WMS_S_NEWPACKET;
						break;
					default:
						break;

					}
				} while(pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bIsCompressedPayload);

				break;
			}          
		default :
			{
				if(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft == 0 && pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft == 0)
				{

					parse_state = pDecoder->tAudioStreamInfo[AudioStreamIndex]->parse_state;

					pDecoder->tAudioStreamInfo[AudioStreamIndex]->parse_state = csWMCDecodePayloadEnd;
					err = WMCDecUpdateNewPayload((HWMCDECODER)dwUserData, Audio_WMC, AudioStreamIndex);
					if (err != WMCDec_Succeeded)
					{
						*pcbBuffer = 0;
						return WMS_S_NEWPACKET;
					}
					pDecoder->tAudioStreamInfo[AudioStreamIndex]->parse_state = parse_state; /* restore */
					pDecoder->tAudioStreamInfo[AudioStreamIndex]->bTimeToChangex = TRUE_WMC; 
					
					if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bIsCompressedPayload ==1)
						break;
					if(err != WMCDec_Succeeded)
						return WMS_S_NEWPACKET;
				}

				/* return as much as we currently have left */

				if(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft == 0)
				{
					if(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft == 0)
					{
						/* done with the file */
						return WMS_S_NEWPACKET;
					}

					pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft -= pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign;
					pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart = TRUE_WMC;
					pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft = pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign;
				}
				if(cbData > pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft)
					cbData = pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft;

				*pcbBuffer = WMCDecCBGetData((HWMCDECODER)dwUserData, pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset, cbData, &pData, pDecoder->u32UserData);

                if (*pcbBuffer != cbData )
                    return WMS_S_NO_MORE_SRCDATA;

				memcpy(pDecoder->tAudioStreamInfo[AudioStreamIndex]->bAudioBuffer, pData, cbData);

				*ppBuffer = pDecoder->tAudioStreamInfo[AudioStreamIndex]->bAudioBuffer;

				pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset+=*pcbBuffer;
				//pInt->payload.wSubpayloadLeft -= *pcbBuffer;
				pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft     -= *pcbBuffer;


				if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart) {
					pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart = FALSE_WMC;
					return WMS_OK;//WMS_S_NEWPACKET;//WMA_S_NEWPACKET;
				}

				return WMS_OK;
			}
		}


	}while(1);


#endif

	
	return WMS_OK;

}
#endif
/******************************************************************************/

tWMCDecStatus WMCRawGetData (U8_WMC *pBuffer, U32_WMC *pcbBuffer, HWMCDECODER hDecoder, U32_WMC cbDstBufferLength)
{
    
    WMFDecoderEx *pDecoder =NULL_WMC;
	tWMCDecStatus err = WMCDec_Succeeded;

	U32_WMC cbData = cbDstBufferLength;
#ifdef WMC_NO_BUFFER_MODE
    U32_WMC cbWanted=0;
    U32_WMC cbActual=0;
    U8_WMC *pData= NULL;
    tWMCParseState  parse_state;
#endif
    U16_WMC AudioStreamIndex = 0;

    pDecoder = (WMFDecoderEx *)hDecoder;
    *pcbBuffer = 0;

    AudioStreamIndex = (U16_WMC)pDecoder->i32CurrentAudioStreamIndex; 

#ifndef WMC_NO_BUFFER_MODE

    if (((pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft ==1) && (pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft==0)) || pDecoder->tAudioStreamInfo[AudioStreamIndex]->bGotCompOutput == TRUE_WMC)
    {
        *pcbBuffer =0;
        pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft =0;
		pDecoder->tAudioStreamInfo[AudioStreamIndex]->bGotCompOutput = TRUE_WMC;
		pDecoder->tAudioStreamInfo[AudioStreamIndex]->bOutputisReady = FALSE_WMC;
        return WMCDec_Succeeded;
    }

    

    if ((pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft ==0) && (pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft==0)) // New Payload
	{

		if(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded > 0)
		{
			if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufCurOffset > pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded)
			{
				pDecoder->tAudioStreamInfo[AudioStreamIndex]->cbNbFramesAudBuf-=1;
				memmove(pDecoder->tAudioStreamInfo[AudioStreamIndex]->pbAudioBuffer, pDecoder->tAudioStreamInfo[AudioStreamIndex]->pbAudioBuffer + pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded,(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufCurOffset - pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded));
				pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufCurOffset = pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufCurOffset - pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded;//pDecoder->dwAudioBufDecoded; 
				pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded=0;
			}

		}
		
		
		memcpy (&(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudPayloadPresTime),(pDecoder->tAudioStreamInfo[AudioStreamIndex]->pbAudioBuffer + pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded), sizeof(U32_WMC));
		memcpy (&(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft),(pDecoder->tAudioStreamInfo[AudioStreamIndex]->pbAudioBuffer + pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded + sizeof(U32_WMC) ), sizeof(U32_WMC));
		pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded += 2*sizeof(U32_WMC);
		pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioTimeStamp = pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudPayloadPresTime;
        pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft =1;
	}

	if (cbData > pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft )
		cbData = pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft;

	if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded + cbData > pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufCurOffset)
	{
		*pcbBuffer = 0;
		return WMCDec_Fail;
	}
	

	memcpy(pBuffer,  pDecoder->tAudioStreamInfo[AudioStreamIndex]->pbAudioBuffer + pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded, cbData);
	*pcbBuffer = cbData;
	pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft-=cbData;

	pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioBufDecoded += (U32_WMC)cbData;
#else

    cbData = MIN_WANTED;
    if (cbDstBufferLength >= MIN_WANTED)
        cbData = MIN_WANTED;
    else
        cbData = cbDstBufferLength;

	do
	{
		switch (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bIsCompressedPayload)
		{

		case 1:
			{
				do
				{
					switch (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bSubPayloadState)
					{
					case 1: // Compressed payload just started
						cbWanted = 1; //to read subpayload length
						cbActual = WMCDecCBGetData(hDecoder, pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset, cbWanted, &pData, pDecoder->u32UserData);

						if(cbActual != cbWanted)
						{
							return WMCDec_BufferTooSmall;
						}

						pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset += cbWanted;
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart = TRUE_WMC;
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft = pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign;
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubCount =0;
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize = pData[0];
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwFrameSize = pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize ;
         				pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioTimeStamp = pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudPayloadPresTime;

						
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft = pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize;
						if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft > 0)
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft -= (U16_WMC)pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft;

						if( pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wTotalDataBytes > pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize)
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wBytesRead = pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize+1;
						else if ( pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wTotalDataBytes == pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize)
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wBytesRead = pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize;

						pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bSubPayloadState = 2;
						break;
					case 2: // Subpayload started
						if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->bGotCompOutput == TRUE_WMC)
						{
							*pcbBuffer =0;
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->bOutputisReady = FALSE_WMC;
							return WMCDec_Succeeded;
						
						}
						if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft == 0 && pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft == 0)
						{
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bSubPayloadState =3;
							*pcbBuffer =0;
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->bGotCompOutput = TRUE_WMC;
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->bOutputisReady = FALSE_WMC;

							//return WMCDec_Succeeded;
							break;
						}
						else
						{
							if(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft == 0)
							{
								if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft == 0) /* done with the file */
									return WMCDec_Succeeded;

								if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft > 0)
									pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft -= (U16_WMC) pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign;
								pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart = TRUE;
								pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft = pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign;
							}
							if(cbData > pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft)
								cbData = pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft;

							*pcbBuffer = WMCDecCBGetData(hDecoder, pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset, cbData, &pData, pDecoder->u32UserData);
                            if (*pcbBuffer != cbData )
                                return WMCDec_BufferTooSmall;

							memcpy(pBuffer, pData, cbData);

							pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset+=*pcbBuffer;
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft     -= *pcbBuffer;
                

							if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart) 
							{
								if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft == pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize - pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign)
								{
									pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubCount++;
								}
								pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart = FALSE_WMC;
								return WMCDec_Succeeded;
							}

							return WMCDec_Succeeded;
						}

						break;
					case 3: // Subpayload finished
						
						
						if ( pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wTotalDataBytes > pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wBytesRead)
						{ // there are payloads to decode
							cbWanted = 1; //to read subpayload length
							cbActual = WMCDecCBGetData(hDecoder, pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset, cbWanted, &pData, pDecoder->u32UserData);

							if(cbActual != cbWanted)
							{
								return WMCDec_BufferTooSmall;
							}

							pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset += cbWanted;
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart     = TRUE_WMC;
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft     = pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign;
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioTimeStamp += (Double_WMC)pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.dwDeltaPresTime;

                    
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize = pData[0];
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwFrameSize = pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize ;
							
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft = pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize;
							if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft > 0)
								pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wSubpayloadLeft -= (U16_WMC)pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft;
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.wBytesRead+= (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bNextSubPayloadSize+1);
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bSubPayloadState =2;                
						}
						else
							pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bSubPayloadState =4; // all subpayloads finished
						break;

					case 4: // All Subpayloads finished

						parse_state = pDecoder->tAudioStreamInfo[AudioStreamIndex]->parse_state;
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bSubPayloadState =0;
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft =0;
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bIsCompressedPayload =0;

						pDecoder->tAudioStreamInfo[AudioStreamIndex]->parse_state = csWMCDecodePayloadEnd;
						
						err = WMCDecUpdateNewPayload(hDecoder, Audio_WMC, AudioStreamIndex);
						if (err == WMCDec_DecodeComplete)
						{
							*pcbBuffer = 0;
							return WMCDec_Succeeded;
						}
						if (err != WMCDec_Succeeded)
						{
							*pcbBuffer = 0;
							return WMCDec_BufferTooSmall;
						}

						pDecoder->tAudioStreamInfo[AudioStreamIndex]->parse_state = parse_state;  //restore 
						break;
					default:
						break;

					}
				} while(pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bIsCompressedPayload);

				break;
			}          
		default :
			{
				if ((pDecoder->tAudioStreamInfo[AudioStreamIndex]->bPayloadGiven == TRUE_WMC) || (pDecoder->tAudioStreamInfo[AudioStreamIndex]->bGotCompOutput == TRUE_WMC) )
				{
					*pcbBuffer =0;
					pDecoder->tAudioStreamInfo[AudioStreamIndex]->bPayloadGiven = FALSE_WMC;
					pDecoder->tAudioStreamInfo[AudioStreamIndex]->bGotCompOutput = TRUE_WMC;
					pDecoder->tAudioStreamInfo[AudioStreamIndex]->bOutputisReady = FALSE_WMC;

					return WMCDec_Succeeded;
				
				}
				
				if(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft == 0 && pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft == 0)
				{

					pDecoder->tAudioStreamInfo[AudioStreamIndex]->bPayloadGiven = TRUE_WMC;
					pDecoder->tAudioStreamInfo[AudioStreamIndex]->bGotCompOutput = TRUE_WMC;
					parse_state = pDecoder->tAudioStreamInfo[AudioStreamIndex]->parse_state;

					pDecoder->tAudioStreamInfo[AudioStreamIndex]->parse_state = csWMCDecodePayloadEnd;
					err = WMCDecUpdateNewPayload(hDecoder, Audio_WMC, AudioStreamIndex);
					if (err == WMCDec_DecodeComplete)
					{
						*pcbBuffer = 0;
						return WMCDec_Succeeded;
					}
					if (err != WMCDec_Succeeded)
					{
						*pcbBuffer = 0;
						return err;
					}
					pDecoder->tAudioStreamInfo[AudioStreamIndex]->parse_state = parse_state; /* restore */
				
         			pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudioTimeStamp = pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwAudPayloadPresTime;

					if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->payload.bIsCompressedPayload ==1)
						break;
					
					continue;

				}

				/* return as much as we currently have left */

				if(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft == 0)
				{
					if(pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft == 0)
					{
						/* done with the file */
						return WMCDec_Succeeded;
					}

					pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft -= pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign;
					pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart = TRUE_WMC;
					pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft = pDecoder->tAudioStreamInfo[AudioStreamIndex]->nBlockAlign;
					if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadLeft ==0)
						pDecoder->tAudioStreamInfo[AudioStreamIndex]->bPayloadGiven = TRUE_WMC;
				}
				if(cbData > pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft)
					cbData = pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft;

				*pcbBuffer = WMCDecCBGetData(hDecoder, pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset, cbData, &pData, pDecoder->u32UserData);

                if (*pcbBuffer != cbData )
                    return WMCDec_BufferTooSmall;

				memcpy(pBuffer, pData, cbData);

				pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwPayloadOffset+=*pcbBuffer;
				//pInt->payload.wSubpayloadLeft -= *pcbBuffer;
				pDecoder->tAudioStreamInfo[AudioStreamIndex]->dwBlockLeft     -= *pcbBuffer;


				if (pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart) {
					pDecoder->tAudioStreamInfo[AudioStreamIndex]->bBlockStart = FALSE_WMC;
					return WMCDec_Succeeded;//WMA_S_NEWPACKET;
				}

				return WMCDec_Succeeded;
			}
		}


	}while(1);


#endif

	return WMCDec_Succeeded;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _ASFPARSE_ONLY_
tWMVDecodeStatus WMVDecCBGetData ( U32_WMV uiUserData, U32_WMV uintPadBeginning, U8_WMV **ppchBuffer, U32_WMV uintUserDataLength, 
                                  U32_WMV* puintActualBufferLength, Bool_WMV*    pbNotEndOfFrame )
{

    WMFDecoderEx *pDecoder =NULL_WMC;
	U32_WMV cbData = MIN_WANTED;
    U16_WMC VideoStreamIndex = 0;
    tWMVDecodeStatus Status = WMV_Succeeded;
#ifdef WMC_NO_BUFFER_MODE
    U32_WMC cbWanted=0;
    U32_WMC cbActual=0;
    U8_WMC *pData= NULL;
    tWMCParseState  parse_state;
	tWMCDecStatus err = WMCDec_Succeeded;
#endif
    

    pDecoder = (WMFDecoderEx *)uiUserData;



    if(pDecoder == NULL_WMC || ppchBuffer == NULL_WMC || puintActualBufferLength == NULL_WMC || pbNotEndOfFrame == NULL_WMC)
    {
        if(ppchBuffer != NULL_WMC)
            *ppchBuffer = NULL_WMC;
        if(puintActualBufferLength != NULL_WMC)
            *puintActualBufferLength = 0;

        if(pbNotEndOfFrame != NULL_WMC)
            *pbNotEndOfFrame = FALSE_WMV;

        return WMV_InValidArguments;
    }

    *ppchBuffer = NULL_WMC;
    *puintActualBufferLength = 0;
    *pbNotEndOfFrame = TRUE_WMV;
    VideoStreamIndex = (U16_WMC)pDecoder->i32CurrentVideoStreamIndex; 

#ifndef WMC_NO_BUFFER_MODE

    if(pDecoder->tVideoStreamInfo[VideoStreamIndex]->bInitStage == TRUE_WMC)
    {
        if(pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft ==0) //First Time
        {
            pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft = pDecoder->tVideoStreamInfo[VideoStreamIndex]->biSize -  sizeof (BITMAPINFOHEADER);
            pDecoder->tVideoStreamInfo[VideoStreamIndex]->bBlockStart = TRUE_WMC;
        }
	    if (cbData > pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft )
        {
		    cbData = pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft;
            *pbNotEndOfFrame = FALSE_WMV;
            Status = WMV_EndOfFrame;
        }

	    if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded + cbData > pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufCurOffset)
	    {
            *ppchBuffer = NULL_WMC;
            *puintActualBufferLength = 0;
            *pbNotEndOfFrame = TRUE_WMV;
            return WMV_EndOfFrame;
	    }
	    

	    memcpy(pDecoder->tVideoStreamInfo[VideoStreamIndex]->bVideoBuffer + uintPadBeginning ,  pDecoder->tVideoStreamInfo[VideoStreamIndex]->pbVideoBuffer + pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded, cbData);
	    *ppchBuffer = pDecoder->tVideoStreamInfo[VideoStreamIndex]->bVideoBuffer; 
	    *puintActualBufferLength = cbData;
	    pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft-=cbData;
	    pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded += (U32_WMC)cbData;
        return Status;
    }
    else
    {
        if(pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft ==0)
        {

		    if(pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded > 0)
		    {
			    if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufCurOffset >pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded)
			    {
				    pDecoder->tVideoStreamInfo[VideoStreamIndex]->cbNbFramesVidBuf-=1;
				    memmove(pDecoder->tVideoStreamInfo[VideoStreamIndex]->pbVideoBuffer, pDecoder->tVideoStreamInfo[VideoStreamIndex]->pbVideoBuffer + pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded,(pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufCurOffset - pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded));
				    pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufCurOffset = pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufCurOffset - pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded;//pDecoder->dwAudioBufDecoded; 
				    if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->pStoreFrameStartPointer != NULL_WMC)
						pDecoder->tVideoStreamInfo[VideoStreamIndex]->pStoreFrameStartPointer -=pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded;
					pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded=0;
			    }

		    }
//			do
//			{
				memcpy (&(pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoTimeStamp),(pDecoder->tVideoStreamInfo[VideoStreamIndex]->pbVideoBuffer + pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded), sizeof(U32_WMC));
				memcpy (&( pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft),( pDecoder->tVideoStreamInfo[VideoStreamIndex]->pbVideoBuffer +  pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded + 2*sizeof(U32_WMC) ), sizeof(U32_WMC));
g_iVideoFrameSize = pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft;
				pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded += (3*sizeof(U32_WMC));
				pDecoder->tVideoStreamInfo[VideoStreamIndex]->bBlockStart = TRUE_WMC;
				pDecoder->tVideoStreamInfo[VideoStreamIndex]->bIsKeyFrame = pDecoder->tVideoStreamInfo[VideoStreamIndex]->pbVideoBuffer[pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded];
				pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded += sizeof(U8_WMC);
//			}while (pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft ==0);
			
        }
	    if (cbData > pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft )
        {
		    cbData = pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft;
            *pbNotEndOfFrame = FALSE_WMV;
            Status = WMV_EndOfFrame;
        }

	    if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded + cbData > pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufCurOffset)
	    {
            *ppchBuffer = NULL_WMC;
            *puintActualBufferLength = 0;
            *pbNotEndOfFrame = TRUE_WMV;
		    return WMV_EndOfFrame;
	    }
	    

	    memcpy(pDecoder->tVideoStreamInfo[VideoStreamIndex]->bVideoBuffer + uintPadBeginning ,  pDecoder->tVideoStreamInfo[VideoStreamIndex]->pbVideoBuffer + pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded, cbData);
	    *ppchBuffer = pDecoder->tVideoStreamInfo[VideoStreamIndex]->bVideoBuffer; 
	    *puintActualBufferLength = cbData + uintPadBeginning;
	    pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft-=cbData;
        if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft ==0)
        {
            *pbNotEndOfFrame = FALSE_WMV;
            Status = WMV_EndOfFrame;
        }

	    pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded += (U32_WMC)cbData;
        return Status;
    }
#else
    if(pDecoder->tVideoStreamInfo[VideoStreamIndex]->bInitStage == TRUE_WMC)
    {
        if(pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft ==0) //First Time
        {
            pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft = pDecoder->tVideoStreamInfo[VideoStreamIndex]->biSize -  sizeof (BITMAPINFOHEADER);
            pDecoder->tVideoStreamInfo[VideoStreamIndex]->bBlockStart = TRUE_WMC;
        }
	    if (cbData > pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft )
        {
		    cbData = pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft;
            *pbNotEndOfFrame = FALSE_WMV;
            Status = WMV_EndOfFrame;
        }
	    

	    memcpy(pDecoder->tVideoStreamInfo[VideoStreamIndex]->bVideoBuffer + uintPadBeginning ,  pDecoder->tVideoStreamInfo[VideoStreamIndex]->bAdditionalInfo + pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded, cbData);
	    *ppchBuffer = pDecoder->tVideoStreamInfo[VideoStreamIndex]->bVideoBuffer; 
	    *puintActualBufferLength = cbData;
	    pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft-=cbData;
	    pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded += (U32_WMC)cbData;
        return Status;
    }
	else
	{
		do
		{
			switch (pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bIsCompressedPayload)
			{

			case 1:
				{
					do
					{
						switch (pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bSubPayloadState)
						{
						case 1: // Compressed payload just started
							cbWanted = 1; //to read subpayload length
							cbActual = WMCDecCBGetData((HWMCDECODER)uiUserData, pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwPayloadOffset, cbWanted, &pData, pDecoder->u32UserData);

							if(cbActual != cbWanted)
							{
								*ppchBuffer = NULL_WMC;
								*puintActualBufferLength = 0;
								*pbNotEndOfFrame = TRUE_WMV;
								return WMV_EndOfFrame;

							}

							pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwPayloadOffset += cbWanted;
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize = pData[0];
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft = pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize;
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wSubCount =0;
g_iVideoFrameSize = pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize;
							
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wSubpayloadLeft = pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize;
							if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wSubpayloadLeft > 0)
								pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wSubpayloadLeft -= (U16_WMC)pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft;

							if( pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wTotalDataBytes > pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize)
								pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wBytesRead = pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize+1;
							else if ( pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wTotalDataBytes == pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize)
								pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wBytesRead = pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize;

							pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bSubPayloadState = 2;
							break;
						case 2: // Subpayload started
							if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft == 0 && pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wSubpayloadLeft == 0)
							{
								pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bSubPayloadState =3;
								break;
							}
							else
							{
								if(cbData > pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft)
									cbData = pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft;

								cbActual = WMCDecCBGetData((HWMCDECODER)uiUserData, pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwPayloadOffset, cbData, &pData, pDecoder->u32UserData);
								if (cbActual != cbData )
								{
									*ppchBuffer = NULL_WMC;
									*puintActualBufferLength = 0;
									*pbNotEndOfFrame = TRUE_WMV;
									return WMV_EndOfFrame;

								}


								memcpy(pDecoder->tVideoStreamInfo[VideoStreamIndex]->bVideoBuffer + uintPadBeginning , pData, cbData);
								*ppchBuffer = pDecoder->tVideoStreamInfo[VideoStreamIndex]->bVideoBuffer; 
								*puintActualBufferLength = cbData + uintPadBeginning;

								pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwPayloadOffset +=cbActual;
								pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft     -= cbActual;
                
								if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft == 0)
								{
									pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwNextVideoTimeStamp = pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoTimeStamp + (U32_WMC)pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.dwDeltaPresTime;
									*pbNotEndOfFrame = FALSE_WMV;
									return WMV_EndOfFrame;
								}
								return Status;

							}

							break;
						case 3: // Subpayload finished
							if ( pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wTotalDataBytes > pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wBytesRead)
							{ // there are payloads to decode
								cbWanted = 1; //to read subpayload length
								cbActual = WMCDecCBGetData((HWMCDECODER)uiUserData, pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwPayloadOffset, cbWanted, &pData, pDecoder->u32UserData);

								if(cbActual != cbWanted)
								{
									*ppchBuffer = NULL_WMC;
									*puintActualBufferLength = 0;
									*pbNotEndOfFrame = TRUE_WMV;
									return WMV_EndOfFrame;
								}

								pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwPayloadOffset += cbWanted;
								pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize = pData[0];
								pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft     = pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize ;
g_iVideoFrameSize = pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize;
							//	pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoTimeStamp += (U32_WMC)pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.dwDeltaPresTime;

                    
								pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wSubpayloadLeft = pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize;
								if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wSubpayloadLeft > 0)
									pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wSubpayloadLeft -= (U16_WMC)pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft;
								pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wBytesRead+= (pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize+1);
								pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bSubPayloadState =2;                
							}
							else
								pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bSubPayloadState =4; // all subpayloads finished
							break;

						case 4: // All Subpayloads finished

							parse_state = pDecoder->tVideoStreamInfo[VideoStreamIndex]->parse_state;
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bSubPayloadState =0;
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwPayloadLeft =0;
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bIsCompressedPayload =0;

							pDecoder->tVideoStreamInfo[VideoStreamIndex]->parse_state = csWMCDecodePayloadEnd;
							
							err = WMCDecUpdateNewPayload((HWMCDECODER)uiUserData, Video_WMC, VideoStreamIndex);
							if (err != WMCDec_Succeeded)
							{
                                if (err == WMCDec_DecodeComplete)
                                {
                                    err = WMCDec_Succeeded;
                                }
                                else
                                {
                                    *ppchBuffer = NULL_WMC;
                                    *puintActualBufferLength = 0;
                                    *pbNotEndOfFrame = TRUE_WMV;
                                    return WMV_EndOfFrame;
                                }
							}

							pDecoder->tVideoStreamInfo[VideoStreamIndex]->parse_state = parse_state;  //restore 
							break;
						default:
						//	*ppchBuffer = NULL_WMC;
						//	*puintActualBufferLength = 0;
						//	*pbNotEndOfFrame = TRUE_WMV;
						//	return WMV_EndOfFrame;
							break;

						}
					} while(pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bIsCompressedPayload /*1*/);

					break;
				}          
			default :
				{

					if(pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft == 0)
					{

						parse_state = pDecoder->tVideoStreamInfo[VideoStreamIndex]->parse_state;

						pDecoder->tVideoStreamInfo[VideoStreamIndex]->parse_state = csWMCDecodePayloadEnd;
						err = WMCDecUpdateNewPayload((HWMCDECODER)uiUserData, Video_WMC, VideoStreamIndex);
						if (err != WMCDec_Succeeded)
						{
                            if (err == WMCDec_DecodeComplete)
                            {
                                err = WMCDec_Succeeded;
                            }
                            else
                            {
                                *ppchBuffer = NULL_WMC;
                                *puintActualBufferLength = 0;
                                *pbNotEndOfFrame = TRUE_WMV;
                                return WMV_EndOfFrame;
                            }
						}

						pDecoder->tVideoStreamInfo[VideoStreamIndex]->parse_state = parse_state; /* restore */
						
						if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bIsCompressedPayload ==1)
							break;
					}
g_iVideoFrameSize = pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwFrameSize;

					/* return as much as we currently have left */

					if(cbData > pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft)
						cbData = pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft;

					cbActual = WMCDecCBGetData((HWMCDECODER)uiUserData, pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwPayloadOffset, cbData, &pData, pDecoder->u32UserData);

					if (cbActual != cbData )
					{
						*ppchBuffer = NULL_WMC;
						*puintActualBufferLength = 0;
						*pbNotEndOfFrame = TRUE_WMV;
						return WMV_EndOfFrame;

					}

					memcpy(pDecoder->tVideoStreamInfo[VideoStreamIndex]->bVideoBuffer + uintPadBeginning , pData, cbData);
					*ppchBuffer = pDecoder->tVideoStreamInfo[VideoStreamIndex]->bVideoBuffer; 
					*puintActualBufferLength = cbData + uintPadBeginning;

					pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwPayloadOffset +=cbActual;
					pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft     -= cbActual;

					pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwFrameLeft -=cbActual;
					
/*					if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwFrameLeft ==0)
					{
						*pbNotEndOfFrame = FALSE_WMV;
						return WMV_EndOfFrame;
					
					} */

					if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwFrameLeft ==0)
					{
					    U32_WMC    dwVideoTimeStamp =0;
						dwVideoTimeStamp = pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoTimeStamp;

						parse_state = pDecoder->tVideoStreamInfo[VideoStreamIndex]->parse_state;

						pDecoder->tVideoStreamInfo[VideoStreamIndex]->parse_state = csWMCDecodePayloadEnd;
						err = WMCDecUpdateNewPayload((HWMCDECODER)uiUserData, Video_WMC, VideoStreamIndex);

                        if (err != WMCDec_Succeeded)
                        {
                            if (err == WMCDec_DecodeComplete)
                            {
                                err = WMCDec_Succeeded;
                            }
                        }
                        else
                            pDecoder->tVideoStreamInfo[VideoStreamIndex]->parse_state = parse_state;

						pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwNextVideoTimeStamp = pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoTimeStamp;
						pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoTimeStamp = dwVideoTimeStamp;


						*pbNotEndOfFrame = FALSE_WMV;
						return WMV_EndOfFrame;
					
					}



					return Status;
				}
			}


		}while(1);
	}


#endif
    
	return Status;

}
#endif //_ASFPARSE_ONLY_
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
tWMCDecStatus WMCDecGetAudioOutput (HWMCDECODER hWMCDec, I16_WMC *pi16Channel0, I16_WMC* pi16Channel1,U32_WMC nNumSamplesRequest, 
                                    U32_WMC* nNumSamplesReturn, I64_WMC* ptPresentationTime )
{

    WMFDecoderEx *pDecoder;
	tWMCDecStatus rc = WMCDec_Succeeded;
    WMARESULT wmar = WMA_OK;
#ifndef __NO_SPEECH__
    WMSRESULT wmsr = WMS_OK;
#endif
    U16_WMC i=0;
    U32_WMC BlockAlign =0;

    if ((hWMCDec == NULL_WMC)||(pi16Channel0 == NULL_WMC) ||(nNumSamplesReturn == NULL_WMC))
        return WMCDec_InValidArguments;

//    if (cbDstBufferLength <1024 )
//        return WMPERR_BUFTOOSMALL;

    pDecoder = (WMFDecoderEx *) hWMCDec;

    i = (U16_WMC)pDecoder->i32CurrentAudioStreamIndex; 
    
    BlockAlign = pDecoder->tAudioStreamInfo[i]->nChannels*pDecoder->tAudioStreamInfo[i]->nBitsPerSample/8;
#ifndef _ASFPARSE_ONLY_
    if (pDecoder->tAudioStreamInfo[i]->hMSA != NULL)
    {
        
        if(pDecoder->tAudioStreamInfo[i]->nVersion > 0 && pDecoder->tAudioStreamInfo[i]->nVersion < 4)
        {
        
        
            if (pi16Channel1 == NULL_WMC || pi16Channel1 == pi16Channel0 + 1 || pDecoder->tAudioStreamInfo[i]->nChannels <= 1 )
            {		// caller wants interleaved data or this sound is mono

                if (ptPresentationTime != NULL_WMC)
					*ptPresentationTime = (U64_WMC)pDecoder->tAudioStreamInfo[i]->dwAudioTimeStamp - pDecoder->tHeaderInfo.msPreroll;
				*nNumSamplesReturn = 2048;

                wmar = WMARawDecGetPCM (pDecoder->tAudioStreamInfo[i]->hMSA,
                    (U16_WMARawDec*)nNumSamplesReturn,
                    (U8_WMARawDec*)pi16Channel0,
                    (U32_WMARawDec) nNumSamplesRequest*BlockAlign
    #ifdef _V9WMADEC_
				    ,ptPresentationTime
    #endif
                    );

//				if (nNumSamplesReturn ==0)
//					pDecoder->tAudioStreamInfo[i]->bOutputisReady = FALSE_WMC;


    #ifdef _V9WMADEC_
                if (ptPresentationTime != NULL_WMC)
					*ptPresentationTime = *ptPresentationTime/10000;
				
				pDecoder->tAudioStreamInfo[i]->dwAudioTimeStamp = (Double_WMC)*ptPresentationTime + pDecoder->tHeaderInfo.msPreroll;;
	#else

                if ((pDecoder->tAudioStreamInfo[i]->bTimeToChange == TRUE_WMC) && (pDecoder->tAudioStreamInfo[i]->bTimeToChangex == TRUE_WMC)&& (*nNumSamplesReturn ==0))
                {
			        pDecoder->tAudioStreamInfo[i]->dwAudioTimeStamp =  pDecoder->tAudioStreamInfo[i]->dwAudPayloadPresTime;
                    pDecoder->tAudioStreamInfo[i]->bTimeToChange = FALSE_WMC;
                    pDecoder->tAudioStreamInfo[i]->bTimeToChangex = FALSE_WMC;
                }

                else
                    pDecoder->tAudioStreamInfo[i]->dwAudioTimeStamp += ((Double_WMC)(*nNumSamplesReturn)*1000.0/pDecoder->tAudioStreamInfo[i]->nSamplesPerSec);

	#endif
 
                if (wmar != WMA_OK)
                    return WMADec_Failed;
       
            }
            else
            {
		        U16_WMC j;
		        I16_WMC *pi16C0src = pi16Channel0;
		        I16_WMC *pi16C0dst = pi16Channel0;
		        I16_WMC *pi16C1    = pi16Channel1;

                if (ptPresentationTime != NULL_WMC)
					*ptPresentationTime = (U64_WMC)pDecoder->tAudioStreamInfo[i]->dwAudioTimeStamp - pDecoder->tHeaderInfo.msPreroll;

                wmar = WMARawDecGetPCM (pDecoder->tAudioStreamInfo[i]->hMSA,
                    (U16_WMARawDec*)nNumSamplesReturn,
                    (U8_WMARawDec*)pi16Channel0,
                    (U32_WMARawDec) nNumSamplesRequest*BlockAlign
    #ifdef _V9WMADEC_
				    ,ptPresentationTime
    #endif
                    );

//				if (nNumSamplesReturn ==0)
//					pDecoder->tAudioStreamInfo[i]->bOutputisReady = FALSE_WMC;



    #ifdef _V9WMADEC_
                if (ptPresentationTime != NULL_WMC)
					*ptPresentationTime = *ptPresentationTime/10000;
  
				pDecoder->tAudioStreamInfo[i]->dwAudioTimeStamp = (Double_WMC)*ptPresentationTime +pDecoder->tHeaderInfo.msPreroll;;

	#else
                if ((pDecoder->tAudioStreamInfo[i]->bTimeToChange == TRUE_WMC)&& (pDecoder->tAudioStreamInfo[i]->bTimeToChangex == TRUE_WMC) && (*nNumSamplesReturn ==0))
                {
			        pDecoder->tAudioStreamInfo[i]->dwAudioTimeStamp =  pDecoder->tAudioStreamInfo[i]->dwAudPayloadPresTime;
                    pDecoder->tAudioStreamInfo[i]->bTimeToChange = FALSE_WMC;
                    pDecoder->tAudioStreamInfo[i]->bTimeToChangex = FALSE_WMC;
                }
                else
                    pDecoder->tAudioStreamInfo[i]->dwAudioTimeStamp += ((Double_WMC)(*nNumSamplesReturn)*1000.0/pDecoder->tAudioStreamInfo[i]->nSamplesPerSec);

	#endif

                if (wmar == WMA_OK) 
                {
			        for (j = 0; j < *nNumSamplesReturn; j++) 
                    {
				        *pi16C0dst++ = *pi16C0src++;
				        *pi16C1++ = *pi16C0src++;
			        }
		        }
      
                if (wmar != WMA_OK)
                    return WMADec_Failed;

            }
        }
#ifndef __NO_SPEECH__
        else if (pDecoder->tAudioStreamInfo[i]->nVersion == 4) // Speech Codec Version
        {

            if (ptPresentationTime != NULL_WMC)
	            *ptPresentationTime = (U64_WMC)pDecoder->tAudioStreamInfo[i]->dwAudioTimeStamp - pDecoder->tHeaderInfo.msPreroll;
            *nNumSamplesReturn =2048;
            wmsr = WMSRawDecGetPCM ((WMSRawDecHandle) pDecoder->tAudioStreamInfo[i]->hMSA, (U16_WMSRawDec*)nNumSamplesReturn, 
                                  (U8_WMSRawDec*)pi16Channel0, (U32_WMARawDec) nNumSamplesRequest*BlockAlign);
            
			if( wmsr != WMS_OK )
            {
                return WMADec_Failed;
            }
//			if (nNumSamplesReturn ==0)
//				pDecoder->tAudioStreamInfo[i]->bOutputisReady = FALSE_WMC;

        
            if ((pDecoder->tAudioStreamInfo[i]->bTimeToChange == TRUE_WMC) && (pDecoder->tAudioStreamInfo[i]->bTimeToChangex == TRUE_WMC) && (*nNumSamplesReturn ==0))
            {
			    pDecoder->tAudioStreamInfo[i]->dwAudioTimeStamp =  pDecoder->tAudioStreamInfo[i]->dwAudPayloadPresTime;
                pDecoder->tAudioStreamInfo[i]->bTimeToChange = FALSE_WMC;
                pDecoder->tAudioStreamInfo[i]->bTimeToChangex = FALSE_WMC;
            }
            else
                pDecoder->tAudioStreamInfo[i]->dwAudioTimeStamp += ((Double_WMC)(*nNumSamplesReturn)*1000.0/pDecoder->tAudioStreamInfo[i]->nSamplesPerSec);
        }
#endif          
        
    }
    else
#endif //_ASFPARSE_ONLY_
    {

        rc = WMCRawGetData ((U8_WMC*)pi16Channel0, (U32_WMC *) nNumSamplesReturn, hWMCDec, nNumSamplesRequest*BlockAlign);
        if (ptPresentationTime != NULL_WMC)
	        *ptPresentationTime = (U64_WMC)pDecoder->tAudioStreamInfo[i]->dwAudioTimeStamp - pDecoder->tHeaderInfo.msPreroll;
 //       *nNumSamplesReturn = *nNumSamplesReturn/BlockAlign; // Amit 09/20/01 In case of compressed, it should be bytes, not samples
//        pDecoder->tAudioStreamInfo[i]->dwAudioTimeStamp += ((*nNumSamplesReturn)*1000/pDecoder->tAudioStreamInfo[i]->nSamplesPerSec);
   
    }

    return rc;
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
tWMCDecStatus WMCDecGetVideoOutput (HWMCDECODER hWMCDec, U8_WMC *pu8VideoOutBuffer, U32_WMC u32VideoOutBufferSize, U32_WMC * pu32OutDataSize, I64_WMC* ptPresentationTime, Bool_WMC *bIsKeyFrame, tWMCDecodeDispRotateDegree tDispRotateDegree)
{

    WMFDecoderEx *pDecoder;
	tWMCDecStatus rc = WMCDec_Succeeded;
#ifndef _ASFPARSE_ONLY_
    tWMVDecodeStatus VidStatus;
#endif
    U16_WMC i = 0;

    

    if ((hWMCDec == NULL_WMC)/*||(pu8VideoOutBuffer == NULL_WMC)||(ptPresentationTime == NULL_WMC)*/ || (pu32OutDataSize == NULL))
        return WMCDec_InValidArguments;

    pDecoder = (WMFDecoderEx *) hWMCDec;
    *pu32OutDataSize =0;
	if (bIsKeyFrame != NULL_WMC)
		*bIsKeyFrame  = FALSE_WMC;
// Output of which stream? Do it tomarrow.....................
    i = (U16_WMC)pDecoder->i32CurrentVideoStreamIndex; 

#ifndef _ASFPARSE_ONLY_
    if (pDecoder->tVideoStreamInfo[i]->pVDec != NULL) // Not a compressed output
    {
        
        if(
            pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_WMV2 ||
            pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_WMV1 ||
            pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_WMS2 ||
            pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_WMS1 ||
            pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_M4S2 ||
            pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MP4S ||
            pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MP43 ||
            pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MP42 ||
            pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MPG4 )
        {
           
			
		//	if (pu8VideoOutBuffer !=NULL)
		//	{			
			pDecoder->tDispRotateDegree = tDispRotateDegree;	
			
			VidStatus = WMVideoDecGetOutput (
					(HWMVDecoder)pDecoder->tVideoStreamInfo[i]->pVDec,
					(U32_WMV)pDecoder->tVideoStreamInfo[i]->biCompressionOut,
#if defined (_ARM_) || defined (_SH3_) 
                    (U16_WMV)((pDecoder->tVideoStreamInfo[i]->biCompressionOut == FOURCC_BI_BITFIELDS && 
                    pDecoder->tVideoStreamInfo[i]->biBitCountOut == 16)? 12 : pDecoder->tVideoStreamInfo[i]->biBitCountOut),
#else
					(U16_WMV)pDecoder->tVideoStreamInfo[i]->biBitCountOut,
#endif //(_ARM_) || defined (_SH3_)
                    // 0,
					// (tWMVDecodeDispRotateDegree)pDecoder->tDispRotateDegree,
					pu8VideoOutBuffer
                    );

				switch(VidStatus)
				{
				case WMV_NoMoreOutput:
					*pu32OutDataSize = 0;;
					rc = WMCDec_Succeeded;
					break;
				case WMV_EndOfFrame:
					break;
				case WMV_BrokenFrame:
					rc = WMVDec_BrokenFrame;
					break;
				case WMV_Succeeded:
					*pu32OutDataSize = (pDecoder->tVideoStreamInfo[i]->biBitCountOut*pDecoder->tVideoStreamInfo[i]->biWidth*pDecoder->tVideoStreamInfo[i]->biHeight)/8;
					if (bIsKeyFrame !=NULL_WMC)
						*bIsKeyFrame = TRUE_WMC;
					rc = WMCDec_Succeeded;
					break;
				default:
					rc = WMVDec_Failed;
				}
		//	}
		//	else
		//	{
		//		*pu32OutDataSize = 0;;
		//		rc = WMCDec_Succeeded;
		//	}
            if (ptPresentationTime != NULL_WMC)
				*ptPresentationTime = pDecoder->tVideoStreamInfo[i]->dwVideoTimeStamp - pDecoder->tHeaderInfo.msPreroll;
        }
#ifndef __NO_SCREEN__
        else if(pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MSS1 ||
				pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MSS2)
        {
	        tWMCDecStatus TempStatus = WMCDec_Succeeded;
        
            TempStatus = WMScGetOutData(hWMCDec, pu8VideoOutBuffer, u32VideoOutBufferSize, i );

            switch(TempStatus)
            {
            case WMVDec_NoMoreOutput:
                *pu32OutDataSize = 0;;
                rc = WMCDec_Succeeded;
                break;
            case WMCDec_Succeeded:
                *pu32OutDataSize = (pDecoder->tVideoStreamInfo[i]->biBitCountOut*pDecoder->tVideoStreamInfo[i]->biWidth*pDecoder->tVideoStreamInfo[i]->biHeight)/8;
				if (bIsKeyFrame !=NULL_WMC)
					*bIsKeyFrame = TRUE_WMC;
                rc = WMCDec_Succeeded;
                break;
            default:
                rc = WMVDec_Failed;
            }
        
            if (ptPresentationTime != NULL_WMC)
				*ptPresentationTime = pDecoder->tVideoStreamInfo[i]->dwVideoTimeStamp - pDecoder->tHeaderInfo.msPreroll;
        }
#endif
    }
    else // Compressed or Raw output
#endif //_ASFPARSE_ONLY_
    {
    
        rc = WMCRawGetVideoData (pu8VideoOutBuffer, (U32_WMC *) pu32OutDataSize, hWMCDec, u32VideoOutBufferSize);
        
        if (ptPresentationTime != NULL_WMC)
			*ptPresentationTime = pDecoder->tVideoStreamInfo[i]->dwVideoTimeStamp  - pDecoder->tHeaderInfo.msPreroll;

		if (bIsKeyFrame !=NULL_WMC)
			*bIsKeyFrame = pDecoder->tVideoStreamInfo[i]->bIsKeyFrame;

    }


    return rc;
}


/******************************************************************************/

tWMCDecStatus WMCRawGetVideoData (U8_WMC *pBuffer, U32_WMC *pcbBuffer, HWMCDECODER hDecoder, U32_WMC cbDstBufferLength)
{
    
    WMFDecoderEx *pDecoder =NULL;
	U32_WMC cbData = cbDstBufferLength;
    U16_WMC VideoStreamIndex = 0;

#ifdef WMC_NO_BUFFER_MODE
    U32_WMC cbWanted=0;
    U32_WMC cbActual=0;
    U8_WMC *pData= NULL;
    tWMCParseState  parse_state;
	tWMCDecStatus err = WMCDec_Succeeded;
#endif

    pDecoder = (WMFDecoderEx *)hDecoder;
    *pcbBuffer = 0;

    VideoStreamIndex = (U16_WMC)pDecoder->i32CurrentVideoStreamIndex; 

#ifndef WMC_NO_BUFFER_MODE
    if (((pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwPayloadLeft ==1) && (pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft==0)) ||(pDecoder->tVideoStreamInfo[VideoStreamIndex]->bGotCompOutput == TRUE_WMC))
    {
        *pcbBuffer =0;
        pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwPayloadLeft =0;
		pDecoder->tVideoStreamInfo[VideoStreamIndex]->bGotCompOutput = TRUE_WMC;
		pDecoder->tVideoStreamInfo[VideoStreamIndex]->bOutputisReady = FALSE_WMC;
        return WMCDec_Succeeded;
    }

    if ((pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwPayloadLeft ==0) && (pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft==0)) // New Payload
	{

		if(pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded > 0)
		{
			if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufCurOffset > pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded)
			{
				pDecoder->tVideoStreamInfo[VideoStreamIndex]->cbNbFramesVidBuf-=1;
				memmove(pDecoder->tVideoStreamInfo[VideoStreamIndex]->pbVideoBuffer, pDecoder->tVideoStreamInfo[VideoStreamIndex]->pbVideoBuffer + pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded,(pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufCurOffset - pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded));
				pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufCurOffset = pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufCurOffset - pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded;//pDecoder->dwVideoBufDecoded; 
				if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->pStoreFrameStartPointer != NULL_WMC)
					pDecoder->tVideoStreamInfo[VideoStreamIndex]->pStoreFrameStartPointer -=pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded;
				pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded=0;
			}

		}
		
		
		memcpy (&(pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoTimeStamp),(pDecoder->tVideoStreamInfo[VideoStreamIndex]->pbVideoBuffer + pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded), sizeof(U32_WMC));
		memcpy (&(pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft),(pDecoder->tVideoStreamInfo[VideoStreamIndex]->pbVideoBuffer + pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded + 2*sizeof(U32_WMC) ), sizeof(U32_WMC));

		pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded += (3*sizeof(U32_WMC));
		pDecoder->tVideoStreamInfo[VideoStreamIndex]->bIsKeyFrame = pDecoder->tVideoStreamInfo[VideoStreamIndex]->pbVideoBuffer[pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded];
		pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded += (sizeof(U8_WMC)) ;
        pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwPayloadLeft =1;
	}

	if (cbData > pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft )
		cbData = pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft;

	if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded + cbData > pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufCurOffset)
	{
		*pcbBuffer = 0;
		return WMCDec_Fail;
	}
	

	if (pBuffer !=NULL)
		memcpy(pBuffer,  pDecoder->tVideoStreamInfo[VideoStreamIndex]->pbVideoBuffer + pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded, cbData);
	*pcbBuffer = cbData;
	pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft-=cbData;

	pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoBufDecoded += (U32_WMC)cbData;
#else

    cbData = MIN_WANTED;
    if (cbDstBufferLength >= MIN_WANTED)
        cbData = MIN_WANTED;
    else
        cbData = cbDstBufferLength;

	do
	{
		switch (pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bIsCompressedPayload)
		{
		case 1:
			{
				do
				{
					switch (pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bSubPayloadState)
					{
					case 1: // Compressed payload just started
						cbWanted = 1; //to read subpayload length
						cbActual = WMCDecCBGetData(hDecoder, pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwPayloadOffset, cbWanted, &pData, pDecoder->u32UserData);

						if(cbActual != cbWanted)
						{
							*pcbBuffer = 0;
							return WMCDec_BufferTooSmall;
						}

						pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwPayloadOffset += cbWanted;
						pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize = pData[0];
						pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwFrameSize = pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize;
						pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft = pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize;
						pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wSubCount =0;
						
						pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wSubpayloadLeft = pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize;
						if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wSubpayloadLeft > 0)
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wSubpayloadLeft -= (U16_WMC)pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft;

						if( pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wTotalDataBytes > pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize)
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wBytesRead = pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize+1;
						else if ( pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wTotalDataBytes == pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize)
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wBytesRead = pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize;

						pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bSubPayloadState = 2;
						break;
					case 2: // Subpayload started
						// if it is coming from normal payload to compressed payload
						if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->bGotCompOutput == TRUE_WMC)
						{
							*pcbBuffer =0;
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->bOutputisReady = FALSE_WMC;
							return WMCDec_Succeeded;
						
						}
						
						if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft == 0 && pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wSubpayloadLeft == 0)
						{
							*pcbBuffer = 0;
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->bGotCompOutput = TRUE_WMC;						
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bSubPayloadState =3;
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->bOutputisReady = FALSE_WMC;
						//	pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwNextVideoTimeStamp = pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoTimeStamp + (U32_WMC)pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.dwDeltaPresTime;
							//return WMCDec_Succeeded;
							break;
						}
						else
						{
							if(cbData > pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft)
								cbData = pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft;

							cbActual = WMCDecCBGetData(hDecoder, pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwPayloadOffset, cbData, &pData, pDecoder->u32UserData);
							if (cbActual != cbData )
							{
								*pcbBuffer = 0;
								return WMCDec_BufferTooSmall;

							}

							memcpy(pBuffer, pData, cbData);
							*pcbBuffer = cbData;

							pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwPayloadOffset +=cbActual;
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft     -= cbActual;
        
							return WMCDec_Succeeded;

						}

						break;
					case 3: // Subpayload finished
					
						
						if ( pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wTotalDataBytes > pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wBytesRead)
						{ // there are payloads to decode
							cbWanted = 1; //to read subpayload length
							cbActual = WMCDecCBGetData(hDecoder, pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwPayloadOffset, cbWanted, &pData, pDecoder->u32UserData);

							if(cbActual != cbWanted)
							{
								*pcbBuffer = 0;
								return WMCDec_BufferTooSmall;

							}

							pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwPayloadOffset += cbWanted;
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize = pData[0];
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft     = pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize ;
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwFrameSize = pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft;
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoTimeStamp += (U32_WMC)pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.dwDeltaPresTime;

            
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wSubpayloadLeft = pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize;
							if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wSubpayloadLeft > 0)
								pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wSubpayloadLeft -= (U16_WMC)pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft;
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.wBytesRead+= (pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bNextSubPayloadSize+1);
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bSubPayloadState =2;                
						}
						else
							pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bSubPayloadState =4; // all subpayloads finished
						break;

					case 4: // All Subpayloads finished

						parse_state = pDecoder->tVideoStreamInfo[VideoStreamIndex]->parse_state;
						pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bSubPayloadState =0;
						pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwPayloadLeft =0;
						pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bIsCompressedPayload =0;

						pDecoder->tVideoStreamInfo[VideoStreamIndex]->parse_state = csWMCDecodePayloadEnd;
						
						err = WMCDecUpdateNewPayload(hDecoder, Video_WMC, VideoStreamIndex);
						if (err == WMCDec_DecodeComplete)
						{
							*pcbBuffer = 0;
							return WMCDec_Succeeded;
						}
						if (err != WMCDec_Succeeded)
						{
							*pcbBuffer = 0;
							return WMCDec_BufferTooSmall;
						}

						pDecoder->tVideoStreamInfo[VideoStreamIndex]->parse_state = parse_state;  //restore 
						break;
					default:
						break;

					}
				} while(pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bIsCompressedPayload /*1*/);

				break;
			}          
		default :
			{
				if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->bGotCompOutput == TRUE_WMC)
				{
					*pcbBuffer =0;
					pDecoder->tVideoStreamInfo[VideoStreamIndex]->bOutputisReady = FALSE_WMC;
					return WMCDec_Succeeded;
				
				}


				if((pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwFrameLeft == 0) && (pDecoder->tVideoStreamInfo[VideoStreamIndex]->bFrameGiven == TRUE_WMC))
				{
					*pcbBuffer = 0;
					pDecoder->tVideoStreamInfo[VideoStreamIndex]->bGotCompOutput = TRUE_WMC;
					pDecoder->tVideoStreamInfo[VideoStreamIndex]->bFrameGiven = FALSE_WMC;
					pDecoder->tVideoStreamInfo[VideoStreamIndex]->bOutputisReady = FALSE_WMC;

					if(pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft == 0)
					{

						parse_state = pDecoder->tVideoStreamInfo[VideoStreamIndex]->parse_state;

						pDecoder->tVideoStreamInfo[VideoStreamIndex]->parse_state = csWMCDecodePayloadEnd;
						err = WMCDecUpdateNewPayload(hDecoder, Video_WMC, VideoStreamIndex);
						if (err != WMCDec_Succeeded)
						{
							*pcbBuffer = 0;
							return WMCDec_BufferTooSmall;
						}

						pDecoder->tVideoStreamInfo[VideoStreamIndex]->parse_state = parse_state; /* restore */
						
						if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bIsCompressedPayload ==1)
							break;
					}
				
				
					return WMCDec_Succeeded;
				
				
				}
				
				
				
				if(pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft == 0)
				{

					parse_state = pDecoder->tVideoStreamInfo[VideoStreamIndex]->parse_state;

					pDecoder->tVideoStreamInfo[VideoStreamIndex]->parse_state = csWMCDecodePayloadEnd;
					err = WMCDecUpdateNewPayload(hDecoder, Video_WMC, VideoStreamIndex);
					if (err == WMCDec_DecodeComplete)
					{
						*pcbBuffer = 0;
						return WMCDec_Succeeded;
					}
					if (err != WMCDec_Succeeded)
					{
						*pcbBuffer = 0;
						return WMCDec_BufferTooSmall;
					}

					pDecoder->tVideoStreamInfo[VideoStreamIndex]->parse_state = parse_state; /* restore */
					
					if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->payload.bIsCompressedPayload ==1)
						break;
				}

				/* return as much as we currently have left */

				if(cbData > pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft)
					cbData = pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft;

				cbActual = WMCDecCBGetData(hDecoder, pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwPayloadOffset, cbData, &pData, pDecoder->u32UserData);

				if (cbActual != cbData )
				{
					*pcbBuffer = 0;
					return WMCDec_BufferTooSmall;

				}

				memcpy(pBuffer, pData, cbData);
				*pcbBuffer = cbData;

				pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwPayloadOffset +=cbActual;
				pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwBlockLeft     -= cbActual;

				pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwFrameLeft -=cbActual;
				
				if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwFrameLeft ==0)
					pDecoder->tVideoStreamInfo[VideoStreamIndex]->bFrameGiven = TRUE_WMC;
/*				
				if (pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwFrameLeft ==0)
				{
				
					U32_WMC    dwVideoTimeStamp =0;
					dwVideoTimeStamp = pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoTimeStamp;

					parse_state = pDecoder->tVideoStreamInfo[VideoStreamIndex]->parse_state;

					pDecoder->tVideoStreamInfo[VideoStreamIndex]->parse_state = csWMCDecodePayloadEnd;
					err = WMCDecUpdateNewPayload((HWMCDECODER)hDecoder, Video_WMC, VideoStreamIndex);
					if (err != WMCDec_Succeeded)
						return err;
					
					pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwNextVideoTimeStamp = pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoTimeStamp;
					pDecoder->tVideoStreamInfo[VideoStreamIndex]->dwVideoTimeStamp = dwVideoTimeStamp;


					pDecoder->tVideoStreamInfo[VideoStreamIndex]->parse_state = parse_state; 

					pDecoder->tVideoStreamInfo[VideoStreamIndex]->bFrameGiven = TRUE_WMC;
				}*/
			
				
				
				return WMCDec_Succeeded;
			}
		}


	}while(1);

#endif
	return WMCDec_Succeeded;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

tWMCDecStatus WMCDecGetBinaryOutput (HWMCDECODER hWMCDec, U8_WMC *pu8BinaryOutBuffer, U32_WMC nSizeRequest, U32_WMC * nSizeReturn, I64_WMC* ptPresentationTime)
{

    WMFDecoderEx *pDecoder;
	tWMCDecStatus rc = WMCDec_Succeeded;
    U16_WMC i = 0;
    

    if ((hWMCDec == NULL_WMC)||(pu8BinaryOutBuffer == NULL_WMC)/*||(ptPresentationTime == NULL_WMC)*/ || (nSizeReturn == NULL))
        return WMCDec_InValidArguments;

    pDecoder = (WMFDecoderEx *) hWMCDec;

    i = (U16_WMC)pDecoder->i32CurrentBinaryStreamIndex; 

    rc = WMCRawGetBinaryData (pu8BinaryOutBuffer, (U32_WMC *) nSizeReturn, hWMCDec, nSizeRequest);
    if (ptPresentationTime != NULL_WMC)
		*ptPresentationTime = pDecoder->tBinaryStreamInfo[i]->dwBinaryTimeStamp - pDecoder->tHeaderInfo.msPreroll;


    return rc;
}

/******************************************************************************/

tWMCDecStatus WMCRawGetBinaryData (U8_WMC *pBuffer, U32_WMC *pcbBuffer, HWMCDECODER hDecoder, U32_WMC cbDstBufferLength)
{
    
    WMFDecoderEx *pDecoder =NULL;
	U32_WMC cbData = cbDstBufferLength;
    U16_WMC BinaryStreamIndex = 0;

#ifdef WMC_NO_BUFFER_MODE
    U32_WMC cbWanted=0;
    U32_WMC cbActual=0;
    U8_WMC *pData= NULL;
    tWMCParseState  parse_state;
	tWMCDecStatus err = WMCDec_Succeeded;
#endif


    pDecoder = (WMFDecoderEx *)hDecoder;
    *pcbBuffer = 0;

    BinaryStreamIndex = (U16_WMC)pDecoder->i32CurrentBinaryStreamIndex; 

#ifndef WMC_NO_BUFFER_MODE
    if (((pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwPayloadLeft ==1) && (pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBlockLeft==0)) || (pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->bGotCompOutput == TRUE_WMC))
    {
        *pcbBuffer =0;
        pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwPayloadLeft =0;
 		pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->bGotCompOutput = TRUE_WMC;
		pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->bOutputisReady = FALSE_WMC;
       return WMCDec_Succeeded;
    }

    if ((pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwPayloadLeft ==0) && (pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBlockLeft==0)) // New Payload
	{

		if(pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryBufDecoded > 0)
		{
			if (pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryBufCurOffset > pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryBufDecoded)
			{
				pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->cbNbFramesBinBuf-=1;
				memmove(pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->pbBinaryBuffer, pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->pbBinaryBuffer + pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryBufDecoded,(pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryBufCurOffset - pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryBufDecoded));
				pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryBufCurOffset = pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryBufCurOffset - pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryBufDecoded;//pDecoder->dwBinaryBufDecoded; 
				pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryBufDecoded=0;
			}

		}
		
		
		memcpy (&(pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryTimeStamp),(pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->pbBinaryBuffer + pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryBufDecoded), sizeof(U32_WMC));
		memcpy (&(pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBlockLeft),(pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->pbBinaryBuffer + pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryBufDecoded + sizeof(U32_WMC) ), sizeof(U32_WMC));
		pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryBufDecoded += 2*sizeof(U32_WMC);
        pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwPayloadLeft =1;
	}

	if (cbData > pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBlockLeft )
		cbData = pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBlockLeft;

	if (pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryBufDecoded + cbData > pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryBufCurOffset)
	{
		*pcbBuffer = 0;
		return WMCDec_Fail;
	}
	

	memcpy(pBuffer,  pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->pbBinaryBuffer + pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryBufDecoded, cbData);
	*pcbBuffer = cbData;
	pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBlockLeft-=cbData;

	pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryBufDecoded += (U32_WMC)cbData;

#else

    cbData = MIN_WANTED;
    if (cbDstBufferLength >= MIN_WANTED)
        cbData = MIN_WANTED;
    else
        cbData = cbDstBufferLength;

	do
	{
		switch (pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.bIsCompressedPayload)
		{
		case 1:
			{
				do
				{
					switch (pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.bSubPayloadState)
					{
					case 1: // Compressed payload just started
						cbWanted = 1; //to read subpayload length
						cbActual = WMCDecCBGetData(hDecoder, pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwPayloadOffset, cbWanted, &pData, pDecoder->u32UserData);

						if(cbActual != cbWanted)
						{
							*pcbBuffer = 0;
							return WMCDec_BufferTooSmall;
						}

						pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwPayloadOffset += cbWanted;
						pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.bNextSubPayloadSize = pData[0];
						pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwFrameSize = pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.bNextSubPayloadSize;
						pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBlockLeft = pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.bNextSubPayloadSize;
						pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.wSubCount =0;
						
						pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.wSubpayloadLeft = pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.bNextSubPayloadSize;
						if (pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.wSubpayloadLeft > 0)
							pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.wSubpayloadLeft -= (U16_WMC)pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBlockLeft;

						if( pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.wTotalDataBytes > pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.bNextSubPayloadSize)
							pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.wBytesRead = pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.bNextSubPayloadSize+1;
						else if ( pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.wTotalDataBytes == pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.bNextSubPayloadSize)
							pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.wBytesRead = pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.bNextSubPayloadSize;

						pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.bSubPayloadState = 2;
						break;
					case 2: // Subpayload started
						// if it is coming from normal payload to compressed payload
						if (pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->bGotCompOutput == TRUE_WMC)
						{
							*pcbBuffer =0;
							pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->bOutputisReady = FALSE_WMC;
							return WMCDec_Succeeded;
						
						}
						if (pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBlockLeft == 0 && pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.wSubpayloadLeft == 0)
						{
							*pcbBuffer = 0;
							pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.bSubPayloadState =3;
							pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->bGotCompOutput = TRUE_WMC;
							pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->bOutputisReady = FALSE_WMC;
						//	pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwNextBinaryTimeStamp = pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryTimeStamp + (U32_WMC)pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.dwDeltaPresTime;

						//	return WMCDec_Succeeded;
							break;
						}
						else
						{
							if(cbData > pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBlockLeft)
								cbData = pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBlockLeft;

							cbActual = WMCDecCBGetData(hDecoder, pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwPayloadOffset, cbData, &pData, pDecoder->u32UserData);
							if (cbActual != cbData )
							{
								*pcbBuffer = 0;
								return WMCDec_BufferTooSmall;

							}

							memcpy(pBuffer, pData, cbData);
							*pcbBuffer = cbData;

							pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwPayloadOffset +=cbActual;
							pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBlockLeft     -= cbActual;
        
							return WMCDec_Succeeded;

						}

						break;
					case 3: // Subpayload finished
						
						if ( pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.wTotalDataBytes > pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.wBytesRead)
						{ // there are payloads to decode
							cbWanted = 1; //to read subpayload length
							cbActual = WMCDecCBGetData(hDecoder, pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwPayloadOffset, cbWanted, &pData, pDecoder->u32UserData);

							if(cbActual != cbWanted)
							{
								*pcbBuffer = 0;
								return WMCDec_BufferTooSmall;

							}

							pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwPayloadOffset += cbWanted;
							pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.bNextSubPayloadSize = pData[0];
							pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBlockLeft     = pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.bNextSubPayloadSize ;
							pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwFrameSize = pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBlockLeft ;
							pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryTimeStamp += (U32_WMC)pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.dwDeltaPresTime;

            
							pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.wSubpayloadLeft = pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.bNextSubPayloadSize;
							if (pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.wSubpayloadLeft > 0)
								pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.wSubpayloadLeft -= (U16_WMC)pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBlockLeft;
							pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.wBytesRead+= (pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.bNextSubPayloadSize+1);
							pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.bSubPayloadState =2;                
						}
						else
							pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.bSubPayloadState =4; // all subpayloads finished
						break;

					case 4: // All Subpayloads finished

						parse_state = pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->parse_state;
						pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.bSubPayloadState =0;
						pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwPayloadLeft =0;
						pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.bIsCompressedPayload =0;

						pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->parse_state = csWMCDecodePayloadEnd;
						
						err = WMCDecUpdateNewPayload(hDecoder, Binary_WMC, BinaryStreamIndex);
						
						if (err == WMCDec_DecodeComplete)
						{
							*pcbBuffer = 0;
							return WMCDec_Succeeded;
						}
						
						if (err != WMCDec_Succeeded)
						{
							*pcbBuffer = 0;
							return WMCDec_BufferTooSmall;
						}

						pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->parse_state = parse_state;  //restore 
						break;
					default:
						break;

					}
				} while(pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.bIsCompressedPayload /*1*/);

				break;
			}          
		default :
			{
				if (pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->bGotCompOutput == TRUE_WMC)
				{
					*pcbBuffer =0;
					pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->bOutputisReady = FALSE_WMC;
					return WMCDec_Succeeded;
				
				}


				if((pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwFrameLeft == 0) && (pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->bFrameGiven == TRUE_WMC));
				{
					*pcbBuffer = 0;
					pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->bOutputisReady = FALSE_WMC;
					pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->bFrameGiven = FALSE_WMC;
					pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->bGotCompOutput = TRUE_WMC;
					return WMCDec_Succeeded;
				}
				
				
				
				if(pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBlockLeft == 0)
				{

					parse_state = pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->parse_state;

					pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->parse_state = csWMCDecodePayloadEnd;
					err = WMCDecUpdateNewPayload(hDecoder, Binary_WMC, BinaryStreamIndex);
					if (err == WMCDec_DecodeComplete)
					{
						*pcbBuffer = 0;
						return WMCDec_Succeeded;
					}

					if (err != WMCDec_Succeeded)
					{
						*pcbBuffer = 0;
						return WMCDec_BufferTooSmall;
					}

					pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->parse_state = parse_state; /* restore */
					
					if (pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->payload.bIsCompressedPayload ==1)
						break;
				}

				/* return as much as we currently have left */

				if(cbData > pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBlockLeft)
					cbData = pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBlockLeft;

				cbActual = WMCDecCBGetData(hDecoder, pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwPayloadOffset, cbData, &pData, pDecoder->u32UserData);

				if (cbActual != cbData )
				{
					*pcbBuffer = 0;
					return WMCDec_BufferTooSmall;

				}

				memcpy(pBuffer, pData, cbData);
				*pcbBuffer = cbData;

				pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwPayloadOffset +=cbActual;
				pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBlockLeft     -= cbActual;

				pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwFrameLeft -=cbActual;
				
				if (pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwFrameLeft ==0)
					pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->bFrameGiven = TRUE_WMC;

/*				if (pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwFrameLeft ==0)
				{
					U32_WMC    dwBinaryTimeStamp =0;
					dwBinaryTimeStamp = pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryTimeStamp;

					parse_state = pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->parse_state;

					pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->parse_state = csWMCDecodePayloadEnd;
					err = WMCDecUpdateNewPayload((HWMCDECODER)hDecoder, Binary_WMC, BinaryStreamIndex);
					if (err != WMCDec_Succeeded)
						return err;
					
					pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwNextBinaryTimeStamp = pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryTimeStamp;
					pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->dwBinaryTimeStamp = dwBinaryTimeStamp;

					pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->parse_state = parse_state; 
					
					pDecoder->tBinaryStreamInfo[BinaryStreamIndex]->bFrameGiven = TRUE_WMC;
				}*/

				
				return WMCDec_Succeeded;
			}
		}


	}while(1);




#endif

	return WMCDec_Succeeded;
}

/******************************************************************************/
 tWMCDecStatus WMCDecDecodeSeqPacket( HWMCDECODER hDecoder)
{

	tWMCDecStatus err = WMCDec_Succeeded;
    tMediaType_WMC MediaType;
    U16_WMC i=0;
    WMFDecoderEx *pDecoder =NULL;
     
    if (NULL == hDecoder)
        return WMCDec_InValidArguments;

    pDecoder = (WMFDecoderEx *) (hDecoder);
    
    
    do
    {
        switch(pDecoder->parse_state)
        {
            case csWMCNewAsfPacket:

    //#ifdef WMAAPI_DEMO
    //            if (pInt->nSampleCount >= WMAAPI_DEMO_LIMIT*pInt->hdr_parse.nSamplesPerSec)
    //                return cWMA_DemoExpired;
    //#endif /* WMAAPI_DEMO */

                if(pDecoder->tHeaderInfo.cbNextPacketOffset > pDecoder->tHeaderInfo.cbLastPacketOffset)
                {
                    return WMCDec_DecodeComplete;
                }

                pDecoder->tHeaderInfo.cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbNextPacketOffset;
                pDecoder->tHeaderInfo.cbNextPacketOffset += pDecoder->tHeaderInfo.cbPacketSize;

                err = WMCDecParsePacketHeader (hDecoder);

/*			    if (err == WMCDec_BufferTooSmall)
			    {
				    pDecoder->tHeaderInfo.cbNextPacketOffset = pDecoder->tHeaderInfo.cbCurrentPacketOffset;
			    //	pInt->hdr_parse.cbCurrentPacketOffset -= pInt->hdr_parse.cbPacketSize;
				    return cWMCNoMoreDataThisTime;
			    }
*/
                if(err != WMCDec_Succeeded)
                {
                    return WMCDec_BadPacketHeader;
                }

                if (pDecoder->tHeaderInfo.ppex.fEccPresent && pDecoder->tHeaderInfo.ppex.fParityPacket)
                {
                    break;
                }

                pDecoder->parse_state = csWMCDecodePayloadStart;
                pDecoder->tHeaderInfo.iPayload = 0;
                break;

            case csWMCDecodePayloadStart:

                if (pDecoder->tHeaderInfo.iPayload >= pDecoder->tHeaderInfo.ppex.cPayloads)
                {
                    pDecoder->parse_state = csWMCNewAsfPacket;
                    return WMCDec_Succeeded; // Return after taking full packet
                }

                err = WMCDecParsePayloadHeader(hDecoder);
                if(err != WMCDec_Succeeded)
                {
                    pDecoder->parse_state = csWMCDecodePayloadEnd;
                    break;
                }

                pDecoder->tHeaderInfo.wPayStart = pDecoder->tHeaderInfo.payload.cbPacketOffset + pDecoder->tHeaderInfo.payload.cbTotalSize  - pDecoder->tHeaderInfo.payload.cbPayloadSize;

                if( pDecoder->tHeaderInfo.payload.cbRepData != 1 )
                {
                    pDecoder->parse_state = csWMCDecodePayload;
                    pDecoder->tHeaderInfo.payload.bIsCompressedPayload =0; // Amit to take care of compressed payloads.
                    break;
                }
                else if( pDecoder->tHeaderInfo.payload.cbRepData == 1)    // Amit to take care of compressed payloads.
                {
                    pDecoder->parse_state = csWMCDecodeCompressedPayload;
                    pDecoder->tHeaderInfo.payload.bIsCompressedPayload =1;
                    break;
                }
 
            case csWMCDecodePayload:
    // In this case store payload in buffer and dont return. Return only after one packet is finished

                err = WMCDecGetMediaType (hDecoder,  pDecoder->tHeaderInfo.payload.bStreamId, &MediaType);
                if (err != WMCDec_Succeeded)
                {
                    pDecoder->parse_state = csWMCDecodePayloadEnd;
                    break;
                }
            
                switch(MediaType)
                {
                case Audio_WMC:
                    // Now get index
                    for (i=0; i< pDecoder->tHeaderInfo.wNoOfAudioStreams; i++)
                    {
                        if (pDecoder->tAudioStreamInfo[i]->wStreamId == pDecoder->tHeaderInfo.payload.bStreamId )
                        {
                            // check whether user wants to output that
//                            if(pDecoder->tAudioStreamInfo[i]->bWantOutput == TRUE_WMC)
                            if((pDecoder->tAudioStreamInfo[i]->bWantOutput == TRUE_WMC) && (pDecoder->tAudioStreamInfo[i]->bStopReading == FALSE_WMC))
                            {
                                if(pDecoder->tAudioStreamInfo[i]->dwAudioTimeStamp == 0)
                                    pDecoder->tAudioStreamInfo[i]->dwAudioTimeStamp = (U32_WMC) pDecoder->tHeaderInfo.payload.msObjectPres;

                                pDecoder->tHeaderInfo.dwPayloadOffset = (U32_WMC)pDecoder->tHeaderInfo.cbCurrentPacketOffset + pDecoder->tHeaderInfo.wPayStart;

                                err = WMCDecStorePayload( hDecoder, pDecoder->tHeaderInfo.payload.cbPayloadSize, Audio_WMC,(U32_WMC)pDecoder->tHeaderInfo.payload.msObjectPres, 0, i, TRUE_WMC, FALSE_WMC);
                                if (err != WMCDec_Succeeded)
                                {
                                    pDecoder->parse_state = csWMCDecodePayloadEnd;
                                    break;
                                }
                            }
                            break;
                        }
                    }
                    pDecoder->parse_state = csWMCDecodePayloadEnd;
                    break;
                case Video_WMC:
                    // In these cases take care of whole frame as frame may be divided in several packets/payloads
                    for (i=0; i< pDecoder->tHeaderInfo.wNoOfVideoStreams; i++)
                    {
                        if (pDecoder->tVideoStreamInfo[i]->wStreamId == pDecoder->tHeaderInfo.payload.bStreamId )
                        {
                            // check whether user wants to output that
//                            if(pDecoder->tVideoStreamInfo[i]->bWantOutput == TRUE_WMC)
                            if((pDecoder->tVideoStreamInfo[i]->bWantOutput == TRUE_WMC) &&(pDecoder->tVideoStreamInfo[i]->bNowStopReadingAndDecoding == FALSE_WMC))
                            {
                                pDecoder->tHeaderInfo.dwPayloadOffset = (U32_WMC) (pDecoder->tHeaderInfo.cbCurrentPacketOffset + pDecoder->tHeaderInfo.wPayStart);
                                
                                if(pDecoder->tVideoStreamInfo[i]->dwVideoTimeStamp == 0)
                                    pDecoder->tVideoStreamInfo[i]->dwVideoTimeStamp = (U32_WMC) pDecoder->tHeaderInfo.payload.msObjectPres;

                                // Keep data about frame size, offset, frame used etc... 
                                if (0 == pDecoder->tHeaderInfo.payload.cbObjectOffset) 
                                { // New Frame starts
					                if (!(pDecoder->tVideoStreamInfo[i]->bFirst)) 
                                    {
						                if (pDecoder->tHeaderInfo.payload.bIsKeyFrame == 0) 
                                        {
							                pDecoder->parse_state = csWMCDecodePayloadEnd;
                                            break;
						                }
						                pDecoder->tVideoStreamInfo[i]->bFirst = 1;
					                
					                }

                                /*    if (pDecoder->tVideoStreamInfo[i]->dwFrameSize != pDecoder->tVideoStreamInfo[i]->cbUsed)
                                    { // Error Previous frame is not completed..... So remove it from buffer...
                                         pDecoder->tVideoStreamInfo[i]->dwVideoBufCurOffset -=(pDecoder->tVideoStreamInfo[i]->cbUsed + 3*sizeof(U32_WMC) + sizeof(U8_WMC)); 
                                    }
					              */  
                                    pDecoder->tVideoStreamInfo[i]->cbUsed = pDecoder->tHeaderInfo.payload.cbPayloadSize;
					                pDecoder->tVideoStreamInfo[i]->cbFrame = pDecoder->tVideoStreamInfo[i]->dwNbFrames;
                                    pDecoder->tVideoStreamInfo[i]->dwNbFrames += 1;
                                    pDecoder->tVideoStreamInfo[i]->dwFrameSize = pDecoder->tHeaderInfo.payload.cbObjectSize; 
                                    pDecoder->tVideoStreamInfo[i]->bIsKeyFrame = pDecoder->tHeaderInfo.payload.bIsKeyFrame;
                                    //store payload
                                    err = WMCDecStorePayload( hDecoder, pDecoder->tHeaderInfo.payload.cbPayloadSize, Video_WMC,pDecoder->tHeaderInfo.payload.msObjectPres, pDecoder->tVideoStreamInfo[i]->cbFrame, i, TRUE_WMC, FALSE_WMC);
                                    if (err != WMCDec_Succeeded) // No problem. No pointers to be adjusted
                                    {
                                        pDecoder->parse_state = csWMCDecodePayloadEnd;
                                        break;
                                    }
                            
				                } 
                                else 
                                {   // old frame cont....
					                if ( pDecoder->tVideoStreamInfo[i]->cbUsed ==0)
                                    {
							            pDecoder->parse_state = csWMCDecodePayloadEnd;
                                        break;
                                    }

                                    if (pDecoder->tVideoStreamInfo[i]->cbUsed == pDecoder->tHeaderInfo.payload.cbObjectOffset) 
                                    { // Packet cont...				
						                // store payload
                                        err = WMCDecStorePayload( hDecoder, pDecoder->tHeaderInfo.payload.cbPayloadSize, Video_WMC,pDecoder->tHeaderInfo.payload.msObjectPres, pDecoder->tVideoStreamInfo[i]->cbFrame, i, FALSE_WMC, FALSE_WMC);
                                        if (err != WMCDec_Succeeded) // Problem...... Pointers to be adjusted as part of the frame is in buffer. Do it tomarrow....
                                        {
                                            pDecoder->parse_state = csWMCDecodePayloadEnd;
                                            pDecoder->tVideoStreamInfo[i]->dwVideoBufCurOffset -=(pDecoder->tVideoStreamInfo[i]->cbUsed + 3*sizeof(U32_WMC) + sizeof(U8_WMC));
                                            pDecoder->tVideoStreamInfo[i]->dwFrameSize = 0;
                                            pDecoder->tVideoStreamInfo[i]->cbUsed = 0;
                                            break;
                                        }
						                pDecoder->tVideoStreamInfo[i]->cbUsed += pDecoder->tHeaderInfo.payload.cbPayloadSize;
					                }
					                else // Broken packet
						                pDecoder->tVideoStreamInfo[i]->cbUsed = 0;
                                }
                            
                                if (err != WMCDec_Succeeded)
                                {
                                    pDecoder->parse_state = csWMCDecodePayloadEnd;
                                    break;
                                }
                            }
                            break;
                        }
                    }
                
                    pDecoder->parse_state = csWMCDecodePayloadEnd;
                    break;
                case Binary_WMC:
                    // In these cases take care of whole frame as frame may be divided in several packets/payloads
                    for (i=0; i< pDecoder->tHeaderInfo.wNoOfBinaryStreams; i++)
                    {
                        if (pDecoder->tBinaryStreamInfo[i]->wStreamId == pDecoder->tHeaderInfo.payload.bStreamId )
                        {
                            // check whether user wants to output that
                          //  if(pDecoder->tBinaryStreamInfo[i]->bWantOutput == TRUE_WMC)
                            if((pDecoder->tBinaryStreamInfo[i]->bWantOutput == TRUE_WMC)&&(pDecoder->tBinaryStreamInfo[i]->bNowStopReadingAndDecoding == FALSE_WMC))
                            {
                                pDecoder->tHeaderInfo.dwPayloadOffset = (U32_WMC)pDecoder->tHeaderInfo.cbCurrentPacketOffset + pDecoder->tHeaderInfo.wPayStart;
                                if(pDecoder->tBinaryStreamInfo[i]->dwBinaryTimeStamp == 0)
                                    pDecoder->tBinaryStreamInfo[i]->dwBinaryTimeStamp = (U32_WMC) pDecoder->tHeaderInfo.payload.msObjectPres;

                                // Keep data about frame size, offset, frame used etc... 
                                if (0 == pDecoder->tHeaderInfo.payload.cbObjectOffset) 
                                { // New Frame starts

                                    if (pDecoder->tBinaryStreamInfo[i]->dwFrameSize != pDecoder->tBinaryStreamInfo[i]->cbUsed)
                                    { // Error Previous frame is not completed..... So remove it from buffer...
                                         pDecoder->tBinaryStreamInfo[i]->dwBinaryBufCurOffset -=(pDecoder->tBinaryStreamInfo[i]->cbUsed + 2*sizeof(U32_WMC)); 
                                    }
					                
                                    pDecoder->tBinaryStreamInfo[i]->cbUsed = pDecoder->tHeaderInfo.payload.cbPayloadSize;
					                pDecoder->tBinaryStreamInfo[i]->cbFrame = pDecoder->tBinaryStreamInfo[i]->dwNbFrames;
                                    pDecoder->tBinaryStreamInfo[i]->dwNbFrames += 1;
                                    pDecoder->tBinaryStreamInfo[i]->dwFrameSize = pDecoder->tHeaderInfo.payload.cbObjectSize; 
                                    //store payload
                                    err = WMCDecStorePayload( hDecoder, pDecoder->tHeaderInfo.payload.cbPayloadSize, Binary_WMC,pDecoder->tHeaderInfo.payload.msObjectPres, pDecoder->tBinaryStreamInfo[i]->cbFrame, i, TRUE_WMC, FALSE_WMC);
                                    if (err != WMCDec_Succeeded) // No problem. No pointers to be adjusted
                                    {
                                        pDecoder->parse_state = csWMCDecodePayloadEnd;
                                        break;
                                    }
                            
				                } 
                                else 
                                {   // old frame cont....
					                if ( pDecoder->tBinaryStreamInfo[i]->cbUsed ==0)
                                    {
							            pDecoder->parse_state = csWMCDecodePayloadEnd;
                                        break;
                                    }

                                    if (pDecoder->tBinaryStreamInfo[i]->cbUsed == pDecoder->tHeaderInfo.payload.cbObjectOffset) 
                                    { // Packet cont...				
						                // store payload
                                        err = WMCDecStorePayload( hDecoder, pDecoder->tHeaderInfo.payload.cbPayloadSize, Binary_WMC,pDecoder->tHeaderInfo.payload.msObjectPres, pDecoder->tBinaryStreamInfo[i]->cbFrame, i, FALSE_WMC, FALSE_WMC);
                                        if (err != WMCDec_Succeeded) // Problem...... Pointers to be adjusted as part of the frame is in buffer. Do it tomarrow....
                                        {
                                            pDecoder->parse_state = csWMCDecodePayloadEnd;
                                            pDecoder->tBinaryStreamInfo[i]->dwBinaryBufCurOffset -=(pDecoder->tBinaryStreamInfo[i]->cbUsed + 2*sizeof(U32_WMC));
                                            pDecoder->tBinaryStreamInfo[i]->dwFrameSize = 0;
                                            pDecoder->tBinaryStreamInfo[i]->cbUsed = 0;
                                            break;
                                        }
						                pDecoder->tBinaryStreamInfo[i]->cbUsed += pDecoder->tHeaderInfo.payload.cbPayloadSize;
					                }
					                else // Broken packet
						                pDecoder->tBinaryStreamInfo[i]->cbUsed = 0;
                                }
                            
                                if (err != WMCDec_Succeeded)
                                {
                                    pDecoder->parse_state = csWMCDecodePayloadEnd;
                                    break;
                                }
                            }
                            break;
                        }
                    }
                
                    pDecoder->parse_state = csWMCDecodePayloadEnd;
                    break;
            
                }
     		    pDecoder->parse_state = csWMCDecodePayloadEnd;
                break;
     //           return cWMA_NoErr;

            case csWMCDecodePayloadEnd:
                pDecoder->tHeaderInfo.iPayload++;
                pDecoder->parse_state = csWMCDecodePayloadStart;
                break;

            case csWMCDecodeCompressedPayload: // Added by Amit to take care of compressed payloads
                // In this case store payload in buffer and dont return. Return only after one packet is finished
                err = WMCDecGetMediaType (hDecoder,  pDecoder->tHeaderInfo.payload.bStreamId, &MediaType);
                if (err != WMCDec_Succeeded)
                {
                    pDecoder->parse_state = csWMCDecodePayloadEnd;
                    break;
                }
            
                switch(MediaType)
                {
                case Audio_WMC:
                    // Now get index
                    for (i=0; i< pDecoder->tHeaderInfo.wNoOfAudioStreams; i++)
                    {
                        if (pDecoder->tAudioStreamInfo[i]->wStreamId == pDecoder->tHeaderInfo.payload.bStreamId )
                        {
                            // check whether user wants to output that
                          //  if(pDecoder->tAudioStreamInfo[i]->bWantOutput == TRUE_WMC)
                            if((pDecoder->tAudioStreamInfo[i]->bWantOutput == TRUE_WMC) && (pDecoder->tAudioStreamInfo[i]->bStopReading == FALSE_WMC))
                            {
                                if(pDecoder->tAudioStreamInfo[i]->dwAudioTimeStamp == 0)
                                    pDecoder->tAudioStreamInfo[i]->dwAudioTimeStamp = (U32_WMC) pDecoder->tHeaderInfo.payload.msObjectPres;

                                pDecoder->tHeaderInfo.dwPayloadOffset = (U32_WMC)pDecoder->tHeaderInfo.cbCurrentPacketOffset + pDecoder->tHeaderInfo.wPayStart;

                                err = WMCDecStorePayload( hDecoder, pDecoder->tHeaderInfo.payload.cbPayloadSize, Audio_WMC,pDecoder->tHeaderInfo.payload.msObjectPres, 0, i, TRUE_WMC, TRUE_WMC);
                                if (err != WMCDec_Succeeded)
                                {
                                    pDecoder->parse_state = csWMCDecodePayloadEnd;
                                    break;
                                }
                            }
                            break;
                        }
                    }
                    pDecoder->parse_state = csWMCDecodePayloadEnd;
                    break;
                case Video_WMC:
                    for (i=0; i< pDecoder->tHeaderInfo.wNoOfVideoStreams; i++)
                    {
                        if (pDecoder->tVideoStreamInfo[i]->wStreamId == pDecoder->tHeaderInfo.payload.bStreamId )
                        {
                            // check whether user wants to output that
                         //   if(pDecoder->tVideoStreamInfo[i]->bWantOutput == TRUE_WMC)
                            if((pDecoder->tVideoStreamInfo[i]->bWantOutput == TRUE_WMC) &&(pDecoder->tVideoStreamInfo[i]->bNowStopReadingAndDecoding == FALSE_WMC))
                            {
					            if (!(pDecoder->tVideoStreamInfo[i]->bFirst)) 
                                {
						            if (pDecoder->tHeaderInfo.payload.bIsKeyFrame == 0) 
                                    {
							            pDecoder->parse_state = csWMCDecodePayloadEnd;
                                        break;
						            }
						            pDecoder->tVideoStreamInfo[i]->bFirst = 1;
					            
					            }
                                
                                if(pDecoder->tVideoStreamInfo[i]->dwVideoTimeStamp == 0)
                                    pDecoder->tVideoStreamInfo[i]->dwVideoTimeStamp = (U32_WMC) pDecoder->tHeaderInfo.payload.msObjectPres;
                                pDecoder->tHeaderInfo.dwPayloadOffset = (U32_WMC)pDecoder->tHeaderInfo.cbCurrentPacketOffset + pDecoder->tHeaderInfo.wPayStart;
                                pDecoder->tVideoStreamInfo[i]->cbUsed = 0;
					            pDecoder->tVideoStreamInfo[i]->cbFrame = pDecoder->tVideoStreamInfo[i]->dwNbFrames;
                                pDecoder->tVideoStreamInfo[i]->dwFrameSize = 0; 
								pDecoder->tVideoStreamInfo[i]->bIsKeyFrame = pDecoder->tHeaderInfo.payload.bIsKeyFrame;

                                err = WMCDecStorePayload( hDecoder, pDecoder->tHeaderInfo.payload.cbPayloadSize, Video_WMC,pDecoder->tHeaderInfo.payload.msObjectPres, pDecoder->tVideoStreamInfo[i]->cbFrame, i, FALSE_WMC, TRUE_WMC);
                                if (err != WMCDec_Succeeded) // Problem...... Pointers to be adjusted as part of the frame is in buffer. Do it tomarrow....
                                {
                                    pDecoder->parse_state = csWMCDecodePayloadEnd;
                                    break;
                                }
                            }
                            break;
                        }
                    }
                
                    pDecoder->parse_state = csWMCDecodePayloadEnd;
                    break;
                case Binary_WMC:
                    // In these cases take care of whole frame as frame may be divided in several packets/payloads
                    for (i=0; i< pDecoder->tHeaderInfo.wNoOfBinaryStreams; i++)
                    {
                        if (pDecoder->tBinaryStreamInfo[i]->wStreamId == pDecoder->tHeaderInfo.payload.bStreamId )
                        {
                            // check whether user wants to output that
                        //    if(pDecoder->tBinaryStreamInfo[i]->bWantOutput == TRUE_WMC)
                            if((pDecoder->tBinaryStreamInfo[i]->bWantOutput == TRUE_WMC)&&(pDecoder->tBinaryStreamInfo[i]->bNowStopReadingAndDecoding == FALSE_WMC))
                            {
                                if(pDecoder->tBinaryStreamInfo[i]->dwBinaryTimeStamp == 0)
                                    pDecoder->tBinaryStreamInfo[i]->dwBinaryTimeStamp = (U32_WMC) pDecoder->tHeaderInfo.payload.msObjectPres;
                                pDecoder->tHeaderInfo.dwPayloadOffset = (U32_WMC)pDecoder->tHeaderInfo.cbCurrentPacketOffset + pDecoder->tHeaderInfo.wPayStart;
                                pDecoder->tBinaryStreamInfo[i]->cbUsed = 0;
					            pDecoder->tBinaryStreamInfo[i]->cbFrame = pDecoder->tBinaryStreamInfo[i]->dwNbFrames;
                                pDecoder->tBinaryStreamInfo[i]->dwFrameSize = 0; 
                            
                                err = WMCDecStorePayload( hDecoder, pDecoder->tHeaderInfo.payload.cbPayloadSize, Video_WMC,pDecoder->tHeaderInfo.payload.msObjectPres, pDecoder->tVideoStreamInfo[i]->cbFrame, i, FALSE_WMC, TRUE_WMC);
                                if (err != WMCDec_Succeeded) 
                                {
                                    pDecoder->parse_state = csWMCDecodePayloadEnd;
                                    break;
                                }
                            }
                            break;
                        }
                    }
                
                    pDecoder->parse_state = csWMCDecodePayloadEnd;
                    break;
                }
     		    pDecoder->parse_state = csWMCDecodePayloadEnd;
                break;

//            default:
        }
        
    }while(1);

    return err;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
tWMCDecStatus WMCDecStorePayload( HWMCDECODER hDecoder, U32_WMC cbPayloadSize, tMediaType_WMC MediaType, U32_WMC PresTime, I32_WMC cbFrame, U16_WMC Index, Bool_WMC bWriteHeader, Bool_WMC bIsCompressed)
{
    tWMCDecStatus rc = WMCDec_Succeeded;
    WMFDecoderEx *pDecoder;
    U32_WMC dwPayloadLeft = 0;
    U32_WMC dwOffset = 0;
    U32_WMC dwLocalOffset=0;
    U32_WMC cbWanted=0;
    U32_WMC cbActual=0;
    U8_WMC *pData= NULL;
    U16_WMC wNextSubPayloadSize =0;
    U32_WMC dwDelta=0;
    U16_WMC wBytesRead =0;
    I32_WMC dwPayloadSize=0;
	U32_WMC dwFrameSize;



    if (NULL == hDecoder)
        return WMCDec_InValidArguments;

    pDecoder = (WMFDecoderEx *)(hDecoder);


	if(Audio_WMC==MediaType) // Audio
	{
        if (bIsCompressed !=TRUE_WMC)
        {
//            assert((pDecoder->tAudioStreamInfo[Index]->dwAudioBufCurOffset + 2*sizeof(U32_WMC) + cbPayloadSize) <= pDecoder->tAudioStreamInfo[Index]->dwAudioBufSize);
			// If buffer is less, Increase it Once only

		    
            if (((pDecoder->tAudioStreamInfo[Index]->dwAudioBufCurOffset + 2*sizeof(U32_WMC) + cbPayloadSize) > pDecoder->tAudioStreamInfo[Index]->dwAudioBufSize) && (FALSE_WMC == pDecoder->tAudioStreamInfo[Index]->bBufferIncreased) )
			{
				pDecoder->tAudioStreamInfo[Index]->pbAudioBuffer = realloc(pDecoder->tAudioStreamInfo[Index]->pbAudioBuffer, pDecoder->tAudioStreamInfo[Index]->dwAudioBufSize *2 );
				if (pDecoder->tAudioStreamInfo[Index]->pbAudioBuffer == NULL)
					return WMCDec_BadMemory;
				pDecoder->tAudioStreamInfo[Index]->dwAudioBufSize *=2;
				pDecoder->tAudioStreamInfo[Index]->bBufferIncreased = TRUE_WMC;
			
			}
			
            assert((pDecoder->tAudioStreamInfo[Index]->dwAudioBufCurOffset + 2*sizeof(U32_WMC) + cbPayloadSize) <= pDecoder->tAudioStreamInfo[Index]->dwAudioBufSize);
			
			if((pDecoder->tAudioStreamInfo[Index]->dwAudioBufCurOffset + cbPayloadSize +2*sizeof(U32_WMC)) <= pDecoder->tAudioStreamInfo[Index]->dwAudioBufSize)
		    {
                dwOffset = pDecoder->tAudioStreamInfo[Index]->dwAudioBufCurOffset;

                memcpy(pDecoder->tAudioStreamInfo[Index]->pbAudioBuffer + dwOffset, &PresTime , sizeof(U32_WMC));
			    memcpy(pDecoder->tAudioStreamInfo[Index]->pbAudioBuffer + dwOffset + sizeof(U32_WMC),  &cbPayloadSize , sizeof(U32_WMC));
                dwOffset+=2*sizeof(U32_WMC);

                dwPayloadLeft = cbPayloadSize;
                do
                {
                    cbWanted = MIN_WANTED;
                    if (cbWanted > dwPayloadLeft)
                        cbWanted = dwPayloadLeft;

                    cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.dwPayloadOffset + dwLocalOffset, cbWanted, &pData, pDecoder->u32UserData);

                    if(cbActual != cbWanted)
                    {
                        return WMCDec_BufferTooSmall;
                    }
                    memcpy(pDecoder->tAudioStreamInfo[Index]->pbAudioBuffer + dwOffset, pData , cbActual);
                    dwOffset+=cbActual;
                    dwPayloadLeft-=cbActual;
                    dwLocalOffset+=cbActual;
                }
                while(dwPayloadLeft>0);

			    pDecoder->tAudioStreamInfo[Index]->dwAudioBufCurOffset = dwOffset;
			    pDecoder->tAudioStreamInfo[Index]->cbNbFramesAudBuf++;
		    }
            else
                return WMCDec_BufferTooSmall;
        }
        else
        {
            cbWanted = 1;
            cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.dwPayloadOffset + dwLocalOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
            }

            wNextSubPayloadSize = pData[0]; 
            dwLocalOffset+=1;

			if (pDecoder->tHeaderInfo.payload.wTotalDataBytes < wNextSubPayloadSize)
				return WMCDec_BadPacketHeader;

            if( pDecoder->tHeaderInfo.payload.wTotalDataBytes > wNextSubPayloadSize)
				wBytesRead = wNextSubPayloadSize+1;
			else if (pDecoder->tHeaderInfo.payload.wTotalDataBytes  == wNextSubPayloadSize)
				wBytesRead = wNextSubPayloadSize;
          
            while (pDecoder->tHeaderInfo.payload.wTotalDataBytes >= wBytesRead) 
			{

				// If buffer is less, Increase it Once only

				
				if (((pDecoder->tAudioStreamInfo[Index]->dwAudioBufCurOffset + 2*sizeof(U32_WMC) + cbPayloadSize) > pDecoder->tAudioStreamInfo[Index]->dwAudioBufSize)&&(pDecoder->tAudioStreamInfo[Index]->bBufferIncreased == FALSE_WMC) )
				{
					pDecoder->tAudioStreamInfo[Index]->pbAudioBuffer = realloc(pDecoder->tAudioStreamInfo[Index]->pbAudioBuffer, pDecoder->tAudioStreamInfo[Index]->dwAudioBufSize *2 );
					if (pDecoder->tAudioStreamInfo[Index]->pbAudioBuffer == NULL)
						return WMCDec_BadMemory;
					pDecoder->tAudioStreamInfo[Index]->dwAudioBufSize *=2;
					pDecoder->tAudioStreamInfo[Index]->bBufferIncreased = TRUE_WMC;
				
				}
                
				
				assert((pDecoder->tAudioStreamInfo[Index]->dwAudioBufCurOffset + 2*sizeof(U32_WMC) + wNextSubPayloadSize) <= pDecoder->tAudioStreamInfo[Index]->dwAudioBufSize);

		        if((pDecoder->tAudioStreamInfo[Index]->dwAudioBufCurOffset + wNextSubPayloadSize +2*sizeof(U32_WMC)) <= pDecoder->tAudioStreamInfo[Index]->dwAudioBufSize)
		        {
                    dwOffset = pDecoder->tAudioStreamInfo[Index]->dwAudioBufCurOffset;
                    PresTime+=dwDelta;
                    dwPayloadSize = (I32_WMC)wNextSubPayloadSize;

                    memcpy(pDecoder->tAudioStreamInfo[Index]->pbAudioBuffer + dwOffset, &PresTime , sizeof(U32_WMC));
			        memcpy(pDecoder->tAudioStreamInfo[Index]->pbAudioBuffer + dwOffset + sizeof(U32_WMC),  &dwPayloadSize , sizeof(U32_WMC));
                    dwOffset+=2*sizeof(U32_WMC);

                    dwPayloadLeft = wNextSubPayloadSize;
                    do
                    {
                        cbWanted = MIN_WANTED;
                        if (cbWanted > dwPayloadLeft)
                            cbWanted = dwPayloadLeft;

                        cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.dwPayloadOffset + dwLocalOffset, cbWanted, &pData, pDecoder->u32UserData);

                        if(cbActual != cbWanted)
                        {
                            return WMCDec_BufferTooSmall;
                        }
                        memcpy(pDecoder->tAudioStreamInfo[Index]->pbAudioBuffer + dwOffset, pData , cbActual);
                        dwOffset+=cbActual;
                        dwPayloadLeft-=cbActual;
                        dwLocalOffset+=cbActual;
                    }
                    while(dwPayloadLeft>0);

			        pDecoder->tAudioStreamInfo[Index]->dwAudioBufCurOffset = dwOffset;
			        pDecoder->tAudioStreamInfo[Index]->cbNbFramesAudBuf++;
                    
                    if (pDecoder->tHeaderInfo.payload.wTotalDataBytes > wBytesRead)
                    {
                        cbWanted = 1;
                        cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.dwPayloadOffset + dwLocalOffset, cbWanted, &pData, pDecoder->u32UserData);

                        if(cbActual != cbWanted)
                        {
                            return WMCDec_BufferTooSmall;
                        }

                        wNextSubPayloadSize = pData[0]; 
					    dwDelta = pDecoder->tHeaderInfo.payload.dwDeltaPresTime;
                        dwLocalOffset+=1;
					    wBytesRead+=wNextSubPayloadSize+1;
                    }
                    else
                        break;
		        }
                else
                    return WMCDec_BufferTooSmall;

			}// end of while
        }
	}
	else if(Video_WMC==MediaType) // Video
	{
        if (bIsCompressed !=TRUE_WMC)
        {
		// If buffer is less increase it only one time;	
       //     assert((pDecoder->tVideoStreamInfo[Index]->dwVideoBufCurOffset + cbPayloadSize + 2*sizeof(U32_WMC)+ sizeof(I32_WMC) + sizeof(U8_WMC))<= pDecoder->tVideoStreamInfo[Index]->dwVideoBufSize);

			if (((pDecoder->tVideoStreamInfo[Index]->dwVideoBufCurOffset + cbPayloadSize + 2*sizeof(U32_WMC)+ sizeof(I32_WMC) + sizeof(U8_WMC)) > pDecoder->tVideoStreamInfo[Index]->dwVideoBufSize)&&(pDecoder->tVideoStreamInfo[Index]->bBufferIncreased == FALSE_WMC) )
			{
				pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer = realloc(pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer, pDecoder->tVideoStreamInfo[Index]->dwVideoBufSize *2 );
				if (pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer == NULL)
					return WMCDec_BadMemory;
				pDecoder->tVideoStreamInfo[Index]->dwVideoBufSize *=2;
				pDecoder->tVideoStreamInfo[Index]->pStoreFrameStartPointer = NULL_WMC;
				pDecoder->tVideoStreamInfo[Index]->pStoreNextFrameStartPointer = NULL_WMC;
				pDecoder->tVideoStreamInfo[Index]->bBufferIncreased = TRUE_WMC;
			
			}
                

            assert((pDecoder->tVideoStreamInfo[Index]->dwVideoBufCurOffset + cbPayloadSize + 2*sizeof(U32_WMC)+ sizeof(I32_WMC) + sizeof(U8_WMC))<= pDecoder->tVideoStreamInfo[Index]->dwVideoBufSize);

		    if((pDecoder->tVideoStreamInfo[Index]->dwVideoBufCurOffset + cbPayloadSize + 2*sizeof(U32_WMC) + sizeof(I32_WMC)  + sizeof(U8_WMC)) <= pDecoder->tVideoStreamInfo[Index]->dwVideoBufSize)
		    {
			    dwOffset = pDecoder->tVideoStreamInfo[Index]->dwVideoBufCurOffset;

                if (bWriteHeader == TRUE_WMC)
                {
                    if (pDecoder->tVideoStreamInfo[Index]->pStoreFrameStartPointer != NULL)
					{
						pDecoder->tVideoStreamInfo[Index]->pStoreNextFrameStartPointer = pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer + dwOffset;
						
						memcpy (&dwFrameSize, pDecoder->tVideoStreamInfo[Index]->pStoreFrameStartPointer + 2*sizeof(U32_WMC), sizeof(U32_WMC));
						
						// Last Frame Error
						if (pDecoder->tVideoStreamInfo[Index]->pStoreNextFrameStartPointer - (pDecoder->tVideoStreamInfo[Index]->pStoreFrameStartPointer + 3*sizeof(U32_WMC) + sizeof(U8_WMC)) != (I32_WMC)dwFrameSize)
						{
							// Last Frame is not complete
							pDecoder->tVideoStreamInfo[Index]->dwVideoBufCurOffset = pDecoder->tVideoStreamInfo[Index]->dwVideoBufCurOffset - (pDecoder->tVideoStreamInfo[Index]->pStoreNextFrameStartPointer - pDecoder->tVideoStreamInfo[Index]->pStoreFrameStartPointer);
							dwOffset = pDecoder->tVideoStreamInfo[Index]->dwVideoBufCurOffset;
							pDecoder->tVideoStreamInfo[Index]->cbNbFramesVidBuf--;
						}						
						
						pDecoder->tVideoStreamInfo[Index]->pStoreFrameStartPointer = pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer + dwOffset;
					}
					else // First Frame
					{
						pDecoder->tVideoStreamInfo[Index]->pStoreFrameStartPointer = pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer + dwOffset;
					}

					memcpy(pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer + dwOffset, &PresTime , sizeof(U32_WMC));
			        memcpy(pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer + dwOffset + sizeof(U32_WMC) , &cbFrame , sizeof(I32_WMC));
			        memcpy(pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer + dwOffset + sizeof(U32_WMC) + sizeof(I32_WMC), &(pDecoder->tVideoStreamInfo[Index]->dwFrameSize) , sizeof(I32_WMC));
//g_iVideoFrameSize = pDecoder->tVideoStreamInfo[Index]->dwFrameSize;
                    dwOffset+=(2*sizeof(U32_WMC) + sizeof(I32_WMC));
    			    pDecoder->tVideoStreamInfo[Index]->cbNbFramesVidBuf++;
                    pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer[dwOffset] = (U8_WMC)(pDecoder->tVideoStreamInfo[Index]->bIsKeyFrame);
                    dwOffset += sizeof(U8_WMC);

                    
                }

                dwPayloadLeft = cbPayloadSize;
                do
                {
                    cbWanted = MIN_WANTED;
                    if (cbWanted > dwPayloadLeft)
                        cbWanted = dwPayloadLeft;

                    cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.dwPayloadOffset + dwLocalOffset, cbWanted, &pData, pDecoder->u32UserData);

                    if(cbActual != cbWanted)
                    {
                        return WMCDec_BufferTooSmall;
                        pDecoder->tVideoStreamInfo[Index]->cbNbFramesVidBuf--;
                    }
                    memcpy(pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer + dwOffset, pData , cbActual);
                    dwOffset+=cbActual;
                    dwPayloadLeft-=cbActual;
                    dwLocalOffset+=cbActual;
                }
                while(dwPayloadLeft>0);

                pDecoder->tVideoStreamInfo[Index]->dwVideoBufCurOffset = dwOffset;
		    }
            else
                return WMCDec_BufferTooSmall;
        }
        else
        {
            cbWanted = 1;
            cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.dwPayloadOffset + dwLocalOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
            }

            wNextSubPayloadSize = pData[0]; 
            dwLocalOffset+=1;

			if (pDecoder->tHeaderInfo.payload.wTotalDataBytes < wNextSubPayloadSize)
				return WMCDec_BadPacketHeader;

            if( pDecoder->tHeaderInfo.payload.wTotalDataBytes > wNextSubPayloadSize)
				wBytesRead = wNextSubPayloadSize+1;
			else if (pDecoder->tHeaderInfo.payload.wTotalDataBytes == wNextSubPayloadSize)
				wBytesRead = wNextSubPayloadSize;
          
            while (pDecoder->tHeaderInfo.payload.wTotalDataBytes >= wBytesRead) 
			{
				if (((pDecoder->tVideoStreamInfo[Index]->dwVideoBufCurOffset + cbPayloadSize + 2*sizeof(U32_WMC)+ sizeof(I32_WMC) + sizeof(U8_WMC)) > pDecoder->tVideoStreamInfo[Index]->dwVideoBufSize)&&(pDecoder->tVideoStreamInfo[Index]->bBufferIncreased == FALSE_WMC) )
				{
					pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer = realloc(pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer, pDecoder->tVideoStreamInfo[Index]->dwVideoBufSize *2 );
					if (pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer == NULL)
						return WMCDec_BadMemory;
					pDecoder->tVideoStreamInfo[Index]->dwVideoBufSize *=2;
					pDecoder->tVideoStreamInfo[Index]->pStoreFrameStartPointer = NULL_WMC;
					pDecoder->tVideoStreamInfo[Index]->pStoreNextFrameStartPointer = NULL_WMC;
					pDecoder->tVideoStreamInfo[Index]->bBufferIncreased = TRUE_WMC;
				
				}

                assert((pDecoder->tVideoStreamInfo[Index]->dwVideoBufCurOffset + 3*sizeof(U32_WMC) + sizeof (U8_WMC) + wNextSubPayloadSize) <= pDecoder->tVideoStreamInfo[Index]->dwVideoBufSize);

		        if((pDecoder->tVideoStreamInfo[Index]->dwVideoBufCurOffset + wNextSubPayloadSize +3*sizeof(U32_WMC) + sizeof(U8_WMC)) <= pDecoder->tVideoStreamInfo[Index]->dwVideoBufSize)
		        {
                    dwOffset = pDecoder->tVideoStreamInfo[Index]->dwVideoBufCurOffset;
                    PresTime+=dwDelta;
                    pDecoder->tVideoStreamInfo[Index]->dwNbFrames = pDecoder->tVideoStreamInfo[Index]->dwNbFrames +1;
                    cbFrame = pDecoder->tVideoStreamInfo[Index]->dwNbFrames;
                    dwPayloadSize = (I32_WMC)wNextSubPayloadSize;
					if (dwPayloadSize > 0)
					{

						if (pDecoder->tVideoStreamInfo[Index]->pStoreFrameStartPointer != NULL)
						{
							pDecoder->tVideoStreamInfo[Index]->pStoreNextFrameStartPointer = pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer + dwOffset;
							
							memcpy (&dwFrameSize, pDecoder->tVideoStreamInfo[Index]->pStoreFrameStartPointer + 2*sizeof(U32_WMC), sizeof(U32_WMC));
							
							// Last Frame Error
							if (pDecoder->tVideoStreamInfo[Index]->pStoreNextFrameStartPointer - (pDecoder->tVideoStreamInfo[Index]->pStoreFrameStartPointer + 3*sizeof(U32_WMC) + sizeof(U8_WMC)) != (I32_WMC)dwFrameSize)
							{
								// Last Frame is not complete
								pDecoder->tVideoStreamInfo[Index]->dwVideoBufCurOffset = pDecoder->tVideoStreamInfo[Index]->dwVideoBufCurOffset - (pDecoder->tVideoStreamInfo[Index]->pStoreNextFrameStartPointer - pDecoder->tVideoStreamInfo[Index]->pStoreFrameStartPointer);
								dwOffset = pDecoder->tVideoStreamInfo[Index]->dwVideoBufCurOffset;
								pDecoder->tVideoStreamInfo[Index]->cbNbFramesVidBuf--;
							}						
							
							pDecoder->tVideoStreamInfo[Index]->pStoreFrameStartPointer = pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer + dwOffset;
						}
						else // First Frame
						{
							pDecoder->tVideoStreamInfo[Index]->pStoreFrameStartPointer = pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer + dwOffset;
						}
						
						
						memcpy(pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer + dwOffset, &PresTime , sizeof(U32_WMC));
						memcpy(pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer + dwOffset + sizeof(U32_WMC) , &cbFrame , sizeof(I32_WMC));
						memcpy(pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer + dwOffset + sizeof(U32_WMC) + sizeof(I32_WMC), &dwPayloadSize , sizeof(I32_WMC));
//g_iVideoFrameSize = dwPayloadSize;
						dwOffset+=(2*sizeof(U32_WMC) + sizeof(I32_WMC));
						//pDecoder->tVideoStreamInfo[Index]->bIsKeyFrame = pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer[dwOffset];
						pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer[dwOffset] = (U8_WMC)(pDecoder->tVideoStreamInfo[Index]->bIsKeyFrame);
						dwOffset+=(sizeof(I8_WMC));
	//    			    pDecoder->tVideoStreamInfo[Index]->cbNbFramesVidBuf++;

						dwPayloadLeft = wNextSubPayloadSize;
						do
						{
							cbWanted = MIN_WANTED;
							if (cbWanted > dwPayloadLeft)
								cbWanted = dwPayloadLeft;

							cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.dwPayloadOffset + dwLocalOffset, cbWanted, &pData, pDecoder->u32UserData);

							if(cbActual != cbWanted)
							{
								return WMCDec_BufferTooSmall;
							}
							memcpy(pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer + dwOffset, pData , cbActual);
							dwOffset+=cbActual;
							dwPayloadLeft-=cbActual;
							dwLocalOffset+=cbActual;
						}
						while(dwPayloadLeft>0);

						pDecoder->tVideoStreamInfo[Index]->dwVideoBufCurOffset = dwOffset;
						pDecoder->tVideoStreamInfo[Index]->cbNbFramesVidBuf++;
					}
                    
                    if (pDecoder->tHeaderInfo.payload.wTotalDataBytes > wBytesRead)
                    {
                        cbWanted = 1;
                        cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.dwPayloadOffset + dwLocalOffset, cbWanted, &pData, pDecoder->u32UserData);

                        if(cbActual != cbWanted)
                        {
                            return WMCDec_BufferTooSmall;
                        }

                        wNextSubPayloadSize = pData[0]; 
					    dwDelta = pDecoder->tHeaderInfo.payload.dwDeltaPresTime;
                        dwLocalOffset+=1;
					    wBytesRead+=wNextSubPayloadSize+1;
                    }
                    else
                        break;
		        }
                else
                    return WMCDec_BufferTooSmall;

			}// end of while
        }

	}
	else if(Binary_WMC==MediaType) // Video
	{

        if (bIsCompressed !=TRUE_WMC)
        {

			if (((pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufCurOffset + cbPayloadSize + 2*sizeof(U32_WMC)) > pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufSize)&&(pDecoder->tBinaryStreamInfo[Index]->bBufferIncreased == FALSE_WMC) )
			{
				pDecoder->tBinaryStreamInfo[Index]->pbBinaryBuffer = realloc(pDecoder->tBinaryStreamInfo[Index]->pbBinaryBuffer, pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufSize *2 );
				if (pDecoder->tBinaryStreamInfo[Index]->pbBinaryBuffer == NULL)
					return WMCDec_BadMemory;
				pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufSize *=2;
				pDecoder->tBinaryStreamInfo[Index]->bBufferIncreased = TRUE_WMC;
			
			}
            assert((pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufCurOffset + cbPayloadSize + 2*sizeof(U32_WMC))<= pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufSize);

		    if((pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufCurOffset + cbPayloadSize + 2*sizeof(U32_WMC)) <= pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufSize)
		    {
			    dwOffset = pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufCurOffset;

                if (bWriteHeader == TRUE_WMC)
                {
                    memcpy(pDecoder->tBinaryStreamInfo[Index]->pbBinaryBuffer + dwOffset, &PresTime , sizeof(U32_WMC));
			        memcpy(pDecoder->tBinaryStreamInfo[Index]->pbBinaryBuffer + dwOffset + sizeof(U32_WMC), &(pDecoder->tBinaryStreamInfo[Index]->dwFrameSize), sizeof(I32_WMC));
                    dwOffset+=(2*sizeof(U32_WMC));
    			    pDecoder->tBinaryStreamInfo[Index]->cbNbFramesBinBuf++;
                }

                dwPayloadLeft = cbPayloadSize;
                do
                {
                    cbWanted = MIN_WANTED;
                    if (cbWanted > dwPayloadLeft)
                        cbWanted = dwPayloadLeft;

                    cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.dwPayloadOffset + dwLocalOffset, cbWanted, &pData, pDecoder->u32UserData);

                    if(cbActual != cbWanted)
                    {
                        return WMCDec_BufferTooSmall;
                        pDecoder->tBinaryStreamInfo[Index]->cbNbFramesBinBuf--;
                    }
                    memcpy(pDecoder->tBinaryStreamInfo[Index]->pbBinaryBuffer + dwOffset, pData , cbActual);
                    dwOffset+=cbActual;
                    dwPayloadLeft-=cbActual;
                    dwLocalOffset+=cbActual;
                }
                while(dwPayloadLeft>0);

                pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufCurOffset = dwOffset;
		    }
            else
                return WMCDec_BufferTooSmall;
        }
        else
        {
            cbWanted = 1;
            cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.dwPayloadOffset + dwLocalOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
            }

            wNextSubPayloadSize = pData[0]; 
            dwLocalOffset+=1;

			if (pDecoder->tHeaderInfo.payload.wTotalDataBytes < wNextSubPayloadSize)
				return WMCDec_BadPacketHeader;

            if( pDecoder->tHeaderInfo.payload.wTotalDataBytes > wNextSubPayloadSize)
				wBytesRead = wNextSubPayloadSize+1;
			else if (pDecoder->tHeaderInfo.payload.wTotalDataBytes == wNextSubPayloadSize)
				wBytesRead = wNextSubPayloadSize;
          
            while (pDecoder->tHeaderInfo.payload.wTotalDataBytes >= wBytesRead) 
			{

				if (((pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufCurOffset + cbPayloadSize + 2*sizeof(U32_WMC)) > pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufSize)&&(pDecoder->tBinaryStreamInfo[Index]->bBufferIncreased == FALSE_WMC) )
				{
					pDecoder->tBinaryStreamInfo[Index]->pbBinaryBuffer = realloc(pDecoder->tBinaryStreamInfo[Index]->pbBinaryBuffer, pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufSize *2 );
					if (pDecoder->tBinaryStreamInfo[Index]->pbBinaryBuffer == NULL)
						return WMCDec_BadMemory;
					pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufSize *=2;
					pDecoder->tBinaryStreamInfo[Index]->bBufferIncreased = TRUE_WMC;
				
				}
                assert((pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufCurOffset + 2*sizeof(U32_WMC) + wNextSubPayloadSize) <= pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufSize);

		        if((pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufCurOffset + wNextSubPayloadSize +2*sizeof(U32_WMC)) <= pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufSize)
		        {
                    dwOffset = pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufCurOffset;
                    PresTime+=dwDelta;

                    dwPayloadSize = (I32_WMC)wNextSubPayloadSize;
                    memcpy(pDecoder->tBinaryStreamInfo[Index]->pbBinaryBuffer + dwOffset, &PresTime , sizeof(U32_WMC));
			        memcpy(pDecoder->tBinaryStreamInfo[Index]->pbBinaryBuffer + dwOffset + sizeof(U32_WMC),  &dwPayloadSize , sizeof(U32_WMC));
                    dwOffset+=2*sizeof(U32_WMC);

                    dwPayloadLeft = wNextSubPayloadSize;
                    do
                    {
                        cbWanted = MIN_WANTED;
                        if (cbWanted > dwPayloadLeft)
                            cbWanted = dwPayloadLeft;

                        cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.dwPayloadOffset + dwLocalOffset, cbWanted, &pData, pDecoder->u32UserData);

                        if(cbActual != cbWanted)
                        {
                            return WMCDec_BufferTooSmall;
                        }
                        memcpy(pDecoder->tBinaryStreamInfo[Index]->pbBinaryBuffer + dwOffset, pData , cbActual);
                        dwOffset+=cbActual;
                        dwPayloadLeft-=cbActual;
                        dwLocalOffset+=cbActual;
                    }
                    while(dwPayloadLeft>0);

			        pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufCurOffset = dwOffset;
			        pDecoder->tBinaryStreamInfo[Index]->cbNbFramesBinBuf++;

                    if (pDecoder->tHeaderInfo.payload.wTotalDataBytes > wBytesRead)
                    {

                        cbWanted = 1;
                        cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.dwPayloadOffset + dwLocalOffset, cbWanted, &pData, pDecoder->u32UserData);

                        if(cbActual != cbWanted)
                        {
                            return WMCDec_BufferTooSmall;
                        }

                        wNextSubPayloadSize = pData[0]; 
					    dwDelta = pDecoder->tHeaderInfo.payload.dwDeltaPresTime;
                        dwLocalOffset+=1;
					    wBytesRead+=wNextSubPayloadSize+1;
                    }
                    else
                        break;
		        }
                else
                    return WMCDec_BufferTooSmall;

			}// end of while
        
        }
	}
		
    return rc;
}



/******************************************************************************************************************/

tWMCDecStatus WMCDecDecodeFrame( HWMCDECODER hDecoder, U8_WMC bType, U16_WMC * pbDecoded, U32_WMC* pnNumberOfSamples)
{
	tWMCDecStatus err = WMCDec_Succeeded;
    WMFDecoderEx *pDecoder;
	U8_WMC* pComData = NULL;
    U16_WMC     i=0;

    U16_WMC     wMinAudioIndex = 0xffff;
    U16_WMC     wMinVideoIndex = 0xffff;
    U16_WMC     wMinBinaryIndex = 0xffff;
    U32_WMC     dwPresTime=0;
    U32_WMC     dwMinPresTime=0xffffffff;
    U32_WMC     dwMinAudioPresTime=0xffffffff;
    U32_WMC     dwMinVideoPresTime=0xffffffff;
    U32_WMC     dwMinBinaryPresTime=0xffffffff;
    tMediaType_WMC MediaType = Audio_WMC;
	Bool_WMC	bGotAtLeastOneVideoOutput = FALSE_WMC;	
	Bool_WMC	bGotAtLeastOneBinaryOutput = FALSE_WMC;
	Bool_WMC	bGotAtLeastOneVideoStreamToOutput = FALSE_WMC;	
	Bool_WMC	bGotAtLeastOneBinaryStreamToOutput = FALSE_WMC;

#ifndef _ASFPARSE_ONLY_
    tWMVDecodeStatus  VidStatus;
#endif
	Bool_WMC	bAllDone = FALSE_WMC;

    WMARESULT wmar = WMA_OK;
#ifndef __NO_SPEECH__
    WMSRESULT wmsr = WMS_OK;
#endif
    U16_WMC Index =0;
    *pnNumberOfSamples =0;
   // U16_WMV uiNumDecodedFrames=0;
    
    if (NULL == hDecoder)
        return WMCDec_InValidArguments;

    pDecoder = (WMFDecoderEx *) (hDecoder);



    for (i=0; i< pDecoder->tPlannedOutputInfo.wTotalOutput; i++ )
    {
        Index = pDecoder->tPlannedOutputInfo.tPlannedId[i].wStreamIndex;

        switch(pDecoder->tPlannedOutputInfo.tPlannedId[i].tMediaType)
        {
        case Audio_WMC:
			if (pDecoder->tAudioStreamInfo[Index]->bTobeDecoded == FALSE_WMC)
			{
				if (pDecoder->tAudioStreamInfo[Index]->dwBlockLeft !=0)
				{
					// problem. Either no output is taken or there is a video error
					pDecoder->tAudioStreamInfo[Index]->dwAudioBufDecoded += pDecoder->tAudioStreamInfo[Index]->dwBlockLeft;
					pDecoder->tAudioStreamInfo[Index]->dwBlockLeft =0;
					pDecoder->tAudioStreamInfo[Index]->bOutputisReady = FALSE_WMC;
				}
				
			    pComData =  pDecoder->tAudioStreamInfo[Index]->pbAudioBuffer + pDecoder->tAudioStreamInfo[Index]->dwAudioBufDecoded;   
			    memcpy(&dwPresTime,pComData,sizeof(U32_WMC));
				
				pDecoder->tAudioStreamInfo[Index]->dwAudioTimeStamp = dwPresTime;
			}
		/*	else
			{
				if (pDecoder->tAudioStreamInfo[Index]->bOutputisReady == TRUE_WMC)
				{
					I16_WMC TempOutBuff[4096];
					U32_WMC cbBuffer=0;
					I64_WMC  tPresentationTime=0;
					do
					{
						WMCDecGetAudioOutput(hDecoder, (I16_WMC*)&TempOutBuff[0], (I16_WMC*)NULL_WMC,(U32_WMC)1024, &cbBuffer, &tPresentationTime )	;					WMCRawGetData (TempOutBuff, &cbBuffer, hDecoder, (U32_WMC) 1024);
					}while(cbBuffer>0);
				
					pDecoder->tAudioStreamInfo[Index]->bOutputisReady = FALSE_WMC;
				}
			
			}*/

            break;
        case Video_WMC:
			if ((pDecoder->tVideoStreamInfo[Index]->bHasGivenAnyOutput == TRUE_WMC)&&(pDecoder->tVideoStreamInfo[Index]->bStopReading == FALSE_WMC))
				bGotAtLeastOneVideoOutput = TRUE_WMC;
			
			if ((pDecoder->tVideoStreamInfo[Index]->bWantOutput == TRUE_WMC)&&(pDecoder->tVideoStreamInfo[Index]->bStopReading == FALSE_WMC))
				bGotAtLeastOneVideoStreamToOutput = TRUE_WMC;
			
			if (pDecoder->tVideoStreamInfo[Index]->dwBlockLeft !=0)
			{
				// problem. Either no output is taken or there is a video error
				pDecoder->tVideoStreamInfo[Index]->dwVideoBufDecoded += pDecoder->tVideoStreamInfo[Index]->dwBlockLeft;
				pDecoder->tVideoStreamInfo[Index]->dwBlockLeft =0;
				pDecoder->tVideoStreamInfo[Index]->bOutputisReady = FALSE_WMC;
			}
            break;
        case Binary_WMC:
			if ((pDecoder->tBinaryStreamInfo[Index]->bHasGivenAnyOutput == TRUE_WMC)&&(pDecoder->tBinaryStreamInfo[Index]->bStopReading == FALSE_WMC))
				bGotAtLeastOneBinaryOutput = TRUE_WMC;

			if ((pDecoder->tBinaryStreamInfo[Index]->bWantOutput == TRUE_WMC)&&(pDecoder->tBinaryStreamInfo[Index]->bStopReading == FALSE_WMC))
				bGotAtLeastOneBinaryStreamToOutput = TRUE_WMC;

			if (pDecoder->tBinaryStreamInfo[Index]->dwBlockLeft !=0)
			{
				// problem. Either no output is taken 
				pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufDecoded += pDecoder->tBinaryStreamInfo[Index]->dwBlockLeft;
				pDecoder->tBinaryStreamInfo[Index]->dwBlockLeft =0;
				pDecoder->tBinaryStreamInfo[Index]->bOutputisReady = FALSE_WMC;
			}

        }
    }

	Index =0;

	if (bGotAtLeastOneVideoStreamToOutput == FALSE_WMC)
		bGotAtLeastOneVideoOutput = TRUE_WMC;

	if (bGotAtLeastOneBinaryStreamToOutput == FALSE_WMC)
		bGotAtLeastOneBinaryOutput = TRUE_WMC;


    if(3== bType)
    {
        for (i=0; i< pDecoder->tPlannedOutputInfo.wTotalOutput; i++ )
        {
            Index = pDecoder->tPlannedOutputInfo.tPlannedId[i].wStreamIndex;

            switch(pDecoder->tPlannedOutputInfo.tPlannedId[i].tMediaType)
            {
            case Audio_WMC:
                if ((pDecoder->tAudioStreamInfo[Index]->dwAudioBufCurOffset > pDecoder->tAudioStreamInfo[Index]->dwAudioBufDecoded))
                {
					if (dwMinAudioPresTime > (U32_WMC)pDecoder->tAudioStreamInfo[Index]->dwAudioTimeStamp)
					{
						dwMinAudioPresTime = (U32_WMC)pDecoder->tAudioStreamInfo[Index]->dwAudioTimeStamp;
						wMinAudioIndex = Index;
					}
				}
				else
				{
					dwMinAudioPresTime = 0xffffffff;
					*pbDecoded = 0xfe;
				
				}
                break;
            case Video_WMC:
                if ((pDecoder->tVideoStreamInfo[Index]->dwVideoBufCurOffset > pDecoder->tVideoStreamInfo[Index]->dwVideoBufDecoded))
                {
					pComData =  pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer + pDecoder->tVideoStreamInfo[Index]->dwVideoBufDecoded;   
					memcpy(&dwPresTime,pComData,sizeof(U32_WMC));
					
					if ((dwMinVideoPresTime > dwPresTime )&&((pDecoder->tVideoStreamInfo[Index]->bStopReading == FALSE_WMC) || (bGotAtLeastOneVideoOutput == FALSE_WMC)))
					{
						dwMinVideoPresTime = dwPresTime;
						wMinVideoIndex = Index;
					}
					else if((dwMinVideoPresTime == dwPresTime ) && (pDecoder->tVideoStreamInfo[Index]->bStopReading == FALSE_WMC))
					{
						dwMinVideoPresTime = dwPresTime;
						wMinVideoIndex = Index;
					}
				}
				else
				{
					dwMinVideoPresTime = 0xffffffff;
					*pbDecoded = 0xfe;
				
				}
				if ((pDecoder->tVideoStreamInfo[Index]->bStopReading == TRUE_WMC) && (bGotAtLeastOneVideoOutput == TRUE_WMC))
				{
					//Dont Read and decode this stream.
					pDecoder->tVideoStreamInfo[Index]->bNowStopReadingAndDecoding = TRUE_WMC;
					
					dwMinVideoPresTime = 0xffffffff;
					*pbDecoded = 0xfe;
					pDecoder->tVideoStreamInfo[Index]->dwVideoBufCurOffset =0;
					pDecoder->tVideoStreamInfo[Index]->dwVideoBufDecoded =0;
				}

                break;
            case Binary_WMC:
                if ((pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufCurOffset > pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufDecoded))
                {
					pComData =  pDecoder->tBinaryStreamInfo[Index]->pbBinaryBuffer + pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufDecoded;   
					memcpy(&dwPresTime,pComData,sizeof(U32_WMC));
					if ((dwMinBinaryPresTime > dwPresTime )&&((pDecoder->tBinaryStreamInfo[Index]->bStopReading == FALSE_WMC) || (bGotAtLeastOneBinaryOutput == FALSE_WMC)))
					{
						dwMinBinaryPresTime = dwPresTime;
						wMinBinaryIndex = Index;
					}
					else if((dwMinBinaryPresTime == dwPresTime ) && (pDecoder->tBinaryStreamInfo[Index]->bStopReading == FALSE_WMC))
					{
						dwMinBinaryPresTime = dwPresTime;
						wMinBinaryIndex = Index;
					}

				}
				else
				{
					dwMinBinaryPresTime = 0xffffffff;
					*pbDecoded = 0xfe;
				
				}
				if ((pDecoder->tBinaryStreamInfo[Index]->bStopReading == TRUE_WMC) && (bGotAtLeastOneBinaryOutput == TRUE_WMC))
				{
					//Dont Read and decode this stream.
					pDecoder->tBinaryStreamInfo[Index]->bNowStopReadingAndDecoding = TRUE_WMC;
					
					dwMinBinaryPresTime = 0xffffffff;
					*pbDecoded = 0xfe;
					pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufCurOffset =0;
					pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufDecoded =0;
				}


            }
        }
    

    // Findout Minimum of all 3..... and select which stream to decode

        dwMinPresTime = dwMinAudioPresTime;
        MediaType = Audio_WMC;

        if (dwMinVideoPresTime < dwMinPresTime)
        {
            dwMinPresTime = dwMinVideoPresTime;
            MediaType = Video_WMC;
        }
        if (dwMinBinaryPresTime < dwMinPresTime)
        {
            dwMinPresTime = dwMinBinaryPresTime;
            MediaType = Binary_WMC;
        }
 
        if (dwMinPresTime == 0xffffffff)
        {
         // No stream is ready to get decoded;
        
            *pbDecoded = 0xff;
            return WMCDec_Succeeded;
        }
    }
    else
    {
        for (i=0; i< pDecoder->tPlannedOutputInfo.wTotalOutput; i++ )
        {
            
			pDecoder->tPlannedOutputInfo.tPlannedId[i].bDone = FALSE_WMC;
			Index = pDecoder->tPlannedOutputInfo.tPlannedId[i].wStreamIndex;
            wMinAudioIndex =0;
            wMinVideoIndex=0;
            wMinBinaryIndex=0;


            switch(pDecoder->tPlannedOutputInfo.tPlannedId[i].tMediaType)
            {
            case Audio_WMC:
                if ((pDecoder->tAudioStreamInfo[Index]->dwAudioBufCurOffset > pDecoder->tAudioStreamInfo[Index]->dwAudioBufDecoded))
                {
                    wMinAudioIndex = Index;
                    MediaType = Audio_WMC;
                }
                else
                {
					pDecoder->tPlannedOutputInfo.tPlannedId[i].bDone = TRUE_WMC;
				//	*pbDecoded = 0xff;
                 //   return WMCDec_Succeeded;
                }
                break;
            case Video_WMC:
                if ((pDecoder->tVideoStreamInfo[Index]->dwVideoBufCurOffset > pDecoder->tVideoStreamInfo[Index]->dwVideoBufDecoded))
                {
				    pComData =  pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer + pDecoder->tVideoStreamInfo[Index]->dwVideoBufDecoded;   
				    memcpy(&dwPresTime,pComData,sizeof(U32_WMC));
					dwMinVideoPresTime = dwPresTime;
                    wMinVideoIndex = Index;
                    MediaType = Video_WMC;
                }
                else
                {
					pDecoder->tPlannedOutputInfo.tPlannedId[i].bDone = TRUE_WMC;
//					*pbDecoded = 0xff;
//                    return WMCDec_Succeeded;
                }
                break;
            case Binary_WMC:
                if ((pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufCurOffset > pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufDecoded))
                {
					pComData =  pDecoder->tBinaryStreamInfo[Index]->pbBinaryBuffer + pDecoder->tBinaryStreamInfo[Index]->dwBinaryBufDecoded;   
					memcpy(&dwPresTime,pComData,sizeof(U32_WMC));
					dwMinBinaryPresTime = dwPresTime;
                    wMinBinaryIndex = Index;
                    MediaType = Binary_WMC;
                }
                else
                {
                    
					pDecoder->tPlannedOutputInfo.tPlannedId[i].bDone = TRUE_WMC;
//					*pbDecoded = 0xff;
//                    return WMCDec_Succeeded;
                }

            }
        }
    
        for (i=0; i< pDecoder->tPlannedOutputInfo.wTotalOutput; i++ )
        {
			if (pDecoder->tPlannedOutputInfo.tPlannedId[i].bDone == TRUE_WMC)
			{
				bAllDone = TRUE_WMC;
			}
			else
			{
				bAllDone = FALSE_WMC;
				break;
			}

		}

		if (bAllDone == TRUE_WMC)
		{
			*pbDecoded = 0xff;
            return WMCDec_Succeeded;
		}


    }

    if ((3== bType) || (4== bType)) // Normal decode
	{
        switch(MediaType)
        {
        case Audio_WMC:
            if ((pDecoder->tAudioStreamInfo[wMinAudioIndex]->dwAudioBufCurOffset > pDecoder->tAudioStreamInfo[wMinAudioIndex]->dwAudioBufDecoded))
            {
                pDecoder->i32CurrentAudioStreamIndex = wMinAudioIndex;
#ifndef _ASFPARSE_ONLY_			   
                if (pDecoder->tAudioStreamInfo[wMinAudioIndex]->bTobeDecoded == TRUE_WMC)
                {
            
                    if (pDecoder->tAudioStreamInfo[wMinAudioIndex]->nVersion >0 && pDecoder->tAudioStreamInfo[wMinAudioIndex]->nVersion <4)
                    {
                        if (pDecoder->tAudioStreamInfo[wMinAudioIndex]->wmar != WMA_OK)
				        {
					        if (pDecoder->tAudioStreamInfo[wMinAudioIndex]->wmar > 0)
					        {
                                if (pDecoder->tAudioStreamInfo[wMinAudioIndex]->wmar == WMA_S_NO_MORE_FRAME)
                                {
                                 //   _asm emms;
                                   // pDecoder->tAudioStreamInfo[wMinAudioIndex]->bTimeToChange = TRUE_WMC; 
 
									wmar = WMARawDecStatus (pDecoder->tAudioStreamInfo[wMinAudioIndex]->hMSA);
                                }
					        }
						    else
					        {
						        WMARawDecReset (pDecoder->tAudioStreamInfo[wMinAudioIndex]->hMSA);
						        pDecoder->tAudioStreamInfo[wMinAudioIndex]->dwAudioBufDecoded = pDecoder->tAudioStreamInfo[wMinAudioIndex]->dwAudioBufDecoded + pDecoder->tAudioStreamInfo[wMinAudioIndex]->dwBlockLeft;
						        pDecoder->tAudioStreamInfo[wMinAudioIndex]->dwBlockLeft =0;
						        wmar = WMARawDecStatus (pDecoder->tAudioStreamInfo[wMinAudioIndex]->hMSA);
					        }
				        }
                        *pnNumberOfSamples = 8000;
                       // _asm emms;
                        wmar = WMARawDecDecodeData (pDecoder->tAudioStreamInfo[wMinAudioIndex]->hMSA, (U32_WMARawDec *)pnNumberOfSamples
    #ifdef _V9WMADEC_
                            , (I32_WMARawDec *)0
    #endif
                            );
                        
						if (wmar == WMA_S_NO_MORE_FRAME)
						{
                           pDecoder->tAudioStreamInfo[wMinAudioIndex]->bTimeToChange = TRUE_WMC; 

						}
						
						if (wmar == WMA_E_BROKEN_FRAME) 
				        {
					        WMARawDecReset (pDecoder->tAudioStreamInfo[wMinAudioIndex]->hMSA);
					        pDecoder->tAudioStreamInfo[wMinAudioIndex]->dwAudioBufDecoded = pDecoder->tAudioStreamInfo[wMinAudioIndex]->dwAudioBufDecoded + pDecoder->tAudioStreamInfo[wMinAudioIndex]->dwBlockLeft;
					        pDecoder->tAudioStreamInfo[wMinAudioIndex]->dwBlockLeft =0;
					        wmar = WMARawDecStatus(pDecoder->tAudioStreamInfo[wMinAudioIndex]->hMSA);
					        wmar = WMA_OK;
                        }

				        if (wmar == WMA_E_ONHOLD) 
				        {
					        wmar = WMA_OK;
                        }
                        if (wmar == WMA_E_LOSTPACKET) 
				        {
					        wmar = WMA_OK;
                        }
        
                        *pbDecoded = pDecoder->tAudioStreamInfo[wMinAudioIndex]->wStreamId;
                        pDecoder->tAudioStreamInfo[wMinAudioIndex]->wmar = wmar;
                    }
#ifndef __NO_SPEECH__
                    else if(pDecoder->tAudioStreamInfo[wMinAudioIndex]->nVersion ==4 )//Speech Codec
                    {
 /*                       if (pDecoder->tAudioStreamInfo[wMinAudioIndex]->wmsr != WMS_OK)
				        {
					        if (pDecoder->tAudioStreamInfo[wMinAudioIndex]->wmsr > 0)
					        {
                                if (pDecoder->tAudioStreamInfo[wMinAudioIndex]->wmsr == WMS_S_NO_MORE_FRAME)
                                {
                                    wmsr = WMSRawDecStatus (pDecoder->tAudioStreamInfo[wMinAudioIndex]->hMSA);
                                }
					        }
						    else
					        {
						        WMSRawDecReset (pDecoder->tAudioStreamInfo[wMinAudioIndex]->hMSA);
						        pDecoder->tAudioStreamInfo[wMinAudioIndex]->dwAudioBufDecoded = pDecoder->tAudioStreamInfo[wMinAudioIndex]->dwAudioBufDecoded + pDecoder->tAudioStreamInfo[wMinAudioIndex]->dwBlockLeft;
						        pDecoder->tAudioStreamInfo[wMinAudioIndex]->dwBlockLeft =0;
						        wmsr = WMSRawDecStatus (pDecoder->tAudioStreamInfo[wMinAudioIndex]->hMSA);
					        }
				        }
*/                        *pnNumberOfSamples = 0;
                        wmsr = WMSRawDecDecodeData (pDecoder->tAudioStreamInfo[wMinAudioIndex]->hMSA, (U32_WMARawDec *)pnNumberOfSamples);
                        if (wmsr == WMS_E_BROKEN_FRAME) 
				        {
					        WMSRawDecReset (pDecoder->tAudioStreamInfo[wMinAudioIndex]->hMSA);
					        pDecoder->tAudioStreamInfo[wMinAudioIndex]->dwAudioBufDecoded = pDecoder->tAudioStreamInfo[wMinAudioIndex]->dwAudioBufDecoded + pDecoder->tAudioStreamInfo[wMinAudioIndex]->dwBlockLeft;
					        pDecoder->tAudioStreamInfo[wMinAudioIndex]->dwBlockLeft =0;
					        wmsr = WMARawDecStatus(pDecoder->tAudioStreamInfo[wMinAudioIndex]->hMSA);
					        wmsr = WMS_OK;
                        }

				        if (wmsr == WMS_E_ONHOLD) 
				        {
					        wmsr = WMS_OK;
                        }
                        if (wmsr == WMS_E_LOSTPACKET) 
				        {
					        wmsr = WMS_OK;
                        }
        
                        *pbDecoded = pDecoder->tAudioStreamInfo[wMinAudioIndex]->wStreamId;
//                        pDecoder->tAudioStreamInfo[wMinAudioIndex]->wmsr = wmsr;
                    }
#endif
                }
                else
#endif //_ASFPARSE_ONLY_
                {
                    *pbDecoded = pDecoder->tAudioStreamInfo[wMinAudioIndex]->wStreamId;
					
					if (pDecoder->tAudioStreamInfo[wMinAudioIndex]->bOutputisReady == TRUE_WMC) // Last output is not taken out
					{
						//Fix buffers
						U8_WMC TempOutBuff[1024];
						U32_WMC cbBuffer=0;
						do
						{
							WMCRawGetData (TempOutBuff, &cbBuffer, hDecoder, (U32_WMC) 1024);
						}while(cbBuffer>0);
					
					}
					
					
            		pDecoder->tAudioStreamInfo[wMinAudioIndex]->bGotCompOutput = FALSE_WMC;
					pDecoder->tAudioStreamInfo[wMinAudioIndex]->bOutputisReady = TRUE_WMC;
					memcpy (pnNumberOfSamples,(pDecoder->tAudioStreamInfo[wMinAudioIndex]->pbAudioBuffer + pDecoder->tAudioStreamInfo[wMinAudioIndex]->dwAudioBufDecoded + sizeof(U32_WMC) ), sizeof(U32_WMC));

//                    *pnNumberOfSamples =1;  // To be changed. Should be no of bytes
                }
            }
            else
            {	
				*pbDecoded = 0xfe;
                pDecoder->tAudioStreamInfo[wMinAudioIndex]->dwAudPayloadPresTime = 0xffffffff;
			    pDecoder->tAudioStreamInfo[wMinAudioIndex]->dwAudioTimeStamp = (Double_WMC)0xffffffff;
	//*pbDecoded = 0xff;
            }
            break;
        case Video_WMC:
            if ((pDecoder->tVideoStreamInfo[wMinVideoIndex]->dwVideoBufCurOffset > pDecoder->tVideoStreamInfo[wMinVideoIndex]->dwVideoBufDecoded))
            {
                pDecoder->i32CurrentVideoStreamIndex = wMinVideoIndex;
#ifndef _ASFPARSE_ONLY_
			    if (pDecoder->tVideoStreamInfo[wMinVideoIndex]->bTobeDecoded == TRUE_WMC)
                {
                    if ((pDecoder->bSkipToNextI) && (pDecoder->tVideoStreamInfo[Index]->pbVideoBuffer[pDecoder->tVideoStreamInfo[Index]->dwVideoBufDecoded + 12])) {
                            pDecoder->bSkipToNextI = FALSE_WMC;
                    };
		                            
                    if (pDecoder->bSkipToNextI) {
                        Bool_WMV bNotEndOfFrame = TRUE_WMV;
                        U8_WMV * pchBuffer = NULL;
                        U32_WMV uintActualBufferLength =0 ;
                       // U32_WMV uintTotalBufferLength =0;

                        while (bNotEndOfFrame == TRUE_WMV) {
                            WMVDecCBGetData ( (U32_WMV) pDecoder, 0,
                                &pchBuffer,
                                4,
                                &uintActualBufferLength,
                                &bNotEndOfFrame );

                            if ((pchBuffer == NULL) || (uintActualBufferLength ==0) )
                                bNotEndOfFrame = FALSE_WMV;

                        //  uintTotalBufferLength+=uintActualBufferLength;
                        }
                        *pnNumberOfSamples = 0;
                        *pbDecoded = pDecoder->tVideoStreamInfo[wMinVideoIndex]->wStreamId;
                    }
                    else 
                    {

                        if(
                            pDecoder->tVideoStreamInfo[wMinVideoIndex]->biCompression == FOURCC_WMV2 ||
                            pDecoder->tVideoStreamInfo[wMinVideoIndex]->biCompression == FOURCC_WMV1 ||
                            pDecoder->tVideoStreamInfo[wMinVideoIndex]->biCompression == FOURCC_WMS2 ||
                            pDecoder->tVideoStreamInfo[wMinVideoIndex]->biCompression == FOURCC_WMS1 ||
                            pDecoder->tVideoStreamInfo[wMinVideoIndex]->biCompression == FOURCC_M4S2 ||
                            pDecoder->tVideoStreamInfo[wMinVideoIndex]->biCompression == FOURCC_MP4S ||
                            pDecoder->tVideoStreamInfo[wMinVideoIndex]->biCompression == FOURCC_MP43 ||
                            pDecoder->tVideoStreamInfo[wMinVideoIndex]->biCompression == FOURCC_MP42 ||
                            pDecoder->tVideoStreamInfo[wMinVideoIndex]->biCompression == FOURCC_MPG4 )
                        
                        {    
                        
                        
                            VidStatus = WMVideoDecDecodeData ((HWMVDecoder)pDecoder->tVideoStreamInfo[wMinVideoIndex]->pVDec, (U16_WMV *)pnNumberOfSamples);
                            if (WMV_Succeeded == VidStatus)
                            {
                                *pbDecoded = pDecoder->tVideoStreamInfo[wMinVideoIndex]->wStreamId;
                                *pnNumberOfSamples =1;
                            }
                            else
                            {
                               // WMVideoDecReset((HWMVDecoder)pDecoder->tVideoStreamInfo[wMinVideoIndex]->pVDec);
						        pDecoder->tVideoStreamInfo[wMinVideoIndex]->dwVideoBufDecoded += pDecoder->tVideoStreamInfo[wMinVideoIndex]->dwBlockLeft;
						        pDecoder->tVideoStreamInfo[wMinVideoIndex]->dwBlockLeft =0;
								*pbDecoded = pDecoder->tVideoStreamInfo[wMinVideoIndex]->wStreamId;
								
								switch(VidStatus)
								{
								case WMV_Failed :
									return WMVDec_Failed;
								case WMV_BadMemory:
									return WMVDec_BadMemory;
								case WMV_NoKeyFrameDecoded:
									return WMVDec_NoKeyFrameDecoded;
								case WMV_CorruptedBits:
									return WMVDec_CorruptedBits;
								case WMV_BrokenFrame:
									return WMVDec_BrokenFrame;
								default:
									return WMVDec_Failed; 
								}
                            }
                        }
#ifndef __NO_SCREEN__
                        else if(pDecoder->tVideoStreamInfo[wMinVideoIndex]->biCompression == FOURCC_MSS1 ||
					            pDecoder->tVideoStreamInfo[wMinVideoIndex]->biCompression == FOURCC_MSS2)
                        {
                            
                            tWMCDecStatus TempStatus;
                            TempStatus = WMScDecodeData (hDecoder, wMinVideoIndex);
                            if (WMCDec_Succeeded == TempStatus)
                            {
                                *pbDecoded = pDecoder->tVideoStreamInfo[wMinVideoIndex]->wStreamId;
                                *pnNumberOfSamples =1;
                            }
                            else
                            {
                            
                                *pbDecoded = pDecoder->tVideoStreamInfo[wMinVideoIndex]->wStreamId;
						        pDecoder->tVideoStreamInfo[wMinVideoIndex]->dwVideoBufDecoded += pDecoder->tVideoStreamInfo[wMinVideoIndex]->dwBlockLeft;
						        pDecoder->tVideoStreamInfo[wMinVideoIndex]->dwBlockLeft =0;
                                return WMVDec_Failed; 
                            }
                        
                        }
#endif
                    }
                }
                else
#endif //_ASFPARSE_ONLY_
                {
                    *pbDecoded = pDecoder->tVideoStreamInfo[wMinVideoIndex]->wStreamId;
 //                   *pnNumberOfSamples =1;  // To be changed. Should be no of bytes
					
					if (pDecoder->tVideoStreamInfo[wMinVideoIndex]->bOutputisReady == TRUE_WMC) // Last output is not taken out
					{
						//Fix buffers
						U8_WMC TempOutBuff[1024];
						U32_WMC cbBuffer=0;
						do
						{
							WMCRawGetVideoData (TempOutBuff, &cbBuffer, hDecoder, (U32_WMC) 1024);
						}while(cbBuffer>0);
					
					}
					
            		pDecoder->tVideoStreamInfo[wMinVideoIndex]->bGotCompOutput = FALSE_WMC;
					
					pDecoder->tVideoStreamInfo[wMinVideoIndex]->bOutputisReady = TRUE_WMC;
		            memcpy (pnNumberOfSamples,(pDecoder->tVideoStreamInfo[wMinVideoIndex]->pbVideoBuffer + pDecoder->tVideoStreamInfo[wMinVideoIndex]->dwVideoBufDecoded + 2*sizeof(U32_WMC) ), sizeof(U32_WMC));
                }


            }
            else
            {
//                *pbDecoded = 0xff;
                *pbDecoded = 0xfe;
				pDecoder->tVideoStreamInfo[wMinVideoIndex]->dwVideoTimeStamp = 0xffffffff;
            }
            
			pDecoder->tVideoStreamInfo[wMinVideoIndex]->dwVideoTimeStamp = dwMinVideoPresTime;
			pDecoder->tVideoStreamInfo[wMinVideoIndex]->bHasGivenAnyOutput = TRUE_WMC;

            break;
        case Binary_WMC:
            if ((pDecoder->tBinaryStreamInfo[wMinBinaryIndex]->dwBinaryBufCurOffset > pDecoder->tBinaryStreamInfo[wMinBinaryIndex]->dwBinaryBufDecoded))
            {
                *pbDecoded = pDecoder->tBinaryStreamInfo[wMinBinaryIndex]->wStreamId;
                pDecoder->i32CurrentBinaryStreamIndex = wMinBinaryIndex;
//                *pnNumberOfSamples =1;  // To be changed. Should be no of bytes
				if (pDecoder->tBinaryStreamInfo[wMinBinaryIndex]->bOutputisReady == TRUE_WMC) // Last output is not taken out
				{
					//Fix buffers
					U8_WMC TempOutBuff[1024];
					U32_WMC cbBuffer=0;
					do
					{
						WMCRawGetBinaryData (TempOutBuff, &cbBuffer, hDecoder, (U32_WMC) 1024);
					}while(cbBuffer>0);
				
				}
				
				
            	pDecoder->tBinaryStreamInfo[wMinBinaryIndex]->bGotCompOutput = FALSE_WMC;
				pDecoder->tBinaryStreamInfo[wMinBinaryIndex]->bOutputisReady = TRUE_WMC;
		        memcpy (pnNumberOfSamples,(pDecoder->tBinaryStreamInfo[wMinBinaryIndex]->pbBinaryBuffer + pDecoder->tBinaryStreamInfo[wMinBinaryIndex]->dwBinaryBufDecoded + sizeof(U32_WMC) ), sizeof(U32_WMC));
            }
            else
            {
//                *pbDecoded = 0xff;
				*pbDecoded = 0xfe;
                pDecoder->tBinaryStreamInfo[wMinBinaryIndex]->dwBinaryTimeStamp = 0xffffffff;
            }
			pDecoder->tBinaryStreamInfo[wMinBinaryIndex]->bHasGivenAnyOutput = TRUE_WMC;

            break;
        default:
            *pbDecoded = 0xff;        
        }
    }
    return WMCDec_Succeeded;
}

/*******************************************************************************************************************************/
tWMCDecStatus WMCDecClose (HWMCDECODER* phWMCDec)
{
    I32_WMC i;

 	WMFDecoderEx* pDecoder = (WMFDecoderEx *)(*phWMCDec);
    if (pDecoder == NULL)
        return WMCDec_InValidArguments;

    for(i=0; i< pDecoder->cTotalIndexs ; i++)
    {
        if (pDecoder->tIndexInfo[i].pIndexEntries !=NULL )
            wmvfree (pDecoder->tIndexInfo[i].pIndexEntries);
        pDecoder->tIndexInfo[i].pIndexEntries = NULL;
    
    }

    for(i=0; i<pDecoder->tHeaderInfo.wNoOfVideoStreams; i++ )
    {

        if(
            pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_WMV2 ||
            pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_WMV1 ||
            pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_WMS2 ||
            pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_WMS1 ||
            pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_M4S2 ||
            pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MP4S ||
            pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MP43 ||
            pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MP42 ||
            pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MPG4 )
        {
        
#ifndef _ASFPARSE_ONLY_        
            if(pDecoder->tVideoStreamInfo[i]->pVDec !=NULL)
            {
                WMVideoDecClose ((HWMVDecoder) pDecoder->tVideoStreamInfo[i]->pVDec);
                pDecoder->tVideoStreamInfo[i]->pVDec = NULL;
            }
#endif
        }
#ifndef __NO_SCREEN__
        else if(pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MSS1 ||
				pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MSS2)
        {
            WMScreenDecoderDestroy ((LPVOID) pDecoder->tVideoStreamInfo[i]->pVDec);
            pDecoder->tVideoStreamInfo[i]->pVDec = NULL;
        }
#endif
        if (pDecoder->tVideoStreamInfo[i]->pbVideoBuffer != NULL)
        {
            wmvfree(pDecoder->tVideoStreamInfo[i]->pbVideoBuffer);
            pDecoder->tVideoStreamInfo[i]->pbVideoBuffer = NULL;


        }
#ifndef __NO_SCREEN__
       
        if (pDecoder->tVideoStreamInfo[i]->pSCInBuffer != NULL)
        {
            wmvfree(pDecoder->tVideoStreamInfo[i]->pSCInBuffer);
            pDecoder->tVideoStreamInfo[i]->pSCInBuffer = NULL;
        }
        if (pDecoder->tVideoStreamInfo[i]->pSCOutBuffer != NULL)
        {
            wmvfree(pDecoder->tVideoStreamInfo[i]->pSCOutBuffer);
            pDecoder->tVideoStreamInfo[i]->pSCOutBuffer = NULL;
        }
#endif        
	    if (pDecoder->tVideoStreamInfo[i] !=NULL)    
			wmvfree(pDecoder->tVideoStreamInfo[i]);
        pDecoder->tVideoStreamInfo[i] = NULL;
    }

    for(i=0; i<pDecoder->tHeaderInfo.wNoOfBinaryStreams; i++ )
    {
        if (pDecoder->tBinaryStreamInfo[i]->pbBinaryBuffer != NULL)
        {
            wmvfree(pDecoder->tBinaryStreamInfo[i]->pbBinaryBuffer);
            pDecoder->tBinaryStreamInfo[i]->pbBinaryBuffer = NULL;
        }
	    if (pDecoder->tBinaryStreamInfo[i] !=NULL)    
			wmvfree(pDecoder->tBinaryStreamInfo[i]);
        pDecoder->tBinaryStreamInfo[i] = NULL;
    }

    for(i=0; i<pDecoder->tHeaderInfo.wNoOfAudioStreams; i++ )
    {
#ifndef _ASFPARSE_ONLY_
        if(pDecoder->tAudioStreamInfo[i]->hMSA !=NULL)
        {
            if (pDecoder->tAudioStreamInfo[i]->nVersion > 0 && pDecoder->tAudioStreamInfo[i]->nVersion <4)
                WMARawDecClose(&(pDecoder->tAudioStreamInfo[i]->hMSA));
#ifndef __NO_SPEECH__
            else if (pDecoder->tAudioStreamInfo[i]->nVersion == 4) // Speech Codec
            {
                WMSRawDecClose(&(pDecoder->tAudioStreamInfo[i]->hMSA));
//                InitNSPLibWMSP(DLL_PROCESS_DETACH);
                MyInitNSP(INTELFFT_FREE_PROCESS);
            }
#endif
            pDecoder->tAudioStreamInfo[i]->hMSA = NULL;
        }
#endif //_ASFPARSE_ONLY_
        if(pDecoder->tAudioStreamInfo[i]->pbAudioBuffer !=NULL)
        {
    		wmvfree(pDecoder->tAudioStreamInfo[i]->pbAudioBuffer);
            pDecoder->tAudioStreamInfo[i]->pbAudioBuffer = NULL;
        }

	    if (pDecoder->tAudioStreamInfo[i] !=NULL)    
			wmvfree(pDecoder->tAudioStreamInfo[i]);
        pDecoder->tAudioStreamInfo[i] = NULL;
    }
    if(pDecoder->pszType != NULL)
    {
        wmvfree(pDecoder->pszType);
    }

    if(pDecoder->pszKeyID != NULL)
    {
        wmvfree(pDecoder->pszKeyID);
    }
    if(pDecoder->m_pLicData != NULL)
    {
        wmvfree(pDecoder->m_pLicData);
    }

    if (pDecoder->pStreamIdnMediaType != NULL)
        wmvfree(pDecoder->pStreamIdnMediaType);
    pDecoder->pStreamIdnMediaType = NULL;
    

    if(pDecoder->m_pContentDesc != NULL) {
        if (pDecoder->m_pContentDesc->pchTitle !=NULL)
        {
            wmvfree (pDecoder->m_pContentDesc->pchTitle );
            pDecoder->m_pContentDesc->pchTitle  = NULL;
        }
        if (pDecoder->m_pContentDesc->pchAuthor !=NULL)
        {
            wmvfree (pDecoder->m_pContentDesc->pchAuthor );
            pDecoder->m_pContentDesc->pchAuthor  = NULL;
        }
        if (pDecoder->m_pContentDesc->pchCopyright !=NULL)
        {
            wmvfree (pDecoder->m_pContentDesc->pchCopyright );
            pDecoder->m_pContentDesc->pchCopyright  = NULL;
        }
        if (pDecoder->m_pContentDesc->pchDescription !=NULL)
        {
            wmvfree (pDecoder->m_pContentDesc->pchDescription );
            pDecoder->m_pContentDesc->pchDescription  = NULL;
        }
        if (pDecoder->m_pContentDesc->pchRating !=NULL)
        {
            wmvfree (pDecoder->m_pContentDesc->pchRating );
            pDecoder->m_pContentDesc->pchRating  = NULL;
        }
        wmvfree(pDecoder->m_pContentDesc);
        pDecoder->m_pContentDesc = NULL;
      
    }
  
    if(pDecoder->m_pCodecEntry  != NULL)
	{
        for(i = 0; i < (I32_WMC)pDecoder->m_dwNumCodec ; i++) 
		{
            if (NULL != pDecoder->m_pCodecEntry[i].m_pwCodecName)
			{
				wmvfree(pDecoder->m_pCodecEntry[i].m_pwCodecName );
				pDecoder->m_pCodecEntry[i].m_pwCodecName = NULL;
			}
            if (NULL != pDecoder->m_pCodecEntry[i].m_pwCodecDescription)
			{
				wmvfree(pDecoder->m_pCodecEntry[i].m_pwCodecDescription );
				pDecoder->m_pCodecEntry[i].m_pwCodecDescription = NULL;
			}
            if (NULL != pDecoder->m_pCodecEntry[i].m_pbCodecInfo)
			{
				wmvfree(pDecoder->m_pCodecEntry[i].m_pbCodecInfo );
				pDecoder->m_pCodecEntry[i].m_pbCodecInfo = NULL;
			}
        }
        wmvfree(pDecoder->m_pCodecEntry);
        pDecoder->m_pCodecEntry = NULL;
    }


	
    if(pDecoder->m_pMarkers != NULL) {
        for(i = 0; i < (I32_WMC)pDecoder->m_dwMarkerNum; i++) {
            wmvfree(pDecoder->m_pMarkers[i].m_pwDescName);
            pDecoder->m_pMarkers[i].m_pwDescName = NULL;
        }
        wmvfree(pDecoder->m_pMarkers);
        pDecoder->m_pMarkers = NULL;
    }

    if(pDecoder->tMetaDataEntry.pDescRec != NULL) {
        for(i = 0; i < (I32_WMC)pDecoder->tMetaDataEntry.m_wDescRecordsCount; i++) {
            SAFEMEMFREE(pDecoder->tMetaDataEntry.pDescRec[i].pwName );
            pDecoder->tMetaDataEntry.pDescRec[i].pwName  = NULL;
            SAFEMEMFREE(pDecoder->tMetaDataEntry.pDescRec[i].pData );
            pDecoder->tMetaDataEntry.pDescRec[i].pData  = NULL;
        }
        SAFEMEMFREE(pDecoder->tMetaDataEntry.pDescRec);
        pDecoder->tMetaDataEntry.pDescRec = NULL;
    }


    if (pDecoder->m_pExtendedContentDesc != NULL)
    {
         if(pDecoder->m_pExtendedContentDesc->cDescriptors > 0) {
            for (i = 0; i < pDecoder->m_pExtendedContentDesc->cDescriptors; i++) {
                wmvfree(pDecoder->m_pExtendedContentDesc->pDescriptors[i].uValue.pbBinary);
                wmvfree(pDecoder->m_pExtendedContentDesc->pDescriptors[i].pwszName);
                pDecoder->m_pExtendedContentDesc->pDescriptors[i].uValue.pbBinary = NULL;
                pDecoder->m_pExtendedContentDesc->pDescriptors[i].pwszName = NULL;
            }
            wmvfree(pDecoder->m_pExtendedContentDesc->pDescriptors);
            pDecoder->m_pExtendedContentDesc->pDescriptors = NULL;
        }
        wmvfree (pDecoder->m_pExtendedContentDesc);
        pDecoder->m_pExtendedContentDesc = NULL;
    }    

    if(pDecoder->m_pScriptCommand != NULL) {
        if(pDecoder->m_pScriptCommand->num_types > 0 ) {
            wmvfree(pDecoder->m_pScriptCommand->type_name_len);
            pDecoder->m_pScriptCommand->type_name_len = NULL;
            for (i = 0; i < pDecoder->m_pScriptCommand->num_types; i++) {
                wmvfree(pDecoder->m_pScriptCommand->type_names[i]);
                pDecoder->m_pScriptCommand->type_names[i] = NULL;
            }
            wmvfree(pDecoder->m_pScriptCommand->type_names);
            pDecoder->m_pScriptCommand->type_names = NULL;
        }
        if(pDecoder->m_pScriptCommand->num_commands > 0 ) {
            wmvfree(pDecoder->m_pScriptCommand->command_param_len);
            pDecoder->m_pScriptCommand->command_param_len = NULL;
            for (i = 0; i < pDecoder->m_pScriptCommand->num_commands; i++) {
                if(pDecoder->m_pScriptCommand->commands[i].param) {
                    wmvfree(pDecoder->m_pScriptCommand->commands[i].param);
                    pDecoder->m_pScriptCommand->commands[i].param = NULL;
				}
            }
            wmvfree(pDecoder->m_pScriptCommand->commands);
            pDecoder->m_pScriptCommand->commands = NULL;
        }
        wmvfree(pDecoder->m_pScriptCommand);
        pDecoder->m_pScriptCommand = NULL;
    }    

    WMFCloseDecoder (phWMCDec);

	*phWMCDec = NULL;


    return WMCDec_Succeeded;

}

/*********************************************************************************************************************/
tWMCDecStatus WMCSkipToNextKey (HWMCDECODER hWMCDec)
{
    tWMCDecStatus err = WMCDec_Succeeded;
    WMFDecoderEx *pDecoder = NULL_WMC;    
  
	if(hWMCDec==NULL)
        return WMCDec_InValidArguments;


    pDecoder = (WMFDecoderEx*) hWMCDec;
#ifndef _ASFPARSE_ONLY_
    pDecoder->bSkipToNextI = TRUE_WMV;
#endif
    return err;
}

/*********************************************************************************************************************/
tWMCDecStatus WMCDecDecodeData (HWMCDECODER hWMCDec, U32_WMC* pnStreamReadyForOutput, U32_WMC* pnNumberOfSamples, I32_WMC iHurryUp)
{
    tWMCDecStatus err = WMCDec_Succeeded;
    WMFDecoderEx *pDecoder = NULL;    
    U64_WMC cbLastPacketOffset; 
//    U32_WMC cbRead;
    I32_WMC lBytesWritten =0;
    U64_WMC cbPacketOffset=0;
    I32_WMC i;
    Bool_WMC bReadyForOutput = FALSE_WMC;
	U16_WMC wOutputStreamCount =0;

    if(hWMCDec==NULL_WMC || pnStreamReadyForOutput == NULL_WMC || (iHurryUp <-2) || (iHurryUp >2) || (pnNumberOfSamples == NULL_WMC) )
        return WMCDec_InValidArguments;
    
    pDecoder = (WMFDecoderEx*) hWMCDec;

    *pnStreamReadyForOutput = 0xff;

    if (pDecoder->bParsed != TRUE_WMC)
        return WMCDec_InValidArguments;
	
	pDecoder->iHurryUp = iHurryUp;

    if (pDecoder->tPlannedOutputInfo.wTotalOutput == 0)
        return WMCDec_DecodeComplete;
	wOutputStreamCount = pDecoder->tPlannedOutputInfo.wTotalOutput;
#ifndef WMC_NO_BUFFER_MODE    
    do
    {
		cbPacketOffset = pDecoder->tHeaderInfo.cbCurrentPacketOffset;
		cbLastPacketOffset =pDecoder->tHeaderInfo.cbLastPacketOffset;
        
        if( cbPacketOffset < cbLastPacketOffset )
        {

            for (i=0; i< pDecoder->tPlannedOutputInfo.wTotalOutput; i++ )
            {
                switch(pDecoder->tPlannedOutputInfo.tPlannedId[i].tMediaType)
                {
                case Audio_WMC:
                    if (pDecoder->tAudioStreamInfo[pDecoder->tPlannedOutputInfo.tPlannedId[i].wStreamIndex]->cbNbFramesAudBuf > 2 )
                        bReadyForOutput = TRUE_WMC;
                    else
                        bReadyForOutput = FALSE_WMC;
                    break;
                case Video_WMC:
                    if (pDecoder->tVideoStreamInfo[pDecoder->tPlannedOutputInfo.tPlannedId[i].wStreamIndex]->cbNbFramesVidBuf > 3 )
                        bReadyForOutput = TRUE_WMC;
                    else
                        bReadyForOutput = FALSE_WMC;
                    break;
                case Binary_WMC:
                    if (pDecoder->tBinaryStreamInfo[pDecoder->tPlannedOutputInfo.tPlannedId[i].wStreamIndex]->cbNbFramesBinBuf > 3 )
                        bReadyForOutput = TRUE_WMC;
                    else
                        bReadyForOutput = FALSE_WMC;
                    break;
                default:
                    bReadyForOutput = FALSE_WMC;

                }
                if (bReadyForOutput == FALSE_WMC)
                    break;
            }
            
            if ( bReadyForOutput == TRUE_WMC)
            {	
                err = WMCDecDecodeFrame( hWMCDec, 3, (U16_WMC *)pnStreamReadyForOutput, pnNumberOfSamples);
                if (*pnStreamReadyForOutput != 0xff)
                    return err;
	        }
        

            err = WMCDecDecodeSeqPacket(hWMCDec);
            
/*			if( WMPERR_DEMOEXPIRED == err )
            {
                err = WMPERR_DECODE_COMPLETE;
				break;
            }		
*/			if( WMCDec_Succeeded != err )
            {
				break;
            }		
		}
		else
        {
			*pnStreamReadyForOutput = 0xfe;
		    err = WMCDecDecodeFrame( hWMCDec, 3, (U16_WMC *)pnStreamReadyForOutput, pnNumberOfSamples);
            
			while ((*pnStreamReadyForOutput == 0xfe)&&(wOutputStreamCount>0))
			{
				err = WMCDecDecodeFrame( hWMCDec, 3, (U16_WMC *)pnStreamReadyForOutput, pnNumberOfSamples);
				wOutputStreamCount--; 
			}
			
			if (*pnStreamReadyForOutput != 0xff)
                return err;
            else
                return WMCDec_DecodeComplete;

        }

    }
    while( 1 );

#else

	err =  WMCDecGetAndDecode (hWMCDec, (U32_WMC*) pnStreamReadyForOutput, (U32_WMC*) pnNumberOfSamples);
	if (*pnStreamReadyForOutput != 0xff)
        return err;
    else
        return WMCDec_DecodeComplete;
	
	
#endif
    return( err );
}

/*******************************************************************************************************************************************/
tWMCDecStatus WMCDecSetVideoOutputFormat (HWMCDECODER hWMCDec, tVideoFormat_WMC tVideoOutputFormat)
{

    tWMCDecStatus Status = WMCDec_Succeeded;
    U16_WMC i=0;
    WMFDecoderEx *pDecoder = NULL_WMC;

    if( NULL_WMC == hWMCDec )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(hWMCDec);


	do
    {
        if (tVideoOutputFormat != IYUV_WMV    &&
            tVideoOutputFormat != I420_WMV    &&
            tVideoOutputFormat != YUY2_WMV    &&
            tVideoOutputFormat != UYVY_WMV    &&
            tVideoOutputFormat != YVYU_WMV    &&
            tVideoOutputFormat != RGB24_WMV   &&
            tVideoOutputFormat != RGB555_WMV  &&
            tVideoOutputFormat != RGB565_WMV  &&
            tVideoOutputFormat != RGB32_WMV   &&
            tVideoOutputFormat != YVU9_WMV    &&
            tVideoOutputFormat != RGB8_WMV    &&
			tVideoOutputFormat != IGNORE_VIDEO)
        {
            Status = WMVDec_UnSupportedOutputFormat;
            break;
        }

        for (i=0; i< pDecoder->tHeaderInfo.wNoOfVideoStreams; i++)
        {
            pDecoder->tVideoStreamInfo[i]->tOutVideoFormat = tVideoOutputFormat;
			if(
                pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_WMV2 ||
                pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_WMV1 ||
                pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_WMS2 ||
                pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_WMS1 ||
                pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_M4S2 ||
                pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MP4S ||
                pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MP43 ||
                pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MP42 ||
                pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MPG4 )
            {

                pDecoder->tVideoStreamInfo[i]->bIsDecodable = TRUE_WMC;
                switch (tVideoOutputFormat)
                {
                case IYUV_WMV:
                    pDecoder->tVideoStreamInfo[i]->biCompressionOut = FOURCC_IYUV;
                    pDecoder->tVideoStreamInfo[i]->biBitCountOut = 12;
                    break;
                
                case I420_WMV:
                    pDecoder->tVideoStreamInfo[i]->biCompressionOut = FOURCC_I420;
                    pDecoder->tVideoStreamInfo[i]->biBitCountOut = 12;
                    break;

                case YUY2_WMV:
                    pDecoder->tVideoStreamInfo[i]->biCompressionOut = FOURCC_YUY2;
                    pDecoder->tVideoStreamInfo[i]->biBitCountOut = 16;
                    break;
                
                case UYVY_WMV:
                    pDecoder->tVideoStreamInfo[i]->biCompressionOut = FOURCC_UYVY;
                    pDecoder->tVideoStreamInfo[i]->biBitCountOut = 16;
                    break;
                
                case YVYU_WMV:
                    pDecoder->tVideoStreamInfo[i]->biCompressionOut = FOURCC_YVYU;
                    pDecoder->tVideoStreamInfo[i]->biBitCountOut = 16;
                    break;
                
                case RGB24_WMV:
                    pDecoder->tVideoStreamInfo[i]->biCompressionOut = FOURCC_BI_RGB;
                    pDecoder->tVideoStreamInfo[i]->biBitCountOut = 24;
                    break;
                
                case RGB555_WMV:
                    pDecoder->tVideoStreamInfo[i]->biCompressionOut = FOURCC_BI_RGB;
                    pDecoder->tVideoStreamInfo[i]->biBitCountOut = 16;
                    break;
                
                case RGB565_WMV:
                    pDecoder->tVideoStreamInfo[i]->biCompressionOut = FOURCC_BI_BITFIELDS;
                    pDecoder->tVideoStreamInfo[i]->biBitCountOut = 16;
                    break;
                
                case RGB32_WMV:
                    pDecoder->tVideoStreamInfo[i]->biCompressionOut = FOURCC_BI_RGB;
                    pDecoder->tVideoStreamInfo[i]->biBitCountOut = 32;
                    break;

                case YVU9_WMV:
                    pDecoder->tVideoStreamInfo[i]->biCompressionOut = FOURCC_YVU9;
                    pDecoder->tVideoStreamInfo[i]->biBitCountOut = 9;
                    break;

                case RGB8_WMV:
                    pDecoder->tVideoStreamInfo[i]->biCompressionOut = FOURCC_BI_RGB;
                    pDecoder->tVideoStreamInfo[i]->biBitCountOut = 8;
                    break;
                case IGNORE_VIDEO:
                    pDecoder->tVideoStreamInfo[i]->biCompressionOut = pDecoder->tVideoStreamInfo[i]->biCompression;
                    pDecoder->tVideoStreamInfo[i]->biBitCountOut = pDecoder->tVideoStreamInfo[i]->biBitCount;
					pDecoder->tVideoStreamInfo[i]->bTobeDecoded = FALSE_WMC;
                    break;
                default:
                    return WMVDec_UnSupportedOutputFormat;

                }
                pDecoder->tVideoStreamInfo[i]->biSizeImageOut = (pDecoder->tVideoStreamInfo[i]->biWidth)*(pDecoder->tVideoStreamInfo[i]->biHeight)*(pDecoder->tVideoStreamInfo[i]->biBitCountOut)/8;

            }
///////////////////////////////////////////////////
#ifndef __NO_SCREEN__
			else if(pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MSS1 ||
					pDecoder->tVideoStreamInfo[i]->biCompression == FOURCC_MSS2)
			{
                LPBITMAPINFOHEADER    lpbiSrc = NULL_WMC;
                BITMAPINFOHEADER      BitmapInfo;  

                memset(&BitmapInfo,0,sizeof(BITMAPINFOHEADER));

                pDecoder->tVideoStreamInfo[i]->bIsDecodable = TRUE_WMC;
                switch (tVideoOutputFormat)
                {
                case RGB24_WMV:
                    pDecoder->tVideoStreamInfo[i]->biCompressionOut = FOURCC_BI_RGB;
                    pDecoder->tVideoStreamInfo[i]->biBitCountOut = 24;
                    break;
                
                case RGB555_WMV:
                    pDecoder->tVideoStreamInfo[i]->biCompressionOut = FOURCC_BI_RGB;
                    pDecoder->tVideoStreamInfo[i]->biBitCountOut = 16;
                    break;
                
                case RGB565_WMV:
                    pDecoder->tVideoStreamInfo[i]->biCompressionOut = FOURCC_BI_BITFIELDS;
                    pDecoder->tVideoStreamInfo[i]->biBitCountOut = 16;
                    break;
                
                case RGB32_WMV:
                    pDecoder->tVideoStreamInfo[i]->biCompressionOut = FOURCC_BI_RGB;
                    pDecoder->tVideoStreamInfo[i]->biBitCountOut = 32;
                    break;

                case RGB8_WMV:
                    pDecoder->tVideoStreamInfo[i]->biCompressionOut = FOURCC_BI_RGB;
                    pDecoder->tVideoStreamInfo[i]->biBitCountOut = 8;
                    break;
                case IGNORE_VIDEO:
                    pDecoder->tVideoStreamInfo[i]->biCompressionOut = pDecoder->tVideoStreamInfo[i]->biCompression;
                    pDecoder->tVideoStreamInfo[i]->biBitCountOut = pDecoder->tVideoStreamInfo[i]->biBitCount;
					pDecoder->tVideoStreamInfo[i]->bTobeDecoded = FALSE_WMC;
                    break;
                default:
                    return WMVDec_UnSupportedOutputFormat;

                }
                pDecoder->tVideoStreamInfo[i]->biSizeImageOut = (pDecoder->tVideoStreamInfo[i]->biWidth)*(pDecoder->tVideoStreamInfo[i]->biHeight)*(pDecoder->tVideoStreamInfo[i]->biBitCountOut)/8;

/*                BitmapInfo.biBitCount = pDecoder->tVideoStreamInfo[i]->biBitCountOut;
                BitmapInfo.biCompression  = pDecoder->tVideoStreamInfo[i]->biCompressionOut;
                BitmapInfo.biHeight  = pDecoder->tVideoStreamInfo[i]->biHeight;
                BitmapInfo.biWidth  = pDecoder->tVideoStreamInfo[i]->biWidth;
                BitmapInfo.biSizeImage = pDecoder->tVideoStreamInfo[i]->biSizeImageOut;
                BitmapInfo.biSize  = sizeof (BITMAPINFOHEADER);


                lpbiSrc = &BitmapInfo;
                hr = WMScreenDecoderInit( pDecoder->tVideoStreamInfo[i]->pVDec, 
                    pDecoder->tVideoStreamInfo[i]->bAdditionalInfo,
                    pDecoder->tVideoStreamInfo[i]->biSize  - sizeof (BITMAPINFOHEADER),
                    lpbiSrc);

                if (FAILED(hr))
                {
                    pDecoder->tVideoStreamInfo[i]->biBitCountOut = pDecoder->tVideoStreamInfo[i]->biBitCount;
                    pDecoder->tVideoStreamInfo[i]->biCompressionOut = pDecoder->tVideoStreamInfo[i]->biCompression;
                    pDecoder->tVideoStreamInfo[i]->biSizeImageOut = pDecoder->tVideoStreamInfo[i]->biSizeImage;

                    pDecoder->tVideoStreamInfo[i]->bIsDecodable = FALSE_WMC;
                    pDecoder->tVideoStreamInfo[i]->bTobeDecoded = FALSE_WMC;
                    return WMVDec_Failed;
                }

                pDecoder->tVideoStreamInfo[i]->pSCInBuffer = wmvalloc(pDecoder->tVideoStreamInfo[i]->biSizeImageOut);
                pDecoder->tVideoStreamInfo[i]->pSCOutBuffer = wmvalloc(pDecoder->tVideoStreamInfo[i]->biSizeImageOut);

                if(pDecoder->tVideoStreamInfo[i]->pSCInBuffer == NULL_WMC || pDecoder->tVideoStreamInfo[i]->pSCOutBuffer == NULL_WMC)
                {
                    return WMCDec_BadMemory;
                
                }

  */              


            }
#endif            
//////////////////////////////////////////////////								

            
            
            else
            {
                
                
                pDecoder->tVideoStreamInfo[i]->biBitCountOut = pDecoder->tVideoStreamInfo[i]->biBitCount;
                pDecoder->tVideoStreamInfo[i]->biCompressionOut = pDecoder->tVideoStreamInfo[i]->biCompression;
                pDecoder->tVideoStreamInfo[i]->biSizeImageOut = pDecoder->tVideoStreamInfo[i]->biSizeImage;

                pDecoder->tVideoStreamInfo[i]->bIsDecodable = FALSE_WMC;
                pDecoder->tVideoStreamInfo[i]->bTobeDecoded = FALSE_WMC;
            }
        
        }

 	}  while (0);
  
    return Status;

}


/****************************************************************************************************************/
tWMCDecStatus WMCDecSeek (HWMCDECODER hWMCDec, U64_WMC u64TimeRequest, U64_WMC* pu64TimeReturn)
{

	U64_WMC cbPacketOffset =0;
    U8_WMC i=0, j=0;
	tWMCDecStatus rc = WMCDec_Succeeded;
    U32_WMC dwToIndexEntry =0;
    WMCINDEXENTRIES* pTempIndexEntry = NULL_WMC;
    U32_WMC dwPacketToGo =0;
    U8_WMC bAudioVideo =0;
    U32_WMC cbVideoSize =0;
    U32_WMC dwVideoTimeStamp=0;
    U16_WMC cbAudioOut =0;
    U32_WMC dwAudioTimeStamp =0;
    U8_WMC* pucVidBufTemp = NULL_WMC;
    U32_WMC dwMinimumPacketToGo = 0xffffffff;
    tMediaType_WMC MediaType;
	U32_WMC nStreamReadyForOutput;
	U32_WMC nNumberOfSamples;
	I16_WMC OutBuff[4096*4];
    U32_WMC nNumSamplesReturn =0;
    I64_WMC tPresentationTime =0;
    U8_WMC *pu8VideoOutBuffer = NULL_WMC;
    U32_WMC u32VideoOutBufferSize =0;
	U32_WMC u32OutDataSize =0;
	Bool_WMC bIsKeyFrame;
	U64_WMC u64LocalTimeRequest=0;
	Bool_WMC bVideoThere = FALSE_WMC;
	U64_WMC u64MyTimeReturn =0;

    PACKET_PARSE_INFO_EX ParseInfoEx;
	PAYLOAD_MAP_ENTRY_EX Payload;
	U32_WMC iPayload =0;
	Bool_WMC bDone = FALSE_WMC;
	Bool_WMC bHasIndexAndOutput = FALSE_WMC;
	Bool_WMC bAudioToBeDecoded = FALSE_WMC;
	Bool_WMC bVideoToBeDecoded = FALSE_WMC;
	U16_WMC wIdToGetOutput =0;
	U16_WMC wVideoIdTobedecoded =0;
	U16_WMC wAudioIdTobeOutput =0;
	U16_WMC wVideoIdTobeOutput =0;
	Bool_WMC bFirst = FALSE_WMC;
	U64_WMC u64LastPresTime=0;


 
    WMFDecoderEx* pDecoder = (WMFDecoderEx*) hWMCDec;
    if (pDecoder == NULL_WMC || pu64TimeReturn == NULL_WMC)
        return WMCDec_InValidArguments;

	memset(&ParseInfoEx, 0, sizeof (PACKET_PARSE_INFO_EX));
	memset(&Payload, 0, sizeof (PAYLOAD_MAP_ENTRY_EX));



	if (0==pDecoder->tPlannedOutputInfo.wTotalOutput)
        return WMCDec_InValidArguments;

	for (i=0; i < pDecoder->tPlannedOutputInfo.wTotalOutput; i++)
	{
		switch(pDecoder->tPlannedOutputInfo.tPlannedId[i].tMediaType)
		{
        case Audio_WMC:
			if (pDecoder->tAudioStreamInfo[pDecoder->tPlannedOutputInfo.tPlannedId[i].wStreamIndex]->bTobeDecoded)
			{
				bAudioToBeDecoded = TRUE_WMC;
//				wAudioIdTobedecoded = pDecoder->tAudioStreamInfo[pDecoder->tPlannedOutputInfo.tPlannedId[i].wStreamIndex]->wStreamId;
			}
			wAudioIdTobeOutput = pDecoder->tAudioStreamInfo[pDecoder->tPlannedOutputInfo.tPlannedId[i].wStreamIndex]->wStreamId;
			break;

        case Video_WMC:
			if (pDecoder->tVideoStreamInfo[pDecoder->tPlannedOutputInfo.tPlannedId[i].wStreamIndex]->bTobeDecoded)
			{
				wVideoIdTobedecoded = pDecoder->tVideoStreamInfo[pDecoder->tPlannedOutputInfo.tPlannedId[i].wStreamIndex]->wStreamId;
				bVideoToBeDecoded = TRUE_WMC;
			}
			wVideoIdTobeOutput = pDecoder->tVideoStreamInfo[pDecoder->tPlannedOutputInfo.tPlannedId[i].wStreamIndex]->wStreamId;
			break;
		}
	
	
	}



    dwMinimumPacketToGo = (U32_WMC)pDecoder->tHeaderInfo.cbLastPacketOffset;

	*pu64TimeReturn = 0;
	
	u64TimeRequest= u64TimeRequest + (U64_WMC)pDecoder->tHeaderInfo.msPreroll ;

	if ((u64TimeRequest < (U64_WMC)pDecoder->tHeaderInfo.msPreroll ) || (u64TimeRequest >(U64_WMC)pDecoder->tHeaderInfo.msDuration))
		return WMCDec_InValidArguments;

    if (pDecoder->cTotalIndexs >0)
    {
        for(i=0; i< pDecoder->cTotalIndexs ; i++)
        {
            rc = WMCDecGetMediaType (hWMCDec, (U16_WMC) pDecoder->tIndexInfo[i].nStreamId, &MediaType);

            if (WMCDec_Succeeded !=rc)
                return rc;

            switch(MediaType)
            {
            case Audio_WMC:
                for(j=0; j<pDecoder->tHeaderInfo.wNoOfAudioStreams; j++)
                {
                    if( pDecoder->tIndexInfo[i].nStreamId == pDecoder->tAudioStreamInfo[j]->wStreamId)
                    {
                        if (pDecoder->tAudioStreamInfo[j]->bWantOutput == TRUE_WMC )
                        {
							u64LocalTimeRequest = u64TimeRequest /*+ (U64_WMC)pDecoder->tIndexInfo[i].time_deltaMs*999/1000*/;
							dwToIndexEntry = (U32_WMC)(u64LocalTimeRequest/pDecoder->tIndexInfo[i].time_deltaMs);
                            if (dwToIndexEntry > pDecoder->tIndexInfo[i].num_entries )
                                return WMCDec_InValidArguments;
                            pTempIndexEntry = pDecoder->tIndexInfo[i].pIndexEntries;
                            pTempIndexEntry+=dwToIndexEntry;
                            dwPacketToGo = pTempIndexEntry->dwPacket;
                            if (dwPacketToGo > pDecoder->tHeaderInfo.cPackets)
                                return WMCDec_InValidArguments;
                            if (dwMinimumPacketToGo > dwPacketToGo)
                            {
                                dwMinimumPacketToGo = dwPacketToGo;
                                pDecoder->tHeaderInfo.cbCurrentPacketOffset = (U64_WMC)pDecoder->tHeaderInfo.cbHeader  + ( (U64_WMC)dwPacketToGo * (U64_WMC)pDecoder->tHeaderInfo.cbPacketSize);
                                pDecoder->tHeaderInfo.cbNextPacketOffset  = (U64_WMC)pDecoder->tHeaderInfo.cbHeader  + ( (U64_WMC)(dwPacketToGo) * (U64_WMC)pDecoder->tHeaderInfo.cbPacketSize );
                            }
                             // To go to precise point
                            pDecoder->tAudioStreamInfo[j]->dwAudioBufCurOffset = 0;
	                        pDecoder->tAudioStreamInfo[j]->cbNbFramesAudBuf = 0;
                            pDecoder->tAudioStreamInfo[j]->dwAudioBufDecoded = 0;
	                        pDecoder->tAudioStreamInfo[j]->bBlockStart = 0;
	                        pDecoder->tAudioStreamInfo[j]->dwBlockLeft = 0;
	                        pDecoder->tAudioStreamInfo[j]->dwPayloadLeft = 0;
	                        pDecoder->tAudioStreamInfo[j]->dwAudPayloadPresTime = 0;
                            pDecoder->tAudioStreamInfo[j]->dwAudioTimeStamp = 0.0;
                            pDecoder->tAudioStreamInfo[j]->bFirstTime = FALSE_WMC;
							bHasIndexAndOutput = TRUE_WMC;
                        }
                    }
            
                }
                break;
            case Video_WMC:
                for(j=0; j<pDecoder->tHeaderInfo.wNoOfVideoStreams; j++)
                {
                    if(pDecoder->tIndexInfo[i].nStreamId == pDecoder->tVideoStreamInfo[j]->wStreamId)
                    {
                        if (pDecoder->tVideoStreamInfo[j]->bWantOutput == TRUE_WMC )
                        {
							WMCDecGetPreviousFrameTime (hWMCDec, pDecoder->tVideoStreamInfo[j]->wStreamId, u64TimeRequest -  (U64_WMC)pDecoder->tHeaderInfo.msPreroll , &u64MyTimeReturn);

							u64LocalTimeRequest = u64TimeRequest/* + (U64_WMC)pDecoder->tIndexInfo[i].time_deltaMs*999/1000*/;

							dwToIndexEntry = (U32_WMC)(u64LocalTimeRequest/pDecoder->tIndexInfo[i].time_deltaMs);
                            if (dwToIndexEntry > pDecoder->tIndexInfo[i].num_entries )
                                return WMCDec_InValidArguments;
                            pTempIndexEntry = pDecoder->tIndexInfo[i].pIndexEntries;
                            pTempIndexEntry+=dwToIndexEntry;
                            dwPacketToGo = pTempIndexEntry->dwPacket;
                            if (dwPacketToGo > pDecoder->tHeaderInfo.cPackets)
                                return WMCDec_InValidArguments;
                            if (dwMinimumPacketToGo > dwPacketToGo)
                            {
                                dwMinimumPacketToGo = dwPacketToGo;
								if (dwMinimumPacketToGo >0)
									dwMinimumPacketToGo -=1;
                                pDecoder->tHeaderInfo.cbCurrentPacketOffset = (U64_WMC)pDecoder->tHeaderInfo.cbHeader  + ( (U64_WMC)dwPacketToGo * (U64_WMC)pDecoder->tHeaderInfo.cbPacketSize);
                                pDecoder->tHeaderInfo.cbNextPacketOffset  = (U64_WMC)pDecoder->tHeaderInfo.cbHeader  + ( (U64_WMC)(dwPacketToGo) * (U64_WMC)pDecoder->tHeaderInfo.cbPacketSize );
                            }
                             // To go to precise point
                            pDecoder->tVideoStreamInfo[j]->bFirst =  FALSE_WMC;
                            pDecoder->tVideoStreamInfo[j]->dwVideoBufCurOffset = 0;
	                        pDecoder->tVideoStreamInfo[j]->bBlockStart = 0;
	                        pDecoder->tVideoStreamInfo[j]->dwBlockLeft = 0;
	                        pDecoder->tVideoStreamInfo[j]->dwPayloadLeft = 0;
	                        pDecoder->tVideoStreamInfo[j]->cbNbFramesVidBuf = 0;
                            pDecoder->tVideoStreamInfo[j]->dwVideoBufDecoded = 0;
                            pDecoder->tVideoStreamInfo[j]->dwVideoTimeStamp = 0;
                            pDecoder->tVideoStreamInfo[j]->dwNbFrames = 0;
	                        pDecoder->tVideoStreamInfo[j]->cbUsed = 0;
                            pDecoder->tVideoStreamInfo[j]->dwFrameSize = 0; 
	                        pDecoder->tVideoStreamInfo[j]->cbFrame = 0;
							bVideoThere = TRUE_WMC;
							bHasIndexAndOutput = TRUE_WMC;

                        }
                    }
            
                }
                break;
            case Binary_WMC:
                for(j=0; j<pDecoder->tHeaderInfo.wNoOfBinaryStreams; j++)
                {
                    if(pDecoder->tIndexInfo[i].nStreamId == pDecoder->tBinaryStreamInfo[j]->wStreamId)
                    {
                        if (pDecoder->tBinaryStreamInfo[j]->bWantOutput == TRUE_WMC )
                        {
							u64LocalTimeRequest = u64TimeRequest /*+ (U64_WMC)pDecoder->tIndexInfo[i].time_deltaMs*999/1000*/;
							dwToIndexEntry = (U32_WMC)(u64LocalTimeRequest/pDecoder->tIndexInfo[i].time_deltaMs);
                            if (dwToIndexEntry > pDecoder->tIndexInfo[i].num_entries )
                                return WMCDec_InValidArguments;
                            pTempIndexEntry = pDecoder->tIndexInfo[i].pIndexEntries;
                            pTempIndexEntry+=dwToIndexEntry;
                            dwPacketToGo = pTempIndexEntry->dwPacket;
                            if (dwPacketToGo > pDecoder->tHeaderInfo.cPackets)
                                return WMCDec_InValidArguments;
                            if (dwMinimumPacketToGo > dwPacketToGo)
                            {
                                dwMinimumPacketToGo = dwPacketToGo;
                                pDecoder->tHeaderInfo.cbCurrentPacketOffset = (U64_WMC)pDecoder->tHeaderInfo.cbHeader  + ( (U64_WMC)dwPacketToGo * (U64_WMC)pDecoder->tHeaderInfo.cbPacketSize);
                                pDecoder->tHeaderInfo.cbNextPacketOffset  = (U64_WMC)pDecoder->tHeaderInfo.cbHeader  + ( (U64_WMC)(dwPacketToGo) * (U64_WMC)pDecoder->tHeaderInfo.cbPacketSize );
                            }
                             // To go to precise point
                            pDecoder->tBinaryStreamInfo[j]->dwBinaryBufCurOffset = 0;
                            pDecoder->tBinaryStreamInfo[j]->dwBinaryTimeStamp = 0;
	                        pDecoder->tBinaryStreamInfo[j]->cbNbFramesBinBuf = 0;
	                        pDecoder->tBinaryStreamInfo[j]->dwBlockLeft = 0;
	                        pDecoder->tBinaryStreamInfo[j]->dwPayloadLeft = 0;
   	                        pDecoder->tBinaryStreamInfo[j]->cbUsed = 0;
                            pDecoder->tBinaryStreamInfo[j]->dwFrameSize = 0; 
	                        pDecoder->tBinaryStreamInfo[j]->cbFrame = 0;
                            pDecoder->tBinaryStreamInfo[j]->dwNbFrames = 0;
                            pDecoder->tBinaryStreamInfo[j]->dwBinaryBufDecoded = 0;
							bHasIndexAndOutput = TRUE_WMC;
                        }
                    }
                }
                break;
            default:
                return WMCDec_InValidArguments;

            }

        } 
        
    }
    
	
	if (FALSE_WMC == bHasIndexAndOutput)
    {
        u64MyTimeReturn = u64TimeRequest - pDecoder->tHeaderInfo.msPreroll;
        rc = WMFDecTimeToOffset (hWMCDec, (U32_WMC)u64TimeRequest - pDecoder->tHeaderInfo.msPreroll, &cbPacketOffset);

	    if (rc == 0)
        {
			do
			
			{
			//	cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbHeader  + (dwPacketToGo * pDecoder->tHeaderInfo.cbPacketSize);
				rc = WMCDecParseVirtualPacketHeader(hWMCDec, (U32_WMC)cbPacketOffset, &ParseInfoEx);
				if (rc != WMCDec_Succeeded)
					return rc;

				for (iPayload = 0; iPayload < ParseInfoEx.cPayloads; iPayload++)
				{
        
					rc = WMCDecParseVirtualPayloadHeader(hWMCDec, (U32_WMC)cbPacketOffset, &ParseInfoEx, &Payload);
					if (rc != WMCDec_Succeeded)
						return rc;

					if (bVideoToBeDecoded)
					{
                        // Find out the start of key frame before this  
	
						if (Payload.bIsKeyFrame && (Payload.cbObjectOffset ==0)&&(Payload.msObjectPres < u64TimeRequest)&&(wVideoIdTobedecoded == (U16_WMC)Payload.bStreamId))
						{
							wIdToGetOutput = (U16_WMC)Payload.bStreamId;
							bDone = TRUE_WMC;
							break;
						}
					}
					else if (
						((Payload.cbRepData == 8) || (Payload.cbRepData == 1))&&
						(((wVideoIdTobeOutput == (U16_WMC)Payload.bStreamId)&&(Payload.cbObjectOffset ==0))||
						(wAudioIdTobeOutput == (U16_WMC)Payload.bStreamId))		
						) // Any valid payload will do
				
					
					
					{
						if ((Payload.msObjectPres > u64TimeRequest) && (cbPacketOffset > pDecoder->tHeaderInfo.cbHeader))
							break;//cbPacketOffset -= pDecoder->tHeaderInfo.cbPacketSize;
						else
						{
							bDone = TRUE_WMC;
							wIdToGetOutput = (U16_WMC)Payload.bStreamId;

						}

						break;
					}

				}
				if ((cbPacketOffset > pDecoder->tHeaderInfo.cbHeader) &&(bDone == FALSE_WMC))
					cbPacketOffset -= pDecoder->tHeaderInfo.cbPacketSize;

			}while((bDone == FALSE_WMC) && (cbPacketOffset > pDecoder->tHeaderInfo.cbHeader));

            
           pDecoder->tHeaderInfo.cbCurrentPacketOffset = cbPacketOffset;
           pDecoder->tHeaderInfo.cbNextPacketOffset =  cbPacketOffset;
        }
	    else
		    return WMCDec_InValidArguments;
		

		if ((bVideoToBeDecoded == FALSE_WMC)&&(bAudioToBeDecoded == FALSE_WMC))
		{

			if (cbPacketOffset > pDecoder->tHeaderInfo.cbHeader)
				cbPacketOffset -=pDecoder->tHeaderInfo.cbPacketSize;
			bDone = FALSE_WMC;
			bFirst = FALSE_WMC;
			
			do
			
			{
				
				rc = WMCDecParseVirtualPacketHeader(hWMCDec, (U32_WMC)cbPacketOffset, &ParseInfoEx);
				if (rc != WMCDec_Succeeded)
					return rc;


				for (iPayload = 0; iPayload < ParseInfoEx.cPayloads; iPayload++)
				{
        
					rc = WMCDecParseVirtualPayloadHeader(hWMCDec, (U32_WMC)cbPacketOffset, &ParseInfoEx, &Payload);
					if (rc != WMCDec_Succeeded)
						return rc;

					if ((wIdToGetOutput == Payload.bStreamId))
					{
						if (bFirst == FALSE_WMC)
						{
							u64LastPresTime = (U64_WMC) Payload.msObjectPres;
							bFirst = TRUE_WMC;
						}
						
						if (Payload.msObjectPres >= u64TimeRequest)
						{
							u64MyTimeReturn = u64LastPresTime - (U64_WMC)pDecoder->tHeaderInfo.msPreroll;
							bDone = TRUE_WMC;
							break;
						}
						else
						{
							u64LastPresTime = (U64_WMC) Payload.msObjectPres;
							continue;
						}
					}

				}
				cbPacketOffset +=pDecoder->tHeaderInfo.cbPacketSize;
			}while((bDone == FALSE_WMC) && (cbPacketOffset < (pDecoder->tHeaderInfo.cbHeader +pDecoder->tHeaderInfo.cbPacketSize*pDecoder->tHeaderInfo.cPackets)));
		}
    
    }

    for(j=0; j<pDecoder->tHeaderInfo.wNoOfAudioStreams; j++)
    {
#ifndef _ASFPARSE_ONLY_
        if ((pDecoder->tAudioStreamInfo[j]->bWantOutput == TRUE_WMC)
			&&(pDecoder->tAudioStreamInfo[j]->bIsDecodable == TRUE_WMC)
			&&(pDecoder->tAudioStreamInfo[j]->nVersion >0 && pDecoder->tAudioStreamInfo[j]->nVersion <4)
			&&(pDecoder->tAudioStreamInfo[j]->hMSA !=NULL_WMC) 
			)
        {
			WMARawDecReset (pDecoder->tAudioStreamInfo[j]->hMSA);
//			WMARawDecStatus(pDecoder->tAudioStreamInfo[j]->hMSA);
		}
#endif        
		pDecoder->tAudioStreamInfo[j]->dwAudioBufCurOffset = 0;
	    pDecoder->tAudioStreamInfo[j]->cbNbFramesAudBuf = 0;
        pDecoder->tAudioStreamInfo[j]->dwAudioBufDecoded = 0;
	    pDecoder->tAudioStreamInfo[j]->bBlockStart = 0;
	    pDecoder->tAudioStreamInfo[j]->dwBlockLeft = 0;
	    pDecoder->tAudioStreamInfo[j]->dwPayloadLeft = 0;
	    pDecoder->tAudioStreamInfo[j]->dwAudPayloadPresTime = 0;
        pDecoder->tAudioStreamInfo[j]->dwAudioTimeStamp = 0.0;
        pDecoder->tAudioStreamInfo[j]->wmar = WMA_S_NO_MORE_FRAME;
		pDecoder->tAudioStreamInfo[j]->bFirstTime = FALSE_WMC;
#ifdef WMC_NO_BUFFER_MODE
		pDecoder->tAudioStreamInfo[j]->cbPacketOffset = pDecoder->tHeaderInfo.cbPacketOffset;
		pDecoder->tAudioStreamInfo[j]->cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbFirstPacketOffset;
		pDecoder->tAudioStreamInfo[j]->cbNextPacketOffset = pDecoder->tHeaderInfo.cbNextPacketOffset;
		pDecoder->tAudioStreamInfo[j]->parse_state = csWMCNewAsfPacket;

#endif

     }

    for(j=0; j<pDecoder->tHeaderInfo.wNoOfVideoStreams; j++)
    {
        pDecoder->tVideoStreamInfo[j]->bFirst =  FALSE_WMC;
        pDecoder->tVideoStreamInfo[j]->dwVideoBufCurOffset = 0;
	    pDecoder->tVideoStreamInfo[j]->bBlockStart = 0;
	    pDecoder->tVideoStreamInfo[j]->dwBlockLeft = 0;
	    pDecoder->tVideoStreamInfo[j]->dwPayloadLeft = 0;
	    pDecoder->tVideoStreamInfo[j]->cbNbFramesVidBuf = 0;
        pDecoder->tVideoStreamInfo[j]->dwVideoBufDecoded = 0;
        pDecoder->tVideoStreamInfo[j]->dwVideoTimeStamp = 0;
        pDecoder->tVideoStreamInfo[j]->dwNbFrames = 0;
	    pDecoder->tVideoStreamInfo[j]->cbUsed = 0;
        pDecoder->tVideoStreamInfo[j]->dwFrameSize = 0; 
	    pDecoder->tVideoStreamInfo[j]->cbFrame = 0;
		pDecoder->tVideoStreamInfo[j]->pStoreFrameStartPointer = NULL_WMC;
		pDecoder->tVideoStreamInfo[j]->pStoreNextFrameStartPointer = NULL_WMC;
		pDecoder->tVideoStreamInfo[j]->bHasGivenAnyOutput = FALSE_WMC;
		pDecoder->tVideoStreamInfo[j]->bNowStopReadingAndDecoding = FALSE_WMC;
#ifdef WMC_NO_BUFFER_MODE
		pDecoder->tVideoStreamInfo[j]->cbPacketOffset = pDecoder->tHeaderInfo.cbPacketOffset;
		pDecoder->tVideoStreamInfo[j]->cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbFirstPacketOffset;
		pDecoder->tVideoStreamInfo[j]->cbNextPacketOffset = pDecoder->tHeaderInfo.cbNextPacketOffset;
		pDecoder->tVideoStreamInfo[j]->parse_state = csWMCNewAsfPacket;
        pDecoder->tVideoStreamInfo[j]->dwNextVideoTimeStamp = 0;

#endif


    }

    for(j=0; j<pDecoder->tHeaderInfo.wNoOfBinaryStreams; j++)
    {
        pDecoder->tBinaryStreamInfo[j]->dwBinaryBufCurOffset = 0;
        pDecoder->tBinaryStreamInfo[j]->dwBinaryTimeStamp = 0;
	    pDecoder->tBinaryStreamInfo[j]->cbNbFramesBinBuf = 0;
	    pDecoder->tBinaryStreamInfo[j]->dwBlockLeft = 0;
	    pDecoder->tBinaryStreamInfo[j]->dwPayloadLeft = 0;
   	    pDecoder->tBinaryStreamInfo[j]->cbUsed = 0;
        pDecoder->tBinaryStreamInfo[j]->dwFrameSize = 0; 
	    pDecoder->tBinaryStreamInfo[j]->cbFrame = 0;
        pDecoder->tBinaryStreamInfo[j]->dwNbFrames = 0;
        pDecoder->tBinaryStreamInfo[j]->dwBinaryBufDecoded = 0;
		pDecoder->tBinaryStreamInfo[j]->bHasGivenAnyOutput = FALSE_WMC;
		pDecoder->tBinaryStreamInfo[j]->bNowStopReadingAndDecoding = FALSE_WMC;
#ifdef WMC_NO_BUFFER_MODE
		pDecoder->tBinaryStreamInfo[j]->cbPacketOffset = pDecoder->tHeaderInfo.cbPacketOffset;
		pDecoder->tBinaryStreamInfo[j]->cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbFirstPacketOffset;
		pDecoder->tBinaryStreamInfo[j]->cbNextPacketOffset = pDecoder->tHeaderInfo.cbNextPacketOffset;
		pDecoder->tBinaryStreamInfo[j]->parse_state = csWMCNewAsfPacket;
        pDecoder->tBinaryStreamInfo[j]->dwNextBinaryTimeStamp = 0;

#endif
    }


    pDecoder->parse_state = csWMCNewAsfPacket;

	if (u64TimeRequest == pDecoder->tHeaderInfo.msPreroll)
	{
		*pu64TimeReturn =0;
		return rc;

	}


	pDecoder->u64SeekTimeRequest = u64TimeRequest;
	pDecoder->bInSeekState = TRUE;

	do
	{
		rc = WMCDecDecodeData (hWMCDec, &nStreamReadyForOutput, &nNumberOfSamples, (I32_WMC)0);
    
		if (nNumberOfSamples >0)
		{
			cbAudioOut = 0;
			for (i=0; i<pDecoder->tHeaderInfo.wNoOfStreams; i++ )
			{
				if (pDecoder->pStreamIdnMediaType[i].wStreamId == (U16_WMC)nStreamReadyForOutput)
				{
            
					switch(pDecoder->pStreamIdnMediaType[i].MediaType)
					{
					case Audio_WMC:
						for (j=0; j<pDecoder->tHeaderInfo.wNoOfAudioStreams ; j++)
						{
							 if ( pDecoder->tAudioStreamInfo[j]->wStreamId == (U16_WMC)nStreamReadyForOutput)
							 {
 								do
								{
									cbAudioOut = 2048;
									rc = WMCDecGetAudioOutput (hWMCDec, (I16_WMC *)OutBuff, NULL_WMC, cbAudioOut, &nNumSamplesReturn, &tPresentationTime );
									if (nNumSamplesReturn > 0)
									{
										if ((tPresentationTime >= (I64_WMC)u64MyTimeReturn) && bVideoThere == FALSE_WMC)
										{
											pDecoder->bInSeekState = FALSE;
											*pu64TimeReturn = tPresentationTime;
										//	break;
										}
									
									}
								}while(nNumSamplesReturn >0);

								break;
							 }
						}
						break;

					case Video_WMC:
						for (j=0; j<pDecoder->tHeaderInfo.wNoOfVideoStreams; j++)
						{
							 if ( pDecoder->tVideoStreamInfo[j]->wStreamId== (U16_WMC)nStreamReadyForOutput)
							 {
                         
        						do
								{
									 rc = WMCDecGetVideoOutput (hWMCDec, NULL_WMC /*pu8VideoOutBuffer*/, 0/*u32VideoOutBufferSize*/, &u32OutDataSize, &tPresentationTime, &bIsKeyFrame, WMC_DispRotate0);
									if ((tPresentationTime >= (I64_WMC)u64MyTimeReturn))
									{
										pDecoder->bInSeekState = FALSE_WMC;
										*pu64TimeReturn = tPresentationTime;
									//	break;
									}
								}while(u32OutDataSize >0);
								break;
							 }
						}
						break;
					}
					break;
				}
			}
		}
	}while ((rc == 0) && (pDecoder->bInSeekState == TRUE));

	pDecoder->bInSeekState = FALSE;

	return rc;
}


/****************************************************************************************************************/
#ifndef __NO_SCREEN__

tWMCDecStatus WMScDecodeData (HWMCDECODER hWMCDec, U16_WMC wIndex )
{


    tWMVDecodeStatus CBStatus = WMV_Succeeded;
    U8_WMV  *pSCBuffer = NULL_WMC;
    U32_WMV uintActualBufferLength =0;
    Bool_WMV    bNotEndOfFrame = TRUE_WMV; 
    U32_WMC dwCompressedFrameSize =0;
    WMFDecoderEx *pDecoder =NULL_WMC;
    BITMAPPALETTE      BitmapInfo;  
    HRESULT hr;
    tWMCDecStatus tStatus = WMCDec_Succeeded;

    memset(&BitmapInfo,0,sizeof(BITMAPPALETTE));

   
    pDecoder = (WMFDecoderEx *)hWMCDec;

        
    do
    {
        CBStatus = WMVDecCBGetData ( (U32_WMV) hWMCDec, (U32_WMV) 0, &pSCBuffer, (U32_WMV) 0, 
                                  &uintActualBufferLength, &bNotEndOfFrame );

        if (pSCBuffer == NULL_WMC)
            return WMCDec_BadData;



        if (dwCompressedFrameSize + uintActualBufferLength <= pDecoder->tVideoStreamInfo[wIndex]->biSizeImageOut)
        {
            memcpy(pDecoder->tVideoStreamInfo[wIndex]->pSCInBuffer + dwCompressedFrameSize, pSCBuffer, uintActualBufferLength);
        }
        else
        {
            return WMCDec_BufferTooSmall;
        }
        dwCompressedFrameSize+=uintActualBufferLength;

    }while((CBStatus == WMV_Succeeded) && (bNotEndOfFrame = TRUE_WMV));

    if ((CBStatus == WMV_EndOfFrame)&&(bNotEndOfFrame == FALSE_WMV))
    {

        BitmapInfo.BitmapHdr.biBitCount = pDecoder->tVideoStreamInfo[wIndex]->biBitCountOut;
        BitmapInfo.BitmapHdr.biCompression  = pDecoder->tVideoStreamInfo[wIndex]->biCompressionOut;
        BitmapInfo.BitmapHdr.biHeight  = pDecoder->tVideoStreamInfo[wIndex]->biHeight;
        BitmapInfo.BitmapHdr.biWidth  = pDecoder->tVideoStreamInfo[wIndex]->biWidth;
        BitmapInfo.BitmapHdr.biSizeImage = pDecoder->tVideoStreamInfo[wIndex]->biSizeImageOut;
        
        if (pDecoder->tVideoStreamInfo[wIndex]->biBitCountOut ==8)
        {
            BitmapInfo.BitmapHdr.biSize  = sizeof (BITMAPINFOHEADER) + 256*3;
            memcpy(BitmapInfo.bPlaette, StandardPalette, 256*3);
        }
        else
            BitmapInfo.BitmapHdr.biSize  = sizeof (BITMAPINFOHEADER);

        pDecoder->tVideoStreamInfo[wIndex]->bScOutGiven = FALSE_WMC;

        hr = WMScreenDecoderDecode(
							    (Void_WMC*)pDecoder->tVideoStreamInfo[wIndex]->pVDec,
							    (U8_WMC *)pDecoder->tVideoStreamInfo[wIndex]->pSCInBuffer, 
							    dwCompressedFrameSize, 
							    pDecoder->tVideoStreamInfo[wIndex]->biWidth ,
							    pDecoder->tVideoStreamInfo[wIndex]->biHeight,
							    (BITMAPINFOHEADER *)&(BitmapInfo),
							    pDecoder->tVideoStreamInfo[wIndex]->pSCOutBuffer,
							    0,
							    0,
							    pDecoder->tVideoStreamInfo[wIndex]->biWidth ,
							    pDecoder->tVideoStreamInfo[wIndex]->biHeight,
							    0);


        if (FAILED (hr))
	        tStatus = WMVDec_Failed;
    }
    else
        tStatus = WMCDec_BadData;

	return tStatus;
}


tWMCDecStatus WMScGetOutData (HWMCDECODER hWMCDec, U8_WMC *pu8VideoOutBuffer, U32_WMC u32VideoOutBufferSize, U16_WMC wIndex )
{


    tWMCDecStatus tStatus = WMCDec_Succeeded;
    WMFDecoderEx *pDecoder =NULL_WMC;

    pDecoder = (WMFDecoderEx *)hWMCDec;

    if ((pu8VideoOutBuffer != NULL_WMC) && (u32VideoOutBufferSize < pDecoder->tVideoStreamInfo[wIndex]->biSizeImageOut))
        return WMCDec_InValidArguments;
    
    if (pDecoder->tVideoStreamInfo[wIndex]->bScOutGiven == TRUE_WMC)
        return WMVDec_NoMoreOutput;
    else
    {
        if (pu8VideoOutBuffer !=NULL_WMC)
			memcpy(pu8VideoOutBuffer, pDecoder->tVideoStreamInfo[wIndex]->pSCOutBuffer, pDecoder->tVideoStreamInfo[wIndex]->biSizeImageOut);
        pDecoder->tVideoStreamInfo[wIndex]->bScOutGiven = TRUE_WMC;
    }

	return tStatus;
}


#endif
/************************************************************************************************/

tWMCDecStatus WMCDecGetIFrameTime (HWMCDECODER hWMCDec, U16_WMC wStreamId, U64_WMC u64TimeRequest, U64_WMC* pu64TimeReturn, U32_WMC* pdwFirstPacketOffset, U32_WMC* pdwPacketSize, U32_WMC* pdwPackets, U64_WMC* pu64FirstPayloadPresTime, U32_WMC * pFirstPayloadOffset, U8_WMC * pFirstPayloadOID, U32_WMC * pSendTime, U64_WMC *pFirstAudioPTime, U8_WMC * pFirstAudioPayloadOID)
{

	U64_WMC cbPacketOffset =0;
    U8_WMC i=0, j=0;
	tWMCDecStatus rc = WMCDec_Succeeded;
    U32_WMC dwToIndexEntry =0;
    WMCINDEXENTRIES* pTempIndexEntry = NULL_WMC;
    U32_WMC dwPacketToGo =0;
    tMediaType_WMC MediaType;
	U32_WMC cbCurrentPacketOffset =0;
	PACKET_PARSE_INFO_EX ParseInfoEx;
	PAYLOAD_MAP_ENTRY_EX Payload;
	U32_WMC iPayload =0;
	U64_WMC u64LocalTimeRequest=0;
	Bool_WMC bFirst = FALSE_WMC;
 	Bool_WMC bFirstAudio = FALSE_WMC;

    WMFDecoderEx* pDecoder = (WMFDecoderEx*) hWMCDec;
    if (pDecoder == NULL_WMC || pu64TimeReturn == NULL_WMC)
        return WMCDec_InValidArguments;


	memset(&ParseInfoEx, 0, sizeof (PACKET_PARSE_INFO_EX));
	memset(&Payload, 0, sizeof (PAYLOAD_MAP_ENTRY_EX));

	*pu64TimeReturn = 0;
	if (pFirstAudioPTime !=NULL_WMC)
		*pFirstAudioPTime =0;
	u64TimeRequest= u64TimeRequest + (U64_WMC)pDecoder->tHeaderInfo.msPreroll ;
	
	if (pDecoder->cTotalIndexs >0)
    {
		for(i=0; i< pDecoder->cTotalIndexs ; i++)
		{
			if (pDecoder->tIndexInfo[i].nStreamId == wStreamId)
			{
				rc = WMCDecGetMediaType (hWMCDec, (U16_WMC) wStreamId, &MediaType);
				if (WMCDec_Succeeded !=rc)
					return rc;
				switch(MediaType)
				{
				case Audio_WMC:
					for(j=0; j<pDecoder->tHeaderInfo.wNoOfAudioStreams; j++)
					{
						if( pDecoder->tIndexInfo[i].nStreamId == wStreamId)
						{
							u64LocalTimeRequest = u64TimeRequest /*+ (U64_WMC)pDecoder->tIndexInfo[i].time_deltaMs*999/1000*/;
							dwToIndexEntry = (U32_WMC)(u64LocalTimeRequest/pDecoder->tIndexInfo[i].time_deltaMs);
							if (dwToIndexEntry > pDecoder->tIndexInfo[i].num_entries )
								return WMCDec_InValidArguments;
							pTempIndexEntry = pDecoder->tIndexInfo[i].pIndexEntries;
							pTempIndexEntry+=dwToIndexEntry;
							dwPacketToGo = pTempIndexEntry->dwPacket;
							if (dwPacketToGo > pDecoder->tHeaderInfo.cPackets)
								return WMCDec_InValidArguments;
						}
					}
					break;
				case Video_WMC:
					for(j=0; j<pDecoder->tHeaderInfo.wNoOfVideoStreams; j++)
					{
						if(pDecoder->tIndexInfo[i].nStreamId == wStreamId)
						{
							u64LocalTimeRequest = u64TimeRequest /*+ (U64_WMC)pDecoder->tIndexInfo[i].time_deltaMs*999/1000*/;
							dwToIndexEntry = (U32_WMC)(u64LocalTimeRequest/pDecoder->tIndexInfo[i].time_deltaMs);
							if (dwToIndexEntry > pDecoder->tIndexInfo[i].num_entries )
								return WMCDec_InValidArguments;
							pTempIndexEntry = pDecoder->tIndexInfo[i].pIndexEntries;
							pTempIndexEntry+=dwToIndexEntry;
							dwPacketToGo = pTempIndexEntry->dwPacket;
							if (dwPacketToGo > pDecoder->tHeaderInfo.cPackets)
								return WMCDec_InValidArguments;
							if (pdwPackets !=NULL_WMC)
							*pdwPackets = dwPacketToGo;

						}
        
					}
					break;
				case Binary_WMC:
					for(j=0; j<pDecoder->tHeaderInfo.wNoOfBinaryStreams; j++)
					{
						if(pDecoder->tIndexInfo[i].nStreamId == wStreamId)
						{
							u64LocalTimeRequest = u64TimeRequest /*+ (U64_WMC)pDecoder->tIndexInfo[i].time_deltaMs*999/1000*/;
							dwToIndexEntry = (U32_WMC)(u64LocalTimeRequest/pDecoder->tIndexInfo[i].time_deltaMs);
							if (dwToIndexEntry > pDecoder->tIndexInfo[i].num_entries )
								return WMCDec_InValidArguments;
							pTempIndexEntry = pDecoder->tIndexInfo[i].pIndexEntries;
							pTempIndexEntry+=dwToIndexEntry;
							dwPacketToGo = pTempIndexEntry->dwPacket;
							if (dwPacketToGo > pDecoder->tHeaderInfo.cPackets)
								return WMCDec_InValidArguments;
						}
					}
					break;
				default:
					return WMCDec_InValidArguments;

				}
			}
		}
	}


    if (pdwFirstPacketOffset !=NULL_WMC)
		*pdwFirstPacketOffset = pDecoder->tHeaderInfo.cbHeader;

    if (pdwPacketSize !=NULL_WMC)
		*pdwPacketSize = pDecoder->tHeaderInfo.cbPacketSize;

	cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbHeader  + (dwPacketToGo * pDecoder->tHeaderInfo.cbPacketSize);


	rc = WMCDecParseVirtualPacketHeader(hWMCDec, cbCurrentPacketOffset, &ParseInfoEx);

	if (pSendTime !=NULL_WMC)
		*pSendTime = ParseInfoEx.dwSCR;

    for (iPayload = 0; iPayload < ParseInfoEx.cPayloads; iPayload++)
    {
        
		rc = WMCDecParseVirtualPayloadHeader(hWMCDec, cbCurrentPacketOffset, &ParseInfoEx, &Payload);
		if (rc != WMCDec_Succeeded)
			return rc;
		if (wStreamId == Payload.bStreamId)
		{
			if (bFirst == FALSE)
			{
				if (pu64FirstPayloadPresTime !=NULL_WMC)
					*pu64FirstPayloadPresTime = (U64_WMC) Payload.msObjectPres - (U64_WMC)pDecoder->tHeaderInfo.msPreroll;

				if (pFirstPayloadOffset !=NULL_WMC)
					*pFirstPayloadOffset = Payload.cbObjectOffset;
				
				if (pFirstPayloadOID !=NULL_WMC)
					*pFirstPayloadOID = Payload.bObjectId;
				bFirst = TRUE;

			}
			
			if (Payload.bIsKeyFrame == 0)
				continue;
			else
		        *pu64TimeReturn = (U64_WMC) Payload.msObjectPres - (U64_WMC)pDecoder->tHeaderInfo.msPreroll;
		}
		else
		{
			if ((pDecoder->tHeaderInfo.wNoOfAudioStreams >0) && (bFirstAudio == FALSE_WMC))
			{
				for (j=0; j<pDecoder->tHeaderInfo.wNoOfAudioStreams; j++)
				{
					if (Payload.bStreamId == pDecoder->tAudioStreamInfo[j]->wStreamId)
					{
						if (pFirstAudioPTime !=NULL_WMC)
							*pFirstAudioPTime = (U64_WMC) Payload.msObjectPres - (U64_WMC)pDecoder->tHeaderInfo.msPreroll;
						bFirstAudio = TRUE_WMC;
                        if (pFirstAudioPayloadOID !=NULL_WMC)
                            *pFirstAudioPayloadOID = Payload.bObjectId;
						break;
					}
				}
			}
		}

	}

	while ((pDecoder->tHeaderInfo.wNoOfAudioStreams >0) && (bFirstAudio == FALSE_WMC) && (dwPacketToGo < pDecoder->tHeaderInfo.cPackets))
	{
		dwPacketToGo ++;
		cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbHeader  + (dwPacketToGo * pDecoder->tHeaderInfo.cbPacketSize);

		rc = WMCDecParseVirtualPacketHeader(hWMCDec, cbCurrentPacketOffset, &ParseInfoEx);

		for (iPayload = 0; iPayload < ParseInfoEx.cPayloads; iPayload++)
		{
        
			rc = WMCDecParseVirtualPayloadHeader(hWMCDec, cbCurrentPacketOffset, &ParseInfoEx, &Payload);
			if (rc != WMCDec_Succeeded)
				return rc;
			if ((pDecoder->tHeaderInfo.wNoOfAudioStreams >0) && (bFirstAudio == FALSE_WMC))
			{
				for (j=0; j<(U8_WMC)pDecoder->tHeaderInfo.wNoOfAudioStreams; j++)
				{
					if (Payload.bStreamId == pDecoder->tAudioStreamInfo[j]->wStreamId)
					{
						if (pFirstAudioPTime !=NULL_WMC)
							*pFirstAudioPTime = (U64_WMC) Payload.msObjectPres - (U64_WMC)pDecoder->tHeaderInfo.msPreroll;
                        if (pFirstAudioPayloadOID !=NULL_WMC)
                            *pFirstAudioPayloadOID = Payload.bObjectId;
						bFirstAudio = TRUE_WMC;
						break;
					}
				}
			}
			if (bFirstAudio == TRUE_WMC)
				break;

		}
	}
	

	return rc;
}

/****************************************************************************************************************/


tWMCDecStatus WMCDecGetNextIFrameTime (HWMCDECODER hWMCDec, U16_WMC wStreamId, U64_WMC u64TimeRequest, U64_WMC* pu64TimeReturn, U32_WMC* pdwPackets, U32_WMC* pdwRemainingPackets, U64_WMC* pFirstAudioPTime, U32_WMC* pdwSCR )
{

	U64_WMC cbPacketOffset =0;
    U8_WMC i=0, j=0;
	tWMCDecStatus rc = WMCDec_Succeeded;
    U32_WMC dwToIndexEntry =0;
    WMCINDEXENTRIES* pTempIndexEntry = NULL_WMC;
    U32_WMC dwPacketToGo =0;
    U32_WMC dwNewPacketToGo =0;
    tMediaType_WMC MediaType;
	U32_WMC cbCurrentPacketOffset =0;
	PACKET_PARSE_INFO_EX ParseInfoEx;
	PAYLOAD_MAP_ENTRY_EX Payload;
	U32_WMC iPayload =0;
	U64_WMC u64LocalTimeRequest =0;
 	Bool_WMC bFirstAudio = FALSE_WMC;
 
    WMFDecoderEx* pDecoder = (WMFDecoderEx*) hWMCDec;
    if (pDecoder == NULL_WMC || pu64TimeReturn == NULL_WMC)
        return WMCDec_InValidArguments;


	memset(&ParseInfoEx, 0, sizeof (PACKET_PARSE_INFO_EX));
	memset(&Payload, 0, sizeof (PAYLOAD_MAP_ENTRY_EX));

	*pu64TimeReturn = 0;
	u64TimeRequest= u64TimeRequest + (U64_WMC)pDecoder->tHeaderInfo.msPreroll ;
    if (pDecoder->cTotalIndexs >0)
    {
		for(i=0; i< pDecoder->cTotalIndexs ; i++)
		{
			if (pDecoder->tIndexInfo[i].nStreamId == wStreamId)
			{
				rc = WMCDecGetMediaType (hWMCDec, (U16_WMC) wStreamId, &MediaType);
				if (WMCDec_Succeeded !=rc)
					return rc;
				switch(MediaType)
				{
				case Audio_WMC:
					for(j=0; j<pDecoder->tHeaderInfo.wNoOfAudioStreams; j++)
					{
					
						if( pDecoder->tIndexInfo[i].nStreamId == wStreamId)
						{
                    
							u64LocalTimeRequest = u64TimeRequest + (U64_WMC)pDecoder->tIndexInfo[i].time_deltaMs*999/1000;
							dwToIndexEntry = (U32_WMC)(u64LocalTimeRequest/pDecoder->tIndexInfo[i].time_deltaMs);
							if (dwToIndexEntry > pDecoder->tIndexInfo[i].num_entries )
								return WMCDec_InValidArguments;
							pTempIndexEntry = pDecoder->tIndexInfo[i].pIndexEntries;
							pTempIndexEntry+=dwToIndexEntry;
							dwPacketToGo = pTempIndexEntry->dwPacket;
							if (dwPacketToGo > pDecoder->tHeaderInfo.cPackets)
								return WMCDec_InValidArguments;
							dwNewPacketToGo = dwPacketToGo;
							while (dwNewPacketToGo == dwPacketToGo)
							{
								pTempIndexEntry++;
								dwNewPacketToGo = pTempIndexEntry->dwPacket;
								if (dwNewPacketToGo > pDecoder->tHeaderInfo.cPackets)
									return WMCDec_InValidArguments;
							}
							if (pdwPackets !=NULL)
								*pdwPackets = dwNewPacketToGo;

						}
					}
					break;
				case Video_WMC:
					for(j=0; j<pDecoder->tHeaderInfo.wNoOfVideoStreams; j++)
					{
						if(pDecoder->tIndexInfo[i].nStreamId == wStreamId)
						{
							u64LocalTimeRequest = u64TimeRequest + (U64_WMC)pDecoder->tIndexInfo[i].time_deltaMs*999/1000;
							dwToIndexEntry = (U32_WMC)(u64LocalTimeRequest/pDecoder->tIndexInfo[i].time_deltaMs);
							if (dwToIndexEntry > pDecoder->tIndexInfo[i].num_entries )
								return WMCDec_InValidArguments;
							pTempIndexEntry = pDecoder->tIndexInfo[i].pIndexEntries;
							pTempIndexEntry+=dwToIndexEntry;
							dwPacketToGo = pTempIndexEntry->dwPacket;
							if (dwPacketToGo > pDecoder->tHeaderInfo.cPackets)
								return WMCDec_InValidArguments;
							dwNewPacketToGo = dwPacketToGo;
							while (dwNewPacketToGo == dwPacketToGo)
							{
								pTempIndexEntry++;
								dwNewPacketToGo = pTempIndexEntry->dwPacket;
								if (dwNewPacketToGo > pDecoder->tHeaderInfo.cPackets)
									return WMCDec_InValidArguments;
							}
							if (pdwPackets !=NULL)
								*pdwPackets = dwNewPacketToGo;

						}
        
					}
					break;
				case Binary_WMC:
					for(j=0; j<pDecoder->tHeaderInfo.wNoOfBinaryStreams; j++)
					{
						if(pDecoder->tIndexInfo[i].nStreamId == wStreamId)
						{
							u64LocalTimeRequest = u64TimeRequest + (U64_WMC)pDecoder->tIndexInfo[i].time_deltaMs*999/1000;
							dwToIndexEntry = (U32_WMC)(u64LocalTimeRequest/pDecoder->tIndexInfo[i].time_deltaMs);
							if (dwToIndexEntry > pDecoder->tIndexInfo[i].num_entries )
								return WMCDec_InValidArguments;
							pTempIndexEntry = pDecoder->tIndexInfo[i].pIndexEntries;
							pTempIndexEntry+=dwToIndexEntry;
							dwPacketToGo = pTempIndexEntry->dwPacket;
							if (dwPacketToGo > pDecoder->tHeaderInfo.cPackets)
								return WMCDec_InValidArguments;
							dwNewPacketToGo = dwPacketToGo;
							while (dwNewPacketToGo == dwPacketToGo)
							{
								pTempIndexEntry++;
								dwNewPacketToGo = pTempIndexEntry->dwPacket;
								if (dwNewPacketToGo > pDecoder->tHeaderInfo.cPackets)
									return WMCDec_InValidArguments;
							}
							if (pdwPackets !=NULL)
								*pdwPackets = dwNewPacketToGo;

						}
					}
					break;
				default:
					return WMCDec_InValidArguments;

				}

        
			}
		}
	}
	
	if (pdwRemainingPackets !=NULL)
		*pdwRemainingPackets = pDecoder->tHeaderInfo.cPackets -  dwNewPacketToGo;

    cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbHeader  + (dwNewPacketToGo * pDecoder->tHeaderInfo.cbPacketSize);


	rc = WMCDecParseVirtualPacketHeader(hWMCDec, cbCurrentPacketOffset, &ParseInfoEx);


    for (iPayload = 0; iPayload < ParseInfoEx.cPayloads; iPayload++)
    {
        
		rc = WMCDecParseVirtualPayloadHeader(hWMCDec, cbCurrentPacketOffset, &ParseInfoEx, &Payload);
		if (rc != WMCDec_Succeeded)
			return rc;

		if (wStreamId == Payload.bStreamId)
		{
			if (Payload.bIsKeyFrame == 0)
				continue;
			else
			{
		        *pu64TimeReturn = (U64_WMC) Payload.msObjectPres - (U64_WMC)pDecoder->tHeaderInfo.msPreroll;
				
				if (pdwSCR != NULL)
					*pdwSCR = ParseInfoEx.dwSCR;
			}
		}
		else
		{
			if ((pDecoder->tHeaderInfo.wNoOfAudioStreams >0) && (bFirstAudio == FALSE_WMC))
			{
				for (j=0; j<pDecoder->tHeaderInfo.wNoOfAudioStreams; j++)
				{
					if (Payload.bStreamId == pDecoder->tAudioStreamInfo[j]->wStreamId)
					{
						if (pFirstAudioPTime !=NULL_WMC)
							*pFirstAudioPTime = (U64_WMC) Payload.msObjectPres - (U64_WMC)pDecoder->tHeaderInfo.msPreroll;
						bFirstAudio = TRUE_WMC;
						break;
					}
				}
			}
		}

	}


	while ((pDecoder->tHeaderInfo.wNoOfAudioStreams >0) && (bFirstAudio == FALSE_WMC) && (dwNewPacketToGo < pDecoder->tHeaderInfo.cPackets))
	{
		dwNewPacketToGo ++;
		cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbHeader  + (dwNewPacketToGo * pDecoder->tHeaderInfo.cbPacketSize);

		rc = WMCDecParseVirtualPacketHeader(hWMCDec, cbCurrentPacketOffset, &ParseInfoEx);

		for (iPayload = 0; iPayload < ParseInfoEx.cPayloads; iPayload++)
		{
        
			rc = WMCDecParseVirtualPayloadHeader(hWMCDec, cbCurrentPacketOffset, &ParseInfoEx, &Payload);
			if (rc != WMCDec_Succeeded)
				return rc;
			if ((pDecoder->tHeaderInfo.wNoOfAudioStreams >0) && (bFirstAudio == FALSE_WMC))
			{
				for (j=0; j<(U8_WMC)pDecoder->tHeaderInfo.wNoOfAudioStreams; j++)
				{
					if (Payload.bStreamId == pDecoder->tAudioStreamInfo[j]->wStreamId)
					{
						if (pFirstAudioPTime !=NULL_WMC)
							*pFirstAudioPTime = (U64_WMC) Payload.msObjectPres - (U64_WMC)pDecoder->tHeaderInfo.msPreroll;
						bFirstAudio = TRUE_WMC;
						break;
					}
				}
			}
			if (bFirstAudio == TRUE_WMC)
				break;

		}
	}
	


	
	return rc;
}

/****************************************************************************************************************/

tWMCDecStatus WMCDecGetPreviousFrameTime (HWMCDECODER hWMCDec, U16_WMC wStreamId, U64_WMC u64TimeRequest, U64_WMC* pu64TimeReturn)
{

	U64_WMC cbPacketOffset =0;
    U8_WMC i=0, j=0;
	tWMCDecStatus rc = WMCDec_Succeeded;
    U32_WMC dwToIndexEntry =0;
    WMCINDEXENTRIES* pTempIndexEntry = NULL_WMC;
    U32_WMC dwPacketToGo =0;
    U32_WMC dwNewPacketToGo =0;
    tMediaType_WMC MediaType;
	U32_WMC cbCurrentPacketOffset =0;
	PACKET_PARSE_INFO_EX ParseInfoEx;
	PAYLOAD_MAP_ENTRY_EX Payload;
	U32_WMC iPayload =0;
	U64_WMC u64LocalTimeRequest =0;
	U64_WMC u64LastPresTime = 0;
	Bool_WMC bFirst = FALSE_WMC;
	Bool_WMC bDone = FALSE_WMC;

    WMFDecoderEx* pDecoder = (WMFDecoderEx*) hWMCDec;
    if (pDecoder == NULL_WMC || pu64TimeReturn == NULL_WMC)
        return WMCDec_InValidArguments;


	memset(&ParseInfoEx, 0, sizeof (PACKET_PARSE_INFO_EX));
	memset(&Payload, 0, sizeof (PAYLOAD_MAP_ENTRY_EX));

	*pu64TimeReturn = 0;
	u64TimeRequest= u64TimeRequest + (U64_WMC)pDecoder->tHeaderInfo.msPreroll ;
    if (pDecoder->cTotalIndexs >0)
    {

		for(i=0; i< pDecoder->cTotalIndexs ; i++)
		{
			if (pDecoder->tIndexInfo[i].nStreamId == wStreamId)
			{
				rc = WMCDecGetMediaType (hWMCDec, (U16_WMC) wStreamId, &MediaType);
				if (WMCDec_Succeeded !=rc)
					return rc;
 
				switch(MediaType)
				{
				case Audio_WMC:
					for(j=0; j<pDecoder->tHeaderInfo.wNoOfAudioStreams; j++)
					{
					
						if( pDecoder->tIndexInfo[i].nStreamId == wStreamId)
						{
                    
							u64LocalTimeRequest = u64TimeRequest;
							dwToIndexEntry = (U32_WMC)(u64LocalTimeRequest/pDecoder->tIndexInfo[i].time_deltaMs);
							if (dwToIndexEntry > pDecoder->tIndexInfo[i].num_entries )
								return WMCDec_InValidArguments;
							pTempIndexEntry = pDecoder->tIndexInfo[i].pIndexEntries;
							pTempIndexEntry+=dwToIndexEntry;
							dwPacketToGo = pTempIndexEntry->dwPacket;
							if (dwPacketToGo > pDecoder->tHeaderInfo.cPackets)
								return WMCDec_InValidArguments;
						}
					}
					break;
				case Video_WMC:
					for(j=0; j<pDecoder->tHeaderInfo.wNoOfVideoStreams; j++)
					{
						if(pDecoder->tIndexInfo[i].nStreamId == wStreamId)
						{
							u64LocalTimeRequest = u64TimeRequest /*+(U64_WMC)pDecoder->tIndexInfo[i].time_deltaMs*999/1000*/;
							dwToIndexEntry = (U32_WMC)(u64LocalTimeRequest/pDecoder->tIndexInfo[i].time_deltaMs);
							if (dwToIndexEntry > pDecoder->tIndexInfo[i].num_entries )
								return WMCDec_InValidArguments;
							pTempIndexEntry = pDecoder->tIndexInfo[i].pIndexEntries;
							pTempIndexEntry+=dwToIndexEntry;
							dwPacketToGo = pTempIndexEntry->dwPacket;
							if (dwPacketToGo > pDecoder->tHeaderInfo.cPackets)
								return WMCDec_InValidArguments;
						}
        
					}
					break;
				case Binary_WMC:
					for(j=0; j<pDecoder->tHeaderInfo.wNoOfBinaryStreams; j++)
					{
						if(pDecoder->tIndexInfo[i].nStreamId == wStreamId)
						{
							u64LocalTimeRequest = u64TimeRequest;
							dwToIndexEntry = (U32_WMC)(u64LocalTimeRequest/pDecoder->tIndexInfo[i].time_deltaMs);
							if (dwToIndexEntry > pDecoder->tIndexInfo[i].num_entries )
								return WMCDec_InValidArguments;
							pTempIndexEntry = pDecoder->tIndexInfo[i].pIndexEntries;
							pTempIndexEntry+=dwToIndexEntry;
							dwPacketToGo = pTempIndexEntry->dwPacket;
							if (dwPacketToGo > pDecoder->tHeaderInfo.cPackets)
								return WMCDec_InValidArguments;
						}
					}
					break;
				default:
					return WMCDec_InValidArguments;

				}
			}
		}
		
		if (dwPacketToGo >0)
			dwPacketToGo-=1;


    }


	do
	
	{
		U32_WMC dwCompPresTime =0;
	    U8_WMC *pData = NULL;
		U32_WMC dwOffset =0;
		U8_WMC bNextSubPayloadSize=0;
		U16_WMC wBytesRead=0;
		U32_WMC cbActual =0;



		
		
		cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbHeader  + (dwPacketToGo * pDecoder->tHeaderInfo.cbPacketSize);
		rc = WMCDecParseVirtualPacketHeader(hWMCDec, cbCurrentPacketOffset, &ParseInfoEx);


		for (iPayload = 0; iPayload < ParseInfoEx.cPayloads; iPayload++)
		{
        
			rc = WMCDecParseVirtualPayloadHeader(hWMCDec, cbCurrentPacketOffset, &ParseInfoEx, &Payload);
			if (rc != WMCDec_Succeeded)
				return rc;

			if (wStreamId == Payload.bStreamId)
			{
				if (bFirst == FALSE_WMC)
				{
					u64LastPresTime = (U64_WMC) Payload.msObjectPres;
					bFirst = TRUE_WMC;
				}
				
				
				if (Payload.cbRepData == 1)
				{
				
					dwOffset = Payload.cbPacketOffset + Payload.cbTotalSize - Payload.cbPayloadSize;
				    cbActual = WMCDecCBGetData(hWMCDec, cbCurrentPacketOffset + dwOffset, Payload.cbPayloadSize, &pData, pDecoder->u32UserData);

					dwCompPresTime = Payload.msObjectPres;
					bNextSubPayloadSize = pData [0];
					pData +=1;
//					if (pPay->wTotalDataBytes < bNextSubPayloadSize)
//						return WMPERR_FAIL;

					if( Payload.wTotalDataBytes > bNextSubPayloadSize)
						wBytesRead = bNextSubPayloadSize+1;
					else if (Payload.wTotalDataBytes == bNextSubPayloadSize)
						wBytesRead = bNextSubPayloadSize;
										
					while (Payload.wTotalDataBytes >= wBytesRead) 
					{

						if (dwCompPresTime >= u64TimeRequest)
						{
							*pu64TimeReturn = u64LastPresTime - (U64_WMC)pDecoder->tHeaderInfo.msPreroll;
							bDone = TRUE_WMC;
							break;
						}
						else
						{
							u64LastPresTime = (U64_WMC) dwCompPresTime;
						//	continue;
						}
						pData += bNextSubPayloadSize;
						bNextSubPayloadSize = pData[0];
						wBytesRead+=bNextSubPayloadSize+1;
						pData+=1;
						dwCompPresTime+=Payload.dwDeltaPresTime;
					}
					
					if (bDone == TRUE_WMC)
						break;
				}				
				else
				{
					if (Payload.msObjectPres >= u64TimeRequest)
					{
						*pu64TimeReturn = u64LastPresTime - (U64_WMC)pDecoder->tHeaderInfo.msPreroll;
						bDone = TRUE_WMC;
						break;
					}
					else
					{
						u64LastPresTime = (U64_WMC) Payload.msObjectPres;
						continue;
					}
				}
			}

		}
		dwPacketToGo++;
	}while((bDone == FALSE_WMC) && (dwNewPacketToGo <=pDecoder->tHeaderInfo.cPackets));
	return rc;
}

/****************************************************************************************************************/

/****************************************************************************************************************/
tWMCDecStatus WMCDecSeekToNextI (HWMCDECODER hWMCDec, U16_WMC wStreamId)
{

	U64_WMC cbPacketOffset =0;
    U8_WMC i=0, j=0;
	tWMCDecStatus rc = WMCDec_Succeeded;
    U32_WMC dwToIndexEntry =0;
    WMCINDEXENTRIES* pTempIndexEntry = NULL_WMC;
    U32_WMC dwPacketToGo =0;
    U8_WMC bAudioVideo =0;
    U32_WMC cbVideoSize =0;
    U32_WMC dwVideoTimeStamp=0;
    U16_WMC cbAudioOut =0;
    U32_WMC dwAudioTimeStamp =0;
    U8_WMC* pucVidBufTemp = NULL_WMC;
    U32_WMC dwMinimumPacketToGo = 0xffffffff;
    tMediaType_WMC MediaType;
    U32_WMC nNumSamplesReturn =0;
    I64_WMC tPresentationTime =0;
    U8_WMC *pu8VideoOutBuffer = NULL_WMC;
    U32_WMC u32VideoOutBufferSize =0;
	U32_WMC u32OutDataSize =0;
	U64_WMC u64LocalTimeRequest=0;
	Bool_WMC bVideoThere = FALSE_WMC;
	U64_WMC u64MyTimeReturn =0;
	U32_WMC dwNewPacketToGo=0;
    I64_WMC tPrevPresentationTime =0;
	U32_WMC cbCurrentPacketOffset =0;
	PACKET_PARSE_INFO_EX ParseInfoEx;
	PAYLOAD_MAP_ENTRY_EX Payload;
	U32_WMC iPayload =0;
	Bool_WMC bDone = FALSE_WMC;


 
    WMFDecoderEx* pDecoder = (WMFDecoderEx*) hWMCDec;
    if (pDecoder == NULL_WMC)
        return WMCDec_InValidArguments;

    dwMinimumPacketToGo = (U32_WMC)pDecoder->tHeaderInfo.cbLastPacketOffset;

	rc = WMCDecGetMediaType (hWMCDec, (U16_WMC) wStreamId, &MediaType);

    if (WMCDec_Succeeded !=rc)
        return rc;

	if (MediaType != Video_WMC)
		return WMCDec_InValidArguments;

	memset(&ParseInfoEx, 0, sizeof (PACKET_PARSE_INFO_EX));
	memset(&Payload, 0, sizeof (PAYLOAD_MAP_ENTRY_EX));



    for (i =0; i < pDecoder->tHeaderInfo.wNoOfVideoStreams; i++)
	{
		if (pDecoder->tVideoStreamInfo[i]->wStreamId == wStreamId)
		{
			tPrevPresentationTime = (I64_WMC)pDecoder->tVideoStreamInfo[i]->dwVideoTimeStamp;
			break;
		}
	}



    if (pDecoder->cTotalIndexs >0)
    {
		for(i=0; i< pDecoder->cTotalIndexs ; i++)
		{
			if (pDecoder->tIndexInfo[i].nStreamId == wStreamId)
			{
				rc = WMCDecGetMediaType (hWMCDec, (U16_WMC) wStreamId, &MediaType);
				if (WMCDec_Succeeded !=rc)
					return rc;
				for(j=0; j<pDecoder->tHeaderInfo.wNoOfVideoStreams; j++)
				{
					if(pDecoder->tIndexInfo[i].nStreamId == wStreamId)
					{
						u64LocalTimeRequest = (U64_WMC)tPrevPresentationTime + (U64_WMC)pDecoder->tIndexInfo[i].time_deltaMs*999/1000;
						dwToIndexEntry = (U32_WMC)(u64LocalTimeRequest/pDecoder->tIndexInfo[i].time_deltaMs);
						if (dwToIndexEntry > pDecoder->tIndexInfo[i].num_entries )
							return WMCDec_InValidArguments;
						pTempIndexEntry = pDecoder->tIndexInfo[i].pIndexEntries;
						pTempIndexEntry+=dwToIndexEntry;
						dwPacketToGo = pTempIndexEntry->dwPacket;
						if (dwPacketToGo > pDecoder->tHeaderInfo.cPackets)
							return WMCDec_InValidArguments;
						dwNewPacketToGo = dwPacketToGo;
						while ((dwNewPacketToGo == dwPacketToGo) && (dwToIndexEntry < pDecoder->tIndexInfo[i].num_entries -1))
						{
							dwToIndexEntry++;
							pTempIndexEntry++;
							dwNewPacketToGo = pTempIndexEntry->dwPacket;
							if (dwNewPacketToGo > pDecoder->tHeaderInfo.cPackets)
								return WMCDec_InValidArguments;

							if (dwNewPacketToGo > dwPacketToGo )
							{
								bDone = TRUE_WMC;
							}
						}

						if (bDone == FALSE_WMC)
							dwNewPacketToGo = pDecoder->tHeaderInfo.cPackets;
					}
    
				}
			}
		}

	}
	else
		return WMCDec_Fail;

	

/*

		rc = WMCDecParseVirtualPacketHeader(hWMCDec, cbCurrentPacketOffset, &ParseInfoEx);


		for (iPayload = 0; iPayload < ParseInfoEx.cPayloads; iPayload++)
		{
        
			rc = WMCDecParseVirtualPayloadHeader(hWMCDec, cbCurrentPacketOffset, &ParseInfoEx, &Payload);
			if (rc != WMCDec_Succeeded)
				return rc;

			if (wStreamId == Payload.bStreamId)
			{
				
				if (Payload.msObjectPres > tPrevPresentationTime)
				{
					break;
				}
			}

		}


*/


    pDecoder->parse_state = csWMCNewAsfPacket;


    pDecoder->tHeaderInfo.cbCurrentPacketOffset = (U64_WMC)pDecoder->tHeaderInfo.cbHeader  + ( (U64_WMC)dwNewPacketToGo * (U64_WMC)pDecoder->tHeaderInfo.cbPacketSize);
    pDecoder->tHeaderInfo.cbNextPacketOffset  = (U64_WMC)pDecoder->tHeaderInfo.cbHeader  + ( (U64_WMC)(dwNewPacketToGo) * (U64_WMC)pDecoder->tHeaderInfo.cbPacketSize );


    for(j=0; j<pDecoder->tHeaderInfo.wNoOfAudioStreams; j++)
    {
#ifndef _ASFPARSE_ONLY_
        if ((pDecoder->tAudioStreamInfo[j]->bWantOutput == TRUE_WMC)
			&&(pDecoder->tAudioStreamInfo[j]->bIsDecodable == TRUE_WMC)
			&&(pDecoder->tAudioStreamInfo[j]->nVersion >0 && pDecoder->tAudioStreamInfo[j]->nVersion <4)
			&&(pDecoder->tAudioStreamInfo[j]->hMSA !=NULL_WMC) 
			)
        {
			WMARawDecReset (pDecoder->tAudioStreamInfo[j]->hMSA);
		}
#endif        
		pDecoder->tAudioStreamInfo[j]->dwAudioBufCurOffset = 0;
	    pDecoder->tAudioStreamInfo[j]->cbNbFramesAudBuf = 0;
        pDecoder->tAudioStreamInfo[j]->dwAudioBufDecoded = 0;
	    pDecoder->tAudioStreamInfo[j]->bBlockStart = 0;
	    pDecoder->tAudioStreamInfo[j]->dwBlockLeft = 0;
	    pDecoder->tAudioStreamInfo[j]->dwPayloadLeft = 0;
	    pDecoder->tAudioStreamInfo[j]->dwAudPayloadPresTime = 0;
        pDecoder->tAudioStreamInfo[j]->dwAudioTimeStamp = 0.0;
        pDecoder->tAudioStreamInfo[j]->wmar = WMA_S_NO_MORE_FRAME;
		pDecoder->tAudioStreamInfo[j]->bFirstTime = FALSE_WMC;

#ifdef WMC_NO_BUFFER_MODE
		pDecoder->tAudioStreamInfo[j]->cbPacketOffset = pDecoder->tHeaderInfo.cbPacketOffset;
		pDecoder->tAudioStreamInfo[j]->cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbFirstPacketOffset;
		pDecoder->tAudioStreamInfo[j]->cbNextPacketOffset = pDecoder->tHeaderInfo.cbNextPacketOffset;
		pDecoder->tAudioStreamInfo[j]->parse_state = csWMCNewAsfPacket;

#endif
     }

    for(j=0; j<pDecoder->tHeaderInfo.wNoOfVideoStreams; j++)
    {
        pDecoder->tVideoStreamInfo[j]->bFirst =  FALSE_WMC;
        pDecoder->tVideoStreamInfo[j]->dwVideoBufCurOffset = 0;
	    pDecoder->tVideoStreamInfo[j]->bBlockStart = 0;
	    pDecoder->tVideoStreamInfo[j]->dwBlockLeft = 0;
	    pDecoder->tVideoStreamInfo[j]->dwPayloadLeft = 0;
	    pDecoder->tVideoStreamInfo[j]->cbNbFramesVidBuf = 0;
        pDecoder->tVideoStreamInfo[j]->dwVideoBufDecoded = 0;
        pDecoder->tVideoStreamInfo[j]->dwVideoTimeStamp = 0;
        pDecoder->tVideoStreamInfo[j]->dwNbFrames = 0;
	    pDecoder->tVideoStreamInfo[j]->cbUsed = 0;
        pDecoder->tVideoStreamInfo[j]->dwFrameSize = 0; 
	    pDecoder->tVideoStreamInfo[j]->cbFrame = 0;
		pDecoder->tVideoStreamInfo[j]->pStoreFrameStartPointer = NULL_WMC;
		pDecoder->tVideoStreamInfo[j]->pStoreNextFrameStartPointer = NULL_WMC;
		pDecoder->tVideoStreamInfo[j]->bHasGivenAnyOutput = FALSE_WMC;
		pDecoder->tVideoStreamInfo[j]->bNowStopReadingAndDecoding = FALSE_WMC;
#ifdef WMC_NO_BUFFER_MODE
		pDecoder->tVideoStreamInfo[j]->cbPacketOffset = pDecoder->tHeaderInfo.cbPacketOffset;
		pDecoder->tVideoStreamInfo[j]->cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbFirstPacketOffset;
		pDecoder->tVideoStreamInfo[j]->cbNextPacketOffset = pDecoder->tHeaderInfo.cbNextPacketOffset;
		pDecoder->tVideoStreamInfo[j]->parse_state = csWMCNewAsfPacket;
        pDecoder->tVideoStreamInfo[j]->dwNextVideoTimeStamp = 0;

#endif
    }

    for(j=0; j<pDecoder->tHeaderInfo.wNoOfBinaryStreams; j++)
    {
        pDecoder->tBinaryStreamInfo[j]->dwBinaryBufCurOffset = 0;
        pDecoder->tBinaryStreamInfo[j]->dwBinaryTimeStamp = 0;
	    pDecoder->tBinaryStreamInfo[j]->cbNbFramesBinBuf = 0;
	    pDecoder->tBinaryStreamInfo[j]->dwBlockLeft = 0;
	    pDecoder->tBinaryStreamInfo[j]->dwPayloadLeft = 0;
   	    pDecoder->tBinaryStreamInfo[j]->cbUsed = 0;
        pDecoder->tBinaryStreamInfo[j]->dwFrameSize = 0; 
	    pDecoder->tBinaryStreamInfo[j]->cbFrame = 0;
        pDecoder->tBinaryStreamInfo[j]->dwNbFrames = 0;
        pDecoder->tBinaryStreamInfo[j]->dwBinaryBufDecoded = 0;
		pDecoder->tBinaryStreamInfo[j]->bHasGivenAnyOutput = FALSE_WMC;
		pDecoder->tBinaryStreamInfo[j]->bNowStopReadingAndDecoding = FALSE_WMC;
#ifdef WMC_NO_BUFFER_MODE
		pDecoder->tBinaryStreamInfo[j]->cbPacketOffset = pDecoder->tHeaderInfo.cbPacketOffset;
		pDecoder->tBinaryStreamInfo[j]->cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbFirstPacketOffset;
		pDecoder->tBinaryStreamInfo[j]->cbNextPacketOffset = pDecoder->tHeaderInfo.cbNextPacketOffset;
		pDecoder->tBinaryStreamInfo[j]->parse_state = csWMCNewAsfPacket;
        pDecoder->tBinaryStreamInfo[j]->dwNextBinaryTimeStamp = 0;

#endif
    }





/*	do
	{
		rc = WMCDecDecodeData (hWMCDec, &nStreamReadyForOutput, &nNumberOfSamples);
        
        if (nNumberOfSamples >0)
        {
            cbAudioOut = 0;
            for (i=0; i<pDecoder->tHeaderInfo.wNoOfStreams; i++ )
            {
                if (pDecoder->pStreamIdnMediaType[i].wStreamId == (U16_WMC)nStreamReadyForOutput)
                {
                
                    switch(pDecoder->pStreamIdnMediaType[i].MediaType)
                    {
                    case Audio_WMC:
                        for (j=0; j<pDecoder->tHeaderInfo.wNoOfAudioStreams ; j++)
                        {
                             if ( pDecoder->tAudioStreamInfo[j]->wStreamId == (U16_WMC)nStreamReadyForOutput)
                             {
 			                    do
                                {
				                    cbAudioOut = 2048;
                                    rc = WMCDecGetAudioOutput (hWMCDec, (I16_WMC *)OutBuff, NULL_WMC, cbAudioOut, &nNumSamplesReturn, &tPresentationTime );
                                    if (nNumSamplesReturn > 0)
									{
										if ((tPresentationTime >= (I64_WMC)(pDecoder->u64SeekTimeRequest - 10 -pDecoder->tHeaderInfo.msPreroll)) && bVideoThere == FALSE)
										{
											pDecoder->bInSeekState = FALSE;
											*pu64TimeReturn = tPresentationTime;
											break;
										}
									
									}
                                }while(nNumSamplesReturn >0);

                                break;
                             }
                        }
                        break;

                    case Video_WMC:
                        for (j=0; j<pDecoder->tHeaderInfo.wNoOfVideoStreams; j++)
                        {
                             if ( pDecoder->tVideoStreamInfo[j]->wStreamId== (U16_WMC)nStreamReadyForOutput)
                             {
                             
        	                    do
                                {
                                     rc = WMCDecGetVideoOutput (hWMCDec, NULL_WMC , 0, &u32OutDataSize, &tPresentationTime, &bIsKeyFrame);
									if (tPresentationTime >= (I64_WMC)u64MyTimeReturn)
									{
										pDecoder->bInSeekState = FALSE;
										*pu64TimeReturn = tPresentationTime;
										break;
									}
                                }while(u32OutDataSize >0);
                                break;
                             }
                        }
                        break;
                    }
                    break;
                }
            }
        }
    }while ((rc == 0) && (pDecoder->bInSeekState == TRUE));


	if (pu8VideoOutBuffer != NULL_WMC)
		wmvfree(pu8VideoOutBuffer);
	pu8VideoOutBuffer = NULL_WMC;

	pDecoder->bInSeekState = FALSE;
*/
	return rc;
}


/****************************************************************************************************************/

tWMCDecStatus WMCDecSeekToPrevI (HWMCDECODER hWMCDec, U16_WMC wStreamId)
{

	U64_WMC cbPacketOffset =0;
    U8_WMC i=0, j=0;
	tWMCDecStatus rc = WMCDec_Succeeded;
    U32_WMC dwToIndexEntry =0;
    WMCINDEXENTRIES* pTempIndexEntry = NULL_WMC;
    U32_WMC dwPacketToGo =0;
    U8_WMC bAudioVideo =0;
    U32_WMC cbVideoSize =0;
    U32_WMC dwVideoTimeStamp=0;
    U16_WMC cbAudioOut =0;
    U32_WMC dwAudioTimeStamp =0;
    U8_WMC* pucVidBufTemp = NULL_WMC;
    U32_WMC dwMinimumPacketToGo = 0xffffffff;
    tMediaType_WMC MediaType;
    U32_WMC nNumSamplesReturn =0;
    I64_WMC tPresentationTime =0;
    U8_WMC *pu8VideoOutBuffer = NULL_WMC;
    U32_WMC u32VideoOutBufferSize =0;
	U32_WMC u32OutDataSize =0;
	U64_WMC u64LocalTimeRequest=0;
	Bool_WMC bVideoThere = FALSE_WMC;
	U64_WMC u64MyTimeReturn =0;
	U32_WMC dwNewPacketToGo=0;
    I64_WMC tPrevPresentationTime =0;
	U32_WMC cbCurrentPacketOffset =0;
	PACKET_PARSE_INFO_EX ParseInfoEx;
	PAYLOAD_MAP_ENTRY_EX Payload;
	U32_WMC iPayload =0;
	Bool_WMC bDone = FALSE_WMC;



 
    WMFDecoderEx* pDecoder = (WMFDecoderEx*) hWMCDec;
    if (pDecoder == NULL_WMC)
        return WMCDec_InValidArguments;

    dwMinimumPacketToGo = (U32_WMC)pDecoder->tHeaderInfo.cbLastPacketOffset;


	memset(&ParseInfoEx, 0, sizeof (PACKET_PARSE_INFO_EX));
	memset(&Payload, 0, sizeof (PAYLOAD_MAP_ENTRY_EX));

    rc = WMCDecGetMediaType (hWMCDec, (U16_WMC) wStreamId, &MediaType);

    if (WMCDec_Succeeded !=rc)
        return rc;

	if (MediaType != Video_WMC)
		return WMCDec_InValidArguments;

    for (i =0; i < pDecoder->tHeaderInfo.wNoOfVideoStreams; i++)
	{
		if (pDecoder->tVideoStreamInfo[i]->wStreamId == wStreamId)
		{
			tPrevPresentationTime = (I64_WMC)pDecoder->tVideoStreamInfo[i]->dwVideoTimeStamp;
		}
	}

    if (pDecoder->cTotalIndexs >0)
    {

		for(i=0; i< pDecoder->cTotalIndexs ; i++)
		{
			if (pDecoder->tIndexInfo[i].nStreamId == wStreamId)
			{
				rc = WMCDecGetMediaType (hWMCDec, (U16_WMC) wStreamId, &MediaType);
				if (WMCDec_Succeeded !=rc)
					return rc;
				for(j=0; j<pDecoder->tHeaderInfo.wNoOfVideoStreams; j++)
				{
					if(pDecoder->tIndexInfo[i].nStreamId == wStreamId)
					{
						u64LocalTimeRequest = tPrevPresentationTime;
						dwToIndexEntry = (U32_WMC)(u64LocalTimeRequest/pDecoder->tIndexInfo[i].time_deltaMs);
						if (dwToIndexEntry > pDecoder->tIndexInfo[i].num_entries )
							return WMCDec_InValidArguments;
						pTempIndexEntry = pDecoder->tIndexInfo[i].pIndexEntries;
						pTempIndexEntry+=dwToIndexEntry;
						dwPacketToGo = pTempIndexEntry->dwPacket;
						if (dwPacketToGo > pDecoder->tHeaderInfo.cPackets)
							return WMCDec_InValidArguments;
						dwNewPacketToGo = dwPacketToGo;


						cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbHeader  + (dwNewPacketToGo * pDecoder->tHeaderInfo.cbPacketSize);

						rc = WMCDecParseVirtualPacketHeader(hWMCDec, cbCurrentPacketOffset, &ParseInfoEx);


						for (iPayload = 0; iPayload < ParseInfoEx.cPayloads; iPayload++)
						{
        
							rc = WMCDecParseVirtualPayloadHeader(hWMCDec, cbCurrentPacketOffset, &ParseInfoEx, &Payload);
							if (rc != WMCDec_Succeeded)
								return rc;

							if (wStreamId == Payload.bStreamId)
							{
								
								if ((Payload.msObjectPres < tPrevPresentationTime)&&(Payload.bIsKeyFrame))
								{
									bDone = TRUE_WMC;
									break;
								}
							}

						}

					    if ((bDone == FALSE_WMC) && (dwToIndexEntry >=2))
						{
							pTempIndexEntry-=2;
							dwPacketToGo = pTempIndexEntry->dwPacket;
							if (dwPacketToGo > pDecoder->tHeaderInfo.cPackets)
								return WMCDec_InValidArguments;
							dwNewPacketToGo = dwPacketToGo;
						}

					

					}
    
				}
			
			}
		}
	}
	else
		return WMCDec_Fail;

    pDecoder->parse_state = csWMCNewAsfPacket;

    pDecoder->tHeaderInfo.cbCurrentPacketOffset = (U64_WMC)pDecoder->tHeaderInfo.cbHeader  + ( (U64_WMC)dwNewPacketToGo * (U64_WMC)pDecoder->tHeaderInfo.cbPacketSize);
    pDecoder->tHeaderInfo.cbNextPacketOffset  = (U64_WMC)pDecoder->tHeaderInfo.cbHeader  + ( (U64_WMC)(dwNewPacketToGo) * (U64_WMC)pDecoder->tHeaderInfo.cbPacketSize );



    for(j=0; j<pDecoder->tHeaderInfo.wNoOfAudioStreams; j++)
    {
#ifndef _ASFPARSE_ONLY_
        if ((pDecoder->tAudioStreamInfo[j]->bWantOutput == TRUE_WMC)
			&&(pDecoder->tAudioStreamInfo[j]->bIsDecodable == TRUE_WMC)
			&&(pDecoder->tAudioStreamInfo[j]->nVersion >0 && pDecoder->tAudioStreamInfo[j]->nVersion <4)
			&&(pDecoder->tAudioStreamInfo[j]->hMSA !=NULL_WMC) 
			)
        {
			WMARawDecReset (pDecoder->tAudioStreamInfo[j]->hMSA);
		}
#endif        
		pDecoder->tAudioStreamInfo[j]->dwAudioBufCurOffset = 0;
	    pDecoder->tAudioStreamInfo[j]->cbNbFramesAudBuf = 0;
        pDecoder->tAudioStreamInfo[j]->dwAudioBufDecoded = 0;
	    pDecoder->tAudioStreamInfo[j]->bBlockStart = 0;
	    pDecoder->tAudioStreamInfo[j]->dwBlockLeft = 0;
	    pDecoder->tAudioStreamInfo[j]->dwPayloadLeft = 0;
	    pDecoder->tAudioStreamInfo[j]->dwAudPayloadPresTime = 0;
        pDecoder->tAudioStreamInfo[j]->dwAudioTimeStamp = 0.0;
        pDecoder->tAudioStreamInfo[j]->wmar = WMA_S_NO_MORE_FRAME;
		pDecoder->tAudioStreamInfo[j]->bFirstTime = FALSE_WMC;

#ifdef WMC_NO_BUFFER_MODE
		pDecoder->tAudioStreamInfo[j]->cbPacketOffset = pDecoder->tHeaderInfo.cbPacketOffset;
		pDecoder->tAudioStreamInfo[j]->cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbFirstPacketOffset;
		pDecoder->tAudioStreamInfo[j]->cbNextPacketOffset = pDecoder->tHeaderInfo.cbNextPacketOffset;
		pDecoder->tAudioStreamInfo[j]->parse_state = csWMCNewAsfPacket;

#endif

     }

    for(j=0; j<pDecoder->tHeaderInfo.wNoOfVideoStreams; j++)
    {
        pDecoder->tVideoStreamInfo[j]->bFirst =  FALSE_WMC;
        pDecoder->tVideoStreamInfo[j]->dwVideoBufCurOffset = 0;
	    pDecoder->tVideoStreamInfo[j]->bBlockStart = 0;
	    pDecoder->tVideoStreamInfo[j]->dwBlockLeft = 0;
	    pDecoder->tVideoStreamInfo[j]->dwPayloadLeft = 0;
	    pDecoder->tVideoStreamInfo[j]->cbNbFramesVidBuf = 0;
        pDecoder->tVideoStreamInfo[j]->dwVideoBufDecoded = 0;
        pDecoder->tVideoStreamInfo[j]->dwVideoTimeStamp = 0;
        pDecoder->tVideoStreamInfo[j]->dwNbFrames = 0;
	    pDecoder->tVideoStreamInfo[j]->cbUsed = 0;
        pDecoder->tVideoStreamInfo[j]->dwFrameSize = 0; 
	    pDecoder->tVideoStreamInfo[j]->cbFrame = 0;
		pDecoder->tVideoStreamInfo[j]->pStoreFrameStartPointer = NULL_WMC;
		pDecoder->tVideoStreamInfo[j]->pStoreNextFrameStartPointer = NULL_WMC;
		pDecoder->tVideoStreamInfo[j]->bHasGivenAnyOutput = FALSE_WMC;
		pDecoder->tVideoStreamInfo[j]->bNowStopReadingAndDecoding = FALSE_WMC;
#ifdef WMC_NO_BUFFER_MODE
		pDecoder->tVideoStreamInfo[j]->cbPacketOffset = pDecoder->tHeaderInfo.cbPacketOffset;
		pDecoder->tVideoStreamInfo[j]->cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbFirstPacketOffset;
		pDecoder->tVideoStreamInfo[j]->cbNextPacketOffset = pDecoder->tHeaderInfo.cbNextPacketOffset;
		pDecoder->tVideoStreamInfo[j]->parse_state = csWMCNewAsfPacket;
        pDecoder->tVideoStreamInfo[j]->dwNextVideoTimeStamp = 0;

#endif
    }

    for(j=0; j<pDecoder->tHeaderInfo.wNoOfBinaryStreams; j++)
    {
        pDecoder->tBinaryStreamInfo[j]->dwBinaryBufCurOffset = 0;
        pDecoder->tBinaryStreamInfo[j]->dwBinaryTimeStamp = 0;
	    pDecoder->tBinaryStreamInfo[j]->cbNbFramesBinBuf = 0;
	    pDecoder->tBinaryStreamInfo[j]->dwBlockLeft = 0;
	    pDecoder->tBinaryStreamInfo[j]->dwPayloadLeft = 0;
   	    pDecoder->tBinaryStreamInfo[j]->cbUsed = 0;
        pDecoder->tBinaryStreamInfo[j]->dwFrameSize = 0; 
	    pDecoder->tBinaryStreamInfo[j]->cbFrame = 0;
        pDecoder->tBinaryStreamInfo[j]->dwNbFrames = 0;
        pDecoder->tBinaryStreamInfo[j]->dwBinaryBufDecoded = 0;
		pDecoder->tBinaryStreamInfo[j]->bHasGivenAnyOutput = FALSE_WMC;
		pDecoder->tBinaryStreamInfo[j]->bNowStopReadingAndDecoding = FALSE_WMC;
#ifdef WMC_NO_BUFFER_MODE
		pDecoder->tBinaryStreamInfo[j]->cbPacketOffset = pDecoder->tHeaderInfo.cbPacketOffset;
		pDecoder->tBinaryStreamInfo[j]->cbCurrentPacketOffset = pDecoder->tHeaderInfo.cbFirstPacketOffset;
		pDecoder->tBinaryStreamInfo[j]->cbNextPacketOffset = pDecoder->tHeaderInfo.cbNextPacketOffset;
		pDecoder->tBinaryStreamInfo[j]->parse_state = csWMCNewAsfPacket;
        pDecoder->tBinaryStreamInfo[j]->dwNextBinaryTimeStamp = 0;

#endif
    }





/*	do
	{
		rc = WMCDecDecodeData (hWMCDec, &nStreamReadyForOutput, &nNumberOfSamples);
        
        if (nNumberOfSamples >0)
        {
            cbAudioOut = 0;
            for (i=0; i<pDecoder->tHeaderInfo.wNoOfStreams; i++ )
            {
                if (pDecoder->pStreamIdnMediaType[i].wStreamId == (U16_WMC)nStreamReadyForOutput)
                {
                
                    switch(pDecoder->pStreamIdnMediaType[i].MediaType)
                    {
                    case Audio_WMC:
                        for (j=0; j<pDecoder->tHeaderInfo.wNoOfAudioStreams ; j++)
                        {
                             if ( pDecoder->tAudioStreamInfo[j]->wStreamId == (U16_WMC)nStreamReadyForOutput)
                             {
 			                    do
                                {
				                    cbAudioOut = 2048;
                                    rc = WMCDecGetAudioOutput (hWMCDec, (I16_WMC *)OutBuff, NULL_WMC, cbAudioOut, &nNumSamplesReturn, &tPresentationTime );
                                    if (nNumSamplesReturn > 0)
									{
										if ((tPresentationTime >= (I64_WMC)(pDecoder->u64SeekTimeRequest - 10 -pDecoder->tHeaderInfo.msPreroll)) && bVideoThere == FALSE)
										{
											pDecoder->bInSeekState = FALSE;
											*pu64TimeReturn = tPresentationTime;
											break;
										}
									
									}
                                }while(nNumSamplesReturn >0);

                                break;
                             }
                        }
                        break;

                    case Video_WMC:
                        for (j=0; j<pDecoder->tHeaderInfo.wNoOfVideoStreams; j++)
                        {
                             if ( pDecoder->tVideoStreamInfo[j]->wStreamId== (U16_WMC)nStreamReadyForOutput)
                             {
                             
        	                    do
                                {
                                     rc = WMCDecGetVideoOutput (hWMCDec, NULL_WMC , 0, &u32OutDataSize, &tPresentationTime, &bIsKeyFrame);
									if (tPresentationTime >= (I64_WMC)u64MyTimeReturn)
									{
										pDecoder->bInSeekState = FALSE;
										*pu64TimeReturn = tPresentationTime;
										break;
									}
                                }while(u32OutDataSize >0);
                                break;
                             }
                        }
                        break;
                    }
                    break;
                }
            }
        }
    }while ((rc == 0) && (pDecoder->bInSeekState == TRUE));


    wmvfree(pu8VideoOutBuffer);
	pu8VideoOutBuffer = NULL_WMC;

	pDecoder->bInSeekState = FALSE;
*/
	return rc;
}


/****************************************************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\wmfparse.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       wmaparse.c
//
//--------------------------------------------------------------------------

#include "bldsetup.h"

#if defined(macintosh) || defined(HITACHI)
typedef unsigned long U32_WMC;
#define __DWORD_DEFINED__
#else
#ifdef _XBOX
#include "xtl.h"
#endif
#ifndef _Embedded_x86
#include <windows.h>
#endif // embedded_x86
#endif

#include <stdlib.h>
#include <string.h>
#ifdef UNDER_CE
#define assert ASSERT
#else
#include <assert.h>
#endif
#include "wmc_type.h"
#include "wmcdecode.h"
#include "wmfparse.h"
#include "wmf_loadstuff.h"
#include "wmf.h"
#include "wmfdec.h"
#ifdef HITACHI
#include "wmmacsp.h"
#endif

#include "wmcguids.h"

Void_WMC SwapWstr(U16Char_WMC *src, I32_WMC n);
Void_WMC SWAPDWORD(U8_WMC * pSrc);
Void_WMC SWAPWORD(U8_WMC * pSrc);
U32_WMC HnsQWORDtoMsDWORD( U64_WMC qw );
U32_WMC GetASFVarField( U8_WMC bType, const U8_WMC *p, U32_WMC *pcbOffset );


Void_WMC SWAPWORD(U8_WMC * pSrc)
{   
    U8_WMC Temp;
    Temp  = *pSrc;
    *pSrc = *(pSrc+1);
    *(pSrc+1)= Temp;
}

Void_WMC SWAPDWORD(U8_WMC * pSrc)
{   
    U8_WMC Temp;
    Temp      = *pSrc;
    *pSrc     = *(pSrc+3);
    *(pSrc+3) = Temp;
    Temp      = *(pSrc+1);
    *(pSrc+1) = *(pSrc+2);
    *(pSrc+2) = Temp;
}

Void_WMC SwapWstr(U16Char_WMC *src, I32_WMC n)
{
    I32_WMC j;
    U8_WMC *p = (U8_WMC *)src;
    for (j = 0; j < n; j++) {
        SWAPWORD(p);
        p += 2;
    }
}

/****************************************************************************/
U32_WMC HnsQWORDtoMsDWORD( U64_WMC qw )
{
    U32_WMC msLo, msHi;

    msLo = (*((U32_WMC*)&qw)) / 10000;
#ifndef UNDER_CE
    msHi = (U32_WMC)( (Float_WMC) (*(((U32_WMC*)&qw)+1)) * 429496.7296 );
#else
    msHi = (U32_WMC)( (Float_WMC) (*(((U32_WMC*)&qw)+1)) * 429496.7296f);
#endif

    return( msLo + msHi );
}


/****************************************************************************/
tWMCDecStatus LoadHeaderObject(HWMCDECODER* phDecoder)
{
    GUID_WMC objectId;
    U64_WMC qwSize;
    U32_WMC cHeaders;
    U8_WMC align;
    U8_WMC arch;

    U8_WMC *pData = NULL;
    U32_WMC cbWanted;
    U32_WMC cbActual;

    WMFDecoderEx *pDecoder = NULL;

    if( NULL == phDecoder)
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(*phDecoder);

 
    cbWanted = MIN_OBJECT_SIZE + sizeof(U32_WMC) + 2*sizeof(U8_WMC);
    cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
        return WMCDec_BufferTooSmall;
    pDecoder->tHeaderInfo.cbCurrentPacketOffset +=(U64_WMC)cbActual;  
   
    
    LoadGUID( objectId, pData );
    LoadQWORD( qwSize, pData );
    LoadDWORD( cHeaders, pData );
    LoadBYTE( align, pData );
    LoadBYTE( arch, pData );

    if( !IsEqualGUID_WMC( &CLSID_CAsfHeaderObjectV0, &objectId ) || ( 1 != align ) || ( 2 != arch ) )
    {
        return  WMCDec_BadAsfHeader;
    }

    pDecoder->tHeaderInfo.cbHeader = *((U32_WMC*) &qwSize);

//    *pcbInternalSpace = MIN_OBJECT_SIZE + sizeof( U32_WMC ) + ( 2 * sizeof( U8_WMC ) );
//    *pcbHeader = *((U32_WMC*) &qwSize);

    return WMCDec_Succeeded;


}


/****************************************************************************/
tWMCDecStatus LoadPropertiesObject( /*const U8_WMC *pbBuffer,*/
                    U32_WMC cbBuffer,
                    HWMCDECODER* phDecoder)
{
    GUID_WMC mmsId;
    U64_WMC qwTotalSize;
    U64_WMC qwCreateTime;
    U64_WMC qwPackets;
    U64_WMC qwPlayDuration;
    U64_WMC qwSendDuration;
    U64_WMC qwPreroll;
    U32_WMC dwFlags;
    U32_WMC dwMinPacketSize;
    U32_WMC dwMaxPacketSize;
    U32_WMC dwMaxBitrate;
    WMFDecoderEx *pDecoder = NULL;
    U8_WMC *pData = NULL; 
    U32_WMC cbWanted;
    U32_WMC cbActual;

    if( NULL == phDecoder )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(*phDecoder);
    
    cbBuffer -= MIN_OBJECT_SIZE;
    
    cbWanted = sizeof( GUID_WMC ) + ( 6 * sizeof( U64_WMC ) ) + ( 4 * sizeof( U32_WMC ) );

    if(cbWanted > cbBuffer)
        return WMCDec_BufferTooSmall;

    cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
        return WMCDec_BufferTooSmall;
    
    
    LoadGUID( mmsId, pData );
    LoadQWORD( qwTotalSize, pData );
    LoadQWORD( qwCreateTime, pData );
    LoadQWORD( qwPackets, pData );
    LoadQWORD( qwPlayDuration, pData );
    LoadQWORD( qwSendDuration, pData );
    LoadQWORD( qwPreroll, pData );
    LoadDWORD( dwFlags, pData );
    LoadDWORD( dwMinPacketSize, pData );
    LoadDWORD( dwMaxPacketSize, pData );
    LoadDWORD( dwMaxBitrate, pData );
    pDecoder->tHeaderInfo.cbPacketSize = dwMaxPacketSize;
    pDecoder->tHeaderInfo.cPackets  = *((U32_WMC*) &qwPackets);
    pDecoder->tHeaderInfo.msDuration  = HnsQWORDtoMsDWORD( qwPlayDuration );
    pDecoder->tHeaderInfo.msSendDuration  = HnsQWORDtoMsDWORD( qwSendDuration );
    pDecoder->tHeaderInfo.msPreroll  = *((U32_WMC*) &qwPreroll);
    pDecoder->tHeaderInfo.dwMaxBitrate  = dwMaxBitrate;

    pDecoder->tHeaderInfo.cbCurrentPacketOffset +=(U64_WMC)cbBuffer; // Use whole Object  

    return WMCDec_Succeeded;

}


/****************************************************************************/
tWMCDecStatus LoadEncryptionObject(
                   // const U8_WMC *pbBuffer,
                    U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder)
{
    tWMCDecStatus we = WMCDec_Succeeded;
    U32_WMC cbType;
    U32_WMC cbKeyID;
    U8_WMC *pData = NULL;
    U32_WMC cbWanted;
    U32_WMC cbActual;
    U32_WMC cbObjectOffset = 0;
    WMFDecoderEx *pDecoder = NULL;

    if( NULL == phDecoder )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(*phDecoder);
    
    if(cbBuffer < MIN_OBJECT_SIZE)
        return WMCDec_BufferTooSmall;

    cbBuffer -= MIN_OBJECT_SIZE;

    pDecoder->pszType = NULL;
    pDecoder->pszKeyID = NULL;
    pDecoder->cbSecData = 0;
    pDecoder->pbSecData = NULL;

    do
    {

        cbWanted = sizeof(U32_WMC);
        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            we = WMCDec_BufferTooSmall;
            break;
        }

        cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            we = WMCDec_BufferTooSmall;
            break;
        }
        cbObjectOffset += cbActual;

        LoadDWORD(pDecoder->cbSecData, pData);

        if(pDecoder->cbSecData > 0)
        {
            cbWanted = pDecoder->cbSecData;
            if(cbObjectOffset + cbWanted > cbBuffer)
            {
                we = WMCDec_BufferTooSmall;
                break;
            }
            cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                we = WMCDec_BufferTooSmall;
                break;
            }
            cbObjectOffset += cbActual;

            
            pDecoder->pbSecData = (U8_WMC *)wmvalloc(pDecoder->cbSecData);
            if(pDecoder->pbSecData == NULL)
            {
                we = WMCDec_BadMemory;
                break;
            }
            memcpy(pDecoder->pbSecData, pData, (size_t)cbActual);
        }


        cbWanted = sizeof(U32_WMC);
        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            we = WMCDec_BufferTooSmall;
            break;
        }

        cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset+ cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            we = WMCDec_BufferTooSmall;
            break;
        }
        cbObjectOffset += cbActual;

        LoadDWORD(cbType, pData);

        if(cbType > 0)
        {
            cbWanted = cbType;
            if(cbObjectOffset + cbWanted > cbBuffer)
            {
                we = WMCDec_BufferTooSmall;
                break;
            }
            cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                we = WMCDec_BufferTooSmall;
                break;
            }
            cbObjectOffset += cbActual;

            pDecoder->pszType = (U8_WMC *)wmvalloc(cbType);
            if(pDecoder->pszType == NULL)
            {
                we = WMCDec_BadMemory;
                break;
            }
            memcpy(pDecoder->pszType, pData, cbActual);

        }

        cbWanted = sizeof(U32_WMC);
        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            we = WMCDec_BufferTooSmall;
            break;
        }

        cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset+ cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            we = WMCDec_BufferTooSmall;
            break;
        }
        cbObjectOffset += cbActual;
        
       
        LoadDWORD(cbKeyID, pData);


        if(cbKeyID > 0)
        {
            cbWanted = cbKeyID;
            if(cbObjectOffset + cbWanted > cbBuffer)
            {
                we = WMCDec_BufferTooSmall;
                break;
            }
            cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                we = WMCDec_BufferTooSmall;
                break;
            }
            cbObjectOffset += cbActual;

            pDecoder->pszKeyID = (U8_WMC *)wmvalloc(cbKeyID);
            if(pDecoder->pszKeyID == NULL)
            {
                we = WMCDec_BadMemory;
                break;
            }
            memcpy(pDecoder->pszKeyID, pData, cbActual);

        }

        /* ignore the license URL */

    }
    while (0);

    if(we != WMCDec_Succeeded)
    {
        /* clean up if necessary */

        if(pDecoder->pszType != NULL)
        {
            wmvfree(pDecoder->pszType);
        }
        if(pDecoder->pszKeyID != NULL)
        {
            wmvfree(pDecoder->pszKeyID);
        }
    }
    pDecoder->tHeaderInfo.cbCurrentPacketOffset +=(U64_WMC)cbBuffer; // Use whole Object  

    return we;

}

/****************************************************************************/
tWMCDecStatus LoadEncryptionObjectEx(
                  //  const U8_WMC *pbBuffer,
                    U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder)
{
    tWMCDecStatus we = WMCDec_Succeeded;
    U32_WMC cbEnhData;
    WMFDecoderEx *pDecoder = NULL;
    U8_WMC *pData = NULL;
    U32_WMC cbWanted;
    U32_WMC cbActual;
    U32_WMC cbObjectOffset = 0;

    if( NULL == phDecoder )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(*phDecoder);
    
    if(cbBuffer < MIN_OBJECT_SIZE)
        return WMCDec_BufferTooSmall;

    cbBuffer -= MIN_OBJECT_SIZE;
    
    pDecoder->cbEnhData = 0;
    pDecoder->pbEnhData = NULL;

    do
    {
        cbWanted = sizeof(U32_WMC);
        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            we = WMCDec_BufferTooSmall;
            break;
        }

        cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            we = WMCDec_BufferTooSmall;
            break;
        }
        cbObjectOffset += cbActual;

        LoadDWORD(cbEnhData, pData);

        if(cbEnhData > 0)
        {
            cbWanted = cbEnhData;
            if(cbObjectOffset + cbWanted > cbBuffer)
            {
                we = WMCDec_BufferTooSmall;
                break;
            }
            cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                we = WMCDec_BufferTooSmall;
                break;
            }
            cbObjectOffset += cbActual;

 
            pDecoder->pbEnhData = (U8_WMC *)wmvalloc(cbEnhData);
            if(pDecoder->pbEnhData == NULL)
            {
                we = WMCDec_BadMemory;
                break;
            }
            memcpy(pDecoder->pbEnhData, pData, cbActual);

        }
        pDecoder->cbEnhData = cbEnhData;

    }
    while (0);
    pDecoder->tHeaderInfo.cbCurrentPacketOffset +=(U64_WMC)cbBuffer; // Use whole Object  

    return we;
}

/****************************************************************************/
tWMCDecStatus LoadAudioObjectSize(
                  //  const U8_WMC *pbBuffer,
                    U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder)
{
    GUID_WMC streamType;
    GUID_WMC ecStrategy;
    U64_WMC qwOffset;
    U32_WMC cbTypeSpecific;
    U32_WMC cbErrConcealment;
    U16_WMC wStreamNum;
    U32_WMC dwJunk;
    U32_WMC nBlocksPerObject;
    U8_WMC *pbTypeSpecific;
    const AsfXAcmAudioErrorMaskingData *pScramblingData;
    BITMAPINFOHEADER * pbminfo = NULL;
    AsfXGenericImageTypeSpecific *pGen = NULL;
    U16_WMC  tw =0;
    U32_WMC tdw=0;
    U8_WMC tb=0;
    U8_WMC *tp = NULL;
    I32_WMC span = 0;
	U16_WMC uTemp=0;
    AUDIOSTREAMINFO * pAudStreamInfo = NULL;
    VIDEOSTREAMINFO * pVidStreamInfo = NULL;
    BINARYSTREAMINFO * pBinStreamInfo = NULL;
    WMFDecoderEx *pDecoder = NULL;
    U8_WMC *pData = NULL;
    U32_WMC cbWanted;
    U32_WMC cbActual;
    U32_WMC cbObjectOffset = 0;
    const U8_WMC* pbECData;

    if( NULL == phDecoder )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(*phDecoder);
    
    if(cbBuffer < MIN_OBJECT_SIZE)
        return WMCDec_BufferTooSmall;

    cbBuffer -= MIN_OBJECT_SIZE;

    
/*    if( cbBuffer < MIN_OBJECT_SIZE + ( 2 * sizeof( GUID_WMC ) ) + sizeof( U64_WMC ) +
                   ( 3 * sizeof( U32_WMC ) ) + sizeof( U16_WMC ) )
    {
        return( WMCDec_BufferTooSmall );
    }
*/

    cbWanted = ( 2 * sizeof( GUID_WMC ) ) + sizeof( U64_WMC ) + ( 3 * sizeof( U32_WMC ) ) + sizeof( U16_WMC );
    if(cbObjectOffset + cbWanted > cbBuffer)
    {
        return WMCDec_BufferTooSmall;
    }

    cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
    {
        return WMCDec_BufferTooSmall;
        
    }
    cbObjectOffset += cbActual;


    LoadGUID( streamType, pData );
    LoadGUID( ecStrategy, pData );
    LoadQWORD( qwOffset, pData );
    LoadDWORD( cbTypeSpecific, pData );
    LoadDWORD( cbErrConcealment, pData );
    LoadWORD( wStreamNum, pData );
    LoadDWORD( dwJunk, pData );

    wStreamNum &= 0x7F;

/*    if( cbBuffer < MIN_OBJECT_SIZE + ( 2 * sizeof( GUID_WMC ) ) + sizeof( U64_WMC ) +
                   ( 3 * sizeof( U32_WMC ) ) + sizeof( U16_WMC ) + cbTypeSpecific + cbErrConcealment )
    {
        return( WMCDec_BufferTooSmall );
    }
*/
// Amit Changed to accomodate Video stream

    if( IsEqualGUID_WMC( &CLSID_AsfXStreamTypeAcmAudio, &streamType ) )
    {
		
        pDecoder->tAudioStreamInfo[pDecoder->tHeaderInfo.wNoOfAudioStreams] = (AUDIOSTREAMINFO *) wmvalloc(sizeof(AUDIOSTREAMINFO));
        if (NULL == pDecoder->tAudioStreamInfo[pDecoder->tHeaderInfo.wNoOfAudioStreams])
            return WMCDec_BadMemory;
        memset(pDecoder->tAudioStreamInfo[pDecoder->tHeaderInfo.wNoOfAudioStreams], 0, sizeof(AUDIOSTREAMINFO));
        pAudStreamInfo = pDecoder->tAudioStreamInfo[pDecoder->tHeaderInfo.wNoOfAudioStreams];

        pDecoder->tHeaderInfo.wNoOfAudioStreams++;
        if (pDecoder->tHeaderInfo.bHasBitRateInfo !=TRUE_WMC)
            pDecoder->tHeaderInfo.wNoOfStreams++;

        pAudStreamInfo->wStreamId = wStreamNum;
        
        if (cbTypeSpecific >0)
        {
            cbWanted = cbTypeSpecific;
            if(cbObjectOffset + cbWanted > cbBuffer)
            {
                return WMCDec_BufferTooSmall;
                
            }
            cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
                
            }
            cbObjectOffset += cbActual;
        
		    tp = pData;
            pbTypeSpecific = pData;
            LoadWORD (tw ,tp);

		    switch(tw) {
            U16_WMC cbSizeWavHeader = 0;
            U8_WMC i=0;

#ifndef _ASFPARSE_ONLY_
            case WAVE_FORMAT_WMAUDIO3:
                if(cbTypeSpecific < 36)
                {
                    return WMCDec_Fail;
                }
            
                pAudStreamInfo->wFormatTag        = tw;
			    pAudStreamInfo->nVersion         = 3;
			    tp = pbTypeSpecific +  2; LoadWORD(tw,tp); 
			    pAudStreamInfo->nChannels        = tw;
			    tp = pbTypeSpecific +  4; LoadDWORD(tdw,tp); 
			    pAudStreamInfo->nSamplesPerSec   = tdw;
			    tp = pbTypeSpecific +  8; LoadDWORD(tdw,tp);
			    pAudStreamInfo->nAvgBytesPerSec  = tdw;
			    tp = pbTypeSpecific + 12; LoadWORD (tw ,tp);
                pAudStreamInfo->nBlockAlign      = tw;
                
                tp = pbTypeSpecific +  14; LoadWORD (tw ,tp);
                pAudStreamInfo->wValidBitsPerSample = tw;
                
                // Round up to the byte to get the container size
                pAudStreamInfo->nBitsPerSample      = 8 * ((tw + 7)/8);
                
                // Has V3 specific info
                // WORD at pbTypeSpecific + 18 is reserved
                tp = pbTypeSpecific + 20; LoadDWORD (tdw, tp);
                pAudStreamInfo->dwChannelMask = tdw;
            
                tp = pbTypeSpecific + 32; LoadWORD (tw ,tp);
                pAudStreamInfo->nEncodeOpt        = tw;
                pAudStreamInfo->bIsDecodable = TRUE_WMC;
                pAudStreamInfo->wmar = WMA_S_NO_MORE_FRAME;
                break;
		    case WAVE_FORMAT_WMAUDIO2:
			    if(cbTypeSpecific < 28 )
				    return WMCDec_Fail;
                pAudStreamInfo->wFormatTag        = tw;
			    pAudStreamInfo->nVersion         = 2;
			    tp = pbTypeSpecific +  2; LoadWORD(tw,tp); 
			    pAudStreamInfo->nChannels        = tw;
			    tp = pbTypeSpecific +  4; LoadDWORD(tdw,tp); 
			    pAudStreamInfo->nSamplesPerSec   = tdw;
			    tp = pbTypeSpecific +  8; LoadDWORD(tdw,tp);
			    pAudStreamInfo->nAvgBytesPerSec  = tdw;
			    tp = pbTypeSpecific + 12; LoadWORD (tw ,tp);
			    pAudStreamInfo->nBlockAlign      = tw;
			    tp = pbTypeSpecific +  14; LoadWORD (tw ,tp);
			    pAudStreamInfo->nBitsPerSample        = tw;
			    tp = pbTypeSpecific + 22; LoadWORD (tw ,tp);
			    tp = pbTypeSpecific + 18; LoadDWORD(tdw,tp);
			    pAudStreamInfo->nSamplesPerBlock = tdw;
			    pAudStreamInfo->nEncodeOpt       = tw;
    // Added for compatibility with V3
                pAudStreamInfo->wValidBitsPerSample = 16;
                 if (pAudStreamInfo->nChannels  == 2)
                    pAudStreamInfo->dwChannelMask = 3;
                 else if (pAudStreamInfo->nChannels  == 1)
                    pAudStreamInfo->dwChannelMask = 4;
                pAudStreamInfo->bIsDecodable = TRUE_WMC;
                pAudStreamInfo->wmar = WMA_S_NO_MORE_FRAME;

			    break;
		    case WAVE_FORMAT_MSAUDIO1:
			    if(cbTypeSpecific < 22 )
				    return WMCDec_Fail;
                pAudStreamInfo->wFormatTag        = tw;
			    pAudStreamInfo->nVersion         = 1;
			    tp = pbTypeSpecific +  4; LoadDWORD(tdw,tp); 
			    pAudStreamInfo->nSamplesPerSec  = tdw;
			    tp = pbTypeSpecific +  8; LoadDWORD(tdw,tp);
			    pAudStreamInfo->nAvgBytesPerSec  = tdw;
			    tp = pbTypeSpecific + 12; LoadWORD (tw ,tp);
			    pAudStreamInfo->nBlockAlign      = tw;
			    tp = pbTypeSpecific +  2; LoadWORD (tw ,tp);
			    pAudStreamInfo->nChannels        = tw;
			    tp = pbTypeSpecific +  14; LoadWORD (tw ,tp);
			    pAudStreamInfo->nBitsPerSample        = tw;
			    tp = pbTypeSpecific + 20; LoadWORD (tw,tp);
			    pAudStreamInfo->nEncodeOpt       = tw;
			    tp = pbTypeSpecific + 18; LoadWORD (tw,tp);
			    pAudStreamInfo->nSamplesPerBlock = tw;
    // Added for compatibility with V3
                pAudStreamInfo->wValidBitsPerSample = 16;
                 if (pAudStreamInfo->nChannels  == 2)
                    pAudStreamInfo->dwChannelMask = 3;
                 else if (pAudStreamInfo->nChannels  == 1)
                    pAudStreamInfo->dwChannelMask = 4;
                pAudStreamInfo->bIsDecodable = TRUE_WMC;
                pAudStreamInfo->wmar = WMA_S_NO_MORE_FRAME;

			    break;
#ifndef __NO_SPEECH__
			case WAVE_FORMAT_MSSPEECH:
			    if(cbTypeSpecific < 18 )
				    return WMCDec_Fail;
                pAudStreamInfo->wFormatTag        = tw;
			    pAudStreamInfo->nVersion         = 4;
			    tp = pbTypeSpecific +  4; LoadDWORD(tdw,tp); 
			    pAudStreamInfo->nSamplesPerSec   = tdw;
			    tp = pbTypeSpecific +  8; LoadDWORD(tdw,tp);
			    pAudStreamInfo->nAvgBytesPerSec  = tdw;
			    tp = pbTypeSpecific + 12; LoadWORD (tw ,tp);
			    pAudStreamInfo->nBlockAlign      = tw;
			    tp = pbTypeSpecific +  2; LoadWORD (tw ,tp);
			    pAudStreamInfo->nChannels        = tw;
			    tp = pbTypeSpecific +  14; LoadWORD (tw ,tp);
			    pAudStreamInfo->nBitsPerSample        = tw;
    // Added for compatibility with V3
                pAudStreamInfo->wValidBitsPerSample = 16;
                 if (pAudStreamInfo->nChannels  == 2)
                    pAudStreamInfo->dwChannelMask = 3;
                 else if (pAudStreamInfo->nChannels  == 1)
                    pAudStreamInfo->dwChannelMask = 4;
                pAudStreamInfo->bIsDecodable = TRUE_WMC;
                pAudStreamInfo->wmar = WMA_S_NO_MORE_FRAME;
                break;
#endif			    
#endif
		    default:
                pAudStreamInfo->wFormatTag         = tw;
			    pAudStreamInfo->nVersion         = 0;
			    tp = pbTypeSpecific +  4; LoadDWORD(tdw,tp); 
			    pAudStreamInfo->nSamplesPerSec   = tdw;
			    tp = pbTypeSpecific +  8; LoadDWORD(tdw,tp);
			    pAudStreamInfo->nAvgBytesPerSec  = tdw;
			    tp = pbTypeSpecific + 12; LoadWORD (tw ,tp);
			    pAudStreamInfo->nBlockAlign      = tw;
			    tp = pbTypeSpecific +  2; LoadWORD (tw ,tp);
			    pAudStreamInfo->nChannels        = tw;
			    tp = pbTypeSpecific +  14; LoadWORD (tw ,tp);
			    pAudStreamInfo->nBitsPerSample        = tw;

                // Added for compatibility with V3
                pAudStreamInfo->wValidBitsPerSample = 16;
                 if (pAudStreamInfo->nChannels   == 2)
                    pAudStreamInfo->dwChannelMask = 3;
                 else if (pAudStreamInfo->nChannels   == 1)
                    pAudStreamInfo->dwChannelMask = 4;
                pAudStreamInfo->bIsDecodable = FALSE_WMC;
		    }
        }



/*        
        pbTypeSpecific = (U8_WMC *)(( cbTypeSpecific > 0 ) ? pbBuffer : NULL);
		pbECData = ( cbErrConcealment > 0 ) ? pbBuffer + cbTypeSpecific: NULL;
		
		if( IsEqualGUID_WMC( &CLSID_AsfXSignatureAudioErrorMaskingStrategy, &ecStrategy ) )
		{
			pAudStreamInfo->cbAudioSize = ((AsfXSignatureAudioErrorMaskingData *) pbECData)->maxObjectSize;
		}
		else if( IsEqualGUID_WMC( &CLSID_AsfXAcmAudioErrorMaskingStrategy, &ecStrategy ) )
		{
			pScramblingData = (const AsfXAcmAudioErrorMaskingData *) pbECData;

#ifndef _Embedded_x86
			pAudStreamInfo->cbAudioSize = pScramblingData->virtualPacketLen * pScramblingData->span;
#else
			span = *pbECData;
			pbECData++;
                        LoadWORD(tw,pbECData); 
			pAudStreamInfo->cbAudioSize = tw * span;
#endif
			if (pScramblingData->span > 1)
				return (WMCDec_Fail );
		}
		else
		{
			return( WMCDec_Fail );
		}
		
		pAudStreamInfo->wStreamId  = wStreamNum;
		tp = pbTypeSpecific;
*/


    /* Error concealment - this can get as big as 400!!! */

        if(cbErrConcealment > 0)
        {
            if( IsEqualGUID_WMC( &CLSID_AsfXSignatureAudioErrorMaskingStrategy, &ecStrategy ) )
            {
                cbWanted = sizeof(AsfXSignatureAudioErrorMaskingData);
            }
            else if( IsEqualGUID_WMC( &CLSID_AsfXAcmAudioErrorMaskingStrategy, &ecStrategy ) )
            {
                cbWanted = 8;
            }
            else
            {
                return WMCDec_Fail;
            }

            if(cbObjectOffset + cbWanted > cbBuffer)
            {
                return WMCDec_BufferTooSmall;
            }
            cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
                
            }
            cbObjectOffset += cbErrConcealment; // Skip over the rest - cbActual;

            if(IsEqualGUID_WMC(&CLSID_AsfXSignatureAudioErrorMaskingStrategy, &ecStrategy))
            {
                pAudStreamInfo->cbAudioSize = ((AsfXSignatureAudioErrorMaskingData *)pData)->maxObjectSize;
            
            }
            else if(IsEqualGUID_WMC(&CLSID_AsfXAcmAudioErrorMaskingStrategy, &ecStrategy))
            {
                pScramblingData = (AsfXAcmAudioErrorMaskingData *)pData;
            
#ifndef _Embedded_x86
			    pAudStreamInfo->cbAudioSize = pScramblingData->virtualPacketLen * pScramblingData->span;
#else
			    pbECData = pData;
                span = *pbECData;
			    pbECData++;
                
                LoadWORD(tw,pbECData); 
			    pAudStreamInfo->cbAudioSize = tw * span;
#endif
			if (pScramblingData->span > 1)
				return (WMCDec_Fail );
            }
            else
            {
                return WMCDec_Fail;
            }
        }

		if (pAudStreamInfo->nVersion !=0)
            nBlocksPerObject = pAudStreamInfo->cbAudioSize / pAudStreamInfo->nBlockAlign;

		pAudStreamInfo->cbAudioSize = nBlocksPerObject * (pAudStreamInfo->nSamplesPerBlock) * (pAudStreamInfo->nChannels) * ((pAudStreamInfo->nBitsPerSample)/8); // Bad calculation fpr WMA3 format To be changed later after asling Navin

//        return( WMCDec_Succeeded );
    }
	else if( IsEqualGUID_WMC( &CLSID_AsfXStreamTypeIcmVideo, &streamType ) )
	{
        if (cbTypeSpecific >0)
        {
            U8_WMC cTempBuff[1024];
            U32_WMC dwDataRead =0;
            U32_WMC dwDataRemaining = cbTypeSpecific;

            if (cbTypeSpecific > MIN_WANTED)
            {
                do
                {
                    if(dwDataRemaining > MIN_WANTED)
                        cbWanted = MIN_WANTED;
                    else
                        cbWanted = dwDataRemaining;

                    cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset + dwDataRead , cbWanted, &pData, pDecoder->u32UserData);
                    memcpy(cTempBuff + dwDataRead, pData, cbActual);
                    dwDataRemaining-= cbActual;   
                    dwDataRead+=cbActual;
                }while(dwDataRead < cbTypeSpecific);

                cbObjectOffset += dwDataRead;
                pData = cTempBuff;

            
            }
            else
            {
                cbWanted = cbTypeSpecific;
                if(cbObjectOffset + cbWanted > cbBuffer)
                {
                    return WMCDec_BufferTooSmall;
                
                }
                cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

                if(cbActual != cbWanted)
                {
                    return WMCDec_BufferTooSmall;
                
                }
                cbObjectOffset += cbActual;
            }
        

		    if (!IsEqualGUID_WMC( &CLSID_AsfXNullErrorMaskingStrategy, &ecStrategy))
		    {			
			    return WMCDec_Fail;
		    }

            pGen = (AsfXGenericImageTypeSpecific *)pData;

            if (NULL == pGen)
			    return WMCDec_Fail;
		    if (0x2 != pGen->flags)
			    return WMCDec_Fail;

            pDecoder->tVideoStreamInfo[pDecoder->tHeaderInfo.wNoOfVideoStreams] = (VIDEOSTREAMINFO *) wmvalloc(sizeof(VIDEOSTREAMINFO));
            if (NULL == pDecoder->tVideoStreamInfo[pDecoder->tHeaderInfo.wNoOfVideoStreams])
                return WMCDec_BadMemory;
            pVidStreamInfo = pDecoder->tVideoStreamInfo[pDecoder->tHeaderInfo.wNoOfVideoStreams];
            
            memset(pDecoder->tVideoStreamInfo[pDecoder->tHeaderInfo.wNoOfVideoStreams], 0, sizeof(VIDEOSTREAMINFO));

            pDecoder->tHeaderInfo.wNoOfVideoStreams++;    
            if (pDecoder->tHeaderInfo.bHasBitRateInfo !=TRUE_WMC)
                pDecoder->tHeaderInfo.wNoOfStreams++;

            tp = pData;
		
		    LoadDWORD(tdw,tp); 	pVidStreamInfo->windowWidth= tdw;
		    LoadDWORD(tdw,tp); 	pVidStreamInfo->windowHeight = tdw;
		    LoadBYTE(tb,tp); 	pVidStreamInfo->flags = tb ;
		    LoadWORD(tw, tp);	pVidStreamInfo->imageInfoLen = tw;
		    pVidStreamInfo->wStreamId = wStreamNum;

		    LoadDWORD(tdw,tp); 	pVidStreamInfo->biSize  = tdw;
		    LoadDWORD(tdw,tp);  pVidStreamInfo->biWidth = tdw; 
		    LoadDWORD(tdw,tp); 	pVidStreamInfo->biHeight = tdw; 
		    LoadWORD(tw,tp); 	pVidStreamInfo->biPlanes = tw; 
		    LoadWORD(tw,tp); 	pVidStreamInfo->biBitCount = tw; 
		    LoadDWORD(tdw,tp);  pVidStreamInfo->biCompression = tdw; 


		    pbminfo = (BITMAPINFOHEADER *)(&(pGen->imageInfo));

            LoadDWORD(tdw,tp); 	pVidStreamInfo->biSizeImage = tdw; 
		    LoadDWORD(tdw,tp);  pVidStreamInfo->biXPelsPerMeter = tdw; 
		    LoadDWORD(tdw,tp);  pVidStreamInfo->biYPelsPerMeter = tdw; 
		    LoadDWORD(tdw,tp); 	pVidStreamInfo->biClrUsed = tdw; 
		    LoadDWORD(tdw,tp);  pVidStreamInfo->biClrImportant = tdw; 
		    
		    if (pVidStreamInfo->imageInfoLen > sizeof(BITMAPINFOHEADER) )
		    {
			    memcpy(pVidStreamInfo->bAdditionalInfo, (pData+11+sizeof(BITMAPINFOHEADER)),pVidStreamInfo->imageInfoLen - sizeof(BITMAPINFOHEADER) );
		    }
       }       
        
	}

	else
    {
        // Binary Stream
        pDecoder->tBinaryStreamInfo[pDecoder->tHeaderInfo.wNoOfBinaryStreams] = (BINARYSTREAMINFO *) wmvalloc(sizeof(BINARYSTREAMINFO));
        if (NULL == pDecoder->tBinaryStreamInfo[pDecoder->tHeaderInfo.wNoOfBinaryStreams])
            return WMCDec_BadMemory;
        pBinStreamInfo = pDecoder->tBinaryStreamInfo[pDecoder->tHeaderInfo.wNoOfBinaryStreams];

        pDecoder->tHeaderInfo.wNoOfBinaryStreams++; 
        if (pDecoder->tHeaderInfo.bHasBitRateInfo !=TRUE_WMC)
            pDecoder->tHeaderInfo.wNoOfStreams++;
        
        pBinStreamInfo->wStreamId = wStreamNum;
//        pBinStreamInfo->bIsDecodable = FALSE_WMC;
//        pBinStreamInfo->bTobeDecoded = FALSE_WMC;
        pBinStreamInfo->bWantOutput = FALSE_WMC;
    }

    pDecoder->tHeaderInfo.cbCurrentPacketOffset +=(U64_WMC)cbBuffer; // Use whole Object  

    return( WMCDec_Succeeded );
}


/****************************************************************************/
U32_WMC GetASFVarField( U8_WMC bType, const U8_WMC *p, U32_WMC *pcbOffset )
{
    U32_WMC dwVar = 0;

    switch( bType )
    {
    case 0x01:
        dwVar = (U32_WMC)(*p);
        *pcbOffset += 1;
        break;
    case 0x02:
    {
        U16_WMC w;
        GetUnalignedWord( p, w );
        dwVar = w;
        *pcbOffset += 2;
        break;
    }
    case 0x03:
        GetUnalignedDword( p, dwVar );
        *pcbOffset += 4;
        break;
    }

    return( dwVar );
}

/****************************************************************************/
tWMCDecStatus WMCDecParsePacketHeader(HWMCDECODER hDecoder)
{
    U8_WMC b;
    PACKET_PARSE_INFO_EX *pParseInfoEx;

    U8_WMC *pData = NULL;
    U32_WMC cbWanted;
    U32_WMC cbActual;
    U32_WMC cbLocalOffset=0;
    WMFDecoderEx *pDecoder = NULL;

    if( NULL == hDecoder )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(hDecoder);

    pParseInfoEx = &(pDecoder->tHeaderInfo.ppex);

//    cbWanted = 24;              /* at most */
    
    cbWanted = 1;
    cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
    {
        return WMCDec_BufferTooSmall;
        
    }

    /* ParsePacket begins */


    pParseInfoEx->fParityPacket = FALSE_WMC;
    pParseInfoEx->cbParseOffset = 0;

    b = pData[cbLocalOffset];
    
    pParseInfoEx->fEccPresent = (BOOL)( (b&0x80) == 0x80 );
    pParseInfoEx->bECLen = 0;

    if(pParseInfoEx->fEccPresent)
    {
        if(b&0x10)
        {
            pParseInfoEx->fParityPacket = TRUE;
            return WMCDec_Succeeded;
        }

        if(b&0x60)
        {
            return WMCDec_Fail;
        }

        pParseInfoEx->bECLen = (b&0x0f);
        if(pParseInfoEx->bECLen != 2)
        {
            return WMCDec_Fail;
        }

        pParseInfoEx->cbParseOffset = (U32_WMC)(1 + pParseInfoEx->bECLen);
//////////////////////////////////////////////////////////////////////////////
        cbWanted = 1;              /* at least */

        cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
        
        }

        b = pData[cbLocalOffset];

//////////////////////////////////////////////////////////////////////////////
    }

    pParseInfoEx->cbPacketLenTypeOffset = pParseInfoEx->cbParseOffset;

    pParseInfoEx->bPacketLenType = (b&0x60)>>5;
    if(pParseInfoEx->bPacketLenType != 0
       && pParseInfoEx->bPacketLenType != 2)
    {
        return WMCDec_Fail;
    }

    pParseInfoEx->bPadLenType = (b&0x18)>>3;
    if(pParseInfoEx->bPadLenType == 3)
    {
        return WMCDec_Fail;
    }

    pParseInfoEx->bSequenceLenType = (b&0x06)>>1;

    pParseInfoEx->fMultiPayloads = (BOOL)(b&0x01);

    pParseInfoEx->cbParseOffset++;

//////////////////////////////////////////////////////////////////////////////
        cbWanted = 1;              /* at least */
        cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
        
        }

        b = pData[cbLocalOffset];

//////////////////////////////////////////////////////////////////////////////

    pParseInfoEx->bOffsetBytes = 4;
    pParseInfoEx->bOffsetLenType = 3;

    if(b != 0x5d)
    {
        if((b&0xc0) != 0x40)
        {
            return WMCDec_Fail;
        }

        if((b&0x30) != 0x10)
        {
            return WMCDec_Fail;
        }

        pParseInfoEx->bOffsetLenType = (b&0x0c)>>2;
        if(pParseInfoEx->bOffsetLenType == 0)
        {
            return WMCDec_Fail;
        }
        else if(pParseInfoEx->bOffsetLenType < 3)
        {
            pParseInfoEx->bOffsetBytes = pParseInfoEx->bOffsetLenType;
        }

        if((b&0x03) != 0x01)
        {
            return WMCDec_Fail;
        }
    }

    pParseInfoEx->cbParseOffset++;

//////////////////////////////////////////////////////////////////////////////
    pParseInfoEx->cbPacketLenOffset = pParseInfoEx->cbParseOffset; 
    switch(pParseInfoEx->bPacketLenType)
    {
    case 0x01:
        {
            cbWanted =1;
            cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
        
            }
            pParseInfoEx->cbExplicitPacketLength =  (U32_WMC)(*pData);
            pParseInfoEx->cbParseOffset++;
            break;
        }
    case 0x02:
        {
            U16_WMC w;
            cbWanted =2;
            cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
        
            }
            GetUnalignedWord(pData, w);
            pParseInfoEx->cbExplicitPacketLength =  (U32_WMC)(w);
            pParseInfoEx->cbParseOffset+=2;
        
            break;

        }
    case 0x03:
        {
            U32_WMC dw;
            cbWanted =4;
            cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
        
            }
            GetUnalignedDword(pData, dw);
            pParseInfoEx->cbExplicitPacketLength =  dw;
            pParseInfoEx->cbParseOffset+=4;
            break;
        }
    default:
        cbWanted =0;
    }

//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
    pParseInfoEx->cbSequenceOffset = pParseInfoEx->cbParseOffset;
    switch(pParseInfoEx->bSequenceLenType)
    {
    case 0x01:
        {
            cbWanted =1;
            cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
        
            }
            pParseInfoEx->dwSequenceNum =  (U32_WMC)(*pData);
            pParseInfoEx->cbParseOffset++;
            break;
        }
    case 0x02:
        {
            U16_WMC w;
            cbWanted =2;
            cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
        
            }
            GetUnalignedWord(pData, w);
            pParseInfoEx->dwSequenceNum =  (U32_WMC)(w);
            pParseInfoEx->cbParseOffset+=2;
        
            break;

        }
    case 0x03:
        {
            U32_WMC dw;
            cbWanted =4;
            cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
        
            }
            GetUnalignedDword(pData, dw);
            pParseInfoEx->dwSequenceNum =  dw;
            pParseInfoEx->cbParseOffset+=4;
            break;
        }
    default:
        cbWanted =0;
    }

///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////    
    pParseInfoEx->cbPadLenOffset = pParseInfoEx->cbParseOffset;
    switch(pParseInfoEx->bPadLenType)
    {
    case 0x01:
        {
            cbWanted =1;
            cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
        
            }
            pParseInfoEx->cbPadding =  (U32_WMC)(*pData);
            pParseInfoEx->cbParseOffset++;
            break;
        }
    case 0x02:
        {
            U16_WMC w;
            cbWanted =2;
            cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
        
            }
            GetUnalignedWord(pData, w);
            pParseInfoEx->cbPadding =  (U32_WMC)(w);
            pParseInfoEx->cbParseOffset+=2;
        
            break;

        }
    case 0x03:
        {
            U32_WMC dw;
            cbWanted =4;
            cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
        
            }
            GetUnalignedDword(pData, dw);
            pParseInfoEx->cbPadding =  dw;
            pParseInfoEx->cbParseOffset+=4;
            break;
        }
    default:
        cbWanted =0;
    }

    
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// Now read 6 bytes
    
    cbWanted =6;
    cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
    {
        return WMCDec_BufferTooSmall;

    }

/////////////////////////////////////////////////////////////////////////////////
    GetUnalignedDword(&pData[cbLocalOffset], pParseInfoEx->dwSCR);

/////////////////////////////////////////////////////////////////////////////////
    
    pParseInfoEx->cbParseOffset += 4;

//////////////////////////////////////////////////////////////////////////////////
    GetUnalignedWord(&pData[cbLocalOffset+4], pParseInfoEx->wDuration);
    
////////////////////////////////////////////////////////////////////////////////////
    
    pParseInfoEx->cbParseOffset += 2;


    /* ParsePacketEx begins */
    if( pParseInfoEx->fEccPresent && pParseInfoEx->fParityPacket ) 
    {
        return WMCDec_Succeeded;
    }


    pParseInfoEx->cbPayLenTypeOffset = 0;
    pParseInfoEx->bPayLenType = 0;
    pParseInfoEx->bPayBytes = 0;
    pParseInfoEx->cPayloads = 1;

    if(pParseInfoEx->fMultiPayloads)
    {
//////////////////////////////////////////////////////
        cbWanted =1;
        cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;

        }

        b = pData[cbLocalOffset];
//////////////////////////////////////////////////////
        pParseInfoEx->cbPayLenTypeOffset = pParseInfoEx->cbParseOffset;

        pParseInfoEx->bPayLenType = (b&0xc0)>>6;
        if(pParseInfoEx->bPayLenType != 2
           && pParseInfoEx->bPayLenType != 1)
        {
            return WMCDec_Fail;
        }

        pParseInfoEx->bPayBytes = pParseInfoEx->bPayLenType;

        pParseInfoEx->cPayloads = (U32_WMC)(b&0x3f);
        if(pParseInfoEx->cPayloads == 0)
        {
            return WMCDec_Fail;
        }

        pParseInfoEx->cbParseOffset++;
    }

    return WMCDec_Succeeded;
}


/****************************************************************************/
tWMCDecStatus WMCDecParsePayloadHeader(HWMCDECODER hDecoder)
{
    U32_WMC cbDummy;
    U32_WMC cbParseOffset;
    U32_WMC cbRepDataOffset;
    U32_WMC dwPayloadSize;
    PACKET_PARSE_INFO_EX *pParseInfoEx;
    PAYLOAD_MAP_ENTRY_EX *pPayload;
    U32_WMC cbLocalOffset=0;
    WMFDecoderEx *pDecoder = NULL;

    U8_WMC *pData = NULL;
    U32_WMC cbWanted;
    U32_WMC cbActual;

    U16_WMC wTotalDataBytes=0;

    if( NULL == hDecoder )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(hDecoder);

    pParseInfoEx = &(pDecoder->tHeaderInfo.ppex);
    pPayload = &(pDecoder->tHeaderInfo.payload);



//    cbWanted = 24;              /* at most */

    cbWanted = 2;              /* at least */
    cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
    {
        return WMCDec_BufferTooSmall;
    }

    cbParseOffset = 0;

    /* Loop in ParsePacketAndPayloads */

    pPayload->cbPacketOffset = (U16_WMC)pParseInfoEx->cbParseOffset;
    pPayload->bStreamId = (pData[cbParseOffset])&0x7f; // Amit to get correct Streamid 
    pPayload->bIsKeyFrame = (((pData[cbParseOffset]) &0x80) >> 7);
    pPayload->bObjectId = pData[cbParseOffset + 1];
    cbDummy = 0;
//////////////////////////////////////////////////////////////////////////////////////
/*    pPayload->cbObjectOffset = GetASFVarField(pParseInfoEx->bOffsetLenType,
                                              &pData[cbParseOffset + 2],
                                              &cbDummy);

  */  switch(pParseInfoEx->bOffsetLenType)
    {
    case 0x01:
        {
            cbWanted =1;

            cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset+2, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
            }
            pPayload->cbObjectOffset =  (U32_WMC)(*pData);
            break;
        }
    case 0x02:
        {
            U16_WMC w;
            cbWanted =2;
            cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset+2, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
            }
             GetUnalignedWord(pData, w);
            pPayload->cbObjectOffset =  (U32_WMC)(w);
        
            break;

        }
    case 0x03:
        {
            U32_WMC dw;
            cbWanted =4;
            cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset+2, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
            }
            GetUnalignedDword(pData, dw);
            pPayload->cbObjectOffset =  dw;
            break;
        }
    default:
        cbWanted =0;
    }

//////////////////////////////////////////////////////////////////////////////////////

    cbRepDataOffset = cbParseOffset + 2 + pParseInfoEx->bOffsetBytes;

///////////////////////////////////////////////////////////////////////////////////////

    cbWanted =1;
    cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset + cbRepDataOffset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
    {
        return WMCDec_BufferTooSmall;
    }
    pPayload->cbRepData = pData[cbLocalOffset];

///////////////////////////////////////////////////////////////////////////////////////
    pPayload->msObjectPres = 0xffffffff;

    if(pPayload->cbRepData == 1)
    {
        pPayload->msObjectPres = pPayload->cbObjectOffset;
        pPayload->cbObjectOffset = 0;
        pPayload->cbObjectSize = 0;
        pPayload->bIsCompressedPayload =1;

        cbWanted =3;
        cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset + cbRepDataOffset + 1, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
        }
		pPayload->dwDeltaPresTime = pData[0/*cbRepDataOffset +1*/];

		if( pParseInfoEx->fMultiPayloads)
		{
            GetUnalignedWord( &pData[ cbLocalOffset + 1 ],wTotalDataBytes );
		}
		else
		{
			wTotalDataBytes = 0;
		}
    }
    else if(pPayload->cbRepData >= 8)
    {
        cbWanted =8;
        cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset + cbRepDataOffset + 1, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
        }
        GetUnalignedDword(&pData[cbLocalOffset],
                          pPayload->cbObjectSize);
        GetUnalignedDword(&pData[cbLocalOffset+ 4],
                          pPayload->msObjectPres);

        pPayload->bIsCompressedPayload =0;
    }

    pPayload->cbTotalSize = 1 + 1 + pParseInfoEx->bOffsetBytes + 1 + pPayload->cbRepData;

    if(pParseInfoEx->fMultiPayloads)
    {
        cbDummy = 0;

//////////////////////////////////////////////////////////////////////////////////////
      /*  dwPayloadSize = GetASFVarField(pParseInfoEx->bPayLenType,
                                       &pData[cbParseOffset + pPayload->cbTotalSize],
                                       &cbDummy);
*/
        switch(pParseInfoEx->bPayLenType)
        {
        case 0x01:
            {
                cbWanted =1;
                cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset + pPayload->cbTotalSize, cbWanted, &pData, pDecoder->u32UserData);
                if(cbActual != cbWanted)
                {
                    return WMCDec_BufferTooSmall;
                }

                dwPayloadSize =  (U32_WMC)(*pData);
                break;
            }
        case 0x02:
            {
                U16_WMC w;
                cbWanted =2;
                cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset + pPayload->cbTotalSize, cbWanted, &pData, pDecoder->u32UserData);
                if(cbActual != cbWanted)
                {
                    return WMCDec_BufferTooSmall;
                }
                GetUnalignedWord(pData, w);
                dwPayloadSize =  (U32_WMC)(w);
        
                break;

            }
        case 0x03:
            {
                U32_WMC dw;
                cbWanted =4;
                cbActual = WMCDecCBGetData(hDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + pParseInfoEx->cbParseOffset + pPayload->cbTotalSize, cbWanted, &pData, pDecoder->u32UserData);
                if(cbActual != cbWanted)
                {
                    return WMCDec_BufferTooSmall;
                }
                GetUnalignedDword(pData, dw);
                dwPayloadSize =  dw;
                break;
            }
        default:
            cbWanted =0;
        }

//////////////////////////////////////////////////////////////////////////////////////

    
    }
    else if(pParseInfoEx->cbExplicitPacketLength > 0)
    {
        dwPayloadSize = pParseInfoEx->cbExplicitPacketLength
                      - pParseInfoEx->cbParseOffset
                      - pPayload->cbTotalSize
                      - pParseInfoEx->cbPadding;
    }
    else
    {
        dwPayloadSize = pDecoder->tHeaderInfo.cbPacketSize
                      - pParseInfoEx->cbParseOffset
                      - pPayload->cbTotalSize
                      - pParseInfoEx->cbPadding;
    }
    if (0 == wTotalDataBytes)
        wTotalDataBytes = (U16_WMC) dwPayloadSize;

    pPayload->cbPayloadSize = (U16_WMC)dwPayloadSize;

    pPayload->cbTotalSize += pParseInfoEx->bPayBytes
                          + (U16_WMC)pPayload->cbPayloadSize;

 	pPayload->wTotalDataBytes = wTotalDataBytes; // Amit

/*    if( 1 == pPayload->cbRepData )
    {
        pPayload->cbPayloadSize--;
    }
*/
    pParseInfoEx->cbParseOffset += pPayload->cbTotalSize;

    if(pParseInfoEx->cbParseOffset > pDecoder->tHeaderInfo.cbPacketSize
       || (pParseInfoEx->cbParseOffset == pDecoder->tHeaderInfo.cbPacketSize
           && pDecoder->tHeaderInfo.iPayload < pParseInfoEx->cPayloads - 1))
    {
        return WMCDec_BadData;
    }

    return WMCDec_Succeeded;
}

/****************************************************************************/
tWMCDecStatus LoadContentDescriptionObject(
                    U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder)

{


    U16_WMC uiTitle_len = 0;
    U16_WMC uiAuthor_len = 0;
    U16_WMC uiCopyright_len = 0;
    U16_WMC uiDescription_len = 0; 
    U16_WMC uiRating_len = 0;
//    U8_WMC *offset = NULL;
    WMFDecoderEx *pDecoder = NULL;
    U8_WMC *pData = NULL;
    U32_WMC cbWanted;
    U32_WMC cbActual;
    U32_WMC cbObjectOffset = 0;

    if( NULL == phDecoder )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(*phDecoder);
    
    if(cbBuffer < MIN_OBJECT_SIZE)
        return WMCDec_BufferTooSmall;

    cbBuffer -= MIN_OBJECT_SIZE;

    cbWanted = 5 * sizeof( U16_WMC );
    if(cbObjectOffset + cbWanted > cbBuffer)
    {
        return WMCDec_BufferTooSmall;
        
    }

    cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
    {
        return WMCDec_BufferTooSmall;
        
    }
    cbObjectOffset += cbActual;

    LoadWORD( uiTitle_len, pData );
    LoadWORD( uiAuthor_len, pData );
    LoadWORD( uiCopyright_len, pData );
    LoadWORD( uiDescription_len, pData );
    LoadWORD( uiRating_len, pData );

    pDecoder->m_pContentDesc = (WMCContentDescription *)wmvalloc(sizeof(WMCContentDescription));
    if (pDecoder->m_pContentDesc == NULL)
        return (WMCDec_BadMemory);
    
    pDecoder->m_pContentDesc->uiTitle_len = uiTitle_len / sizeof(U16Char_WMC);
    pDecoder->m_pContentDesc->uiAuthor_len = uiAuthor_len / sizeof(U16Char_WMC);
    pDecoder->m_pContentDesc->uiCopyright_len = uiCopyright_len / sizeof(U16Char_WMC);
    pDecoder->m_pContentDesc->uiDescription_len = uiDescription_len / sizeof(U16Char_WMC);
    pDecoder->m_pContentDesc->uiRating_len = uiRating_len / sizeof(U16Char_WMC);



    pDecoder->m_pContentDesc->pchTitle = NULL;
    pDecoder->m_pContentDesc->pchAuthor = NULL;
    pDecoder->m_pContentDesc->pchCopyright = NULL;
    pDecoder->m_pContentDesc->pchDescription = NULL;
    pDecoder->m_pContentDesc->pchRating = NULL;

    
    
//    offset = (U8_WMC*) pbBuffer;
    if (uiTitle_len > 0)
    {
        cbWanted = uiTitle_len;
        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            return WMCDec_BufferTooSmall;
            
        }

        cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
            
        }
        cbObjectOffset += cbActual;
        
        pDecoder->m_pContentDesc->pchTitle = (U16Char_WMC *)wmvalloc(uiTitle_len);
        if (pDecoder->m_pContentDesc->pchTitle == NULL)
            return( WMCDec_BadMemory );
        else
            memcpy(pDecoder->m_pContentDesc->pchTitle, pData, cbActual );
#ifndef LITTLE_ENDIAN
        SwapWstr((U16Char_WMC *)pDecoder->m_pContentDesc->pchTitle, uiTitle_len / sizeof(U16Char_WMC));
#endif
    }
    
    if (uiAuthor_len > 0)
    {
        cbWanted = uiAuthor_len;
        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            return WMCDec_BufferTooSmall;
            
        }

        cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
            
        }
        cbObjectOffset += cbActual;

        
        pDecoder->m_pContentDesc->pchAuthor = (U16Char_WMC *)wmvalloc (uiAuthor_len);
        if (pDecoder->m_pContentDesc->pchAuthor == NULL)
            return( WMCDec_BadMemory );
        else
            memcpy(pDecoder->m_pContentDesc->pchAuthor, pData, cbActual );
#ifndef LITTLE_ENDIAN
        SwapWstr((U16Char_WMC *)pDecoder->m_pContentDesc->pchAuthor, uiAuthor_len / sizeof(U16Char_WMC));
#endif
    }
    if (uiCopyright_len > 0)
    {
        cbWanted = uiCopyright_len;
        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            return WMCDec_BufferTooSmall;
            
        }

        cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
            
        }
        cbObjectOffset += cbActual;

        pDecoder->m_pContentDesc->pchCopyright = (U16Char_WMC *)wmvalloc (uiCopyright_len);
        if (pDecoder->m_pContentDesc->pchCopyright == NULL)
            return( WMCDec_BadMemory );
        else
            memcpy(pDecoder->m_pContentDesc->pchCopyright, pData, cbActual );
#ifndef LITTLE_ENDIAN
        SwapWstr((U16Char_WMC *)pDecoder->m_pContentDesc->pchCopyright, uiCopyright_len / sizeof(U16Char_WMC));
#endif
    }
    if (uiDescription_len > 0)
    {
        cbWanted = uiDescription_len;
        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            return WMCDec_BufferTooSmall;
            
        }

        cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
            
        }
        cbObjectOffset += cbActual;

        pDecoder->m_pContentDesc->pchDescription = (U16Char_WMC *)wmvalloc (uiDescription_len);
        if (pDecoder->m_pContentDesc->pchDescription == NULL)
            return( WMCDec_BadMemory );
        else
            memcpy(pDecoder->m_pContentDesc->pchDescription, pData, cbActual );
#ifndef LITTLE_ENDIAN
        SwapWstr((U16Char_WMC *)pDecoder->m_pContentDesc->pchDescription, uiDescription_len / sizeof(U16Char_WMC));
#endif
    }
    if (uiRating_len > 0)
    {
        cbWanted = uiRating_len;
        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            return WMCDec_BufferTooSmall;
            
        }

        cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
            
        }
        cbObjectOffset += cbActual;

        pDecoder->m_pContentDesc->pchRating = (U16Char_WMC *)wmvalloc (uiRating_len);
        if (pDecoder->m_pContentDesc->pchRating == NULL)
            return( WMCDec_BadMemory );
        else
            memcpy(pDecoder->m_pContentDesc->pchRating, pData, cbActual );
#ifndef LITTLE_ENDIAN
        SwapWstr((U16Char_WMC *)pDecoder->m_pContentDesc->pchRating, uiRating_len / sizeof(U16Char_WMC));
#endif
        
    }
    pDecoder->tHeaderInfo.cbCurrentPacketOffset +=(U64_WMC)cbBuffer; // Use whole Object  
    
    return( WMCDec_Succeeded );

}
/****************************************************************************/
tWMCDecStatus
LoadMarkerObject(
                    U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder)
{
    U32_WMC cbObjectOffset = 0;

    GUID_WMC m_gMarkerStrategy;
    U16_WMC m_wAlignment;
    U16_WMC m_wNameLen;
    U16_WMC tw;
    U32_WMC i, j;
    WMFDecoderEx *pDecoder = NULL;

    U8_WMC *pData = NULL;
    U32_WMC cbWanted;
    U32_WMC cbActual;
	U64_WMC qTemp;

    if( NULL == phDecoder )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(*phDecoder);
    
    if(cbBuffer < MIN_OBJECT_SIZE)
        return WMCDec_BufferTooSmall;

    cbBuffer -= MIN_OBJECT_SIZE;

    cbWanted = 24;
    if(cbObjectOffset + cbWanted > cbBuffer)
    {
        return WMCDec_BufferTooSmall;
        
    }

    cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
    {
        return WMCDec_BufferTooSmall;
        
    }
    cbObjectOffset += cbActual;

    LoadGUID (m_gMarkerStrategy , pData);
    LoadDWORD(pDecoder->m_dwMarkerNum   , pData);
    LoadWORD (m_wAlignment      , pData);
    LoadWORD (m_wNameLen        , pData);

    if (pDecoder->m_dwMarkerNum == 0)
    {
        pDecoder->tHeaderInfo.cbCurrentPacketOffset +=(U64_WMC)cbBuffer; // Use whole Object    
        return( WMCDec_Succeeded );
    }
    
    
	if (m_wNameLen > 0) // Bug in Specs
	{
		cbWanted = m_wNameLen;
        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            return WMCDec_BufferTooSmall;
            
        }

        cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
            
        }
        cbObjectOffset += cbActual;
	
	}

 //   pbBuffer += m_wNameLen;

    (pDecoder->m_pMarkers) = (WMCMarkerEntry *)wmvalloc(sizeof(WMCMarkerEntry)*(pDecoder->m_dwMarkerNum));
    if (NULL == (pDecoder->m_pMarkers))
        return (WMCDec_BadMemory);

    for (j = 0; j < pDecoder->m_dwMarkerNum; j++) 
    {

        cbWanted = 18;
        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            return WMCDec_BufferTooSmall;
            
        }

        cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
            
        }
        cbObjectOffset += cbActual;
        
		
        LoadQWORD(qTemp, pData);
//		(pDecoder->m_pMarkers)[j].m_qOffset.dwHi = qTemp.dwHi; 
//		(pDecoder->m_pMarkers)[j].m_qOffset.dwLo = qTemp.dwLo;
		(pDecoder->m_pMarkers)[j].m_qOffset = qTemp; 

        LoadQWORD(qTemp, pData);
//		(pDecoder->m_pMarkers)[j].m_qtime.dwHi = qTemp.dwHi; 
//		(pDecoder->m_pMarkers)[j].m_qtime.dwLo = qTemp.dwLo;
		(pDecoder->m_pMarkers)[j].m_qtime = qTemp; 


        LoadWORD ((pDecoder->m_pMarkers)[j].m_wEntryLen , pData);

        cbWanted = (pDecoder->m_pMarkers)[j].m_wEntryLen;
        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            return WMCDec_BufferTooSmall;
            
        }

        cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
            
        }
        cbObjectOffset += cbActual;
        
        LoadDWORD((pDecoder->m_pMarkers)[j].m_dwSendTime, pData);
        LoadDWORD((pDecoder->m_pMarkers)[j].m_dwFlags, pData);
        LoadDWORD((pDecoder->m_pMarkers)[j].m_dwDescLen, pData);

        (pDecoder->m_pMarkers)[j].m_pwDescName = (U16Char_WMC *)wmvalloc(sizeof(U16Char_WMC)*((pDecoder->m_pMarkers)[j].m_dwDescLen));
        if (NULL == (pDecoder->m_pMarkers)[j].m_pwDescName)
            return (WMCDec_BadMemory);

        for (i=0;i<(pDecoder->m_pMarkers)[j].m_dwDescLen;i++) {
            LoadWORD(tw, pData);
            (pDecoder->m_pMarkers)[j].m_pwDescName[i] = tw;
        }
/*		if ((pDecoder->m_pMarkers)[j].m_wEntryLen > (12+ 2*((pDecoder->m_pMarkers)[j].m_dwDescLen)))
		{
			pbBuffer += ((pDecoder->m_pMarkers)[j].m_wEntryLen - (12+ 2*((pDecoder->m_pMarkers)[j].m_dwDescLen)));	
		
		}
*/
    }
    pDecoder->tHeaderInfo.cbCurrentPacketOffset +=(U64_WMC)cbBuffer; // Use whole Object    

    return WMCDec_Succeeded;
}

/****************************************************************************/
tWMCDecStatus LoadExtendedContentDescriptionObject(
                    U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder)
{


    U16_WMC cDescriptors;

    I32_WMC i;
    WMFDecoderEx *pDecoder = NULL;
    U32_WMC cbTrack;

    U8_WMC *pData = NULL;
    U32_WMC cbWanted;
    U32_WMC cbActual;
    U32_WMC cbObjectOffset = 0;

    if( NULL == phDecoder )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(*phDecoder);
    
    if(cbBuffer < MIN_OBJECT_SIZE)
        return WMCDec_BufferTooSmall;

    cbBuffer -= MIN_OBJECT_SIZE;
    cbTrack = cbBuffer;

    cbWanted = sizeof(U16_WMC);
    if(cbObjectOffset + cbWanted > cbBuffer)
    {
        return WMCDec_BufferTooSmall;
        
    }

    cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
    {
        return WMCDec_BufferTooSmall;
        
    }
    cbObjectOffset += cbActual;
    cbTrack -=cbActual;


    LoadWORD( cDescriptors, pData );
//    cbBuffer -= sizeof(U16_WMC);


    pDecoder->m_pExtendedContentDesc = (WMCExtendedContentDesc *)wmvalloc(sizeof(WMCExtendedContentDesc));
    if (pDecoder->m_pExtendedContentDesc == NULL)
        return (WMCDec_BadMemory);

    pDecoder->m_pExtendedContentDesc->cDescriptors = cDescriptors;
    pDecoder->m_pExtendedContentDesc->pDescriptors = NULL;
    pDecoder->m_pExtendedContentDesc->pDescriptors = (ECD_DESCRIPTOR *)wmvalloc(cDescriptors * sizeof(ECD_DESCRIPTOR));
    if(pDecoder->m_pExtendedContentDesc->pDescriptors == NULL)
        return( WMCDec_BadMemory );

    
    if(cbBuffer < pDecoder->m_pExtendedContentDesc->cDescriptors * sizeof(U16_WMC))
        return( WMCDec_BufferTooSmall );

    for(i = 0; i < cDescriptors; i++) 
    {

        cbWanted = sizeof(U16_WMC);
        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            return WMCDec_BufferTooSmall;
            
        }

        cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
            
        }
        cbObjectOffset += cbActual;

        LoadWORD(pDecoder->m_pExtendedContentDesc->pDescriptors[i].cbName, pData);
        cbTrack -=cbActual;

        if(cbTrack < pDecoder->m_pExtendedContentDesc->pDescriptors[i].cbName + sizeof(U16_WMC) * 2)
            return( WMCDec_BufferTooSmall );
        pDecoder->m_pExtendedContentDesc->pDescriptors[i].pwszName = NULL;
        pDecoder->m_pExtendedContentDesc->pDescriptors[i].pwszName = (U16Char_WMC *)wmvalloc(pDecoder->m_pExtendedContentDesc->pDescriptors[i].cbName);
        if (pDecoder->m_pExtendedContentDesc->pDescriptors[i].pwszName == NULL)
            return( WMCDec_BadMemory );
        else
        {
            cbWanted = pDecoder->m_pExtendedContentDesc->pDescriptors[i].cbName + sizeof(U16_WMC) * 2;
            if(cbObjectOffset + cbWanted > cbBuffer)
            {
                return WMCDec_BufferTooSmall;
                
            }

            cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
                
            }
            cbObjectOffset += cbActual;
            memcpy(pDecoder->m_pExtendedContentDesc->pDescriptors[i].pwszName, pData, pDecoder->m_pExtendedContentDesc->pDescriptors[i].cbName);
        }
#ifndef LITTLE_ENDIAN
        SwapWstr((U16Char_WMC *)pDecoder->m_pExtendedContentDesc->pDescriptors[i].pwszName, pDecoder->m_pExtendedContentDesc->pDescriptors[i].cbName / sizeof(U16Char_WMC));
#endif
        pData += pDecoder->m_pExtendedContentDesc->pDescriptors[i].cbName;
        cbTrack -= pDecoder->m_pExtendedContentDesc->pDescriptors[i].cbName;
        LoadWORD(pDecoder->m_pExtendedContentDesc->pDescriptors[i].data_type, pData);
        cbTrack -= sizeof(U16_WMC);
        LoadWORD(pDecoder->m_pExtendedContentDesc->pDescriptors[i].cbValue, pData);
        cbTrack -= sizeof(U16_WMC);

        if(cbTrack < pDecoder->m_pExtendedContentDesc->pDescriptors[i].cbValue)
            return( WMCDec_BufferTooSmall );
        pDecoder->m_pExtendedContentDesc->pDescriptors[i].uValue.pbBinary = NULL;
        pDecoder->m_pExtendedContentDesc->pDescriptors[i].uValue.pbBinary = (U8_WMC *)wmvalloc(pDecoder->m_pExtendedContentDesc->pDescriptors[i].cbValue);
        if (pDecoder->m_pExtendedContentDesc->pDescriptors[i].uValue.pbBinary == NULL)
            return( WMCDec_BadMemory );
        else
        {
            cbWanted =  pDecoder->m_pExtendedContentDesc->pDescriptors[i].cbValue;
            if(cbObjectOffset + cbWanted > cbBuffer)
            {
                return WMCDec_BufferTooSmall;
                
            }

            cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
            }
            cbObjectOffset += cbActual;
            memcpy(pDecoder->m_pExtendedContentDesc->pDescriptors[i].uValue.pbBinary, pData,pDecoder->m_pExtendedContentDesc->pDescriptors[i].cbValue);
        }
#ifndef LITTLE_ENDIAN
        if((pDecoder->m_pExtendedContentDesc->pDescriptors[i].data_type == ECD_DWORD) ||
        (pDecoder->m_pExtendedContentDesc->pDescriptors[i].data_type == ECD_BOOL))
            SWAPDWORD((U8_WMC *)pDecoder->m_pExtendedContentDesc->pDescriptors[i].uValue.pbBinary);
        else if(pDecoder->m_pExtendedContentDesc->pDescriptors[i].data_type == ECD_STRING)
            SwapWstr((U16Char_WMC *)pDecoder->m_pExtendedContentDesc->pDescriptors[i].uValue.pwszString, pDecoder->m_pExtendedContentDesc->pDescriptors[i].cbValue / sizeof(U16Char_WMC));
        else if(pDecoder->m_pExtendedContentDesc->pDescriptors[i].data_type == ECD_WORD)
            SWAPWORD((U8_WMC *)pDecoder->m_pExtendedContentDesc->pDescriptors[i].uValue.pbBinary);
#endif
        pData += pDecoder->m_pExtendedContentDesc->pDescriptors[i].cbValue;
        cbTrack -= pDecoder->m_pExtendedContentDesc->pDescriptors[i].cbValue;
    }
    pDecoder->tHeaderInfo.cbCurrentPacketOffset +=(U64_WMC)cbBuffer; // Use whole Object    
    
    return( WMCDec_Succeeded );
}
/***************************************************************************************************************/
tWMCDecStatus LoadScriptCommandObject(
                    U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder)

{


    U16_WMC num_commands, num_types;
    GUID_WMC command_id;
    I32_WMC i;
    U32_WMC cbTrack;
    WMFDecoderEx *pDecoder = NULL;
    U8_WMC *pData = NULL;
    U32_WMC cbWanted;
    U32_WMC cbActual;
    U32_WMC cbObjectOffset = 0;

    if( NULL == phDecoder )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(*phDecoder);
    
    if(cbBuffer < MIN_OBJECT_SIZE)
        return WMCDec_BufferTooSmall;

    cbBuffer -= MIN_OBJECT_SIZE;
    cbTrack = cbBuffer;


    cbWanted = /*sizeof(GUID_WMC) + */sizeof(GUID_WMC) + 2 * sizeof(U16_WMC);
    if(cbObjectOffset + cbWanted > cbBuffer)
    {
        return WMCDec_BufferTooSmall;
    }

    cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
    {
       return WMCDec_BufferTooSmall;
    }
	cbObjectOffset+=cbActual;


    LoadGUID( command_id, pData );
    LoadWORD( num_commands, pData );
   
	LoadWORD( num_types, pData );

    pDecoder->m_pScriptCommand = (WMCScriptCommand *)wmvalloc(sizeof(WMCScriptCommand));
    if (pDecoder->m_pScriptCommand == NULL)
        return (WMCDec_BadMemory);
	memset(pDecoder->m_pScriptCommand, 0, sizeof(WMCScriptCommand));


    pDecoder->m_pScriptCommand->type_names = NULL;
    pDecoder->m_pScriptCommand->type_name_len = NULL;
    pDecoder->m_pScriptCommand->commands = NULL;
    pDecoder->m_pScriptCommand->command_param_len = NULL;
    pDecoder->m_pScriptCommand->num_types = num_types;
    if(num_types) 
    {
        pDecoder->m_pScriptCommand->type_names = (U16Char_WMC **)wmvalloc(num_types * sizeof(U16Char_WMC *));
        pDecoder->m_pScriptCommand->type_name_len = (I32_WMC *)wmvalloc(num_types * sizeof(I32_WMC));
    }
	for (i = 0; i < num_types; i++) 
    {
        pDecoder->m_pScriptCommand->type_names[i] = NULL;
        pDecoder->m_pScriptCommand->type_name_len[i] = 0;
	} 
	
	for (i = 0; i < num_types; i++) 
    {
        U16_WMC wChars = 0;
        cbWanted = sizeof(U16_WMC);
        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            return WMCDec_BufferTooSmall;
        }

        cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
        }
        cbObjectOffset += cbActual;
        LoadWORD(wChars, pData);
        cbTrack -=cbActual;

        if(cbTrack < (U32_WMC)wChars * sizeof(U16Char_WMC))
		{
			return( WMCDec_BufferTooSmall );
		}

        pDecoder->m_pScriptCommand->type_names[i] = NULL;
        pDecoder->m_pScriptCommand->type_names[i] = (U16Char_WMC *)wmvalloc(wChars * sizeof(U16Char_WMC));
		memset(pDecoder->m_pScriptCommand->type_names[i], 0, wChars * sizeof(U16Char_WMC));
        pDecoder->m_pScriptCommand->type_name_len[i] = (I32_WMC) wChars;
        if(pDecoder->m_pScriptCommand->type_names[i] == NULL)
		{
			return( WMCDec_BadMemory );
		}
        else
        {
            cbWanted = wChars * sizeof(U16Char_WMC);
            if(cbObjectOffset + cbWanted > cbBuffer)
            {
                return WMCDec_BufferTooSmall;
            }

            cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
            }
            cbObjectOffset += cbActual;
            
            memcpy(pDecoder->m_pScriptCommand->type_names[i], pData, wChars * sizeof(U16Char_WMC));
        }
#ifndef LITTLE_ENDIAN
        SwapWstr((U16Char_WMC *)pDecoder->m_pScriptCommand->type_names[i], wChars);
#endif
        pData +=  (wChars * sizeof(U16Char_WMC));
        cbTrack -=  (wChars * sizeof(U16Char_WMC));
    }
    pDecoder->m_pScriptCommand->num_commands = num_commands;
    if(num_commands)  
	{
        pDecoder->m_pScriptCommand->commands = (WMCCommandEntry *)wmvalloc(num_commands * sizeof(WMCCommandEntry));
        pDecoder->m_pScriptCommand->command_param_len = (I32_WMC *)wmvalloc(num_commands * sizeof(I32_WMC));
    }
	for (i = 0; i < num_commands; i++) 
    {
        pDecoder->m_pScriptCommand->commands[i].param = NULL;
        pDecoder->m_pScriptCommand->command_param_len[i] = 0;
	} 
    
	for (i = 0; i < num_commands; i++) 
    {
        U16_WMC wChars = 0;
        cbWanted = sizeof(U32_WMC) + 2 * sizeof(U16_WMC);
        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            return WMCDec_BufferTooSmall;
        }

        cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
            
        }
        cbObjectOffset += cbActual;

        LoadDWORD(pDecoder->m_pScriptCommand->commands[i].time, pData);
        cbTrack -= sizeof(U32_WMC);
        LoadWORD(pDecoder->m_pScriptCommand->commands[i].type, pData);
        cbTrack -= sizeof(U16_WMC);
        LoadWORD(wChars, pData);
        cbTrack -= sizeof(U16_WMC);
        if(cbTrack < (U32_WMC)wChars * sizeof(U16Char_WMC))
            return( WMCDec_BufferTooSmall );

        pDecoder->m_pScriptCommand->commands[i].param = NULL;
        pDecoder->m_pScriptCommand->commands[i].param = (U16Char_WMC *)wmvalloc(wChars * sizeof(U16Char_WMC));
        pDecoder->m_pScriptCommand->command_param_len[i] = (I32_WMC)wChars;
        if( pDecoder->m_pScriptCommand->commands[i].param == NULL)
            return( WMCDec_BadMemory );
        else
        {
            cbWanted = wChars * sizeof(U16Char_WMC);
            if(cbObjectOffset + cbWanted > cbBuffer)
            {
                return WMCDec_BufferTooSmall;
                
            }

            cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
                
            }
            cbObjectOffset += cbActual;

            memcpy(pDecoder->m_pScriptCommand->commands[i].param, pData, (wChars * sizeof(U16Char_WMC)));
        }
#ifndef LITTLE_ENDIAN
        SwapWstr((U16Char_WMC *)pDecoder->m_pScriptCommand->commands[i].param, wChars);
#endif
        cbTrack -= (wChars * sizeof(U16Char_WMC));
        pData += (wChars * sizeof(U16Char_WMC));
    }
    pDecoder->tHeaderInfo.cbCurrentPacketOffset +=(U64_WMC)cbBuffer; // Use whole Object    
    return( WMCDec_Succeeded );
}
/***************************************************************************************************************/


tWMCDecStatus
LoadLicenseStoreObject(U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder)
{
    tWMCDecStatus we = WMCDec_Succeeded;
    U32_WMC m_dwFlag;
    WMFDecoderEx *pDecoder = NULL;
    U8_WMC *pData = NULL;
    U32_WMC cbWanted;
    U32_WMC cbActual;
    U32_WMC cbObjectOffset = 0;

    if( NULL == phDecoder )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(*phDecoder);
    
    if(cbBuffer < MIN_OBJECT_SIZE)
        return WMCDec_BufferTooSmall;

    cbBuffer -= MIN_OBJECT_SIZE;


  

    do
    {

        cbWanted = sizeof(U32_WMC);
        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            we = WMCDec_BufferTooSmall;
            break;
        }

        cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            we = WMCDec_BufferTooSmall;
            break;
        }
        cbObjectOffset += cbActual;

        LoadDWORD(m_dwFlag, pData);

        cbWanted = sizeof(U32_WMC);
        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            we = WMCDec_BufferTooSmall;
            break;
        }

        cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            we = WMCDec_BufferTooSmall;
            break;
        }
        cbObjectOffset += cbActual;

        LoadDWORD(pDecoder->m_dwLicenseLen, pData);

        cbWanted = pDecoder->m_dwLicenseLen;
        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            we = WMCDec_BufferTooSmall;
            break;
        }

        cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            we = WMCDec_BufferTooSmall;
            break;
        }
        cbObjectOffset += cbActual;

        pDecoder->m_pLicData = (U8_WMC *)wmvalloc(pDecoder->m_dwLicenseLen);
        if(NULL == pDecoder->m_pLicData)
        {
            we = WMCDec_BadMemory;
            break;
        }

        memcpy(pDecoder->m_pLicData, pData, pDecoder->m_dwLicenseLen);

    } while(0);

    if(we != WMCDec_Succeeded)
    {
        /* clean up if necessary */

        if(pDecoder->m_pLicData != NULL)
        {
            wmvfree(pDecoder->m_pLicData);
        }
    }
   pDecoder->tHeaderInfo.cbCurrentPacketOffset +=(U64_WMC)cbBuffer; // Use whole Object    
   return we;
}

/****************************************************************************/
tWMCDecStatus LoadExtendedStreamPropertiesObject(
               //     const U8_WMC *pbBuffer,
                    U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder)
{
    U32_WMC dwTemp =0;
    U16_WMC wNoOfStreams =0;
    U16_WMC i =0;
    U32_WMC dwBitRate =0;
    U16_WMC wStreamNo =0;
    U32_WMC dwOldBitRate =0;
    WMFDecoderEx *pDecoder = NULL;
    U8_WMC *pData = NULL;
    U32_WMC cbWanted;
    U32_WMC cbActual;
    U32_WMC cbObjectOffset = 0;

    if( NULL == phDecoder )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(*phDecoder);
    
    if(cbBuffer < MIN_OBJECT_SIZE)
        return WMCDec_BufferTooSmall;

    cbBuffer -= MIN_OBJECT_SIZE;

    cbWanted = sizeof(U16_WMC);
    if(cbObjectOffset + cbWanted > cbBuffer)
    {
        return WMCDec_BufferTooSmall;
    }

    cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
    {
        return WMCDec_BufferTooSmall;
    }
    cbObjectOffset += cbActual;


    LoadWORD( wNoOfStreams, pData );

    if( cbBuffer < (sizeof( U16_WMC ) + wNoOfStreams *(sizeof( U16_WMC ) + sizeof( U32_WMC )) ))
    {
        return( WMCDec_BufferTooSmall );
    }
    pDecoder->tHeaderInfo.wNoOfStreams = wNoOfStreams;
	
	if (wNoOfStreams >127)
        return( WMCDec_BufferTooSmall );

	for (i =0; i < wNoOfStreams; i++)
	{

        cbWanted = sizeof( U16_WMC ) + sizeof( U32_WMC ) ;
        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            return WMCDec_BufferTooSmall;
        }

        cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
        }
        cbObjectOffset += cbActual;
 
        LoadWORD( wStreamNo, pData );
 	    LoadDWORD( dwBitRate, pData );
        pDecoder->tHeaderInfo.tBitRateInfo[i].wStreamId = wStreamNo;
        pDecoder->tHeaderInfo.tBitRateInfo[i].dwBitRate = dwBitRate;
        
	}
    pDecoder->tHeaderInfo.bHasBitRateInfo = TRUE_WMC;
    pDecoder->tHeaderInfo.cbCurrentPacketOffset +=(U64_WMC)cbBuffer; // Use whole Object    
    return WMCDec_Succeeded;
}


/****************************************************************************/
tWMCDecStatus LoadIndexObject(HWMCDECODER *phDecoder,
                    U64_WMC cbOffset,
                    U32_WMC cbBuffer,
                    U16_WMC wStreamId,
					WMCINDEXINFO *pIndexInfo
                    )
{
    U32_WMC dwTemp =0;
    U64_WMC time_delta = 0;
    U32_WMC i=0;
    U16_WMC wTemp=0;
    WMCINDEXENTRIES *tpTempEntry = NULL;
    U8_WMC *pData = NULL;
    U32_WMC cbWanted;
    U32_WMC cbActual;
    U32_WMC cbObjectOffset = 0;

    WMFDecoderEx *pDecoder = NULL;

    if( NULL == phDecoder )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(*phDecoder);
    



    if(cbBuffer < MIN_OBJECT_SIZE)
        return WMCDec_BufferTooSmall;

//	cbBuffer -= MIN_OBJECT_SIZE;
//	cbBuffer -= sizeof(GUID_WMC);

    if( cbBuffer < sizeof( U64_WMC ) +2*sizeof( U32_WMC ))
        return( WMCDec_BufferTooSmall );

    cbObjectOffset = MIN_OBJECT_SIZE + sizeof(GUID_WMC);


    cbWanted = sizeof(U64_WMC) + 2*sizeof( U32_WMC ) ;

    if(cbObjectOffset + cbWanted > cbBuffer)
    {
        return WMCDec_BufferTooSmall;
    }

    cbActual = WMCDecCBGetData(*phDecoder, cbOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
    {
        return WMCDec_BufferTooSmall;
    }
    cbObjectOffset += cbActual;
    
	
   LoadQWORD(time_delta,pData);
   pIndexInfo->time_deltaMs = (*((U32_WMC*)&time_delta))/10000;
   LoadDWORD( dwTemp,pData);
   pIndexInfo->max_packets = dwTemp;
   LoadDWORD( dwTemp,pData);
   pIndexInfo->num_entries = dwTemp;
   pIndexInfo->nStreamId = wStreamId;

   pIndexInfo->pIndexEntries = (WMCINDEXENTRIES *) wmvalloc(pIndexInfo->num_entries*sizeof(WMCINDEXENTRIES));

   if (NULL == pIndexInfo->pIndexEntries)
        return( WMCDec_BadMemory );
   tpTempEntry =  pIndexInfo->pIndexEntries;
   
   for (i=0; i< pIndexInfo->num_entries; i++)
   {
      
        cbWanted = sizeof(U16_WMC) + sizeof( U32_WMC ) ;

        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            return WMCDec_BufferTooSmall;
        }

        cbActual = WMCDecCBGetData(*phDecoder, cbOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
        }
        cbObjectOffset += cbActual;
       
        LoadDWORD(dwTemp,pData);
        tpTempEntry->dwPacket = dwTemp;

        LoadWORD(wTemp,pData);
        tpTempEntry->wSpan = wTemp;
        tpTempEntry++;        
   }

   return WMCDec_Succeeded;
}


/****************************************************************************/

tWMCDecStatus LoadObjectHeader(HWMCDECODER *phDecoder, GUID_WMC *pObjectId, U64_WMC *pqwSize)
{
    U8_WMC *pData = NULL;
    U32_WMC cbWanted;
    U32_WMC cbActual;
    WMFDecoderEx *pDecoder = NULL;
    if( NULL == phDecoder )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(*phDecoder);

    cbWanted = MIN_OBJECT_SIZE;
    cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
    {
        return WMCDec_BufferTooSmall;
    }

    pDecoder->tHeaderInfo.cbCurrentPacketOffset += cbActual;

    LoadGUID((*pObjectId), pData);
    LoadQWORD((*pqwSize), pData);

    return WMCDec_Succeeded;
}

/****************************************************************************/

tWMCDecStatus LoadVirtualObjectHeader(HWMCDECODER *phDecoder, GUID_WMC *pObjectId, U64_WMC *pqwSize, U32_WMC Offset)
{
    U8_WMC *pData = NULL;
    U32_WMC cbWanted;
    U32_WMC cbActual;
    WMFDecoderEx *pDecoder = NULL;
    if( NULL == phDecoder )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(*phDecoder);

    cbWanted = MIN_OBJECT_SIZE;
    cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + Offset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
    {
        return WMCDec_BufferTooSmall;
    }

    LoadGUID((*pObjectId), pData);
    LoadQWORD((*pqwSize), pData);

    return WMCDec_Succeeded;
}


/****************************************************************************/

tWMCDecStatus ParseAsfHeader(HWMCDECODER *phDecoder, U8_WMC isFull)
{
    tWMCDecStatus rc;
    GUID_WMC objId;
    U64_WMC qwSize;

    WMFDecoderEx *pDecoder = NULL;
    if( NULL == phDecoder )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(*phDecoder);

    /* initialize the some state */

    pDecoder->tHeaderInfo.cbCurrentPacketOffset = 0;


    /* ASF Header Object */

    rc = LoadHeaderObject(phDecoder);
    if(rc != WMCDec_Succeeded)
    {
        return rc;
    }
    pDecoder->tHeaderInfo.cbFirstPacketOffset = pDecoder->tHeaderInfo.cbHeader += DATA_OBJECT_SIZE;

    /* Scan Header Objects */

    while(pDecoder->tHeaderInfo.cbCurrentPacketOffset < pDecoder->tHeaderInfo.cbFirstPacketOffset)
    {
        rc = LoadObjectHeader(phDecoder, &objId, &qwSize);
        if(rc != WMCDec_Succeeded)
        {
            return rc;
        }

        if( IsEqualGUID_WMC( &CLSID_CAsfPropertiesObjectV2, &objId ) )
        {
            rc = LoadPropertiesObject(
                     //           pbBuffer,
                                *((U32_WMC*) &qwSize),
                                phDecoder);
            if (WMCDec_Succeeded != rc)
				goto abort;
        }
        else if( IsEqualGUID_WMC( &CLSID_CAsfStreamPropertiesObjectV1, &objId ))
        {
            rc = LoadAudioObjectSize(
                          //      pbBuffer,
                                *((U32_WMC*) &qwSize),
                                phDecoder);

            if (WMCDec_Succeeded != rc)
				goto abort;
        }
        else if(IsEqualGUID_WMC(&CLSID_CAsfContentEncryptionObject, &objId))
        {
            rc = LoadEncryptionObject( //pbBuffer,
                                      *((U32_WMC*) &qwSize),
                                      phDecoder);
            if (rc != WMCDec_Succeeded)
				goto abort;
        }
        else if(IsEqualGUID_WMC(&CLSID_CAsfContentEncryptionObjectEx, &objId))
        {
            rc = LoadEncryptionObjectEx( // pbBuffer,
                                      *((U32_WMC*) &qwSize),
                                      phDecoder);
            if (rc != WMCDec_Succeeded)
				goto abort;
        }
        else if(IsEqualGUID_WMC(&CLSID_CAsfContentDescriptionObjectV0, &objId))
        {
            if(isFull)
            {
                rc = LoadContentDescriptionObject( //pbBuffer,
                                          *((U32_WMC*) &qwSize),
                                          phDecoder);
                if (rc != WMCDec_Succeeded)
				    goto abort;
            }
        }
        else if(IsEqualGUID_WMC(&CLSID_CAsfMarkerObjectV0, &objId))
        {
            rc = LoadMarkerObject( // pbBuffer,
                                 *((U32_WMC*) &qwSize),
                                      phDecoder);
            if(rc != WMCDec_Succeeded)
				goto abort;
        }
        else if(IsEqualGUID_WMC(&CLSID_CAsfExtendedContentDescObject, &objId))
        {
            if(isFull)
            {
                rc = LoadExtendedContentDescriptionObject(//pbBuffer,
                                     *((U32_WMC*) &qwSize),
                                          phDecoder);
                if(rc != WMCDec_Succeeded)
				    goto abort;
            }
        }
        else if(IsEqualGUID_WMC(&CLSID_CAsfScriptCommandObjectV0, &objId))
        {

            rc = LoadScriptCommandObject(//pbBuffer,
                                 *((U32_WMC*) &qwSize),
                                      phDecoder);
            if(rc != WMCDec_Succeeded)
				goto abort;
        }
        else if(IsEqualGUID_WMC(&CLSID_CAsfLicenseStoreObject, &objId))
        {
            rc = LoadLicenseStoreObject(//pbBuffer,
                                 *((U32_WMC*) &qwSize),
                                      phDecoder);
            if(rc != WMCDec_Succeeded)
				goto abort;
        }
        else if(IsEqualGUID_WMC(&CLSID_CAsfExtendedStreamPropertiesObject, &objId))
        {
            rc = LoadExtendedStreamPropertiesObject(//pbBuffer,
                                 *((U32_WMC*) &qwSize),
                                      phDecoder);
            if(rc != WMCDec_Succeeded)
				goto abort;
       

		}
        else if(IsEqualGUID_WMC(&CLSID_CAsfCodecObjectV0, &objId))
        {
            rc = LoadCodecListObject(//pbBuffer,
                                 *((U32_WMC*) &qwSize),
                                      phDecoder);
            if(rc != WMCDec_Succeeded)
				goto abort;
       

		}
        else if(IsEqualGUID_WMC(&CLSID_CAsfClockObjectV0, &objId))
        {
            rc = LoadClockObject(*((U32_WMC*) &qwSize),
                                      phDecoder);
            if(rc != WMCDec_Succeeded)
				goto abort;
       

		}
        else
        {
            /* skip over this object */
            pDecoder->tHeaderInfo.cbCurrentPacketOffset += (qwSize - MIN_OBJECT_SIZE);
        }
    }

abort:

return rc;
}

/****************************************************************************/
tWMCDecStatus
LoadCodecListObject(
                    U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder)
{
    U32_WMC cbObjectOffset = 0;

    GUID_WMC m_gCodecList;
    U16_WMC tw;
    U32_WMC i, j;
    WMFDecoderEx *pDecoder = NULL;

    U8_WMC *pData = NULL;
    U32_WMC cbWanted;
    U32_WMC cbActual;

    if( NULL == phDecoder )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(*phDecoder);
    
    if(cbBuffer < MIN_OBJECT_SIZE)
        return WMCDec_BufferTooSmall;

    cbBuffer -= MIN_OBJECT_SIZE;

    cbWanted = 20;
    if(cbObjectOffset + cbWanted > cbBuffer)
    {
        return WMCDec_BufferTooSmall;
        
    }

    cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
    {
        return WMCDec_BufferTooSmall;
        
    }
    cbObjectOffset += cbActual;

    LoadGUID (m_gCodecList , pData);
    LoadDWORD(pDecoder->m_dwNumCodec   , pData);

	if (pDecoder->m_dwNumCodec > 0)
	{
		pDecoder->m_pCodecEntry = (WMCCodecEntry *)wmvalloc((pDecoder->m_dwNumCodec)* sizeof(WMCCodecEntry));
		if (NULL == (pDecoder->m_pCodecEntry))
			return (WMCDec_BadMemory);
	}
	else
	{
	    pDecoder->tHeaderInfo.cbCurrentPacketOffset +=(U64_WMC)cbBuffer; // Use whole Object    
		return WMCDec_Succeeded;
	}

    
    for (j = 0; j < pDecoder->m_dwNumCodec; j++) 
    {

		cbWanted = 4;
		if(cbObjectOffset + cbWanted > cbBuffer)
		{
			return WMCDec_BufferTooSmall;
        
		}

		cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

		if(cbActual != cbWanted)
		{
			return WMCDec_BufferTooSmall;
        
		}
		cbObjectOffset += cbActual;
        
        LoadWORD(tw, pData);
		if (tw == 0x0002)
		{
			(pDecoder->m_pCodecEntry)[j].m_wCodecType = Audio_WMC;
		}
		else if(tw == 0x0001)
		{
			(pDecoder->m_pCodecEntry)[j].m_wCodecType = Video_WMC;
		}
		else
			(pDecoder->m_pCodecEntry)[j].m_wCodecType = Binary_WMC;

        LoadWORD((pDecoder->m_pCodecEntry)[j].m_wCodecNameLength , pData);

        (pDecoder->m_pCodecEntry)[j].m_pwCodecName = (U16Char_WMC *)wmvalloc(sizeof(U16Char_WMC)*((pDecoder->m_pCodecEntry)[j].m_wCodecNameLength));
        if (NULL == (pDecoder->m_pCodecEntry)[j].m_pwCodecName)
            return (WMCDec_BadMemory);
        
		
		
		
		cbWanted = (pDecoder->m_pCodecEntry)[j].m_wCodecNameLength * sizeof(U16Char_WMC);
        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            return WMCDec_BufferTooSmall;
            
        }

        cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
            
        }
        cbObjectOffset += cbActual;

        for (i=0;i<(pDecoder->m_pCodecEntry)[j].m_wCodecNameLength;i++) 
		{
            LoadWORD(tw, pData);
            (pDecoder->m_pCodecEntry)[j].m_pwCodecName[i] = tw;
        }

		cbWanted = 2;
		if(cbObjectOffset + cbWanted > cbBuffer)
		{
			return WMCDec_BufferTooSmall;
        
		}

		cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

		if(cbActual != cbWanted)
		{
			return WMCDec_BufferTooSmall;
        
		}
		cbObjectOffset += cbActual;
        
        LoadWORD((pDecoder->m_pCodecEntry)[j].m_wCodecDescLength, pData);


        (pDecoder->m_pCodecEntry)[j].m_pwCodecDescription  = (U16Char_WMC *)wmvalloc(sizeof(U16Char_WMC)*((pDecoder->m_pCodecEntry)[j].m_wCodecDescLength ));
        if (NULL == (pDecoder->m_pCodecEntry)[j].m_pwCodecDescription)
            return (WMCDec_BadMemory);
        
		
		cbWanted = (pDecoder->m_pCodecEntry)[j].m_wCodecDescLength * sizeof(U16Char_WMC);
        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            return WMCDec_BufferTooSmall;
            
        }

        cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
            
        }
        cbObjectOffset += cbActual;

        for (i=0;i<(pDecoder->m_pCodecEntry)[j].m_wCodecDescLength;i++) 
		{
            LoadWORD(tw, pData);
            (pDecoder->m_pCodecEntry)[j].m_pwCodecDescription[i] = tw;
        }


		cbWanted = 2;
		if(cbObjectOffset + cbWanted > cbBuffer)
		{
			return WMCDec_BufferTooSmall;
        
		}

		cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

		if(cbActual != cbWanted)
		{
			return WMCDec_BufferTooSmall;
        
		}
		cbObjectOffset += cbActual;
        
        LoadWORD((pDecoder->m_pCodecEntry)[j].m_wCodecInfoLen, pData);


        (pDecoder->m_pCodecEntry)[j].m_pbCodecInfo = (U8_WMC *)wmvalloc(((pDecoder->m_pCodecEntry)[j].m_wCodecInfoLen));
        if (NULL == (pDecoder->m_pCodecEntry)[j].m_pbCodecInfo)
            return (WMCDec_BadMemory);
        
		
		cbWanted = (pDecoder->m_pCodecEntry)[j].m_wCodecInfoLen;
        if(cbObjectOffset + cbWanted > cbBuffer)
        {
            return WMCDec_BufferTooSmall;
            
        }

        cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
            
        }
        cbObjectOffset += cbActual;

        memcpy((pDecoder->m_pCodecEntry)[j].m_pbCodecInfo,pData,(pDecoder->m_pCodecEntry)[j].m_wCodecInfoLen);

    }

    pDecoder->tHeaderInfo.cbCurrentPacketOffset +=(U64_WMC)cbBuffer; // Use whole Object    

    return WMCDec_Succeeded;
}

/****************************************************************************/

/****************************************************************************/
tWMCDecStatus WMCDecParseVirtualPayloadHeader(HWMCDECODER hDecoder, U32_WMC cbCurrentPacketOffset, PACKET_PARSE_INFO_EX *pParseInfoEx, PAYLOAD_MAP_ENTRY_EX *pPayload)
{
    U32_WMC cbDummy;
    U32_WMC cbParseOffset;
    U32_WMC cbRepDataOffset;
    U32_WMC dwPayloadSize;
    U32_WMC cbLocalOffset=0;
    WMFDecoderEx *pDecoder = NULL;

    U8_WMC *pData = NULL;
    U32_WMC cbWanted;
    U32_WMC cbActual;

    U16_WMC wTotalDataBytes=0;

    if( NULL == hDecoder )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(hDecoder);



    cbWanted = 2;              /* at least */
    cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
    {
        return WMCDec_BufferTooSmall;
    }

    cbParseOffset = 0;

    /* Loop in ParsePacketAndPayloads */

    pPayload->cbPacketOffset = (U16_WMC)pParseInfoEx->cbParseOffset;
    pPayload->bStreamId = (pData[cbParseOffset])&0x7f; // Amit to get correct Streamid 
    pPayload->bIsKeyFrame = (((pData[cbParseOffset]) &0x80) >> 7);
    pPayload->bObjectId = pData[cbParseOffset + 1];
    cbDummy = 0;
	
	switch(pParseInfoEx->bOffsetLenType)
    {
    case 0x01:
        {
            cbWanted =1;

            cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset+2, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
            }
            pPayload->cbObjectOffset =  (U32_WMC)(*pData);
            break;
        }
    case 0x02:
        {
            U16_WMC w;
            cbWanted =2;
            cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset+2, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
            }
             GetUnalignedWord(pData, w);
            pPayload->cbObjectOffset =  (U32_WMC)(w);
        
            break;

        }
    case 0x03:
        {
            U32_WMC dw;
            cbWanted =4;
            cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset+2, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
            }
            GetUnalignedDword(pData, dw);
            pPayload->cbObjectOffset =  dw;
            break;
        }
    default:
        cbWanted =0;
    }


    cbRepDataOffset = cbParseOffset + 2 + pParseInfoEx->bOffsetBytes;


    cbWanted =1;
    cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset + cbRepDataOffset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
    {
        return WMCDec_BufferTooSmall;
    }
    pPayload->cbRepData = pData[cbLocalOffset];

    pPayload->msObjectPres = 0xffffffff;

    if(pPayload->cbRepData == 1)
    {
        pPayload->msObjectPres = pPayload->cbObjectOffset;
        pPayload->cbObjectOffset = 0;
        pPayload->cbObjectSize = 0;
        pPayload->bIsCompressedPayload =1;

        cbWanted =3;
        cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset + cbRepDataOffset + 1, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
        }
		pPayload->dwDeltaPresTime = pData[0/*cbRepDataOffset +1*/];

		if( pParseInfoEx->fMultiPayloads)
		{
            GetUnalignedWord( &pData[ cbLocalOffset + 1 ],wTotalDataBytes );
		}
		else
		{
			wTotalDataBytes = 0;
		}
    }
    else if(pPayload->cbRepData >= 8)
    {
        cbWanted =8;
        cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset + cbRepDataOffset + 1, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
        }
        GetUnalignedDword(&pData[cbLocalOffset],
                          pPayload->cbObjectSize);
        GetUnalignedDword(&pData[cbLocalOffset+ 4],
                          pPayload->msObjectPres);

        pPayload->bIsCompressedPayload =0;
    }

    pPayload->cbTotalSize = 1 + 1 + pParseInfoEx->bOffsetBytes + 1 + pPayload->cbRepData;

    if(pParseInfoEx->fMultiPayloads)
    {
        cbDummy = 0;

        switch(pParseInfoEx->bPayLenType)
        {
        case 0x01:
            {
                cbWanted =1;
                cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset + pPayload->cbTotalSize, cbWanted, &pData, pDecoder->u32UserData);
                if(cbActual != cbWanted)
                {
                    return WMCDec_BufferTooSmall;
                }

                dwPayloadSize =  (U32_WMC)(*pData);
                break;
            }
        case 0x02:
            {
                U16_WMC w;
                cbWanted =2;
                cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset + pPayload->cbTotalSize, cbWanted, &pData, pDecoder->u32UserData);
                if(cbActual != cbWanted)
                {
                    return WMCDec_BufferTooSmall;
                }
                GetUnalignedWord(pData, w);
                dwPayloadSize =  (U32_WMC)(w);
        
                break;

            }
        case 0x03:
            {
                U32_WMC dw;
                cbWanted =4;
                cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset + pPayload->cbTotalSize, cbWanted, &pData, pDecoder->u32UserData);
                if(cbActual != cbWanted)
                {
                    return WMCDec_BufferTooSmall;
                }
                GetUnalignedDword(pData, dw);
                dwPayloadSize =  dw;
                break;
            }
        default:
            cbWanted =0;
        }

    }
    else if(pParseInfoEx->cbExplicitPacketLength > 0)
    {
        dwPayloadSize = pParseInfoEx->cbExplicitPacketLength
                      - pParseInfoEx->cbParseOffset
                      - pPayload->cbTotalSize
                      - pParseInfoEx->cbPadding;
    }
    else
    {
        dwPayloadSize = pDecoder->tHeaderInfo.cbPacketSize
                      - pParseInfoEx->cbParseOffset
                      - pPayload->cbTotalSize
                      - pParseInfoEx->cbPadding;
    }
    if (0 == wTotalDataBytes)
        wTotalDataBytes = (U16_WMC) dwPayloadSize;

    pPayload->cbPayloadSize = (U16_WMC)dwPayloadSize;

    pPayload->cbTotalSize += pParseInfoEx->bPayBytes
                          + (U16_WMC)pPayload->cbPayloadSize;

 	pPayload->wTotalDataBytes = wTotalDataBytes; // Amit

    pParseInfoEx->cbParseOffset += pPayload->cbTotalSize;

    if(pParseInfoEx->cbParseOffset > pDecoder->tHeaderInfo.cbPacketSize)
    {
        return WMCDec_BadData;
    }

    return WMCDec_Succeeded;
}

/****************************************************************************/

tWMCDecStatus WMCDecParseVirtualPacketHeader(HWMCDECODER hDecoder, U32_WMC cbCurrentPacketOffset, PACKET_PARSE_INFO_EX* pParseInfoEx)
{
    U8_WMC b;
    U8_WMC *pData = NULL;
    U32_WMC cbWanted;
    U32_WMC cbActual;
    U32_WMC cbLocalOffset=0;
    WMFDecoderEx *pDecoder = NULL;

    if( NULL == hDecoder )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(hDecoder);


    cbWanted = 1;
    cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
    {
        return WMCDec_BufferTooSmall;
        
    }

    /* ParsePacket begins */


    pParseInfoEx->fParityPacket = FALSE_WMC;
    pParseInfoEx->cbParseOffset = 0;

    b = pData[cbLocalOffset];
    
    pParseInfoEx->fEccPresent = (BOOL)( (b&0x80) == 0x80 );
    pParseInfoEx->bECLen = 0;

    if(pParseInfoEx->fEccPresent)
    {
        if(b&0x10)
        {
            pParseInfoEx->fParityPacket = TRUE;
            return WMCDec_Succeeded;
        }

        if(b&0x60)
        {
            return WMCDec_Fail;
        }

        pParseInfoEx->bECLen = (b&0x0f);
        if(pParseInfoEx->bECLen != 2)
        {
            return WMCDec_Fail;
        }

        pParseInfoEx->cbParseOffset = (U32_WMC)(1 + pParseInfoEx->bECLen);
//////////////////////////////////////////////////////////////////////////////
        cbWanted = 1;              /* at least */

        cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
        
        }

        b = pData[cbLocalOffset];

//////////////////////////////////////////////////////////////////////////////
    }

    pParseInfoEx->cbPacketLenTypeOffset = pParseInfoEx->cbParseOffset;

    pParseInfoEx->bPacketLenType = (b&0x60)>>5;
    if(pParseInfoEx->bPacketLenType != 0
       && pParseInfoEx->bPacketLenType != 2)
    {
        return WMCDec_Fail;
    }

    pParseInfoEx->bPadLenType = (b&0x18)>>3;
    if(pParseInfoEx->bPadLenType == 3)
    {
        return WMCDec_Fail;
    }

    pParseInfoEx->bSequenceLenType = (b&0x06)>>1;

    pParseInfoEx->fMultiPayloads = (BOOL)(b&0x01);

    pParseInfoEx->cbParseOffset++;

//////////////////////////////////////////////////////////////////////////////
        cbWanted = 1;              /* at least */
        cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;
        
        }

        b = pData[cbLocalOffset];

//////////////////////////////////////////////////////////////////////////////

    pParseInfoEx->bOffsetBytes = 4;
    pParseInfoEx->bOffsetLenType = 3;

    if(b != 0x5d)
    {
        if((b&0xc0) != 0x40)
        {
            return WMCDec_Fail;
        }

        if((b&0x30) != 0x10)
        {
            return WMCDec_Fail;
        }

        pParseInfoEx->bOffsetLenType = (b&0x0c)>>2;
        if(pParseInfoEx->bOffsetLenType == 0)
        {
            return WMCDec_Fail;
        }
        else if(pParseInfoEx->bOffsetLenType < 3)
        {
            pParseInfoEx->bOffsetBytes = pParseInfoEx->bOffsetLenType;
        }

        if((b&0x03) != 0x01)
        {
            return WMCDec_Fail;
        }
    }

    pParseInfoEx->cbParseOffset++;

//////////////////////////////////////////////////////////////////////////////
    pParseInfoEx->cbPacketLenOffset = pParseInfoEx->cbParseOffset; 
    switch(pParseInfoEx->bPacketLenType)
    {
    case 0x01:
        {
            cbWanted =1;
            cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
        
            }
            pParseInfoEx->cbExplicitPacketLength =  (U32_WMC)(*pData);
            pParseInfoEx->cbParseOffset++;
            break;
        }
    case 0x02:
        {
            U16_WMC w;
            cbWanted =2;
            cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
        
            }
            GetUnalignedWord(pData, w);
            pParseInfoEx->cbExplicitPacketLength =  (U32_WMC)(w);
            pParseInfoEx->cbParseOffset+=2;
        
            break;

        }
    case 0x03:
        {
            U32_WMC dw;
            cbWanted =4;
            cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
        
            }
            GetUnalignedDword(pData, dw);
            pParseInfoEx->cbExplicitPacketLength =  dw;
            pParseInfoEx->cbParseOffset+=4;
            break;
        }
    default:
        cbWanted =0;
    }

//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
    pParseInfoEx->cbSequenceOffset = pParseInfoEx->cbParseOffset;
    switch(pParseInfoEx->bSequenceLenType)
    {
    case 0x01:
        {
            cbWanted =1;
            cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
        
            }
            pParseInfoEx->dwSequenceNum =  (U32_WMC)(*pData);
            pParseInfoEx->cbParseOffset++;
            break;
        }
    case 0x02:
        {
            U16_WMC w;
            cbWanted =2;
            cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
        
            }
            GetUnalignedWord(pData, w);
            pParseInfoEx->dwSequenceNum =  (U32_WMC)(w);
            pParseInfoEx->cbParseOffset+=2;
        
            break;

        }
    case 0x03:
        {
            U32_WMC dw;
            cbWanted =4;
            cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
        
            }
            GetUnalignedDword(pData, dw);
            pParseInfoEx->dwSequenceNum =  dw;
            pParseInfoEx->cbParseOffset+=4;
            break;
        }
    default:
        cbWanted =0;
    }

///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////    
    pParseInfoEx->cbPadLenOffset = pParseInfoEx->cbParseOffset;
    switch(pParseInfoEx->bPadLenType)
    {
    case 0x01:
        {
            cbWanted =1;
            cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
        
            }
            pParseInfoEx->cbPadding =  (U32_WMC)(*pData);
            pParseInfoEx->cbParseOffset++;
            break;
        }
    case 0x02:
        {
            U16_WMC w;
            cbWanted =2;
            cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
        
            }
            GetUnalignedWord(pData, w);
            pParseInfoEx->cbPadding =  (U32_WMC)(w);
            pParseInfoEx->cbParseOffset+=2;
        
            break;

        }
    case 0x03:
        {
            U32_WMC dw;
            cbWanted =4;
            cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

            if(cbActual != cbWanted)
            {
                return WMCDec_BufferTooSmall;
        
            }
            GetUnalignedDword(pData, dw);
            pParseInfoEx->cbPadding =  dw;
            pParseInfoEx->cbParseOffset+=4;
            break;
        }
    default:
        cbWanted =0;
    }

    
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// Now read 6 bytes
    
    cbWanted =6;
    cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
    {
        return WMCDec_BufferTooSmall;

    }

/////////////////////////////////////////////////////////////////////////////////
    GetUnalignedDword(&pData[cbLocalOffset], pParseInfoEx->dwSCR);

/////////////////////////////////////////////////////////////////////////////////
    
    pParseInfoEx->cbParseOffset += 4;

//////////////////////////////////////////////////////////////////////////////////
    GetUnalignedWord(&pData[cbLocalOffset+4], pParseInfoEx->wDuration);
    
////////////////////////////////////////////////////////////////////////////////////
    
    pParseInfoEx->cbParseOffset += 2;


    /* ParsePacketEx begins */
    if( pParseInfoEx->fEccPresent && pParseInfoEx->fParityPacket ) 
    {
        return WMCDec_Succeeded;
    }


    pParseInfoEx->cbPayLenTypeOffset = 0;
    pParseInfoEx->bPayLenType = 0;
    pParseInfoEx->bPayBytes = 0;
    pParseInfoEx->cPayloads = 1;

    if(pParseInfoEx->fMultiPayloads)
    {
//////////////////////////////////////////////////////
        cbWanted =1;
        cbActual = WMCDecCBGetData(hDecoder, cbCurrentPacketOffset + pParseInfoEx->cbParseOffset, cbWanted, &pData, pDecoder->u32UserData);

        if(cbActual != cbWanted)
        {
            return WMCDec_BufferTooSmall;

        }

        b = pData[cbLocalOffset];
//////////////////////////////////////////////////////
        pParseInfoEx->cbPayLenTypeOffset = pParseInfoEx->cbParseOffset;

        pParseInfoEx->bPayLenType = (b&0xc0)>>6;
        if(pParseInfoEx->bPayLenType != 2
           && pParseInfoEx->bPayLenType != 1)
        {
            return WMCDec_Fail;
        }

        pParseInfoEx->bPayBytes = pParseInfoEx->bPayLenType;

        pParseInfoEx->cPayloads = (U32_WMC)(b&0x3f);
        if(pParseInfoEx->cPayloads == 0)
        {
            return WMCDec_Fail;
        }

        pParseInfoEx->cbParseOffset++;
    }

    return WMCDec_Succeeded;
}


/****************************************************************************/
tWMCDecStatus
LoadClockObject(U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder)
{
    U32_WMC cbObjectOffset = 0;

    GUID_WMC PacketClockType;
    U16_WMC PacketClockSize;
    U32_WMC dwHeaderExtDataSize =0;
    WMFDecoderEx *pDecoder = NULL;

    U8_WMC *pData = NULL;
    U32_WMC cbWanted;
    U32_WMC cbActual;
	tWMCDecStatus rc = WMCDec_Succeeded;

    if( NULL == phDecoder )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(*phDecoder);
    
    if(cbBuffer < MIN_OBJECT_SIZE)
        return WMCDec_BufferTooSmall;

    cbBuffer -= MIN_OBJECT_SIZE;




    cbWanted = 18;
    if(cbObjectOffset + cbWanted > cbBuffer)
    {
        return WMCDec_BufferTooSmall;
        
    }

    cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
    {
        return WMCDec_BufferTooSmall;
        
    }
    cbObjectOffset += cbActual;

    LoadGUID (PacketClockType , pData);

	if (IsEqualGUID_WMC( &CLSID_CAsfPacketClock1, &PacketClockType ) ==0)
	{
        pDecoder->tHeaderInfo.cbCurrentPacketOffset +=(U64_WMC)cbBuffer; // Use whole Object    
		return WMCDec_BadAsfHeader;
	}

    LoadWORD (PacketClockSize      , pData);

    if (PacketClockSize != 6)
    {
        pDecoder->tHeaderInfo.cbCurrentPacketOffset +=(U64_WMC)cbBuffer; // Use whole Object    
		return WMCDec_BadAsfHeader;
    }
    
    cbWanted = 4;
    if(cbObjectOffset + cbWanted > cbBuffer)
    {
        return WMCDec_BufferTooSmall;
        
    }

    cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
    {
        return WMCDec_BufferTooSmall;
        
    }
    cbObjectOffset += cbActual;

    LoadDWORD (dwHeaderExtDataSize    , pData);

	if (dwHeaderExtDataSize >= MIN_OBJECT_SIZE )
	{
		// There are more objects. parse them.
	
		GUID_WMC sobjId;
		U64_WMC sqwSize;
	
	
		while(cbObjectOffset < cbBuffer)
		{
			rc = LoadVirtualObjectHeader(phDecoder, &sobjId, &sqwSize, cbObjectOffset);
			if(rc != WMCDec_Succeeded)
			{
				return rc;
			}

			if( IsEqualGUID_WMC( &CLSID_AsfXMetaDataObject, &sobjId ) )
			{
				rc = LoadVirtualMetaDataObject(
						 //           pbBuffer,
									*((U32_WMC*) &sqwSize),
									phDecoder, cbObjectOffset );
				
				cbObjectOffset += (*((U32_WMC*)&sqwSize));
				if (WMCDec_Succeeded != rc)
					goto sabort;
			}
			else
			{
				/* skip over this object */
				cbObjectOffset += (*((U32_WMC*)&sqwSize));
			}
		}
	
	}

sabort:

    pDecoder->tHeaderInfo.cbCurrentPacketOffset +=(U64_WMC)cbBuffer; // Use whole Object    

    return WMCDec_Succeeded;
}

/****************************************************************************/
tWMCDecStatus
LoadVirtualMetaDataObject(
                    U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder, U32_WMC Offset)
{
    U32_WMC cbObjectOffset = 0;

    U16_WMC DescRecCount=0;
    WMFDecoderEx *pDecoder = NULL;
    U16_WMC i=0;

    U8_WMC *pData = NULL;
    U32_WMC cbWanted;
    U32_WMC cbActual;

	WMCMetaDataDescRecords *tDesc = NULL;

    if( NULL == phDecoder )
        return( WMCDec_InValidArguments );

    pDecoder = (WMFDecoderEx *)(*phDecoder);
    
    if(cbBuffer < MIN_OBJECT_SIZE)
        return WMCDec_BufferTooSmall;

    cbBuffer -= MIN_OBJECT_SIZE;
	Offset+=MIN_OBJECT_SIZE;
//	cbObjectOffset+= MIN_OBJECT_SIZE;

    cbWanted = 2;
    if(cbObjectOffset + cbWanted > cbBuffer)
    {
        return WMCDec_BufferTooSmall;
        
    }

    cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + Offset+ cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

    if(cbActual != cbWanted)
    {
        return WMCDec_BufferTooSmall;
        
    }
    cbObjectOffset += cbActual;

    LoadWORD(DescRecCount  , pData);

	if (DescRecCount >0)
	{
		pDecoder->tMetaDataEntry.m_wDescRecordsCount = DescRecCount;	
		pDecoder->tMetaDataEntry.pDescRec = (WMCMetaDataDescRecords *)wmvalloc(DescRecCount*sizeof(WMCMetaDataDescRecords));	
		
		if (NULL == pDecoder->tMetaDataEntry.pDescRec)
			return WMCDec_BadMemory;
		tDesc = pDecoder->tMetaDataEntry.pDescRec;	

		for (i=0; i<DescRecCount; i++)
		{
			cbWanted = 12;
			if(cbObjectOffset + cbWanted > cbBuffer)
			{
				return WMCDec_BufferTooSmall;
        
			}

			cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + Offset+ cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

			if(cbActual != cbWanted)
			{
				return WMCDec_BufferTooSmall;
        
			}
			cbObjectOffset += cbActual;
			
			LoadWORD(pDecoder->tMetaDataEntry.pDescRec[i].wLangIdIndex  , pData);
			LoadWORD(pDecoder->tMetaDataEntry.pDescRec[i].wStreamNumber   , pData);
			LoadWORD(pDecoder->tMetaDataEntry.pDescRec[i].wNameLenth  , pData);
			LoadWORD(pDecoder->tMetaDataEntry.pDescRec[i].wDataType  , pData);
			LoadWORD(pDecoder->tMetaDataEntry.pDescRec[i].wDataLength  , pData);
			
			if (pDecoder->tMetaDataEntry.pDescRec[i].wNameLenth >0)  // Length is in bytes
			{
				pDecoder->tMetaDataEntry.pDescRec[i].pwName = (U16Char_WMC *)wmvalloc(pDecoder->tMetaDataEntry.pDescRec[i].wNameLenth);	
				if(NULL == pDecoder->tMetaDataEntry.pDescRec[i].pwName)
					return WMCDec_BadMemory;
			
				cbWanted = (pDecoder->tMetaDataEntry.pDescRec[i].wNameLenth);
				if(cbObjectOffset + cbWanted > cbBuffer)
				{
					return WMCDec_BufferTooSmall;
        
				}

				cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + Offset+ cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

				if(cbActual != cbWanted)
				{
					return WMCDec_BufferTooSmall;
        
				}
				cbObjectOffset += cbActual;

				memcpy(pDecoder->tMetaDataEntry.pDescRec[i].pwName, pData, pDecoder->tMetaDataEntry.pDescRec[i].wNameLenth);
			}


			if (pDecoder->tMetaDataEntry.pDescRec[i].wDataLength >0)
			{
				U32_WMC dwMemLength =0;

				dwMemLength = pDecoder->tMetaDataEntry.pDescRec[i].wDataLength;
			/*	switch(pDecoder->tMetaDataEntry.pDescRec->wDataType)
				{
				case 0x0000:
				case 0x8000:
					dwMemLength = sizeof(U16Char_WMC)*pDecoder->tMetaDataEntry.pDescRec->wDataLength;
					break;
				case 0x0001:
				case 0x8001:
					dwMemLength = pDecoder->tMetaDataEntry.pDescRec->wDataLength;
					break;
				case 0x0002:
				case 0x8002:
					dwMemLength = 2;
					break;
				case 0x0003:
				case 0x8003:
					dwMemLength = 4;
					break;
				case 0x0004:
				case 0x8004:
					dwMemLength = 8;
					break;
				case 0x0005:
				case 0x8005:
					dwMemLength = 2;
					break;
				case 0x0006:
				case 0x8006:
					dwMemLength = 8;
					break;
				default:
					dwMemLength = pDecoder->tMetaDataEntry.pDescRec->wDataLength;
				} */

				pDecoder->tMetaDataEntry.pDescRec[i].pData = (Void_WMC *)wmvalloc(dwMemLength);	
				if(NULL == pDecoder->tMetaDataEntry.pDescRec[i].pData)
					return WMCDec_BadMemory;
			
				cbWanted = dwMemLength;
				if(cbObjectOffset + cbWanted > cbBuffer)
				{
					return WMCDec_BufferTooSmall;
        
				}

				cbActual = WMCDecCBGetData(*phDecoder, pDecoder->tHeaderInfo.cbCurrentPacketOffset + Offset+ cbObjectOffset, cbWanted, &pData, pDecoder->u32UserData);

				if(cbActual != cbWanted)
				{
					return WMCDec_BufferTooSmall;
        
				}
				cbObjectOffset += cbActual;

				memcpy(pDecoder->tMetaDataEntry.pDescRec[i].pData, pData, dwMemLength);
			}

			tDesc++;	
		}
	}



    return WMCDec_Succeeded;
}

/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\wmvver.h ===
#ifndef __WMVVER_H__
#define __WMVVER_H__

#include <xboxverp.h>

#ifdef __cplusplus
extern "C"
{
#endif

#pragma data_seg(push)
#pragma data_seg(".XBLD$V")

#if DBG
#pragma comment(linker, "/include:_WMVDecBuildNumberD")
__declspec(selectany) unsigned short WMVDecBuildNumberD[8] = { 'MW', 'DV', 'CE', 'D',
    VER_PRODUCTVERSION | 0x8000 };
#else
#pragma comment(linker, "/include:_WMVDecBuildNumber")
__declspec(selectany) unsigned short WMVDecBuildNumber[8] = { 'MW', 'DV', 'CE', 0,
    VER_PRODUCTVERSION | 0x4000 };
#endif

#pragma data_seg(pop)

#ifdef __cplusplus
}
#endif

#endif // __WMVVER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\wmvxmo.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation. All rights reserved.

Module Name:

    wmvxmo.cpp

Abstract:

    XMO wrapper for the WMV decoder library

--*/


#include "bldsetup.h"
#pragma comment(linker, "/merge:WMVDECRW=WMVDEC")
#pragma comment(linker, "/merge:WMVDECRD=WMVDEC")
#pragma comment(linker, "/section:WMVDEC,ERW")

#ifdef WMV_MEMORY_DEBUGGING
#include <ntos.h>
#endif

#include <xtl.h>
#include <wmvxmo.h>
#include <xdbg.h>

#include "wmcdecode.h"

//
// Convert the last error code to HRESULT
//
inline HRESULT GetLastHRESULT() {
    DWORD err = GetLastError();
    return HRESULT_FROM_WIN32(err);
}


//
// Helper class for implementing file data buffering
//
struct IOBUF {
    BYTE* StartPtr;
    DWORD StartOffset;
    DWORD ByteCount;
    INT State;
    OVERLAPPED Overlapped;

    enum { EMPTY, PENDING, READY };

    BOOL IsReady() { return State == READY; }
    BOOL IsPending() { return State == PENDING; }
    BOOL IsEmpty() { return State == EMPTY; }

    BOOL Contains(DWORD offset) {
        return (offset >= StartOffset) && (offset < StartOffset+ByteCount);
    }

    BOOL Contains(DWORD offset, DWORD count) {
        return (offset >= StartOffset) && (offset + count <= StartOffset + ByteCount);
    }
};

struct CFileBuffer {
    //
    // Constructor
    //
    CFileBuffer() {
        m_File = INVALID_HANDLE_VALUE;
        m_AllocBuffer = NULL;
        m_ErrorFlag = FALSE;
        memset(m_Buffers, 0, sizeof(m_Buffers));
        memset(m_Events, 0, sizeof(m_Events));
    }

    //
    // Destructor
    //
    ~CFileBuffer() {
        if (m_File != INVALID_HANDLE_VALUE) {
            BOOL closeok = CloseHandle(m_File);
            ASSERT(closeok);
        }

        if (m_AllocBuffer) {
            BOOL freeok = VirtualFree(m_AllocBuffer, 0, MEM_RELEASE);
            ASSERT(freeok);

            XDBGTRC("WMVDEC", "Max backward jump: %d", m_MaxBackwardJump);
        }

        for (INT i=0; i < FILE_BUFFER_COUNT_TOTAL; i++) {
            if (m_Events[i]) {
                CloseHandle(m_Events[i]);
            }
        }
    }

    //
    // Wait for pending overlapped I/O to complete
    //
    VOID Flush() {
        if (IsOpen()) {
            for (INT i=0; i < FILE_BUFFER_COUNT_TOTAL; i++) {
                CheckIoBufCompletion(&m_Buffers[i], TRUE);
            }
        }
    }

    //
    // Open a file
    //
    BOOL IsOpen() { return (m_File != INVALID_HANDLE_VALUE); }

    BOOL OpenFile(LPCSTR filename) {
        DWORD fileflag = FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN;

        #ifndef DISABLE_FILE_BUFFERING
        fileflag |= FILE_FLAG_OVERLAPPED|FILE_FLAG_NO_BUFFERING;
        #endif

        m_File = CreateFile(filename,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            fileflag,
                            NULL);
        
        if (m_File == INVALID_HANDLE_VALUE) {
            XDBGWRN("WMVDEC", "Failed to open file %s: %d", filename, GetLastError());
            return FALSE;
        }

        m_FileSize = GetFileSize(m_File, NULL);
        if (m_FileSize == 0xffffffff) {
            XDBGWRN("WMVDEC", "Failed to get file size: %d", GetLastError());
            return FALSE;
        }

        ASSERT(m_FileSize <= 0xffffffff - FILE_BUFFER_COUNT_FORWARD*FILE_BUFFER_SIZE);
        return TRUE;
    }

    //
    // Initialize the file buffer object
    //
    HRESULT Initialize() {
        if (!m_AllocBuffer) {
            DWORD bufsize = FILE_BUFFER_COUNT_TOTAL * FILE_BUFFER_SIZE;
            m_AllocBuffer = (LPBYTE) VirtualAlloc(NULL, bufsize, MEM_COMMIT, PAGE_READWRITE); 
            if (!m_AllocBuffer) return DSERR_OUTOFMEMORY;
            memset(m_AllocBuffer, 0, bufsize);
        }

        m_CurBuf = m_Buffers;
        memset(m_Buffers, 0, sizeof(m_Buffers));

        for (INT i=0; i < FILE_BUFFER_COUNT_TOTAL; i++) {
            m_Buffers[i].StartPtr = m_AllocBuffer + i*FILE_BUFFER_SIZE;

            if (!m_Events[i]) {
                m_Events[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
                if (!m_Events[i])
                    return GetLastHRESULT();
            }
            m_Buffers[i].Overlapped.hEvent = m_Events[i];
        }

        m_MaxBackwardJump = 0;
        m_ErrorFlag = FALSE;
        return DS_OK;
    }

    //
    // Check if there is no data available in the file buffer
    //
    BOOL NoDataAvailable() {
        return CheckIoBufCompletion(&m_Buffers[0], FALSE);
    }

    //
    // Get the next file buffer after the specified one
    //
    IOBUF* GetNextBuf(IOBUF* iobuf) {
        return iobuf == &m_Buffers[FILE_BUFFER_COUNT_TOTAL-1] ? m_Buffers : iobuf+1;
    }

    //
    // Read data from the file
    //  NOTE: We assume the access pattern is almost sequential
    //  and optimize for that case accordingly.
    //
    DWORD ReadData(DWORD offset, DWORD byteCount, LPBYTE* ppData) {
        #ifdef DISABLE_FILE_BUFFERING

        DWORD cb;
        ASSERT(byteCount <= MAX_WMV_READ_REQUEST);
        if (SetFilePointer(m_File, offset, NULL, FILE_BEGIN) != offset ||
            !ReadFile(m_File, m_AllocBuffer, byteCount, &cb, NULL)) {
            XDBGWRN("WMVDEC", "ReadFile failed: %d", GetLastError());
            return 0;
        }

        *ppData = m_AllocBuffer;
        return cb;

        #else // !DISABLE_FILE_BUFFERING

        if (m_CurBuf->IsReady() && m_CurBuf->Contains(offset, byteCount)) {
            //
            // Fast code path: requested data is entirely in the current buffer
            //
            *ppData = m_CurBuf->StartPtr + (offset - m_CurBuf->StartOffset);
            return byteCount;
        }

        // We're in error state, fail all reads.
        *ppData = m_AllocBuffer;
        if (m_ErrorFlag || byteCount == 0) return 0;
        
        ASSERT(byteCount <= MAX_WMV_READ_REQUEST);
        if (offset >= m_FileSize || byteCount > m_FileSize-offset) {
            XDBGWRN("WMVDEC", "Trying to read past end of file: %d+%d", offset, byteCount);
            return 0;
        }

        //
        // If the new window base in the buffering window but
        // is behind the current window base, then we'll just
        // change the window base.
        //
        // Otherwise, we need to slide the entire buffering window.
        //
        DWORD newWindowBase = offset & ~(FILE_BUFFER_SIZE-1);

        // Barf if we're seeking back past our back buffer.
        // Note that one case is allowed: rewind from the index
        // at the end of the file to the beginning of the file.
        #if DBG
        DWORD backdelta;
        if ((newWindowBase < m_CurBuf->StartOffset) &&
            (backdelta = m_CurBuf->StartOffset - newWindowBase) < m_FileSize/2) {
            if (backdelta > m_MaxBackwardJump)
                m_MaxBackwardJump = backdelta;
            if (backdelta > FILE_BUFFER_COUNT_BACKWARD*FILE_BUFFER_SIZE) {
                DbgPrint(
                    "Your WMV file is badly encoded. Please read the Xbox WMV\n"
                    "encoding guidelines and reencode your movie.\n");
                __asm int 3;
            }
        }
        #endif

        INT i = (newWindowBase>>FILE_BUFFER_SIZE_SHIFT) % FILE_BUFFER_COUNT_TOTAL;
        IOBUF* curbuf = m_CurBuf = &m_Buffers[i];

        if (curbuf->IsPending() && curbuf->StartOffset != newWindowBase) {
            CheckIoBufCompletion(curbuf, TRUE);
        }

        i = FILE_BUFFER_COUNT_FORWARD;
        do {
            if (curbuf->IsEmpty() ||
                curbuf->StartOffset != newWindowBase && !curbuf->IsPending()) {
                StartReadRequest(curbuf, newWindowBase);
            }
            curbuf = GetNextBuf(curbuf);
            newWindowBase += FILE_BUFFER_SIZE;
        } while (--i && newWindowBase < m_FileSize);

        if (m_CurBuf->IsPending()) {
            CheckIoBufCompletion(m_CurBuf, TRUE);
        }

        if (m_CurBuf->Contains(offset, byteCount)) {
            *ppData = m_CurBuf->StartPtr + (offset - m_CurBuf->StartOffset);
            return byteCount;
        }
    
        if (m_CurBuf->ByteCount != FILE_BUFFER_SIZE) {
            XDBGWRN("WMVDEC", "Not enough data: %d+%d", offset, byteCount);
            return 0;
        }

        //
        // The data is split into two different buffers
        //
        DWORD cnt1 = m_CurBuf->StartOffset + m_CurBuf->ByteCount - offset;
        memcpy(m_PartialBuf, m_CurBuf->StartPtr+m_CurBuf->ByteCount-cnt1, cnt1);
        offset += cnt1;

        DWORD cnt2 = byteCount - cnt1;
        BYTE* p;
        if (ReadData(offset, cnt2, &p) != cnt2)
            return 0;

        ASSERT(p != m_PartialBuf);
        memcpy(&m_PartialBuf[cnt1], p, cnt2);
        *ppData = m_PartialBuf;
        return byteCount;

        #endif // !DISABLE_FILE_BUFFERING
    }


    //
    // Initiate an overlapped read operation
    //
    VOID StartReadRequest(IOBUF* iobuf, DWORD offset) {
        iobuf->StartOffset = offset & ~(FILE_BUFFER_SIZE-1);
        iobuf->Overlapped.OffsetHigh = 0;
        iobuf->Overlapped.Offset = iobuf->StartOffset;
        ResetEvent(iobuf->Overlapped.hEvent);

        BOOL result = ReadFile(
                            m_File,
                            iobuf->StartPtr,
                            FILE_BUFFER_SIZE, 
                            &iobuf->ByteCount,
                            &iobuf->Overlapped);

        if (result) {
            // The read completes successfully right away
            iobuf->State = IOBUF::READY;
        } else {
            iobuf->ByteCount = 0;
            DWORD err = GetLastError();
            if (err == ERROR_IO_PENDING) {
                iobuf->State = IOBUF::PENDING;
            } else {
                XDBGWRN("WMVDEC", "ReadFile failed: error = %d\n", err);
                iobuf->State = IOBUF::EMPTY;
                m_ErrorFlag = TRUE;
            }
        }
    }

    //
    // Check if both IO buffers have pending I/O operations
    //
    BOOL CheckIoBufCompletion(IOBUF* iobuf, BOOL wait) {
        if (!iobuf->IsPending()) return FALSE;

        // Do the faster check first
        if (!wait && !HasOverlappedIoCompleted(&iobuf->Overlapped))
            return TRUE;
        
        BOOL result = GetOverlappedResult(m_File, &iobuf->Overlapped, &iobuf->ByteCount, wait);

        if (result) {
            iobuf->State = IOBUF::READY;
        } else {
            DWORD err = GetLastError();
            if (err == ERROR_IO_INCOMPLETE)
                return TRUE;

            XDBGWRN("WMVDEC", "Overlapped read failed: error = %d\n", err);
            iobuf->State = IOBUF::EMPTY;
            iobuf->ByteCount = 0;
            m_ErrorFlag = TRUE;
        }

        return FALSE;
    }

    enum {
        MAX_DISK_SECTOR_SIZE = 2*1024,      // for both DVD and hard disk
        MAX_WMV_READ_REQUEST = 512,         // max WMV read request - currently at 512 bytes
        FILE_BUFFER_SIZE_SHIFT = 16,
        FILE_BUFFER_SIZE = 1 << FILE_BUFFER_SIZE_SHIFT,
        FILE_BUFFER_COUNT_FORWARD = 4,
        FILE_BUFFER_COUNT_BACKWARD = 14,
        FILE_BUFFER_COUNT_TOTAL = FILE_BUFFER_COUNT_FORWARD+FILE_BUFFER_COUNT_BACKWARD,
    };

    HANDLE m_File;
    DWORD m_FileSize;
    BYTE* m_AllocBuffer;
    BOOL m_ErrorFlag;
    DWORD m_MaxBackwardJump;
    IOBUF* m_CurBuf;
    IOBUF m_Buffers[FILE_BUFFER_COUNT_TOTAL];
    HANDLE m_Events[FILE_BUFFER_COUNT_TOTAL];
    BYTE m_PartialBuf[MAX_WMV_READ_REQUEST];
};

class CWMVDecoder : public IWMVDecoder {
public:
    CWMVDecoder() {
        m_RefCount = 1;
        m_Signature = MYSIGNATURE;
        m_LastHR = DS_OK;
        m_Callback = NULL;
        m_LastHR = DS_OK;
        m_WMC = NULL;
        m_NumAudioStreams = m_NumVideoStreams = 0;
        m_AudioSampleSize = 0;
    }

    ~CWMVDecoder() { Reset(); }

    STDMETHODIMP_(ULONG) AddRef() {
       return InterlockedIncrement(&m_RefCount);
    }

    STDMETHODIMP_(ULONG) Release() {
       long refcnt = InterlockedDecrement(&m_RefCount);
       if (refcnt == 0) delete this;
       return refcnt;
    }

    STDMETHODIMP GetInfo(LPXMEDIAINFO pInfo) {
        //
        // These flags are copied from WMA XMO interface.
        // I'm not sure what effects they actually have, if any.
        //
        pInfo->dwFlags = XMO_STREAMF_FIXED_SAMPLE_SIZE |
                         XMO_STREAMF_FIXED_PACKET_ALIGNMENT;

        // dwInputSize field is not applicable to us.
        //  Just default it to something.
        pInfo->dwInputSize = m_AudioSampleSize;

        //
        // dwOutputSize is applicable only to audio output packet
        // and not to video output packet
        //
        pInfo->dwOutputSize = 2048 * m_AudioSampleSize;
        pInfo->dwMaxLookahead = 0;

        return DS_OK;
    }

    STDMETHODIMP GetStatus(DWORD* pdwStatus) {
        //
        // Since we're synchronous, we're always ready to accept input and output
        //
        *pdwStatus = XMO_STATUSF_ACCEPT_INPUT_DATA | XMO_STATUSF_ACCEPT_OUTPUT_DATA;
        return DS_OK;
    }

    STDMETHODIMP Process(LPCXMEDIAPACKET pInputPacket, LPCXMEDIAPACKET pOutputPacket) {
        //
        // Not supported, use Decode method instead
        //
        return DSERR_UNSUPPORTED;
    }

    STDMETHODIMP Discontinuity() {
        //
        // This is a NOP for us, always return success
        //
        return DS_OK;
    }

    STDMETHODIMP Flush() {
        //
        // Clean up the current state and reinitialize the decoder
        //
        HRESULT hr = Reset();
        if (SUCCEEDED(hr)) hr = Initialize();
        return (m_LastHR = hr);
    }

    STDMETHODIMP GetPlayDuration(PREFERENCE_TIME prtPlayDuration, PREFERENCE_TIME prtPreroll) {
        *prtPlayDuration = (REFERENCE_TIME) m_WMVHeaderInfo.u32PlayDuration * 10000;
        *prtPreroll = (REFERENCE_TIME) m_WMVHeaderInfo.u32Preroll * 10000;
        return DS_OK;
    }

    STDMETHODIMP GetVideoInfo(LPWMVVIDEOINFO pVideoInfo);
    STDMETHODIMP GetAudioInfo(LPWAVEFORMATEX pAudioInfo);
    STDMETHODIMP ProcessMultiple(LPCXMEDIAPACKET pVideoOutputPacket, LPCXMEDIAPACKET pAudioOutputPacket);
    STDMETHODIMP Seek(PREFERENCE_TIME prtSeekPosition);

    HRESULT Initialize();
    HRESULT Reset();
    DWORD ReadFileData(DWORD offset, DWORD byteCount, LPBYTE* ppData);

    LONG m_RefCount;
    DWORD m_Signature;
    LPFNWMVXMODATACALLBACK m_Callback;
    LPVOID m_ClientContext;
    HRESULT m_LastHR;
    HWMCDECODER m_WMC;
    tVideoFormat_WMC m_VideoOutputFormat;
    DWORD m_NumAudioStreams, m_NumVideoStreams;
    strAudioInfo_WMC m_AudioStreamInfo;
    strVideoInfo_WMC m_VideoStreamInfo;
    strHeaderInfo_WMC m_WMVHeaderInfo;
    DWORD m_AudioSampleSize;
    INT m_LastStreamId;
    INT m_NoOutputDataCount;
    CFileBuffer m_FileBuffer;

    enum { MYSIGNATURE = 'WMVX' };
    enum { STREAMID_NONE = 0xffffffff };
};


STDAPI
WmvCreateDecoder(
    IN LPCSTR pszFileName,
    IN LPFNWMVXMODATACALLBACK pfnCallback,
    IN DWORD dwVideoOutputFormat,
    IN LPVOID pvContext,
    OUT LPWMVDECODER* ppWmvDecoder
    )

/*++

Routine Description:

    Create a WMV decoder instance

Arguments:

    pszFilename - Specifies the name of the WMV file to be decoded
    pfnCallback - Supply the callback function for reading input data
        either pszFilename or pfnCallback should be specified, but not both
    dwVideoOutputFormat - Specifies the video output format
        must be WMVVIDEOFORMAT_YUY2
    pvContext - This pointer will be passed to the callback function
    ppWmvDecoder - Returns a pointer to the new WMV decoder instance

Return Value:

    Error code

--*/

{
    ASSERT(pszFileName || pfnCallback);
    ASSERT(dwVideoOutputFormat == WMVVIDEOFORMAT_YUY2);

    #ifdef WMV_MEMORY_DEBUGGING
    WmvDebugMemInit();
    #endif

    *ppWmvDecoder = NULL;

    CWMVDecoder* decoder = new CWMVDecoder;
    if (!decoder) return DSERR_OUTOFMEMORY;
    decoder->m_ClientContext = pvContext;
    decoder->m_VideoOutputFormat = YUY2_WMV;

    HRESULT hr = DS_OK;
    if (pszFileName) {
        // If the filename is specified, we ignore the callback function.

        // Open the file
        if (!decoder->m_FileBuffer.OpenFile(pszFileName))
            hr = GetLastHRESULT();
    } else {
        decoder->m_Callback = pfnCallback;
    }

    if (SUCCEEDED(hr))
        hr = decoder->Initialize();

    if (SUCCEEDED(hr))
        *ppWmvDecoder = decoder;
    else
        delete decoder;

    return hr;
}


HRESULT
CWMVDecoder::Initialize()

/*++

Routine Description:

    Initialize the WMV decoder instance

Arguments:

    NONE

Return Value:

    Error code

--*/

{
    if (m_FileBuffer.IsOpen()) {
        //
        // Initialize the file buffer
        //
        HRESULT hr = m_FileBuffer.Initialize();
        if (FAILED(hr)) return hr;
    }

    //
    // Create the WMV decoder object
    //
    tWMCDecStatus wmcerr;
    m_WMC = WMCDecCreate((U32_WMC) this);
    if (!m_WMC) {
        wmcerr = WMCDec_Fail;
        goto exit;
    }

    //
    // Initialize the decoder
    //
    wmcerr = WMCDecInit(&m_WMC, m_VideoOutputFormat, TRUE, 0);
    if (wmcerr != WMCDec_Succeeded) goto exit;
    
    wmcerr = WMCDecGetHeaderInfo(m_WMC, &m_WMVHeaderInfo);
    if (wmcerr != WMCDec_Succeeded) goto exit;

    XDBGTRC("WMVDEC",
        "WMV header information:\n"
        "  play duration: %d\n"
        "  preroll: %d\n"
        "  send duration: %d\n"
        "  max bit rate: %d\n"
        "  has DRM: %d\n",
        m_WMVHeaderInfo.u32PlayDuration,
        m_WMVHeaderInfo.u32Preroll,
        m_WMVHeaderInfo.u32SendDuration,
        m_WMVHeaderInfo.u32MaxBitrate,
        m_WMVHeaderInfo.u8HasDRM);

    //
    // Get information about each stream in the WMV file
    //
    U32_WMC i, numStreams;
    tStreamIdnMediaType_WMC* streamTypes;
    wmcerr = WMCDecGetStreamInfo(m_WMC, &numStreams, &streamTypes);
    if (wmcerr != WMCDec_Succeeded) goto exit;

    XDBGTRC("WMVDEC", "Number of streams: %d", numStreams);

    tStreamIdPattern_WMC* decPatterns;
    decPatterns = (tStreamIdPattern_WMC*) wmvalloc(numStreams * sizeof(*decPatterns));
    if (!decPatterns) {
        wmcerr = WMCDec_BadMemory;
        goto exit;
    }

    U32_WMC selectedVideoStreamIndex = 0xffffffff;
    U32_WMC selectedAudioStreamIndex = 0xffffffff;
    m_NumAudioStreams = m_NumVideoStreams = 0;
    for (i=0; i < numStreams && wmcerr == WMCDec_Succeeded; i++) {
        U16_WMC streamId = streamTypes[i].wStreamId;
        XDBGTRC("WMVDEC", "Stream: id = %d", streamId);
        ASSERT(streamId != STREAMID_NONE);

        decPatterns[i].wStreamId = streamId;
        decPatterns[i].tPattern = Discard_WMC;

        switch (streamTypes[i].MediaType) {
        case Audio_WMC: {
            strAudioInfo_WMC audioStreamInfo;
            wmcerr = WMCDecGetAudioInfo(m_WMC, streamId, &audioStreamInfo);
            if (wmcerr != WMCDec_Succeeded) goto exit;

            m_NumAudioStreams++;
            if (selectedAudioStreamIndex != 0xffffffff) {
                if (m_AudioStreamInfo.u32BitsPerSecond < audioStreamInfo.u32BitsPerSecond) {
                    XDBGWRN("WMVDEC",
                        "Discarding audio stream: id = %d",
                        m_AudioStreamInfo.u16StreamId);
                    decPatterns[selectedAudioStreamIndex].tPattern = Discard_WMC;
                } else {
                    XDBGWRN("WMVDEC",
                        "Discarding audio stream: id = %d",
                        audioStreamInfo.u16StreamId);
                    break;
                }
            }

            selectedAudioStreamIndex = i;
            decPatterns[i].tPattern = Decompressed_WMC;
            m_AudioStreamInfo = audioStreamInfo;
            ASSERT(streamId == audioStreamInfo.u16StreamId);
            break;
        }

        case Video_WMC: {
            strVideoInfo_WMC videoStreamInfo;
            wmcerr = WMCDecGetVideoInfo(m_WMC, streamId, &videoStreamInfo);
            if (wmcerr != WMCDec_Succeeded) goto exit;

            m_NumVideoStreams++;
            if (selectedVideoStreamIndex != 0xffffffff) {
                if (m_VideoStreamInfo.u32BitsPerSecond < videoStreamInfo.u32BitsPerSecond) {
                    XDBGWRN("WMVDEC",
                        "Discarding video stream: id = %d",
                        m_VideoStreamInfo.u16StreamId);
                    decPatterns[selectedVideoStreamIndex].tPattern = Discard_WMC;
                } else {
                    XDBGWRN("WMVDEC",
                        "Discarding video stream: id = %d",
                        videoStreamInfo.u16StreamId);
                    break;
                }
            }

            selectedVideoStreamIndex = i;
            decPatterns[i].tPattern = Decompressed_WMC;
            m_VideoStreamInfo = videoStreamInfo;
            ASSERT(streamId == videoStreamInfo.u16StreamId);
            break;
        }

        case Binary_WMC: {
            XDBGWRN("WMVDEC", "Binary stream ignored");

            strBinaryInfo_WMC binaryStreamInfo;
            wmcerr = WMCDecGetBinaryInfo(m_WMC, streamId, &binaryStreamInfo);
            break;
        }

        default:
            XDBGWRN("WMVDEC", "Unknown stream type: %d", streamTypes[i].MediaType);
            break;
        }
    }

    if (wmcerr == WMCDec_Succeeded)
        wmcerr = WMCDecSetDecodePatternForStreams(&m_WMC, decPatterns);
    wmvfree(decPatterns);
    if (wmcerr != WMCDec_Succeeded) goto exit;

    //
    // Only 16-bit PCM audio is supported at the moment
    //
    if (m_NumAudioStreams) {
        XDBGTRC("WMVDEC",
            "Active audio stream:\n"
            "  format tag: %d\n"
            "  bits-per-second: %d\n"
            "  bits-per-sample: %d\n"
            "  samples-per-second: %d\n"
            "  number of channels: %d\n"
            "  block size: %d\n"
            "  valid bits-per-sample: %d\n"
            "  channel mask: %d\n"
            "  stream id: %d\n",
            m_AudioStreamInfo.u16FormatTag,
            m_AudioStreamInfo.u32BitsPerSecond,
            m_AudioStreamInfo.u16BitsPerSample,
            m_AudioStreamInfo.u16SamplesPerSecond,
            m_AudioStreamInfo.u16NumChannels,
            m_AudioStreamInfo.u32BlockSize,
            m_AudioStreamInfo.u16ValidBitsPerSample,
            m_AudioStreamInfo.u32ChannelMask,
            m_AudioStreamInfo.u16StreamId);

        ASSERT(m_AudioStreamInfo.u16BitsPerSample == 16 &&
               m_AudioStreamInfo.u16ValidBitsPerSample == 16);

        m_AudioSampleSize = m_AudioStreamInfo.u16NumChannels *
                            m_AudioStreamInfo.u16ValidBitsPerSample / 8;
    } else {
        XDBGWRN("WMVDEC", "No audio stream");
    }

    //
    // Frame width must be even
    //
    if (m_NumVideoStreams) {
        XDBGTRC("WMVDEC",
            "Active video stream:\n"
            "  compression: 0x%x\n"
            "  bits-per-second: %d\n"
            "  frames-per-second: %d\n"
            "  width: %d\n"
            "  height: %d\n"
            "  stream id: %d\n"
            "  output bit count: %d\n"
            "  output pixel type: 0x%x\n",
            m_VideoStreamInfo.u32Compression,
            m_VideoStreamInfo.u32BitsPerSecond,
            (ULONG) m_VideoStreamInfo.fltFramesPerSecond,
            m_VideoStreamInfo.i32Width,
            m_VideoStreamInfo.i32Height,
            m_VideoStreamInfo.u16StreamId,
            m_VideoStreamInfo.u16VideoOutputBitCount,
            m_VideoStreamInfo.u32VideoOutputPixelType);

        ASSERT(m_VideoStreamInfo.i32Width > 0 &&
               m_VideoStreamInfo.i32Height > 0 &&
               m_VideoStreamInfo.i32Width % 2 == 0);
    } else {
        XDBGWRN("WMVDEC", "No video stream");
    }

    m_LastStreamId = STREAMID_NONE;

    // Start this with a reasonably large negative number
    // because for some files the decoder will return
    // no data for quite a few calls to WMCDecDecodeData
    // at the beginning of the file.
    m_NoOutputDataCount = -100;

exit:
    if (wmcerr == WMCDec_Succeeded)
        return DS_OK;
    
    XDBGWRN("WMVDEC", "Initialization failed: %d", wmcerr);
    return MAKE_WMVHRESULT(wmcerr);
}


HRESULT
CWMVDecoder::Reset()

/*++

Routine Description:

    Reset the WMV decoder instance

Arguments:

    NONE

Return Value:

    Error code

--*/

{
    m_FileBuffer.Flush();

    if (m_WMC) {
        tWMCDecStatus wmcerr = WMCDecClose(&m_WMC);
        if (wmcerr == WMCDec_Succeeded)
            m_WMC = NULL;
        else
            return MAKE_WMVHRESULT(wmcerr);
    }

    return DS_OK;
}


U32_WMC
WMCDecCBGetData(
    HWMCDECODER hWMCDec,
    U64_WMC nOffset,
    U32_WMC nNumBytesRequest,
    U8_WMC **ppData,
    U32_WMC u32UserData
    )

/*++

Routine Description:

    This is the callback function for the WMV decoder library

Arguments:

    hWMCDec - Handle to the decoder object
    nOffset - Specifies the byte offset from the beginning of the WMV file
    nNumBytesRequest - Specifies the amount of data requested
    ppData - Returns a pointer to the input data
    u32UserData - User context

Return Value:

    Number of bytes returned, 0 if there is an error

--*/

{
    // NOTE: WMV XMO callback only support 32-bit offset
    ASSERT((nOffset >> 32) == 0);
    DWORD offset = (DWORD) nOffset;

    CWMVDecoder* decoder = (CWMVDecoder*) u32UserData;

    if (decoder->m_Callback) {
        return (*decoder->m_Callback)(
                    decoder->m_ClientContext,
                    offset,
                    nNumBytesRequest,
                    (LPVOID*) ppData);
    } else {
        return decoder->m_FileBuffer.ReadData(offset, nNumBytesRequest, ppData);
    }
}


STDMETHODIMP
CWMVDecoder::GetAudioInfo(
    LPWAVEFORMATEX pAudioInfo
    )

/*++

Routine Description:

    Get information about the active audio stream

Arguments:

    pAudioInfo - Output buffer for returning the audio stream information

Return Value:

    Error code

--*/

{
    if (m_NumAudioStreams == 0)
        return WMVERR_NO_AUDIO_STREAM;

    pAudioInfo->wFormatTag = WAVE_FORMAT_PCM;
    pAudioInfo->nChannels = m_AudioStreamInfo.u16NumChannels;
    pAudioInfo->nSamplesPerSec = m_AudioStreamInfo.u16SamplesPerSecond;
    pAudioInfo->wBitsPerSample = m_AudioStreamInfo.u16ValidBitsPerSample;
    pAudioInfo->nBlockAlign = (WORD) m_AudioSampleSize;
    pAudioInfo->nAvgBytesPerSec = m_AudioStreamInfo.u16SamplesPerSecond * m_AudioSampleSize;
    pAudioInfo->cbSize = 0;

    return DS_OK;
}


STDMETHODIMP
CWMVDecoder::GetVideoInfo(
    LPWMVVIDEOINFO pVideoInfo
    )

/*++

Routine Description:

    Get information about the active video stream

Arguments:

    pVideoInfo - Output buffer for returning the video stream information

Return Value:

    Error code

--*/

{
    if (m_NumVideoStreams == 0)
        return WMVERR_NO_VIDEO_STREAM;

    pVideoInfo->dwWidth = m_VideoStreamInfo.i32Width;
    pVideoInfo->dwHeight = m_VideoStreamInfo.i32Height;
    pVideoInfo->dwOutputBitsPerPixel = m_VideoStreamInfo.u16VideoOutputBitCount;
    pVideoInfo->fFramesPerSecond = m_VideoStreamInfo.fltFramesPerSecond;
    pVideoInfo->dwBitsPerSecond = m_VideoStreamInfo.u32BitsPerSecond;

    return DS_OK;
}


STDMETHODIMP
CWMVDecoder::ProcessMultiple(
    LPCXMEDIAPACKET pVideoOutputPacket,
    LPCXMEDIAPACKET pAudioOutputPacket
    )

/*++

Routine Description:

    Description of the function

Arguments:

    pVideoOutputPacket - Video output packet
    pAudioOutputPacket - Audio output packet

Return Value:

    Error code

--*/

{
    if( pVideoOutputPacket ) {
        *(pVideoOutputPacket->pdwCompletedSize) = 0;
        *(pVideoOutputPacket->pdwStatus) = XMEDIAPACKET_STATUS_PENDING;
    }

    if( pAudioOutputPacket ) {
        *(pAudioOutputPacket->pdwCompletedSize) = 0;
        *(pAudioOutputPacket->pdwStatus) = XMEDIAPACKET_STATUS_PENDING;
    }

    // Check if the decoder object is in an error state
    if (FAILED(m_LastHR)) {
        if( pVideoOutputPacket )
            *(pVideoOutputPacket->pdwStatus) = XMEDIAPACKET_STATUS_FAILURE;
        if( pAudioOutputPacket )
            *(pAudioOutputPacket->pdwStatus) = XMEDIAPACKET_STATUS_FAILURE;
        return m_LastHR;
    }

    U32_WMC readyId, samplesReady;
    tWMCDecStatus wmcerr;
    HRESULT hr = DS_OK;

    if (m_LastStreamId != STREAMID_NONE) {
        readyId = m_LastStreamId;
        samplesReady = 1;
    } else {
    retry:
        //
        // If there is no data available in the file buffer, we'll end up
        // blocking in WMCDecCBGetData. So we don't call WMCDecDecodeData
        // at all and just return empty-handed. This is not foolproof but
        // should help in majority of the cases.
        //
        if (m_FileBuffer.NoDataAvailable())
            goto success;

        wmcerr = WMCDecDecodeData(m_WMC, &readyId, &samplesReady, 0);
        if (wmcerr == WMCDec_DecodeComplete) {
            XDBGTRC("WMVDEC", "Decoding completed: %d", samplesReady);
            hr = S_FALSE;
            goto success;
        }
    }

    if (samplesReady > 0) {
        U32_WMC outputSize = 0;
        I64_WMC timestamp;
        LPCXMEDIAPACKET packet;

        if (readyId == m_AudioStreamInfo.u16StreamId) {
            if( !pAudioOutputPacket ) {
                m_LastStreamId = readyId;
                hr = E_PENDING;
                goto success;
            }

            //
            // Audio stream is ready for output
            //
            I16_WMC* buf = (I16_WMC*) pAudioOutputPacket->pvBuffer;
            U32_WMC remainingSpace = pAudioOutputPacket->dwMaxSize / m_AudioSampleSize;
            U32_WMC samplesDecoded;
            I64_WMC ts;

            while (TRUE) {
                // We only care about the timestamp for the first output sample
                wmcerr = WMCDecGetAudioOutput(
                            m_WMC,
                            buf,
                            NULL,
                            remainingSpace,
                            &samplesDecoded,
                            (outputSize == 0) ? &timestamp : &ts);
                if (wmcerr != WMCDec_Succeeded) goto error;

                if (samplesDecoded == 0) break;
                outputSize += samplesDecoded;
                if ((remainingSpace -= samplesDecoded) == 0) break;
                buf += samplesDecoded;
            }

            *(pAudioOutputPacket->pdwCompletedSize) = outputSize * m_AudioSampleSize;
            packet = pAudioOutputPacket;
        } else if (readyId == m_VideoStreamInfo.u16StreamId) {
            ASSERT( samplesReady == 1 );
            if( !pVideoOutputPacket ) {
                m_LastStreamId = readyId;
                hr = E_PENDING;
                goto success;
            }

            //
            // Video stream is ready for output
            //
            Bool_WMC isKeyFrame;
            wmcerr = WMCDecGetVideoOutput(
                        m_WMC,
                        (U8_WMC*) pVideoOutputPacket->pvBuffer,
                        pVideoOutputPacket->dwMaxSize,
                        &outputSize,
                        &timestamp,
                        &isKeyFrame,
                        WMC_DispRotate0);

            if (wmcerr != WMCDec_Succeeded) goto error;

            ASSERT(outputSize == m_VideoStreamInfo.i32Width *
                                 m_VideoStreamInfo.i32Height *
                                 m_VideoStreamInfo.u16VideoOutputBitCount / 8);

            readyId = STREAMID_NONE;
            *(pVideoOutputPacket->pdwCompletedSize) = outputSize;
            packet = pVideoOutputPacket;
        } else {
            XDBGWRN("WMVDEC", "Unexpected stream is ready for output: %d", readyId);
        }

        if (outputSize) {
            // Convert from milliseconds to 100ns
            if (packet->prtTimestamp)
                *(packet->prtTimestamp) = timestamp * 10000;

            m_LastStreamId = readyId;
            m_NoOutputDataCount = 0;
        } else if (m_LastStreamId != STREAMID_NONE) {
            m_LastStreamId = STREAMID_NONE;
            goto retry;
        }
    } else if (m_NoOutputDataCount++ >= 4) {
        //
        // HACK: This to workaround a bug in the decoder library
        // where WMCDecDecodeData never returns WMCDec_DecodeComplete.
        // So we have a kluge here to assume that the decoding is finished
        // if 4 consecutive calls to WMCDecDecodeData all return no data.
        //
        XDBGWRN("WMVDEC", "No output data, assume end of movie");
        hr = S_FALSE;
    }

success:
    if( pVideoOutputPacket )
        *(pVideoOutputPacket->pdwStatus) = XMEDIAPACKET_STATUS_SUCCESS;
    if( pAudioOutputPacket )
        *(pAudioOutputPacket->pdwStatus) = XMEDIAPACKET_STATUS_SUCCESS;
    return hr;
    
error:
    XDBGWRN("WMVDEC", "Decode failed: %d", wmcerr);
    if( pVideoOutputPacket )
        *(pVideoOutputPacket->pdwStatus) = XMEDIAPACKET_STATUS_FAILURE;
    if( pAudioOutputPacket )
        *(pAudioOutputPacket->pdwStatus) = XMEDIAPACKET_STATUS_FAILURE;
    return MAKE_WMVHRESULT(wmcerr);
}

STDMETHODIMP
CWMVDecoder::Seek(
    PREFERENCE_TIME prtSeekPosition
    )

/*++

Routine Description:

    Seek to the specified time position in the movie

Arguments:

    prtSeekPosition - On entry, this specifies the position to seek to
        on exit, this is updated to reflect the actually position that was seeked to

Return Value:

    Error code

--*/

{
    if (FAILED(m_LastHR))
        return m_LastHR;

    tWMCDecStatus wmcerr;
    U64_WMC seekpos = *prtSeekPosition / 10000;

    if (m_LastStreamId != STREAMID_NONE) {
        XDBGWRN("WMVDEC", "Seeking during playback is not supported");
        return DSERR_UNSUPPORTED;
    }

    wmcerr = WMCDecSeek(m_WMC, seekpos, &seekpos);
    if (wmcerr != WMCDec_Succeeded)
        return MAKE_WMVHRESULT(wmcerr);

    m_NoOutputDataCount = 0;
    *prtSeekPosition = seekpos * 10000;
    return DS_OK;
}

//
// Memory debugging facilities
//

#ifdef WMV_MEMORY_DEBUGGING

#define MAXFILENAMELEN 12
#define TAILPADALIGN sizeof(ULONG_PTR)

struct WmvDebugMemHeader {
    LIST_ENTRY links;
    CHAR filename[MAXFILENAMELEN];
    INT linenum;
    INT size;
    VOID* ptr;
};

INITIALIZED_CRITICAL_SECTION(WmvDebugMemLock);
LIST_ENTRY WmvDebugMemList;
HANDLE WmvDebugMemHeap;

void WmvDebugMemInit()
{
    EnterCriticalSection(&WmvDebugMemLock);
    if (!WmvDebugMemHeap) {
        WmvDebugMemHeap = GetProcessHeap();
        InitializeListHead(&WmvDebugMemList);
    }
    LeaveCriticalSection(&WmvDebugMemLock);
}

void* WmvDebugAlloc(char* filename, int linenum, size_t size)
{
    size_t allocsize = sizeof(WmvDebugMemHeader) +
                       ((size + (TAILPADALIGN-1)) & ~(TAILPADALIGN-1)) +
                       TAILPADALIGN;

    WmvDebugMemHeader* entry = (WmvDebugMemHeader*) HeapAlloc(WmvDebugMemHeap, 0, allocsize);
    if (!entry) return NULL;

    char* basename = strrchr(filename, '\\');
    if (basename)
        basename += 1;
    else
        basename = filename;

    strncpy(entry->filename, basename, MAXFILENAMELEN);
    entry->linenum = linenum;
    entry->size = size;
    entry->ptr = entry + 1;

    ULONG_PTR tailmagic = (ULONG_PTR) entry->ptr + entry->size;
    ULONG_PTR* tail = (ULONG_PTR*) entry->ptr + (size / TAILPADALIGN);

    if (size % TAILPADALIGN) {
        *tail++ = tailmagic;
        tailmagic += TAILPADALIGN;
    }
    *tail = tailmagic;

    EnterCriticalSection(&WmvDebugMemLock);
    InsertHeadList(&WmvDebugMemList, &entry->links);
    LeaveCriticalSection(&WmvDebugMemLock);

    return entry->ptr;
}

#define WMVDEBUGFREEASSERT(cond) do { \
            if (!(cond)) { \
                DbgPrint("!!!!!!!! Memory corruption:\n"); \
                DbgPrint("  %s\n", #cond); \
                DbgPrint("  ptr = %x, entry = %x\n", ptr, entry); \
                __asm { int 3 }; \
            } \
        } while (0)

void WmvDebugFree(void* ptr)
{
    if (!ptr) return;

    EnterCriticalSection(&WmvDebugMemLock);

    WmvDebugMemHeader* entry = (WmvDebugMemHeader*) ptr - 1;
    WMVDEBUGFREEASSERT(entry->ptr == ptr);

    LIST_ENTRY* preventry = (LIST_ENTRY*) entry->links.Blink;
    WMVDEBUGFREEASSERT(preventry->Flink == (void*) entry);

    LIST_ENTRY* nextentry = (LIST_ENTRY*) entry->links.Flink;
    WMVDEBUGFREEASSERT(nextentry->Blink == (void*) entry);

    ULONG_PTR tailmagic = (ULONG_PTR) entry->ptr + entry->size;
    ULONG_PTR* tail = (ULONG_PTR*) entry->ptr + (entry->size / TAILPADALIGN);

    if (entry->size % TAILPADALIGN) {
        ULONG_PTR mask = -1 << (TAILPADALIGN - entry->size%TAILPADALIGN)*8;
        WMVDEBUGFREEASSERT((*tail & mask) == (tailmagic & mask));
        tail++;
        tailmagic += TAILPADALIGN;
    }

    WMVDEBUGFREEASSERT(*tail == tailmagic);

    RemoveEntryList(&entry->links);

    tail[-1] = *tail = 0;
    entry->ptr = NULL;
    entry->links.Flink = entry->links.Blink = NULL;
    LeaveCriticalSection(&WmvDebugMemLock);

    HeapFree(WmvDebugMemHeap, 0, entry);
}

void* WmvDebugRealloc(char* filename, int linenum, void* ptr, size_t size)
{
    // We assume this is called very infrequently
    //  just free the old memory and realloc new memory
    WmvDebugFree(ptr);
    return WmvDebugAlloc(filename, linenum, size);
}

#endif // WMV_MEMORY_DEBUGGING
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\bitfields.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       bitfields.h
//
//--------------------------------------------------------------------------

#ifndef __BITFIELDS_H_
#define __BITFIELDS_H_
#include "typedef.hpp"
//#ifndef _WINGDI_

#if defined(__MACVIDEO__) || defined(__UNIXVIDEO__) || defined(_Embedded_x86) || defined(__arm) || defined(_XBOX)

#   ifndef _COLORSCHEME
#       define _COLORSCHEME
#       ifndef _XBOX
#           define BI_RGB        0L
#       endif
#       define BI_RLE8       1L
#       define BI_RLE4       2L
#       define BI_BITFIELDS  3L
#   endif

#   ifndef _BITMAPINFOHEADER
#       define _BITMAPINFOHEADER
        typedef struct tagBITMAPINFOHEADER{
            U32_WMV      biSize;
            Long       biWidth;
            Long       biHeight;
            U16_WMV       biPlanes;
            U16_WMV       biBitCount;
            U32_WMV      biCompression;
            U32_WMV      biSizeImage;
            Long       biXPelsPerMeter;
            Long       biYPelsPerMeter;
            U32_WMV      biClrUsed;
            U32_WMV      biClrImportant;
        } BITMAPINFOHEADER, *LPBITMAPINFOHEADER;//, *PBITMAPINFOHEADER;

#   endif

    typedef struct tagRGBQUAD {
            U8_WMV    rgbBlue;
            U8_WMV    rgbGreen;
            U8_WMV    rgbRed;
            U8_WMV    rgbReserved;
    } RGBQUAD;

    typedef struct tagBITMAPINFO {
        BITMAPINFOHEADER    bmiHeader;
#       ifdef __arm
            RGBQUAD             bmiColors[3];
#       else
            RGBQUAD             bmiColors[1];
#       endif
    } BITMAPINFO;// FAR *LPBITMAPINFO, *PBITMAPINFO;

#else 
#   if defined(_WIN32) || defined(_WIN16)
#       include <windows.h>
#       ifdef UNDER_CE
#           include "vfw_ce.h"
#       else
#           include <vfw.h>
#       endif // UNDER_CE
#   endif
#endif

#if !defined(_WIN32)
#   ifdef _Embedded_x86
        typedef struct tagBITMAPINFOHEADER_BITFIELDS{
            U32_WMV      biSize;
            Long       biWidth;
            Long       biHeight;
            U16_WMV       biPlanes;
            U16_WMV       biBitCount;
            U32_WMV      biCompression;
            U32_WMV      biSizeImage;
            Long       biXPelsPerMeter;
            Long       biYPelsPerMeter;
            U32_WMV      biClrUsed;
            U32_WMV      biClrImportant;
            U32_WMV dwMask[3];
        } BITMAPINFOHEADER_BITFIELDS;
#   else    // _Embedded_x86
        struct BITMAPINFOHEADER_BITFIELDS : tagBITMAPINFOHEADER {
            U32_WMV dwMask[3];
        };
#   endif   // _Embedded_x86
#else   // _WIN32
    struct BITMAPINFOHEADER_BITFIELDS : BITMAPINFOHEADER {
        U32_WMV dwMask[3];
};
#endif  // _WIN32

#endif  // __BITFIELDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\constants_wmv.h ===
#define MB_SIZE 16
#define BLOCK_SIZE 8
//#define SUB_BLOCK_SIZE 8
#define NUMBITS_SLICE_SIZE_WMV2         3 // To indicate Processor's #
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\codehead.h ===
/*************************************************************************

Copyright (c) 1996  Microsoft Corporation

Module Name:

	codehead.h

Abstract:
	define number of bits and some information for encoder/decoder

Author:

	Ming-Chieh Lee (mingcl@microsoft.com) 20-March-1996

Revision History:

*************************************************************************/

#ifndef __CODEHEAD_H_ 
#define __CODEHEAD_H_

#define MARKER_BIT						1

#define START_CODE_PREFIX				1
#define NUMBITS_START_CODE_PREFIX		24
#define NUMBITS_START_CODE_SUFFIX		8
#define USER_DATA_START_CODE			0xB2



// VOL overhead information
#define NUMBITS_VOL_START_CODE			4
#define VOL_START_CODE					2
#define NUMBITS_VOL_ID					4
#define NUMBITS_VOL_SHAPE				2
#define NUMBITS_VOL_WIDTH				13
#define NUMBITS_VOL_HEIGHT				13
#define NUMBITS_TIME_RESOLUTION			16
// #define NUMBITS_VOL_FCODE				2
#define NUMBITS_SEP_MOTION_TEXTURE		1
#define NUMBITS_QMATRIX					8
#define NUMBITS_SLICE_SIZE				5 // maximum 32 MB's
#define NUMBITS_SLICE_SIZE_WMV2         3 // To indicate Processor's #
// sprite data
#define NUMBITS_NUM_SPRITE_POINTS		6
#define NUMBITS_X_COORDINATE			12
#define NUMBITS_Y_COORDINATE			12
#define SPRITE_MV_ESC					2
#define NUMBITS_SPRITE_MV_ESC			13
	

// VOP overhead information
#define VOP_START_CODE					0xB6
#define NUMBITS_VOP_START_CODE			8
#define NUMBITS_VOP_TIME				5
#define NUMBITS_VOP_HORIZONTAL_SPA_REF	10
#define NUMBITS_VOP_VERTICAL_SPA_REF	10
#define NUMBITS_VOP_WIDTH				13
#define NUMBITS_VOP_HEIGHT				13
#define NUMBITS_VOP_PRED_TYPE			2
#define NUMBITS_VOP_PRED_TYPE_WMV2		1
#define NUMBITS_VOP_QUANTIZER			5
#define NUMBITS_VOP_DBQUANT				2

// Video Packet overhead, added by Toshiba
#define NUMBITS_VP_RESYNC_MARKER        17
#define RESYNC_MARKER                   0x1
#define NUMBITS_VP_QUANTIZER            NUMBITS_VOP_QUANTIZER
#define NUMBITS_VP_HEC                  1
#define NUMBITS_VP_PRED_TYPE            NUMBITS_VOP_PRED_TYPE
#define NUMBITS_VP_INTRA_DC_SWITCH_THR  3

// for MB ovrehead information
#define NUMBITS_MB_SKIP					1

// for motion estimation
#define ADD_DISP						0

// B-VOP parameters
#define I_INDEX							0
#define P_INDEX							1
#define B1_INDEX						2
#define B2_INDEX						3

// Block DCT parameters
#define NUMBITS_ESC_RUN 6
#define NUMBITS_ESC_LEVEL 8

// for MPEG4-compliant

// VO overhead information
#define NUMBITS_VO_START_CODE			3
#define VO_START_CODE					0
#define NUMBITS_VO_ID					5

// VOL overhead information
#define NUMBITS_VOL_FCODE				3

// sprite data
#ifdef __VERIFICATION_MODEL_
#define NUMBITS_SPRITE_USAGE			2
#else
#define NUMBITS_SPRITE_USAGE			1
#endif //__VERIFICATION_MODEL_

// VOP overhead information
#define NUMBITS_VOP_TIMEINCR			10
#define NUMBITS_VOP_FCODE				3

// for MB ovrehead information
#define NUMBITS_MB_SKIP					1

//#define MAX_DISP						3
// #define ADD_DISP						2

#endif // __CODEHEAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\constants.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Constants.h

Abstract:

    Contants and macros used in MsAudio.

Author:

    Wei-ge Chen (wchen) 12-March-1998

Revision History:


*************************************************************************/

#ifndef __CONSTANTS_H_
#define __CONSTANTS_H_

#ifdef  PI
#undef  PI
#endif
#define PI  3.1415926535897932384626433832795
// value prior to 10/5/99 as a float: #define PI  3.14159265359F

#define FLOAT_SHRT_MAX  32767.0F - 10.0F
#define FLOAT_SHRT_MIN -32768.0F + 10.0F
#define FLOAT_INT_MAX  2147483647.0F - 10.0F
#define FLOAT_INT_MIN -2147483648.0F + 10.0F

#ifdef	BITS_PER_BYTE
#undef	BITS_PER_BYTE
#endif
#define BITS_PER_BYTE 8

#ifdef	BITS_PER_DWORD
#undef	BITS_PER_DWORD
#endif
#define BITS_PER_DWORD      32

#ifdef	BITS_PER_QWORD
#undef	BITS_PER_QWORD
#endif
#define BITS_PER_QWORD      64

#ifdef	NBITS_PACKET_CNT
#undef	NBITS_PACKET_CNT
#endif
#define NBITS_PACKET_CNT    4

#ifdef	NBITS_FRM_CNT
#undef	NBITS_FRM_CNT
#endif
#define NBITS_FRM_CNT       4


#ifdef  NUM_MILSEC_PER_FRAME
#undef  NUM_MILSEC_PER_FRAME
#endif
#define NUM_MILSEC_PER_FRAME 32

#ifdef  NUM_BARK_BAND
#undef  NUM_BARK_BAND
#endif
#define NUM_BARK_BAND 25

#ifdef  MAX_WIDTH_BARKBAND
#undef  MAX_WIDTH_BARKBAND
#endif
#define MAX_WIDTH_BARKBAND 450

#ifdef  MIN_BITRATE
#undef  MIN_BITRATE
#endif
#define MIN_BITRATE 2000    //2.0kbps, TBD

#ifdef  MAX_BITRATE
#undef  MAX_BITRATE
#endif
#define MAX_BITRATE 640000  //64kbps, TBD

#ifdef  LOW_CUTOFF_V1
#undef  LOW_CUTOFF_V1
#endif
#define LOW_CUTOFF_V1 3        //TBD

#ifdef  LOW_CUTOFF
#undef  LOW_CUTOFF
#endif
#define LOW_CUTOFF 0        //wchen: no more due to bug#19144

#ifdef  ABS_THRESHOLD_IN_DB     // in dB, how much to bring down Fletcher-Munson curves;
#undef  ABS_THRESHOLD_IN_DB
#endif
#define ABS_THRESHOLD_IN_DB -30

#define PWRTODB_STEP        ((Float)2.5)
#define PWRTODB_NOSCALE     24 // 61/0.4, Calculated using B=608 in 10*log10(0xFFFFFFFF*2^0/B) - 7
#define PWRTODB_SIZE        57 // 143.5/0.4, Calculated using B=1 in 10*10log10(0xFFFFFFFF*2^18/B) - 7
#define PWRTODB_FULLSCALE   20 // We chop off 18 whole bits (+ any fraction bits) in full-scale pwr-to-db tbl

// Number of bits to discard when calculating power (max power > U32, need to make room)
#define PWRTODB_DEFSACRIFICE    (PWRTODB_FULLSCALE + 2*TRANSFORM_FRACT_BITS)

// power reduction factor in dB for masking @ same frequency
#ifdef INTEGER_ENCODER
#define MIN_THRESHOLD_IN_DB_V1  ((I32)(25 / PWRTODB_STEP ))
#else   // INTEGER_ENCODER
#define MIN_THRESHOLD_IN_DB_V1  25
#endif  // INTEGER_ENCODER

#ifdef  MIN_MASKQ_IN_DB_V1
#undef  MIN_MASKQ_IN_DB_V1
#endif
#define MIN_MASKQ_IN_DB_V1 (Int) (MIN_THRESHOLD_IN_DB_V1 / MASK_QUANT)

#ifdef  MAX_MASKQ_IN_DB_V1
#undef  MAX_MASKQ_IN_DB_V1
#endif                                      
#define MAX_MASKQ_IN_DB_V1 MIN_MASKQ_IN_DB_V1 + (1 << NBITS_FIRST_MASKQUANT) - 1

#ifdef  MASK_QUANT      // in db
#undef  MASK_QUANT      
#endif
#define MASK_QUANT 2.5

#ifdef  NBITS_FIRST_MASKQUANT      
#undef  NBITS_FIRST_MASKQUANT      
#endif
#define NBITS_FIRST_MASKQUANT 5   

#ifdef  FIRST_V2_MASKQUANT
#undef  FIRST_V2_MASKQUANT
#endif
#define FIRST_V2_MASKQUANT 36

#ifdef  MAX_MASKQUANT_DIFF      
#undef  MAX_MASKQUANT_DIFF      
#endif
#define MAX_MASKQUANT_DIFF 60  // limited by the huffman table

#ifdef  NUM_BITS_QUANTIZER
#undef  NUM_BITS_QUANTIZER
#endif
#define NUM_BITS_QUANTIZER 7

// both as the escape code and the range...
#ifdef  MSA_MAX_QUANT_ESC
#undef  MSA_MAX_QUANT_ESC
#endif
#define MSA_MAX_QUANT_ESC ((1<<NUM_BITS_QUANTIZER) - 1)

#ifdef  MAX_QUANT
#undef  MAX_QUANT
#endif
#define MAX_QUANT 129	/* 138 has been seen by decoder */

#ifdef  MIN_QUANT
#undef  MIN_QUANT
#endif
#define MIN_QUANT 1		/*	was once 10; 22 is lowest value seen by decoder */

#define MAX_RUNLEVEL_44SM_QB 60
#define MAX_RUNLEVEL_44SS_QB 40
#define MAX_RUNLEVEL_44SM_HB 110
#define MAX_RUNLEVEL_44SS_HB 70
#define MAX_RUNLEVEL_44SM_OB 340
#define MAX_RUNLEVEL_44SS_OB 180
#define MAX_RUNLEVEL_16SM_OB 70
#define MAX_RUNLEVEL_16SS_OB 40

//lpc constants;need clean up
#define LPCORDER 10
#define FOURTYFOURS_QB 1
#define FOURTYFOURS_OB 2
#define SIXTEENS_OB 3

#define MIN_AUDIBLE 0   // should be fixed...

#define MSA_STEREO_WEIGHT 1.6

#define MIN_EQ -35
#define MAX_EQ 15
#define MIN_RATE BITS_PER_BYTE

#define NUM_PREV_POWER 8
#define NUM_TRANS_FILTER 3

// We're lucky in that everywhere where MIN_FRAME_SIZE is used, pau->m_fHalfTransform
// is available. If this changes, the compiler will let you know.
#define MIN_FRAME_SIZE  HALF(pau->m_fHalfTransform, 128)

// Constants
#define QUANTSTEP_DENOMINATOR 20
#define QUANTSTEP_FRACT_BITS 28

#define TRANSFORM_FRACT_BITS    5

#define MAX_CSUBBAND 2048

// The following should only be used when compiling the integer encoder
#ifdef INTEGER_ENCODER
#define INVWEIGHTFACTOR_FRACTBITS   27
#define INVQUANTSTEP_FRACTBITS      27
#define WEIGHTINPUT_FRACTBITS   14  // prvWeightInput
#define WEIGHT_FRACTBITS        4   // prvGetMaskingThresholdMono and others in masking.c

// Discard bits to allow power value to stay within U32 range. We only need to discard
// 3 bits but discard 1 extra so sqrt(2^TRANSIENT_BITDISCARD) is power of 2
#define TRANSIENT_THRFRACTBITS  4       // Allows 1/16 precision (see threshold init)
#define TRANSIENT_BITDISCARD    (3 + 1 + TRANSIENT_THRFRACTBITS)
#endif  // INTEGER_ENCODER


// fix-point binary points conversion factors
// convert float or double to BP1 integer ( -1.0 <= x < +1.0 )
#define NF2BP1 0x7FFFFFFF
// convert float or double to BP2 integer ( -2.0 <= x < +2.0 )
#define NF2BP2 0x3FFFFFFF

//wchen: added for new buffer model 

#define NOT_DETECTED_YET -2
#define NO_TRANSIENT     -1

#endif //__CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\config.h ===
#ifndef __CONFIG_H__
#define __CONFIG_H__

#ifndef EXTERN_C
#ifdef __cplusplus
#define EXTERN_C extern "C"
#else 
#define EXTERN_C extern 
#endif
#endif

// The XxxGetXxxXxx funstions below are used to enumerate supported parameter
// combinations.  ulIndex is a 0-based index, the funtions return FALSE if it
// is out of range.
//
// The XxxCheckXxxXxx functions return TRUE if the parameter combination is
// supported, FALSE otherwise.

typedef struct _WMAFormatInfo {
    // base WAVEFORMATEX
    U32 nSamplesPerSec;
    U32 nChannels;
    U32 nAvgBytesPerSec;
    U32 nBlockAlign;
    // extended WAVEFORMATES
    U32 nSamplesPerBlock;
    U32 dwSuperBlockAlign;
    U16 wEncodeOptions;

    // miscellaneous
    U32 nFramesPerPacket;
    U32 nSamplesPerFrame;
    U32 nMaxSamplesPerPacket;
    U32 nLookaheadSamples;
    U32 nSuperFrameSamples; // useless ?
    U32 ulOfficialBitrate;
} WMAFormatInfo;

#ifdef __cplusplus
extern "C" {
#endif

   // Checks if the codec can encode this PCM at all (at at least some bitrate)
Bool CheckPCMParams(U32 ulSamplingRate, U32 ulChannels);
// Enumerate all of the channels / sampling combinations supported at any bitrate
Bool GetPCMParamsByIndex(U32 ulIndex, U32 *pulSamplingRate, U32 *pulChannels);


//
// For the GetXxxXxx functions, the entire WMAFormatInfo is an output parameter.
// For CheckFormat, the WAVEFORMATEX stuff is input and the miscellaneous fields
// at the end are output.
//

// Enumerates all of the output formats, regardless if input.  Normal formats
// are enumerated first, followed by the special ASF AV Interleave versions of
// formats that cannot be interleaved in their normal form.
Bool GetFormatByIndex(U32 ulIndex, Bool fIncludeASFAVInterleaveSpecial, WMAFormatInfo* pFormat);
// Total number of formants enumerated by GetFormatByIndex
U32 TotalFormatCount(Bool fIncludeASFAVInterleaveSpecial);

// This is for when you know the input sampling rate and the number of channels
// and want to enumerate all possible output formats.  Normal formats are
// enumerated first, followed by the special ASF AV Interleave versions.
Bool GetFormatByPCMParamsAndIndex(U32 ulIndex, U32 ulSamplingRate, U32 ulChannels, Bool fIncludeASFAVInterleaveSpecial, WMAFormatInfo* pFormat);

// If you know the sampling rate / channels AND the approximate bitrate you
// want, call this to get the corresponding WMAFormatInfo parameters.
EXTERN_C Bool GetFormatByPCMParamsAndBitrate(U32 ulSamplingRate, 
                                             U32 ulChannels, 
                                             U32 ulBitrate, Bool fASFAVInterleave, WMAFormatInfo* pFormat);

// Only the following members of pSrcFormat are used:
// nSamplesPerSec, nChannels, nAvgBytesPerSec, nBlockAlign,
// nSamplesPerBlock, dwSuperBlockAlign, wEncodeOptions
Bool GetTranscodeDstFormatByIndex(const WMAFormatInfo* pSrcFormat,
                                  const U32 ulIndex,
                                  WMAFormatInfo* pDstFormat);


#ifdef __cplusplus
}
#endif


#endif //__CONFIG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\x86.c ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    x86.c

Abstract:

    Intel x86-specific functions.

Author:

    Raymond Cheng (raych)       Jul 29, 1999

Revision History:


*************************************************************************/

#include "bldsetup.h"

#include "macros.h" // This will define WMA_TARGET_X86 (or not)
#ifdef _XBOX
#define WMA_TARGET_X86
#define _SCRUNCH_INLINE_ASM
#endif

#ifdef WMA_TARGET_X86

#ifndef UNDER_CE
#include <time.h>
#endif
#include <math.h>
#include <limits.h>
#include "MsAudio.h"
#include "x86opcodes.h"
#include "AutoProfile.h"


#if !defined(BUILD_INTEGER) && !defined(UNDER_CE) && !defined(_Embedded_x86)

#ifdef INTELFFT_FOR_CE
// For some reason, somebody has a #define __stdcall __cdecl somewhere.
// Get rid of this, because it's causing us linker errors.
#ifdef __stdcall
#undef __stdcall
#endif
#endif  // INTELFFT_FOR_CE

#include "nsp.h"
#include "nspfft.h"

// From userdll.c
Bool MyInitNSP(I32 fdwReason);
void auFreeIntelFFTHelper(I32 iMinFrameSizeLOG,
                          I32 iMaxFrameSizeLOG);
void auSetMinMaxFrameSize(const Int iMinFrameSizeLOG,
                          const Int iMaxFrameSizeLOG);
extern I32 g_iMinFrameSizeLOG;
extern I32 g_iMaxFrameSizeLOG;

// This function initializes for prvFFT4DCT_INTEL as well as prvInvFftComplexConjugate_INTEL

WMARESULT auInitIntelFFT(const CAudioObject *pau,
                         const INTELFFT_INITCODE iCode)
{
    const int c_iMinFrameSizeLOG = LOG2(pau->m_cFrameSampleHalf / pau->m_iMaxSubFrameDiv);
    const int c_iMaxFrameSizeLOG = LOG2(pau->m_cFrameSampleHalf);
    WMARESULT   wmaResult = WMA_OK;

    int     i;
    Bool    fResult;

    fResult = MyInitNSP(iCode);
    if (WMAB_FALSE == fResult)
    {
        wmaResult = WMA_E_NOTSUPPORTED;
        goto exit;
    }

    for (i = c_iMinFrameSizeLOG; i <= c_iMaxFrameSizeLOG; i++)
        nspcFft(NULL, i-1, NSP_Init); // Remember FFT size is frame size / 2, so subtract 1

    auSetMinMaxFrameSize(c_iMinFrameSizeLOG, c_iMaxFrameSizeLOG);

exit:
    return wmaResult;
}

WMARESULT auFreeIntelFFT(const CAudioObject *pau,
                         const INTELFFT_INITCODE iCode)
{
    int iMinFrameSizeLOG = 0;
    int iMaxFrameSizeLOG = 0;

    Bool fResult;

    // It is possible to be freed without having been initialized
    if (0 != pau->m_cFrameSampleHalf)
    {
        iMinFrameSizeLOG = LOG2(pau->m_cFrameSampleHalf / pau->m_iMaxSubFrameDiv);
        iMaxFrameSizeLOG = LOG2(pau->m_cFrameSampleHalf);
    }
    auFreeIntelFFTHelper(iMinFrameSizeLOG, iMaxFrameSizeLOG);

    fResult = MyInitNSP(iCode);
    assert(fResult);

    return WMA_OK;
}


void prvFFT4DCT_INTEL(CoefType data[], Int nLog2np, FftDirection fftDirection)
{
    assert (fftDirection == FFT_FORWARD || fftDirection == FFT_INVERSE);

    if (fftDirection == FFT_FORWARD)
      nspcFft((SCplx *)data, nLog2np, NSP_Forw);
    else
      nspcFft((SCplx *)data, nLog2np, NSP_Inv);
}


#endif  // !defined(BUILD_INTEGER) && !defined(UNDER_CE)


#ifdef USE_SIN_COS_TABLES
//////////////////////////////////////////////////
//         MMX 32x32=32mbs's multiply           //
//////////////////////////////////////////////////

// input:  mm0 formated as defined by SHUFFLE_BITS
//         mm1 standerd 2s complement 32bit number 
//         mm7 = 0x0000FFFF0000FFFF
// output: mm1
#ifdef BEST_PRESITION
// temporary registers: mm2,mm4
#define MMX_MULT_BP2    _asm {                                     \
_asm                    movq        mm2,mm1                        \
_asm                    pand        mm2,mm7                        \
_asm                    pxor        mm1,mm2                        \
_asm                    psrlw       mm2,1                          \
_asm                    por         mm1,mm2                        \
_asm                    movq        mm2,mm0                        \
_asm                    pmaddwd     mm2,mm1                        \
_asm                    movq        mm4,mm1                        \
_asm                    pslld       mm4,16                         \
_asm                    pmaddwd     mm4,mm0                        \
_asm                    psrld       mm4,15                         \
_asm                    paddd       mm2,mm4                        \
_asm                    psrad       mm2,13                         \
_asm                    psrld       mm1,16                         \
_asm                    pmaddwd     mm1,mm0                        \
_asm                    pslld       mm1,2                          \
_asm                    paddd       mm1,mm2                        }
#else
// temporary registers: mm2
#define MMX_MULT_BP2     _asm {                                    \
_asm                     movq        mm2,mm1                       \
_asm                     pand        mm2,mm7                       \
_asm                     pxor        mm1,mm2                       \
_asm                     psrlw       mm2,1                         \
_asm                     por         mm1,mm2                       \
_asm                     movq        mm2,mm0                       \
_asm                     pmaddwd     mm2,mm1                       \
_asm                     psrad       mm2,13                        \
_asm                     psrld       mm1,16                        \
_asm                     pmaddwd     mm1,mm0                       \
_asm                     pslld       mm1,2                         \
_asm                     paddd       mm1,mm2                       }

#endif

///////////////////////////////////////////
//     Other macros for recomMono_MMX    //
///////////////////////////////////////////

#define LOAD_SIGN _asm  {                                          \
_asm                    movd        mm3,ebx                        \
_asm                    shr         ebx,14                         \
_asm                    movq        mm4,[g_rgiMMXSineTable+ebx*8]  \
_asm                    movd        ebx,mm3                        }

#define ADD_AND_SATURATE _asm {                                    \
_asm                    pslld       mm5,COEF_FRAC_BITS             \
_asm                    paddd       mm5,mm1                        \
_asm                    psrad       mm5,COEF_FRAC_BITS             \
_asm                    packssdw    mm5,mm5                        }

#define INIT_LOOP1_2 _asm {                                        \
_asm                    movzx       eax,word Ptr iLoopCount        \
_asm                    shr         eax,1                          \
_asm                    mov         edi,piDst                      \
_asm                    mov         esi,pSin                       \
_asm                    mov         ecx,piSrc                      \
_asm                    movq        mm7,x0000FFFF0000FFFF          \
_asm                    mov         edx,uiSignbitCount             \
_asm                    movzx       ebx,word Ptr uiSignbitData     }

#define SAVE_LOOP_STATE1_2 _asm {                                  \
_asm                mov         piSrc,ecx                          \
_asm                mov         piDst,edi                          \
_asm                mov         pSin,esi                           \
_asm                mov         uiSignbitCount,edx                 \
_asm                mov         uiSignbitData,bx                   }

#define GET_NEXT_SINES _asm {                                      \
_asm                    movd        mm3,eax                        \
_asm                    mov         eax,piSrcSign                  \
_asm                    movzx       ebx,word Ptr [eax]             \
_asm                    add         eax,2                          \
_asm                    mov         piSrcSign,eax                  \
_asm                    mov         edx,16                         \
_asm                    movd        eax,mm3                        }

#define LOAD_FLIP_SHIFT_SATURATE  _asm   {                         \
_asm                    movq        mm0,[eax-8]                    \
_asm                    movq        mm2,mm0                        \
_asm                    psrlq       mm0,32                         \
_asm                    psllq       mm2,32                         \
_asm                    por         mm0,mm2                        \
_asm                    psrad       mm0,COEF_FRAC_BITS             \
_asm                    packssdw    mm0,mm0                        }

#define INIT_LOOP_3 _asm {                                         \
_asm                    movzx       ecx,word Ptr iLoopCount        \
_asm                    shr         ecx,1                          \
_asm                    pxor        mm7,mm7                        \
_asm                    movq        mm6,xFFFF0000FFFF0000          \
_asm                    mov         edi,piDst                      \
_asm                    mov         eax,piCoef                     }


#ifdef BUILD_INTEGER

WMARESULT auReconstruct_MMX (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll){
    Int iChannel;
    WMARESULT hr;
    for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)
    {
        hr = (auReconMono_MMX) (pau, 
                          pau->m_rgpcinfo + iChannel, 
                          piOutput + iChannel,  
                          (I16*)pcSampleGet,
                          fForceTransformAll);
    }
    return hr;
}

WMARESULT auReconMono_MMX ( CAudioObject* pau, 
                        PerChannelInfo* ppcinfo, 
                        I16* piOutput, 
                        I16* pcSampleGet,
                        Bool fForceTransformAll)
{
    //all starting from the begining of this frame
    //official starting of a subfrm (including leading zeros)
    //case 1 (Large -> Small):  starts later than what's been reconstructed w/o leading zeros
    //                          in this case dst should be skiped (this may mean memcpy from prev)
    //                          src and coef are fine
    //                          
    //case 2 (Small -> Large):  starts earler than what's been reconstructed but all leading zeros
    //                          in this case dst 

    int *pSin = pau->m_piSinForRecon;
    static U32 g_rgiMMXSineTable[8] = { 0,0,0,0xFFFF0000,0xFFFF0000,0,0xFFFF0000,0xFFFF0000};
    static const __int64 x0000FFFF0000FFFF = 0x0000FFFF0000FFFF;
    static const __int64 xFFFF0000FFFF0000 = 0xFFFF0000FFFF0000;

    CoefType *piCoef;   //floating vlaue = (float)*piCoef/(1<<5)  assuming TRANSFORM_FRACT_BITS = 5
    Int i, iEnd, iSegEnd;
    I16 *piSrc, *piDst; 
    // get local copies of these values which are used frequently or repeatedly (helps optimization)
    Int cChan = pau->m_cChannel;
    Int cSubFrameSampleHalf = pau->m_cSubFrameSampleHalfAdjusted;
    Int cSubFrameSampleQuad = pau->m_cSubFrameSampleQuadAdjusted;
    Int iCoefRecurQ2 = pau->m_iCoefRecurQ2;
    Int iCoefRecurQ3 = pau->m_iCoefRecurQ3;

#ifndef PREVOUTPUT_16BITS
    I16    *piSrcSign;
    U16     uiSignbitData;
    U32     uiSignbitCount;
#else
    assert(0); //Not yet implemented
#   pragma COMPILER_MESSAGE("INVALID BUILD!! reconMono_MMX will not work with PREVOUTPUT_16BITS")
#endif  // PREVOUTPUT_16BITS
#ifdef PROFILE
    FunctionProfile fp;
    FunctionProfileStart(&fp,RECON_MONO_PROFILE);
#endif

    //persistent states
    i = ppcinfo->m_iCurrGetPCM_SubFrame;       //current position in a frame
    piCoef = (CoefType*)ppcinfo->m_rgiCoefReconCurr; 
    piSrc = ppcinfo->m_piPrevOutputCurr;

    //eventually we'll use piOutput directly
    piDst = piOutput;

    iEnd = i + *pcSampleGet;
    *pcSampleGet = 0;

    CALC_SIGN_OFFSETS(ppcinfo->m_piPrevOutput, piSrc, ppcinfo->m_piPrevOutputSign, piSrcSign, 
        uiSignbitData, uiSignbitCount, cChan)

    ASSERT_SIGNBIT_POINTER(piSrcSign);

    if (i < cSubFrameSampleQuad) 
    {
        iSegEnd = min (cSubFrameSampleQuad, iEnd);
        if ( i < iSegEnd )
        {
            if (cChan==1){
                I16 iLoopCount = (I16)(iSegEnd-i);
                assert((iLoopCount & 0xF) == 0); 
                (*pcSampleGet)+=iLoopCount;
                i+=iLoopCount;
                _asm{
                INIT_LOOP1_2
                pxor mm6,mm6

                Loop1m:
                    push        eax

                    mov         eax,piCoef
                    movq        mm0,[esi]
                    movq        mm1,[eax]

                    MMX_MULT_BP2

                    LOAD_SIGN

                    movd        mm5,[ecx]
                    punpcklwd   mm5,mm6     //for mono
                    por         mm5,mm4       

                    ADD_AND_SATURATE

                    movd        [edi],mm5


                    add         ecx,2*2
                    add         edi,2*2
                    add         esi,2*4
                    add         eax,2*4
                    mov         piCoef,eax

                    sub         edx,2
                    shl         ebx,2
                    and         ebx,0xFFFF

                    cmp         edx,0
                    jnz         SineRegisterNotEmpty1m
                        GET_NEXT_SINES
                    SineRegisterNotEmpty1m:


                pop         eax
                dec         eax
                jnz         Loop1m

                SAVE_LOOP_STATE1_2

                } 
            }else {
                I16 iLoopCount = (I16)(iSegEnd-i);
                assert((iLoopCount & 0xF) == 0); 
                (*pcSampleGet)+=iLoopCount;
                i+=iLoopCount;
                _asm{
                INIT_LOOP1_2
                movq        mm6,xFFFF0000FFFF0000     

                Loop1:
                    push        eax

                    mov         eax,piCoef
                    movq        mm0,[esi]
                    movq        mm1,[eax]

                    MMX_MULT_BP2

                    LOAD_SIGN

                    movq        mm5,[ecx]
                    pand        mm5,mm7       
                    por         mm5,mm4       

                    ADD_AND_SATURATE

                    pxor        mm4,mm4        //interleved write for sterio
                    punpcklwd   mm5,mm4
                    movq        mm4,[edi]
                    pand        mm4,mm6
                    por         mm5,mm4
                    movq        [edi],mm5


                    add         ecx,4*2
                    add         edi,4*2
                    add         esi,2*4
                    add         eax,2*4
                    mov         piCoef,eax

                    sub         edx,2
                    shl         ebx,2
                    and         ebx,0xFFFF

                    cmp         edx,0
                    jnz         SineRegisterNotEmpty1
                        GET_NEXT_SINES
                    SineRegisterNotEmpty1:


                pop         eax
                dec         eax
                jnz         Loop1

                SAVE_LOOP_STATE1_2

                } 
            }
        }
    }
    if (i < iCoefRecurQ2)  
    {
        iSegEnd = min (iCoefRecurQ2, iEnd);
        if ( i < iSegEnd )
        {
            I16 iLoopCount = (I16)(iSegEnd-i);
            assert((iLoopCount&0x1) == 0);
            (*pcSampleGet)+=iLoopCount;
            i+=iLoopCount;
            if (cChan==1){
                _asm{
                INIT_LOOP1_2
                pxor             mm6,mm6

                Loop2:
                    push        eax

                    mov         eax,piCoef

                    movq        mm0,[esi]
                    movq        mm1,[eax-8]

                    movq        mm2,mm1   //Flip high and low 32 bits
                    psrlq       mm1,32
                    psllq       mm2,32
                    por         mm1,mm2

                    MMX_MULT_BP2

                    LOAD_SIGN

                    movd        mm5,[ecx]
                    punpcklwd   mm5,mm6     
                    por         mm5,mm4     

                    ADD_AND_SATURATE

                    movd        [edi],mm5


                    add         ecx,2*2
                    add         edi,2*2
                    add         esi,2*4

                    sub         eax,2*4
                    mov         piCoef,eax

                    sub         edx,2
                    shl         ebx,2
                    and         ebx,0xFFFF

                    cmp         edx,0
                    jnz         SineRegisterNotEmpty2
                        GET_NEXT_SINES
                    SineRegisterNotEmpty2:

                pop         eax
                dec         eax
                jnz         Loop2

                SAVE_LOOP_STATE1_2

                } 
            } else {
                _asm{
                INIT_LOOP1_2
                movq        mm6,xFFFF0000FFFF0000     

                Loop2m:
                    push        eax

                    mov         eax,piCoef

                    movq        mm0,[esi]
                    movq        mm1,[eax-8]

                    movq        mm2,mm1   //Flip high and low 32 bits
                    psrlq       mm1,32
                    psllq       mm2,32
                    por         mm1,mm2

                    MMX_MULT_BP2

                    LOAD_SIGN

                    movq        mm5,[ecx]
                    pand        mm5,mm7       //for sterio
                    por         mm5,mm4       //for sterio
                    //punpcklwd   mm5,mm6     //for mono

                    ADD_AND_SATURATE

                    pxor        mm4,mm4        //interleved write for sterio
                    punpcklwd   mm5,mm4
                    movq        mm4,[edi]
                    pand        mm4,mm6
                    por         mm5,mm4
                    movq        [edi],mm5


                    add         ecx,4*2
                    add         edi,4*2
                    add         esi,2*4

                    sub         eax,2*4
                    mov         piCoef,eax

                    sub         edx,2
                    shl         ebx,2
                    and         ebx,0xFFFF

                    cmp         edx,0
                    jnz         SineRegisterNotEmpty2m
                        GET_NEXT_SINES
                    SineRegisterNotEmpty2m:

                pop         eax
                dec         eax
                jnz         Loop2m

                SAVE_LOOP_STATE1_2

                } 
            }
        }
    }
    if (i < iCoefRecurQ3) 
    {
        I16 iLoopCount;
        iSegEnd = min (iCoefRecurQ3, iEnd);
        iLoopCount = (I16)( iSegEnd - i );
        assert((iLoopCount&1)==0); 
        (*pcSampleGet)+=iLoopCount;
        i+=iLoopCount;
        if (iLoopCount) {
            if (cChan==1){
                _asm{
                INIT_LOOP_3
                Loop3m:      
                    LOAD_FLIP_SHIFT_SATURATE
                    movd        [edi],mm0   //store 
                    add         edi,2*2
                    sub         eax,2*4
                dec         ecx
                jnz         Loop3m
                mov         piDst,edi
                mov         piCoef,eax
                }
            }else{
                _asm{
                INIT_LOOP_3
                
                Loop3:      
                    LOAD_FLIP_SHIFT_SATURATE
                    punpcklwd   mm0,mm7     //Merge with interleved data
                    movq        mm1,[edi]
                    pand        mm1,mm6
                    por         mm0,mm1
                    movq        [edi],mm0   //store 
                    add         edi,4*2
                    sub         eax,2*4
                dec         ecx
                jnz         Loop3
                mov         piDst,edi
                mov         piCoef,eax
                }
            }
        }
    }
    _asm emms

    SAVE_SIGNBIT_STATE(piSrcSign,uiSignbitData);
    ppcinfo->m_rgiCoefReconCurr = (Int*)piCoef;
    ppcinfo->m_iCurrGetPCM_SubFrame = (I16)i;
    ppcinfo->m_piPrevOutputCurr = piSrc;
#ifdef PROFILE
    FunctionProfileStop(&fp);
#endif
    return WMA_OK;
}
#undef MMX_MULT_BP2
#undef LOAD_SIGN
#undef ADD_AND_SATURATE
#undef INIT_LOOP1_2
#undef SAVE_LOOP_STATE1_2 
#undef GET_NEXT_SINES
#undef LOAD_FLIP_SHIFT_SATURATE
#undef INIT_LOOP_3 

#else //not BUILD_INTEGER

#ifndef PREVOUTPUT_16BITS
#define COMBINE_SIGNBIT_FAST                                                   \
               iResult = (((uiSignbitData)>>15) & 0xFFFF0000) | (U16)*piSrc;   \
               uiSignbitData <<= 1;                                             
#else
#define COMBINE_SIGNBIT_FAST iResult = *piSrc; 
#endif            


#define RECORD_SIGNBIT_FAST                           \
    uiSignbitData <<= 1;                              \
    uiSignbitData |= ((iResult >> 31) & 0x00000001);  \
    uiSignbitCount += 1;                               


/////////////////////////////////////////////////////////////////////////////////////
// Save History Mono - X86 optimized version
// This function achieves its speedup by unrolling the loop so that the 1 out of 16
// brantch is removed and the same functionality is done with the loop structure.
// It also uses the sin tables instead of doing the recursion 
/////////////////////////////////////////////////////////////////////////////////////
#if !defined(PREVOUTPUT_16BITS) && !defined (BUILD_INTEGER)
WMARESULT auSaveHistoryMono (CAudioObject* pau, 
                            PerChannelInfo* ppcinfo, 
                            Bool fForceTransformAll)
{
    CoefType *piCoef;   //floating vlaue = (float)*piCoef/(1<<5)  assuming TRANSFORM_FRACT_BITS = 5
    
    Int i;      // , iEnd, iSegEnd;
    I16 *piDst; 
    I32 iResult;
    CoefType cfResult;

    // get local copies of these values which are used frequently or repeatedly (helps optimization)
    Int cChan = pau->m_cChannel;
	// HALF_TRANSFORM: the following member variables are not restored so continue to hold their halved values
    Int cSubFrameSample3Quad = 3 * pau->m_cSubFrameSampleQuadAdjusted;
    Int iCoefRecurQ4 = pau->m_iCoefRecurQ4;
    BP2Type bp2Sin  = INTEGER_OR_INT_FLOAT( pau->m_iSinRampDownStart, pau->m_fltSinRampDownStart );
    BP2Type bp2Cos  = INTEGER_OR_INT_FLOAT( pau->m_iCosRampDownStart, pau->m_fltCosRampDownStart );
    BP2Type bp2Sin1 = INTEGER_OR_INT_FLOAT( pau->m_iSinRampDownPrior, pau->m_fltSinRampDownPrior );
    BP2Type bp2Cos1 = INTEGER_OR_INT_FLOAT( pau->m_iCosRampDownPrior, pau->m_fltCosRampDownPrior );
    BP2Type bp2Step = INTEGER_OR_INT_FLOAT( pau->m_iSinRampDownStep,  pau->m_fltSinRampDownStep  );
    Float *pfltSinTable = pau->m_piSinForSaveHistory;
    Int iLoopCnt;
    Int iLoopLen;
    Int iLoopBy16;
    Int iLoopBy1;

#ifndef PREVOUTPUT_16BITS
    I16    *piDstSign = ppcinfo->m_piPrevOutputSign;
    U32     uiSignbitData = 0;
    U32     uiSignbitCount = 0;
#endif  // PREVOUTPUT_16BITS

#ifdef PROFILE
    FunctionProfile fp;
    FunctionProfileStart(&fp,SAVE_HISTORY_MONO_PROFILE);
#endif

    //all starting from the begining of this frame
    //official starting of a subfrm (including leading zeros)
    //case 1 (Large -> Small):  starts later than what's been reconstructed w/o leading zeros
    //                          in this case dst should be skiped (this may mean memcpy from prev)
    //                          src and coef are fine
    //                          
    //case 2 (Small -> Large):  starts earler than what's been reconstructed but all leading zeros
    //                          in this case dst 

    //eventually we'll use piOutput directly
    piDst = ppcinfo->m_piPrevOutput;


    //persistent states
    i = ppcinfo->m_iCurrGetPCM_SubFrame;       //current position in a frame
    assert( (0<=i && i<=iCoefRecurQ4) || (i==CURRGETPCM_INVALID));
    piCoef = (CoefType*)ppcinfo->m_rgiCoefReconCurr; 
    ASSERT_SIGNBIT_POINTER(piDstSign);


#if defined(WMA_SHOW_FRAMES)  && defined(_DEBUG)
    prvWmaShowFrames(pau, "SavHist", " %4d 0x%08x 0x%08x %4d %4d", 
        i, piCoef, piDst, cSubFrameSample3Quad, iCoefRecurQ4);
#endif
    iLoopLen = cSubFrameSample3Quad - i;
    if ( iLoopLen<0 )
        iLoopLen = 0;
    iLoopBy1  = iLoopLen & 0xF;
    iLoopBy16 = iLoopLen >> 4;
    for (iLoopCnt = 0; iLoopCnt < iLoopBy16; iLoopCnt++,i+=16) {

        //1
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //2
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //3
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //4
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //5
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //6
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //7
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //8
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //9
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //10
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //11
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //12
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //13
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //14
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //15
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //16
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        *piDstSign = (I16) uiSignbitData;                                       
        piDstSign += 1;                                                      
        uiSignbitCount = 0;                                                     

    }

    for (iLoopCnt = 0; iLoopCnt < iLoopBy1; iLoopBy1++,i++)    {

        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );

        piDst += cChan;

        RECORD_SIGNBIT(iResult, piDstSign, uiSignbitData,
            uiSignbitCount, 1);

    }

    iLoopLen = iCoefRecurQ4 - i;
    if ( iLoopLen < 0 )
        iLoopLen = 0;
    iLoopBy1  = iLoopLen & 0xF;
    iLoopBy16 = iLoopLen >> 4;
    for (iLoopCnt=0; iLoopCnt < iLoopBy16; iLoopCnt++,i++)    {

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        *piDstSign = (I16) uiSignbitData;                                       
        piDstSign += 1;                                                      
        uiSignbitCount = 0;                                                     
    }
    for (iLoopCnt=0; iLoopCnt < iLoopBy1; iLoopCnt++,i++)    {

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );

        piDst += cChan;

        RECORD_SIGNBIT(iResult, piDstSign, uiSignbitData,
            uiSignbitCount, 1);

    }

    ppcinfo->m_iCurrGetPCM_SubFrame = (I16)i;       //protect ourself from multiple calls

#ifdef PROFILE
    FunctionProfileStop(&fp);
#endif
    return WMA_OK;
}
#endif // !defined(PREVOUTPUT_16BITS) && !defined (BUILD_INTEGER)

//This function is here to satisfy the function pointers to be compatible with the 
//reconStereo's
WMARESULT auReconstruct_X86 (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll){
    Int iChannel;
    WMARESULT hr;
    for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)
    {
        hr = (auReconMono_X86) (pau, 
                          pau->m_rgpcinfo + iChannel, 
                          piOutput + iChannel,  
                          (I16*)pcSampleGet,
                          fForceTransformAll);
        if (hr != WMA_OK){
            pau->aupfnReconstruct = auReconstruct;
            return auReconstruct(pau,piOutput,pcSampleGet,fForceTransformAll); 
        }
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////
// Recon Mono - X86 optimized version
// This function achieves its speedup by unrolling the loop so that the 1 out of 16
// brantch is removed and the same functionality is done with the loop structure.
// It also uses the sin tables instead of doing the recursion 
/////////////////////////////////////////////////////////////////////////////////////

WMARESULT auReconMono_X86 ( CAudioObject* pau, 
                        PerChannelInfo* ppcinfo, 
                        I16* piOutput, 
                        I16* pcSampleGet,
                        Bool fForceTransformAll)
{
    //all starting from the begining of this frame
    //official starting of a subfrm (including leading zeros)
    //case 1 (Large -> Small):  starts later than what's been reconstructed w/o leading zeros
    //                          in this case dst should be skiped (this may mean memcpy from prev)
    //                          src and coef are fine
    //                          
    //case 2 (Small -> Large):  starts earler than what's been reconstructed but all leading zeros
    //                          in this case dst 

    CoefType *piCoef;   //floating vlaue = (float)*piCoef/(1<<5)  assuming TRANSFORM_FRACT_BITS = 5
    Int i, iEnd, iSegEnd;
    I16 *piSrc, *piDst; 
    I32 iResult;
    CoefType cfResult;
    // get local copies of these values which are used frequently or repeatedly (helps optimization)
    Int cChan = pau->m_cChannel;
    Int cSubFrameSampleHalf = pau->m_cSubFrameSampleHalfAdjusted;
    Int cSubFrameSampleQuad = pau->m_cSubFrameSampleQuadAdjusted;
    Int iCoefRecurQ2 = pau->m_iCoefRecurQ2;
    Int iCoefRecurQ3 = pau->m_iCoefRecurQ3;
    BP2Type bp2Sin  = *((BP2Type*)(&ppcinfo->m_iSin));
    BP2Type bp2Cos  = *((BP2Type*)(&ppcinfo->m_iCos));
    BP2Type bp2Sin1 = *((BP2Type*)(&ppcinfo->m_iSin1));
    BP2Type bp2Cos1 = *((BP2Type*)(&ppcinfo->m_iCos1));
    BP2Type bp2Step = *((BP2Type*)(&ppcinfo->m_iStep));
    float *piSin = pau->m_piSinForRecon;

#ifndef PREVOUTPUT_16BITS
    U16    *piSrcSign;
    I32     uiSignbitData;
    U32     uiSignbitCount;
#endif  // PREVOUTPUT_16BITS
#ifdef PROFILE
    FunctionProfile fp;
    FunctionProfileStart(&fp,RECON_MONO_PROFILE);
#endif

    //persistent states
    i = ppcinfo->m_iCurrGetPCM_SubFrame;       //current position in a frame
    piCoef = (CoefType*)ppcinfo->m_rgiCoefReconCurr; 
    piSrc = ppcinfo->m_piPrevOutputCurr;

    //eventually we'll use piOutput directly
    piDst = piOutput;

    iEnd = i + *pcSampleGet;
    *pcSampleGet = 0;

    CALC_SIGN_OFFSETS(ppcinfo->m_piPrevOutput, piSrc, ppcinfo->m_piPrevOutputSign, piSrcSign, 
        uiSignbitData, uiSignbitCount, cChan)
    ASSERT_SIGNBIT_POINTER(piSrcSign);

    if (i < cSubFrameSampleQuad) 
    {
        iSegEnd = min (cSubFrameSampleQuad, iEnd);
        if ( i < iSegEnd )
        {
            Int iLoopBy16,iLoopBy1,iLoopCnt;
            iLoopBy16 = (iSegEnd - i) >> 4;
            iLoopBy1  = (iSegEnd - i) & 0xF;
            (*pcSampleGet) += (I16)(iLoopBy16<<4);
            i += (iLoopBy16<<4);
            for (iLoopCnt = 0; iLoopCnt < iLoopBy16; iLoopCnt++)    {
                uiSignbitData<<=16;

                COMBINE_SIGNBIT_FAST
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                uiSignbitData = *piSrcSign++;                                              
            }
            uiSignbitCount = 16;                                                     
            if (iLoopBy1) return !WMA_OK;

/*            for (iLoopCnt = 0; iLoopCnt < iLoopBy1; iLoopCnt++, i++, (*pcSampleGet)++)    {

                COMBINE_SIGNBIT(iResult, *piSrc, piSrcSign, uiSignbitData,
                    uiSignbitCount);

                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );

                piSrc += cChan;
                piDst += cChan;
            }   */

        }
    }
    if (i < iCoefRecurQ2)  
    {
        iSegEnd = min (iCoefRecurQ2, iEnd);
        if ( i < iSegEnd )
        {
            Int iLoopBy16,iLoopBy1,iLoopCnt;
            iLoopBy16 = (iSegEnd - i) >> 4;
            iLoopBy1  = (iSegEnd - i) & 0xF;
            (*pcSampleGet) += (I16)(iLoopBy16<<4);
            i += (iLoopBy16<<4);
            for (iLoopCnt = 0;iLoopCnt < iLoopBy16;iLoopCnt++)    {
                uiSignbitData<<=16;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                uiSignbitData = *piSrcSign++;                                              
            }
            uiSignbitCount = 16;                                                     
            if (iLoopBy1) return !WMA_OK;
/*            for (iLoopCnt = 0; iLoopCnt < iLoopBy1; iLoopCnt++, i++,(*pcSampleGet)++)    {

                COMBINE_SIGNBIT(iResult, *piSrc, piSrcSign, uiSignbitData,
                    uiSignbitCount);

                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );

                piSrc += cChan;
                piDst += cChan;
            }  */
        }
    }
    if (i < iCoefRecurQ3) 
    {
        iSegEnd = min (iCoefRecurQ3, iEnd);
        for (; i < iSegEnd; i++,(*pcSampleGet)++)    {
            cfResult = INT_FROM_COEF( *--piCoef );
            ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
            piDst += cChan;
        }
    }

    SAVE_SIGNBIT_STATE(piSrcSign,uiSignbitData);
    if (pau->m_cChannel < 2 || ((pau->m_cChannel == 2) && (ppcinfo == &(pau->m_rgpcinfo[1]))))
        pau->m_piSinForRecon = piSin;

    ppcinfo->m_rgiCoefReconCurr = (Int*)piCoef;
    ppcinfo->m_iCurrGetPCM_SubFrame = (I16)i;
    ppcinfo->m_piPrevOutputCurr = piSrc;
#ifdef PROFILE
    FunctionProfileStop(&fp);
#endif
    return WMA_OK;
}


#if 0
//auReconStereo_X86 has been removed from build as the saturation code does not work with out the
//extra checking in ROUNDF_TO_S below which would cause it to be slow. I left it in the codebase
//as it serves as a good model for other reconStereo's for other platforms.

INLINE I16 FASTCALL ROUNDF_TO_S(float f) {
    I16 intval;
    if (f > 32767) f = 32767;
    if (f < -32767) f= -32767;
    _asm {
        fld         f
        fistp       word ptr [intval]
    }
    return intval;
}

WMARESULT auReconStereo_X86 (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll)
{
    Int overflow = 0;
    Float *piCoef2; 
    Float *piCoef;  
    Int i, iEnd, iSegEnd;
    I16 *piSrc, *piDst; 
    I32 iResult;
    Float cfResult;

    // get local copies of these values which are used frequently or repeatedly (helps optimization)
    Int cChan = pau->m_cChannel;
    Int cSubFrameSampleHalf = pau->m_cSubFrameSampleHalfAdjusted;
    Int cSubFrameSampleQuad = pau->m_cSubFrameSampleQuadAdjusted;
    Int iCoefRecurQ2 = pau->m_iCoefRecurQ2;
    Int iCoefRecurQ3 = pau->m_iCoefRecurQ3;
    float *piSin = pau->m_piSinForRecon;

    U16    *piSrcSign;
    I32     uiSignbitData;
    U32     uiSignbitCount;
    U16    *piSrcSign2;
    I32     uiSignbitData2;
    U32     uiSignbitCount2;

#ifdef PREVOUTPUT_16BITS
    assert(0);
#endif// PREVOUTPUT_16BITS

#ifdef PROFILE
    FunctionProfile fp;
    FunctionProfileStart(&fp,RECON_MONO_PROFILE);
#endif

    //persistent states
    i = pau->m_rgpcinfo[0].m_iCurrGetPCM_SubFrame;       //current position in a frame
    assert(i==pau->m_rgpcinfo[1].m_iCurrGetPCM_SubFrame);
    piCoef = (float*)pau->m_rgpcinfo[0].m_rgiCoefReconCurr; 
    piCoef2 = (float*)(pau->m_rgpcinfo[1].m_rgiCoefReconCurr); 

    piSrc = pau->m_rgpcinfo[0].m_piPrevOutputCurr;
    assert((piSrc+1) == pau->m_rgpcinfo[1].m_piPrevOutputCurr);
    
    //eventually we'll use piOutput directly
    piDst = piOutput;

    iEnd = i + *pcSampleGet;
    *pcSampleGet = 0;

    CALC_SIGN_OFFSETS(pau->m_rgpcinfo[0].m_piPrevOutput,(piSrc+0), pau->m_rgpcinfo[0].m_piPrevOutputSign, piSrcSign, 
        uiSignbitData, uiSignbitCount, cChan)

    CALC_SIGN_OFFSETS(pau->m_rgpcinfo[1].m_piPrevOutput,(piSrc+1), pau->m_rgpcinfo[1].m_piPrevOutputSign, piSrcSign2, 
        uiSignbitData2, uiSignbitCount2, cChan)

    ASSERT_SIGNBIT_POINTER(piSrcSign);

    if (i < cSubFrameSampleQuad) 
    {
        iSegEnd = min (cSubFrameSampleQuad, iEnd);
        if ( i < iSegEnd )
        {
            Int iLoopBy16,iLoopBy1,iLoopCnt;
            iLoopBy16 = (iSegEnd - i) >> 4;
            iLoopBy1  = (iSegEnd - i) & 0xF;
            (*pcSampleGet) += (I16)(iLoopBy16<<4);
            i += (iLoopBy16<<4);

            for (iLoopCnt = 0; iLoopCnt < iLoopBy16; iLoopCnt++)    {
                uiSignbitData<<=16;
                uiSignbitData2<<=16;

#               define RECONSTRUCT2                                                 \
                iResult = (((uiSignbitData)>>15) & 0xFFFF0000) | (U16)*piSrc;       \
                uiSignbitData <<= 1;                                                \
                cfResult = *piSin * *piCoef + iResult;                              \
                if ((*piDst = ROUNDF_TO_S(cfResult)) == 0x8000) overflow=1;         \
                iResult = (((uiSignbitData2)>>15) & 0xFFFF0000) | (U16)piSrc[1];    \
                uiSignbitData2 <<= 1;                                               \
                cfResult = *piSin * *piCoef2 + iResult;                             \
                if ((piDst[1] = ROUNDF_TO_S(cfResult)) == 0x8000) overflow=1;       \
                piSin++;                                                            \
                piCoef++;                                                           \
                piCoef2++;                                                          \
                piSrc += cChan;                                                     \
                piDst += cChan;     

                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2

#               undef RECONSTRUCT2          

                uiSignbitData = *piSrcSign++;                                              
                uiSignbitData2 = *piSrcSign2++;                                              
            }
            uiSignbitCount = 16;                                                     
        }
    }

    if (i < iCoefRecurQ2)  
    {
        iSegEnd = min (iCoefRecurQ2, iEnd);
        if ( i < iSegEnd )
        {
            U16 *piDstCopy = piDst;
            Int iLoopBy16,iLoopBy1,iLoopCnt;
            iLoopBy16 = (iSegEnd - i) >> 4;
            iLoopBy1  = (iSegEnd - i) & 0xF;
            for (iLoopCnt = 0;iLoopCnt < iLoopBy16;iLoopCnt++, i+=16,(*pcSampleGet)+=16)    {
                uiSignbitData<<=16;
                uiSignbitData2<<=16;

#               define RECONSTRUCT2                                                   \
                piCoef--;                                                             \
                piCoef2--;                                                            \
                iResult = (((uiSignbitData)>>15) & 0xFFFF0000) | (U16)*piSrc;         \
                uiSignbitData <<= 1;                                                  \
                cfResult = *piSin * *piCoef + iResult;                                \
                if ((*piDst = ROUNDF_TO_S(cfResult))==0x8000) overflow=1;             \
                iResult = (((uiSignbitData2)>>15) & 0xFFFF0000) | (U16)piSrc[1];      \
                uiSignbitData2 <<= 1;                                                 \
                cfResult = *piSin * *piCoef2 + iResult;                               \
                if ((piDst[1] = ROUNDF_TO_S(cfResult))==0x8000) overflow=1;           \
                piSin++;                                                              \
                piSrc += cChan;                                                       \
                piDst += cChan;     

                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
#               undef RECONSTRUCT2          

                uiSignbitData = *piSrcSign++;                                              
                uiSignbitData2 = *piSrcSign2++;                                              
            }
            uiSignbitCount = 16;                                                     
            uiSignbitCount2 = 16;                                                     
        }
    }
    if (i < iCoefRecurQ3) 
    {
        iSegEnd = min (iCoefRecurQ3, iEnd);
        for (; i < iSegEnd; i++,(*pcSampleGet)++)    {
            cfResult = INT_FROM_COEF( *--piCoef );
            ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
            cfResult = INT_FROM_COEF( *--piCoef2 );
            ROUND_SATURATE_STORE( (piDst+1), cfResult, SHRT_MIN, SHRT_MAX, iResult );
            piDst += cChan;
        }
    }

    if (overflow){
        Int iChannel;
        for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)
        {
            //hr = 
            auReconMono_X86 (pau, 
                              pau->m_rgpcinfo + iChannel, 
                              piOutput + iChannel,  
                              (I16*)pcSampleGet,
                              fForceTransformAll);
        }
    } else {
        SAVE_SIGNBIT_STATE(piSrcSign,uiSignbitData);
        pau->m_rgpcinfo[0].m_rgiCoefReconCurr = (Int*)piCoef;
        pau->m_rgpcinfo[0].m_iCurrGetPCM_SubFrame = (I16)i;
        pau->m_rgpcinfo[0].m_piPrevOutputCurr = piSrc;


        SAVE_SIGNBIT_STATE(piSrcSign2,uiSignbitData2);
        pau->m_rgpcinfo[1].m_rgiCoefReconCurr = (Int*)piCoef2;
        pau->m_rgpcinfo[1].m_iCurrGetPCM_SubFrame = (I16)i;
        pau->m_rgpcinfo[1].m_piPrevOutputCurr = piSrc+1;

        pau->m_piSinForRecon = piSin;
    }         
    return WMA_OK;
}
#endif //if 0

////////////////////////////////////////////////////////////////////////////////////////
// Recon Stereo MMX
// This function improves on reconMono_X86 by doing both channels at once and using MMX
// to do the calculations 4 at a time for the integer part and doing the floating point part
// in a seperate loop. 
// If a non divisable by 16 frame is encounterd the function turns itself off and 
// calls the safer function 
////////////////////////////////////////////////////////////////////////////////////////

WMARESULT auReconStereo_MMX (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll)
{
    static const __int64 x0000FFFF0000FFFF = 0x0000FFFF0000FFFF;
    static const __int64 x8000800080008000 = 0x8000800080008000;
    Int tempBuf[2048];
    Int *tBuf;

    Float *piCoef2; 
    Float *piCoef;  
    Int i, iEnd, iSegEnd;
    I16 *piSrc, *piDst; 
    I32 iResult;
    Float cfResult;

    // get local copies of these values which are used frequently or repeatedly (helps optimization)
    Int cChan = pau->m_cChannel;
    Int cSubFrameSampleHalf = pau->m_cSubFrameSampleHalfAdjusted;
    Int cSubFrameSampleQuad = pau->m_cSubFrameSampleQuadAdjusted;
    Int iCoefRecurQ2 = pau->m_iCoefRecurQ2;
    Int iCoefRecurQ3 = pau->m_iCoefRecurQ3;
    float *piSin = pau->m_piSinForRecon;

    U16    *piSrcSign;
    I32     uiSignbitData;
    U32     uiSignbitCount;
    U16    *piSrcSign2;
    I32     uiSignbitData2;
    U32     uiSignbitCount2;

#ifdef PREVOUTPUT_16BITS
    assert(0);
#endif// PREVOUTPUT_16BITS

#ifdef PROFILE
    FunctionProfile fp;
    FunctionProfileStart(&fp,RECON_MONO_PROFILE);
#endif

    //persistent states
    i = pau->m_rgpcinfo[0].m_iCurrGetPCM_SubFrame;       //current position in a frame
    assert(i==pau->m_rgpcinfo[1].m_iCurrGetPCM_SubFrame);
    piCoef = (float*)pau->m_rgpcinfo[0].m_rgiCoefReconCurr; 
    piCoef2 = (float*)(pau->m_rgpcinfo[1].m_rgiCoefReconCurr); 

    piSrc = pau->m_rgpcinfo[0].m_piPrevOutputCurr;
    assert((piSrc+1) == pau->m_rgpcinfo[1].m_piPrevOutputCurr);
    
    //eventually we'll use piOutput directly
    piDst = piOutput;

    iEnd = i + *pcSampleGet;
    *pcSampleGet = 0;

    CALC_SIGN_OFFSETS(pau->m_rgpcinfo[0].m_piPrevOutput,(piSrc+0), pau->m_rgpcinfo[0].m_piPrevOutputSign, piSrcSign, 
        uiSignbitData, uiSignbitCount, cChan)

    CALC_SIGN_OFFSETS(pau->m_rgpcinfo[1].m_piPrevOutput,(piSrc+1), pau->m_rgpcinfo[1].m_piPrevOutputSign, piSrcSign2, 
        uiSignbitData2, uiSignbitCount2, cChan)

    ASSERT_SIGNBIT_POINTER(piSrcSign);

    if (i < cSubFrameSampleQuad) 
    {
        iSegEnd = min (cSubFrameSampleQuad, iEnd);
        if ( i < iSegEnd )
        {
            Int iLoopBy16,iLoopBy1;//,iLoopCnt;
            iLoopBy16 = (iSegEnd - i) >> 4;
            iLoopBy1  = (iSegEnd - i) & 0xF;
            (*pcSampleGet) += (I16)(iLoopBy16<<4);
            i += (iLoopBy16<<4);
            assert(iLoopBy1==0);
            tBuf = tempBuf;

            _asm{
            
            mov         esi,piSin
            mov         ecx,piCoef
            mov         edx,piCoef2
            lea         ebx,tempBuf
            mov         eax,iLoopBy16
            shl         eax,4
            Loop1F:

                fld         dword Ptr [esi]         //Load Sin value
                add         esi,4                   //piSin++
                fld         dword Ptr [ecx]         //Load Coefficent from channel 1
                fmul        st(0),st(1)             //Multiply it with Sin value
                add         ecx,4                   //piCoef++
                fld         dword Ptr [edx]         //Load Coefficent from channel 2
                fmulp       st(2),st(0)             //Multiply it with Sin value
                fistp       dword Ptr [ebx]         //Store as 32bit int
                add         edx,4                   //piCoef2++
                fistp       dword Ptr [ebx+4]       //Store as 32bit int
                add         ebx,8                   //bump temp buffer ptr

            dec         eax
            jnz         Loop1F
            mov         piSin,esi
            mov         piCoef,ecx
            mov         piCoef2,edx
   

            mov         ebx,piSrcSign
            mov         ecx,piSrcSign2
            mov         esi,piSrc
            mov         edx,tBuf 
            mov         edi,piDst

            movd        mm0,uiSignbitData    
            movd        mm1,uiSignbitData2

            mov         eax,iLoopBy16
            Loop1M:    
                    
                punpcklwd   mm0,mm1
                    
#               define RECONSTRUCT4(x) _asm {                                            \
_asm            movq        mm1,mm0                                                      \
_asm            psraw       mm1,15             /*sine extend sine bit data*/             \
_asm            movd        mm2,[esi+(x*8)]    /*load 2 16bit data elements*/            \
_asm            punpcklwd   mm2,mm1            /*merge with sign bit for 2 32bit values*/\
_asm            movq        mm1,[edx+(x*16)]   /*get 2 precalculated coef * sin */       \
_asm            paddd       mm1,mm2            /*add the 2 vectors*/                     \
_asm            pslld       mm0,1              /*shift sine bit data for next time*/     \
_asm            movq        mm3,mm0            /*repeat process for 2 more elements*/    \
_asm            psraw       mm3,15                                                       \
_asm            movd        mm4,[esi+(x*8)+4]                                            \
_asm            punpcklwd   mm4,mm3                                                      \
_asm            movq        mm3,[edx+(x*16)+8]                                           \
_asm            paddd       mm3,mm4                                                      \
_asm            packssdw    mm1,mm3           /*merge and saturate 2 sets of 2*/         \
_asm            movq        [edi+(x*8)],mm1   /*store 4 reconstructed samples*/          \
_asm            pslld       mm0,1             /*shift sine bit data for next time*/      }

                RECONSTRUCT4(0)
                RECONSTRUCT4(1)
                RECONSTRUCT4(2)
                RECONSTRUCT4(3)
                RECONSTRUCT4(4)
                RECONSTRUCT4(5)
                RECONSTRUCT4(6)
                RECONSTRUCT4(7)
                    
                add         esi,32*2
                add         edx,32*4
                add         edi,32*2

                movd        mm0,[ebx]
                movd        mm1,[ecx]

                add         ebx,2
                add         ecx,2
                

            dec         eax
            jnz         Loop1M

            mov         piSrc,esi
            mov         tBuf,edx
            mov         piDst,edi

            movd        uiSignbitData,mm0
            movd        uiSignbitData2,mm1
            mov         piSrcSign,ebx
            mov         piSrcSign2,ecx

            emms
            }
            uiSignbitCount  = 16;
            uiSignbitCount2 = 16;
            if (iLoopBy1) {
                pau->aupfnReconstruct = auReconstruct;
                return auReconstruct(pau,piOutput,pcSampleGet,fForceTransformAll); 
            }
/*            for (iLoopCnt = 0; iLoopCnt < iLoopBy1; iLoopCnt++, i++, (*pcSampleGet)++)    {
                //Channel 1
                COMBINE_SIGNBIT(iResult, *piSrc, piSrcSign, uiSignbitData,
                    uiSignbitCount);
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc++;
                piDst++;

                //Channel 2
                COMBINE_SIGNBIT(iResult, *piSrc, piSrcSign, uiSignbitData2,
                    uiSignbitCount2);
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef2++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc++;
                piDst++;
            }  */
        }
    }

    if (i < iCoefRecurQ2)  
    {
        iSegEnd = min (iCoefRecurQ2, iEnd);
        if ( i < iSegEnd )
        {
            Int iLoopBy16,iLoopBy1;//,iLoopCnt;
            iLoopBy16 = (iSegEnd - i) >> 4;
            iLoopBy1  = (iSegEnd - i) & 0xF;
            assert(iLoopBy1==0);
            (*pcSampleGet) += (I16)(iLoopBy16<<4);
            i += (iLoopBy16<<4);
            tBuf = tempBuf;
            _asm{
            mov         esi,piSin
            mov         ecx,piCoef
            mov         edx,piCoef2
            mov         ebx,tBuf
            mov         eax,iLoopBy16
            shl         eax,4
            Loop2F:

                fld         dword Ptr [esi]         //Load Sin value
                add         esi,4                   //piSin++
                fld         dword Ptr [ecx-4]       //Load Coefficent from channel 1
                fmul        st(0),st(1)             //Multiply it with Sin value
                sub         ecx,4                   //piCoef--
                fld         dword Ptr [edx-4]       //Load Coefficent from channel 2
                fmulp       st(2),st(0)             //Multiply it with Sin value
                fistp       dword Ptr [ebx]         //Store as 32bit int
                sub         edx,4                   //piCoef--
                fistp       dword Ptr [ebx+4]       //Store as 32bit int
                add         ebx,8                   //bump temp buffer ptr

            dec         eax
            jnz         Loop2F
            mov         piSin,esi
            mov         piCoef,ecx
            mov         piCoef2,edx
                
            mov         ebx,piSrcSign
            mov         ecx,piSrcSign2
            mov         esi,piSrc
            mov         edx,tBuf 
            mov         edi,piDst

            movd        mm0,uiSignbitData    
            movd        mm1,uiSignbitData2

            mov         eax,iLoopBy16
            Loop2M:    
                    
                punpcklwd   mm0,mm1
                    
                RECONSTRUCT4(0)
                RECONSTRUCT4(1)
                RECONSTRUCT4(2)
                RECONSTRUCT4(3)
                RECONSTRUCT4(4)
                RECONSTRUCT4(5)
                RECONSTRUCT4(6)
                RECONSTRUCT4(7)
                    
                add         esi,32*2
                add         edx,32*4
                add         edi,32*2

                movd        mm0,[ebx]
                movd        mm1,[ecx]

                add         ebx,2
                add         ecx,2
                

            dec         eax
            jnz         Loop2M

            mov         piSrc,esi
            mov         tBuf,edx
            mov         piDst,edi

            movd        uiSignbitData,mm0
            movd        uiSignbitData2,mm1
            mov         piSrcSign,ebx
            mov         piSrcSign2,ecx

            emms
#           undef RECONSTRUCT4
            }
            uiSignbitCount  = 16;
            uiSignbitCount2 = 16;
            if (iLoopBy1) {
                pau->aupfnReconstruct = auReconstruct;
                return auReconstruct(pau,piOutput,pcSampleGet,fForceTransformAll); 
            }

/*            for (iLoopCnt = 0; iLoopCnt < iLoopBy1; iLoopCnt++, i++, (*pcSampleGet)++)    {
                //Channel 1
                COMBINE_SIGNBIT(iResult, *piSrc, piSrcSign, uiSignbitData,
                    uiSignbitCount);
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc++;
                piDst++;

                //Channel 2
                COMBINE_SIGNBIT(iResult, *piSrc, piSrcSign, uiSignbitData2,
                    uiSignbitCount2);
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef2) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc++;
                piDst++;
            }   */
        }
    }
    if (i < iCoefRecurQ3) 
    {
        iSegEnd = min (iCoefRecurQ3, iEnd);

        for (; i < iSegEnd; i++,(*pcSampleGet)++)    {
            cfResult = INT_FROM_COEF( *--piCoef );
            ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
            cfResult = INT_FROM_COEF( *--piCoef2 );
            ROUND_SATURATE_STORE( (piDst+1), cfResult, SHRT_MIN, SHRT_MAX, iResult );
            piDst += cChan;
        }
    }

    SAVE_SIGNBIT_STATE(piSrcSign,uiSignbitData);
    pau->m_rgpcinfo[0].m_rgiCoefReconCurr = (Int*)piCoef;
    pau->m_rgpcinfo[0].m_iCurrGetPCM_SubFrame = (I16)i;
    pau->m_rgpcinfo[0].m_piPrevOutputCurr = piSrc;


    SAVE_SIGNBIT_STATE(piSrcSign2,uiSignbitData2);
    pau->m_rgpcinfo[1].m_rgiCoefReconCurr = (Int*)piCoef2;
    pau->m_rgpcinfo[1].m_iCurrGetPCM_SubFrame = (I16)i;//= (I16)i;
    pau->m_rgpcinfo[1].m_piPrevOutputCurr = piSrc+1;

    pau->m_piSinForRecon = piSin;

#ifdef PROFILE
    FunctionProfileStop(&fp);
#endif
    return WMA_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Recon Stereo SIMD FP
// This function improves on auReconStereo_MMX by doing the floating point using intels
// vector floating point instructions and removing the floating point loop and intermixing
// it with the int/MMX loop. It is otherwize similar to auReconStereo_MMX
//////////////////////////////////////////////////////////////////////////////////////////////

WMARESULT auReconStereo_SIMDFP (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll)
{
    Int overflow = 0;
    Float *piCoef2; 
    Float *piCoef;  
    Int i, iEnd, iSegEnd;
    I16 *piSrc, *piDst; 
    I32 iResult;

    // get local copies of these values which are used frequently or repeatedly (helps optimization)
    Int cChan = pau->m_cChannel;
    Int cSubFrameSampleHalf = pau->m_cSubFrameSampleHalfAdjusted;
    Int cSubFrameSampleQuad = pau->m_cSubFrameSampleQuadAdjusted;
    Int iCoefRecurQ2 = pau->m_iCoefRecurQ2;
    Int iCoefRecurQ3 = pau->m_iCoefRecurQ3;
    float *piSin = pau->m_piSinForRecon;

    U16    *piSrcSign;
    I32     uiSignbitData;
    U32     uiSignbitCount;
    U16    *piSrcSign2;
    I32     uiSignbitData2;
    U32     uiSignbitCount2;

#ifdef PREVOUTPUT_16BITS
    assert(0);
#endif// PREVOUTPUT_16BITS

#ifdef PROFILE
    FunctionProfile fp;
    FunctionProfileStart(&fp,RECON_MONO_PROFILE);
#endif

    //persistent states
    i = pau->m_rgpcinfo[0].m_iCurrGetPCM_SubFrame;       //current position in a frame
    assert(i==pau->m_rgpcinfo[1].m_iCurrGetPCM_SubFrame);
    piCoef = (float*)pau->m_rgpcinfo[0].m_rgiCoefReconCurr; 
    piCoef2 = (float*)(pau->m_rgpcinfo[1].m_rgiCoefReconCurr); 

    piSrc = pau->m_rgpcinfo[0].m_piPrevOutputCurr;
    assert((piSrc+1) == pau->m_rgpcinfo[1].m_piPrevOutputCurr);
    
    //eventually we'll use piOutput directly
    piDst = piOutput;

    iEnd = i + *pcSampleGet;
    *pcSampleGet = 0;

    CALC_SIGN_OFFSETS(pau->m_rgpcinfo[0].m_piPrevOutput,(piSrc+0), pau->m_rgpcinfo[0].m_piPrevOutputSign, piSrcSign, 
        uiSignbitData, uiSignbitCount, cChan)

    CALC_SIGN_OFFSETS(pau->m_rgpcinfo[1].m_piPrevOutput,(piSrc+1), pau->m_rgpcinfo[1].m_piPrevOutputSign, piSrcSign2, 
        uiSignbitData2, uiSignbitCount2, cChan)

    ASSERT_SIGNBIT_POINTER(piSrcSign);

    if (i < cSubFrameSampleQuad) 
    {
        iSegEnd = min (cSubFrameSampleQuad, iEnd);
        if ( i < iSegEnd )
        {
            Int iLoopBy16,iLoopBy1;
            iLoopBy16 = (iSegEnd - i) >> 4;
            iLoopBy1  = (iSegEnd - i) & 0xF;
            (*pcSampleGet) += (I16)(iLoopBy16<<4);
            i += (iLoopBy16<<4);

            _asm {
            mov         ebx,piSin
            mov         ecx,piCoef
            mov         edx,piCoef2
            mov         esi,piSrc
            mov         edi,piDst
            
            movd        mm0,uiSignbitData    
            movd        mm1,uiSignbitData2

            mov         eax,iLoopBy16
            Loop1:

                punpcklwd   mm0,mm1
                                           //Note:The indentation of these comments tries
                                           //     to show logical paths since the instructions 
                                           //     have been scheduled out of logical paths

#define RECONSTRUCT8(x) _asm {                                                                                           \
_asm            movups      xmm3_ebx          /*Load 4 Sin values from table*/                                           \
_asm            movq        mm5,mm0               /*copy sign bit data*/                                                 \
_asm            add         ebx,4*4       /*Bump ptr*/                                                                   \
_asm            movaps      xmm0_xmm3         /*copy Sin values*/                                                        \
_asm            psraw       mm5,15                /*sine extend sine bit data*/                                          \
_asm            shufps      (xmm0_xmm3,0x50)  /*broadcast 1st and 2nd Sin values (a=a,b=a,c=b,d=b) */                    \
_asm            movd        mm2,[esi+(x*16)]      /*load 2 16bit data elements from piSrc*/                              \
_asm            movups      xmm4_ecx          /*Load Coefficents for channel 1*/                                         \
_asm            add         ecx,4*4       /*Bump ptr*/                                                                   \
_asm            punpcklwd   mm2,mm5               /*interleave src with sign bit for 2 32bit values*/                    \
_asm            movaps      xmm1_xmm4         /*make a copy of coefficents for channel 1*/                               \
_asm            pslld       mm0,1                 /*shift sine bit data for next 2*/                                     \
_asm            movups      xmm2_edx          /*Load Coefficents for channel 2*/                                         \
_asm            add         edx,4*4       /*Bump ptr*/                                                                   \
_asm            movq        mm6,mm0               /*copy sign bit data*/                                                 \
_asm            pslld       mm0,1                 /*shift sine bit data for next 2*/                                     \
_asm            unpcklps    xmm1_xmm2         /*Interleve first 2 Coefficents of channel 1 & 2*/                         \
_asm            psraw       mm6,15                /*sine extend sine bit data*/                                          \
_asm            mulps       xmm0_xmm1         /*Multiply coefficents with Sin values*/                                   \
_asm            movd        mm4,[esi+(x*16)+4]    /*load next 2 16bit data elements from piSrc*/                         \
_asm            cvtps2pi    mm1_xmm0          /*convert 2 lower multiply results to rounded integer values*/             \
_asm            punpcklwd   mm4,mm6               /*interleave src with sign bit for 2 32bit values*/                    \
_asm            shufps      (xmm0_xmm0,0xE)   /*move high elements in to low (a=c,b=d,c=a,d=a)*/                         \
_asm            movq        mm7,mm0                   /*copy sign bit data*/                                             \
_asm            pslld       mm0,1                     /*shift sine bit data for next 2*/                                 \
_asm            cvtps2pi    mm3_xmm0          /*convert 2 multiplyed results to rounded integer values*/                 \
_asm            psraw       mm7,15                    /*sine extend sine bit data*/                                      \
_asm            movaps      xmm0_xmm3                      /*copy Sin values*/                                           \
_asm            paddd       mm1,mm2           /*add the 2 vectors*/                                                      \
_asm            paddd       mm3,mm4           /*add the 2 other vectors*/                                                \
_asm            shufps      (xmm0_xmm3,0xFA)               /*broadcast 3rd and 4th Sin Values (a=c,b=c,c=d,d=d)*/        \
_asm            packssdw    mm1,mm3           /*merge and saturate vectors*/                                             \
_asm            movq        mm5,mm0                   /*copy sign bit data*/                                             \
_asm            movaps      xmm1_xmm4                      /*make a copy of coefficents for channel 1*/                  \
_asm            movq        [edi+(x*16)],mm1  /*store 4 reconstructed samples*/                                          \
_asm            unpckhps    xmm1_xmm2                      /*Interleve last 2 Coefficents of channel 1 & 2*/             \
_asm            movd        mm2,[esi+(x*16)+8]        /*load next 2 16bit data elements from piSrc*/                     \
_asm            pslld       mm0,1                     /*shift sine bit data for next 2*/                                 \
_asm            mulps       xmm0_xmm1                      /*Multiply coefficents with Sin values*/                      \
_asm            movd        mm4,[esi+(x*16)+12]       /*load next 2 16bit data elements from piSrc*/                     \
_asm            psraw       mm5,15                    /*sine extend sine bit data*/                                      \
_asm            cvtps2pi    mm1_xmm0                       /*convert 2 lower multiply results to rounded integer values*/\
_asm            punpcklwd   mm2,mm7                   /*merge with sign bit for 2 32bit values*/                         \
_asm            shufps      (xmm0_xmm0,0xE)                /*move high elements in to low (a=c,b=d,c=a,d=a)*/            \
_asm            punpcklwd   mm4,mm5                   /*interleave src with sign bit for 2 32bit values*/                \
_asm            paddd       mm1,mm2                        /*add the 2 vectors*/                                         \
_asm            cvtps2pi    mm3_xmm0                       /*convert 2 multiply results to rounded integer values*/      \
_asm            paddd       mm3,mm4                        /*add the 2 other vectors*/                                   \
_asm            packssdw    mm1,mm3                        /*merge and saturate 2 sets of 2*/                            \
_asm            movq        [edi+(x*16)+8],mm1             /*store 4 reconstructed samples*/                             }

                RECONSTRUCT8(0)
                RECONSTRUCT8(1)
                RECONSTRUCT8(2)
                RECONSTRUCT8(3)
                
                add         esi,2*32
                add         edi,2*32


                mov         iResult,ebx

                mov         ebx,piSrcSign  //uiSignbitData = *piSrcSign++;
                movd        mm0,[ebx]
                pslld       mm0,16
                psrld       mm0,16
                add         ebx,2
                mov         piSrcSign,ebx

                mov         ebx,piSrcSign2 //uiSignbitData2 = *piSrcSign2++;
                movd        mm1,[ebx]
                pslld       mm1,16
                psrld       mm1,16
                add         ebx,2
                mov         piSrcSign2,ebx

                mov         ebx,iResult
 
            dec         eax
            jnz         Loop1

            mov         piSrc,esi
            mov         piDst,edi
            mov         piSin,ebx
            mov         piCoef,ecx
            mov         piCoef2,edx
            movd        uiSignbitData,mm0
            movd        uiSignbitData2,mm1

            emms

#           undef RECONSTRUCT8
            }
            uiSignbitCount = 16;                                                     
            uiSignbitCount2 = 16;                                                     
            if (iLoopBy1) {
                pau->aupfnReconstruct = auReconstruct;
                return auReconstruct(pau,piOutput,pcSampleGet,fForceTransformAll); 
            }
        }
    }

    if (i < iCoefRecurQ2)  
    {
        iSegEnd = min (iCoefRecurQ2, iEnd);
        if ( i < iSegEnd )
        {
            U16 *piDstCopy = piDst;
            Int iLoopBy16,iLoopBy1;
            iLoopBy16 = (iSegEnd - i) >> 4;
            iLoopBy1  = (iSegEnd - i) & 0xF;
            (*pcSampleGet) += (I16)(iLoopBy16<<4);
            i += (iLoopBy16<<4);

            _asm {
            mov         ebx,piSin
            mov         ecx,piCoef
            mov         edx,piCoef2
            mov         esi,piSrc
            mov         edi,piDst
            
            movd        mm0,uiSignbitData    
            movd        mm1,uiSignbitData2

            mov         eax,iLoopBy16
            Loop2:

                punpcklwd   mm0,mm1

#define RECONSTRUCT8(x) _asm {                                                                                           \
_asm            movups      xmm3_ebx          /*Load 4 Sin values from table*/                                           \
_asm            movq        mm5,mm0               /*copy sign bit data*/                                                 \
_asm            add         ebx,4*4       /*Bump ptr*/                                                                   \
_asm            movaps      xmm0_xmm3         /*copy Sin values*/                                                        \
_asm            psraw       mm5,15                /*sine extend sine bit data*/                                          \
_asm            shufps      (xmm0_xmm3,0x50)  /*broadcast 1st and 2nd Sin values (a=a,b=a,c=b,d=b) */                    \
_asm            movd        mm2,[esi+(x*16)]      /*load 2 16bit data elements from piSrc*/                              \
_asm            sub         ecx,4*4       /*Bump ptr*/                                                                   \
_asm            movups      xmm4_ecx          /*Load Coefficents for channel 1*/                                         \
_asm            shufps      (xmm4_xmm4,0x1B)                                                                             \
_asm            punpcklwd   mm2,mm5               /*interleave src with sign bit for 2 32bit values*/                    \
_asm            movaps      xmm1_xmm4         /*make a copy of coefficents for channel 1*/                               \
_asm            pslld       mm0,1                 /*shift sine bit data for next 2*/                                     \
_asm            sub         edx,4*4       /*Bump ptr*/                                                                   \
_asm            movups      xmm2_edx          /*Load Coefficents for channel 2*/                                         \
_asm            shufps      (xmm2_xmm2,0x1B)                                                                             \
_asm            movq        mm6,mm0               /*copy sign bit data*/                                                 \
_asm            pslld       mm0,1                 /*shift sine bit data for next 2*/                                     \
_asm            unpcklps    xmm1_xmm2         /*Interleve first 2 Coefficents of channel 1 & 2*/                         \
_asm            psraw       mm6,15                /*sine extend sine bit data*/                                          \
_asm            mulps       xmm0_xmm1         /*Multiply coefficents with Sin values*/                                   \
_asm            movd        mm4,[esi+(x*16)+4]    /*load next 2 16bit data elements from piSrc*/                         \
_asm            cvtps2pi    mm1_xmm0          /*convert 2 lower multiply results to rounded integer values*/             \
_asm            punpcklwd   mm4,mm6               /*interleave src with sign bit for 2 32bit values*/                    \
_asm            shufps      (xmm0_xmm0,0xE)   /*move high elements in to low (a=c,b=d,c=a,d=a)*/                         \
_asm            movq        mm7,mm0                   /*copy sign bit data*/                                             \
_asm            pslld       mm0,1                     /*shift sine bit data for next 2*/                                 \
_asm            cvtps2pi    mm3_xmm0          /*convert 2 multiplyed results to rounded integer values*/                 \
_asm            psraw       mm7,15                    /*sine extend sine bit data*/                                      \
_asm            movaps      xmm0_xmm3                      /*copy Sin values*/                                           \
_asm            paddd       mm1,mm2           /*add the 2 vectors*/                                                      \
_asm            paddd       mm3,mm4           /*add the 2 other vectors*/                                                \
_asm            shufps      (xmm0_xmm3,0xFA)               /*broadcast 3rd and 4th Sin Values (a=c,b=c,c=d,d=d)*/        \
_asm            packssdw    mm1,mm3           /*merge and saturate vectors*/                                             \
_asm            movq        mm5,mm0                   /*copy sign bit data*/                                             \
_asm            movaps      xmm1_xmm4                      /*make a copy of coefficents for channel 1*/                  \
_asm            movq        [edi+(x*16)],mm1  /*store 4 reconstructed samples*/                                          \
_asm            unpckhps    xmm1_xmm2                      /*Interleve last 2 Coefficents of channel 1 & 2*/             \
_asm            movd        mm2,[esi+(x*16)+8]        /*load next 2 16bit data elements from piSrc*/                     \
_asm            pslld       mm0,1                     /*shift sine bit data for next 2*/                                 \
_asm            mulps       xmm0_xmm1                      /*Multiply coefficents with Sin values*/                      \
_asm            movd        mm4,[esi+(x*16)+12]       /*load next 2 16bit data elements from piSrc*/                     \
_asm            psraw       mm5,15                    /*sine extend sine bit data*/                                      \
_asm            cvtps2pi    mm1_xmm0                       /*convert 2 lower multiply results to rounded integer values*/\
_asm            punpcklwd   mm2,mm7                   /*merge with sign bit for 2 32bit values*/                         \
_asm            shufps      (xmm0_xmm0,0xE)                /*move high elements in to low (a=c,b=d,c=a,d=a)*/            \
_asm            punpcklwd   mm4,mm5                   /*interleave src with sign bit for 2 32bit values*/                \
_asm            paddd       mm1,mm2                        /*add the 2 vectors*/                                         \
_asm            cvtps2pi    mm3_xmm0                       /*convert 2 multiply results to rounded integer values*/      \
_asm            paddd       mm3,mm4                        /*add the 2 other vectors*/                                   \
_asm            packssdw    mm1,mm3                        /*merge and saturate 2 sets of 2*/                            \
_asm            movq        [edi+(x*16)+8],mm1             /*store 4 reconstructed samples*/                             }

                RECONSTRUCT8(0)
                RECONSTRUCT8(1)
                RECONSTRUCT8(2)
                RECONSTRUCT8(3)
                
                add         esi,2*32
                add         edi,2*32

                mov         iResult,ebx

                mov         ebx,piSrcSign   //uiSignbitData = *piSrcSign++;
                movd        mm0,[ebx]
                pslld       mm0,16
                psrld       mm0,16
                add         ebx,2
                mov         piSrcSign,ebx

                mov         ebx,piSrcSign2  //uiSignbitData2 = *piSrcSign2++;
                movd        mm1,[ebx]
                pslld       mm1,16
                psrld       mm1,16
                add         ebx,2
                mov         piSrcSign2,ebx

                mov         ebx,iResult
 
            dec         eax
            jnz         Loop2

            mov         piSrc,esi
            mov         piDst,edi
            mov         piSin,ebx
            mov         piCoef,ecx
            mov         piCoef2,edx
            movd        uiSignbitData,mm0
            movd        uiSignbitData2,mm1

            emms

#           undef RECONSTRUCT8

            }
            uiSignbitCount = 16;                                                     
            uiSignbitCount2 = 16;                                                     
            if (iLoopBy1) {
                pau->aupfnReconstruct = auReconstruct;
                return auReconstruct(pau,piOutput,pcSampleGet,fForceTransformAll); 
            }
        }
    }
    if (i < iCoefRecurQ3) 
    {
        Int iLoopBy4,iLoopBy1,iLoopCnt;
        iSegEnd = min (iCoefRecurQ3, iEnd);
        iLoopBy4 = (iSegEnd - i) >> 2;
        iLoopBy1 = (iSegEnd - i) & 0x3;
        (*pcSampleGet) += (I16)(iLoopBy4<<2);
        i += (iLoopBy4<<2);
        if (iLoopBy4 != 0)
        {
            _asm {

            mov         eax,iLoopBy4
            mov         ecx,piCoef
            mov         edx,piCoef2
            mov         edi,piDst
            Loop3:    
                sub         ecx,4*4                 //Bump ptr                                                              
                movups      xmm4_ecx                //Load Coefficents for channel 1
                sub         edx,4*4                 //Bump ptr                                          
                movups      xmm2_edx                //Load Coefficents for channel 2                                        
                cvtps2pi    mm0_xmm4                //convert 2 lower multiply results to rounded integer values            
                cvtps2pi    mm1_xmm2                //convert 2 lower multiply results to rounded integer values           
                shufps      (xmm4_xmm4,0xE)         //move high elements in to low (a=c,b=d,c=a,d=a)              
                shufps      (xmm2_xmm2,0xE)         //move high elements in to low (a=c,b=d,c=a,d=a)                        
                cvtps2pi    mm2_xmm4                //convert 2 lower multiply results to rounded integer values           
                cvtps2pi    mm3_xmm2                //convert 2 lower multiply results to rounded integer values            
                packssdw    mm2,mm3                 //Convert to 16bit and saturate
                pshufw      mm2_mm2 emit 0x8D     //Shuffle (a=b,b=d,c=a,b=c)
                packssdw    mm0,mm1                 //Convert to 16bit and saturate
                pshufw      mm0_mm0 emit 0x8D     //Shuffle (a=b,b=d,c=a,b=c)
                movq        [edi],mm2               //Store 4 16bit words
                movq        [edi+8],mm0             //Store 4 16bit words
                add         edi,2*8                 //Bump Ptr
            dec         eax
            jnz         Loop3
            mov         piCoef,ecx
            mov         piCoef2,edx
            mov         piDst,edi

            emms

            }
        }
        //if (iLoopBy1) _asm emms
        for (iLoopCnt = 0; iLoopCnt < iLoopBy1; iLoopCnt++, i++,(*pcSampleGet)++)    {
            Float cfResult = INT_FROM_COEF( *--piCoef );
            ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
            cfResult = INT_FROM_COEF( *--piCoef2 );
            ROUND_SATURATE_STORE( (piDst+1), cfResult, SHRT_MIN, SHRT_MAX, iResult );
            piDst += cChan;
        }
    }
    //_asm emms

    SAVE_SIGNBIT_STATE(piSrcSign,uiSignbitData);
    pau->m_rgpcinfo[0].m_rgiCoefReconCurr = (Int*)piCoef;
    pau->m_rgpcinfo[0].m_iCurrGetPCM_SubFrame = (I16)i;
    pau->m_rgpcinfo[0].m_piPrevOutputCurr = piSrc;


    SAVE_SIGNBIT_STATE(piSrcSign2,uiSignbitData2);
    pau->m_rgpcinfo[1].m_rgiCoefReconCurr = (Int*)piCoef2;
    pau->m_rgpcinfo[1].m_iCurrGetPCM_SubFrame = (I16)i;
    pau->m_rgpcinfo[1].m_piPrevOutputCurr = piSrc+1;

    pau->m_piSinForRecon = piSin;

#ifdef PROFILE
    FunctionProfileStop(&fp);
#endif
    return WMA_OK;
}

#endif //BUILD_INTEGER
#endif //USE_SIN_COS_TABLES

#endif // defined(WMA_TARGET_X86)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\huffdec.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    HuffDec.h

Abstract:

    Huffman decoder. Simplified from Sanjeevm's huffman.hpp

Author:

    Wei-ge Chen (wchen) 19-July-1999

Revision History:


*************************************************************************/

#ifndef _HUFFDEC_H
#define _HUFFDEC_H

#ifdef __cplusplus
extern "C" {  // only need to export C interface if
              // used by C++ source code
#endif

#include "macros.h"
#include "strmdec_wma.h"

#define BITSTREAM_READ 1

WMARESULT huffDecGet(const U16 *pDecodeTable, CWMAInputBitStream *bs,
                     U32* puBitCnt, U32 *puResult, U32* puSign);

#ifdef __cplusplus
}
#endif
#endif //_HUFFDEC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\basic.hpp ===
//codecs/scrunchcore/type/basic.hpp#5 - edit change 20855 (text)
/*************************************************************************

Copyright (c) Microsoft Corporation 1996 - 1999

Module Name:

	basic.hpp

Abstract:

    Basic types:
		Data, CSite, CVector2D, CVector3D, CRct, CPixel, CMotionVector, CMatrix3x3D

Author:

	Ming-Chieh Lee (mingcl@microsoft.com) 20-March-1996
	Wei-ge Chen (wchen@microsoft.com) 20-March-1996
	Bruce Lin	(blin@microsoft.com) 14-April-1996
	Chuang Gu (chuanggu@microsoft.com) 5-June-1996

Revision History:


*************************************************************************/


#ifndef __BASIC_HPP_
#define __BASIC_HPP_

// briaking - replaced the previously convoluted stuff involving ndis.h with this:
#ifdef UNDER_CE
// find ASSERT in windows CE include files
#include <windows.h>
#include <dbgapi.h>
#define assert ASSERT
#else
#include "assert.h"
#endif

#include <string.h>

#ifdef __MAKE_DLL_
#define API __declspec (dllexport)
#define Class        class API
#else
#define API
#define Class		class
#endif // __MAKE_DLL_

#ifdef __MFC_
#include <afx.h>
#include <afxtempl.h>
#include <windowsx.h>
#endif // __MFC_

#ifdef DO_BOE
#define BOE DebugBreak()
#else
#define BOE	
#endif

#ifndef ICERR_OK
#define ICERR_OK		0L
#define ICERR_ERROR		-100L
#define	ICERR_MEMORY		-3L
#define ICERR_BADFORMAT        	-2L
#endif

#if defined(__MACVIDEO__) || defined(__UNIXVIDEO__)
#undef NOERROR
#define NOERROR	0
#undef far
#define far                 
typedef void far            *LPVOID;
#endif
typedef void *LPVoid;

#ifdef __MACAUDIO__

#define NO_WINDOWS
#define WORD_ALIGN
#define DWORD_ALIGN

#include <MacTypes.h>
//#include <Errors.h>
//#include <Endian.h>
//#include <MacMemory.h>
//#include <Resources.h>
//#include <Components.h>
//#include <Sound.h>
//#include <MoviesFormat.h>

typedef SInt32 __int32;
typedef SInt64 __int64;
#define __huge
#define E_FAIL			0x80004005L
#define E_OUTOFMEMORY	0x8007000EL
#define S_OK			0x0L
#define S_FALSE			0x1L
#define ZeroMemory(a,b)	memset(a,0,b)

typedef unsigned char BYTE;
typedef UInt32 DWORD;
typedef UInt16 WORD;
#ifndef _HRESULT
#define _HRESULT
typedef long HRESULT;
#endif
typedef long HMODULE;

#else
#ifndef _MAC
#ifndef Linux
#ifndef HITACHI
#ifndef NULL
#define NULL 0
#endif
#endif
#endif//Linux   
#define signbit(x) (((x) > 0) ? 1 : 0)
typedef char Byte;
#else
#define __huge
#endif

#endif

#define own // used as "reserved word" to indicate ownership or transfer to distinguish from const
#define TRUE 1
#define FALSE 0
#define transpValue 0
#define opaqueValue 255
#define transpPixel CPixel(0,0,0,0)
#define opaquePixel CPixel(255,255,255,255)

#define max(a,b) (((a) > (b)) ? (a) : (b))
#ifndef _MIN
#define _MIN
#define min(a, b)  (((a) < (b)) ? (a) : (b))
#endif
#define checkRange(x, a, b) (((x) < (a)) ? (a) : ((x) > (b)) ? (b) : (x))
#define DELETE_ARRAY(ptr) if (ptr) {delete [] ptr; ptr = NULL;};
#define DELETE_PTR(ptr) if (ptr) {delete ptr; ptr = NULL;};



//NQF, for Linux, define UNIX, then, undefine UNIX at very end
#if defined(Linux) || defined(_Embedded_x86)
#define  UNIX
#undef   NULL 
#include <stddef.h>
#endif  
//NQF  


/////////////////////////////////////////////
//
//      Forward declarations for classes
//
/////////////////////////////////////////////
#ifdef __cplusplus
Class CSite;
Class CVector2D;
Class CRct;
Class CPixel; // 32 bit pixel, various interpretations depending on PixelType
Class CMotionVector;
#endif //__cplusplus

// Unix defines

#ifdef UNIX

#define NO_WINDOWS
#define WORD_ALIGN
#define DWORD_ALIGN

#ifndef _XBOX
typedef signed long __int32;
#ifndef HITACHI
typedef signed long long __int64;
typedef unsigned long long U64;
#endif
#else
typedef unsigned __int64 U64;
#endif // _XBOX
#define __huge
#define _cdecl
#define __fastcall
#define FAR
#define E_FAIL		     0x80004005L
#define E_OUTOFMEMORY	     0x8007000EL
#define S_OK		     0x0L
#define S_FALSE		     0x1L
#ifndef _XBOX
#define ZeroMemory(a,b)	memset(a,0,b)
#endif

typedef unsigned char BYTE;
typedef unsigned long DWORD;
typedef unsigned short WORD;
typedef char TCHAR;
typedef long HRESULT;
typedef long HMODULE;
#ifdef HITACHI

typedef struct tQWORD
{
    DWORD   dwLo;
    DWORD   dwHi;

}   QWORD;

typedef QWORD U64;

#endif


#if !(defined(macintosh) || defined(_Embedded_x86))
	#ifndef SUNCC50
#ifndef Linux
#ifndef HITACHI
    typedef enum { false , true } bool;  
#endif
#endif
#endif
#endif  // _MAC

#endif


/////////////////////////////////////////////
//
//  Typedefs for basic types
//
/////////////////////////////////////////////

// HongCho: some platforms might not support inline assembly
#ifdef _M_IX86
#ifdef _WIN32
#define _SCRUNCH_INLINEASM
#else
// default is not supporting it...
#undef _SCRUNCH_INLINEASM
#endif // _WIN32
#endif // _M_IX86
#ifdef _ALPHA_
#define _SCRUNCH_INLINEASM
#endif // _ALPHA_
#if defined(_Embedded_x86)
#define _SCRUNCH_INLINEASM
#endif // _Embedded_x86

#if 1 // in case future compilers redefine longs and shorts
typedef unsigned long U32;

#if defined(_WIN32) || defined (_XBOX)
typedef int I32;
#else
//#if macintosh
//typedef SInt32 I32;
//#else
typedef long int I32;
//#endif
#endif

typedef unsigned short U16;
typedef short I16;
#endif // in case future compilers redefine longs and shorts

#define Sizeof(x) ((U32) sizeof (x))


#ifdef _ALPHA_ //Wide type is the widest integer register supported by the machine
typedef __int64 Wide;
typedef unsigned __int64 UWide;
#else
#ifndef UNDER_CE
#define __unaligned
#endif
//typedef __int32 Wide;
//#if macintosh
//typedef UInt32 UWide;
//#else
//typedef unsigned __int32 UWide;
typedef I32 Wide;
typedef U32 UWide;
//#endif
#endif
#ifdef macintosh
typedef long long Int64;
typedef long long I64;
#else
#ifndef HITACHI
typedef __int64 Int64;
typedef __int64 I64;
#endif
#endif

#ifdef __MACAUDIO__
typedef UInt64 U64;
#else
#ifndef UNIX
#ifdef macintosh
typedef unsigned long long U64;
#else
typedef unsigned __int64 U64;
#endif // UNIX
#endif // macintosh
#endif  //_MACAUDIO
typedef U32 UInt;
typedef I32 Int;
typedef double Double;
typedef float Float;
typedef float Float32;
typedef float F32;
#ifndef _Embedded_x86
typedef unsigned char U8;
#else
#define U8 unsigned char
#endif
typedef signed char I8;
typedef I32 Long;
typedef U32 ULong;
typedef void Void;
typedef I32 Bool;
typedef I32 CoordI;
typedef double CoordD;
typedef char Char;
typedef enum AlphaUsage {RECTANGLE = 0, ONE_BIT = 1, EIGHT_BIT = 2} AlphaUsage;
typedef enum {RGBT_ILLEGAL, RGBT_8, RGBT_555, RGBT_565, RGBT_888} RGBType;
typedef enum {red, green, blue, alpha} RGBA; // define pixel component
typedef enum BlockNum {
	ALL_Y_BLOCKS	= 0,
	Y_BLOCK1		= 1,
	Y_BLOCK2		= 2,
	Y_BLOCK3		= 3,
	Y_BLOCK4		= 4,
	U_BLOCK			= 5,
	V_BLOCK			= 6,
	A_BLOCK1		= 7,
	A_BLOCK2		= 8,
	A_BLOCK3		= 9,
	A_BLOCK4		= 10,
	ALL_A_BLOCKS	= 11
} BlockNum;
typedef enum PlaneType {Y_PLANE, U_PLANE, V_PLANE, A_PLANE, BY_PLANE, BUV_PLANE} PlaneType;
//typedef enum MotEstMode {MOTEST_VIDEO_CONFERENCE, MOTEST_PLATEAU} MotEstMode;
#define MOTEST_VIDEO_CONFERENCE 1
#define MOTEST_PLATEAU 2

//typedef Int Time;
#ifdef macintosh
typedef long long Time;
#else
typedef __int64 Time;
#endif

#ifndef __huge
#if !defined(_WIN32)
#define __huge _huge
#else
#define __huge
#endif
#endif

#if defined(_WIN16)

#define memcpy _fmemcpy
#define memset _fmemset

Void HugeCopyMemory(Void __huge *dst, const Void __huge *src, UInt count);
Void HugeSetMemory(Void __huge *dst, Int c, UInt count);

#else

#define HugeCopyMemory memcpy
#define HugeSetMemory memset

#endif


/////////////////////////////////////////////
//
//  Space
//
/////////////////////////////////////////////

#ifdef __cplusplus
Class CSite
{
public:  
	CoordI x; 
	CoordI y; 

	// Constructors
	CSite () {}
	CSite (const CSite& s) {x = s.x; y = s.y;}
	CSite (CoordI xx, CoordI yy) {x = xx; y = yy;}

	// Properties
	CoordI xCoord () const {return x;}
	CoordI yCoord () const {return y;}

	// Operators
	Void set (CoordI xx, CoordI yy) {x = xx; y = yy;}
	CSite operator + (const CSite& st) const; // Coornidate-wise +
	CSite operator - (const CSite& st) const; // Coornidate-wise -
	CSite operator * (const CSite& st) const; // Coornidate-wise *
	CSite operator * (Int scale) const; // Coornidate-wise scaling
	CSite operator / (const CSite& st) const; // Coornidate-wise /
	CSite operator / (Int scale) const; // Coornidate-wise scaling
	CSite operator % (const CSite& st) const; // Coornidate-wise %
	Void operator = (const CSite& st);

	// Synonyms
	Bool operator == (const CSite& s) const {return x == s.x && y == s.y;}
	Bool operator != (const CSite& s) const {return x != s.x || y != s.y;}
}; 

Class CVector
{
public:
	I8 x;
	I8 y;

    // constructor
    CVector () {x = y = 0;}
	CVector (I8 xx, I8 yy) {x = xx; y = yy;}
};


Class CRct
{
public:
    CoordI left, top, right, bottom;

    // Constructors
    CRct ()
	    {left = top = 0; right = bottom = -1;}
    CRct (CoordI l, CoordI t, CoordI r, CoordI b)
	    {left = l; top = t; right = r; bottom = b;}

    // Attributes
    Bool valid () const
	    {return left < right && top < bottom;} 
    Bool empty () const
	    {return left >= right || top >= bottom;}
    CoordI width () const
	    {return (right - left);}
    CoordI height () const
	    {return (bottom - top);}
    UInt area () const
	    {return (UInt) width () * height ();}
    UInt offset (CoordI x, CoordI y) const
        {return !valid () ? 0 : width () * (y - top) + (x - left);} 
    Bool operator == (const CRct& rc) const; 
    Bool operator != (const CRct& rc) const; 

    // Operations
    Void operator = (const CRct& rc);
};

/////////////////////////////////////////////
//
//  Motion Vectors
//
/////////////////////////////////////////////

Class CMotionVector
{
public:
	I8 m_iMVX; // x direction motion
	I8 m_iMVY; // y direction motion
	I8 m_iHalfX; // x direction half pixel. 3 values: -1, 0, 1
	I8 m_iHalfY; // x direction half pixel. 3 values: -1, 0, 1
    CVector m_vctTrueHalfPel; // true motion vector (double)
#ifdef _4MV_
    I8 m_i8x8MVX [4]; // x direction motion
	I8 m_i8x8MVY [4]; // y direction motion
	I8 m_i8x8HalfX [4]; // x direction half pixel. 3 values: -1, 0, 1
	I8 m_i8x8HalfY [4]; // x direction half pixel. 3 values: -1, 0, 1
	CVector m_vct8x8TrueHalfPel [4]; // true8x8 motion vector (double)
	CVector m_vct8x8PredMVHalfPel [4]; // pred8x8 motion vector (double)
#endif
	CVector m_vctPredMVHalfPel; // pred motion vector (double)

	// Constructor
	CMotionVector (const CVector& vctHalfPel);
	CMotionVector () {setToZero ();}
	// Attributes
	const CVector& trueMVHalfPel () const {return m_vctTrueHalfPel;}

	// Operations
	Void operator = (const CMotionVector& mv);
	Void operator = (const CVector& vctHalfPel);
	Void setToZero ();
	Void computeTrueHalfPelMV (); // compute trueMV (CVector2D) from MV (CMotionVector)
    Void computeTrue8x8HalfPelMV (Int iBlkNum);
	Void computeMV (); // compute MV (CMotionVector) from trueMV (CVector2D)

};

#define NUM_BYTES_MV	(sizeof(CMotionVector))
#define NUM_BYTES_5MV	(sizeof(CMotionVector[5]))
#ifdef _4MV_
#define NUM_BYTES_MV_NOPREDMV	(sizeof(CMotionVector) - sizeof(CVector[5]))
#else
#define NUM_BYTES_MV_NOPREDMV	(sizeof(CMotionVector) - sizeof(CVector))
#endif
#endif //__cplusplus

#if defined (_M_IX86) && defined (__cplusplus)
#pragma warning (disable:4035)
inline Int _cdecl ROUND( float f) {
    __int64 intval;
    _asm {
        fld         f
        fistp       qword ptr [intval]
        mov         eax,dword ptr [intval]
    }
}

inline Int _cdecl ROUND( double f) {
    _asm {
        fld         f
        fistp       qword ptr [f]
        mov         eax,dword ptr [f]
    }
}
#pragma warning (default:4035)
#else
#define ROUND(x) ((x) > 0 ? (Int)(x + 0.5) : (Int)(x - 0.5))
#endif

union Buffer {
    I16 i16[64];
    Int i32[64];
};

#if !defined( NO_WINDOWS ) && defined( _M_IX86 ) && defined (__cplusplus)

#include <windows.h>
class CMyCriticalSection
{
public:
    CMyCriticalSection() {InitializeCriticalSection(&m_cs); m_bInitialized = TRUE;};
    ~CMyCriticalSection() {DeleteCriticalSection(&m_cs);};
    void Lock() {EnterCriticalSection(&m_cs);};
    void Unlock() {LeaveCriticalSection(&m_cs);};
    BOOL CheckInitialization() {return m_bInitialized;}; 
private:
    CRITICAL_SECTION m_cs;
    BOOL m_bInitialized;
};
#endif


//NQF, for Linux, define UNIX, then, undefine UNIX at very end
#ifdef   Linux
#undef  UNIX
#endif  
//NQF  


#endif // __BASIC_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\dectable_mp4x.hpp ===
/*************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

	dectable_mp4x.hpp

Abstract:

	MP4S - MP43 Decoder Huffmane tables 

Author:

	Bruce Lin (blin@microsoft.com) June-1998

Revision History:

*************************************************************************/
#include "xplatform.h"
#include "typedef.hpp"
extern U8_WMV gDecodeCodeTableCBPY[128];
extern U8_WMV gDecodeCodeTableMCBPCintra_New [16];
extern U8_WMV gDecodeCodeTableMCBPCinter_New [256];

extern U8_WMV gDecodeCodeTableMCBPCintra[1024];
extern U8_WMV gDecodeCodeTableMCBPCinter[1024];

extern U8_WMV gDecodeCodeTableIntraDCy[256];
extern U8_WMV gDecodeCodeTableIntraDCc[512];

extern U8_WMV gDecodeCodeTableMV[16384];

extern U8_WMV gDecodeCodeTableIntraDCMPEG4y[4096];
extern U8_WMV gDecodeCodeTableIntraDCMPEG4c[8192];
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\cpudetect.h ===
/*************************************************************************

Copyright (C) 1996 -- 1998  Microsoft Corporation

Module Name:

	CPUDetect.cpp

Abstract:

	Several CPU detection utilities.

Author:

    Joseph Wu (sjwu@microsoft.com)          05/98
    Bruce Line (blin@microsoft.com)         05/98
    Ming-Chieh Lee (mingcl@microsoft.com)   06/98

Revision History:

*************************************************************************/

#ifndef __CPUDETECT_H_
#define __CPUDETECT_H_

#ifdef __cplusplus
extern "C" {
#endif

// HongCho: It's better for these "support" functions to be defined regardless
//          of the platform.  If not supported either because of the architecture
//          or the API, the default return value should be just FALSE.
int g_SupportMMX (void);
int g_SupportSSE1 (void);
int g_SupportSSE2 (void);
int g_SupportMVI (void);
int g_SupportCMOV (void);


#ifdef _M_IX86
int cpuidIsIntelP5 (void); // To detect Intel P5
int g_CPUClock (void);
#endif // _M_IX86

#ifdef _Embedded_x86
int cpuidIsIntelP5 (void); // to detect 486, P5, or P6
#endif

#ifdef macintosh
int g_SupportAltiVec(void);
#endif

#ifdef __cplusplus
}
#endif

#endif // __CPUDETECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\DecTables.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       tables_rc.h
//
//--------------------------------------------------------------------------

#ifndef _DECTABLES_H_
#define _DECTABLES_H_

#ifdef __cplusplus
extern "C" {  // only need to export C interface if
              // used by C++ source code
#endif

#include "macros.h"
#include "constants.h"

#ifdef USE_SIN_COS_TABLES
extern const Int g_SinTableForReconstruction[(2048+1024+512+256+128+64)];
#endif

//for high rates only
extern const U16    g_rgiBarkFreq	[];

extern const U16    g_rgiHuffDecTblMsk[];

extern const U16    g_rgiHuffDecTbl16smOb[];
extern const U16    gRun16smOb[];   //can be a byte
extern const U16    gLevel16smOb[]; //can be a byte

extern const U16    g_rgiHuffDecTbl16ssOb[];
extern const U16    gRun16ssOb[];   //can be a byte
extern const U16    gLevel16ssOb[]; //can be a byte

//For FFT & adaptToSubFrameConfig
typedef struct {
    BP1Type sin_PIby4cSB;		// sin( pi/(4*cSB) ) * nF2BP1 for DCT and inverseTransform
    BP1Type cos_PIby4cSB;		// cos( pi/(4*cSB) ) * nF2BP1 for DCT and inverseTransform
	BP1Type sin_3PIby4cSB;		// sin( 3*pi/(4*cSB) ) * nF2BP1 for DCT
	BP1Type cos_3PIby4cSB;		// cos( 3*pi/(4*cSB) ) * nF2BP1 for DCT
	BP1Type sin_PIbycSB;		// sin( pi/cSB ) * nF2BP1 for DCT
	BP1Type cos_PIbycSB;		// cos( pi/cSB ) * nF2BP1 for DCT
	BP1Type sin_2PIbycSB;		// sin( pi/(cSB/2) ) * nF2BP1 for FFT
	BP1Type cos_2PIbycSB;		// cos( pi/(cSB/2) ) * nF2BP1 for FFT
	BP1Type sin_PIby2cSB;		// sin( pi/(2*cSB) ) * nF2BP1 for inverseTransform
	BP1Type cos_PIby2cSB;		// cos( pi/(2*cSB) ) * nF2BP1 for inverseTransform
	BP1Type two_sin_PIbycSB;	// 2 * sin( pi/cSB ) * nF2BP1 for DCT
#ifdef ENABLE_LPC
    BP2Type sin_4PIbycSB;       // sin( 4*pi/cSB ) * nF2BP2 for LPC
    BP2Type cos_4PIbycSB;       // sin( 4*pi/cSB ) * nF2BP2 for LPC
#endif
}SinCosTable;

#define SINCOSTABLE_ENTRIES 17
extern const SinCosTable * const rgSinCosTables[SINCOSTABLE_ENTRIES];

#if defined(BUILD_INTEGER)
	typedef I32 MaskPowerType;
#	define MASK_POWER_FRAC_BITS 28
#	define MASK_POWER_SCALE (1<<MASK_POWER_FRAC_BITS)
#	define MASK_POWER_FROM_FLOAT(flt) ((MaskPowerType)((flt)*MASK_POWER_SCALE))
#	define FLOAT_FROM_MASK_POWER(typ) ((typ)/((Float)MASK_POWER_SCALE))

	typedef I32 DBPowerType;
#	define DBPOWER_FRAC_BITS QUANTSTEP_FRACT_BITS
#	define DBPOWER_FROM_FLOAT(flt) ((DBPowerType)((flt)*(1<<DBPOWER_FRAC_BITS)))
#	define FLOAT_FROM_DBPOWER(typ) ((typ)*(((Float)1.0)/(1<<DBPOWER_FRAC_BITS)))
#else
	typedef Float MaskPowerType;
#	define MASK_POWER_FRAC_BITS 0
#	define MASK_POWER_SCALE 1
#	define MASK_POWER_FROM_FLOAT(flt) ((MaskPowerType)(flt))
#	define FLOAT_FROM_MASK_POWER(typ) ((Float)(typ))

	typedef Float DBPowerType;
#	define DBPOWER_FROM_FLOAT(flt) ((DBPowerType)(flt))
#	define FLOAT_FROM_DBPower(typ) ((Float)(typ))
#endif

#if defined(SKIMP_ON_ROM)
#	define MASK_MINUS_POWER_TABLE_SIZE 40
#   define MASK_PLUS_POWER_TABLE_SIZE 50
#else
#	define MASK_MINUS_POWER_TABLE_SIZE 72
#   define MASK_PLUS_POWER_TABLE_SIZE 62
#endif
extern const MaskPowerType rgiMaskMinusPower10[MASK_MINUS_POWER_TABLE_SIZE];
extern const MaskPowerType rgiMaskPlusPower10[MASK_PLUS_POWER_TABLE_SIZE];


#define DBPOWER_TABLE_SIZE 128
#define DBPOWER_TABLE_OFFSET 18
extern const DBPowerType rgDBPower10[DBPOWER_TABLE_SIZE];
#ifdef BUILD_INT_FLOAT
extern const Float rgfltDBPowerExponentScale[((DBPOWER_TABLE_OFFSET+DBPOWER_TABLE_SIZE)>>3)+1];
#endif

#ifdef ENABLE_ALL_ENCOPT
//for all other rates
extern const U16    g_rgiHuffDecTbl44smOb[];
extern const U16    gRun44smOb[];   //can be a byte
extern const U16    gLevel44smOb[];

extern const U16    g_rgiHuffDecTbl44ssOb[];
extern const U16    gRun44ssOb[];
extern const U16    gLevel44ssOb[]; //can be a byte

extern const U16    g_rgiHuffDecTbl44smQb[];
extern const U16    gRun44smQb[];
extern const U16    gLevel44smQb[];  //can be a byte

extern const U16    g_rgiHuffDecTbl44ssQb[];
extern const U16    gRun44ssQb[];
extern const U16    gLevel44ssQb[];  //can be a byte

extern const U16    g_rgiHuffDecTblNoisePower[];

extern const float  g_rgfltLsfReconLevel [LPCORDER] [16];

#if defined(BUILD_INTEGER)

#   define INVQUADROOT_FRACTION_TABLE_LOG2_SIZE 8
#   define INVQUADROOT_FRACTION_TABLE_SIZE (1<<INVQUADROOT_FRACTION_TABLE_LOG2_SIZE)

    extern const UInt g_InvQuadRootFraction[1+INVQUADROOT_FRACTION_TABLE_SIZE];
    extern const UInt g_InvQuadRootExponent[BITS_LP_SPEC_POWER+1];

#   define INVERSE_FRACTION_TABLE_LOG2_SIZE 8
#   define INVERSE_FRACTION_TABLE_SIZE (1<<INVERSE_FRACTION_TABLE_LOG2_SIZE)
    extern const UInt g_InverseFraction[1+INVERSE_FRACTION_TABLE_SIZE];

#   define SQRT_FRACTION_TABLE_LOG2_SIZE 8
#   define SQRT_FRACTION_TABLE_SIZE (1<<SQRT_FRACTION_TABLE_LOG2_SIZE)
    extern const UInt g_SqrtFraction[1+SQRT_FRACTION_TABLE_SIZE];

#endif

#endif // ENABLE_ALL_ENCOPT

#define PWRTORMS_ZEROPT     60
#define PWRTORMS_SIZE       (PWRTORMS_ZEROPT*2 + 1)
extern const UInt           g_rgfiPwrToRMS[];

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\huffman_wmv.hpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       huffman.hpp
//
//--------------------------------------------------------------------------

/*  -*-c++-*-
 *  Sanjeev Mehrotra
 *  6/19/1998
 *  Chuang Gu
 *  2/1/2000
 */
#ifndef _HUFFMAN_H
#define _HUFFMAN_H
#include "typedef.hpp"
//extern U32_WMV getMask [33];
#define BITSTREAM_READ 1
//class CInputBitStream_WMV;
typedef enum tagVResultCode
{
  vrNoError        = 0,
  vrFail           = 1,
  vrNotFound       = 2,
  vrExists         = 3,
  vrEof            = 4,
  vrOutOfMemory    = 5,
  vrOutOfResource  = 6,
  vrOutOfBounds    = 7,
  vrBadParam       = 8,
  vrBadInput       = 9,
  vrIOError        = 10,
  vrInterrupted    = 11,
  vrNotSupported   = 12,
  vrNotImplemented = 13,
  vrDropped        = 14,
  vr_ENDOFALLERRORS
} VResultCode;

class VResult
{
private:
  VResultCode m_vrCode;

public:
  VResult() : m_vrCode(vrFail) {}
  VResult(VResultCode vrCode) : m_vrCode(vrCode) {}
  operator VResultCode() { return m_vrCode; }
#if !defined(_Embedded_x86) || defined(_XBOX)
  Bool_WMV failed() { return m_vrCode != vrNoError; }
#else
  Bool_WMV failed(void);   
#endif
  char* explanation();
};

#define MAX_STAGES 3

#if !defined(UNDER_CE) && !defined(MIMIC_CE_ON_DESKTOP)
    // define stages assuming large memory and cache
#   define BITS_STAGE1 10
#   define BITS_STAGE2 11
#else
    // define stages assuming small memory and cache
#   define BITS_STAGE1 6
#   define BITS_STAGE2 15
#endif

// Mode            Entry Size   Max # Symbols   Max codeword length
// ----------------------------------------------------------------
// LARGE_HUFFMAN    8 bytes         Large             32 bits
// MED_HUFFMAN      4 bytes         65536             32 bits
// SMALL_HUFFMAN    2 bytes          4096             32 bits

//#define LARGE_HUFFMAN
#ifndef LARGE_HUFFMAN
#define SMALL_HUFFMAN
#endif

#if defined(OPT_HUFFMAN_GET_WMV) 
  typedef struct _HuffDecInfo {

#   if (defined(UNDER_CE) && 1) || (defined(MIMIC_CE_ON_DESKTOP) && 1)
        // The largest symbol is 1099 because we put indexes, not the real symbol in these tables
        // By using three stages, we 
#       define HUFFDEC_SYMBOL_BITS 12
#       define HUFFDEC_LENGTH_BITS 4
        U16_WMV symbol : HUFFDEC_SYMBOL_BITS;
        U16_WMV length : HUFFDEC_LENGTH_BITS;
#   else
        // The following comment does not seem to be true any longer
            //MIPS implementation rely on the specific offsets of these structs. so DON'T CHANGE THEM. 
            // - weidongz Nov.3, 2000
#       define HUFFDEC_SYMBOL_BITS 31
#       define HUFFDEC_LENGTH_BITS 31
        U32_WMV symbol;
        U32_WMV length;
#   endif
  } HuffDecInfo;

  typedef struct _TableInfo {
    I32_WMV bits;
    HuffDecInfo *table;
  } TableInfo;

#else
  typedef struct _HuffDecInfo {
#     define HUFFDEC_SYMBOL_BITS 12
#     define HUFFDEC_LENGTH_BITS 4
      U16_WMV symbol : 12;
      U16_WMV length : 4;
  } HuffDecInfo;

  typedef struct _TableInfo {
    I32_WMV bits;
    HuffDecInfo *table;
  } TableInfo;

#endif

typedef struct _TableInitInfo {
  I32_WMV prefix;     // the prefix that got you there
  I32_WMV start, end; // start, end tableNums of children tables
  I32_WMV bits;       // the bits for this table
  I32_WMV maxBits;    // the maximum # of bits of things entering this table
} TableInitInfo;



//class CVideoObjectDecoder ;
//class CDCTTableInfo_Dec;
typedef struct _Huffman_WMV 
{


//  static U32_WMV m_mask[33]; // 32 bit dependency

  // It is critical that encTable be 32 bits and decTable be 16 bits for 
  // the given huffman routines to work
    U32_WMV m_uiUserData;
    I32_WMV m_alphabetSize;
    I32_WMV m_maxCodeLength;
    I32_WMV m_numDecEntries, m_allocDecEntries;
    I32_WMV m_allocTables;
    tPackHuffmanCode_WMV *m_encInfo; 
  //HuffEncInfo   *m_encInfo;

#if defined( OPT_HUFFMAN_GET_WMV)
  // it is critical for the mips implementation to work that the order and 
  // the types of these members are exactly as shown here.
  // -weidongz Nov.9.2000
  union
  {
    HuffDecInfo   *m_decInfo;
	int OPT_HUFFMAN_GET_Hbase;
  };
  TableInfo     *m_tableInfo;
#else
  HuffDecInfo   *m_decInfo;
  TableInfo     *m_tableInfo;
#endif

  TableInitInfo *m_initInfo;

}Huffman_WMV;

//-----------------------------------------------------------------------------
// Inline definitions
/*
inline I32_WMV Huffman::length(I32_WMV inpSym) {
#ifndef PROFILE
  Assert(inpSym >= 0 && inpSym < m_alphabetSize);
#endif
  return (I32_WMV)m_encInfo[inpSym].length;
}
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\dectable_c.h ===
//  tables for decoding.
     extern U8_WMV sm_rgRunAtIndx_HghMt [168];
     extern I8_WMV sm_rgLevelAtIndx_HghMt [168];
     extern U8_WMV sm_rgRunAtIndxOfIntraY_HghMt [185];
     extern I8_WMV sm_rgLevelAtIndxOfIntraY_HghMt [185];

     extern U8_WMV sm_rgRunAtIndx_Talking [148];
     extern I8_WMV sm_rgLevelAtIndx_Talking [148];
     extern U8_WMV sm_rgRunAtIndxOfIntraY_Talking [132];
     extern I8_WMV sm_rgLevelAtIndxOfIntraY_Talking [132];
     extern tPackHuffmanCode_WMV sm_HufMVTable_Talking [1101];
     extern U8_WMV sm_uXMvFromIndex_Talking [1099];
     extern U8_WMV sm_uYMvFromIndex_Talking [1099];
     extern tPackHuffmanCode_WMV sm_HufMVTable_HghMt [1101];
     extern U8_WMV sm_uXMvFromIndex_HghMt [1099];
     extern U8_WMV sm_uYMvFromIndex_HghMt [1099];
    // Header
     extern tPackHuffmanCode_WMV sm_HufPCBPCYTable [129];
     extern tPackHuffmanCode_WMV sm_HufICBPCYTable [65];
    
    //#ifdef NEW_PCBPCY_TABLE
     extern tPackHuffmanCode_WMV sm_HufPCBPCYTable_HighRate [129];
     extern tPackHuffmanCode_WMV sm_HufPCBPCYTable_MidRate [129];
     extern tPackHuffmanCode_WMV sm_HufPCBPCYTable_LowRate [129];
    //#endif
    
    //_DCTDC
     extern tPackHuffmanCode_WMV sm_HufDCTDCyTable_Talking[121];
     extern tPackHuffmanCode_WMV sm_HufDCTDCcTable_Talking[121];
     extern tPackHuffmanCode_WMV sm_HufDCTDCyTable_HghMt[121];
     extern tPackHuffmanCode_WMV sm_HufDCTDCcTable_HghMt[121];
     extern tPackHuffmanCode_WMV sm_HufDCTACInterTable_HghMt[170];
     extern tPackHuffmanCode_WMV sm_HufDCTACIntraTable_HghMt[187];
     extern tPackHuffmanCode_WMV sm_HufDCTACInterTable_Talking[150];
     extern tPackHuffmanCode_WMV sm_HufDCTACIntraTable_Talking[134];
     extern tPackHuffmanCode_WMV sm_HufDCTACInterTable_MPEG4 [104];
     extern tPackHuffmanCode_WMV sm_HufDCTACIntraTable_MPEG4 [104];
     extern U8_WMV sm_rgRunAtIndx_MPEG4 [102];
     extern I8_WMV sm_rgLevelAtIndx_MPEG4 [102];
     extern U8_WMV sm_rgRunAtIndxOfIntraY_MPEG4 [102];
     extern I8_WMV sm_rgLevelAtIndxOfIntraY_MPEG4 [102];

     // ---------------------------------------------------

    extern HuffDecInfo m_hufMVDec_TalkingDecInfo[1806]; 
    extern TableInfo   m_hufMVDec_TalkingTableInfo[90];

    extern HuffDecInfo m_hufMVDec_HghMtDecInfo[1894]; 
    extern TableInfo   m_hufMVDec_HghMtTableInfo[151];
    
    extern HuffDecInfo m_hufICBPCYDecDecInfo[162]; 
    extern TableInfo   m_hufICBPCYDecTableInfo[15];
    
    extern HuffDecInfo m_hufICBPCYDecDecInfo[162]; 
    extern TableInfo   m_hufICBPCYDecTableInfo[15];
    
    extern HuffDecInfo m_hufPCBPCYDecDecInfo[756]; 
    extern TableInfo   m_hufPCBPCYDecTableInfo[13];
    
    extern HuffDecInfo m_hufPCBPCYDec_HighRateDecInfo[1112];
    extern TableInfo   m_hufPCBPCYDec_HighRateTableInfo[19];
    
    extern HuffDecInfo m_hufPCBPCYDec_MidRateDecInfo[650];
    extern TableInfo   m_hufPCBPCYDec_MidRateTableInfo[17];
    
    extern HuffDecInfo m_hufPCBPCYDec_LowRateDecInfo[408];
    extern TableInfo   m_hufPCBPCYDec_LowRateTableInfo[21];
    
    extern HuffDecInfo m_hufDCTDCyDec_TalkingDecInfo[838]; 
    extern TableInfo   m_hufDCTDCyDec_TalkingTableInfo[6];
    
    extern HuffDecInfo m_hufDCTDCcDec_TalkingDecInfo[668]; 
    extern TableInfo   m_hufDCTDCcDec_TalkingTableInfo[7];
    
    extern HuffDecInfo m_hufDCTDCyDec_HghMtDecInfo[1476]; 
    extern TableInfo   m_hufDCTDCyDec_HghMtTableInfo[7];
    
    extern HuffDecInfo m_hufDCTDCcDec_HghMtDecInfo[1088]; 
    extern TableInfo   m_hufDCTDCcDec_HghMtTableInfo[5];
    
    extern HuffDecInfo m_hufDCTACInterDec_HghMtDecInfo[464]; 
    extern TableInfo   m_hufDCTACInterDec_HghMtTableInfo[30];
    
    extern HuffDecInfo m_hufDCTACIntraDec_HghMtDecInfo[504]; 
    extern TableInfo   m_hufDCTACIntraDec_HghMtTableInfo[42];
    
    extern HuffDecInfo m_hufDCTACInterDec_TalkingDecInfo[404]; 
    extern TableInfo   m_hufDCTACInterDec_TalkingTableInfo[32];
    
    extern HuffDecInfo m_hufDCTACIntraDec_TalkingDecInfo[286];
    extern TableInfo   m_hufDCTACIntraDec_TalkingTableInfo[28];
    
    extern HuffDecInfo m_hufDCTACInterDec_MPEG4DecInfo[144]; 
    extern TableInfo   m_hufDCTACInterDec_MPEG4TableInfo[18];
    
    extern HuffDecInfo m_hufDCTACIntraDec_MPEG4DecInfo[144]; 
    extern TableInfo   m_hufDCTACIntraDec_MPEG4TableInfo[18];
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\intelFFT.h ===
#ifndef __INTELFFT_H_
#define __INTELFFT_H_

//***************************************************************************
// Data Types
//***************************************************************************
typedef enum {INTELFFT_INIT_PROCESS, INTELFFT_INIT_THREAD,
    INTELFFT_FREE_THREAD, INTELFFT_FREE_PROCESS} INTELFFT_INITCODE;

//***************************************************************************
// Function Declarations
//***************************************************************************
int MyInitNSP(int fdwReason); // Actually returning a BOOL

void auSetMinMaxFrameSize(const int iMinFrameSizeLOG,
                          const int iMaxFrameSizeLOG);

#endif  // __INTELFFT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\idctdec_wmv2.h ===
/*************************************************************************

Copyright (C) 1996 -- 1998  Microsoft Corporation

Module Name:

	idctdec_wmv2.h

Abstract:

	Inverse DCT routines used by WMV2 decoder

Author:

	Marc Holder (marchold@microsoft.com)    05/98
    Bruce Lin (blin@microsoft.com)          06/98
    Ming-Chieh Lee (mingcl@microsoft.com)   06/98

Revision History:

*************************************************************************/

#ifndef __IDCTDEC_WMV2_H_
#define __IDCTDEC_WMV2_H_

#include "wmvdec_api.h"

///////////////////////////////////////////////////////////////////////////
//
// Intra IDCT Functions
//
///////////////////////////////////////////////////////////////////////////
#ifndef OPT_IDCT_ARM
Void_WMV g_IDCTDec_WMV2 (PixelC __huge* piDst, I32_WMV  iOffsetToNextRowForDCT, const PixelI32 __huge* rgiCoefRecon);
#else
extern "C" Void_WMV g_IDCTDec_WMV2 (PixelC __huge* piDst, I32_WMV  iOffsetToNextRowForDCT, const PixelI32 __huge* rgiCoefRecon);
#endif

#ifdef _WMV_TARGET_X86_
Void_WMV g_IDCTDecMMX_WMV2 (PixelC __huge* piDst, I32_WMV  iOffsetToNextRowForDCT, const PixelI32 __huge* rgiCoefRecon);
Void_WMV g_IDCTDecP5_WMV2 (PixelC __huge* piDst, I32_WMV  iOffsetToNextRowForDCT, const PixelI32 __huge* rgiCoefRecon);
#endif //_WMV_TARGET_X86_

///////////////////////////////////////////////////////////////////////////
//
// Inter IDCT Functions
//
///////////////////////////////////////////////////////////////////////////

#ifndef OPT_IDCT_ARM
Void_WMV g_IDCTDec16_WMV2 (Buffer __huge* piDst, Buffer __huge* piSrc, I32_WMV  iOffsetToNextRowForDCT, I32_WMV  iDCTHorzFlags);
#else
extern "C" Void_WMV g_IDCTDec16_WMV2 (Buffer __huge* piDst, Buffer __huge* piSrc, I32_WMV  iOffsetToNextRowForDCT, I32_WMV  iDCTHorzFlags);
#endif

#ifndef _EMB_WMV2_
Void_WMV g_IDCTDec_WMV2 (Buffer __huge* piDst, Buffer __huge* piSrc, I32_WMV  iOffsetToNextRowForDCT, I32_WMV  iDCTHorzFlags);
Void_WMV g_8x4IDCTDec_WMV2 (Buffer __huge* piDstBuf, I32_WMV  iOffsetToNextRowForDCT, const Buffer __huge* rgiCoefReconBuf, I32_WMV  iHalf);
Void_WMV g_4x8IDCTDec_WMV2 (Buffer __huge* piDstBuf, I32_WMV  iOffsetToNextRowForDCT, const Buffer __huge* rgiCoefReconBuf, I32_WMV  iHalf);
Void_WMV g_4x4IDCTDec_WMV2 (Buffer __huge* piDstBuf, I32_WMV  iOffsetToNextRowForDCT, const Buffer __huge* rgiCoefReconBuf, I32_WMV  iQuadrant);
#endif //_EMB_WMV2_

Void_WMV g_4x4IDCTDecMMX_WMV2 (Buffer __huge* piDstBuf, I32_WMV  iOffsetToNextRowForDCT, const Buffer __huge* rgiCoefReconBuf, I32_WMV  iQuadrant);
#ifdef _WMV_TARGET_X86_
Void_WMV g_IDCTDecMMX_WMV2 (Buffer __huge* piDst, Buffer __huge* piSrc, I32_WMV  iOffsetToNextRowForDCT, I32_WMV  iDCTHorzFlags);
Void_WMV g_IDCTDecP5_WMV2 (Buffer __huge* piDst, Buffer __huge* piSrc, I32_WMV  iOffsetToNextRowForDCT, I32_WMV  iDCTHorzFlags);
#endif //_WMV_TARGET_X86_

#if defined(_WMV_TARGET_X86_) || defined(_Embedded_x86)
Void_WMV g_8x4IDCTDecMMX_WMV2 (Buffer __huge* piDstBuf, I32_WMV  iOffsetToNextRowForDCT, const Buffer __huge* rgiCoefReconBuf, I32_WMV  iHalf);
Void_WMV g_4x8IDCTDecMMX_WMV2 (Buffer __huge* piDstBuf, I32_WMV  iOffsetToNextRowForDCT, const Buffer __huge* rgiCoefReconBuf, I32_WMV  iHalf);
#endif //_WMV_TARGET_X86_

Void_WMV g_InitIDCTTablesDec (); 

#endif // __IDCTDEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\localhuffman_wmv.h ===
//#define ALT_TRAIN
/*************************************************************************

Copyright (c) 1996 -- 2000  Microsoft Corporation

Module Name:

	localHuffman.h

Abstract:

	Local Huffman code generator.

Revision History:

    Sridhar Srinivasan: 3/16/00

*************************************************************************/

#include "xplatform.h"
#include "typedef.hpp"
#include "codehead.h"

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>

#include "strmdec_wmv.hpp"
#include "huffman_wmv.hpp"

/********************************************************************
  end of definition of CLocalHuffman
********************************************************************/

enum { LH_INTER0, LH_INTER, LH_INTRAY0, LH_INTRAY,
// IntraUV uses Inter tables
       LH_ORIENT, LH_INTRAZ, LH_INTRANZ, LH_INTRAC0, LH_INTRAC1 };
// New Intra coding

enum { QP_AT_8BIT_LEVEL = 5 };

enum { L0a=46, L0b, L0c, L0d, L0e, L0f,  L0z, L0y, L0x, L0w, L0v,  L0u, L0t,
/*59*/ L1a, L1b, L1c, L1d, L1e, L1f,  L1g, L1h, L1i,  L1z, L1y, L1x, L1w, L1v,
/*73*/ Q0, Q1, X0, X1 };

static const I32_WMV SIGNSHIFT=16; // right shift leaves only info regarding sign
// low QP encoding (static works best)

static const I32_WMV iModeArray[]={ LH_INTER0, LH_INTRAY0, LH_INTER0,
    LH_INTRAY, LH_INTER /*experimental*/ };

/**********************************************************************
 CAltTablesDecoder : definition
**********************************************************************/
struct t_LocalHuffmanDecoder;

typedef struct t_AltTablesDecoder
{
    U32_WMV    m_uiUserData;
    I32_WMV    m_iNewFrame;
    I32_WMV    m_iNewIntraFrame;
    t_LocalHuffmanDecoder   *m_paLH[LH_INTRAC1+1];
    Bool_WMV   m_bIntraFrame;
    I32_WMV    m_iNContexts;

    I32_WMV    m_iQLev;
    Bool_WMV   m_bIsFirstRun;
} t_CAltTablesDecoder;

t_AltTablesDecoder *t_AltTablesDecoderConstruct (U32_WMV uiUserData);
Void_WMV    t_AltTablesDecoderDestruct (t_AltTablesDecoder *pAltTab);
Void_WMV    t_AltTablesSetNewFrame (t_AltTablesDecoder *pAltTab,
                                    I32_WMV, I32_WMV);

/**********************************************************************
 Static variables
**********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\lowrate_common.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    lowrate_common.h

Abstract:

    Macros from lowrate_common.c, placed here so that the macros may be
    used by encoder-only parts of the code.

Author:

    Raymond Cheng (raych)       Jan 18, 2001

*************************************************************************/

#ifndef __LOWRATE_COMMON_H
#define __LOWRATE_COMMON_H


//***************************************************************************
// Encoder/Decoder Separation
//***************************************************************************

// From lowrate_common.c

#ifdef ENABLE_ALL_ENCOPT
//******************************************************************************************
// Support routines for Resampling indexes to those used when the MaskQ's were last updated
//******************************************************************************************
#define MASKQ_RESAMPLE_OFFSET 6
typedef struct MaskResampleInfo
{
	Int iMaskResampleRatio;
	Int iMaskResampleRatioPow;
	Int cValidBarkBandLatestUpdate;
} MaskResampleInfo;


#ifdef HITACHI
#pragma inline(iResampleIndex)
static Int iResampleIndex( Int iRecon, const MaskResampleInfo MRI )
#else
static INLINE Int iResampleIndex( Int iRecon, const MaskResampleInfo MRI )
#endif
{	// return resampled linear index suitable for frame that was last updated with MaskQ
	// equvilent to iRecon shifted left or right by (MRI.iMaskResampleRatioPow-MASKQ_RESAMPLE_OFFSET)
	return ( (((iRecon) << MRI.iMaskResampleRatioPow) >> MASKQ_RESAMPLE_OFFSET) );
}

#ifdef HITACHI
#pragma inline(iUnResampleIndex)
static Int iUnResampleIndex( Int iResampled, const MaskResampleInfo MRI )
#else
static INLINE Int iUnResampleIndex( Int iResampled, const MaskResampleInfo MRI )
#endif
{	// return the reverse of iResampleIndex()
	// that is, convert from resampled indexes of MaskQ or WeightFactor to natural index for the current frame
    if (MRI.iMaskResampleRatioPow > MASKQ_RESAMPLE_OFFSET){
		// Rounding for down shift 
		// Although V4 did not round when resampling, this inverse funtion needs to round ???
        return (iResampled + (1<<(MRI.iMaskResampleRatioPow-(MASKQ_RESAMPLE_OFFSET+1)))) >> (MRI.iMaskResampleRatioPow-MASKQ_RESAMPLE_OFFSET);
        // return iResampled >> (MRI.iMaskResampleRatioPow-MASKQ_RESAMPLE_OFFSET);
    } else {
        return iResampled << (MASKQ_RESAMPLE_OFFSET-MRI.iMaskResampleRatioPow);
    }
}


//*****************************************************************************************
// Look up (10^(1/16)) ^ iMaskQ
//*****************************************************************************************
#ifdef HITACHI
#pragma inline(ffltMaskPower10)
static FastFloat ffltMaskPower10( Int iMaskQ )
#else
static INLINE FastFloat ffltMaskPower10( Int iMaskQ )
#endif
{	// (10^(1/16)) ^ iMaskQ
	FastFloat fflt;

    // There is, unfortunately, no easy way to keep this assert with our new
    // combined decoder/encoder build.
//#if !defined (ENCODER)
//  assert( -MASK_MINUS_POWER_TABLE_SIZE < iMaskQ && iMaskQ <= MASK_PLUS_POWER_TABLE_SIZE );
//#endif

    if ( iMaskQ <= 0 )
	{
		if (iMaskQ < -MASK_MINUS_POWER_TABLE_SIZE)
			iMaskQ = -(MASK_MINUS_POWER_TABLE_SIZE-1);
#if defined(BUILD_INTEGER)
		fflt.iFraction = rgiMaskMinusPower10[ -iMaskQ ];	// with MASK_POWER_FRAC_BITS==28 fractional bits
		fflt.iFracBits = MASK_POWER_FRAC_BITS+(-iMaskQ>>2);
#else
		fflt = rgiMaskMinusPower10[ -iMaskQ ] / (Float)(1<<(-iMaskQ>>2));
#endif
	}
	else
	{
		if (iMaskQ >= MASK_PLUS_POWER_TABLE_SIZE)
			iMaskQ = MASK_PLUS_POWER_TABLE_SIZE;
#if defined(BUILD_INTEGER)
		fflt.iFraction = rgiMaskPlusPower10[ iMaskQ-1 ];	// with MASK_POWER_FRAC_BITS==28 fractional bits
		fflt.iFracBits = MASK_POWER_FRAC_BITS-(iMaskQ>>2);
#else
		fflt = rgiMaskPlusPower10[ iMaskQ-1 ] * (Float)(1<<(iMaskQ>>2));
#endif
	}
	return fflt;
}
#endif  // ENABLE_ALL_ENCOPT


//******************************************************************************************
//******************************************************************************************
#if defined(_DEBUG) && defined(INVERSE_QUANTIZE_AT_FRAME)
// these help match where we are with V4 which does not have a m_iFrameCount
#	define DEBUG_BREAK_AT_FRAME_INV_QUANT										\
		{ 																		\
			if ( pau->m_iCurrSubFrame == 0 && ppcinfo == pau->m_rgpcinfo )		\
			{	iInvQuantFrameCount++;	iInvQuantSubFrameCount = 0; }			\
			else if ( ppcinfo == pau->m_rgpcinfo ) iInvQuantSubFrameCount++;	\
			if ( iInvQuantFrameCount==INVERSE_QUANTIZE_AT_FRAME )				\
				DEBUG_BREAK();													\
		}
#elif defined(_DEBUG) && ( defined(PRINT_INVERSE_QUANTIZE_AT_FRAME) || defined(PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST) )
// these help match where we are with V4 which does not have a m_iFrameCount
#	define DEBUG_BREAK_AT_FRAME_INV_QUANT										\
		{ 																		\
			if ( pau->m_iCurrSubFrame == 0 && ppcinfo == pau->m_rgpcinfo )		\
			{	iInvQuantFrameCount++;	iInvQuantSubFrameCount = 0; }			\
			else if ( ppcinfo == pau->m_rgpcinfo ) iInvQuantSubFrameCount++;	\
		}
#else	// defined(_DEBUG) && defined(PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST) 
#	define DEBUG_BREAK_AT_FRAME_INV_QUANT
#endif	// ...


//******************************************************************************************
//******************************************************************************************
// prvScanForNextBarkIndex scans for the next resampled bark index and then returns its unresampled linear index
//   iRecon and iHighLimit are linear indexes in the current frames natural scale.
//   iBarkResampled is the bark index in the resampled bark scale (appropriate for the frame when the MaskQ's were last updated)
//   rgiBarkIndex is the resampled bark index scale from that last updated MaskQ subframe
#ifdef HITACHI
#pragma inline(prvScanForNextBarkIndex)
static Int prvScanForNextBarkIndex( const Int iRecon, Int* piBarkResampled, const int iHighLimit, 
										  const Int* const rgiBarkIndexResampled, const MaskResampleInfo MRI )
#else
static INLINE Int prvScanForNextBarkIndex( const Int iRecon, Int* piBarkResampled, const int iHighLimit, 
										  const Int* const rgiBarkIndexResampled, const MaskResampleInfo MRI )
#endif
{   //Scan for the next resampled bark index
	Int iNextBarkIndex, iBarkResampled, iReconResampled;
	iReconResampled = iResampleIndex(iRecon, MRI);
    while ( iReconResampled >= rgiBarkIndexResampled [*piBarkResampled+1]) 
		++(*piBarkResampled);
	iBarkResampled = *piBarkResampled;
	if ( iBarkResampled >= MRI.cValidBarkBandLatestUpdate )
	{
		assert( iBarkResampled < MRI.cValidBarkBandLatestUpdate );
		return( MRI.cValidBarkBandLatestUpdate );
	}
	iNextBarkIndex = iUnResampleIndex( rgiBarkIndexResampled [iBarkResampled + 1], MRI );
    if (iNextBarkIndex > iHighLimit) 
		iNextBarkIndex = iHighLimit;
	return iNextBarkIndex;
}


//******************************************************************************************
//******************************************************************************************
#if defined(BUILD_INTEGER)
// SCALE_COEF_RECON shifts CoefRecon to give it TRANSFORM_FRACT_BITS==5 fractional bits
#if defined(PLATFORM_OPTIMIZE_MINIMIZE_BRANCHING)
	// This SCALE_COEF_RECON macro requires 6 ops and no branches
	// This SETUP_FOR_SCALE_COEF_RECON requires 5 ops plus 1 branch.
	// SCALE_COEFFICENT gets executed 25x as often as SETUP_FOR_SCALE_COEF_RECON, 
	// so this method requires 6.2 ops plus 0.04 branches per SCALE_COEFFICENT
#	define SCALE_COEF_RECON(iCR) ((((iCR)>>-iShift) & iMask2) | (((iCR)<<iShift) & iMask1))
//#	define SETUP_FOR_SCALE_COEF_RECON(iFB) iShift = iFB-TRANSFORM_FRACT_BITS;  \
//								      iMask2 = 0xFFFFFFFF ^ (iMask1 = (iShift>=0) ? 0xFFFFFFFF : 0)
// See comment below
#	define SETUP_FOR_SCALE_COEF_RECON(fftQ) iShift = fftQ.iFracBits-TRANSFORM_FRACT_BITS;  \
								      iMask2 = 0xFFFFFFFF ^ (iMask1 = (iShift>=0) ? 0xFFFFFFFF : 0)

#else   // PLATFORM_OPTIMIZE_MINIMIZE_BRANCHING
	// When branching is not a high penaty activity, do it the simplier way
	//   iCoefRecon = (t=iFracBits-5)<0 ? iCoefRecon>>-t : iCoefRecon<<t
	// This SCALE_COEF_RECON requires 3 ops plus 1 branch or 2 ops plus 1 branch.  
	// This SETUP_FOR_SCALE_COEF_RECON requires 2 ops
	// SCALE_COEFFICENT gets executed 25x as often as SETUP_FOR_SCALE_COEF_RECON, 
	// so this method requires 2.58 ops plus 0.04 branches per SCALE_COEFFICENT
	// On one test on a 500 MHz Pentium 686, this way saves 1% execution time over masking.
#	define SCALE_COEF_RECON(iCR) (iShift<0) ? (iCR)<<-iShift : (iCR)>>iShift
//#	define SETUP_FOR_SCALE_COEF_RECON(iFB) iShift=iFB-TRANSFORM_FRACT_BITS
// This more complex setup (with pre-normalization) is required to deal with 56_WMAv2.wma which ends
// with 1.5 seconds of DC bias at -890.  This results in a single large coef at 0 and the rest 0.
// Then in the noise band, iShift tries to be == 33...
#	define SETUP_FOR_SCALE_COEF_RECON(fftQ) \
    while( fftQ.iFracBits > (30+TRANSFORM_FRACT_BITS) ) { fftQ.iFracBits--; fftQ.iFraction>>=1; } \
    iShift=fftQ.iFracBits-TRANSFORM_FRACT_BITS;
#endif  // PLATFORM_OPTIMIZE_MINIMIZE_BRANCHING

#define UNNORMED_MULT(fflt,c,shift) \
	fflt.iFraction = MULT_HI( fflt.iFraction, c );	\
	fflt.iFracBits += shift;

static const I32 cDitherFactorMR = 0x28F5C28F;		// BARK 0.02 * 2^35 (but I am not sure how to derive the 35)

#else   // defined(BUILD_INTEGER)

#define SCALE_COEF_RECON(iCR) (iCR)
#define SETUP_FOR_SCALE_COEF_RECON(ffltQ)
#define UNNORMED_MULT(flt,c,shift) flt *= c
static const Float cDitherFactorMR = 0.02F;		            // BARK_MODE: 0.02
/* // IW
#ifdef_XBOX  
static const Float cDitherFactorMR = 0.02F;		            // BARK_MODE: 0.02
#else
extern const Float cDitherFactorMR;
#endif
*/

#endif  // defined(BUILD_INTEGER)


#endif  // __LOWRATE_COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\nsp.h ===
/*M*
//
//               INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//        Copyright (c) 1995 Intel Corporation. All Rights Reserved.
//
//      $Workfile: nsp.h $
//      $Revision: 4 $
//      $Modtime: 9/11/99 4:16p $
//
//  Purpose: NSP Common Header file
*M*/

#if !defined (_NSP_H)
#if defined (__BORLANDC__)
#include "nsppatch.h"
#endif

#define _NSP_H

#include "nspwarn.h"

/* ======================================================================== */



/* ---------------------------- Definitions ------------------------------- */

#if !defined (_OWN_BLDPCS)

#define  NSP_EPS   (1.0E-12)
#define  NSP_PI    (3.14159265358979324)     /* Standard C not support M_PI */
#define  NSP_2PI   (6.28318530717958648)
#define  NSP_PI_2  (1.57079632679489662)
#define  NSP_PI_4  (0.785398163397448310)

#define  NSP_DegToRad(deg)  ((deg)/180.0 * NSP_PI)

#define  NSPsDegToRad(deg)  ((float) ((deg)/180.0 * NSP_PI))
#define  NSPdDegToRad(deg)  ((double)((deg)/180.0 * NSP_PI))

#define  MAX(a,b)  (((a) > (b)) ? (a) : (b))
#define  MIN(a,b)  (((a) < (b)) ? (a) : (b))

#if !defined (FALSE)
#define  FALSE  0
#define  TRUE   1
#endif


/* --------------------------- Common Types ------------------------------- */

  typedef int    NSPStatus;


  typedef struct _SCplx {
    float        re;
    float        im;
  } SCplx;

  typedef struct _DCplx {
    double        re;
    double        im;
  } DCplx;

  typedef struct _WCplx {
    short         re;
    short         im;
  } WCplx;

  typedef struct _ICplx {
    int         re;
    int         im;
  } ICplx;

static const SCplx  SCplxZero = {0,0};
static const DCplx  DCplxZero = {(double)0.0,(double)0.0};
static const WCplx  WCplxZero = {(short) 0,  (short) 0};
static const ICplx  ICplxZero = {(int)0,(int)0};

static const SCplx SCplxOneZero = {1,0};
static const DCplx DCplxOneZero = {(double)1.0,(double)0.0};
static const WCplx WCplxOneOne  = {(short) 1,  (short) 1};
static const ICplx ICplxOneOne  = {(int)1,(int)1};
static const SCplx SCplxOneOne  = {(float) 1.0,(float) 1.0};
static const DCplx DCplxOneOne  = {(double)1.0,(double)1.0};


/* ======================================================================== */

#endif                                                            /* _NSP_H */
#endif                                                            /* PCS    */

#ifdef __cplusplus
extern "C" {
#endif

#if defined( _WIN32 ) && !defined( __GNUC__ )
#define __STDCALL __stdcall
#define __CDECL __cdecl
#define __INT64 __int64
#else
#define __STDCALL
#define __CDECL
#define __INT64 long long 
#endif


#if !defined (NSPAPI)
# if !defined(NSP_W32DLL)
#  define NSPAPI(type,name,arg) extern    type __STDCALL name arg;
# elif defined (__BORLANDC__)
#  define NSPAPI(type,name,arg) extern  type _import __STDCALL name arg;
# else
#   if defined (_WIN32)
#      define NSPAPI(type,name,arg) extern  __declspec(dllimport) type __STDCALL name arg;
#   elif defined (linux)
#      define NSPAPI(type,name,arg) extern type name arg;
#   endif
# endif
#endif

/* ---------------------- NSP Library Control Symbols -----------------------

nsp_UsesVector:     vector/scalar Zero,Set,Copy,Add,Sub,Mpy,Div,Conj
                    b<,Inv>Tresh<1,2>,bAbs<1,2>,bAdd<2,3>,bExp<1,2>,bLn<1,2>,
                    bMpy<2,3>, bSqr<1,2>, bSqrt<1,2>, Max, Maxext, Min, Minext
                    Mean, StDev
                    Dotprod, Dotprodext,
                    bConj<,Extend><1,2>, bConjFlip2
                    b<Mu,A>LawToLin, bLinTo<Mu,A>Law
                    AutoCorr<Biased,Unbiased>, CrossCorr,
                    Norm, Normext, Normalize, bDiv<1,2,3>
                    <Up,Down>Sample,bArctan<1,2>

nsp_UsesConversion: bImag, bReal, bCplxTo2Real, b2RealToCplx,
                    b<,r>Mag, b<,rPhase>,
                    bFloatTo<Int,Fix,S31Fix,S15Fix,S7Fix,S1516Fix>,
                    b<Int,Fix,S31Fix,S15Fix,S7Fix,S1516Fix>ToFloat,
                    b<,r>CartToPolar, b<,r>PolarToCart

nsp_UsesConvolution:Conv
                    Conv2D
                    Filter2D

nsp_UsesDct:        Dct

nsp_UsesTransform:  Dft
                    Fft<,Nip>, <Real,Ccs>Fftl<,Nip>, MpyRC<Perm,Pack><2,3>
                    <Real,Ccs><,2>Fft<,Nip>
                    Goertz

nsp_UsesFir:        struct FirState,FirInit<,Mr>,FirFree,Fir<Get,Set><Taps,Dlyl>
                    struct Fir<Taps|Dly>State, 
                    FirlInit<,Mr,Dlyl>, Firl, Firl<Get,Set><Taps,Dlyl>,
                    

nsp_UsesFirGen:     nspdFirLowpass, nspdFirHighpass, nspdFirBandpass 
                    nspdFirBandstop 
                        

nsp_UsesIir:        struct Iir<Tap,Dly>State, IirlInit<,Bq,Dlyl>, Iirl
                    struct Iir<Tap,Dly>State, IirInit<,Bq>, Iir, IirFree

nsp_UsesLms:        struct Lms<Tap,Dly>State, LmslInit<,Mr,Dlyl>,
                    Lmsl<Get,Set><Step,Leak>, Lmsl<,Na>

nsp_UsesMedian      MedianFilter1,MedianFilter2

nsp_UsesMisc:       BitRevTbl,BitRev,
                    TwdTbl

nsp_UsesSampleGen:  struct ToneState, ToneInit, Tone
                    struct TrnglState, TrnglInit, Trngl
                    bRandUni, RandUni, RandUniInit
                    bRandGauss, RandGauss, RandGausInit

nsp_UsesWin:        Win<Bartlett,Hann,Hamming,Blackman<,Std,Opt>,Kaiser>

nsp_UsesWavelet:    WtInit, WtInitLen, WtSetState, WtGetState,
                    WtDecompose, WtReconstruct */


/* ---------------------------- NSP Library Parts ------------------------- */

#if defined (nsp_UsesAll) || defined (nsp_UsesConvolution)
# include  "nspconv.h"
# include  "nspcnv2d.h"
# include  "nspfir2.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesConversion)
# include  "nspcvrt.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesDct)
# include "nspdct.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesFir)
# include  "nspfirl.h"
# include  "nspfirh.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesFirGen)
# include  "nspfirg.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesIir)
# include  "nspiirl.h"
# include  "nspiirh.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesLms)
# include  "nsplmsl.h"
# include  "nsplmsh.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesMedian)
# include  "nspmed.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesMisc)
# include  "nspmisc.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesSampleGen)
# include  "nsprand.h"
# include  "nsptone.h"
# include  "nsptrngl.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesTransform)
# include  "nspfft.h"
# include  "nspgrtzl.h"
# include  "nspgrtzw.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesVector)
# include  "nsparith.h"
# include  "nspcorr.h"
# include  "nsplaw.h"
# include  "nsplnexp.h"
# include  "nspsampl.h"
# include  "nspfirh.h"
# include  "nspfirl.h"
# include  "nspfirg.h"
# include  "nsprsmpl.h"
# include  "nspvec.h"
# include  "nspdotp.h"
# include  "nspnorm.h"
# include  "nsplogic.h"
# include  "nspdiv.h"
# include  "nspatan.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesWin)
# include  "nspwin.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesWavelet)
# include  "nspwlt.h"
#endif

#include "nsperror.h"
#include "nspalloc.h"

/* ------------------------------------------------------------------------ */

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\macros_wmv.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

	header.h

Abstract:
	define number of bits and some information for encoder/decoder

Author:

	Ming-Chieh Lee (mingcl@microsoft.com) 20-March-1996

Revision History:

*************************************************************************/

#ifndef __MACROS_WMV_H_ 
#define __MACROS_WMV_H_

// for motion 
#define NOT_MV 10000

// macroblock
#define MB_SIZE 16
#define MB_SQUARE_SIZE 256

#define ALLBLOCK 0
#define SUB_BLOCK_SIZE 4 // for YVU9 color input
// block
#define BLOCK_SIZE 8
#define BLOCK_SIZE_TIMES2 16
#define BLOCK_SIZE_TIMES6 48
#define BLOCK_SIZE_TIMES2_TIMES2	32
#define BLOCK_SIZE_TIMES2_TIMES3	48
#define BLOCK_SIZE_TIMES2_TIMES4	64
#define BLOCK_SIZE_TIMES2_TIMES5	80
#define BLOCK_SIZE_TIMES2_TIMES6	96
#define BLOCK_SIZE_TIMES2_TIMES7	112

#define BLOCK_SQUARE_SIZE 64
#define BLOCK_SQUARE_SIZE_TIMES2 128
#define BLOCK_SQUARE_SIZE_TIMES3 192
#define BLOCK_SQUARE_SIZE_TIMES5 320
#define BLOCK_SQUARE_SIZE_TIMES6 384
#define BLOCK_SQUARE_SIZE_TIMES7 448
#define BLOCK_SQUARE_SIZE_TIMES9 576
#define BLOCK_SQUARE_SIZE_TIMES11 704
#define BLOCK_SQUARE_SIZE_TIMES12 768
#define BLOCK_SQUARE_SIZE_TIMES13 832

#ifdef _EMB_WMV2_
#define VECTORIZE_MOTIONCOMP_RNDCTRL_OFF 0x10000
#define VECTORIZE_MOTIONCOMP_RNDCTRL_ON 0x0
#endif

#if defined(DYNAMIC_EDGEPAD)
#       if defined(STATIC_PAD_0) 
#       define EXPANDY_REFVOP		    0
#       define EXPANDUV_REFVOP			0
#       else
#       define EXPANDY_REFVOP		    8
#       define EXPANDUV_REFVOP			4
#endif
#else
#define EXPANDY_REFVOP					32
#define EXPANDUV_REFVOP					16
#endif

#define INTER   1
#define INTRA   0

#define __huge 
#define own // used as "reserved word" to indicate ownership or transfer to distinguish from const
#define TRUE 1
#define FALSE 0

#define Sizeof(x) ((U32_WMV) sizeof (x))
#define DELETE_ARRAY(ptr) if (ptr) {delete [] ptr; ptr = NULL_WMV;};
#define DELETE_PTR(ptr) if (ptr) {delete ptr; ptr = NULL_WMV;};
#define FREE_PTR(ptr) if (ptr) {wmvfree(ptr); ptr = NULL_WMV;};

#define NUM_BLOCKS	6
#define VAR_FOR_HYBRID_MV 8
#define MIN_BITRATE_MB_TABLE 50
#define MAX_BITRATE_DCPred_IMBInPFrame 128 
#define MOTEST_VIDEO_CONFERENCE 1
#define MOTEST_PLATEAU 2


#ifndef ICERR_OK
#define ICERR_OK		0L
#define ICERR_ERROR		-100L
#define	ICERR_MEMORY		-3L
#define ICERR_BADFORMAT        	-2L
#endif

#define checkRange(x, a, b) (((x) < (a)) ? (a) : ((x) > (b)) ? (b) : (x))

#ifndef _MIN
#define _MIN
#define min(a, b)  (((a) < (b)) ? (a) : (b))
#endif

#define max(a,b) (((a) > (b)) ? (a) : (b))

#endif // __HEADER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\macros.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Macros.h

Abstract:

    Processor-specific macros, defines, and data types.

Author:

    Raymond Cheng (raych)       Jul 29, 1999

Revision History:


*************************************************************************/

#ifndef __COMMON_MACROS_H
#define __COMMON_MACROS_H

#ifndef DISABLE_ASSERTS
#define DISABLE_ASSERTS
#endif // DISABLE_ASSERTS

// If BUILD_INTEGER or BUILD_INT_FLOAT is not defined by project set default state

#ifdef SDE_WANTS_ASSERTS
// This should be defined only when an SDE is watching and never when checking in or for builds.
// a compiler warning message is on wmaos.c
#   ifdef DISABLE_ASSERTS
#       undef DISABLE_ASSERTS
#   endif
#elif !defined(DISABLE_ASSERTS)
// DISABLE ASSERTS because of a known issue. V4-encoded streams can contain garbage
// at the end which we will detect as an invalid bitstream.
#   define DISABLE_ASSERTS
#endif

#include "constants.h"

#ifdef UNDER_CE
#include <windef.h>
#include <kfuncs.h>
#include <dbgapi.h>
#define assert ASSERT
#else
// The following are ANSI C includes, and so should be safe for all platforms
#include <assert.h>     // If this doesn't exist, you must write an "assert" macro
#endif
#include <string.h>
#include <stdlib.h>

#ifdef DISABLE_ASSERTS
#undef assert
#define assert(a)
#endif  // DISABLE_ASSERTS


// **************************************************************************
// Platform-Specific #ifdefs
// **************************************************************************
#ifndef DISABLE_OPT	// If this is defined, use the ANSI build

#ifdef __QNX__
#undef _M_IX86
#endif

#if defined(_M_IX86) && !defined(INTEGER_ENCODER)
//#ifdef __QNX__
//#define WMA_TARGET_QNX_X86
//#else
#define WMA_TARGET_X86
//#endif
#endif

#ifdef _MIPS_
#define WMA_TARGET_MIPS
#endif

#if defined(_SH3_) && !defined(_SH4_)
#define WMA_TARGET_SH3
#endif

#ifdef _SH4_
#define WMA_TARGET_SH4
#endif

#ifdef _Embedded_x86
#define WMA_TARGET_Embedded_x86
#endif


#ifdef S_SUNOS5
#define WMA_TARGET_S_SUNOS5
#endif

#ifdef _ARM_
#define WMA_TARGET_ARM
#endif

// It's often nice to be able to compare the output between optimized versions
// and the ANSI version, to verify that the optimizations are in sync. Alas,
// some optimizations sacrifice reproducibility for speed. The following #define allows
// us to disable those optimizations to verify the main algorithms.
//#define WMA_ANSI_COMPATIBILITY_MODE

#endif	// !DISABLE_OPT

// ======================================================
// Intel x86 Platform
// ======================================================
#if defined(WMA_TARGET_X86)

#if !defined(UNDER_CE) 
#define USE_SIN_COS_TABLES
#endif

// Override the ROUNDF/ROUNDD macros below
#ifndef LITTLE_ENDIAN
#define LITTLE_ENDIAN
#endif  //LITTLE_ENDIAN
#define PLATFORM_SPECIFIC_ROUND
#define PLATFORM_SPECIFIC_BITCOPY
#define PLATFORM_SPECIFIC_FNPTR //mmx, katmai

#ifdef WMA_ANSI_COMPATIBILITY_MODE
#undef PLATFORM_SPECIFIC_ROUND
#endif // WMA_ANSI_COMPATIBILITY_MODE

// Do the fundamental typedefs: {U|I}{8|16|32|64}
typedef unsigned __int64 U64;
typedef __int64 I64;
// Default all other typedefs to standard definitions (see below)
                                                               
// Do compiler directives
#define PLATFORM_SPECIFIC_INLINE
#if _MSC_VER >= 1200            /* VC6.0 == 1200, VC5.0 == 1100 */
#define INLINE __forceinline
#else  /* _MSC_VER */
#define INLINE __inline
#endif /* _MSC_VER */
// ======================================================
// QNX in X86 Platform
// ======================================================
#elif defined(WMA_TARGET_QNX_X86)

// Override the ROUNDF/ROUNDD macros below
#define LITTLE_ENDIAN
#define PLATFORM_SPECIFIC_ROUND
#define PLATFORM_SPECIFIC_BITCOPY

#ifdef WMA_ANSI_COMPATIBILITY_MODE
#undef PLATFORM_SPECIFIC_ROUND
#endif // WMA_ANSI_COMPATIBILITY_MODE

// Do the fundamental typedefs: {U|I}{8|16|32|64}
#ifdef __QNX__
#include "../qnx/qnx.h"
#else
typedef __int64 U64;
typedef __int64 I64;
#endif
// Default all other typedefs to standard definitions (see below)

// Do compiler directives
#define PLATFORM_SPECIFIC_INLINE                       
#define INLINE __inline

// ======================================================
// MIPS (Casio) Platform
// ======================================================
#elif defined(WMA_TARGET_MIPS)

#define LITTLE_ENDIAN

// Do the fundamental typedefs: {U|I}{8|16|32|64}
typedef unsigned __int64 U64;
typedef __int64 I64;
// Default all other typedefs to standard definitions (see below)

// Do compiler directives
#define PLATFORM_SPECIFIC_INLINE
#define INLINE __forceinline


// ======================================================
//SH3 (HP WinCE and Hitachi) Platform
// ======================================================
#elif defined(WMA_TARGET_SH3)

#define LITTLE_ENDIAN

// Do the fundamental typedefs: {U|I}{8|16|32|64}
#ifdef NOINT64 
#include "int64.h"
typedef UINT64 U64;
typedef  INT64 I64;
#else
typedef unsigned __int64 U64;
typedef __int64 I64;
#endif
// Default all other typedefs to standard definitions (see below)

// Do compiler directives
#define PLATFORM_SPECIFIC_INLINE
#ifdef HITACHI
#pragma inline(quickRand, RandStateClear, LOG2, NormUInt, Align2FracBits, ROUNDF, ROUNDD, bitCpy)
#define INLINE static
#else
#define INLINE __forceinline
#endif
// ======================================================
//SH4 (HP WinCE and Hitachi) Platform
// ======================================================
#elif defined(WMA_TARGET_SH4)

#define LITTLE_ENDIAN

// Do the fundamental typedefs: {U|I}{8|16|32|64}
#ifdef NOINT64 
#include "int64.h"
typedef UINT64 U64;
typedef  INT64 I64;
#else
typedef __int64 U64;
typedef __int64 I64;
#endif
// Default all other typedefs to standard definitions (see below)

// Do compiler directives
#define PLATFORM_SPECIFIC_INLINE
#ifdef HITACHI
#pragma inline(quickRand, RandStateClear, LOG2, NormUInt, Align2FracBits, ROUNDF, ROUNDD, bitCpy)
#define INLINE static
#else
#define INLINE __forceinline
#endif
// ======================================================
//ARM Platform
// ======================================================
#elif defined(WMA_TARGET_ARM)

#define LITTLE_ENDIAN

// Do the fundamental typedefs: {U|I}{8|16|32|64}
typedef unsigned __int64 U64;
typedef __int64 I64;
// Default all other typedefs to standard definitions (see below)

// Do compiler directives
#define PLATFORM_SPECIFIC_INLINE
#define INLINE __forceinline

// ======================================================
//Linux in X86 Platform
// ======================================================
#elif defined(WMA_TARGET_Embedded_x86)
#undef BIG_ENDIAN
#undef  LITTLE_ENDIAN
#define LITTLE_ENDIAN

// Do the fundamental typedefs: {U|I}{8|16|32|64}
typedef  unsigned long long U64;
typedef  long long  I64;
// Default all other typedefs to standard definitions (see below)
// 
// Do compiler directives
#define PLATFORM_SPECIFIC_INLINE
#define INLINE inline  

// ======================================================
//Sun Solaris
// ======================================================
#elif defined(WMA_TARGET_S_SUNOS5)

#undef  LITTLE_ENDIAN
#undef  BIG_ENDIAN
#define BIG_ENDIAN

// Do the fundamental typedefs: {U|I}{8|16|32|64}
typedef  unsigned long long int  U64 ;
typedef  long long int  I64 ;

#define  PLATFORM_SPECIFIC_I32
typedef unsigned int U32;
typedef int I32;
// Default all other typedefs to standard definitions (see below)
// 
// Do compiler directives
#define PLATFORM_SPECIFIC_INLINE
#define INLINE inline  


// ======================================================
//MacOS Platform
// ======================================================
#elif defined(WMA_TARGET_MACOS)

#undef  LITTLE_ENDIAN
#undef  BIG_ENDIAN
#define BIG_ENDIAN

// Do the fundamental typedefs: {U|I}{8|16|32|64}
typedef  unsigned long long     U64;
typedef  long long              I64;

// Default all other typedefs to standard definitions (see below)
// 


// ======================================================
// ANSI-C version (no platform-specific details
// ======================================================
#else

#define WMA_TARGET_ANSI

// Default endian
#if !defined(LITTLE_ENDIAN) && !defined(BIG_ENDIAN)
#define LITTLE_ENDIAN
#endif

// Do the fundamental typedefs: {U|I}{8|16|32|64}
#ifdef NOINT64 
#include "int64.h"
typedef UINT64 U64;
#else
#ifdef __QNX__
typedef unsigned long long int U64;
typedef long long int I64;
#else
#ifdef macintosh
typedef unsigned long long U64;
typedef long long I64;
#else
typedef unsigned __int64 U64;
typedef __int64 I64;
#endif
#endif
#endif //NOINT64
// Default all other typedefs to standard definitions (see below)

#endif // Platform-specific #ifdefs



// **************************************************************************
// Default Fundamental Typedefs
// **************************************************************************
#ifndef PLATFORM_SPECIFIC_I32
#ifdef HITACHI
typedef unsigned long U32;
typedef long I32;
#else
typedef unsigned long int U32;
typedef long int I32;
#endif
#endif

#ifndef PLATFORM_SPECIFIC_I16
typedef unsigned short U16;
typedef short I16;
#endif

#ifndef PLATFORM_SPECIFIC_I8
typedef unsigned char U8;
typedef signed char I8;
#endif



// **************************************************************************
// Common Typedefs (not expected to change by platform)
// **************************************************************************
#ifndef _WMARESULT_DEFINED
#define _WMARESULT_DEFINED
typedef I32 WMARESULT;

// SUCCESS codes
static const WMARESULT WMA_OK               = 0x00000000;
static const WMARESULT WMA_S_FALSE          = 0x00000001;
static const WMARESULT WMA_S_BUFUNDERFLOW   = 0x00000002;
static const WMARESULT WMA_S_NEWPACKET      = 0x00000003;
static const WMARESULT WMA_S_NO_MORE_FRAME  = 0x00000004;
static const WMARESULT WMA_S_DEFAULT        = 0x00000005;
static const WMARESULT WMA_S_SWITCHCHMODE   = 0x00000006; // Internal error, corrected internally

// ERROR codes
static const WMARESULT WMA_E_FAIL           = 0x80004005;
static const WMARESULT WMA_E_OUTOFMEMORY    = 0x8007000E;
static const WMARESULT WMA_E_INVALIDARG     = 0x80070057;
static const WMARESULT WMA_E_NOTSUPPORTED   = 0x80040000;
static const WMARESULT WMA_E_LOSTPACKET     = 0x80040001;
static const WMARESULT WMA_E_BROKEN_FRAME   = 0x80040002;
static const WMARESULT WMA_E_BUFFEROVERFLOW = 0x80040003;
static const WMARESULT WMA_E_ONHOLD         = 0x80040004; 
//ON_HOLD: the decoder can't continue operating because of sth, most
//       likely no more data for flushing, getbits or peekbits. all functions
//       stop *immediately*.

static const WMARESULT WMA_E_BUFFERUNDERFLOW =0x80040005;
static const WMARESULT WMA_E_INVALIDRECHDR  = 0x80040006;
static const WMARESULT WMA_E_SYNCERROR      = 0x80040007;
static const WMARESULT WMA_E_NOTIMPL        = 0x80040008;
static const WMARESULT WMA_E_FLUSHOVERFLOW  = 0x80040009; // Too much input data provided to flush
static const WMARESULT WMA_E_NOMOREINPUT    = 0x8004000A; // Streaming mode: absolutely no more data (returned via GetMoreData callback)


#endif // _WMARESULT_DEFINED

#define WMAB_TRUE 1
#define WMAB_FALSE 0

#define own // used as "reserved word" to indicate ownership or transfer to distinguish from const

typedef double Double;
typedef float Float;
typedef void Void;
typedef U32 UInt;
typedef I32 Int;
typedef I32 Bool; // In Win32, BOOL is an "int" == 4 bytes. Keep it this way to reduce problems.


// **************************************************************************
// Overridable Compiler Directives
// **************************************************************************
#ifndef PLATFORM_SPECIFIC_INLINE
// This should hopefully work for most compilers. It works for VC
#define INLINE __inline
#endif  // PLATFORM_SPECIFIC_INLINE

#ifndef PLATFORM_SPECIFIC_COMPILER_MESSAGE
#define COMPILER_MESSAGE(x)         message(x)
#endif

#ifndef PLATFORM_SPECIFIC_COMPILER_PACKALIGN
#define COMPILER_PACKALIGN(x)       pack(x)
#endif

#ifndef PLATFORM_SPECIFIC_COMPILER_PACKALIGN_DEFAULT
#define COMPILER_PACKALIGN_DEFAULT  pack()
#endif

#ifdef _MSC_VER
#define MSVC_DISABLE_WARNING(x)     warning(disable:x)
#define MSVC_RESTORE_WARNING(x)     warning(default:x)
#define MSVC_CDECL                  __cdecl
#else   // _MSC_VER
// I'm hoping that compilers can take an empty #pragma (VC can)
#define MSVC_DISABLE_WARNING(x)
#define MSVC_RESTORE_WARNING(x)
#define MSVC_CDECL
#endif  // _MSC_VER


// **************************************************************************
// Macros Common to All Platforms
// **************************************************************************
// If you need to override the following for just one platform, #define a
// switch to override as in the case for ROUNDF/ROUNDD above in the
// platform-specific #ifdefs so that it is plain to see.

#define MULT_HI(a,b) (MULT_HI_DWORD(a,b)<<1)
#ifndef BUILD_INTEGER
    // these macros are not used by integer decoder. 
    // Where/when needed, provide cpu depended optimized versions as well as these generic ones.
#   define UMASR(a,b,c) (U32)((((U64)a)*((U64)b))>>c)
#   define MASR(a,b,c) (I32)((((I64)a)*((I64)b))>>(c))
#   define DASR(a,b,c) (I32)((((I64)a)*((I64)b))>>(c))
#   define DASL(a,b,c) (I32)((((I64)a)*((I64)b))<<(c))

    // The following macro has no perf-enhanced equivalents, although one can
    // easily be written a la x86 MULT_HI_DWORD:
    // I32HI,LOW = a*b; if (I32LOW & 0x80000000) I32HI += 1; return I32HI;
    // NOTE that it only rounds UP, and does not consider negative numbers.
#   define MULT_HI_DWORD_ROUND(a,b)    (I32)((((I64)(a))*((I64)(b)) + ((I64)1 << 31))>>32)
#endif

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a, b)  (((a) < (b)) ? (a) : (b))
#define checkRange(x, a, b) (((x) < (a)) ? (a) : (((x) > (b)) ? (b) : (x)))
#define DELETE_ARRAY(ptr) if (ptr!=NULL) auFree (ptr); ptr = NULL;
#define DELETE_PTR(ptr) if (ptr!=NULL) auFree (ptr); ptr = NULL;
#define ARRAY_SIZE(ar) (sizeof(ar)/sizeof((ar)[0]))

#  ifdef DEBUG_ONLY
// WCE already has this macro defined in the same way, avoid warning messages
#  undef DEBUG_ONLY
#  endif
#ifdef _DEBUG
#define DEBUG_ONLY(x)   x
#else   // _DEBUG
#define DEBUG_ONLY(x)
#endif  // _DEBUG

#if defined(LITTLE_ENDIAN)
#define DEFAULTENDIAN_TO_BIGENDIAN(i)   ByteSwap(i)
#define BIGENDIAN_TO_DEFAULTENDIAN(i)   ByteSwap(i)
#elif defined(BIG_ENDIAN)
#define DEFAULTENDIAN_TO_BIGENDIAN(i)   (i)
#define BIGENDIAN_TO_DEFAULTENDIAN(i)   (i)
#else
#error Must define the endian of the target platform
#endif // ENDIAN

#define SWAP_WORD( w )      (w) = ((w) << 8) | ((w) >> 8)

#define SWAP_DWORD( dw )    (dw) = ((dw) << 24) | ( ((dw) & 0xFF00) << 8 ) | ( ((dw) & 0xFF0000) >> 8 ) | ( ((dw) & 0xFF000000) >> 24);

// WMARESULT macros (stolen from winerror.h)
#define WMA_SUCCEEDED(Status) ((WMARESULT)(Status) >= 0)
#define WMA_FAILED(Status) ((WMARESULT)(Status)<0)


// Create types which are change implementation between BUILD_INTEGER and BUILD_INT_FLOAT
// Some platforms, like the X86 and the SH4, can implement either build efficently.
// Other platforms, with only emulated floating point support, are typically only build with BUILD_INTEGER
//  
// Each type defined below is either a float (BUILD_INT_FLOAT) and an I32 with some number of fractional bits (BUILD_INTEGER)
// Use float or and I32 with five fractional bits
// And create a type for trig functions (Float or I32 with 30 fractional bits)
#if defined(BUILD_INTEGER)

// Coefficents type (output of inverse quantization, transformed by DCT and overlapped/added)
// Range is +/- 2^26 with five fractional bits
    typedef I32 CoefType;
#   define COEF_FRAC_BITS 5
#   define COEF_FRAC_SCALE (1<<COEF_FRAC_BITS)
#   define COEF_FROM_FLOAT(flt) ((CoefType)(flt*COEF_FRAC_SCALE))
#   define FLOAT_FROM_COEF(coef) (coef/((Float)COEF_FRAC_SCALE))
#   define COEF_FROM_INT(i) ((i)<<COEF_FRAC_BITS)
#   define INT_FROM_COEF(cf) ((cf)>>COEF_FRAC_BITS)

// Fractional Type with range -2.0 <= x < 2.0 used by FFT Trig Recurrsion 
    typedef I32 BP2Type;
#   define BP2_FRAC_BITS 30
#   define BP2_FRAC_SCALE NF2BP2
#   define BP2_FROM_FLOAT(flt) ((BP2Type)(flt*BP2_FRAC_SCALE))
#   define FLOAT_FROM_BP2(bp2) (bp2/((Float)BP2_FRAC_SCALE))
#   define BP2_FROM_BP1(bp1) ((bp1)>>1)
#   define MULT_BP2(a,b) MULT_HI_DWORD_DOWN((a),(b))

// Fractional type with range -1.0 <= x < 1.0 used by DCT Trig Recurrsion
    typedef I32 BP1Type;
#   define BP1_FRAC_BITS 31
#   define BP1_FRAC_SCALE NF2BP1
#   define BP1_FROM_FLOAT(flt) ((BP2Type)(flt*BP1_FRAC_SCALE))
#   define FLOAT_FROM_BP1(bp1) (bp1/((Float)BP1_FRAC_SCALE))
#   define MULT_BP1(a,b) MULT_HI((a),(b))

// Fraction is stored at 2^32 (BP0)
#define UBP0_FROM_FLOAT(x) ((U32)(x*4294967296.0F))

    typedef I32 FracBitsType;
    typedef struct {
    //I8 exponent;  Old exponent was shift from binary point at 24th position
        FracBitsType iFracBits;
        I32 iFraction;
    } FastFloat;

// Type for holding quantization magnitide returned by prvWeightedQuantization
    typedef FastFloat QuantFloat;

//****************************************************************************
//         Types, constants related to LPC.
//         Lot of these could be moved to constants.h or lpcConst.h for cleanliness
//****************************************************************************

//  LSP (aka LSF), used for inverse quantized LSF.
    typedef Int LspType;
#   define FRACT_BITS_LSP 30
#   define LSP_SCALE (1<<FRACT_BITS_LSP)
#   define LSP_FROM_FLOAT(a) ((LpType)((a)*LSP_SCALE))
#   define MULT_LSP(a,b) (I32)((((I64)(a))*((I64)(b)))>>FRACT_BITS_LSP)
// MULT_LSP may be redefined by processor specific code in macros_cpu.h

//  LP, used for P, Q, and LPC values
    typedef Int LpType;
#   ifndef MATCH_ARM_WAY
#       define FRACT_BITS_LP 27
#   else
#       define FRACT_BITS_LP 26
#   endif
#   define LP_SCALE (1<<FRACT_BITS_LP)
#   define FLOAT_FROM_LP(a) ((Float)((a)*(1.0f/LP_SCALE)))
#   define LP_FROM_FLOAT(a) ((LpType)((a)*LP_SCALE))

//  LP Spectrum: used during FFT of LPC values
//  LP Spectrum power: sum-squares of FFT output
    typedef Int LpSpecType;
#if defined (LPCPOWER32)
//               Uses 32-bit intermediates
//               LPC scale is 2^21.  Making it any larger causes overflows in the square(x) function 
//               in LPC_TO_SPECTRUM. But would like more frac bits, because the small values of the 
//               spectrum yield larger WeightFactors. And float version on the same sound uses 
//               IQR(1.575e-7) = 75.5795. Largest IQR of 1/LPC_SCALE is 38 or the result for values 
//               less than that which is 1/(2*LPC_SCALE) => 45.25.
#   define FRACT_BITS_LP_SPEC 21
    typedef UInt LpSpecPowerType;
#   define BITS_LP_SPEC_POWER 32
#   define FRACT_BITS_LP_SPEC_POWER 21
#   define QR_FRACTION_FRAC_BITS 27
#   define QR_EXPONENT_FRAC_BITS 25

#else // !LPCPOWER32
//                Uses 64-bit intermediates
#   ifndef MATCH_ARM_WAY
#       define FRACT_BITS_LP_SPEC 25
#   else
        //  ARM's use of 26 instead of 25 produces BIG relative errors compared to LPC_COMPARE
        //  at least when using the old version of the Lpc code.
//#       define FRACT_BITS_LP_SPEC 26
#       define FRACT_BITS_LP_SPEC 25
#   endif
    typedef U64 LpSpecPowerType;
#   define BITS_LP_SPEC_POWER 64
#   define FRACT_BITS_LP_SPEC_POWER 30 
#   define QR_FRACTION_FRAC_BITS 24
#   define QR_EXPONENT_FRAC_BITS 29
#endif // LPCPOWER32

#   define LP_SPEC_SCALE (1<<FRACT_BITS_LP_SPEC)
#   define LP_SPEC_POWER_SCALE ((float)(1L<<FRACT_BITS_LP_SPEC_POWER))
#   define LP_SPEC_FROM_FLOAT(a) ((LpSpecType)((a)*LP_SPEC_SCALE))
#   define LP_SPEC_POWER_FROM_FLOAT(a) ((LpSpecType)((a)*LP_SPEC_POWER_SCALE))
#   define FLOAT_FROM_LP_SPEC(a) ((Float)((a)*(1.0f/LP_SPEC_SCALE)))
#   define LP_SPEC_FROM_LP(a) ((LpSpecType)((a)>>(FRACT_BITS_LP-FRACT_BITS_LP_SPEC)))

//  Weights, computed from LPC (and Bark?).
    typedef UInt WeightType;
//               We see weight factor values upto 64.53440857: 7 bits enough to cover integer part, 
//               leaving upto 25 bits for fraction. However, only 21 bits of fraction are generated 
//               upstream, making other 4 bits zero, even if used.
#if defined (LPCPOWER32)
#   define WEIGHTFACTOR_FRACT_BITS     20
#else
#   ifndef MATCH_ARM_WAY
#       define WEIGHTFACTOR_FRACT_BITS     21
#   else
#       define WEIGHTFACTOR_FRACT_BITS     25
#   endif
#endif 
#   define WEIGHT_FROM_FLOAT(a) ((WeightType)((a)*(1<<WEIGHTFACTOR_FRACT_BITS)))
#   define FLOAT_FROM_WEIGHT(a) ((Float)((a)*(1.0f/(1<<WEIGHTFACTOR_FRACT_BITS))))

//****************************************************************************
//         End of types, constants related to LPC.
//****************************************************************************

    // Some utility functions with obvious meaning
#   define DIV2(a) ((a)>>1)
#   define MUL2(a) ((a)<<1)
#   define DIV4(a) ((a)>>2)
#   define MUL4(a) ((a)<<2)
#   define MUL8(a) ((a)<<3)

#   define INTEGER_ONLY(a) a
#   define INTEGER_OR_INT_FLOAT(a,b) a

#else // ************ so must be BUILD_INT_FLOAT *****************

// Coefficents type (output of inverse quantization, transformed by DCT and overlapped/added)
    typedef Float CoefType;
#   define COEF_FRAC_BITS 0
#   define COEF_FRAC_SCALE 1
#   define COEF_FROM_FLOAT(flt) ((CoefType)(flt))
#   define FLOAT_FROM_COEF(coef) ((Float)(coef))
#   define COEF_FROM_INT(i) (i)
#   define INT_FROM_COEF(cf) (cf)

// Fractional Type used by FFT Trig Recurrsion 
    typedef Float BP2Type;
#   define BP2_FRAC_BITS 0
#   define BP2_FRAC_SCALE 1
#   define BP2_FROM_FLOAT(flt) ((BP2Type)(flt))
#   define FLOAT_FROM_BP2(bp2) ((Float)(bp2))
#   define BP2_FROM_BP1(bp1) (bp1)
#   define MULT_BP2(a,b) ((a)*(b))

// Fractional type used by DCT Trig Recurrsion
    typedef Float BP1Type;
#   define BP1_FRAC_BITS 0
#   define BP1_FRAC_SCALE 1
#   define BP1_FROM_FLOAT(flt) ((BP1Type)(flt))
#   define FLOAT_FROM_BP1(bp1) ((Float)(bp1))
#   define MULT_BP1(a,b) ((a)*(b))

// Another form of floating point 
    typedef Float FastFloat;

// Type for holding quantization magnitide returned by prvWeightedQuantization
    typedef Float QuantFloat;

//****************************************************************************
//         Types, constants related to LPC.
//****************************************************************************

//  LSP (aka LSF), used for inverse quantized LSF.
    typedef Float LspType;
#   define LSP_FROM_FLOAT(a) ((LspType)(a))
#   define MULT_LSP(x,y) ((x)*(y))

// LP, used for P, Q, and LPC values
    typedef Float LpType;
#   define LP_FROM_FLOAT(a) ((LpType)(a))
#   define FLOAT_FROM_LP(a) ((Float)(a))

// LP Spectrum: used during FFT of LPC values
// LP Spectrum power: sum-squares of FFT output
    typedef Float LpSpecType;
    typedef Float LpSpecPowerType;
#   define LP_SPEC_FROM_FLOAT(a) ((LpSpecType)(a))
#   define FLOAT_FROM_LP_SPEC(a) ((Float)(a))
#   define LP_SPEC_FROM_LP(a)    ((LpSpecType)(a))

//  Weights, computed from LPC   (and Bark?).
    typedef Float WeightType;
#   define WEIGHT_FROM_FLOAT(a) ((WeightType)(a))
#   define FLOAT_FROM_WEIGHT(a) ((Float)(a))

//****************************************************************************
//         End of types, constants related to LPC.
//****************************************************************************

// Some utility functions with obvious meaning
#   define DIV2(a) ((a)*0.5f)
#   define MUL2(a) ((a)*2.0f)
#   define DIV4(a) ((a)*0.25f)
#   define MUL4(a) ((a)*4.0f)
#   define MUL8(a) ((a)*8.0f)

#   define INTEGER_ONLY(a)
#   define INTEGER_OR_INT_FLOAT(a,b) b

#endif  // either BUILD_INTEGER or BUILD_INT_FLOAT

// some utility macros that are type specific to avoid the compiler's type conversion rules.
#define COEF_ABS(a) (((a)<0) ? -(a) : (a))
#define BPX_ABS(a) (((a)<0) ? -(a) : (a))


#if !(defined(REFERENCE_RAND_24) || defined(REFERENCE_RAND_16))

    //****************************************************************************
    // quick and dirty rand generator, assuming low word multiply, only works for 
    // 32-bit machines see Numerical Recipes p.284.  
    // Note this is the referenced generator but the 24-bit or 16-bit versions can
    // be used for compliance comparisions with 24-bit or 16-bit implementations.
    //****************************************************************************

    typedef struct tagRandState {
        I32 iPrior;         // prior value
        U32 uiRand;         // current value
    } tRandState;

    INLINE I32 quickRand(tRandState* ptRandState)
    {
        const U32 a = 1664525;
        const U32 c = 1013904223;
        I32 iTemp, iTemp1;
        //a*x + c has to be done with unsigned 32 bit
        ptRandState->uiRand =  a * ptRandState->uiRand + c;

        // uiRand values starting from a 0 seed are: 0x3c6ef35f, 0x47502932, 0xd1ccf6e9, 0xaaf95334, 0x6252e503, 0x9f2ec686, 0x57fe6c2d, ...

        // do not change the above - this reference generator has been extensively tested and has excellent randomness properties
        // a truism in the world of random number generator theory and practice is:
        // "any change, no matter how small, can and will change the properties of the generator and must be fully tested"
        // In case you don't know, it can easily take a person-month to fully test a generator.
    
        // Notwithstanding the above, it is fair to take a function of a random number to shape its range or distribution.
        // This we do below to give it a triangular distrbution between -2.5 and 2.5 to roughly approximate a Guassian distribution.

        // cast and shift to make the range (-1, 1) with Binary Point 3.
        iTemp = ((I32)(ptRandState->uiRand)) >> 2; 

        // *1.25 to make the range (-1.25, 1.25) 
        iTemp += (iTemp>>2);
    
        // Difference of two random numbers gives a triangle distribution and a range of (-2.5, 2.5)
        // it also gives a serial correlation of -0.5 at lag 1.  But all the other lags have normally small correlations.
        iTemp1 = iTemp - ptRandState->iPrior;

        // Save first term of this difference for next time.
        ptRandState->iPrior = iTemp;

        //return -2.5 to 2.5 with Binary Point = 3 with a triangle distribution
        return iTemp1;
    }

    INLINE void RandStateClear(tRandState* ptRandState) {
        ptRandState->iPrior = 0;
        ptRandState->uiRand = 0;
    }

	// protect encoder from having these defined by mistake
#	ifdef REFERENCE_RAND_24
#		undef REFERENCE_RAND_24
#	endif
#	ifdef REFERENCE_RAND_16
#		undef REFERENCE_RAND_16
#	endif

#elif defined(REFERENCE_RAND_24)

    //****************************************************************************
    // Quick and dirty 24-bit rand generator.
    // Simulates 24-bits on a 32-bit reference machine.
    // Note this is the 24-bit referenced generator which can be used for compliance 
    // comparisions with 24-bit implementations by defining REFERENCE_RAN_24
    //****************************************************************************
    typedef struct tagRandState {
        I32 iPrior;         // prior value   (only top 24-bits used)
        U32 uiRand;         // current value (only top 24-bits used)
    } tRandState;

    INLINE I32 quickRand(tRandState* ptRandState)
    {
        // OK to 512 lags, then ChiSquare is suspect at 1024 and rejects at 2048 (length 1024000)
        const U32 uLCa = 69857;         // 0x000110E1
        const U32 uLCc = 3546581;       // 0x00361DD5

        I32 iTemp, iTemp1;
        //a*x + c has to be done with unsigned 32 bit - but we similate a 24x24
        ptRandState->uiRand =  (uLCa * ((ptRandState->uiRand)>>8) + uLCc)<<8;

        // uiRand values starting from a 0 seed are: 0x361dd500, 0x78a60a00, 0xaaac9f00, 0xa0c59400, 0x7104e900, 0xc2fe9e00, 0x1fc6b300

        // do not change the above - see comment in 32-bit generator

        // cast and shift to make the range (-1, 1) with Binary Point 3.
        iTemp = (((I32)(ptRandState->uiRand)) >> 2) & 0xFFFFFF00; 

        // *1.25 to make the range (-1.25, 1.25) 
        iTemp += ((iTemp>>2) & 0xFFFFFF00);
    
        // Difference of two random numbers gives a triangle distribution and a range of (-2.5, 2.5)
        // it also gives a serial correlation of -0.5 at lag 1.  But all the other lags have normally small correlations.
        iTemp1 = iTemp - ptRandState->iPrior;

        // Save first term of this difference for next time.
        ptRandState->iPrior = iTemp;

        //return -2.5 to 2.5 with Binary Point = 3 with a triangle distribution
        return iTemp1;
    }

    INLINE void RandStateClear(tRandState* ptRandState) {
        ptRandState->iPrior = 0;
        ptRandState->uiRand = 0;
    }


#elif defined(REFERENCE_RAND_16)
    //****************************************************************************
    // Quick and dirty 16-bit rand generator.
    // Simulates 16-bits on a 32-bit reference machine.
    // Note this is the 16-bit referenced generator for compliance comparisions 
    // with 16-bit implementations by defining REFERENCE_RAN_16.
    // The function actually returns 21 random bits at the top of the 32 
    // so is not a pure 16-bit generator, but does limit itself to a 16x16=>32 multiply
    //****************************************************************************

    // Background
    // A pure 16-bit Linear Congruent generator has limited sequence length.  
    // Use 13 A's and 3 C's choosen from good values in the middle of the range.
    // Tested OK up to lag 1024 (length 32768) and pretty good at 2048 and 2049.
    // Sequence length quite long.

    // these two arrays are defined once in dectables.c
#   define LCA_SET 13
#   define LCC_SET 3
    extern const unsigned int g_uWMALCA[LCA_SET];   // {1637,1033,1825,1621, 1657,1861,1229,1549, 2017,941,1409,1777, 1153};
    extern const unsigned int g_uWMALCC[LCC_SET];   // {13849,13841,13859};

    typedef struct tagRandState {
        I32 iPrior;         // prior value
        U16 uiRand;         // current value
        char bIdxLCA;       // index for uLCA
        char bIdxLCC;       // index for uLCC
    } tRandState;

    INLINE I32 quickRand(tRandState* ptRandState)
    {
        // This 16-bit implementation returns a 32-bit result with the top 21 bits random.
        // But it base implementation is 16x16=>32, e.g. it requires only a single precision 16-bit multiply.

        I32 iTemp, iTemp1;
        U32 uTemp;

        //a*x + c is with unsigned 32 bit - but we similate a 16x16+16 =32
        uTemp =  (g_uWMALCA[ptRandState->bIdxLCA++] * (ptRandState->uiRand)) + g_uWMALCC[ptRandState->bIdxLCC++];

        // save bottom 16 bits
        ptRandState->uiRand  = (unsigned short)uTemp;

        // uiRand values starting from a 0 seed are: 0x3623, 0x259c, 0x5add, 0x5698, 0xb511, 0x78ae, 0x6af9, 0x09f2, 0xc49b, 0x4f3e, 0x4377, 0x1108

        // wrap indexes
        if (ptRandState->bIdxLCA>=LCA_SET) 
            ptRandState->bIdxLCA = 0;
        if (ptRandState->bIdxLCC>=LCC_SET)
            ptRandState->bIdxLCC = 0;

        // get best 19 bits into top
        uTemp <<= 13;           

        // do not change the above - see comment in 32-bit generator

        // cast and shift to make the range (-1, 1) with Binary Point 3.
        iTemp = (((I32)(uTemp)) >> 2); 

        // *1.25 to make the range (-1.25, 1.25) 
        iTemp += (iTemp>>2);
    
        // Difference of two random numbers gives a triangle distribution and a range of (-2.5, 2.5)
        // it also gives a serial correlation of -0.5 at lag 1.  But all the other lags have normally small correlations.
        iTemp1 = iTemp - ptRandState->iPrior;

        // Save first term of this difference for next time.
        ptRandState->iPrior = iTemp;

        //return -2.5 to 2.5 with Binary Point = 3 with a triangle distribution
        return iTemp1;
    }

    INLINE void RandStateClear(tRandState* ptRandState) {
        ptRandState->iPrior = 0;
        ptRandState->uiRand = 0;
        ptRandState->bIdxLCA = 1;
        ptRandState->bIdxLCC = 2;
    }

#endif

//****************************************************************************
// log base 2 of a number which is a power of 2 
//****************************************************************************
INLINE I32 LOG2(U32 i)
{   // returns n where n = log2(2^n) = log2(2^(n+1)-1)
    U32 iLog2 = 0;
    assert (i != 0);
    while ((i >> iLog2) > 1)
        iLog2++;

    return iLog2;
}

#ifndef macintosh
#define log2 LOG2
#endif

//****************************************************************************
// Normalize a dynamically scaled unsigned int 
//****************************************************************************
INLINE void NormUInt( UInt* puiValue, Int* pcFracBits, const UInt uiTarget ){
    const UInt uiTarget2 = uiTarget>>1;
    register UInt uiV = *puiValue;
    register Int cFB = *pcFracBits;
    assert( uiV > 0 );    
    if (uiV == 0) return; // useful if asserts are disabled

    while ( uiV < uiTarget2 )
    {
        uiV <<= 2;        
        cFB += 2;
    }
    if ( uiV < uiTarget )
    {
        uiV <<= 1;        
        cFB += 1;
    }
    *puiValue = uiV;
    *pcFracBits = cFB;
}

//****************************************************************************
// Align a dynamically scaled int to a particular binary point position
//****************************************************************************
INLINE Int Align2FracBits( const Int iValue, const Int cFracBits, const Int cAlignFracBits )
{
    const Int iShift = cFracBits-cAlignFracBits;

    if (iShift < 0) {
        return (iValue << -iShift);
    } else if (iShift < 32) { 
        return (iValue >> iShift);
    } else {
        return 0;
    }
}


// V4 Compatibility Mode: This mode allows us to compare V5 encoder with V4 encoder
#ifdef V4V5_COMPARE_MODE
#define V4V5COMPARE_SNAPTOZERO(x)   if (fabs(x) <= 1.0e-15) {(x) = 0;}
#define ROUNDF_V4V5COMPARE(x)  ROUNDD(x)
typedef double V4V5COMPARE;
#else   // V4V5_COMPARE_MODE
#define V4V5COMPARE_SNAPTOZERO(x)
#define ROUNDF_V4V5COMPARE(x)  ROUNDF(x)
typedef float  V4V5COMPARE;
#endif  // V4V5_COMPARE_MODE

#ifdef BUILD_INTEGER
typedef I32     FLOATORI32;
typedef U32     FLOATORU32;
typedef U16     FLOATORU16;
#define FLOATORU32_CONST(flop,fb)           ((U32)((flop)*(1 << (fb))))
#define FLOATORINT_TOFLOAT(x,fb)            ((Float)(x)/(Float)(1 << (fb)))
#define FLOATORINT_SELECTTOFLOAT(f,i,fb)    ((Float)(i)/(Float)(1 << (fb)))
#define FLOATORINT_ASSERT(x)                assert(x)
#define FLOATORINT_AB(a,b)                  (a)

// The following is used to allow non-integerized code to convert a FLOP
// result to a bit-discarded integer result
#define FLOATORU32_DISCARDBITSFROMFLT(x,fb) ((U32)((x)/(float)(1 << (fb))))
#define FLOATORU32_DISCARDBITSFROMU32(x,fb) ((U32)(x) >> (fb))
#define FLOATORU32_DISCARDBITSFROMI64(x,fb) ((I64)(x) >> (fb))
#define FLOATORU32_ADDFRACTBITS(i,fb)       ((i) << (fb))
#define FLOATORI32_DISCARDBITSFROMI32(x,fb) ((I32)(x) >> (fb))

#else   // BUILD_INTEGER

typedef Float   FLOATORI32;
typedef Float   FLOATORU32;
typedef Float   FLOATORU16;
#define FLOATORU32_CONST(flop,fb)           (flop)
#define FLOATORINT_TOFLOAT(x,fb)            (x)
#define FLOATORINT_SELECTTOFLOAT(f,i,fb)    (f)
#define FLOATORINT_ASSERT(x)
#define FLOATORINT_AB(a,b)                  (b)

#define FLOATORU32_DISCARDBITSFROMFLT(x,fb) (x) // FLOP-to-FLOP, no conversion required
#define FLOATORU32_DISCARDBITSFROMU32(x,fb) ((Float)x)
#define FLOATORU32_DISCARDBITSFROMI64(x,fb) (x)
#define FLOATORU32_ADDFRACTBITS(i,fb)       (i) // FLOP, no fract bits required
#define FLOATORI32_DISCARDBITSFROMI32(x,fb) (x)
#endif  // BUILD_INTEGER


// **************************************************************************
// Bring in platform-specific macros
// **************************************************************************
// Include them here because some of them use the global macros above
#include "wmaOS.h"
#if defined(WMA_TARGET_X86) || defined(WMA_TARGET_QNX_X86)

// Output target
#ifdef COMMONMACROS_OUTPUT_TARGET
#pragma COMPILER_MESSAGE("-----MACROS.H: Compiling for Intel x86 Target")
#endif  // COMMONMACROS_OUTPUT_TARGET

//#ifdef __QNX__
#include "x86macros.h"
//#else
//#include "..\x86\macros.h"
//#endif

//---------------------------------------------------------------------------
#elif defined(WMA_TARGET_MIPS)

// Output target
#ifdef BUILD_INTEGER
#ifdef COMMONMACROS_OUTPUT_TARGET
#pragma COMPILER_MESSAGE("-----MACROS.H: Compiling for MIPS integer Target")
#endif // COMMONMACROS_OUTPUT_TARGET
#else
#ifdef COMMONMACROS_OUTPUT_TARGET
#pragma COMPILER_MESSAGE("-----MACROS.H: Compiling for MIPS floating point  Target")
#endif // COMMONMACROS_OUTPUT_TARGET

#endif

#include "..\mips\macros_mips.h"

#elif defined(WMA_TARGET_SH3)

// Output target
#ifdef COMMONMACROS_OUTPUT_TARGET
#pragma COMPILER_MESSAGE("-----MACROS.H: Compiling for SH3 (Hitachi & HP WinCE) Target")
#endif // COMMONMACROS_OUTPUT_TARGET

#include "..\sh3\macros_sh3.h"

#elif defined(WMA_TARGET_SH4)

// Output target
#ifdef COMMONMACROS_OUTPUT_TARGET
#pragma COMPILER_MESSAGE("-----MACROS.H: Compiling for SH4 (Hitachi WinCE) Target")
#endif // COMMONMACROS_OUTPUT_TARGET

#ifndef HITACHI
static 
#endif
INLINE U32 ByteSwap(U32 i){ 
    U8 *p = (U8 *)&i;
    return (p[0]<<24)|(p[1]<<16)|(p[2]<<8)|p[3];
}

#include "..\sh4\macros_SH4.h"

//---------------------------------------------------------------------------
#else

// Output target
#ifdef COMMONMACROS_OUTPUT_TARGET
#pragma COMPILER_MESSAGE("-----MACROS.H: Compiling for ANSI-C Target")
#endif // COMMONMACROS_OUTPUT_TARGET

// Bring in platform-independent macros
#define MULT_HI_DWORD_DOWN(a,b) (I32)((((I64)(a))*((I64)(b)))>>30)
#define MULT_HI_DWORD(a,b) (I32)((((I64)(a))*((I64)(b)))>>32)

// Unsigned version of multiply
#define MULT_HI_UDWORD(a,b) (U32)((((U64)(a))*((U64)(b)))>>32)

static INLINE U32 ByteSwap(U32 i){ 
    U8 *p = (U8 *)&i;
    return (p[0]<<24)|(p[1]<<16)|(p[2]<<8)|p[3];
}

#endif // Platform-specific #ifdefs


// **************************************************************************
// Overridable Macros (optimized for some platforms, but not all)
// **************************************************************************
// The following can be overridden within a particular platform macro file
#ifndef PLATFORM_SPECIFIC_ROUND
#ifdef HITACHI
static I32 ROUNDF(float f) {
#else
static INLINE I32 ROUNDF(float f) {
#endif
    if (f < 0.0f)
        return (I32) (f - 0.5f);
    else
        return (I32) (f + 0.5f);
}

//---------------------------------------------------------------------------
#ifdef HITACHI
static I32 ROUNDD(double f) {
#else
static INLINE I32 ROUNDD(double f) {
#endif
    if (f < 0)
        return (I32) (f - 0.5);
    else
        return (I32) (f + 0.5);
}
#endif // PLATFORM_SPECIFIC_ROUND

//---------------------------------------------------------------------------
#ifndef PLATFORM_SPECIFIC_BITCOPY
//assuming bsrc is zeroed out
#ifdef HITACHI
static void bitCpy (const U8* pbSrc, Int iBitStartSrc, Int cBits, U8* pbDst)
#else
static INLINE void bitCpy (const U8* pbSrc, Int iBitStartSrc, Int cBits, U8* pbDst)
#endif
{
    const U8* pbSrcEnd;
    Int iShiftDown;
    U8 b2, b1;

    assert (pbSrc != NULL && pbDst != NULL);
    assert (iBitStartSrc < BITS_PER_DWORD && iBitStartSrc >= 0);
    assert (cBits >= 0);

    // Caller assumes we're copying DWORDs at a time (hangover from Intel)
    // Normalize pointers 
    pbSrc += iBitStartSrc / BITS_PER_BYTE;
    iBitStartSrc %= BITS_PER_BYTE;

    pbSrcEnd = pbSrc + (iBitStartSrc > 0) + 
                            (((cBits - iBitStartSrc) + 7) & ~7) / 8; //open
    iShiftDown = (BITS_PER_BYTE - iBitStartSrc);
    b1 = *pbSrc;
    while (pbSrc < pbSrcEnd) {
        pbSrc++;
        b2 = *pbSrc;
        *pbDst = (b1 << iBitStartSrc) | (b2 >> iShiftDown);
        b1 = b2;
        pbDst++;
    }
}
#endif // PLATFORM_SPECIFIC_BITCOPY

#ifndef PLATFORM_SPECIFIC_FNPTR
#define PLATFORM_SPECIFIC_FNPTR     //nothing for non-x86
#endif // PLATFORM_SPECIFIC_FNPTR


//**********************************************************************
// Support for FastFloat
//**********************************************************************

#if defined(BUILD_INTEGER)
    // FastFloat
    // FastFloat is a quick way of handling values that exceed I32 range without incurring
    // the expense of floating point emulation on integer only platforms.
    // real value = iFraction * pow( 2, -iFracBits )
    // In debugger, iFraction*1.0F/(1<<iFracBits) works if 0<=iFracBits<31

    // Normalize a FastFloat
#ifdef HITACHI  
#   pragma inline(Norm4FastFloat)
#else   
    INLINE
#endif
static void Norm4FastFloat( FastFloat* pfflt )
    {   // use the faster Norm4FastFloatU when you know the value is positive
        register UInt uiF = abs(pfflt->iFraction);
        register Int iFB = 0;
        if ( uiF == 0 )
        {
            pfflt->iFracBits = 0;
            return;
        }
        while ( uiF < 0x1FFFFFFF )
        {
            uiF <<= 2;
            iFB +=  2;
        }
        if ( uiF < 0x3FFFFFFF )
        {
            iFB +=  1;
        }
        pfflt->iFraction <<= iFB;
        pfflt->iFracBits += iFB;
    }


#ifdef HITACHI
#   pragma inline(Norm4FastFloatU)
#else   
    INLINE
#endif
static void Norm4FastFloatU( FastFloat* pfflt )
    {   // same as above when we know value is positive (which we often do)
        register UInt uiF = pfflt->iFraction;
        register Int iFB = 0;
        assert( uiF > 0 );
        while ( uiF < 0x1FFFFFFF )
        {
            uiF  <<= 2;
            iFB +=  2;
        }
        if ( uiF < 0x3FFFFFFF )
        {
            uiF  <<= 1;
            iFB +=  1;
        }
        pfflt->iFraction = uiF;
        pfflt->iFracBits += iFB;
    }


#ifdef HITACHI
    #pragma inline(ffltMultiply)
#else   
    INLINE
#endif  
static FastFloat ffltMultiply( FastFloat ffltA, FastFloat ffltB )
    {
        FastFloat ffltP;
        ffltP.iFraction = MULT_HI( ffltA.iFraction, ffltB.iFraction );
        ffltP.iFracBits = (ffltA.iFracBits + ffltB.iFracBits - 31);
        Norm4FastFloat( &ffltP );
        return ffltP;
    }
#   define FASTFLOAT_MULT(a,b) ffltMultiply((a),(b))


#ifdef HITACHI
    #pragma inline(FastFloatFromFloat)
#else   
    INLINE
#endif  
static FastFloat FastFloatFromFloat(Float flt) {
        FastFloat fflt;
        Float fltScale = (Float)(1<<(31-24));
        fflt.iFracBits = 24;
        while( flt < -fltScale || fltScale < flt )
        {
            flt /= 2;
            fflt.iFracBits -= 1;
            fltScale *= 2;
        }
        fflt.iFraction = (I32)(flt*(1<<fflt.iFracBits));
        Norm4FastFloat( &fflt );
        return fflt;
    }   


#ifdef HITACHI  
    #pragma inline(FloatFromFastFloat)
#else   
    INLINE
#endif
static Float FloatFromFastFloat( FastFloat fflt )
    {
        assert( 0<= fflt.iFracBits && fflt.iFracBits <= 50 );
        if ( fflt.iFracBits > 30 )
            return fflt.iFraction/(1048576.0F*(1<<(fflt.iFracBits-20)));
        else
            return fflt.iFraction/((Float)(1<<fflt.iFracBits));

    }
#   define FASTFLOAT_FROM_FLOAT(flt) FastFloatFromFloat(flt)
#   define FLOAT_FROM_FASTFLOAT(fflt) FloatFromFastFloat(fflt)
#   define DOUBLE_FROM_FASTFLOAT(fflt) ((double)fflt.iFraction/(1<<fflt.iFracBits))


#ifdef HITACHI
    #pragma inline(FastFloatFromU64)
#else   
    INLINE
#endif  
static FastFloat FastFloatFromU64(U64 u64, Int cExp) 
    {
        FastFloat fflt;
        U32 uiMSF = (U32)(u64>>32);
        Int iExp = 0;
        if ( uiMSF==0 ) {
            iExp = 32;
            uiMSF = (U32)u64;
        }
        if (uiMSF==0) {
            fflt.iFracBits = 0;
            fflt.iFraction = 0;
            return fflt;
        }
        // normalize the most significant fractional part
        while( (uiMSF & 0xF0000000)==0 ) {
            iExp += 3;
            uiMSF <<= 3;
        }
        while( (uiMSF & 0xC0000000)==0 ) {
            iExp++;
            uiMSF <<= 1;
        }
        // number of fractional bits
        fflt.iFracBits = iExp+cExp-32;
#if defined(PLATFORM_OPTIMIZE_MINIMIZE_BRANCHING)
        fflt.iFraction = (U32)((u64<<iExp)>>32);
#else
        fflt.iFraction = (iExp>32) ? (U32)(u64<<(iExp-32)) : (U32)(u64>>(32-iExp));
#endif
        return fflt;
    }   
#define FASTFLOAT_FROM_U64(u64,exp) FastFloatFromU64(u64,exp)


    typedef FastFloat QuantStepType;
#define DOUBLE_FROM_QUANTSTEPTYPE(qst) DOUBLE_FROM_FASTFLOAT(qst)
#define  FLOAT_FROM_QUANTSTEPTYPE(qst) FLOAT_FROM_FASTFLOAT(qst)
#define FASTFLOAT_FROM_QUANTSTEPTYPE(qst) (qst)

#else   // must be BUILD_INT_FLOAT

#   define FASTFLOAT_FROM_FLOAT(flt) (flt)
#   define FLOAT_FROM_FASTFLOAT(fflt) (fflt)
#   define FASTFLOAT_MULT(a,b) ((a)*(b))
#   define DOUBLE_FROM_FASTFLOAT(fflt) ((double)fflt)

#   define FASTFLOAT_FROM_U64(u64,exp) (((Float)(u64))/(((U64)1)<<exp))

    typedef Float QuantStepType;
#define DOUBLE_FROM_QUANTSTEPTYPE(qst) ((Double)(qst))
#define  FLOAT_FROM_QUANTSTEPTYPE(qst) (qst)
#define FASTFLOAT_FROM_QUANTSTEPTYPE(qst) ((FastFloat)(qst))


#endif


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
// Define Macros to switch auReconMono and auSaveHistoryMono between Integer and Float

#if defined(BUILD_INTEGER)

#define ROUND_SATURATE_STORE(piDst,cf,mn,mx,iTmp)      \
    *piDst = (I16) checkRange (cf, mn, mx);            \
    iTmp = cf;

#else  // BUILD_INT_FLOAT

#ifdef PLATFORM_SPECIFIC_ROUND
// Combined Round and Saturate is faster in floating point
// But if the platform has special Round function, we must use it.
#define ROUND_AND_CHECK_RANGE(it,flt,mn,mx)            \
    it = (I32)ROUNDF_V4V5COMPARE(flt);                 \
    it = checkRange(it,mn,mx);
#else
// Combined Round and Saturate is faster in floating point
#define ROUND_AND_CHECK_RANGE(it,flt,mn,mx)            \
    if ( flt < (V4V5COMPARE)0.0 ) {                    \
        it = (I32)( flt - ((V4V5COMPARE)0.05) );       \
        if ( it < mn ) it = mn;                        \
    } else {                                           \
        it = (I32)( flt + ((V4V5COMPARE)0.05) );       \
        if ( it > mx ) it = mx;                        \
    }
#endif

#define ROUND_SATURATE_STORE(piDst,cf,mn,mx,iTmp)      \
    ROUND_AND_CHECK_RANGE( iTmp, cf, mn, mx );         \
    *piDst = (I16)iTmp;
        
#endif // Both BUILD_INTEGER and BUILD_INT_FLOAT

#ifdef _XBOX
#define XFILE void
#define STDOUT (void *)
extern XFILE * _XFOPEN(char *filename, char *mode);
extern int  _XFSEEK(XFILE *strmnum, long offset, int origin);
extern int  _XFWRITE(const void *buffer, int size, int count, XFILE *strmnum);
extern long  _XFTELL(XFILE *strmnum);
extern int  _XFCLOSE(XFILE *strmnum);
extern int  _XFFLUSH();
extern int  _XFPRINTF(XFILE *strmnum, const char *format, ...);
#define FOPEN _XFOPEN
#define FSEEK _XFSEEK
#define FTELL _XFTELL
#define FCLOSE _XFCLOSE
#define FWRITE _XFWRITE
#define FFLUSH _XFFLUSH
#define FPRINTF _XFPRINTF
#else
#define XFILE FILE
#define STDOUT stdout
#define FOPEN fopen
#define FSEEK fseek
#define FTELL ftell
#define FCLOSE fclose
#define FWRITE fwrite
#define FFLUSH fflush
#define FPRINTF fprintf
#endif
#endif  // __COMMON_MACROS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\lpcConst.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       lpcConst.h
//
//--------------------------------------------------------------------------

#pragma MSVC_DISABLE_WARNING(4305)

#define LSP_CONST16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) \
	LSP_FROM_FLOAT(a),LSP_FROM_FLOAT(b),LSP_FROM_FLOAT(c),LSP_FROM_FLOAT(d),LSP_FROM_FLOAT(e), \
	LSP_FROM_FLOAT(f),LSP_FROM_FLOAT(g),LSP_FROM_FLOAT(h),LSP_FROM_FLOAT(i),LSP_FROM_FLOAT(j), \
	LSP_FROM_FLOAT(k),LSP_FROM_FLOAT(l),LSP_FROM_FLOAT(m),LSP_FROM_FLOAT(n),LSP_FROM_FLOAT(o), \
	LSP_FROM_FLOAT(p)

// -2.0F*(Float)cos(2.0*PI*rgfltLsfReconLevel [iLPC] [ilsfQ[iLPC]]); 
//#ifdef _XBOX  // not needed anymore? IW
//extern const LpType g_rgiLsfReconLevel [LPCORDER] [16];
//#else
const LpType g_rgiLsfReconLevel [LPCORDER] [16] = {
LSP_CONST16(-1.9873287678,-1.9794453382,-1.9717909098,-1.9626054764,-1.9503837824,-1.9333611727,-1.9071923494,-1.8619141579,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000),
LSP_CONST16(-1.9725999832,-1.9608316422,-1.9498258829,-1.9380615950,-1.9251661301,-1.9101020098,-1.8923232555,-1.8714981079,-1.8456481695,-1.8135806322,-1.7762006521,-1.7326526642,-1.6790785789,-1.6095907688,-1.5082964897,-1.3312033415),
LSP_CONST16(-1.9010910988,-1.8648242950,-1.8341966867,-1.8016844988,-1.7665011883,-1.7281632423,-1.6850270033,-1.6373825073,-1.5850157738,-1.5179518461,-1.4367990494,-1.3395057917,-1.2417620420,-1.1226072311,-0.9674966931,-0.7404826283),
LSP_CONST16(-1.7694386244,-1.6782246828,-1.5994637012,-1.5356057882,-1.4747079611,-1.4121016264,-1.3450953960,-1.2733950615,-1.1930381060,-1.0976517200,-0.9881871939,-0.8723944426,-0.7436917424,-0.5976818204,-0.4316863120,-0.1797702163),
LSP_CONST16(-1.4342834949,-1.3203835487,-1.2107408047,-1.1057798862,-1.0056174994,-0.9033592343,-0.8043748736,-0.7070966959,-0.6042739749,-0.4981404841,-0.3850953877,-0.2710680068,-0.1440741569,-0.0021991048,0.1672514081,0.3693608642),
LSP_CONST16(-0.9989568591,-0.8418816328,-0.7075374126,-0.5790659189,-0.4705556333,-0.3696696460,-0.2682664692,-0.1716338098,-0.0720839128,0.0306293573,1.4003738165,0.2512896955,0.3721393645,0.5107564926,0.6488751173,0.8030803204),
LSP_CONST16(-0.2651528120,-0.0631355122,0.0887208059,0.2110354751,0.3106967807,0.3968032300,0.4722347558,0.5416713357,0.6144474149,0.6894334555,0.7658020854,0.8517008424,0.9528906345,1.0651470423,1.2051070929,1.3761774302),
LSP_CONST16(0.5394030213,0.7377092838,0.8842487335,1.0111793280,1.1338908672,1.2683007717,1.4204199314,1.6203391552,1.1015881300,1.1651256084,1.2333712578,1.3041440248,1.3766331673,1.4685384035,1.5762579441,1.6689363718),
LSP_CONST16(0.3860199749,0.5600935221,0.6697848439,0.7602847219,0.8384606242,0.9086808562,0.9740887880,1.0369496346,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000),
LSP_CONST16(1.5614498854,1.6594402790,1.7268968821,1.7785774469,1.8220300674,1.8622007370,1.9028397799,1.9482047558,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000)
};							
// #endif


#if (defined(PLATFORM_LPC_NO_TRIG_TABLE) || defined(PLATFORM_LPC_SMALL_TRIG_TABLE)) && defined(PLATFORM_LPC_FOLDED_PRUNED)

#if defined(PLATFORM_LPC_SMALL_TRIG_TABLE) || defined(_DEBUG)

#define BP2_CONST2(a,b) BP2_FROM_FLOAT(a),BP2_FROM_FLOAT(b)

// sin(pi*i/2048) and cos(pi*i/2048) used to derive the lpc constants

const BP2Type lpc_trig2048[] = {
    BP2_CONST2(0,1),    //0
    BP2_CONST2(0.00153398018628477,0.999998823451702),    //1
    BP2_CONST2(0.00306795676296598,0.999995293809576),    //2
    BP2_CONST2(0.00460192612044857,0.999989411081928),    //3
    BP2_CONST2(0.00613588464915448,0.999981175282601),    //4
    BP2_CONST2(0.0076698287395311,0.999970586430974),    //5
    BP2_CONST2(0.00920375478205982,0.999957644551964),    //6
    BP2_CONST2(0.0107376591672645,0.999942349676024),    //7
    BP2_CONST2(0.0122715382857199,0.999924701839145),    //8
    BP2_CONST2(0.0138053885280604,0.999904701082853),    //9
    BP2_CONST2(0.0153392062849881,0.999882347454213),    //10
    BP2_CONST2(0.0168729879472817,0.999857641005824),    //11
    BP2_CONST2(0.0184067299058048,0.999830581795823),    //12
    BP2_CONST2(0.0199404285515144,0.999801169887884),    //13
    BP2_CONST2(0.0214740802754695,0.999769405351215),    //14
    BP2_CONST2(0.0230076814688394,0.999735288260562),    //15
    BP2_CONST2(0.0245412285229123,0.999698818696204),    //16
    BP2_CONST2(0.0260747178291039,0.999659996743959),    //17
    BP2_CONST2(0.0276081457789657,0.999618822495179),    //18
    BP2_CONST2(0.0291415087641937,0.999575296046749),    //19
    BP2_CONST2(0.0306748031766366,0.999529417501093),    //20
    BP2_CONST2(0.0322080254083046,0.999481186966167),    //21
    BP2_CONST2(0.0337411718513776,0.999430604555462),    //22
    BP2_CONST2(0.0352742388982139,0.999377670388003),    //23
    BP2_CONST2(0.0368072229413588,0.99932238458835),    //24
    BP2_CONST2(0.0383401203735527,0.999264747286594),    //25
    BP2_CONST2(0.0398729275877398,0.999204758618364),    //26
    BP2_CONST2(0.0414056409770767,0.999142418724817),    //27
    BP2_CONST2(0.0429382569349408,0.999077727752645),    //28
    BP2_CONST2(0.0444707718549387,0.999010685854073),    //29
    BP2_CONST2(0.0460031821309146,0.998941293186857),    //30
    BP2_CONST2(0.0475354841569593,0.998869549914284),    //31
    BP2_CONST2(0.049067674327418,0.998795456205172),    //32
    BP2_CONST2(0.0505997490368993,0.998719012233873),    //33
    BP2_CONST2(0.0521317046802833,0.998640218180265),    //34
    BP2_CONST2(0.0536635376527305,0.998559074229759),    //35
    BP2_CONST2(0.0551952443496899,0.998475580573295),    //36
    BP2_CONST2(0.0567268211669077,0.99838973740734),    //37
    BP2_CONST2(0.0582582645004358,0.998301544933893),    //38
    BP2_CONST2(0.0597895707466399,0.998211003360478),    //39
    BP2_CONST2(0.0613207363022086,0.998118112900149),    //40
    BP2_CONST2(0.0628517575641614,0.998022873771486),    //41
    BP2_CONST2(0.0643826309298575,0.997925286198596),    //42
    BP2_CONST2(0.0659133527970038,0.997825350411112),    //43
    BP2_CONST2(0.0674439195636641,0.997723066644192),    //44
    BP2_CONST2(0.0689743276282667,0.99761843513852),    //45
    BP2_CONST2(0.0705045733896139,0.997511456140303),    //46
    BP2_CONST2(0.0720346532468893,0.997402129901275),    //47
    BP2_CONST2(0.0735645635996674,0.99729045667869),    //48
    BP2_CONST2(0.0750943008479213,0.997176436735326),    //49
    BP2_CONST2(0.0766238613920315,0.997060070339483),    //50
    BP2_CONST2(0.0781532416327942,0.996941357764982),    //51
    BP2_CONST2(0.0796824379714301,0.996820299291166),    //52
    BP2_CONST2(0.0812114468095924,0.996696895202896),    //53
    BP2_CONST2(0.0827402645493757,0.996571145790555),    //54
    BP2_CONST2(0.0842688875933241,0.996443051350043),    //55
    BP2_CONST2(0.0857973123444399,0.996312612182778),    //56
    BP2_CONST2(0.0873255352061921,0.996179828595697),    //57
    BP2_CONST2(0.0888535525825246,0.996044700901252),    //58
    BP2_CONST2(0.090381360877865,0.995907229417412),    //59
    BP2_CONST2(0.0919089564971327,0.99576741446766),    //60
    BP2_CONST2(0.0934363358457478,0.995625256380994),    //61
    BP2_CONST2(0.094963495329639,0.995480755491927),    //62
    BP2_CONST2(0.0964904313552526,0.995333912140482),    //63
    BP2_CONST2(0.0980171403295606,0.995184726672197),    //64
    BP2_CONST2(0.0995436186600693,0.995033199438119),    //65
    BP2_CONST2(0.101069862754828,0.994879330794806),    //66
    BP2_CONST2(0.102595869022436,0.994723121104326),    //67
    BP2_CONST2(0.104121633872055,0.994564570734255),    //68
    BP2_CONST2(0.105647153713411,0.994403680057679),    //69
    BP2_CONST2(0.107172424956809,0.994240449453188),    //70
    BP2_CONST2(0.108697444013139,0.994074879304879),    //71
    BP2_CONST2(0.110222207293883,0.993906970002356),    //72
    BP2_CONST2(0.111746711211127,0.993736721940725),    //73
    BP2_CONST2(0.113270952177564,0.993564135520595),    //74
    BP2_CONST2(0.11479492660651,0.993389211148081),    //75
    BP2_CONST2(0.116318630911905,0.993211949234794),    //76
    BP2_CONST2(0.117842061508325,0.993032350197851),    //77
    BP2_CONST2(0.119365214810991,0.992850414459865),    //78
    BP2_CONST2(0.120888087235777,0.992666142448948),    //79
    BP2_CONST2(0.122410675199216,0.99247953459871),    //80
    BP2_CONST2(0.123932975118512,0.992290591348257),    //81
    BP2_CONST2(0.125454983411546,0.992099313142192),    //82
    BP2_CONST2(0.126976696496886,0.991905700430609),    //83
    BP2_CONST2(0.128498110793793,0.9917097536691),    //84
    BP2_CONST2(0.130019222722233,0.991511473318744),    //85
    BP2_CONST2(0.131540028702883,0.991310859846115),    //86
    BP2_CONST2(0.133060525157139,0.991107913723277),    //87
    BP2_CONST2(0.134580708507126,0.99090263542778),    //88
    BP2_CONST2(0.136100575175706,0.990695025442665),    //89
    BP2_CONST2(0.137620121586486,0.990485084256457),    //90
    BP2_CONST2(0.139139344163826,0.990272812363169),    //91
    BP2_CONST2(0.140658239332849,0.990058210262297),    //92
    BP2_CONST2(0.142176803519448,0.989841278458821),    //93
    BP2_CONST2(0.143695033150294,0.989622017463201),    //94
    BP2_CONST2(0.145212924652847,0.98940042779138),    //95
    BP2_CONST2(0.146730474455362,0.989176509964781),    //96
    BP2_CONST2(0.148247678986896,0.988950264510303),    //97
    BP2_CONST2(0.149764534677322,0.988721691960324),    //98
    BP2_CONST2(0.15128103795733,0.988490792852697),    //99
    BP2_CONST2(0.152797185258443,0.988257567730749),    //100
    BP2_CONST2(0.15431297301302,0.988022017143284),    //101
    BP2_CONST2(0.155828397654265,0.987784141644572),    //102
    BP2_CONST2(0.157343455616238,0.987543941794359),    //103
    BP2_CONST2(0.158858143333861,0.987301418157858),    //104
    BP2_CONST2(0.160372457242928,0.987056571305751),    //105
    BP2_CONST2(0.161886393780112,0.986809401814186),    //106
    BP2_CONST2(0.163399949382973,0.986559910264775),    //107
    BP2_CONST2(0.16491312048997,0.986308097244599),    //108
    BP2_CONST2(0.166425903540464,0.986053963346195),    //109
    BP2_CONST2(0.167938294974731,0.985797509167567),    //110
    BP2_CONST2(0.169450291233968,0.985538735312176),    //111
    BP2_CONST2(0.170961888760301,0.985277642388941),    //112
    BP2_CONST2(0.172473083996796,0.98501423101224),    //113
    BP2_CONST2(0.173983873387464,0.984748501801904),    //114
    BP2_CONST2(0.175494253377271,0.984480455383221),    //115
    BP2_CONST2(0.177004220412149,0.984210092386929),    //116
    BP2_CONST2(0.178513770938998,0.983937413449219),    //117
    BP2_CONST2(0.1800229014057,0.98366241921173),    //118
    BP2_CONST2(0.181531608261125,0.983385110321551),    //119
    BP2_CONST2(0.183039887955141,0.983105487431216),    //120
    BP2_CONST2(0.18454773693862,0.982823551198705),    //121
    BP2_CONST2(0.186055151663447,0.982539302287441),    //122
    BP2_CONST2(0.18756212858253,0.982252741366289),    //123
    BP2_CONST2(0.189068664149806,0.981963869109555),    //124
    BP2_CONST2(0.190574754820253,0.981672686196983),    //125
    BP2_CONST2(0.192080397049892,0.981379193313755),    //126
    BP2_CONST2(0.193585587295804,0.981083391150487),    //127
    BP2_CONST2(0.195090322016128,0.98078528040323),    //128
    BP2_CONST2(0.19659459767008,0.980484861773469),    //129
    BP2_CONST2(0.198098410717954,0.980182135968117),    //130
    BP2_CONST2(0.199601757621131,0.979877103699518),    //131
    BP2_CONST2(0.201104634842092,0.979569765685441),    //132
    BP2_CONST2(0.202607038844421,0.979260122649082),    //133
    BP2_CONST2(0.204108966092817,0.978948175319062),    //134
    BP2_CONST2(0.205610413053099,0.978633924429423),    //135
    BP2_CONST2(0.207111376192219,0.978317370719628),    //136
    BP2_CONST2(0.208611851978263,0.977998514934557),    //137
    BP2_CONST2(0.21011183688047,0.97767735782451),    //138
    BP2_CONST2(0.211611327369228,0.9773539001452),    //139
    BP2_CONST2(0.213110319916091,0.977028142657754),    //140
    BP2_CONST2(0.214608810993787,0.976700086128712),    //141
    BP2_CONST2(0.21610679707622,0.976369731330021),    //142
    BP2_CONST2(0.217604274638484,0.976037079039039),    //143
    BP2_CONST2(0.21910124015687,0.975702130038529),    //144
    BP2_CONST2(0.220597690108874,0.975364885116657),    //145
    BP2_CONST2(0.222093620973204,0.975025345066994),    //146
    BP2_CONST2(0.22358902922979,0.974683510688511),    //147
    BP2_CONST2(0.225083911359793,0.974339382785576),    //148
    BP2_CONST2(0.22657826384561,0.973992962167956),    //149
    BP2_CONST2(0.228072083170886,0.973644249650812),    //150
    BP2_CONST2(0.229565365820519,0.973293246054698),    //151
    BP2_CONST2(0.231058108280671,0.97293995220556),    //152
    BP2_CONST2(0.232550307038775,0.972584368934732),    //153
    BP2_CONST2(0.234041958583543,0.972226497078936),    //154
    BP2_CONST2(0.235533059404975,0.971866337480279),    //155
    BP2_CONST2(0.237023605994367,0.971503890986252),    //156
    BP2_CONST2(0.238513594844318,0.971139158449725),    //157
    BP2_CONST2(0.240003022448741,0.97077214072895),    //158
    BP2_CONST2(0.241491885302869,0.970402838687556),    //159
    BP2_CONST2(0.242980179903264,0.970031253194544),    //160
    BP2_CONST2(0.244467902747824,0.969657385124292),    //161
    BP2_CONST2(0.245955050335795,0.969281235356549),    //162
    BP2_CONST2(0.247441619167773,0.968902804776429),    //163
    BP2_CONST2(0.24892760574572,0.968522094274417),    //164
    BP2_CONST2(0.250413006572965,0.968139104746362),    //165
    BP2_CONST2(0.251897818154217,0.967753837093476),    //166
    BP2_CONST2(0.25338203699557,0.967366292222329),    //167
    BP2_CONST2(0.254865659604515,0.966976471044852),    //168
    BP2_CONST2(0.256348682489943,0.966584374478333),    //169
    BP2_CONST2(0.257831102162159,0.966190003445413),    //170
    BP2_CONST2(0.259312915132886,0.965793358874084),    //171
    BP2_CONST2(0.260794117915276,0.965394441697689),    //172
    BP2_CONST2(0.262274707023914,0.96499325285492),    //173
    BP2_CONST2(0.263754678974831,0.964589793289813),    //174
    BP2_CONST2(0.265234030285512,0.964184063951746),    //175
    BP2_CONST2(0.266712757474898,0.96377606579544),    //176
    BP2_CONST2(0.268190857063403,0.963365799780954),    //177
    BP2_CONST2(0.269668325572915,0.962953266873684),    //178
    BP2_CONST2(0.271145159526808,0.962538468044359),    //179
    BP2_CONST2(0.272621355449949,0.962121404269042),    //180
    BP2_CONST2(0.274096909868706,0.961702076529123),    //181
    BP2_CONST2(0.275571819310958,0.961280485811321),    //182
    BP2_CONST2(0.2770460803061,0.96085663310768),    //183
    BP2_CONST2(0.278519689385053,0.960430519415566),    //184
    BP2_CONST2(0.279992643080273,0.960002145737666),    //185
    BP2_CONST2(0.281464937925758,0.959571513081985),    //186
    BP2_CONST2(0.282936570457055,0.959138622461842),    //187
    BP2_CONST2(0.284407537211272,0.958703474895872),    //188
    BP2_CONST2(0.285877834727081,0.958266071408018),    //189
    BP2_CONST2(0.28734745954473,0.957826413027533),    //190
    BP2_CONST2(0.288816408206049,0.957384500788976),    //191
    BP2_CONST2(0.290284677254462,0.956940335732209),    //192
    BP2_CONST2(0.291752263234989,0.956493918902395),    //193
    BP2_CONST2(0.293219162694259,0.956045251349996),    //194
    BP2_CONST2(0.294685372180514,0.955594334130771),    //195
    BP2_CONST2(0.296150888243624,0.955141168305771),    //196
    BP2_CONST2(0.297615707435086,0.954685754941338),    //197
    BP2_CONST2(0.29907982630804,0.954228095109106),    //198
    BP2_CONST2(0.300543241417273,0.95376818988599),    //199
    BP2_CONST2(0.302005949319228,0.953306040354194),    //200
    BP2_CONST2(0.303467946572011,0.952841647601199),    //201
    BP2_CONST2(0.304929229735402,0.952375012719766),    //202
    BP2_CONST2(0.306389795370861,0.951906136807932),    //203
    BP2_CONST2(0.307849640041535,0.951435020969008),    //204
    BP2_CONST2(0.309308760312269,0.950961666311575),    //205
    BP2_CONST2(0.310767152749611,0.950486073949482),    //206
    BP2_CONST2(0.312224813921825,0.950008245001843),    //207
    BP2_CONST2(0.313681740398892,0.949528180593037),    //208
    BP2_CONST2(0.315137928752522,0.949045881852701),    //209
    BP2_CONST2(0.316593375556166,0.94856134991573),    //210
    BP2_CONST2(0.318048077385015,0.948074585922276),    //211
    BP2_CONST2(0.319502030816016,0.947585591017741),    //212
    BP2_CONST2(0.320955232427875,0.947094366352777),    //213
    BP2_CONST2(0.32240767880107,0.946600913083284),    //214
    BP2_CONST2(0.323859366517853,0.946105232370403),    //215
    BP2_CONST2(0.325310292162263,0.945607325380521),    //216
    BP2_CONST2(0.326760452320132,0.945107193285261),    //217
    BP2_CONST2(0.328209843579092,0.94460483726148),    //218
    BP2_CONST2(0.329658462528587,0.944100258491273),    //219
    BP2_CONST2(0.331106305759876,0.94359345816196),    //220
    BP2_CONST2(0.332553369866044,0.943084437466093),    //221
    BP2_CONST2(0.333999651442009,0.942573197601447),    //222
    BP2_CONST2(0.335445147084532,0.942059739771017),    //223
    BP2_CONST2(0.33688985339222,0.941544065183021),    //224
    BP2_CONST2(0.338333766965541,0.941026175050889),    //225
    BP2_CONST2(0.339776884406827,0.940506070593268),    //226
    BP2_CONST2(0.341219202320282,0.939983753034014),    //227
    BP2_CONST2(0.342660717311994,0.93945922360219),    //228
    BP2_CONST2(0.344101425989939,0.938932483532065),    //229
    BP2_CONST2(0.345541324963989,0.938403534063108),    //230
    BP2_CONST2(0.346980410845924,0.93787237643999),    //231
    BP2_CONST2(0.348418680249435,0.937339011912575),    //232
    BP2_CONST2(0.349856129790135,0.936803441735922),    //233
    BP2_CONST2(0.351292756085567,0.936265667170278),    //234
    BP2_CONST2(0.352728555755211,0.93572568948108),    //235
    BP2_CONST2(0.35416352542049,0.935183509938948),    //236
    BP2_CONST2(0.355597661704784,0.934639129819681),    //237
    BP2_CONST2(0.35703096123343,0.934092550404259),    //238
    BP2_CONST2(0.358463420633737,0.933543772978836),    //239
    BP2_CONST2(0.359895036534988,0.932992798834739),    //240
    BP2_CONST2(0.361325805568454,0.932439629268462),    //241
    BP2_CONST2(0.362755724367397,0.931884265581668),    //242
    BP2_CONST2(0.36418478956708,0.93132670908118),    //243
    BP2_CONST2(0.365612997804774,0.930766961078984),    //244
    BP2_CONST2(0.367040345719767,0.930205022892219),    //245
    BP2_CONST2(0.368466829953372,0.929640895843181),    //246
    BP2_CONST2(0.369892447148934,0.929074581259316),    //247
    BP2_CONST2(0.371317193951838,0.928506080473216),    //248
    BP2_CONST2(0.372741067009516,0.927935394822618),    //249
    BP2_CONST2(0.374164062971458,0.927362525650401),    //250
    BP2_CONST2(0.375586178489217,0.926787474304582),    //251
    BP2_CONST2(0.377007410216418,0.926210242138311),    //252
    BP2_CONST2(0.378427754808766,0.925630830509873),    //253
    BP2_CONST2(0.379847208924051,0.925049240782678),    //254
    BP2_CONST2(0.381265769222162,0.924465474325263),    //255
    BP2_CONST2(0.38268343236509,0.923879532511287),    //256
    BP2_CONST2(0.384100195016935,0.923291416719528),    //257
    BP2_CONST2(0.385516053843919,0.922701128333879),    //258
    BP2_CONST2(0.386931005514389,0.922108668743345),    //259
    BP2_CONST2(0.388345046698826,0.921514039342042),    //260
    BP2_CONST2(0.389758174069856,0.92091724152919),    //261
    BP2_CONST2(0.391170384302254,0.920318276709111),    //262
    BP2_CONST2(0.392581674072951,0.919717146291227),    //263
    BP2_CONST2(0.393992040061048,0.919113851690058),    //264
    BP2_CONST2(0.395401478947816,0.918508394325212),    //265
    BP2_CONST2(0.39680998741671,0.91790077562139),    //266
    BP2_CONST2(0.398217562153374,0.917290997008378),    //267
    BP2_CONST2(0.399624199845647,0.916679059921043),    //268
    BP2_CONST2(0.401029897183576,0.916064965799332),    //269
    BP2_CONST2(0.402434650859418,0.915448716088268),    //270
    BP2_CONST2(0.403838457567654,0.914830312237946),    //271
    BP2_CONST2(0.40524131400499,0.914209755703531),    //272
    BP2_CONST2(0.406643216870369,0.913587047945251),    //273
    BP2_CONST2(0.408044162864979,0.912962190428398),    //274
    BP2_CONST2(0.409444148692258,0.912335184623323),    //275
    BP2_CONST2(0.410843171057904,0.91170603200543),    //276
    BP2_CONST2(0.412241226669883,0.911074734055176),    //277
    BP2_CONST2(0.413638312238435,0.910441292258067),    //278
    BP2_CONST2(0.415034424476082,0.909805708104652),    //279
    BP2_CONST2(0.416429560097637,0.909167983090522),    //280
    BP2_CONST2(0.417823715820212,0.908528118716306),    //281
    BP2_CONST2(0.419216888363224,0.907886116487666),    //282
    BP2_CONST2(0.420609074448403,0.907241977915296),    //283
    BP2_CONST2(0.4220002707998,0.906595704514915),    //284
    BP2_CONST2(0.423390474143796,0.905947297807268),    //285
    BP2_CONST2(0.424779681209109,0.905296759318119),    //286
    BP2_CONST2(0.4261678887268,0.904644090578246),    //287
    BP2_CONST2(0.427555093430282,0.903989293123443),    //288
    BP2_CONST2(0.428941292055329,0.903332368494512),    //289
    BP2_CONST2(0.430326481340083,0.902673318237259),    //290
    BP2_CONST2(0.431710658025057,0.902012143902493),    //291
    BP2_CONST2(0.433093818853152,0.901348847046022),    //292
    BP2_CONST2(0.434475960569656,0.900683429228647),    //293
    BP2_CONST2(0.435857079922255,0.90001589201616),    //294
    BP2_CONST2(0.437237173661044,0.899346236979342),    //295
    BP2_CONST2(0.438616238538528,0.898674465693954),    //296
    BP2_CONST2(0.439994271309633,0.89800057974074),    //297
    BP2_CONST2(0.441371268731717,0.897324580705418),    //298
    BP2_CONST2(0.44274722756457,0.89664647017868),    //299
    BP2_CONST2(0.444122144570429,0.895966249756185),    //300
    BP2_CONST2(0.445496016513982,0.895283921038558),    //301
    BP2_CONST2(0.446868840162374,0.894599485631383),    //302
    BP2_CONST2(0.44824061228522,0.893912945145203),    //303
    BP2_CONST2(0.449611329654607,0.893224301195515),    //304
    BP2_CONST2(0.450980989045104,0.892533555402765),    //305
    BP2_CONST2(0.452349587233771,0.891840709392343),    //306
    BP2_CONST2(0.453717121000164,0.891145764794583),    //307
    BP2_CONST2(0.455083587126344,0.890448723244758),    //308
    BP2_CONST2(0.456448982396884,0.889749586383073),    //309
    BP2_CONST2(0.457813303598877,0.889048355854665),    //310
    BP2_CONST2(0.459176547521944,0.888345033309596),    //311
    BP2_CONST2(0.46053871095824,0.887639620402854),    //312
    BP2_CONST2(0.461899790702463,0.886932118794342),    //313
    BP2_CONST2(0.46325978355186,0.886222530148881),    //314
    BP2_CONST2(0.464618686306238,0.8855108561362),    //315
    BP2_CONST2(0.465976495767966,0.884797098430938),    //316
    BP2_CONST2(0.467333208741988,0.884081258712635),    //317
    BP2_CONST2(0.468688822035828,0.883363338665732),    //318
    BP2_CONST2(0.470043332459596,0.882643339979563),    //319
    BP2_CONST2(0.471396736825998,0.881921264348355),    //320
    BP2_CONST2(0.472749031950343,0.881197113471222),    //321
    BP2_CONST2(0.47410021465055,0.880470889052161),    //322
    BP2_CONST2(0.475450281747156,0.879742592800047),    //323
    BP2_CONST2(0.476799230063322,0.879012226428634),    //324
    BP2_CONST2(0.478147056424843,0.878279791656542),    //325
    BP2_CONST2(0.479493757660153,0.877545290207261),    //326
    BP2_CONST2(0.480839330600334,0.876808723809146),    //327
    BP2_CONST2(0.482183772079123,0.876070094195407),    //328
    BP2_CONST2(0.483527078932919,0.875329403104111),    //329
    BP2_CONST2(0.484869248000791,0.874586652278176),    //330
    BP2_CONST2(0.486210276124486,0.873841843465367),    //331
    BP2_CONST2(0.487550160148436,0.87309497841829),    //332
    BP2_CONST2(0.488888896919763,0.872346058894392),    //333
    BP2_CONST2(0.490226483288291,0.871595086655951),    //334
    BP2_CONST2(0.49156291610655,0.870842063470079),    //335
    BP2_CONST2(0.492898192229784,0.870086991108711),    //336
    BP2_CONST2(0.49423230851596,0.869329871348607),    //337
    BP2_CONST2(0.495565261825773,0.868570705971341),    //338
    BP2_CONST2(0.496897049022654,0.867809496763303),    //339
    BP2_CONST2(0.498227666972782,0.867046245515693),    //340
    BP2_CONST2(0.499557112545082,0.866280954024513),    //341
    BP2_CONST2(0.500885382611241,0.865513624090569),    //342
    BP2_CONST2(0.502212474045711,0.864744257519462),    //343
    BP2_CONST2(0.503538383725718,0.863972856121587),    //344
    BP2_CONST2(0.504863108531268,0.863199421712124),    //345
    BP2_CONST2(0.506186645345155,0.862423956111041),    //346
    BP2_CONST2(0.507508991052971,0.861646461143081),    //347
    BP2_CONST2(0.508830142543107,0.860866938637767),    //348
    BP2_CONST2(0.510150096706767,0.86008539042939),    //349
    BP2_CONST2(0.51146885043797,0.859301818357008),    //350
    BP2_CONST2(0.512786400633563,0.858516224264443),    //351
    BP2_CONST2(0.514102744193222,0.857728610000272),    //352
    BP2_CONST2(0.515417878019463,0.856938977417829),    //353
    BP2_CONST2(0.51673179901765,0.856147328375194),    //354
    BP2_CONST2(0.518044504095999,0.855353664735196),    //355
    BP2_CONST2(0.51935599016559,0.854557988365401),    //356
    BP2_CONST2(0.520666254140367,0.853760301138111),    //357
    BP2_CONST2(0.521975292937154,0.852960604930364),    //358
    BP2_CONST2(0.523283103475656,0.85215890162392),    //359
    BP2_CONST2(0.524589682678469,0.851355193105265),    //360
    BP2_CONST2(0.525895027471085,0.850549481265603),    //361
    BP2_CONST2(0.527199134781901,0.849741768000853),    //362
    BP2_CONST2(0.528502001542228,0.84893205521164),    //363
    BP2_CONST2(0.529803624686295,0.848120344803297),    //364
    BP2_CONST2(0.531104001151255,0.847306638685858),    //365
    BP2_CONST2(0.532403127877198,0.846490938774052),    //366
    BP2_CONST2(0.533701001807153,0.845673246987299),    //367
    BP2_CONST2(0.534997619887097,0.844853565249707),    //368
    BP2_CONST2(0.536292979065963,0.844031895490066),    //369
    BP2_CONST2(0.537587076295645,0.843208239641845),    //370
    BP2_CONST2(0.538879908531008,0.842382599643186),    //371
    BP2_CONST2(0.540171472729893,0.841554977436898),    //372
    BP2_CONST2(0.541461765853123,0.840725374970458),    //373
    BP2_CONST2(0.542750784864516,0.839893794196),    //374
    BP2_CONST2(0.544038526730884,0.839060237070313),    //375
    BP2_CONST2(0.545324988422046,0.838224705554838),    //376
    BP2_CONST2(0.546610166910835,0.837387201615662),    //377
    BP2_CONST2(0.5478940591731,0.836547727223512),    //378
    BP2_CONST2(0.54917666218772,0.835706284353753),    //379
    BP2_CONST2(0.550457972936605,0.83486287498638),    //380
    BP2_CONST2(0.551737988404707,0.834017501106018),    //381
    BP2_CONST2(0.553016705580027,0.833170164701913),    //382
    BP2_CONST2(0.55429412145362,0.83232086776793),    //383
    BP2_CONST2(0.555570233019602,0.831469612302545),    //384
    BP2_CONST2(0.55684503727516,0.830616400308846),    //385
    BP2_CONST2(0.558118531220556,0.829761233794523),    //386
    BP2_CONST2(0.559390711859136,0.828904114771865),    //387
    BP2_CONST2(0.560661576197336,0.828045045257756),    //388
    BP2_CONST2(0.561931121244689,0.827184027273669),    //389
    BP2_CONST2(0.563199344013834,0.826321062845664),    //390
    BP2_CONST2(0.564466241520519,0.825456154004378),    //391
    BP2_CONST2(0.565731810783613,0.824589302785025),    //392
    BP2_CONST2(0.566996048825109,0.823720511227391),    //393
    BP2_CONST2(0.568258952670131,0.822849781375826),    //394
    BP2_CONST2(0.569520519346947,0.821977115279242),    //395
    BP2_CONST2(0.570780745886967,0.821102514991105),    //396
    BP2_CONST2(0.572039629324757,0.820225982569435),    //397
    BP2_CONST2(0.573297166698042,0.819347520076797),    //398
    BP2_CONST2(0.574553355047716,0.818467129580299),    //399
    BP2_CONST2(0.575808191417845,0.817584813151584),    //400
    BP2_CONST2(0.577061672855679,0.816700572866828),    //401
    BP2_CONST2(0.578313796411656,0.815814410806734),    //402
    BP2_CONST2(0.579564559139406,0.814926329056527),    //403
    BP2_CONST2(0.580813958095765,0.814036329705948),    //404
    BP2_CONST2(0.582061990340775,0.813144414849254),    //405
    BP2_CONST2(0.583308652937698,0.812250586585204),    //406
    BP2_CONST2(0.584553942953015,0.811354847017064),    //407
    BP2_CONST2(0.585797857456439,0.810457198252595),    //408
    BP2_CONST2(0.587040393520918,0.809557642404051),    //409
    BP2_CONST2(0.588281548222645,0.808656181588175),    //410
    BP2_CONST2(0.589521318641064,0.80775281792619),    //411
    BP2_CONST2(0.590759701858874,0.806847553543799),    //412
    BP2_CONST2(0.591996694962041,0.805940390571176),    //413
    BP2_CONST2(0.5932322950398,0.805031331142964),    //414
    BP2_CONST2(0.594466499184664,0.804120377398266),    //415
    BP2_CONST2(0.595699304492433,0.803207531480645),    //416
    BP2_CONST2(0.596930708062197,0.802292795538116),    //417
    BP2_CONST2(0.598160706996342,0.80137617172314),    //418
    BP2_CONST2(0.599389298400565,0.800457662192623),    //419
    BP2_CONST2(0.600616479383869,0.799537269107905),    //420
    BP2_CONST2(0.60184224705858,0.798614994634761),    //421
    BP2_CONST2(0.603066598540348,0.797690840943391),    //422
    BP2_CONST2(0.604289530948156,0.796764810208419),    //423
    BP2_CONST2(0.605511041404326,0.795836904608884),    //424
    BP2_CONST2(0.606731127034524,0.794907126328237),    //425
    BP2_CONST2(0.607949784967774,0.793975477554337),    //426
    BP2_CONST2(0.609167012336453,0.793041960479444),    //427
    BP2_CONST2(0.610382806276309,0.792106577300212),    //428
    BP2_CONST2(0.611597163926462,0.79116933021769),    //429
    BP2_CONST2(0.61281008242941,0.79023022143731),    //430
    BP2_CONST2(0.614021558931038,0.789289253168886),    //431
    BP2_CONST2(0.615231590580627,0.788346427626606),    //432
    BP2_CONST2(0.616440174530854,0.787401747029031),    //433
    BP2_CONST2(0.617647307937804,0.786455213599086),    //434
    BP2_CONST2(0.618852987960976,0.785506829564054),    //435
    BP2_CONST2(0.620057211763289,0.784556597155575),    //436
    BP2_CONST2(0.621259976511088,0.783604518609638),    //437
    BP2_CONST2(0.62246127937415,0.782650596166576),    //438
    BP2_CONST2(0.623661117525695,0.781694832071059),    //439
    BP2_CONST2(0.624859488142386,0.780737228572094),    //440
    BP2_CONST2(0.626056388404344,0.779777787923015),    //441
    BP2_CONST2(0.627251815495144,0.778816512381476),    //442
    BP2_CONST2(0.628445766601833,0.777853404209453),    //443
    BP2_CONST2(0.629638238914927,0.776888465673232),    //444
    BP2_CONST2(0.630829229628424,0.775921699043408),    //445
    BP2_CONST2(0.632018735939809,0.774953106594874),    //446
    BP2_CONST2(0.633206755050057,0.773982690606823),    //447
    BP2_CONST2(0.634393284163645,0.773010453362737),    //448
    BP2_CONST2(0.635578320488556,0.772036397150385),    //449
    BP2_CONST2(0.636761861236284,0.771060524261814),    //450
    BP2_CONST2(0.637943903621844,0.770082836993348),    //451
    BP2_CONST2(0.639124444863776,0.76910333764558),    //452
    BP2_CONST2(0.640303482184152,0.768122028523365),    //453
    BP2_CONST2(0.641481012808583,0.76713891193582),    //454
    BP2_CONST2(0.642657033966227,0.766153990196313),    //455
    BP2_CONST2(0.643831542889791,0.765167265622459),    //456
    BP2_CONST2(0.645004536815544,0.764178740536117),    //457
    BP2_CONST2(0.646176012983316,0.763188417263381),    //458
    BP2_CONST2(0.647345968636512,0.762196298134579),    //459
    BP2_CONST2(0.648514401022112,0.761202385484262),    //460
    BP2_CONST2(0.649681307390683,0.760206681651202),    //461
    BP2_CONST2(0.650846684996381,0.759209188978388),    //462
    BP2_CONST2(0.65201053109696,0.758209909813015),    //463
    BP2_CONST2(0.653172842953777,0.757208846506485),    //464
    BP2_CONST2(0.6543336178318,0.756206001414395),    //465
    BP2_CONST2(0.655492852999615,0.755201376896537),    //466
    BP2_CONST2(0.656650545729429,0.754194975316889),    //467
    BP2_CONST2(0.657806693297079,0.753186799043613),    //468
    BP2_CONST2(0.658961292982037,0.752176850449043),    //469
    BP2_CONST2(0.66011434206742,0.751165131909686),    //470
    BP2_CONST2(0.661265837839992,0.750151645806215),    //471
    BP2_CONST2(0.662415777590172,0.749136394523459),    //472
    BP2_CONST2(0.66356415861204,0.748119380450404),    //473
    BP2_CONST2(0.664710978203345,0.74710060598018),    //474
    BP2_CONST2(0.66585623366551,0.746080073510064),    //475
    BP2_CONST2(0.666999922303637,0.745057785441466),    //476
    BP2_CONST2(0.668142041426518,0.744033744179929),    //477
    BP2_CONST2(0.669282588346636,0.743007952135122),    //478
    BP2_CONST2(0.670421560380173,0.741980411720831),    //479
    BP2_CONST2(0.671558954847018,0.740951125354959),    //480
    BP2_CONST2(0.672694769070773,0.739920095459516),    //481
    BP2_CONST2(0.673829000378756,0.738887324460615),    //482
    BP2_CONST2(0.674961646102012,0.737852814788466),    //483
    BP2_CONST2(0.676092703575316,0.73681656887737),    //484
    BP2_CONST2(0.67722217013718,0.735778589165714),    //485
    BP2_CONST2(0.678350043129861,0.734738878095963),    //486
    BP2_CONST2(0.679476319899365,0.73369743811466),    //487
    BP2_CONST2(0.680600997795453,0.732654271672413),    //488
    BP2_CONST2(0.68172407417165,0.731609381223893),    //489
    BP2_CONST2(0.682845546385248,0.730562769227828),    //490
    BP2_CONST2(0.683965411797315,0.729514438146997),    //491
    BP2_CONST2(0.6850836677727,0.728464390448225),    //492
    BP2_CONST2(0.686200311680039,0.727412628602376),    //493
    BP2_CONST2(0.687315340891759,0.726359155084346),    //494
    BP2_CONST2(0.68842875278409,0.725303972373061),    //495
    BP2_CONST2(0.689540544737067,0.724247082951467),    //496
    BP2_CONST2(0.690650714134535,0.723188489306527),    //497
    BP2_CONST2(0.691759258364158,0.722128193929215),    //498
    BP2_CONST2(0.692866174817425,0.721066199314508),    //499
    BP2_CONST2(0.693971460889654,0.720002507961382),    //500
    BP2_CONST2(0.695075113980001,0.718937122372804),    //501
    BP2_CONST2(0.696177131491463,0.717870045055732),    //502
    BP2_CONST2(0.697277510830887,0.7168012785211),    //503
    BP2_CONST2(0.698376249408973,0.715730825283819),    //504
    BP2_CONST2(0.699473344640284,0.714658687862769),    //505
    BP2_CONST2(0.700568793943248,0.713584868780794),    //506
    BP2_CONST2(0.701662594740168,0.712509370564692),    //507
    BP2_CONST2(0.702754744457225,0.711432195745216),    //508
    BP2_CONST2(0.703845240524485,0.710353346857062),    //509
    BP2_CONST2(0.704934080375905,0.709272826438866),    //510
    BP2_CONST2(0.70602126144934,0.708190637033195),    //511
    BP2_CONST2(0.707106781186547,0.707106781186548)    //512
};

#if 1

#define TRIGTBL(i,j) lpc_trig2048[((i)<<(iShrink+1))+(j)]

#else
// When I tried to use separate tables to pulling unnecessary stuff into the cache 
// on smaller transforms, it had no effect on performancer

#define TRIGTBL(i,j) lpc_Trigs[iShrink][((i)<<1)+(j)]

const BP2Type lpc_trig1024[] = {
    BP2_CONST2(0,1),    //0
    BP2_CONST2(0.00306795676296598,0.999995293809576),    //1
    BP2_CONST2(0.00613588464915448,0.999981175282601),    //2
    BP2_CONST2(0.00920375478205982,0.999957644551964),    //3
    BP2_CONST2(0.0122715382857199,0.999924701839145),    //4
    BP2_CONST2(0.0153392062849881,0.999882347454213),    //5
    BP2_CONST2(0.0184067299058048,0.999830581795823),    //6
    BP2_CONST2(0.0214740802754695,0.999769405351215),    //7
    BP2_CONST2(0.0245412285229123,0.999698818696204),    //8
    BP2_CONST2(0.0276081457789657,0.999618822495179),    //9
    BP2_CONST2(0.0306748031766366,0.999529417501093),    //10
    BP2_CONST2(0.0337411718513776,0.999430604555462),    //11
    BP2_CONST2(0.0368072229413588,0.99932238458835),    //12
    BP2_CONST2(0.0398729275877398,0.999204758618364),    //13
    BP2_CONST2(0.0429382569349408,0.999077727752645),    //14
    BP2_CONST2(0.0460031821309146,0.998941293186857),    //15
    BP2_CONST2(0.049067674327418,0.998795456205172),    //16
    BP2_CONST2(0.0521317046802833,0.998640218180265),    //17
    BP2_CONST2(0.0551952443496899,0.998475580573295),    //18
    BP2_CONST2(0.0582582645004358,0.998301544933893),    //19
    BP2_CONST2(0.0613207363022086,0.998118112900149),    //20
    BP2_CONST2(0.0643826309298575,0.997925286198596),    //21
    BP2_CONST2(0.0674439195636641,0.997723066644192),    //22
    BP2_CONST2(0.0705045733896139,0.997511456140303),    //23
    BP2_CONST2(0.0735645635996674,0.99729045667869),    //24
    BP2_CONST2(0.0766238613920315,0.997060070339483),    //25
    BP2_CONST2(0.0796824379714301,0.996820299291166),    //26
    BP2_CONST2(0.0827402645493757,0.996571145790555),    //27
    BP2_CONST2(0.0857973123444399,0.996312612182778),    //28
    BP2_CONST2(0.0888535525825246,0.996044700901252),    //29
    BP2_CONST2(0.0919089564971327,0.99576741446766),    //30
    BP2_CONST2(0.094963495329639,0.995480755491927),    //31
    BP2_CONST2(0.0980171403295606,0.995184726672197),    //32
    BP2_CONST2(0.101069862754828,0.994879330794806),    //33
    BP2_CONST2(0.104121633872055,0.994564570734255),    //34
    BP2_CONST2(0.107172424956809,0.994240449453188),    //35
    BP2_CONST2(0.110222207293883,0.993906970002356),    //36
    BP2_CONST2(0.113270952177564,0.993564135520595),    //37
    BP2_CONST2(0.116318630911905,0.993211949234794),    //38
    BP2_CONST2(0.119365214810991,0.992850414459865),    //39
    BP2_CONST2(0.122410675199216,0.99247953459871),    //40
    BP2_CONST2(0.125454983411546,0.992099313142192),    //41
    BP2_CONST2(0.128498110793793,0.9917097536691),    //42
    BP2_CONST2(0.131540028702883,0.991310859846115),    //43
    BP2_CONST2(0.134580708507126,0.99090263542778),    //44
    BP2_CONST2(0.137620121586486,0.990485084256457),    //45
    BP2_CONST2(0.140658239332849,0.990058210262297),    //46
    BP2_CONST2(0.143695033150294,0.989622017463201),    //47
    BP2_CONST2(0.146730474455362,0.989176509964781),    //48
    BP2_CONST2(0.149764534677322,0.988721691960324),    //49
    BP2_CONST2(0.152797185258443,0.988257567730749),    //50
    BP2_CONST2(0.155828397654265,0.987784141644572),    //51
    BP2_CONST2(0.158858143333861,0.987301418157858),    //52
    BP2_CONST2(0.161886393780112,0.986809401814186),    //53
    BP2_CONST2(0.16491312048997,0.986308097244599),    //54
    BP2_CONST2(0.167938294974731,0.985797509167567),    //55
    BP2_CONST2(0.170961888760301,0.985277642388941),    //56
    BP2_CONST2(0.173983873387464,0.984748501801904),    //57
    BP2_CONST2(0.177004220412149,0.984210092386929),    //58
    BP2_CONST2(0.1800229014057,0.98366241921173),    //59
    BP2_CONST2(0.183039887955141,0.983105487431216),    //60
    BP2_CONST2(0.186055151663447,0.982539302287441),    //61
    BP2_CONST2(0.189068664149806,0.981963869109555),    //62
    BP2_CONST2(0.192080397049892,0.981379193313755),    //63
    BP2_CONST2(0.195090322016128,0.98078528040323),    //64
    BP2_CONST2(0.198098410717954,0.980182135968117),    //65
    BP2_CONST2(0.201104634842092,0.979569765685441),    //66
    BP2_CONST2(0.204108966092817,0.978948175319062),    //67
    BP2_CONST2(0.207111376192219,0.978317370719628),    //68
    BP2_CONST2(0.21011183688047,0.97767735782451),    //69
    BP2_CONST2(0.213110319916091,0.977028142657754),    //70
    BP2_CONST2(0.21610679707622,0.976369731330021),    //71
    BP2_CONST2(0.21910124015687,0.975702130038529),    //72
    BP2_CONST2(0.222093620973204,0.975025345066994),    //73
    BP2_CONST2(0.225083911359793,0.974339382785576),    //74
    BP2_CONST2(0.228072083170886,0.973644249650812),    //75
    BP2_CONST2(0.231058108280671,0.97293995220556),    //76
    BP2_CONST2(0.234041958583543,0.972226497078936),    //77
    BP2_CONST2(0.237023605994367,0.971503890986252),    //78
    BP2_CONST2(0.240003022448741,0.97077214072895),    //79
    BP2_CONST2(0.242980179903264,0.970031253194544),    //80
    BP2_CONST2(0.245955050335795,0.969281235356549),    //81
    BP2_CONST2(0.24892760574572,0.968522094274417),    //82
    BP2_CONST2(0.251897818154217,0.967753837093476),    //83
    BP2_CONST2(0.254865659604515,0.966976471044852),    //84
    BP2_CONST2(0.257831102162159,0.966190003445413),    //85
    BP2_CONST2(0.260794117915276,0.965394441697689),    //86
    BP2_CONST2(0.263754678974831,0.964589793289813),    //87
    BP2_CONST2(0.266712757474898,0.96377606579544),    //88
    BP2_CONST2(0.269668325572915,0.962953266873684),    //89
    BP2_CONST2(0.272621355449949,0.962121404269042),    //90
    BP2_CONST2(0.275571819310958,0.961280485811321),    //91
    BP2_CONST2(0.278519689385053,0.960430519415566),    //92
    BP2_CONST2(0.281464937925758,0.959571513081985),    //93
    BP2_CONST2(0.284407537211272,0.958703474895872),    //94
    BP2_CONST2(0.28734745954473,0.957826413027533),    //95
    BP2_CONST2(0.290284677254462,0.956940335732209),    //96
    BP2_CONST2(0.293219162694259,0.956045251349996),    //97
    BP2_CONST2(0.296150888243624,0.955141168305771),    //98
    BP2_CONST2(0.29907982630804,0.954228095109106),    //99
    BP2_CONST2(0.302005949319228,0.953306040354194),    //100
    BP2_CONST2(0.304929229735402,0.952375012719766),    //101
    BP2_CONST2(0.307849640041535,0.951435020969008),    //102
    BP2_CONST2(0.310767152749611,0.950486073949482),    //103
    BP2_CONST2(0.313681740398892,0.949528180593037),    //104
    BP2_CONST2(0.316593375556166,0.94856134991573),    //105
    BP2_CONST2(0.319502030816016,0.947585591017741),    //106
    BP2_CONST2(0.32240767880107,0.946600913083284),    //107
    BP2_CONST2(0.325310292162263,0.945607325380521),    //108
    BP2_CONST2(0.328209843579092,0.94460483726148),    //109
    BP2_CONST2(0.331106305759876,0.94359345816196),    //110
    BP2_CONST2(0.333999651442009,0.942573197601447),    //111
    BP2_CONST2(0.33688985339222,0.941544065183021),    //112
    BP2_CONST2(0.339776884406827,0.940506070593268),    //113
    BP2_CONST2(0.342660717311994,0.93945922360219),    //114
    BP2_CONST2(0.345541324963989,0.938403534063108),    //115
    BP2_CONST2(0.348418680249435,0.937339011912575),    //116
    BP2_CONST2(0.351292756085567,0.936265667170278),    //117
    BP2_CONST2(0.35416352542049,0.935183509938948),    //118
    BP2_CONST2(0.35703096123343,0.934092550404259),    //119
    BP2_CONST2(0.359895036534988,0.932992798834739),    //120
    BP2_CONST2(0.362755724367397,0.931884265581668),    //121
    BP2_CONST2(0.365612997804774,0.930766961078984),    //122
    BP2_CONST2(0.368466829953372,0.929640895843181),    //123
    BP2_CONST2(0.371317193951838,0.928506080473216),    //124
    BP2_CONST2(0.374164062971458,0.927362525650401),    //125
    BP2_CONST2(0.377007410216418,0.926210242138311),    //126
    BP2_CONST2(0.379847208924051,0.925049240782678),    //127
    BP2_CONST2(0.38268343236509,0.923879532511287),    //128
    BP2_CONST2(0.385516053843919,0.922701128333879),    //129
    BP2_CONST2(0.388345046698826,0.921514039342042),    //130
    BP2_CONST2(0.391170384302254,0.920318276709111),    //131
    BP2_CONST2(0.393992040061048,0.919113851690058),    //132
    BP2_CONST2(0.39680998741671,0.91790077562139),    //133
    BP2_CONST2(0.399624199845647,0.916679059921043),    //134
    BP2_CONST2(0.402434650859418,0.915448716088268),    //135
    BP2_CONST2(0.40524131400499,0.914209755703531),    //136
    BP2_CONST2(0.408044162864979,0.912962190428398),    //137
    BP2_CONST2(0.410843171057904,0.91170603200543),    //138
    BP2_CONST2(0.413638312238435,0.910441292258067),    //139
    BP2_CONST2(0.416429560097637,0.909167983090522),    //140
    BP2_CONST2(0.419216888363224,0.907886116487666),    //141
    BP2_CONST2(0.4220002707998,0.906595704514915),    //142
    BP2_CONST2(0.424779681209109,0.905296759318119),    //143
    BP2_CONST2(0.427555093430282,0.903989293123443),    //144
    BP2_CONST2(0.430326481340083,0.902673318237259),    //145
    BP2_CONST2(0.433093818853152,0.901348847046022),    //146
    BP2_CONST2(0.435857079922255,0.90001589201616),    //147
    BP2_CONST2(0.438616238538528,0.898674465693954),    //148
    BP2_CONST2(0.441371268731717,0.897324580705418),    //149
    BP2_CONST2(0.444122144570429,0.895966249756185),    //150
    BP2_CONST2(0.446868840162374,0.894599485631383),    //151
    BP2_CONST2(0.449611329654607,0.893224301195515),    //152
    BP2_CONST2(0.452349587233771,0.891840709392343),    //153
    BP2_CONST2(0.455083587126344,0.890448723244758),    //154
    BP2_CONST2(0.457813303598877,0.889048355854665),    //155
    BP2_CONST2(0.46053871095824,0.887639620402854),    //156
    BP2_CONST2(0.46325978355186,0.886222530148881),    //157
    BP2_CONST2(0.465976495767966,0.884797098430938),    //158
    BP2_CONST2(0.468688822035828,0.883363338665732),    //159
    BP2_CONST2(0.471396736825998,0.881921264348355),    //160
    BP2_CONST2(0.47410021465055,0.880470889052161),    //161
    BP2_CONST2(0.476799230063322,0.879012226428634),    //162
    BP2_CONST2(0.479493757660153,0.877545290207261),    //163
    BP2_CONST2(0.482183772079123,0.876070094195407),    //164
    BP2_CONST2(0.484869248000791,0.874586652278176),    //165
    BP2_CONST2(0.487550160148436,0.87309497841829),    //166
    BP2_CONST2(0.490226483288291,0.871595086655951),    //167
    BP2_CONST2(0.492898192229784,0.870086991108711),    //168
    BP2_CONST2(0.495565261825773,0.868570705971341),    //169
    BP2_CONST2(0.498227666972782,0.867046245515693),    //170
    BP2_CONST2(0.500885382611241,0.865513624090569),    //171
    BP2_CONST2(0.503538383725718,0.863972856121587),    //172
    BP2_CONST2(0.506186645345155,0.862423956111041),    //173
    BP2_CONST2(0.508830142543107,0.860866938637767),    //174
    BP2_CONST2(0.51146885043797,0.859301818357008),    //175
    BP2_CONST2(0.514102744193222,0.857728610000272),    //176
    BP2_CONST2(0.51673179901765,0.856147328375194),    //177
    BP2_CONST2(0.51935599016559,0.854557988365401),    //178
    BP2_CONST2(0.521975292937154,0.852960604930364),    //179
    BP2_CONST2(0.524589682678469,0.851355193105265),    //180
    BP2_CONST2(0.527199134781901,0.849741768000853),    //181
    BP2_CONST2(0.529803624686295,0.848120344803297),    //182
    BP2_CONST2(0.532403127877198,0.846490938774052),    //183
    BP2_CONST2(0.534997619887097,0.844853565249707),    //184
    BP2_CONST2(0.537587076295645,0.843208239641845),    //185
    BP2_CONST2(0.540171472729893,0.841554977436898),    //186
    BP2_CONST2(0.542750784864516,0.839893794196),    //187
    BP2_CONST2(0.545324988422046,0.838224705554838),    //188
    BP2_CONST2(0.5478940591731,0.836547727223512),    //189
    BP2_CONST2(0.550457972936605,0.83486287498638),    //190
    BP2_CONST2(0.553016705580027,0.833170164701913),    //191
    BP2_CONST2(0.555570233019602,0.831469612302545),    //192
    BP2_CONST2(0.558118531220556,0.829761233794523),    //193
    BP2_CONST2(0.560661576197336,0.828045045257756),    //194
    BP2_CONST2(0.563199344013834,0.826321062845664),    //195
    BP2_CONST2(0.565731810783613,0.824589302785025),    //196
    BP2_CONST2(0.568258952670131,0.822849781375826),    //197
    BP2_CONST2(0.570780745886967,0.821102514991105),    //198
    BP2_CONST2(0.573297166698042,0.819347520076797),    //199
    BP2_CONST2(0.575808191417845,0.817584813151584),    //200
    BP2_CONST2(0.578313796411656,0.815814410806734),    //201
    BP2_CONST2(0.580813958095765,0.814036329705948),    //202
    BP2_CONST2(0.583308652937698,0.812250586585204),    //203
    BP2_CONST2(0.585797857456439,0.810457198252595),    //204
    BP2_CONST2(0.588281548222645,0.808656181588175),    //205
    BP2_CONST2(0.590759701858874,0.806847553543799),    //206
    BP2_CONST2(0.5932322950398,0.805031331142964),    //207
    BP2_CONST2(0.595699304492433,0.803207531480645),    //208
    BP2_CONST2(0.598160706996342,0.80137617172314),    //209
    BP2_CONST2(0.600616479383869,0.799537269107905),    //210
    BP2_CONST2(0.603066598540348,0.797690840943391),    //211
    BP2_CONST2(0.605511041404326,0.795836904608884),    //212
    BP2_CONST2(0.607949784967774,0.793975477554337),    //213
    BP2_CONST2(0.610382806276309,0.792106577300212),    //214
    BP2_CONST2(0.61281008242941,0.79023022143731),    //215
    BP2_CONST2(0.615231590580627,0.788346427626606),    //216
    BP2_CONST2(0.617647307937804,0.786455213599086),    //217
    BP2_CONST2(0.620057211763289,0.784556597155575),    //218
    BP2_CONST2(0.62246127937415,0.782650596166576),    //219
    BP2_CONST2(0.624859488142386,0.780737228572094),    //220
    BP2_CONST2(0.627251815495144,0.778816512381476),    //221
    BP2_CONST2(0.629638238914927,0.776888465673232),    //222
    BP2_CONST2(0.632018735939809,0.774953106594874),    //223
    BP2_CONST2(0.634393284163645,0.773010453362737),    //224
    BP2_CONST2(0.636761861236284,0.771060524261814),    //225
    BP2_CONST2(0.639124444863776,0.76910333764558),    //226
    BP2_CONST2(0.641481012808583,0.76713891193582),    //227
    BP2_CONST2(0.643831542889791,0.765167265622459),    //228
    BP2_CONST2(0.646176012983316,0.763188417263381),    //229
    BP2_CONST2(0.648514401022112,0.761202385484262),    //230
    BP2_CONST2(0.650846684996381,0.759209188978388),    //231
    BP2_CONST2(0.653172842953777,0.757208846506485),    //232
    BP2_CONST2(0.655492852999615,0.755201376896537),    //233
    BP2_CONST2(0.657806693297079,0.753186799043613),    //234
    BP2_CONST2(0.66011434206742,0.751165131909686),    //235
    BP2_CONST2(0.662415777590172,0.749136394523459),    //236
    BP2_CONST2(0.664710978203345,0.74710060598018),    //237
    BP2_CONST2(0.666999922303637,0.745057785441466),    //238
    BP2_CONST2(0.669282588346636,0.743007952135122),    //239
    BP2_CONST2(0.671558954847018,0.740951125354959),    //240
    BP2_CONST2(0.673829000378756,0.738887324460615),    //241
    BP2_CONST2(0.676092703575316,0.73681656887737),    //242
    BP2_CONST2(0.678350043129861,0.734738878095963),    //243
    BP2_CONST2(0.680600997795453,0.732654271672413),    //244
    BP2_CONST2(0.682845546385248,0.730562769227828),    //245
    BP2_CONST2(0.6850836677727,0.728464390448225),    //246
    BP2_CONST2(0.687315340891759,0.726359155084346),    //247
    BP2_CONST2(0.689540544737067,0.724247082951467),    //248
    BP2_CONST2(0.691759258364158,0.722128193929215),    //249
    BP2_CONST2(0.693971460889654,0.720002507961382),    //250
    BP2_CONST2(0.696177131491463,0.717870045055732),    //251
    BP2_CONST2(0.698376249408973,0.715730825283819),    //252
    BP2_CONST2(0.700568793943248,0.713584868780794),    //253
    BP2_CONST2(0.702754744457225,0.711432195745216),    //254
    BP2_CONST2(0.704934080375905,0.709272826438866),    //255
    BP2_CONST2(0.707106781186547,0.707106781186548)     //256
};

const BP2Type lpc_trig512[] = {
    BP2_CONST2(0,1),    //0
    BP2_CONST2(0.00613588464915448,0.999981175282601),    //1
    BP2_CONST2(0.0122715382857199,0.999924701839145),    //2
    BP2_CONST2(0.0184067299058048,0.999830581795823),    //3
    BP2_CONST2(0.0245412285229123,0.999698818696204),    //4
    BP2_CONST2(0.0306748031766366,0.999529417501093),    //5
    BP2_CONST2(0.0368072229413588,0.99932238458835),    //6
    BP2_CONST2(0.0429382569349408,0.999077727752645),    //7
    BP2_CONST2(0.049067674327418,0.998795456205172),    //8
    BP2_CONST2(0.0551952443496899,0.998475580573295),    //9
    BP2_CONST2(0.0613207363022086,0.998118112900149),    //10
    BP2_CONST2(0.0674439195636641,0.997723066644192),    //11
    BP2_CONST2(0.0735645635996674,0.99729045667869),    //12
    BP2_CONST2(0.0796824379714301,0.996820299291166),    //13
    BP2_CONST2(0.0857973123444399,0.996312612182778),    //14
    BP2_CONST2(0.0919089564971327,0.99576741446766),    //15
    BP2_CONST2(0.0980171403295606,0.995184726672197),    //16
    BP2_CONST2(0.104121633872055,0.994564570734255),    //17
    BP2_CONST2(0.110222207293883,0.993906970002356),    //18
    BP2_CONST2(0.116318630911905,0.993211949234794),    //19
    BP2_CONST2(0.122410675199216,0.99247953459871),    //20
    BP2_CONST2(0.128498110793793,0.9917097536691),    //21
    BP2_CONST2(0.134580708507126,0.99090263542778),    //22
    BP2_CONST2(0.140658239332849,0.990058210262297),    //23
    BP2_CONST2(0.146730474455362,0.989176509964781),    //24
    BP2_CONST2(0.152797185258443,0.988257567730749),    //25
    BP2_CONST2(0.158858143333861,0.987301418157858),    //26
    BP2_CONST2(0.16491312048997,0.986308097244599),    //27
    BP2_CONST2(0.170961888760301,0.985277642388941),    //28
    BP2_CONST2(0.177004220412149,0.984210092386929),    //29
    BP2_CONST2(0.183039887955141,0.983105487431216),    //30
    BP2_CONST2(0.189068664149806,0.981963869109555),    //31
    BP2_CONST2(0.195090322016128,0.98078528040323),    //32
    BP2_CONST2(0.201104634842092,0.979569765685441),    //33
    BP2_CONST2(0.207111376192219,0.978317370719628),    //34
    BP2_CONST2(0.213110319916091,0.977028142657754),    //35
    BP2_CONST2(0.21910124015687,0.975702130038529),    //36
    BP2_CONST2(0.225083911359793,0.974339382785576),    //37
    BP2_CONST2(0.231058108280671,0.97293995220556),    //38
    BP2_CONST2(0.237023605994367,0.971503890986252),    //39
    BP2_CONST2(0.242980179903264,0.970031253194544),    //40
    BP2_CONST2(0.24892760574572,0.968522094274417),    //41
    BP2_CONST2(0.254865659604515,0.966976471044852),    //42
    BP2_CONST2(0.260794117915276,0.965394441697689),    //43
    BP2_CONST2(0.266712757474898,0.96377606579544),    //44
    BP2_CONST2(0.272621355449949,0.962121404269042),    //45
    BP2_CONST2(0.278519689385053,0.960430519415566),    //46
    BP2_CONST2(0.284407537211272,0.958703474895872),    //47
    BP2_CONST2(0.290284677254462,0.956940335732209),    //48
    BP2_CONST2(0.296150888243624,0.955141168305771),    //49
    BP2_CONST2(0.302005949319228,0.953306040354194),    //50
    BP2_CONST2(0.307849640041535,0.951435020969008),    //51
    BP2_CONST2(0.313681740398892,0.949528180593037),    //52
    BP2_CONST2(0.319502030816016,0.947585591017741),    //53
    BP2_CONST2(0.325310292162263,0.945607325380521),    //54
    BP2_CONST2(0.331106305759876,0.94359345816196),    //55
    BP2_CONST2(0.33688985339222,0.941544065183021),    //56
    BP2_CONST2(0.342660717311994,0.93945922360219),    //57
    BP2_CONST2(0.348418680249435,0.937339011912575),    //58
    BP2_CONST2(0.35416352542049,0.935183509938948),    //59
    BP2_CONST2(0.359895036534988,0.932992798834739),    //60
    BP2_CONST2(0.365612997804774,0.930766961078984),    //61
    BP2_CONST2(0.371317193951838,0.928506080473216),    //62
    BP2_CONST2(0.377007410216418,0.926210242138311),    //63
    BP2_CONST2(0.38268343236509,0.923879532511287),    //64
    BP2_CONST2(0.388345046698826,0.921514039342042),    //65
    BP2_CONST2(0.393992040061048,0.919113851690058),    //66
    BP2_CONST2(0.399624199845647,0.916679059921043),    //67
    BP2_CONST2(0.40524131400499,0.914209755703531),    //68
    BP2_CONST2(0.410843171057904,0.91170603200543),    //69
    BP2_CONST2(0.416429560097637,0.909167983090522),    //70
    BP2_CONST2(0.4220002707998,0.906595704514915),    //71
    BP2_CONST2(0.427555093430282,0.903989293123443),    //72
    BP2_CONST2(0.433093818853152,0.901348847046022),    //73
    BP2_CONST2(0.438616238538528,0.898674465693954),    //74
    BP2_CONST2(0.444122144570429,0.895966249756185),    //75
    BP2_CONST2(0.449611329654607,0.893224301195515),    //76
    BP2_CONST2(0.455083587126344,0.890448723244758),    //77
    BP2_CONST2(0.46053871095824,0.887639620402854),    //78
    BP2_CONST2(0.465976495767966,0.884797098430938),    //79
    BP2_CONST2(0.471396736825998,0.881921264348355),    //80
    BP2_CONST2(0.476799230063322,0.879012226428634),    //81
    BP2_CONST2(0.482183772079123,0.876070094195407),    //82
    BP2_CONST2(0.487550160148436,0.87309497841829),    //83
    BP2_CONST2(0.492898192229784,0.870086991108711),    //84
    BP2_CONST2(0.498227666972782,0.867046245515693),    //85
    BP2_CONST2(0.503538383725718,0.863972856121587),    //86
    BP2_CONST2(0.508830142543107,0.860866938637767),    //87
    BP2_CONST2(0.514102744193222,0.857728610000272),    //88
    BP2_CONST2(0.51935599016559,0.854557988365401),    //89
    BP2_CONST2(0.524589682678469,0.851355193105265),    //90
    BP2_CONST2(0.529803624686295,0.848120344803297),    //91
    BP2_CONST2(0.534997619887097,0.844853565249707),    //92
    BP2_CONST2(0.540171472729893,0.841554977436898),    //93
    BP2_CONST2(0.545324988422046,0.838224705554838),    //94
    BP2_CONST2(0.550457972936605,0.83486287498638),    //95
    BP2_CONST2(0.555570233019602,0.831469612302545),    //96
    BP2_CONST2(0.560661576197336,0.828045045257756),    //97
    BP2_CONST2(0.565731810783613,0.824589302785025),    //98
    BP2_CONST2(0.570780745886967,0.821102514991105),    //99
    BP2_CONST2(0.575808191417845,0.817584813151584),    //100
    BP2_CONST2(0.580813958095765,0.814036329705948),    //101
    BP2_CONST2(0.585797857456439,0.810457198252595),    //102
    BP2_CONST2(0.590759701858874,0.806847553543799),    //103
    BP2_CONST2(0.595699304492433,0.803207531480645),    //104
    BP2_CONST2(0.600616479383869,0.799537269107905),    //105
    BP2_CONST2(0.605511041404326,0.795836904608884),    //106
    BP2_CONST2(0.610382806276309,0.792106577300212),    //107
    BP2_CONST2(0.615231590580627,0.788346427626606),    //108
    BP2_CONST2(0.620057211763289,0.784556597155575),    //109
    BP2_CONST2(0.624859488142386,0.780737228572094),    //110
    BP2_CONST2(0.629638238914927,0.776888465673232),    //111
    BP2_CONST2(0.634393284163645,0.773010453362737),    //112
    BP2_CONST2(0.639124444863776,0.76910333764558),    //113
    BP2_CONST2(0.643831542889791,0.765167265622459),    //114
    BP2_CONST2(0.648514401022112,0.761202385484262),    //115
    BP2_CONST2(0.653172842953777,0.757208846506485),    //116
    BP2_CONST2(0.657806693297079,0.753186799043613),    //117
    BP2_CONST2(0.662415777590172,0.749136394523459),    //118
    BP2_CONST2(0.666999922303637,0.745057785441466),    //119
    BP2_CONST2(0.671558954847018,0.740951125354959),    //120
    BP2_CONST2(0.676092703575316,0.73681656887737),    //121
    BP2_CONST2(0.680600997795453,0.732654271672413),    //122
    BP2_CONST2(0.6850836677727,0.728464390448225),    //123
    BP2_CONST2(0.689540544737067,0.724247082951467),    //124
    BP2_CONST2(0.693971460889654,0.720002507961382),    //125
    BP2_CONST2(0.698376249408973,0.715730825283819),    //126
    BP2_CONST2(0.702754744457225,0.711432195745216),    //127
    BP2_CONST2(0.707106781186547,0.707106781186548)     //128
};
const BP2Type lpc_trig256[] = {
    BP2_CONST2(0,1),    //0
    BP2_CONST2(0.0122715382857199,0.999924701839145),    //1
    BP2_CONST2(0.0245412285229123,0.999698818696204),    //2
    BP2_CONST2(0.0368072229413588,0.99932238458835),    //3
    BP2_CONST2(0.049067674327418,0.998795456205172),    //4
    BP2_CONST2(0.0613207363022086,0.998118112900149),    //5
    BP2_CONST2(0.0735645635996674,0.99729045667869),    //6
    BP2_CONST2(0.0857973123444399,0.996312612182778),    //7
    BP2_CONST2(0.0980171403295606,0.995184726672197),    //8
    BP2_CONST2(0.110222207293883,0.993906970002356),    //9
    BP2_CONST2(0.122410675199216,0.99247953459871),    //10
    BP2_CONST2(0.134580708507126,0.99090263542778),    //11
    BP2_CONST2(0.146730474455362,0.989176509964781),    //12
    BP2_CONST2(0.158858143333861,0.987301418157858),    //13
    BP2_CONST2(0.170961888760301,0.985277642388941),    //14
    BP2_CONST2(0.183039887955141,0.983105487431216),    //15
    BP2_CONST2(0.195090322016128,0.98078528040323),    //16
    BP2_CONST2(0.207111376192219,0.978317370719628),    //17
    BP2_CONST2(0.21910124015687,0.975702130038529),    //18
    BP2_CONST2(0.231058108280671,0.97293995220556),    //19
    BP2_CONST2(0.242980179903264,0.970031253194544),    //20
    BP2_CONST2(0.254865659604515,0.966976471044852),    //21
    BP2_CONST2(0.266712757474898,0.96377606579544),    //22
    BP2_CONST2(0.278519689385053,0.960430519415566),    //23
    BP2_CONST2(0.290284677254462,0.956940335732209),    //24
    BP2_CONST2(0.302005949319228,0.953306040354194),    //25
    BP2_CONST2(0.313681740398892,0.949528180593037),    //26
    BP2_CONST2(0.325310292162263,0.945607325380521),    //27
    BP2_CONST2(0.33688985339222,0.941544065183021),    //28
    BP2_CONST2(0.348418680249435,0.937339011912575),    //29
    BP2_CONST2(0.359895036534988,0.932992798834739),    //30
    BP2_CONST2(0.371317193951838,0.928506080473216),    //31
    BP2_CONST2(0.38268343236509,0.923879532511287),    //32
    BP2_CONST2(0.393992040061048,0.919113851690058),    //33
    BP2_CONST2(0.40524131400499,0.914209755703531),    //34
    BP2_CONST2(0.416429560097637,0.909167983090522),    //35
    BP2_CONST2(0.427555093430282,0.903989293123443),    //36
    BP2_CONST2(0.438616238538528,0.898674465693954),    //37
    BP2_CONST2(0.449611329654607,0.893224301195515),    //38
    BP2_CONST2(0.46053871095824,0.887639620402854),    //39
    BP2_CONST2(0.471396736825998,0.881921264348355),    //40
    BP2_CONST2(0.482183772079123,0.876070094195407),    //41
    BP2_CONST2(0.492898192229784,0.870086991108711),    //42
    BP2_CONST2(0.503538383725718,0.863972856121587),    //43
    BP2_CONST2(0.514102744193222,0.857728610000272),    //44
    BP2_CONST2(0.524589682678469,0.851355193105265),    //45
    BP2_CONST2(0.534997619887097,0.844853565249707),    //46
    BP2_CONST2(0.545324988422046,0.838224705554838),    //47
    BP2_CONST2(0.555570233019602,0.831469612302545),    //48
    BP2_CONST2(0.565731810783613,0.824589302785025),    //49
    BP2_CONST2(0.575808191417845,0.817584813151584),    //50
    BP2_CONST2(0.585797857456439,0.810457198252595),    //51
    BP2_CONST2(0.595699304492433,0.803207531480645),    //52
    BP2_CONST2(0.605511041404326,0.795836904608884),    //53
    BP2_CONST2(0.615231590580627,0.788346427626606),    //54
    BP2_CONST2(0.624859488142386,0.780737228572094),    //55
    BP2_CONST2(0.634393284163645,0.773010453362737),    //56
    BP2_CONST2(0.643831542889791,0.765167265622459),    //57
    BP2_CONST2(0.653172842953777,0.757208846506485),    //58
    BP2_CONST2(0.662415777590172,0.749136394523459),    //59
    BP2_CONST2(0.671558954847018,0.740951125354959),    //60
    BP2_CONST2(0.680600997795453,0.732654271672413),    //61
    BP2_CONST2(0.689540544737067,0.724247082951467),    //62
    BP2_CONST2(0.698376249408973,0.715730825283819),    //63
    BP2_CONST2(0.707106781186547,0.707106781186548)     //64
};
const BP2Type lpc_trig128[] = {
    BP2_CONST2(0,1),    //0
    BP2_CONST2(0.0245412285229123,0.999698818696204),    //1
    BP2_CONST2(0.049067674327418,0.998795456205172),    //2
    BP2_CONST2(0.0735645635996674,0.99729045667869),    //3
    BP2_CONST2(0.0980171403295606,0.995184726672197),    //4
    BP2_CONST2(0.122410675199216,0.99247953459871),    //5
    BP2_CONST2(0.146730474455362,0.989176509964781),    //6
    BP2_CONST2(0.170961888760301,0.985277642388941),    //7
    BP2_CONST2(0.195090322016128,0.98078528040323),    //8
    BP2_CONST2(0.21910124015687,0.975702130038529),    //9
    BP2_CONST2(0.242980179903264,0.970031253194544),    //10
    BP2_CONST2(0.266712757474898,0.96377606579544),    //11
    BP2_CONST2(0.290284677254462,0.956940335732209),    //12
    BP2_CONST2(0.313681740398892,0.949528180593037),    //13
    BP2_CONST2(0.33688985339222,0.941544065183021),    //14
    BP2_CONST2(0.359895036534988,0.932992798834739),    //15
    BP2_CONST2(0.38268343236509,0.923879532511287),    //16
    BP2_CONST2(0.40524131400499,0.914209755703531),    //17
    BP2_CONST2(0.427555093430282,0.903989293123443),    //18
    BP2_CONST2(0.449611329654607,0.893224301195515),    //19
    BP2_CONST2(0.471396736825998,0.881921264348355),    //20
    BP2_CONST2(0.492898192229784,0.870086991108711),    //21
    BP2_CONST2(0.514102744193222,0.857728610000272),    //22
    BP2_CONST2(0.534997619887097,0.844853565249707),    //23
    BP2_CONST2(0.555570233019602,0.831469612302545),    //24
    BP2_CONST2(0.575808191417845,0.817584813151584),    //25
    BP2_CONST2(0.595699304492433,0.803207531480645),    //26
    BP2_CONST2(0.615231590580627,0.788346427626606),    //27
    BP2_CONST2(0.634393284163645,0.773010453362737),    //28
    BP2_CONST2(0.653172842953777,0.757208846506485),    //29
    BP2_CONST2(0.671558954847018,0.740951125354959),    //30
    BP2_CONST2(0.689540544737067,0.724247082951467),    //31
    BP2_CONST2(0.707106781186547,0.707106781186548)     //32
};

const BP2Type* lpc_Trigs[] = {
    lpc_trig2048, lpc_trig1024, lpc_trig512, lpc_trig256, lpc_trig128 };

#endif // 0

#endif  // _DEBUG

#elif defined(PLATFORM_LPC_FOLDED)

//#pragma COMPILER_MESSAGE(__FILE__ "(35) : Warning - constants for PLATFORM_LPC_FOLDED")

#define BP2_CONST6(a,b,c,d,e,f) BP2_FROM_FLOAT(a),BP2_FROM_FLOAT(b),BP2_FROM_FLOAT(c), \
                                BP2_FROM_FLOAT(d),BP2_FROM_FLOAT(e),BP2_FROM_FLOAT(f)


const BP2Type lpc_cnst4[] = {
    BP2_CONST6(-0.541195999830961,1.84775899909436,0,1.41421399917453,0.541195999830961,0.765366999432444),    //0
    BP2_CONST6(0.995386999100446,0.00920400023460388,0.996926999650895,0.00613600015640259,0.998464999720454,0.00306800007820129),    //1
    BP2_CONST6(-0.535177999176084,1.84421699866652,0.0043389992788434,1.40986800007522,0.543199999257922,0.762531000189483),    //2
    BP2_CONST6(-0.547202999703586,1.85126099921762,-0.0043389992788434,1.4185459986329,0.539190999232232,0.76820100005716),    //3
    BP2_CONST6(-1.41419899929314,1.42070699855685,-0.996926999650895,1.99998999945819,0.00216899998486042,1.4120429996401),    //4
    BP2_CONST6(0.990753999911248,0.0184069992974401,0.993844999931752,0.0122719993814826,0.996926999650895,0.00613600015640259),    //5
    BP2_CONST6(-0.529147999361157,1.84063599910587,0.00867699924856424,1.40550999995321,0.545201999135315,0.759694000706076),    //6
    BP2_CONST6(-0.553197999484837,1.85472399927675,-0.00867699924856424,1.42286399845033,0.537184999324381,0.771031999960541),    //7
    BP2_CONST6(-1.41415299940854,1.42716899886727,-0.993844999931752,1.99996199924498,0.0043389992788434,1.40986800007522),    //8
    BP2_CONST6(0.986098999157547,0.0276110004633665,0.990753999911248,0.0184069992974401,0.995386999100446,0.00920400023460388),    //9
    BP2_CONST6(-0.523106999695301,1.8370169987902,0.0130159994587302,1.40113800019025,0.547202999703586,0.756856000050902),    //10
    BP2_CONST6(-0.559181999415159,1.85814899858087,-0.0130159994587302,1.42716999910771,0.535177999176084,0.7738620005548),    //11
    BP2_CONST6(-1.41407899931073,1.43360299896448,-0.990753999911248,1.99991499911993,0.00650799926370382,1.40769100002944),    //12
    BP2_CONST6(0.981423999182879,0.0368130002170801,0.987652999348938,0.0245430003851652,0.993844999931752,0.0122719993814826),    //13
    BP2_CONST6(-0.517054999247193,1.83335799910128,0.0173549996688962,1.39675199985504,0.549202999100089,0.754015000537037),    //14
    BP2_CONST6(-0.565153999254107,1.86153399851173,-0.0173549996688962,1.43146199919283,0.53316899947822,0.776689999736845),    //15
    BP2_CONST6(-1.4139739992097,1.44000499881803,-0.987652999348938,1.99984899908304,0.00867699924856424,1.40550999995321),    //16
    BP2_CONST6(0.976726999506354,0.0460160002112389,0.984542999416589,0.0306780003011227,0.992300999350845,0.0153390001505613),    //17
    BP2_CONST6(-0.510991999879479,1.82966099958866,0.021692999638617,1.39235400035977,0.551200999878346,0.751172999851405),    //18
    BP2_CONST6(-0.571113999933004,1.86487899906933,-0.021692999638617,1.435739999637,0.531158999539911,0.779516000300645),    //19
    BP2_CONST6(-1.41383899934589,1.44637699890881,-0.984542999416589,1.99976499937474,0.0108469994738698,1.40332499984651),    //20
    BP2_CONST6(0.972009999677538,0.0552169997245073,0.981423999182879,0.0368130002170801,0.990753999911248,0.0184069992974401),    //21
    BP2_CONST6(-0.504917999729514,1.82592399884015,0.0260309996083379,1.38794299960136,0.553197999484837,0.748328999616205),    //22
    BP2_CONST6(-0.577060999348759,1.86818399932235,-0.0260309996083379,1.44000499881803,0.529147999361157,0.782341000624001),    //23
    BP2_CONST6(-1.41367399971932,1.45271799899637,-0.981423999182879,1.99966099858283,0.0130159994587302,1.40113800019025),    //24
    BP2_CONST6(0.967272999696433,0.0644159996882081,0.978294999338686,0.0429480001330376,0.989204999990761,0.0214749993756413),    //25
    BP2_CONST6(-0.498833999969065,1.82214999943971,0.0303689995780587,1.38351800013333,0.555193999782204,0.745481999590992),    //26
    BP2_CONST6(-0.582996999844908,1.87145099975168,-0.0303689995780587,1.44425599928945,0.527134999632835,0.785163999535143),    //27
    BP2_CONST6(-1.41347999963909,1.45902899932116,-0.978294999338686,1.99953799881041,0.0151849994435906,1.39894700050354),    //28
    BP2_CONST6(0.962514999322593,0.0736150005832314,0.975157999433577,0.0490819998085499,0.987652999348938,0.0245430003851652),    //29
    BP2_CONST6(-0.49273799918592,1.81833599880337,0.0347059993073344,1.37908199988305,0.557188999839127,0.742633999325335),    //30
    BP2_CONST6(-0.588919999077916,1.87467799894511,-0.0347069995477796,1.44849499873816,0.525121999904513,0.787983999587595),    //31
    BP2_CONST6(-1.41325499955564,1.46530799940228,-0.975157999433577,1.9993979986757,0.0173549996688962,1.39675199985504),    //32
    BP2_CONST6(0.957736999727785,0.0828109998255968,0.972010999917984,0.0552159994840622,0.986098999157547,0.0276110004633665),    //33
    BP2_CONST6(-0.486632999964058,1.81448399927467,0.0390439992770553,1.37463000044226,0.559181999415159,0.739784999750554),    //34
    BP2_CONST6(-0.594830999150872,1.87786499876528,-0.0390439992770553,1.45271899923682,0.523106999695301,0.790802999399602),    //35
    BP2_CONST6(-1.41300099994987,1.47155799902975,-0.972010999917984,1.99923799932003,0.0195239996537566,1.39455499965697),    //36
    BP2_CONST6(0.952937999740242,0.0920059997588396,0.968853999860584,0.0613500000908971,0.984542999416589,0.0306780003011227),    //37
    BP2_CONST6(-0.480516999959946,1.81059299968183,0.0433809999376535,1.3701669992879,0.561173999682068,0.736933999694883),    //38
    BP2_CONST6(-0.600728999823331,1.8810119992122,-0.0433809999376535,1.45692899916321,0.521090999245643,0.793620000593364),    //39
    BP2_CONST6(-1.41271599940955,1.47777399886399,-0.968853999860584,1.99905799981206,0.021692999638617,1.39235400035977),    //40
    BP2_CONST6(0.94811899960041,0.10120000038296,0.965688999742269,0.0674829995259643,0.982984999194741,0.033746000379324),    //41
    BP2_CONST6(-0.474390999414027,1.80666399933397,0.0477169994264841,1.36569099966436,0.563164999708533,0.7340799998492),    //42
    BP2_CONST6(-0.606614999473094,1.88411999866366,-0.0477169994264841,1.46112499851733,0.519072999246418,0.796436000615358),    //43
    BP2_CONST6(-1.41240199934691,1.4839609991759,-0.965688999742269,1.9988609990105,0.0238619996234775,1.39015000034123),    //44
    BP2_CONST6(0.943279999308288,0.110391000285745,0.962514999322593,0.0736150005832314,0.981423999182879,0.0368130002170801),    //45
    BP2_CONST6(-0.468254999257624,1.80269799847155,0.0520529998466372,1.36120199970901,0.565153999254107,0.731226000003516),    //46
    BP2_CONST6(-0.612486999481916,1.88718699943274,-0.0520529998466372,1.46530799940228,0.517054999247193,0.799248000606894),    //47
    BP2_CONST6(-1.41205799952149,1.49011599924415,-0.962514999322593,1.99864499922841,0.0260309996083379,1.38794299960136),    //48
    BP2_CONST6(0.938420999795198,0.119579999707639,0.959331999532878,0.0797459995374084,0.97986099962145,0.0398810002952814),    //49
    BP2_CONST6(-0.462108999490738,1.7986919991672,0.0563889993354678,1.35670000035315,0.567141999490559,0.72836900036782),    //50
    BP2_CONST6(-0.618346999399363,1.89021499920636,-0.0563889993354678,1.46947799902409,0.5150349996984,0.802059999667108),    //51
    BP2_CONST6(-1.41168299969285,1.49623799882829,-0.959331999532878,1.99840999860316,0.0281999995931983,1.38573199976235),    //52
    BP2_CONST6(0.933541999198496,0.128766000270844,0.956138999201357,0.0858770003542304,0.978294999338686,0.0429480001330376),    //53
    BP2_CONST6(-0.455952999182045,1.79464799910783,0.0607239995151758,1.35218499973416,0.56912799924612,0.725512000732123),    //54
    BP2_CONST6(-0.624192999675869,1.89320099912583,-0.0607239995151758,1.47363299876451,0.513013999909162,0.804868999868631),    //55
    BP2_CONST6(-1.41127899941056,1.50232999864965,-0.956138999201357,1.99815499875694,0.0303689995780587,1.38351800013333),    //56
    BP2_CONST6(0.928643999621272,0.137949000112712,0.952937999740242,0.0920059997588396,0.976727999746799,0.0460149999707937),    //57
    BP2_CONST6(-0.449787999503314,1.79056799877434,0.0650579994544387,1.34765799995511,0.571113999933004,0.722650999203324),    //58
    BP2_CONST6(-0.630026999861001,1.89614899922162,-0.0650579994544387,1.47777399886399,0.510991999879479,0.807676999829709),    //59
    BP2_CONST6(-1.4108449993655,1.50838999915868,-0.952937999740242,1.99788199923932,0.0325379995629191,1.38130099978297),    //60
    BP2_CONST6(0.923725999891757,0.147128999233246,0.949727999977767,0.0981349991634488,0.975157999433577,0.0490819998085499),    //61
    BP2_CONST6(-0.443612999282777,1.7864479990676,0.0693919993937016,1.34311799984425,0.573097999207675,0.719790000468492),    //62
    BP2_CONST6(-0.635845999233424,1.89905599877238,-0.0693919993937016,1.48190199863165,0.508967999368906,0.810483000241219),    //63
    BP2_CONST6(-1.41038199979811,1.51441799942404,-0.949727999977767,1.99759099911898,0.0347069995477796,1.37908099964261),    //64
    BP2_CONST6(0.918787999078631,0.156306000426412,0.946507999673485,0.104263999499381,0.973584999330341,0.0521499998867512),    //65
    BP2_CONST6(-0.437428999692202,1.78229199908673,0.0737249990925193,1.33856500033289,0.575079999864101,0.716926999390125),    //66
    BP2_CONST6(-0.641652999445796,1.90192299894988,-0.0737249990925193,1.48601499851793,0.506943999789655,0.813285999931395),    //67
    BP2_CONST6(-1.40988799929618,1.52041399851441,-0.946507999673485,1.99727999884635,0.0368749992921948,1.37685800064355),    //68
    BP2_CONST6(0.913830999284982,0.165479999966919,0.943279999308288,0.110391000285745,0.972010999917984,0.0552159994840622),    //69
    BP2_CONST6(-0.43123499955982,1.77809599880129,0.0780579997226596,1.33399899955838,0.577061999589204,0.71406100038439),    //70
    BP2_CONST6(-0.647445999085903,1.9047499988228,-0.0780579997226596,1.49011599924415,0.504917999729514,0.816087999381124),    //71
    BP2_CONST6(-1.4093639999628,1.5263759996742,-0.943279999308288,1.99695099890232,0.0390439992770553,1.37463000044226),    //72
    BP2_CONST6(0.908853999339044,0.174651000648737,0.940042999573051,0.116516999900341,0.97043399978429,0.0582829993218184),    //73
    BP2_CONST6(-0.425031999126077,1.77386399824172,0.0823899991810322,1.32942100055515,0.579040999524295,0.711195999756455),    //74
    BP2_CONST6(-0.653224999085068,1.90753599908202,-0.0823899991810322,1.49420099891722,0.502890999428927,0.818888000212609),    //75
    BP2_CONST6(-1.40881099924445,1.53230799920856,-0.940042999573051,1.99660299904644,0.0412119999527931,1.37240100000053),    //76
    BP2_CONST6(0.90385799948126,0.183818000368774,0.936796999536454,0.122642000205815,0.968854999169707,0.0613490007817745),    //77
    BP2_CONST6(-0.41882099956274,1.76959499903023,0.0867209993302822,1.32483100052922,0.581019999459385,0.708327000029385),    //78
    BP2_CONST6(-0.658989999443292,1.91028199903666,-0.0867209993302822,1.49827299918979,0.500862999819219,0.821685999631881),    //79
    BP2_CONST6(-1.40822799969464,1.53820699919015,-0.936796999536454,1.99623599927872,0.0433809999376535,1.3701669992879),    //80
    BP2_CONST6(0.898842999711632,0.192981000058353,0.933542999438941,0.128765000030398,0.967272999696433,0.0644159996882081),    //81
    BP2_CONST6(-0.412599999457598,1.76528699882328,0.0910509992390871,1.32022800017148,0.582996999844908,0.705457000061869),    //82
    BP2_CONST6(-0.664741999469697,1.91298799868673,-0.0910509992390871,1.5023309988901,0.498833999969065,0.824481999501585),    //83
    BP2_CONST6(-1.40761499945074,1.54407299868762,-0.933542999438941,1.99585099890828,0.0455489996820688,1.36793099995702),    //84
    BP2_CONST6(0.893808999098837,0.202140000648797,0.930278999730944,0.134887999854982,0.965688999742269,0.0674829995259643),    //85
    BP2_CONST6(-0.406370999291539,1.76094199903309,0.0953799998387694,1.31561299972236,0.584972999989986,0.702584999613463),    //86
    BP2_CONST6(-0.670478999614715,1.91565299872308,-0.0953799998387694,1.5063729993999,0.496802999638021,0.827277000062167),    //87
    BP2_CONST6(-1.40697199944406,1.54990699887275,-0.930278999730944,1.99544599931687,0.0477169994264841,1.36569099966436),    //88
    BP2_CONST6(0.888756999745965,0.211294000037014,0.927006999962031,0.141008999198675,0.964102999307215,0.0705490000545979),    //89
    BP2_CONST6(-0.400132999755442,1.75655999965965,0.0997089995071292,1.31098499987274,0.586946999654173,0.69971300009638),    //90
    BP2_CONST6(-0.676201999187469,1.91827699914574,-0.0997089995071292,1.510402998887,0.494770999997854,0.830068999901413),    //91
    BP2_CONST6(-1.40629899967461,1.55570699926465,-0.927006999962031,1.99502299912273,0.0498849991708994,1.36344800051301),    //92
    BP2_CONST6(0.88368499930948,0.220444000326097,0.923725999891757,0.147128999233246,0.962514999322593,0.0736150005832314),    //93
    BP2_CONST6(-0.393885999917984,1.7521399995312,0.104035999625921,1.30634600017219,0.588919999077916,0.696838000789284),    //94
    BP2_CONST6(-0.681910999119281,1.9208609983325,-0.104035999625921,1.51441799942404,0.49273799918592,0.832860000431537),    //95
    BP2_CONST6(-1.40559699945151,1.56147499941289,-0.923725999891757,1.99458099901676,0.0520529998466372,1.36120199970901),    //96
    BP2_CONST6(0.878593999892473,0.229589999653399,0.920435999520123,0.153247999958694,0.960924999788403,0.0766799999400973),    //97
    BP2_CONST6(-0.387631999328732,1.74768399912863,0.108362999744713,1.30169299989938,0.590891999192535,0.693961000069975),    //98
    BP2_CONST6(-0.687604999169707,1.92340399883687,-0.108362999744713,1.51841899938881,0.490703999996185,0.835647999309003),    //99
    BP2_CONST6(-1.40486499946564,1.56720999907702,-0.920435999520123,1.99411999899893,0.0542209995910525,1.35895300004631),    //100
    BP2_CONST6(0.873484999872744,0.238729999400675,0.917137999087572,0.159365000203252,0.959331999532878,0.0797459995374084),    //101
    BP2_CONST6(-0.381368999369442,1.74318999890238,0.112687999382615,1.29702899977564,0.592861999757587,0.691083000041544),    //102
    BP2_CONST6(-0.693284999579191,1.92590599879622,-0.112687999382615,1.52240499854087,0.488668999634683,0.838433999568223),    //103
    BP2_CONST6(-1.40410299971699,1.57291099894791,-0.917137999087572,1.99364099837839,0.0563889993354678,1.35670000035315),    //104
    BP2_CONST6(0.868357999250292,0.247866000048816,0.913830999284982,0.165479999966919,0.957736999727785,0.0828109998255968),    //105
    BP2_CONST6(-0.375097999349236,1.73865999933332,0.117011999711394,1.29235200025141,0.594830999150872,0.688203000463545),    //106
    BP2_CONST6(-0.698949999175965,1.92836799845099,-0.117011999711394,1.5263759996742,0.486632999964058,0.841217999346554),    //107
    BP2_CONST6(-1.40331099927425,1.57857899926602,-0.913830999284982,1.99314199853688,0.0585559997707605,1.35444500017911),    //108
    BP2_CONST6(0.863211999647319,0.256996000185609,0.910514999181032,0.17159500066191,0.956139999441802,0.0858760001137853),    //109
    BP2_CONST6(-0.368818999268115,1.73409299924969,0.121335999108851,1.2876630006358,0.596797999925911,0.685321999713778),    //110
    BP2_CONST6(-0.704599999822676,1.93078899942338,-0.121335999108851,1.5303349988535,0.484594999812543,0.844000999815762),    //111
    BP2_CONST6(-1.40248999930918,1.58421399910002,-0.910514999181032,1.99262499902397,0.0607239995151758,1.35218499973416),    //112
    BP2_CONST6(0.858046999201178,0.266121000051498,0.907190999947488,0.177706999704242,0.954539999365806,0.0889410004019737),    //113
    BP2_CONST6(-0.362531999126077,1.7294889986515,0.125657999888062,1.28296199999749,0.598764999769628,0.682438000105321),    //114
    BP2_CONST6(-0.710235999897122,1.93316899985074,-0.125657999888062,1.53427799977362,0.482556999661028,0.846780999563634),    //115
    BP2_CONST6(-1.40163899958133,1.58981499914079,-0.907190999947488,1.99208899959921,0.0628909999504685,1.34992399998009),    //116
    BP2_CONST6(0.852864999324083,0.275240000337362,0.90385799948126,0.183818000368774,0.952937999740242,0.0920059997588396),    //117
    BP2_CONST6(-0.356236999854445,1.72484699916094,0.129978999495506,1.27824900019913,0.600728999823331,0.679553999565541),    //118
    BP2_CONST6(-0.715855999849736,1.93550799973309,-0.129978999495506,1.53820699919015,0.480516999959946,0.849558999761939),    //119
    BP2_CONST6(-1.40075799915939,1.59538199845701,-0.90385799948126,1.99153499864041,0.0650579994544387,1.34765799995511),    //120
    BP2_CONST6(0.847663999535143,0.284354000352323,0.900516999885439,0.189926999621093,0.951333999633789,0.0950710000470281),    //121
    BP2_CONST6(-0.349934999831021,1.7201699996367,0.134298999793828,1.27352300006896,0.60269199963659,0.676667999476194),    //122
    BP2_CONST6(-0.721460999920964,1.9378059990704,-0.134298999793828,1.54212099965661,0.478475999087095,0.852336000651121),    //123
    BP2_CONST6(-1.399846999906,1.60091499984264,-0.900516999885439,1.99096099939197,0.0672249998897314,1.34538999944925),    //124
    BP2_CONST6(0.842445999383926,0.293461000546813,0.89716799929738,0.196034000255167,0.949727999977767,0.0981349991634488),    //125
    BP2_CONST6(-0.343625999987125,1.71545699983835,0.138616999611259,1.2687870003283,0.604653999209403,0.673780000768601),    //126
    BP2_CONST6(-0.727050999179482,1.94006299879401,-0.138616999611259,1.54602099955081,0.476433999836445,0.855109999887645),    //127
    BP2_CONST6(-1.39890699926763,1.60641499888151,-0.89716799929738,1.99036999884992,0.0693919993937016,1.34311799984425),    //128
    BP2_CONST6(0.837209999561309,0.302562000229955,0.893808999098837,0.202140000648797,0.94811899960041,0.10120000038296),    //129
    BP2_CONST6(-0.337308999150991,1.7107069985941,0.142933999188244,1.26403800025582,0.606614999473094,0.670889999717473),    //130
    BP2_CONST6(-0.732625999487936,1.94227899890393,-0.142933999188244,1.54990599863231,0.474390999414027,0.857882999815046),    //131
    BP2_CONST6(-1.39793699979782,1.61188099905848,-0.893808999098837,1.98975799884647,0.0715589998289943,1.34084299951791),    //132
    BP2_CONST6(0.831955999135971,0.311656000092626,0.890442999079823,0.20824300032109,0.946507999673485,0.104263999499381),    //133
    BP2_CONST6(-0.330984999425709,1.70592099893838,0.147249999456108,1.25927700009196,0.608572999946773,0.667999999597668),    //134
    BP2_CONST6(-0.738184999674558,1.94445299915969,-0.147249999456108,1.55377699900418,0.472346999682486,0.860652999952435),    //135
    BP2_CONST6(-1.39693799987435,1.61731299944221,-0.890442999079823,1.98912899848073,0.0737249990925193,1.33856600057333),    //136
    BP2_CONST6(0.826683999970555,0.320744999684393,0.887067999690771,0.214344999752939,0.944895999506115,0.107327000238001),    //137
    BP2_CONST6(-0.324654999189079,1.70109899900853,0.151564999483526,1.25450299959629,0.610530999489128,0.66510699968785),    //138
    BP2_CONST6(-0.743727999739348,1.94658699911087,-0.151564999483526,1.55763299856334,0.470300999470055,0.863421999849379),    //139
    BP2_CONST6(-1.39590899925678,1.62270999886095,-0.887067999690771,1.98848099913448,0.075891999527812,1.33628400042653),    //140
    BP2_CONST6(0.821394999511539,0.329826000146568,0.88368499930948,0.220444000326097,0.943279999308288,0.110391000285745),    //141
    BP2_CONST6(-0.318316999822855,1.69624099973589,0.155877999961376,1.24971899949014,0.612486999481916,0.662213000468909),    //142
    BP2_CONST6(-0.749255999922752,1.94867899920791,-0.155877999961376,1.56147499941289,0.468254999257624,0.866187999956309),    //143
    BP2_CONST6(-1.39484999980777,1.62807199917733,-0.88368499930948,1.98781399894505,0.0780579997226596,1.33399999979883),    //144
    BP2_CONST6(0.816087999381124,0.338901000097394,0.88029299955815,0.226541999727488,0.941662999801337,0.113454000093043),    //145
    BP2_CONST6(-0.311971999704838,1.69134599901735,0.160188999958336,1.24492299929261,0.614441999234259,0.659316999837756),    //146
    BP2_CONST6(-0.754766999743878,1.95072999969124,-0.160188999958336,1.56530099920928,0.466206999495625,0.86895199958235),    //147
    BP2_CONST6(-1.3937619999051,1.6334009990096,-0.88029299955815,1.98712799884378,0.0802239999175072,1.331712000072),    //148
    BP2_CONST6(0.810764999128878,0.347967000678182,0.876892999745905,0.232636999338865,0.940042999573051,0.116516999900341),    //149
    BP2_CONST6(-0.305620999075472,1.68641599826514,0.164498999714851,1.24011499993503,0.616394999437034,0.65641999989748),    //150
    BP2_CONST6(-0.760262999683618,1.95273999962955,-0.164498999714851,1.56911299936473,0.464158999733627,0.871713999658823),    //151
    BP2_CONST6(-1.39264499954879,1.6386949988082,-0.876892999745905,1.98642399907112,0.0823899991810322,1.3294220007956),    //152
    BP2_CONST6(0.805423999205231,0.357027000747621,0.873484999872744,0.23873099964112,0.938420999795198,0.119579999707639),    //153
    BP2_CONST6(-0.299263999797404,1.6814509993419,0.168807999230921,1.23529400024563,0.618346999399363,0.653521000407636),    //154
    BP2_CONST6(-0.765742999501526,1.95470799878239,-0.168807999230921,1.57291099894791,0.462108999490738,0.874474000185728),    //155
    BP2_CONST6(-1.3914979994297,1.64395499881356,-0.873484999872744,1.9857009993866,0.0845549991354346,1.32712900079786),    //156
    BP2_CONST6(0.80006599985063,0.366080000065267,0.870068999938666,0.244820999912918,0.936796999536454,0.122642000205815),    //157
    BP2_CONST6(-0.292899999767542,1.67644999921321,0.173114999197423,1.23046300001442,0.620296999812126,0.650620999746024),    //158
    BP2_CONST6(-0.771205999888479,1.95663499925285,-0.173114999197423,1.57669299840927,0.460057999938726,0.877232999540865),    //159
    BP2_CONST6(-1.39032099954783,1.64917899947613,-0.870068999938666,1.98495899979025,0.0867209993302822,1.32483100052922),    //160
    BP2_CONST6(0.79469099920243,0.375124000012875,0.866643999703228,0.25090999994427,0.935170999728143,0.125703999772668),    //161
    BP2_CONST6(-0.286529999226332,1.67141299881041,0.177419999614358,1.22561999969184,0.622245999984443,0.647718999534845),    //162
    BP2_CONST6(-0.776652999222278,1.95851999893784,-0.177419999614358,1.58045999892055,0.458005999214947,0.879989000037312),    //163
    BP2_CONST6(-1.38911499921232,1.6543679991737,-0.866643999703228,1.98419799935072,0.0888859992846847,1.32253100071102),    //164
    BP2_CONST6(0.789298999123275,0.384161000140011,0.863211999647319,0.256996000185609,0.933542999438941,0.128765000030398),    //165
    BP2_CONST6(-0.280153999105096,1.6663399990648,0.181723999790847,1.22076499927788,0.624192999675869,0.644816000014543),    //166
    BP2_CONST6(-0.782083999365568,1.96036399900913,-0.181723999790847,1.58421299885958,0.455952999182045,0.882743000052869),    //167
    BP2_CONST6(-1.38787999935448,1.65952299907803,-0.863211999647319,1.98341999948024,0.0910509992390871,1.32022800017148),    //168
    BP2_CONST6(0.783889999613165,0.393190000206232,0.859770999290049,0.263079999946058,0.931911999359726,0.131827000528574),    //169
    BP2_CONST6(-0.273770999163389,1.66123199835419,0.186025999486446,1.21589899994432,0.626138999126851,0.641910000704228),    //170
    BP2_CONST6(-0.78749799914658,1.96216699853539,-0.186025999486446,1.58795099891722,0.453898999840021,0.885494999587535),    //171
    BP2_CONST6(-1.38661499973386,1.66464199963957,-0.859770999290049,1.98262199852615,0.0932159991934896,1.31792200077325),    //172
    BP2_CONST6(0.778464999981224,0.402209999971092,0.856321999803185,0.269160999916494,0.930278999730944,0.134887999854982),    //173
    BP2_CONST6(-0.267383999191225,1.65608999878168,0.190325999632478,1.21102199982851,0.628082999959588,0.639004999771714),    //174
    BP2_CONST6(-0.792894999496638,1.96392799913883,-0.190325999632478,1.59167399909347,0.451843999326229,0.888244000263512),    //175
    BP2_CONST6(-1.38532099965959,1.6697259992361,-0.856321999803185,1.9818059997633,0.0953799998387694,1.3156139999628),    //176
    BP2_CONST6(0.773023999296128,0.411220000125468,0.852864999324083,0.275240000337362,0.928643999621272,0.137949000112712),    //177
    BP2_CONST6(-0.260989999398589,1.65091199893504,0.194623999297619,1.20613300055265,0.630025999620556,0.636096999980509),    //178
    BP2_CONST6(-0.798275999724864,1.96564699895679,-0.194623999297619,1.59538099914789,0.449787999503314,0.89099199976772),    //179
    BP2_CONST6(-1.38399799913167,1.67477499879896,-0.852864999324083,1.98096999898552,0.0975439995527267,1.31330200005322),    //180
    BP2_CONST6(0.767564999870955,0.420223999768496,0.849399999715387,0.281316000036895,0.927006999962031,0.141008999198675),    //181
    BP2_CONST6(-0.254590999335051,1.64569899905472,0.198920999653637,1.20123200025409,0.631967999972403,0.633186999708414),    //182
    BP2_CONST6(-0.803638999350368,1.96732399892061,-0.198920999653637,1.59907499887049,0.447730999439955,0.893737000413239),    //183
    BP2_CONST6(-1.38264499977231,1.67978799901902,-0.849399999715387,1.98011699970811,0.0997089995071292,1.31098499987274),    //184
    BP2_CONST6(0.762090999633073,0.42921799980104,0.845926999114453,0.287390000186861,0.925366999581456,0.144070000387728),    //185
    BP2_CONST6(-0.248186999931931,1.64045199938118,0.203214999288321,1.19632200058549,0.633907999843358,0.630276000127196),    //186
    BP2_CONST6(-0.808985999785363,1.96896099951118,-0.203214999288321,1.60275199916213,0.445671999827027,0.896482000127434),    //187
    BP2_CONST6(-1.38126299995929,1.68476599920541,-0.845926999114453,1.97924399841576,0.101871999911964,1.30866799969226),    //188
    BP2_CONST6(0.756600999273359,0.4382020002231,0.842445999383926,0.293461000546813,0.923725999891757,0.147128999233246),    //189
    BP2_CONST6(-0.241776999086142,1.63516999874264,0.207507999613881,1.19139899965375,0.635845999233424,0.627364000305533),    //190
    BP2_CONST6(-0.814315999858081,1.97055599931627,-0.207507999613881,1.60641499888151,0.443612999282777,0.899222999811172),    //191
    BP2_CONST6(-1.37985099945217,1.68970699887722,-0.842445999383926,1.97835299931466,0.104035999625921,1.30634600017219),    //192
    BP2_CONST6(0.751093999482691,0.447177999652922,0.838956999592483,0.29952900018543,0.922081999480724,0.150189000181854),    //193
    BP2_CONST6(-0.235361999832094,1.62985199969261,0.211798999458551,1.18646400049328,0.637782999314367,0.62445000000298),    //194
    BP2_CONST6(-0.819627999328076,1.97210799902677,-0.211798999458551,1.61006299871951,0.441552999429405,0.901961999945342),    //195
    BP2_CONST6(-1.37841099966317,1.69461399875581,-0.838956999592483,1.97744299937039,0.106198999099433,1.30402200017124),    //196
    BP2_CONST6(0.745571999810636,0.45614399947226,0.835459999740123,0.305594999343157,0.920435999520123,0.153247999958694),    //197
    BP2_CONST6(-0.22894199937582,1.62450099922716,0.216087999753654,1.18151899985969,0.639718999154865,0.621534000150859),    //198
    BP2_CONST6(-0.824922999367117,1.97361899912357,-0.216087999753654,1.61369499936699,0.439490999095142,0.904699000529944),    //199
    BP2_CONST6(-1.37694099918007,1.69948399905115,-0.835459999740123,1.9765149988234,0.108362999744713,1.30169299989938),    //200
    BP2_CONST6(0.740033999085426,0.465101000852883,0.831955999135971,0.311657000333071,0.918787999078631,0.156307000666857),    //201
    BP2_CONST6(-0.222516999579966,1.61911499872803,0.220374999567866,1.17656200006604,0.641652999445796,0.618617000058293),    //202
    BP2_CONST6(-0.830200999975204,1.97508799936622,-0.220374999567866,1.61731299944221,0.437428999692202,0.907433999702334),    //203
    BP2_CONST6(-1.37544199917465,1.70431799907237,-0.831955999135971,1.97556899860501,0.110524999909103,1.29936299938708),    //204
    BP2_CONST6(0.734479999169707,0.474047000519931,0.828442999161779,0.317716999910772,0.917137999087572,0.159365000203252),    //205
    BP2_CONST6(-0.216087999753654,1.61369499936699,0.224658999592066,1.17159599997103,0.643584999255836,0.615699999965727),    //206
    BP2_CONST6(-0.835459999740123,1.9765149988234,-0.224658999592066,1.62091399915516,0.435364999808371,0.910166999325156),    //207
    BP2_CONST6(-1.3739139996469,1.70911599881947,-0.828442999161779,1.97460299823433,0.112687999382615,1.29702899977564),    //208
    BP2_CONST6(0.728910999372601,0.482983999885619,0.824922999367117,0.323773000389338,0.915484999306499,0.162423000670969),    //209
    BP2_CONST6(-0.209653999656439,1.6082409992814,0.22894199937582,1.16661700047552,0.645515999756753,0.612780000083148),    //210
    BP2_CONST6(-0.840702999383211,1.97790099866688,-0.22894199937582,1.62450099922716,0.433300999924541,0.91289799939841),    //211
    BP2_CONST6(-1.37235699966549,1.71387799922376,-0.824922999367117,1.97361899912357,0.114849999547005,1.29469200037419),    //212
    BP2_CONST6(0.723325999453663,0.4919100003317,0.821394999511539,0.329826000146568,0.913830999284982,0.165479999966919),    //213
    BP2_CONST6(-0.203215999528766,1.60275299940258,0.233221999369562,1.16162800043821,0.647445999085903,0.609858000651001),    //214
    BP2_CONST6(-0.845926999114453,1.97924399841576,-0.233221999369562,1.62807199917733,0.43123499955982,0.915626999922096),    //215
    BP2_CONST6(-1.37077099923044,1.71860399842262,-0.821394999511539,1.97261599916964,0.117012999951839,1.29235100001096),    //216
    BP2_CONST6(0.717725999653339,0.500826000235974,0.817858999595046,0.33587700035423,0.912173999473452,0.168538000434637),    //217
    BP2_CONST6(-0.196772999130189,1.59722999855875,0.237500999122858,1.15662700030952,0.649373999796807,0.60693599935621),    //218
    BP2_CONST6(-0.851133999414741,1.98054599855095,-0.237500999122858,1.63162899855524,0.429167999885976,0.918353999964892),    //219
    BP2_CONST6(-1.36915599927306,1.72329399921,-0.817858999595046,1.97159499954432,0.119173999875784,1.29000899940729),    //220
    BP2_CONST6(0.712110999971628,0.509730999357998,0.814315999858081,0.341923999600112,0.910514999181032,0.17159500066191),    //221
    BP2_CONST6(-0.190325999632478,1.59167399909347,0.241776999086142,1.15161600057035,0.651299999095499,0.604012000374495),    //222
    BP2_CONST6(-0.856321999803185,1.98180499952286,-0.241776999086142,1.63516999874264,0.42710099928081,0.921076999977231),    //223
    BP2_CONST6(-1.36751199979335,1.72794699948281,-0.814315999858081,1.97055599931627,0.121335999108851,1.2876630006358),    //224
    BP2_CONST6(0.706479999236762,0.518626000732183,0.810764999128878,0.347967000678182,0.908853999339044,0.174651000648737),    //225
    BP2_CONST6(-0.183874999172986,1.58608399890363,0.246049999259412,1.14659500028938,0.653224999085068,0.601086000911891),    //226
    BP2_CONST6(-0.861491999588906,1.98302299901843,-0.246049999259412,1.6386949988082,0.425031999126077,0.923799999989569),    //227
    BP2_CONST6(-1.36583799961954,1.7325619990006,-0.810764999128878,1.96949799824506,0.123496999964118,1.28531399928033),    //228
    BP2_CONST6(0.700834999792277,0.527509000152349,0.807205999270081,0.354008000344038,0.907190999947488,0.177706999704242),    //229
    BP2_CONST6(-0.177419999614358,1.58045999892055,0.250321999192238,1.1415610006079,0.65514799952507,0.598159999586641),    //230
    BP2_CONST6(-0.866643999703228,1.98419799935072,-0.250321999192238,1.64220499899238,0.422962999902666,0.926518999971449),    //231
    BP2_CONST6(-1.36413599923253,1.73714199848473,-0.807205999270081,1.9684199988842,0.125657999888062,1.28296199999749),    //232
    BP2_CONST6(0.695174999535083,0.536381999962031,0.803638999350368,0.360046000219882,0.905525999143719,0.180763000622392),    //233
    BP2_CONST6(-0.170961999334395,1.57480399869382,0.254590999335051,1.13651800062507,0.657069999724626,0.595230999402701),    //234
    BP2_CONST6(-0.871777999214828,1.98533199913799,-0.254590999335051,1.64569999929517,0.420891999267042,0.929237999953329),    //235
    BP2_CONST6(-1.36240499932318,1.74168399907648,-0.803639999590814,1.96732499916106,0.127818999812007,1.28060699999332),    //236
    BP2_CONST6(0.689499999396502,0.54524299968034,0.80006599985063,0.366078999824822,0.90385799948126,0.183818000368774),    //237
    BP2_CONST6(-0.164499999955297,1.56911399960517,0.25885699968785,1.13146399985998,0.658989999443292,0.592302000150084),    //238
    BP2_CONST6(-0.876892999745905,1.98642399907112,-0.25885699968785,1.64917799923568,0.41882099956274,0.931952999904751),    //239
    BP2_CONST6(-1.36064499989151,1.74618999939411,-0.80006599985063,1.96621199976652,0.129978999495506,1.27824900019913),    //240
    BP2_CONST6(0.68381099961698,0.554092000238597,0.796483999118208,0.372110000811517,0.902188999578356,0.186873000115156),    //241
    BP2_CONST6(-0.158033999614418,1.56338999886065,0.263121999800205,1.12639799993485,0.660908999852836,0.589370999485254),    //242
    BP2_CONST6(-0.88198999967426,1.98747399915009,-0.263121999800205,1.6526429997757,0.416747999377549,0.934667000547051),    //243
    BP2_CONST6(-1.35885699931532,1.75065899919718,-0.796483999118208,1.96507899835705,0.132138999179006,1.27588800061494),    //244
    BP2_CONST6(0.678105999715626,0.562930000014603,0.792894999496638,0.378136999905109,0.900516999885439,0.189926999621093),    //245
    BP2_CONST6(-0.151564999483526,1.55763299856334,0.267382999882102,1.12132299970835,0.662825999781489,0.586438000202178),    //246
    BP2_CONST6(-0.887067999690771,1.98848099913448,-0.267382999882102,1.656089999713,0.414673999883235,0.937377999536693),    //247
    BP2_CONST6(-1.35703899990767,1.755090999417,-0.792894999496638,1.96392799913883,0.134298999793828,1.27352300006896),    //248
    BP2_CONST6(0.672387999482452,0.571755999699234,0.789298999123275,0.384161000140011,0.898842999711632,0.192981000058353),    //249
    BP2_CONST6(-0.145092999562621,1.5518439989537,0.271642999723554,1.11623699963092,0.664741999469697,0.583503999747335),    //250
    BP2_CONST6(-0.892126999795436,1.98944599926471,-0.271642999723554,1.65952299907803,0.412599999457598,0.940086999908089),    //251
    BP2_CONST6(-1.35519299935549,1.75948499888181,-0.789298999123275,1.96275899838656,0.136457999236882,1.27115700021386),    //252
    BP2_CONST6(0.666655999608337,0.58056899998337,0.785694999620318,0.390181000344455,0.89716799929738,0.196034000255167),    //253
    BP2_CONST6(-0.138616999611259,1.54602099955081,0.275898999534547,1.11114099994301,0.666655999608337,0.58056899998337),    //254
    BP2_CONST6(-0.89716799929738,1.99036999884992,-0.275898999534547,1.66293899901211,0.410524999722838,0.94279299955815),    //255
    BP2_CONST6(-1.35331799928098,1.76384299900382,-0.785694999620318,1.96157099958509,0.138616999611259,1.2687870003283),    //256
    BP2_CONST6(0.660908999852836,0.589370999485254,0.782083999365568,0.396197000518441,0.895489999093115,0.199087000451982),    //257
    BP2_CONST6(-0.132138999179006,1.54016599897295,0.280152999795973,1.10603399947285,0.668567999266088,0.577632999978959),    //258
    BP2_CONST6(-0.902188999578356,1.99125099927186,-0.280152999795973,1.6663399990648,0.408447999507189,0.945497999899089),    //259
    BP2_CONST6(-1.35141399968415,1.7681619990617,-0.782083999365568,1.96036499924957,0.140775999985635,1.26641299948096),    //260
    BP2_CONST6(0.65514799952507,0.598159999586641,0.778464999981224,0.402208999730647,0.893808999098837,0.202140000648797),    //261
    BP2_CONST6(-0.125657999888062,1.53427799977362,0.284404999576509,1.10091600008308,0.670478999614715,0.574694999493658),    //262
    BP2_CONST6(-0.907190999947488,1.99208899959921,-0.284404999576509,1.6697259992361,0.406370999291539,0.948200000450015),    //263
    BP2_CONST6(-1.34948199987411,1.77244499977678,-0.778464999981224,1.95913899969309,0.142933999188244,1.26403800025582),    //264
    BP2_CONST6(0.649373999796807,0.60693599935621,0.774838999845087,0.408218000084162,0.892126999795436,0.205191999673843),    //265
    BP2_CONST6(-0.119173999875784,1.52835699915885,0.288653999567032,1.09578800015151,0.672387999482452,0.571755999699234),    //266
    BP2_CONST6(-0.912173999473452,1.99288599938154,-0.288653999567032,1.67309599928557,0.404291999526322,0.950900999829173),    //267
    BP2_CONST6(-1.34752199985086,1.77669099904596,-0.774838999845087,1.95789599977433,0.145091999322176,1.2616590000689),    //268
    BP2_CONST6(0.643584999255836,0.615699999965727,0.771205999888479,0.414222999475896,0.890442999079823,0.20824300032109),    //269
    BP2_CONST6(-0.112687999382615,1.52240499854087,0.292899999767542,1.09064999967813,0.674295999109745,0.568815000355243),    //270
    BP2_CONST6(-0.917137999087572,1.99364099837839,-0.292899999767542,1.67644999921321,0.402212999761105,0.953598999418318),    //271
    BP2_CONST6(-1.34553199913352,1.78089699894189,-0.771205999888479,1.95663499925285,0.147249999456108,1.25927700009196),    //272
    BP2_CONST6(0.637782999314367,0.62445000000298,0.767564999870955,0.420223999768496,0.888756999745965,0.211294000037014),    //273
    BP2_CONST6(-0.106198999099433,1.51641899906098,0.297142999246716,1.08550100028514,0.676201999187469,0.565873000770807),    //274
    BP2_CONST6(-0.922081999480724,1.9943529991433,-0.297142999246716,1.67978799901902,0.400132999755442,0.956294000148773),    //275
    BP2_CONST6(-1.34351499937474,1.78506799880415,-0.767565999180078,1.95535499881953,0.149407999590039,1.25689100008457),    //276
    BP2_CONST6(0.631967999972403,0.633186999708414,0.763917999342083,0.426219999790192,0.887067999690771,0.214344999752939),    //277
    BP2_CONST6(-0.0997089995071292,1.510402998887,0.301382999867201,1.08034299965947,0.678105999715626,0.562930000014603),    //278
    BP2_CONST6(-0.927006999962031,1.99502299912273,-0.301382999867201,1.68310999963432,0.398051999509335,0.958987000398337),    //279
    BP2_CONST6(-1.34146799985319,1.78919899929314,-0.763917999342083,1.95405599847435,0.151564999483526,1.25450299959629),    //280
    BP2_CONST6(0.626138999126851,0.641911000013351,0.760262999683618,0.43221400026232,0.885376999154686,0.21739500015974),    //281
    BP2_CONST6(-0.0932159991934896,1.50435399916023,0.305620999075472,1.0751740001142,0.680008999072015,0.559986000880599),    //282
    BP2_CONST6(-0.931911999359726,1.99565099924802,-0.305620999075472,1.68641599826514,0.395968999713659,0.961678999476134),    //283
    BP2_CONST6(-1.33939399942755,1.79329299926757,-0.760262999683618,1.95273999962955,0.153720999136567,1.25211300048977),    //284
    BP2_CONST6(0.620296999812126,0.650620999746024,0.756600999273359,0.4382020002231,0.88368499930948,0.220444000326097),    //285
    BP2_CONST6(-0.0867209993302822,1.49827299918979,0.309855999425054,1.06999500002712,0.681910999119281,0.557039000093936),    //286
    BP2_CONST6(-0.936796999536454,1.99623599927872,-0.309855999425054,1.68970699887722,0.393885999917984,0.964367999695241),    //287
    BP2_CONST6(-1.33729099947959,1.79734899941831,-0.756600999273359,1.95140399876981,0.155877999961376,1.24971899949014),    //288
    BP2_CONST6(0.614441999234259,0.659316999837756,0.752931999973952,0.444186999462545,0.88198999967426,0.223492999561131),    //289
    BP2_CONST6(-0.0802239999175072,1.49215999990701,0.314087999984622,1.06480599939823,0.683809999376535,0.554093000479042),    //290
    BP2_CONST6(-0.941662999801337,1.99677999969571,-0.314087999984622,1.69298199936747,0.391801999881864,0.967054999433457),    //291
    BP2_CONST6(-1.33515899907797,1.80136699881404,-0.752931999973952,1.95005099941045,0.158033999614418,1.24732199963182),    //292
    BP2_CONST6(0.608572999946773,0.667999999597668,0.749254999682307,0.450167999602854,0.88029299955815,0.226541999727488),    //293
    BP2_CONST6(-0.0737249990925193,1.48601499851793,0.318316999822855,1.05960700009018,0.685708999633789,0.551142999902367),    //294
    BP2_CONST6(-0.946507999673485,1.99727999884635,-0.318316999822855,1.69624099973589,0.389716999605298,0.969739000312983),    //295
    BP2_CONST6(-1.33299999963492,1.8053469993174,-0.749254999682307,1.94867799896746,0.160188999958336,1.24492299929261),    //296
    BP2_CONST6(0.60269199963659,0.676667999476194,0.745571999810636,0.45614399947226,0.878593999892473,0.229589999653399),    //297
    BP2_CONST6(-0.0672249998897314,1.47983999922871,0.322542999871075,1.054397999309,0.687604999169707,0.54819400049746),    //298
    BP2_CONST6(-0.951333999633789,1.9977389993146,-0.322542999871075,1.69948399905115,0.387631999328732,0.972420000471174),    //299
    BP2_CONST6(-1.33081199973821,1.80928799882531,-0.745571999810636,1.94728799909353,0.162344999611378,1.24251999985426),    //300
    BP2_CONST6(0.596797999925911,0.685321999713778,0.741881999187171,0.462116000242531,0.876892999745905,0.23263799957931),    //301
    BP2_CONST6(-0.0607239995151758,1.47363299876451,0.326764999888837,1.0491800000891,0.689499999396502,0.54524299968034),    //302
    BP2_CONST6(-0.956139999441802,1.99815599899739,-0.326764999888837,1.70270999986678,0.385544999502599,0.97510000038892),    //303
    BP2_CONST6(-1.3285959996283,1.81319199874997,-0.741881999187171,1.94587999861687,0.164498999714851,1.24011499993503),    //304
    BP2_CONST6(0.590891999192535,0.693961000069975,0.738183999434113,0.468084000051022,0.875189999118447,0.235683999955654),    //305
    BP2_CONST6(-0.0542209995910525,1.46739499922841,0.330984999425709,1.04395100008696,0.691392999142408,0.54229100048542),    //306
    BP2_CONST6(-0.960924999788403,1.9985299995169,-0.330984999425709,1.70592099893838,0.383456999436021,0.977777999825775),    //307
    BP2_CONST6(-1.32635199930518,1.81705599930137,-0.738184999674558,1.94445399940013,0.166653999127448,1.23770599998533),    //308
    BP2_CONST6(0.584972999989986,0.702584999613463,0.734479999169707,0.474047000519931,0.873484999872744,0.23873099964112),    //309
    BP2_CONST6(-0.0477169994264841,1.46112499851733,0.335201999172568,1.03871200047433,0.693284999579191,0.539335999637842),    //310
    BP2_CONST6(-0.965688999742269,1.9988609990105,-0.335201999172568,1.70911599881947,0.381368999369442,0.98045300040394),    //311
    BP2_CONST6(-1.32407999970018,1.8208829993382,-0.734479999169707,1.94300699885934,0.168807999230921,1.23529500048607),    //312
    BP2_CONST6(0.579040999524295,0.711195000447332,0.73076899908483,0.480006000027061,0.871777999214828,0.241776000708342),    //313
    BP2_CONST6(-0.0412119999527931,1.45482499990612,0.339414999820292,1.03346399962902,0.695174999535083,0.536381999962031),    //314
    BP2_CONST6(-0.97043399978429,1.99915099889039,-0.339414999820292,1.7122939992696,0.379278999753296,0.983125999569892),    //315
    BP2_CONST6(-1.32177899964153,1.82466999907046,-0.73076899908483,1.94154399819672,0.170961999334395,1.23288000002503),    //316
    BP2_CONST6(0.573097999207675,0.719790000468492,0.727050999179482,0.485960000194609,0.870068999938666,0.244820999912918),    //317
    BP2_CONST6(-0.0347069995477796,1.44849399942904,0.343625999987125,1.0282049998641,0.697062999941408,0.533425999805331),    //318
    BP2_CONST6(-0.975157999433577,1.9993979986757,-0.343625999987125,1.71545699983835,0.377188999205828,0.985795999877154),    //319
    BP2_CONST6(-1.31945099961012,1.82841999921947,-0.727050999179482,1.94006299879401,0.173114999197423,1.23046300001442),    //320
    BP2_CONST6(0.567141999490559,0.72836900036782,0.723325999453663,0.4919100003317,0.868357999250292,0.247866000048816),    //321
    BP2_CONST6(-0.0281999995931983,1.44213199894875,0.347832999192178,1.02293700072914,0.698949999175965,0.530468000099062),    //322
    BP2_CONST6(-0.97986099962145,1.99960299953818,-0.347832999192178,1.71860399842262,0.375097999349236,0.988464000634849),    //323
    BP2_CONST6(-1.3170949993655,1.8321299990639,-0.723325999453663,1.93856199923902,0.175267999991775,1.22804299928247),    //324
    BP2_CONST6(0.561173999682068,0.736932999454438,0.719593999907374,0.49785599950701,0.866643999703228,0.25090999994427),    //325
    BP2_CONST6(-0.021692999638617,1.435739999637,0.352036999538541,1.0176600003615,0.700834999792277,0.527509000152349),    //326
    BP2_CONST6(-0.984542999416589,1.9997639991343,-0.352036999538541,1.72173399943858,0.373004999943078,0.991130999289453),    //327
    BP2_CONST6(-1.31470999959856,1.8358009988442,-0.719593999907374,1.93704399932175,0.177419999614358,1.22561999969184),    //328
    BP2_CONST6(0.555193999782204,0.745481999590992,0.715855999849736,0.503796000033617,0.864928999915719,0.253952999599278),    //329
    BP2_CONST6(-0.0151849994435906,1.42931699939072,0.356236999854445,1.01237399969249,0.702717999927699,0.524549999274313),    //330
    BP2_CONST6(-0.989204999990761,1.99988499935716,-0.356236999854445,1.72484799940139,0.370911999605596,0.993795000016689),    //331
    BP2_CONST6(-1.31229899916797,1.83943499904125,-0.715855999849736,1.93550799973309,0.179571999236941,1.22319400031119),    //332
    BP2_CONST6(0.549202999100089,0.754015000537037,0.712110999971628,0.509730999357998,0.863211999647319,0.256996000185609),    //333
    BP2_CONST6(-0.00867799948900938,1.42286499869078,0.360433999449015,1.00707700010389,0.704599999822676,0.521588999778032),    //334
    BP2_CONST6(-0.993844999931752,1.99996199924498,-0.360433999449015,1.72794499900192,0.368818999268115,0.996455000713467),    //335
    BP2_CONST6(-1.30985899921506,1.84302799869328,-0.712110999971628,1.93395299930125,0.181723999790847,1.22076499927788),    //336
    BP2_CONST6(0.543199999257922,0.762531000189483,0.708358999341726,0.515662000514566,0.861491999588906,0.260038999840617),    //337
    BP2_CONST6(-0.00216899998486042,1.41638099960982,0.364627999253571,1.00177100021392,0.706479999236762,0.518626000732183),    //338
    BP2_CONST6(-0.998464999720454,1.9999979995191,-0.364627999253571,1.73102699872106,0.366723999381065,0.999114000238478),    //339
    BP2_CONST6(-1.30739199928939,1.84658299852162,-0.708358999341726,1.93237999919801,0.183874999172986,1.21833400055766),    //340
    BP2_CONST6(0.537184999324381,0.771031999960541,0.704599999822676,0.521588999778032,0.859770999290049,0.263079999946058),    //341
    BP2_CONST6(0.0043389992788434,1.40986800007522,0.368817999958992,0.99645600002259,0.708358999341726,0.515662000514566),    //342
    BP2_CONST6(-1.00306299980729,1.99998999945819,-0.368818999268115,1.73409299924969,0.364627999253571,1.00177100021392),    //343
    BP2_CONST6(-1.30489599984139,1.8500979989767,-0.704599999822676,1.93078899942338,0.186025999486446,1.21589899994432),    //344
    BP2_CONST6(0.531158999539911,0.779516999609768,0.700834999792277,0.527509999461472,0.858046999201178,0.266122000291944),    //345
    BP2_CONST6(0.0108469994738698,1.40332499984651,0.373004999943078,0.991130999289453,0.710235999897122,0.512697000056505),    //346
    BP2_CONST6(-1.00764099974185,1.99994199909269,-0.3730059992522,1.73714199848473,0.362531999126077,1.00442500039935),    //347
    BP2_CONST6(-1.30237399972975,1.85357499960809,-0.700834999792277,1.92917999904602,0.188175999559462,1.21346199978142),    //348
    BP2_CONST6(0.525121999904513,0.787983999587595,0.697062999941408,0.533425999805331,0.856321999803185,0.269160999916494),    //349
    BP2_CONST6(0.0173539994284511,1.39675300009548,0.377188999205828,0.985795999877154,0.712110999971628,0.509730999357998),    //350
    BP2_CONST6(-1.0121959997341,1.99984899908304,-0.377188999205828,1.74017399828881,0.360433999449015,1.00707700010389),    //351
    BP2_CONST6(-1.2998239994049,1.85701299924403,-0.697062999941408,1.92755199968814,0.190325999632478,1.21102199982851),    //352
    BP2_CONST6(0.519072999246418,0.796436000615358,0.693284999579191,0.539336999878287,0.854593999683856,0.272202000021935),    //353
    BP2_CONST6(0.0238619996234775,1.39015000034123,0.381368999369442,0.98045300040394,0.713983999565243,0.506764000281691),    //354
    BP2_CONST6(-1.01673099957406,1.9997159987688,-0.381368999369442,1.74319099914282,0.358335999771953,1.00972699932754),    //355
    BP2_CONST6(-1.29724599979817,1.86041099950671,-0.693284999579191,1.92590699903666,0.192474999465048,1.20857900008559),    //356
    BP2_CONST6(0.513013999909162,0.804868999868631,0.689499999396502,0.54524299968034,0.852864999324083,0.275240000337362),    //357
    BP2_CONST6(0.0303689995780587,1.38351800013333,0.385544999502599,0.97510000038892,0.715855999849736,0.503796000033617),    //358
    BP2_CONST6(-1.02124399971216,1.99953899905085,-0.385544999502599,1.74618999939411,0.356236999854445,1.01237399969249),    //359
    BP2_CONST6(-1.29463999997824,1.8637689994648,-0.689499999396502,1.92424299847334,0.194623999297619,1.20613399986177),    //360
    BP2_CONST6(0.506943999789655,0.813285999931395,0.685708999633789,0.551142999902367,0.851132999174296,0.278278999961913),    //361
    BP2_CONST6(0.0368749992921948,1.37685800064355,0.389716999605298,0.969739000312983,0.717725999653339,0.500826000235974),    //362
    BP2_CONST6(-1.02573499921709,1.99931999854743,-0.389717999845743,1.74917399976402,0.354136999696493,1.01501899957656),    //363
    BP2_CONST6(-1.29200699925422,1.86708699911832,-0.685708999633789,1.92256099916994,0.196772999130189,1.20368400029838),    //364
    BP2_CONST6(0.500862999819219,0.821685999631881,0.681910999119281,0.557039000093936,0.849399999715387,0.281316000036895),    //365
    BP2_CONST6(0.0433809999376535,1.3701669992879,0.393885999917984,0.964367999695241,0.719593999907374,0.49785599950701),    //366
    BP2_CONST6(-1.0302049992606,1.99905999843031,-0.393885999917984,1.7521399995312,0.352036999538541,1.0176600003615),    //367
    BP2_CONST6(-1.28934699948877,1.87036699894815,-0.681910999119281,1.9208609983325,0.198920999653637,1.20123299956321),    //368
    BP2_CONST6(0.494770999997854,0.830068999901413,0.678106999956071,0.562928999774158,0.847663999535143,0.284354000352323),    //369
    BP2_CONST6(0.0498849991708994,1.36344900075346,0.398051999509335,0.958987000398337,0.721460999920964,0.494882999919355),    //370
    BP2_CONST6(-1.03465199936181,1.99875599890947,-0.398051999509335,1.755090999417,0.349934999831021,1.02030099928379),    //371
    BP2_CONST6(-1.28665999975055,1.87360799964517,-0.678106999956071,1.91914399992674,0.20106799993664,1.19877899996936),    //372
    BP2_CONST6(0.488668999634683,0.838433999568223,0.674295999109745,0.568815000355243,0.845926999114453,0.287390000186861),    //373
    BP2_CONST6(0.0563889993354678,1.35670000035315,0.402212999761105,0.953598000109195,0.723325999453663,0.4919100003317),    //374
    BP2_CONST6(-1.03907799907028,1.99840999860316,-0.402212999761105,1.75802499894052,0.347832999192178,1.02293800003826),    //375
    BP2_CONST6(-1.28394499979913,1.87680699955672,-0.674295999109745,1.91740699857473,0.203215999528766,1.19632100034505),    //376
    BP2_CONST6(0.482556999661028,0.846780999563634,0.670478999614715,0.574694999493658,0.844186999835073,0.290426000021398),    //377
    BP2_CONST6(0.0628909999504685,1.34992299973964,0.406370999291539,0.948200000450015,0.725188999436795,0.4889360005036),    //378
    BP2_CONST6(-1.04348099976778,1.99802099913358,-0.406370999291539,1.76094199903309,0.345729999244213,1.02557300031185),    //379
    BP2_CONST6(-1.28120299987494,1.87996799964457,-0.670478999614715,1.91565299872308,0.205361999571323,1.19386199954897),    //380
    BP2_CONST6(0.476433999836445,0.855109999887645,0.666655999608337,0.58056899998337,0.842445999383926,0.293461000546813),    //381
    BP2_CONST6(0.0693919993937016,1.34311799984425,0.410523999482393,0.942793999798595,0.727050999179482,0.485961000435054),    //382
    BP2_CONST6(-1.04786299914121,1.99759099911898,-0.410524999722838,1.76384299900382,0.343625999987125,1.0282049998641),    //383
    BP2_CONST6(-1.278433999978,1.88308899942785,-0.666655999608337,1.91388099920004,0.207507999613881,1.19139899965375),    //384
    BP2_CONST6(0.470300999470055,0.863421999849379,0.662825999781489,0.586438000202178,0.840702999383211,0.29649499990046),    //385
    BP2_CONST6(0.075891999527812,1.33628400042653,0.414673999883235,0.937377999536693,0.728910999372601,0.482983999885619),    //386
    BP2_CONST6(-1.05222299974411,1.99711899925023,-0.414673999883235,1.76672599930316,0.34152099955827,1.03083600010722),    //387
    BP2_CONST6(-1.27563799917697,1.8861689986661,-0.662825999781489,1.91209099907428,0.209653999656439,1.18893299996852),    //388
    BP2_CONST6(0.464158999733627,0.871713999658823,0.658989999443292,0.592302000150084,0.838956999592483,0.29952900018543),    //389
    BP2_CONST6(0.0823899991810322,1.32942100055515,0.41882099956274,0.931951999664306,0.73076899908483,0.480006000027061),    //390
    BP2_CONST6(-1.05655999947339,1.99660299904644,-0.41882099956274,1.76959499903023,0.339415999129415,1.03346300031989),    //391
    BP2_CONST6(-1.27281499933451,1.88920999877154,-0.658989999443292,1.91028199903666,0.211798999458551,1.18646499980241),    //392
    BP2_CONST6(0.458005999214947,0.879989000037312,0.65514799952507,0.598159999586641,0.837209999561309,0.302562000229955),    //393
    BP2_CONST6(0.0888859992846847,1.32253100071102,0.422962999902666,0.926518999971449,0.732624999247491,0.477028000168502),    //394
    BP2_CONST6(-1.06087499950081,1.99604599922895,-0.422962999902666,1.77244499977678,0.337308999150991,1.03608900029212),    //395
    BP2_CONST6(-1.26996499951928,1.89221099950373,-0.65514799952507,1.90845599863678,0.213943999260664,1.18399300053715),    //396
    BP2_CONST6(0.451843999326229,0.888244000263512,0.651299999095499,0.604012000374495,0.835459999740123,0.305594999343157),    //397
    BP2_CONST6(0.0953799998387694,1.3156139999628,0.42710099928081,0.921076999977231,0.734479999169707,0.474048000760376),    //398
    BP2_CONST6(-1.06516699958592,1.99544599931687,-0.42710099928081,1.77527999877929,0.335201999172568,1.03871200047433),    //399
    BP2_CONST6(-1.2670879997313,1.89517199900001,-0.651299999095499,1.90661199856549,0.216087999753654,1.18151899985969),    //400
    BP2_CONST6(0.445671999827027,0.896482000127434,0.647445999085903,0.609858000651001,0.833708999678492,0.308625999838114),    //401
    BP2_CONST6(0.101871999911964,1.30866799969226,0.43123499955982,0.915626999922096,0.736332999542355,0.471065999940038),    //402
    BP2_CONST6(-1.06943699996918,1.99480499979108,-0.43123499955982,1.77809699904173,0.333093999885023,1.04133299924433),    //403
    BP2_CONST6(-1.26418399997055,1.89809199981391,-0.647445999085903,1.9047499988228,0.218231999315321,1.17904200032353),    //404
    BP2_CONST6(0.439490999095142,0.904699000529944,0.643584999255836,0.615699000656604,0.831955999135971,0.311657000333071),    //405
    BP2_CONST6(0.108361999504268,1.30169400013983,0.435364999808371,0.910166999325156,0.738183999434113,0.468084000051022),    //406
    BP2_CONST6(-1.07368399947881,1.99411999899893,-0.435364999808371,1.78089699894189,0.330984999425709,1.04395100008696),    //407
    BP2_CONST6(-1.26125299930572,1.90097199846059,-0.643584999255836,1.90286999847739,0.220374999567866,1.17656300030648),    //408
    BP2_CONST6(0.433300999924541,0.91289799939841,0.639718999154865,0.621534000150859,0.830199999734759,0.31468699965626),    //409
    BP2_CONST6(0.114849999547005,1.29469200037419,0.439490999095142,0.904699000529944,0.740033999085426,0.465101000852883),    //410
    BP2_CONST6(-1.07790899928659,1.99339499883353,-0.439490999095142,1.78368099872022,0.328875999897718,1.04656599927693),    //411
    BP2_CONST6(-1.2582959998399,1.9038129998371,-0.639718999154865,1.90097199846059,0.222516999579966,1.1740809995681),    //412
    BP2_CONST6(0.42710099928081,0.921076999977231,0.635845999233424,0.627364000305533,0.828442999161779,0.317716999910772),    //413
    BP2_CONST6(0.121335999108851,1.2876630006358,0.443612999282777,0.899222999811172,0.741881999187171,0.462116000242531),    //414
    BP2_CONST6(-1.08210999984294,1.99262499902397,-0.443612999282777,1.78644899837672,0.32676599919796,1.04917900077998),    //415
    BP2_CONST6(-1.25531199946999,1.90661199856549,-0.635845999233424,1.89905599877238,0.224658999592066,1.17159599997103),    //416
    BP2_CONST6(0.420891999267042,0.929237000644207,0.631967999972403,0.633186999708414,0.826683999970555,0.320744999684393),    //417
    BP2_CONST6(0.127817999571562,1.28060800023376,0.447730999439955,0.893737000413239,0.743727999739348,0.45913099963218),    //418
    BP2_CONST6(-1.08628899976611,1.99181499890983,-0.447730999439955,1.78919899929314,0.324653999879956,1.05179099924862),    //419
    BP2_CONST6(-1.25230099912732,1.90937099885195,-0.631967999972403,1.89712299965322,0.226800999604166,1.16910799965262),    //420
    BP2_CONST6(0.414673999883235,0.937377999536693,0.628082999959588,0.639003999531269,0.824922999367117,0.323773000389338),    //421
    BP2_CONST6(0.134298999793828,1.27352300006896,0.451843999326229,0.888244000263512,0.745571999810636,0.45614399947226),    //422
    BP2_CONST6(-1.09044399950653,1.99096099939197,-0.451843999326229,1.79193199891597,0.322542999871075,1.054397999309),    //423
    BP2_CONST6(-1.24926399998366,1.91208999976515,-0.628082999959588,1.89517099969089,0.22894199937582,1.16661700047552),    //424
    BP2_CONST6(0.408447999507189,0.945497999899089,0.624192999675869,0.644816000014543,0.823159999214112,0.326799999922514),    //425
    BP2_CONST6(0.140775999985635,1.26641299948096,0.455952999182045,0.882743000052869,0.747414999641478,0.453156000003219),    //426
    BP2_CONST6(-1.09457699954509,1.99006699863821,-0.455952999182045,1.79464899841696,0.320429999381304,1.05700400006026),    //427
    BP2_CONST6(-1.24620099924504,1.91476899851113,-0.624192999675869,1.89320199936628,0.231082999147475,1.16412300057709),    //428
    BP2_CONST6(0.402212999761105,0.953598000109195,0.620296999812126,0.650620999746024,0.821394999511539,0.329826000146568),    //429
    BP2_CONST6(0.147249999456108,1.25927700009196,0.460057999938726,0.877232999540865,0.749254999682307,0.450167999602854),    //430
    BP2_CONST6(-1.09868599940091,1.98912899848073,-0.460057999938726,1.79734899941831,0.318316999822855,1.05960700009018),    //431
    BP2_CONST6(-1.24311099946498,1.91740699857473,-0.620296999812126,1.89121499937027,0.233221999369562,1.16162800043821),    //432
    BP2_CONST6(0.395968999713659,0.961678999476134,0.616394999437034,0.65641999989748,0.819627999328076,0.332852000370622),    //433
    BP2_CONST6(0.153720999136567,1.25211300048977,0.464158999733627,0.871713999658823,0.751093999482691,0.447177999652922),    //434
    BP2_CONST6(-1.10277199931442,1.98814999870955,-0.464158999733627,1.80003199912607,0.316202999092638,1.06220800057053),    //435
    BP2_CONST6(-1.23999499995261,1.92000499926507,-0.616394999437034,1.88920999877154,0.235361999832094,1.15912899933755),    //436
    BP2_CONST6(0.389716999605298,0.969738000072538,0.612486999481916,0.662212000228464,0.817858999595046,0.33587700035423),    //437
    BP2_CONST6(0.160188999958336,1.24492299929261,0.468254999257624,0.866187999956309,0.752931999973952,0.444186999462545),    //438
    BP2_CONST6(-1.10683499928563,1.98712799884378,-0.468254999257624,1.80269799847155,0.314087999984622,1.06480599939823),    //439
    BP2_CONST6(-1.23685199953615,1.92256099916994,-0.612486999481916,1.88718699943274,0.237500999122858,1.15662700030952),    //440
    BP2_CONST6(0.383456999436021,0.977777999825775,0.608572999946773,0.667999999597668,0.816087999381124,0.338901000097394),    //441
    BP2_CONST6(0.166653999127448,1.23770599998533,0.472346999682486,0.860652999952435,0.754766999743878,0.44119600020349),    //442
    BP2_CONST6(-1.1108739990741,1.98606399819254,-0.472346999682486,1.8053469993174,0.311971999704838,1.06740199960768),    //443
    BP2_CONST6(-1.23368399962782,1.92507799901068,-0.608572999946773,1.88514599949121,0.2396389991045,1.1541230008006),    //444
    BP2_CONST6(0.377188999205828,0.985795999877154,0.604653999209403,0.673780000768601,0.814315999858081,0.341923999600112),    //445
    BP2_CONST6(0.173114999197423,1.23046300001442,0.476433999836445,0.855109999887645,0.756600999273359,0.4382020002231),    //446
    BP2_CONST6(-1.11488999985158,1.98495899979025,-0.476433999836445,1.80797799956053,0.309855999425054,1.06999500002712),    //447
    BP2_CONST6(-1.23048899974673,1.92755299899727,-0.604653999209403,1.8830879991874,0.241776999086142,1.15161600057035),    //448
    BP2_CONST6(0.370911999605596,0.993793999776244,0.600728999823331,0.679553999565541,0.812540999613702,0.344945999793708),    //449
    BP2_CONST6(0.179571999236941,1.22319400031119,0.480516999959946,0.849558999761939,0.758432999253273,0.43520800024271),    //450
    BP2_CONST6(-1.11888199951499,1.98381099943071,-0.480516999959946,1.81059299968183,0.307738999836147,1.07258599996566),    //451
    BP2_CONST6(-1.22726799920201,1.92998699843883,-0.600728999823331,1.8810119992122,0.243913999758661,1.14910599961876),    //452
    BP2_CONST6(0.364627999253571,1.00177100021392,0.596797999925911,0.685321999713778,0.810764999128878,0.347967000678182),    //453
    BP2_CONST6(0.186025999486446,1.21589899994432,0.484594999812543,0.844000999815762,0.760262999683618,0.43221400026232),    //454
    BP2_CONST6(-1.1228509992361,1.98262199852615,-0.484594999812543,1.81319099944084,0.305620999075472,1.0751740001142),    //455
    BP2_CONST6(-1.22402099985629,1.93237999919801,-0.596797999925911,1.8789179995656,0.246049999259412,1.14659500028938),    //456
    BP2_CONST6(0.358335999771953,1.00972600001841,0.592861999757587,0.691083000041544,0.808985999785363,0.350988999940455),    //457
    BP2_CONST6(0.192474999465048,1.20857900008559,0.488668999634683,0.838433999568223,0.762090999633073,0.42921799980104),    //458
    BP2_CONST6(-1.12679599970579,1.98138999938964,-0.488668999634683,1.81577199883759,0.30350299924612,1.07776000071316),    //459
    BP2_CONST6(-1.22074799984693,1.93473199941217,-0.592861999757587,1.87680699955672,0.248185999691486,1.14407999999821),    //460
    BP2_CONST6(0.352036999538541,1.0176600003615,0.588919999077916,0.696838000789284,0.807205999270081,0.354008000344038),    //461
    BP2_CONST6(0.198920999653637,1.20123299956321,0.49273799918592,0.832860000431537,0.763917999342083,0.426219999790192),    //462
    BP2_CONST6(-1.13071699999272,1.98011699970811,-0.49273799918592,1.81833599880337,0.301382999867201,1.08034399989992),    //463
    BP2_CONST6(-1.21744999941438,1.93704499863088,-0.588919999077916,1.87467799894511,0.250321999192238,1.1415610006079),    //464
    BP2_CONST6(0.345729999244213,1.0255720000714,0.584972999989986,0.702584999613463,0.805423999205231,0.357027000747621),    //465
    BP2_CONST6(0.205361999571323,1.19386100023984,0.496802999638021,0.827277000062167,0.765742999501526,0.423221999779344),    //466
    BP2_CONST6(-1.13461299985647,1.97880099900066,-0.496802999638021,1.8208829993382,0.299263999797404,1.08292299974709),    //467
    BP2_CONST6(-1.21412499994039,1.93931499961763,-0.584972999989986,1.87253099959343,0.252456999383867,1.13904100004583),    //468
    BP2_CONST6(0.339414999820292,1.03346399962902,0.581019999459385,0.708327000029385,0.803638999350368,0.360046000219882),    //469
    BP2_CONST6(0.211798999458551,1.18646400049328,0.500862999819219,0.821685999631881,0.767564999870955,0.420223999768496),    //470
    BP2_CONST6(-1.13848599977791,1.97744299937039,-0.500862999819219,1.82341199927031,0.297142999246716,1.08550200052559),    //471
    BP2_CONST6(-1.21077499911189,1.94154399819672,-0.581019999459385,1.87036699894815,0.254590999335051,1.13651800062507),    //472
    BP2_CONST6(0.333093999885023,1.0413319999352,0.577061999589204,0.714061999693512,0.801852999255061,0.363064000383019),    //473
    BP2_CONST6(0.218230999074876,1.17904300056397,0.504917999729514,0.816087999381124,0.769386999309062,0.417222999967635),    //474
    BP2_CONST6(-1.1423349995166,1.97604399919509,-0.504917999729514,1.82592499908059,0.295021999627352,1.0880770003423),    //475
    BP2_CONST6(-1.20739899948239,1.94373299926519,-0.577061999589204,1.86818599887192,0.256724999286234,1.13399200048297),    //476
    BP2_CONST6(0.32676599919796,1.04917900077998,0.573097999207675,0.719790000468492,0.80006599985063,0.366078999824822),    //477
    BP2_CONST6(0.224658999592066,1.17159599997103,0.508967999368906,0.810483000241219,0.771205999888479,0.414222999475896),    //478
    BP2_CONST6(-1.14615999907255,1.97460299823433,-0.508968999609351,1.82841999921947,0.292899999767542,1.09064999967813),    //479
    BP2_CONST6(-1.2039979994297,1.94587999861687,-0.573097999207675,1.86598599888384,0.258857999928296,1.13146299961954),    //480
    BP2_CONST6(0.320429999381304,1.05700400006026,0.569128999486565,0.725511000491678,0.798275999724864,0.36909499950707),    //481
    BP2_CONST6(0.231081999838352,1.16412399988621,0.513013999909162,0.804868999868631,0.773022999987006,0.41122099943459),    //482
    BP2_CONST6(-1.14995999913662,1.97311999835073,-0.513013999909162,1.83089699968695,0.290776999667287,1.09322000015527),    //483
    BP2_CONST6(-1.20057099964469,1.94798599928617,-0.569128999486565,1.8637689994648,0.260989999398589,1.12893200013786),    //484
    BP2_CONST6(0.314087999984622,1.06480599939823,0.565153999254107,0.731226000003516,0.796483999118208,0.372110000811517),    //485
    BP2_CONST6(0.237500999122858,1.15662700030952,0.517054999247193,0.799248000606894,0.774838999845087,0.408218000084162),    //486
    BP2_CONST6(-1.15373599994927,1.97159499954432,-0.517054999247193,1.83335799910128,0.288653999567032,1.09578800015151),    //487
    BP2_CONST6(-1.19711899943649,1.95005099941045,-0.565153999254107,1.86153399851173,0.263121999800205,1.12639799993485),    //488
    BP2_CONST6(0.307738999836147,1.07258599996566,0.561173999682068,0.736933999694883,0.79469099920243,0.375124000012875),    //489
    BP2_CONST6(0.243913999758661,1.14910699985921,0.521090999245643,0.793620000593364,0.776652999222278,0.405214000493288),    //490
    BP2_CONST6(-1.15748799964785,1.97002899926155,-0.521090999245643,1.83580199908465,0.286529999226332,1.09835300035774),    //491
    BP2_CONST6(-1.19364199973642,1.9520749989897,-0.561173999682068,1.85928199905902,0.265252999961376,1.12386199925094),    //492
    BP2_CONST6(0.301383999176323,1.0803430005908,0.557188999839127,0.742633999325335,0.792894999496638,0.378138000145555),    //493
    BP2_CONST6(0.250321999192238,1.1415610006079,0.525121999904513,0.787983999587595,0.778464999981224,0.402208999730647),    //494
    BP2_CONST6(-1.16121499985456,1.96842099912464,-0.525121999904513,1.83822799939662,0.284404999576509,1.10091600008308),    //495
    BP2_CONST6(-1.19013899937272,1.9540569987148,-0.557188999839127,1.85701299924403,0.267383999191225,1.12132300063967),    //496
    BP2_CONST6(0.295021999627352,1.0880770003423,0.553198999725282,0.74832799937576,0.791097999550402,0.381148999556899),    //497
    BP2_CONST6(0.256723999977112,1.13399299979209,0.529147999361157,0.782341000624001,0.780274999327957,0.399203999899328),    //498
    BP2_CONST6(-1.16491699963808,1.96677099913358,-0.529147999361157,1.84063699934631,0.282279999926686,1.10347600001841),    //499
    BP2_CONST6(-1.18661099951714,1.9559979988262,-0.553197999484837,1.85472499858587,0.269512999802828,1.11878199968487),    //500
    BP2_CONST6(0.288653999567032,1.09578800015151,0.549202999100089,0.754015000537037,0.789298999123275,0.384161000140011),    //501
    BP2_CONST6(0.263121999800205,1.12639799993485,0.53316899947822,0.776689999736845,0.782083999365568,0.396196000277996),    //502
    BP2_CONST6(-1.16859399992972,1.96507799904793,-0.53316899947822,1.84302799869328,0.280152999795973,1.10603399947285),    //503
    BP2_CONST6(-1.18305699992924,1.95789599977433,-0.549202999100089,1.85242099873721,0.271642999723554,1.11623699963092),    //504
    BP2_CONST6(0.282279999926686,1.10347499977797,0.545201999135315,0.759694000706076,0.78749799914658,0.387171000242233),    //505
    BP2_CONST6(0.269512999802828,1.11878199968487,0.537184999324381,0.771031999960541,0.783889999613165,0.393188999965787),    //506
    BP2_CONST6(-1.17224799934774,1.96334599889814,-0.537184999324381,1.8454019986093,0.278026999905705,1.10858799982815),    //507
    BP2_CONST6(-1.17947899922728,1.95975499879568,-0.545201999135315,1.85009899828583,0.273770999163389,1.11369100026786),    //508
    BP2_CONST6(0.275898999534547,1.11114099994301,0.541195999830961,0.765366999432444,0.785694999620318,0.390181000344455),    //509
    BP2_CONST6(0.275898999534547,1.11114099994301,0.541195999830961,0.765366999432444,0.785694999620318,0.390181000344455),    //510
    BP2_CONST6(-1.17587599996477,1.96157099958509,-0.541195999830961,1.84775899909436,0.275898999534547,1.11114099994301),    //511
    BP2_CONST6(-1.17587599996477,1.96157099958509,-0.541195999830961,1.84775899909436,0.275898999534547,1.11114099994301)     //512
};

#elif !defined(PLATFORM_LPC_DIRECT)

//#pragma COMPILER_MESSAGE(__FILE__ "(559) : Warning - constants for MARCs LPC")

// TODO: rebuild lpc_const3 and lpc_const4 from first principles - LPC is sensitive and this does not generate as good precision as PLATFORM_LPC_DIRECT

#define BP2_CONST4(a,b,c,d) BP2_FROM_FLOAT(a),BP2_FROM_FLOAT(b),BP2_FROM_FLOAT(c),BP2_FROM_FLOAT(d)

// the following takes 2kb and will get loaded in the cache during prvLpcToSpectrum
const BP2Type lpc_cnst3[] = {
BP2_CONST4(1.000000,1.000000,-1.000000,-1.000000),      // previously was 0,0,0,0,
BP2_CONST4(1.012196,1.006117,-0.987653,-0.993845),
BP2_CONST4(1.024240,1.012196,-0.975158,-0.987653),
BP2_CONST4(1.036130,1.018237,-0.962515,-0.981424),
BP2_CONST4(1.047863,1.024240,-0.949728,-0.975158),
BP2_CONST4(1.059439,1.030204,-0.936797,-0.968855),
BP2_CONST4(1.070855,1.036130,-0.923726,-0.962515),
BP2_CONST4(1.082110,1.042016,-0.910515,-0.956140),
BP2_CONST4(1.093202,1.047863,-0.897168,-0.949728),
BP2_CONST4(1.104129,1.053671,-0.883685,-0.943280),
BP2_CONST4(1.114890,1.059439,-0.870069,-0.936797),
BP2_CONST4(1.125483,1.065167,-0.856322,-0.930279),
BP2_CONST4(1.135907,1.070855,-0.842446,-0.923726),
BP2_CONST4(1.146160,1.076503,-0.828443,-0.917138),
BP2_CONST4(1.156240,1.082110,-0.814316,-0.910515),
BP2_CONST4(1.166145,1.087676,-0.800066,-0.903858),
BP2_CONST4(1.175876,1.093202,-0.785695,-0.897168),
BP2_CONST4(1.185429,1.098686,-0.771206,-0.890443),
BP2_CONST4(1.194803,1.104129,-0.756601,-0.883685),
BP2_CONST4(1.203998,1.109531,-0.741882,-0.876893),
BP2_CONST4(1.213011,1.114890,-0.727051,-0.870069),
BP2_CONST4(1.221842,1.120208,-0.712111,-0.863212),
BP2_CONST4(1.230489,1.125483,-0.697063,-0.856322),
BP2_CONST4(1.238950,1.130716,-0.681911,-0.849400),
BP2_CONST4(1.247225,1.135907,-0.666656,-0.842446),
BP2_CONST4(1.255312,1.141055,-0.651300,-0.835460),
BP2_CONST4(1.263210,1.146160,-0.635846,-0.828443),
BP2_CONST4(1.270918,1.151221,-0.620297,-0.821395),
BP2_CONST4(1.278434,1.156240,-0.604654,-0.814316),
BP2_CONST4(1.285758,1.161214,-0.588920,-0.807206),
BP2_CONST4(1.292888,1.166145,-0.573098,-0.800066),
BP2_CONST4(1.299823,1.171033,-0.557189,-0.792895),
BP2_CONST4(1.306563,1.175876,-0.541196,-0.785695),
BP2_CONST4(1.313106,1.180674,-0.525122,-0.778465),
BP2_CONST4(1.319451,1.185429,-0.508968,-0.771206),
BP2_CONST4(1.325598,1.190138,-0.492738,-0.763918),
BP2_CONST4(1.331544,1.194803,-0.476434,-0.756601),
BP2_CONST4(1.337291,1.199423,-0.460058,-0.749255),
BP2_CONST4(1.342836,1.203998,-0.443613,-0.741882),
BP2_CONST4(1.348178,1.208528,-0.427101,-0.734480),
BP2_CONST4(1.353318,1.213012,-0.410524,-0.727051),
BP2_CONST4(1.358254,1.217450,-0.393886,-0.719594),
BP2_CONST4(1.362985,1.221842,-0.377189,-0.712111),
BP2_CONST4(1.367511,1.226189,-0.360434,-0.704600),
BP2_CONST4(1.371831,1.230489,-0.343626,-0.697063),
BP2_CONST4(1.375945,1.234743,-0.326765,-0.689500),
BP2_CONST4(1.379851,1.238950,-0.309856,-0.681911),
BP2_CONST4(1.383550,1.243111,-0.292900,-0.674296),
BP2_CONST4(1.387040,1.247225,-0.275899,-0.666656),
BP2_CONST4(1.390321,1.251292,-0.258857,-0.658990),
BP2_CONST4(1.393393,1.255312,-0.241777,-0.651300),
BP2_CONST4(1.396255,1.259285,-0.224659,-0.643585),
BP2_CONST4(1.398907,1.263210,-0.207508,-0.635846),
BP2_CONST4(1.401348,1.267088,-0.190326,-0.628083),
BP2_CONST4(1.403578,1.270918,-0.173115,-0.620297),
BP2_CONST4(1.405597,1.274700,-0.155878,-0.612487),
BP2_CONST4(1.407404,1.278434,-0.138617,-0.604654),
BP2_CONST4(1.408999,1.282120,-0.121336,-0.596798),
BP2_CONST4(1.410382,1.285758,-0.104036,-0.588920),
BP2_CONST4(1.411552,1.289347,-0.086721,-0.581020),
BP2_CONST4(1.412510,1.292888,-0.069392,-0.573098),
BP2_CONST4(1.413255,1.296380,-0.052053,-0.565154),
BP2_CONST4(1.413788,1.299823,-0.034706,-0.557189),
BP2_CONST4(1.414107,1.303218,-0.017355,-0.549203),
BP2_CONST4(1.414214,1.306563, 0.000000,-0.541196),
BP2_CONST4(1.414107,1.309859, 0.017355,-0.533169),
BP2_CONST4(1.413788,1.313106, 0.034707,-0.525122),
BP2_CONST4(1.413255,1.316303, 0.052053,-0.517055),
BP2_CONST4(1.412510,1.319451, 0.069392,-0.508968),
BP2_CONST4(1.411552,1.322549, 0.086721,-0.500863),
BP2_CONST4(1.410382,1.325598, 0.104036,-0.492738),
BP2_CONST4(1.408999,1.328596, 0.121336,-0.484595),
BP2_CONST4(1.407404,1.331544, 0.138617,-0.476434),
BP2_CONST4(1.405597,1.334443, 0.155878,-0.468255),
BP2_CONST4(1.403578,1.337291, 0.173115,-0.460058),
BP2_CONST4(1.401348,1.340088, 0.190326,-0.451844),
BP2_CONST4(1.398907,1.342836, 0.207508,-0.443613),
BP2_CONST4(1.396255,1.345532, 0.224659,-0.435365),
BP2_CONST4(1.393393,1.348178, 0.241777,-0.427101),
BP2_CONST4(1.390321,1.350774, 0.258857,-0.418821),
BP2_CONST4(1.387040,1.353318, 0.275899,-0.410525),
BP2_CONST4(1.383550,1.355812, 0.292900,-0.402213),
BP2_CONST4(1.379851,1.358254, 0.309856,-0.393886),
BP2_CONST4(1.375945,1.360645, 0.326765,-0.385545),
BP2_CONST4(1.371831,1.362985, 0.343626,-0.377189),
BP2_CONST4(1.367511,1.365274, 0.360434,-0.368819),
BP2_CONST4(1.362985,1.367511, 0.377189,-0.360434),
BP2_CONST4(1.358254,1.369697, 0.393886,-0.352037),
BP2_CONST4(1.353318,1.371831, 0.410525,-0.343626),
BP2_CONST4(1.348179,1.373914, 0.427101,-0.335202),
BP2_CONST4(1.342836,1.375945, 0.443613,-0.326766),
BP2_CONST4(1.337291,1.377924, 0.460058,-0.318317),
BP2_CONST4(1.331544,1.379851, 0.476434,-0.309856),
BP2_CONST4(1.325598,1.381727, 0.492738,-0.301383),
BP2_CONST4(1.319451,1.383550, 0.508969,-0.292900),
BP2_CONST4(1.313106,1.385321, 0.525122,-0.284405),
BP2_CONST4(1.306563,1.387040, 0.541196,-0.275899),
BP2_CONST4(1.299824,1.388707, 0.557189,-0.267384),
BP2_CONST4(1.292888,1.390321, 0.573098,-0.258858),
BP2_CONST4(1.285758,1.391883, 0.588920,-0.250322),
BP2_CONST4(1.278434,1.393393, 0.604654,-0.241777),
BP2_CONST4(1.270918,1.394850, 0.620297,-0.233222),
BP2_CONST4(1.263210,1.396255, 0.635846,-0.224659),
BP2_CONST4(1.255312,1.397607, 0.651300,-0.216088),
BP2_CONST4(1.247225,1.398907, 0.666656,-0.207508),
BP2_CONST4(1.238950,1.400154, 0.681911,-0.198921),
BP2_CONST4(1.230489,1.401348, 0.697063,-0.190326),
BP2_CONST4(1.221842,1.402489, 0.712111,-0.181724),
BP2_CONST4(1.213012,1.403578, 0.727051,-0.173115),
BP2_CONST4(1.203998,1.404614, 0.741882,-0.164499),
BP2_CONST4(1.194803,1.405597, 0.756601,-0.155878),
BP2_CONST4(1.185429,1.406527, 0.771206,-0.147250),
BP2_CONST4(1.175876,1.407404, 0.785695,-0.138617),
BP2_CONST4(1.166146,1.408228, 0.800066,-0.129979),
BP2_CONST4(1.156240,1.408999, 0.814316,-0.121336),
BP2_CONST4(1.146160,1.409717, 0.828443,-0.112688),
BP2_CONST4(1.135907,1.410382, 0.842446,-0.104036),
BP2_CONST4(1.125484,1.410994, 0.856322,-0.095380),
BP2_CONST4(1.114890,1.411552, 0.870069,-0.086721),
BP2_CONST4(1.104129,1.412058, 0.883685,-0.078058),
BP2_CONST4(1.093202,1.412510, 0.897168,-0.069392),
BP2_CONST4(1.082110,1.412909, 0.910515,-0.060724),
BP2_CONST4(1.070855,1.413255, 0.923726,-0.052053),
BP2_CONST4(1.059439,1.413548, 0.936797,-0.043381),
BP2_CONST4(1.047863,1.413788, 0.949728,-0.034707),
BP2_CONST4(1.036130,1.413974, 0.962515,-0.026031),
BP2_CONST4(1.024240,1.414107, 0.975158,-0.017355),
BP2_CONST4(1.012196,1.414187, 0.987653,-0.008677),
BP2_CONST4(1.000000,1.414213, 1.000000, 0.000000),  
0,0,0,0
};

#define BP2_CONST6(a,b,c,d,e,f) BP2_FROM_FLOAT(a),BP2_FROM_FLOAT(b),BP2_FROM_FLOAT(c), \
                                BP2_FROM_FLOAT(d),BP2_FROM_FLOAT(e),BP2_FROM_FLOAT(f)

// the following takes 12kb and will get loaded in the cache during prvLpcToSpectrum
const BP2Type lpc_cnst4[] = {
BP2_CONST6(1.000000,1.000000,1.000000,1.000000,1.000000,1.000000),   // previously 0,0,0,0,0,0,
BP2_CONST6(0.995387,1.004591,0.996927,1.003063,0.998465,1.001533),
BP2_CONST6(0.990754,1.009161,0.993845,1.006117,0.996927,1.003063),
BP2_CONST6(0.986099,1.013710,0.990754,1.009161,0.995387,1.004591),
BP2_CONST6(0.981424,1.018237,0.987653,1.012196,0.993845,1.006117),
BP2_CONST6(0.976727,1.022743,0.984543,1.015221,0.992301,1.007640),
BP2_CONST6(0.972010,1.027227,0.981424,1.018237,0.990754,1.009161),
BP2_CONST6(0.967273,1.031689,0.978295,1.021243,0.989205,1.010680),
BP2_CONST6(0.962515,1.036130,0.975158,1.024240,0.987653,1.012196),
BP2_CONST6(0.957737,1.040548,0.972011,1.027227,0.986099,1.013710),
BP2_CONST6(0.952938,1.044944,0.968854,1.030204,0.984543,1.015221),
BP2_CONST6(0.948119,1.049319,0.965689,1.033172,0.982985,1.016731),
BP2_CONST6(0.943280,1.053671,0.962515,1.036130,0.981424,1.018237),
BP2_CONST6(0.938421,1.058001,0.959332,1.039078,0.979861,1.019742),
BP2_CONST6(0.933542,1.062308,0.956139,1.042016,0.978295,1.021243),
BP2_CONST6(0.928644,1.066593,0.952938,1.044944,0.976728,1.022743),
BP2_CONST6(0.923726,1.070855,0.949728,1.047863,0.975158,1.024240),
BP2_CONST6(0.918788,1.075094,0.946508,1.050772,0.973585,1.025735),
BP2_CONST6(0.913831,1.079311,0.943280,1.053671,0.972011,1.027227),
BP2_CONST6(0.908854,1.083505,0.940043,1.056560,0.970434,1.028717),
BP2_CONST6(0.903858,1.087676,0.936797,1.059439,0.968855,1.030204),
BP2_CONST6(0.898843,1.091824,0.933543,1.062308,0.967273,1.031689),
BP2_CONST6(0.893809,1.095949,0.930279,1.065167,0.965689,1.033172),
BP2_CONST6(0.888757,1.100051,0.927007,1.068016,0.964103,1.034652),
BP2_CONST6(0.883685,1.104129,0.923726,1.070855,0.962515,1.036130),
BP2_CONST6(0.878594,1.108184,0.920436,1.073684,0.960925,1.037605),
BP2_CONST6(0.873485,1.112215,0.917138,1.076503,0.959332,1.039078),
BP2_CONST6(0.868358,1.116224,0.913831,1.079311,0.957737,1.040548),
BP2_CONST6(0.863212,1.120208,0.910515,1.082110,0.956140,1.042016),
BP2_CONST6(0.858047,1.124168,0.907191,1.084898,0.954540,1.043481),
BP2_CONST6(0.852865,1.128105,0.903858,1.087676,0.952938,1.044944),
BP2_CONST6(0.847664,1.132018,0.900517,1.090444,0.951334,1.046405),
BP2_CONST6(0.842446,1.135907,0.897168,1.093202,0.949728,1.047863),
BP2_CONST6(0.837210,1.139772,0.893809,1.095949,0.948119,1.049319),
BP2_CONST6(0.831956,1.143612,0.890443,1.098686,0.946508,1.050772),
BP2_CONST6(0.826684,1.147429,0.887068,1.101413,0.944896,1.052223),
BP2_CONST6(0.821395,1.151221,0.883685,1.104129,0.943280,1.053671),
BP2_CONST6(0.816088,1.154989,0.880293,1.106835,0.941663,1.055117),
BP2_CONST6(0.810765,1.158732,0.876893,1.109530,0.940043,1.056560),
BP2_CONST6(0.805424,1.162451,0.873485,1.112216,0.938421,1.058001),
BP2_CONST6(0.800066,1.166146,0.870069,1.114890,0.936797,1.059439),
BP2_CONST6(0.794691,1.169815,0.866644,1.117554,0.935171,1.060875),
BP2_CONST6(0.789299,1.173460,0.863212,1.120208,0.933543,1.062308),
BP2_CONST6(0.783890,1.177080,0.859771,1.122851,0.931912,1.063739),
BP2_CONST6(0.778465,1.180675,0.856322,1.125483,0.930279,1.065167),
BP2_CONST6(0.773024,1.184244,0.852865,1.128105,0.928644,1.066593),
BP2_CONST6(0.767565,1.187789,0.849400,1.130716,0.927007,1.068016),
BP2_CONST6(0.762091,1.191309,0.845927,1.133317,0.925367,1.069437),
BP2_CONST6(0.756601,1.194803,0.842446,1.135907,0.923726,1.070855),
BP2_CONST6(0.751094,1.198272,0.838957,1.138486,0.922082,1.072271),
BP2_CONST6(0.745572,1.201716,0.835460,1.141055,0.920436,1.073684),
BP2_CONST6(0.740034,1.205135,0.831956,1.143613,0.918788,1.075095),
BP2_CONST6(0.734480,1.208527,0.828443,1.146160,0.917138,1.076503),
BP2_CONST6(0.728911,1.211895,0.824923,1.148696,0.915485,1.077908),
BP2_CONST6(0.723326,1.215236,0.821395,1.151221,0.913831,1.079311),
BP2_CONST6(0.717726,1.218552,0.817859,1.153736,0.912174,1.080712),
BP2_CONST6(0.712111,1.221842,0.814316,1.156240,0.910515,1.082110),
BP2_CONST6(0.706480,1.225106,0.810765,1.158732,0.908854,1.083505),
BP2_CONST6(0.700835,1.228344,0.807206,1.161214,0.907191,1.084898),
BP2_CONST6(0.695175,1.231557,0.803639,1.163685,0.905526,1.086289),
BP2_CONST6(0.689500,1.234743,0.800066,1.166145,0.903858,1.087676),
BP2_CONST6(0.683811,1.237903,0.796484,1.168594,0.902189,1.089062),
BP2_CONST6(0.678106,1.241036,0.792895,1.171032,0.900517,1.090444),
BP2_CONST6(0.672388,1.244144,0.789299,1.173460,0.898843,1.091824),
BP2_CONST6(0.666656,1.247225,0.785695,1.175876,0.897168,1.093202),
BP2_CONST6(0.660909,1.250280,0.782084,1.178281,0.895490,1.094577),
BP2_CONST6(0.655148,1.253308,0.778465,1.180674,0.893809,1.095949),
BP2_CONST6(0.649374,1.256310,0.774839,1.183057,0.892127,1.097319),
BP2_CONST6(0.643585,1.259285,0.771206,1.185429,0.890443,1.098686),
BP2_CONST6(0.637783,1.262233,0.767565,1.187789,0.888757,1.100051),
BP2_CONST6(0.631968,1.265155,0.763918,1.190138,0.887068,1.101413),
BP2_CONST6(0.626139,1.268050,0.760263,1.192477,0.885377,1.102772),
BP2_CONST6(0.620297,1.270918,0.756601,1.194803,0.883685,1.104129),
BP2_CONST6(0.614442,1.273759,0.752932,1.197119,0.881990,1.105483),
BP2_CONST6(0.608573,1.276573,0.749255,1.199423,0.880293,1.106835),
BP2_CONST6(0.602692,1.279360,0.745572,1.201716,0.878594,1.108184),
BP2_CONST6(0.596798,1.282120,0.741882,1.203998,0.876893,1.109531),
BP2_CONST6(0.590892,1.284853,0.738184,1.206268,0.875190,1.110874),
BP2_CONST6(0.584973,1.287558,0.734480,1.208527,0.873485,1.112216),
BP2_CONST6(0.579041,1.290236,0.730769,1.210775,0.871778,1.113554),
BP2_CONST6(0.573098,1.292888,0.727051,1.213011,0.870069,1.114890),
BP2_CONST6(0.567142,1.295511,0.723326,1.215236,0.868358,1.116224),
BP2_CONST6(0.561174,1.298107,0.719594,1.217450,0.866644,1.117554),
BP2_CONST6(0.555194,1.300676,0.715856,1.219652,0.864929,1.118882),
BP2_CONST6(0.549203,1.303218,0.712111,1.221842,0.863212,1.120208),
BP2_CONST6(0.543200,1.305731,0.708359,1.224021,0.861492,1.121531),
BP2_CONST6(0.537185,1.308217,0.704600,1.226189,0.859771,1.122851),
BP2_CONST6(0.531159,1.310676,0.700835,1.228345,0.858047,1.124169),
BP2_CONST6(0.525122,1.313106,0.697063,1.230489,0.856322,1.125483),
BP2_CONST6(0.519073,1.315509,0.693285,1.232622,0.854594,1.126796),
BP2_CONST6(0.513014,1.317883,0.689500,1.234743,0.852865,1.128105),
BP2_CONST6(0.506944,1.320230,0.685709,1.236852,0.851133,1.129412),
BP2_CONST6(0.500863,1.322549,0.681911,1.238950,0.849400,1.130716),
BP2_CONST6(0.494771,1.324840,0.678107,1.241036,0.847664,1.132018),
BP2_CONST6(0.488669,1.327103,0.674296,1.243111,0.845927,1.133317),
BP2_CONST6(0.482557,1.329338,0.670479,1.245174,0.844187,1.134613),
BP2_CONST6(0.476434,1.331544,0.666656,1.247225,0.842446,1.135907),
BP2_CONST6(0.470301,1.333723,0.662826,1.249264,0.840703,1.137198),
BP2_CONST6(0.464159,1.335873,0.658990,1.251292,0.838957,1.138486),
BP2_CONST6(0.458006,1.337995,0.655148,1.253308,0.837210,1.139772),
BP2_CONST6(0.451844,1.340088,0.651300,1.255312,0.835460,1.141055),
BP2_CONST6(0.445672,1.342154,0.647446,1.257304,0.833709,1.142335),
BP2_CONST6(0.439491,1.344190,0.643585,1.259284,0.831956,1.143613),
BP2_CONST6(0.433301,1.346199,0.639719,1.261253,0.830200,1.144887),
BP2_CONST6(0.427101,1.348178,0.635846,1.263210,0.828443,1.146160),
BP2_CONST6(0.420892,1.350129,0.631968,1.265155,0.826684,1.147429),
BP2_CONST6(0.414674,1.352052,0.628083,1.267087,0.824923,1.148696),
BP2_CONST6(0.408448,1.353946,0.624193,1.269009,0.823160,1.149960),
BP2_CONST6(0.402213,1.355811,0.620297,1.270918,0.821395,1.151221),
BP2_CONST6(0.395969,1.357648,0.616395,1.272815,0.819628,1.152480),
BP2_CONST6(0.389717,1.359455,0.612487,1.274699,0.817859,1.153736),
BP2_CONST6(0.383457,1.361235,0.608573,1.276573,0.816088,1.154989),
BP2_CONST6(0.377189,1.362985,0.604654,1.278434,0.814316,1.156240),
BP2_CONST6(0.370912,1.364706,0.600729,1.280283,0.812541,1.157487),
BP2_CONST6(0.364628,1.366399,0.596798,1.282120,0.810765,1.158732),
BP2_CONST6(0.358336,1.368062,0.592862,1.283945,0.808986,1.159975),
BP2_CONST6(0.352037,1.369697,0.588920,1.285758,0.807206,1.161214),
BP2_CONST6(0.345730,1.371302,0.584973,1.287558,0.805424,1.162451),
BP2_CONST6(0.339415,1.372879,0.581020,1.289347,0.803639,1.163685),
BP2_CONST6(0.333094,1.374426,0.577062,1.291124,0.801853,1.164917),
BP2_CONST6(0.326766,1.375945,0.573098,1.292888,0.800066,1.166145),
BP2_CONST6(0.320430,1.377434,0.569129,1.294640,0.798276,1.167371),
BP2_CONST6(0.314088,1.378894,0.565154,1.296380,0.796484,1.168594),
BP2_CONST6(0.307739,1.380325,0.561174,1.298108,0.794691,1.169815),
BP2_CONST6(0.301384,1.381727,0.557189,1.299823,0.792895,1.171033),
BP2_CONST6(0.295022,1.383099,0.553199,1.301527,0.791098,1.172247),
BP2_CONST6(0.288654,1.384442,0.549203,1.303218,0.789299,1.173460),
BP2_CONST6(0.282280,1.385755,0.545202,1.304896,0.787498,1.174669),
BP2_CONST6(0.275899,1.387040,0.541196,1.306563,0.785695,1.175876),
BP2_CONST6(0.269513,1.388295,0.537185,1.308217,0.783890,1.177079),
BP2_CONST6(0.263122,1.389520,0.533169,1.309859,0.782084,1.178280),
BP2_CONST6(0.256724,1.390717,0.529148,1.311489,0.780275,1.179479),
BP2_CONST6(0.250322,1.391883,0.525122,1.313106,0.778465,1.180674),
BP2_CONST6(0.243914,1.393021,0.521091,1.314711,0.776653,1.181867),
BP2_CONST6(0.237501,1.394128,0.517055,1.316303,0.774839,1.183057),
BP2_CONST6(0.231082,1.395206,0.513014,1.317883,0.773023,1.184244),
BP2_CONST6(0.224659,1.396255,0.508968,1.319451,0.771206,1.185429),
BP2_CONST6(0.218231,1.397274,0.504918,1.321006,0.769387,1.186610),
BP2_CONST6(0.211799,1.398263,0.500863,1.322549,0.767565,1.187789),
BP2_CONST6(0.205362,1.399223,0.496803,1.324080,0.765743,1.188965),
BP2_CONST6(0.198921,1.400154,0.492738,1.325598,0.763918,1.190138),
BP2_CONST6(0.192475,1.401054,0.488669,1.327103,0.762091,1.191309),
BP2_CONST6(0.186026,1.401925,0.484595,1.328596,0.760263,1.192477),
BP2_CONST6(0.179572,1.402766,0.480517,1.330076,0.758433,1.193641),
BP2_CONST6(0.173115,1.403578,0.476434,1.331544,0.756601,1.194803),
BP2_CONST6(0.166654,1.404360,0.472347,1.333000,0.754767,1.195963),
BP2_CONST6(0.160189,1.405112,0.468255,1.334443,0.752932,1.197119),
BP2_CONST6(0.153721,1.405834,0.464159,1.335873,0.751094,1.198272),
BP2_CONST6(0.147250,1.406527,0.460058,1.337291,0.749255,1.199423),
BP2_CONST6(0.140776,1.407189,0.455953,1.338696,0.747415,1.200571),
BP2_CONST6(0.134299,1.407822,0.451844,1.340088,0.745572,1.201716),
BP2_CONST6(0.127818,1.408426,0.447731,1.341468,0.743728,1.202859),
BP2_CONST6(0.121336,1.408999,0.443613,1.342836,0.741882,1.203998),
BP2_CONST6(0.114850,1.409542,0.439491,1.344190,0.740034,1.205135),
BP2_CONST6(0.108362,1.410056,0.435365,1.345532,0.738184,1.206268),
BP2_CONST6(0.101872,1.410540,0.431235,1.346862,0.736333,1.207399),
BP2_CONST6(0.095380,1.410994,0.427101,1.348178,0.734480,1.208528),
BP2_CONST6(0.088886,1.411417,0.422963,1.349482,0.732625,1.209653),
BP2_CONST6(0.082390,1.411811,0.418821,1.350773,0.730769,1.210775),
BP2_CONST6(0.075892,1.412176,0.414674,1.352052,0.728911,1.211895),
BP2_CONST6(0.069392,1.412510,0.410524,1.353318,0.727051,1.213012),
BP2_CONST6(0.062891,1.412814,0.406371,1.354571,0.725189,1.214125),
BP2_CONST6(0.056389,1.413089,0.402213,1.355811,0.723326,1.215236),
BP2_CONST6(0.049885,1.413334,0.398052,1.357039,0.721461,1.216344),
BP2_CONST6(0.043381,1.413548,0.393886,1.358254,0.719594,1.217450),
BP2_CONST6(0.036875,1.413733,0.389717,1.359456,0.717726,1.218552),
BP2_CONST6(0.030369,1.413887,0.385545,1.360645,0.715856,1.219652),
BP2_CONST6(0.023862,1.414012,0.381369,1.361822,0.713984,1.220748),
BP2_CONST6(0.017354,1.414107,0.377189,1.362985,0.712111,1.221842),
BP2_CONST6(0.010847,1.414172,0.373005,1.364136,0.710236,1.222933),
BP2_CONST6(0.004339,1.414207,0.368818,1.365274,0.708359,1.224021),
BP2_CONST6(-0.002169,1.414212,0.364628,1.366399,0.706480,1.225106),
BP2_CONST6(-0.008678,1.414187,0.360434,1.367511,0.704600,1.226189),
BP2_CONST6(-0.015185,1.414132,0.356237,1.368611,0.702718,1.227268),
BP2_CONST6(-0.021693,1.414047,0.352037,1.369697,0.700835,1.228344),
BP2_CONST6(-0.028200,1.413932,0.347833,1.370770,0.698950,1.229418),
BP2_CONST6(-0.034707,1.413787,0.343626,1.371831,0.697063,1.230489),
BP2_CONST6(-0.041212,1.413613,0.339415,1.372879,0.695175,1.231557),
BP2_CONST6(-0.047717,1.413408,0.335202,1.373914,0.693285,1.232621),
BP2_CONST6(-0.054221,1.413174,0.330985,1.374936,0.691393,1.233684),
BP2_CONST6(-0.060724,1.412909,0.326765,1.375945,0.689500,1.234743),
BP2_CONST6(-0.067225,1.412615,0.322543,1.376941,0.687605,1.235799),
BP2_CONST6(-0.073725,1.412290,0.318317,1.377924,0.685709,1.236852),
BP2_CONST6(-0.080224,1.411936,0.314088,1.378894,0.683810,1.237903),
BP2_CONST6(-0.086721,1.411552,0.309856,1.379851,0.681911,1.238950),
BP2_CONST6(-0.093216,1.411138,0.305621,1.380795,0.680009,1.239995),
BP2_CONST6(-0.099709,1.410694,0.301383,1.381726,0.678106,1.241036),
BP2_CONST6(-0.106199,1.410220,0.297143,1.382644,0.676202,1.242075),
BP2_CONST6(-0.112688,1.409717,0.292900,1.383550,0.674296,1.243111),
BP2_CONST6(-0.119174,1.409183,0.288654,1.384442,0.672388,1.244144),
BP2_CONST6(-0.125658,1.408620,0.284405,1.385321,0.670479,1.245174),
BP2_CONST6(-0.132139,1.408027,0.280153,1.386187,0.668568,1.246201),
BP2_CONST6(-0.138617,1.407404,0.275899,1.387040,0.666656,1.247225),
BP2_CONST6(-0.145093,1.406751,0.271643,1.387880,0.664742,1.248246),
BP2_CONST6(-0.151565,1.406068,0.267383,1.388706,0.662826,1.249264),
BP2_CONST6(-0.158034,1.405356,0.263122,1.389520,0.660909,1.250280),
BP2_CONST6(-0.164500,1.404614,0.258857,1.390321,0.658990,1.251292),
BP2_CONST6(-0.170962,1.403842,0.254591,1.391109,0.657070,1.252301),
BP2_CONST6(-0.177420,1.403040,0.250322,1.391883,0.655148,1.253308),
BP2_CONST6(-0.183875,1.402209,0.246050,1.392645,0.653225,1.254311),
BP2_CONST6(-0.190326,1.401348,0.241777,1.393393,0.651300,1.255312),
BP2_CONST6(-0.196773,1.400457,0.237501,1.394128,0.649374,1.256310),
BP2_CONST6(-0.203216,1.399537,0.233222,1.394850,0.647446,1.257304),
BP2_CONST6(-0.209654,1.398587,0.228942,1.395559,0.645516,1.258296),
BP2_CONST6(-0.216088,1.397607,0.224659,1.396255,0.643585,1.259285),
BP2_CONST6(-0.222517,1.396598,0.220375,1.396937,0.641653,1.260270),
BP2_CONST6(-0.228942,1.395559,0.216088,1.397607,0.639719,1.261253),
BP2_CONST6(-0.235362,1.394490,0.211799,1.398263,0.637783,1.262233),
BP2_CONST6(-0.241777,1.393393,0.207508,1.398907,0.635846,1.263210),
BP2_CONST6(-0.248187,1.392265,0.203215,1.399537,0.633908,1.264184),
BP2_CONST6(-0.254591,1.391108,0.198921,1.400153,0.631968,1.265155),
BP2_CONST6(-0.260990,1.389922,0.194624,1.400757,0.630026,1.266123),
BP2_CONST6(-0.267384,1.388706,0.190326,1.401348,0.628083,1.267088),
BP2_CONST6(-0.273771,1.387461,0.186026,1.401925,0.626139,1.268049),
BP2_CONST6(-0.280154,1.386186,0.181724,1.402489,0.624193,1.269009),
BP2_CONST6(-0.286530,1.384883,0.177420,1.403040,0.622246,1.269965),
BP2_CONST6(-0.292900,1.383550,0.173115,1.403578,0.620297,1.270918),
BP2_CONST6(-0.299264,1.382187,0.168808,1.404102,0.618347,1.271868),
BP2_CONST6(-0.305621,1.380795,0.164499,1.404614,0.616395,1.272815),
BP2_CONST6(-0.311972,1.379374,0.160189,1.405112,0.614442,1.273759),
BP2_CONST6(-0.318317,1.377924,0.155878,1.405597,0.612487,1.274700),
BP2_CONST6(-0.324655,1.376444,0.151565,1.406068,0.610531,1.275638),
BP2_CONST6(-0.330985,1.374936,0.147250,1.406527,0.608573,1.276573),
BP2_CONST6(-0.337309,1.373398,0.142934,1.406972,0.606615,1.277505),
BP2_CONST6(-0.343626,1.371831,0.138617,1.407404,0.604654,1.278434),
BP2_CONST6(-0.349935,1.370235,0.134299,1.407822,0.602692,1.279360),
BP2_CONST6(-0.356237,1.368610,0.129979,1.408228,0.600729,1.280283),
BP2_CONST6(-0.362532,1.366957,0.125658,1.408620,0.598765,1.281203),
BP2_CONST6(-0.368819,1.365274,0.121336,1.408999,0.596798,1.282120),
BP2_CONST6(-0.375098,1.363562,0.117012,1.409364,0.594831,1.283034),
BP2_CONST6(-0.381369,1.361821,0.112688,1.409717,0.592862,1.283945),
BP2_CONST6(-0.387632,1.360052,0.108363,1.410056,0.590892,1.284853),
BP2_CONST6(-0.393886,1.358254,0.104036,1.410382,0.588920,1.285758),
BP2_CONST6(-0.400133,1.356427,0.099709,1.410694,0.586947,1.286660),
BP2_CONST6(-0.406371,1.354571,0.095380,1.410993,0.584973,1.287558),
BP2_CONST6(-0.412600,1.352687,0.091051,1.411279,0.582997,1.288454),
BP2_CONST6(-0.418821,1.350774,0.086721,1.411552,0.581020,1.289347),
BP2_CONST6(-0.425032,1.348832,0.082390,1.411811,0.579041,1.290237),
BP2_CONST6(-0.431235,1.346861,0.078058,1.412057,0.577062,1.291123),
BP2_CONST6(-0.437429,1.344863,0.073725,1.412290,0.575080,1.292007),
BP2_CONST6(-0.443613,1.342835,0.069392,1.412510,0.573098,1.292888),
BP2_CONST6(-0.449788,1.340780,0.065058,1.412716,0.571114,1.293765),
BP2_CONST6(-0.455953,1.338695,0.060724,1.412909,0.569128,1.294640),
BP2_CONST6(-0.462109,1.336583,0.056389,1.413089,0.567142,1.295511),
BP2_CONST6(-0.468255,1.334443,0.052053,1.413255,0.565154,1.296380),
BP2_CONST6(-0.474391,1.332273,0.047717,1.413408,0.563165,1.297245),
BP2_CONST6(-0.480517,1.330076,0.043381,1.413548,0.561174,1.298108),
BP2_CONST6(-0.486633,1.327851,0.039044,1.413674,0.559182,1.298967),
BP2_CONST6(-0.492738,1.325598,0.034706,1.413788,0.557189,1.299823),
BP2_CONST6(-0.498834,1.323316,0.030369,1.413887,0.555194,1.300676),
BP2_CONST6(-0.504918,1.321006,0.026031,1.413974,0.553198,1.301527),
BP2_CONST6(-0.510992,1.318669,0.021693,1.414047,0.551201,1.302374),
BP2_CONST6(-0.517055,1.316303,0.017355,1.414107,0.549203,1.303218),
BP2_CONST6(-0.523107,1.313910,0.013016,1.414154,0.547203,1.304059),
BP2_CONST6(-0.529148,1.311488,0.008677,1.414187,0.545202,1.304896),
BP2_CONST6(-0.535178,1.309039,0.004339,1.414207,0.543200,1.305731),
BP2_CONST6(-0.541196,1.306563,-0.000000,1.414214,0.541196,1.306563),
BP2_CONST6(-0.547203,1.304058,-0.004339,1.414207,0.539191,1.307392),
BP2_CONST6(-0.553198,1.301526,-0.008677,1.414187,0.537185,1.308217),
BP2_CONST6(-0.559182,1.298967,-0.013016,1.414154,0.535178,1.309040),
BP2_CONST6(-0.565154,1.296380,-0.017355,1.414107,0.533169,1.309859),
BP2_CONST6(-0.571114,1.293765,-0.021693,1.414047,0.531159,1.310675),
BP2_CONST6(-0.577061,1.291123,-0.026031,1.413974,0.529148,1.311489),
BP2_CONST6(-0.582997,1.288454,-0.030369,1.413887,0.527135,1.312299),
BP2_CONST6(-0.588920,1.285758,-0.034707,1.413788,0.525122,1.313106),
BP2_CONST6(-0.594831,1.283034,-0.039044,1.413675,0.523107,1.313910),
BP2_CONST6(-0.600729,1.280283,-0.043381,1.413548,0.521091,1.314711),
BP2_CONST6(-0.606615,1.277505,-0.047717,1.413408,0.519073,1.315509),
BP2_CONST6(-0.612487,1.274700,-0.052053,1.413255,0.517055,1.316303),
BP2_CONST6(-0.618347,1.271868,-0.056389,1.413089,0.515035,1.317095),
BP2_CONST6(-0.624193,1.269008,-0.060724,1.412909,0.513014,1.317883),
BP2_CONST6(-0.630027,1.266122,-0.065058,1.412716,0.510992,1.318669),
BP2_CONST6(-0.635846,1.263210,-0.069392,1.412510,0.508968,1.319451),
BP2_CONST6(-0.641653,1.260270,-0.073725,1.412290,0.506944,1.320230),
BP2_CONST6(-0.647446,1.257304,-0.078058,1.412058,0.504918,1.321006),
BP2_CONST6(-0.653225,1.254311,-0.082390,1.411811,0.502891,1.321779),
BP2_CONST6(-0.658990,1.251292,-0.086721,1.411552,0.500863,1.322549),
BP2_CONST6(-0.664742,1.248246,-0.091051,1.411280,0.498834,1.323316),
BP2_CONST6(-0.670479,1.245174,-0.095380,1.410993,0.496803,1.324080),
BP2_CONST6(-0.676202,1.242075,-0.099709,1.410694,0.494771,1.324840),
BP2_CONST6(-0.681911,1.238950,-0.104036,1.410382,0.492738,1.325598),
BP2_CONST6(-0.687605,1.235799,-0.108363,1.410056,0.490704,1.326352),
BP2_CONST6(-0.693285,1.232621,-0.112688,1.409717,0.488669,1.327103),
BP2_CONST6(-0.698950,1.229418,-0.117012,1.409364,0.486633,1.327851),
BP2_CONST6(-0.704600,1.226189,-0.121336,1.408999,0.484595,1.328596),
BP2_CONST6(-0.710236,1.222933,-0.125658,1.408620,0.482557,1.329338),
BP2_CONST6(-0.715856,1.219652,-0.129979,1.408228,0.480517,1.330076),
BP2_CONST6(-0.721461,1.216345,-0.134299,1.407822,0.478476,1.330812),
BP2_CONST6(-0.727051,1.213012,-0.138617,1.407404,0.476434,1.331544),
BP2_CONST6(-0.732626,1.209653,-0.142934,1.406972,0.474391,1.332274),
BP2_CONST6(-0.738185,1.206268,-0.147250,1.406527,0.472347,1.333000),
BP2_CONST6(-0.743728,1.202859,-0.151565,1.406068,0.470301,1.333723),
BP2_CONST6(-0.749256,1.199423,-0.155878,1.405597,0.468255,1.334443),
BP2_CONST6(-0.754767,1.195963,-0.160189,1.405112,0.466207,1.335159),
BP2_CONST6(-0.760263,1.192477,-0.164499,1.404614,0.464159,1.335873),
BP2_CONST6(-0.765743,1.188965,-0.168808,1.404103,0.462109,1.336583),
BP2_CONST6(-0.771206,1.185429,-0.173115,1.403578,0.460058,1.337291),
BP2_CONST6(-0.776653,1.181867,-0.177420,1.403040,0.458006,1.337995),
BP2_CONST6(-0.782084,1.178280,-0.181724,1.402489,0.455953,1.338696),
BP2_CONST6(-0.787498,1.174669,-0.186026,1.401925,0.453899,1.339394),
BP2_CONST6(-0.792895,1.171033,-0.190326,1.401348,0.451844,1.340088),
BP2_CONST6(-0.798276,1.167371,-0.194624,1.400757,0.449788,1.340780),
BP2_CONST6(-0.803639,1.163685,-0.198921,1.400154,0.447731,1.341468),
BP2_CONST6(-0.808986,1.159975,-0.203215,1.399537,0.445672,1.342154),
BP2_CONST6(-0.814316,1.156240,-0.207508,1.398907,0.443613,1.342836),
BP2_CONST6(-0.819628,1.152480,-0.211799,1.398264,0.441553,1.343515),
BP2_CONST6(-0.824923,1.148696,-0.216088,1.397607,0.439491,1.344190),
BP2_CONST6(-0.830201,1.144887,-0.220375,1.396938,0.437429,1.344863),
BP2_CONST6(-0.835460,1.141055,-0.224659,1.396255,0.435365,1.345532),
BP2_CONST6(-0.840703,1.137198,-0.228942,1.395559,0.433301,1.346199),
BP2_CONST6(-0.845927,1.133317,-0.233222,1.394850,0.431235,1.346862),
BP2_CONST6(-0.851134,1.129412,-0.237501,1.394128,0.429168,1.347522),
BP2_CONST6(-0.856322,1.125483,-0.241777,1.393393,0.427101,1.348178),
BP2_CONST6(-0.861492,1.121531,-0.246050,1.392645,0.425032,1.348832),
BP2_CONST6(-0.866644,1.117554,-0.250322,1.391883,0.422963,1.349482),
BP2_CONST6(-0.871778,1.113554,-0.254591,1.391109,0.420892,1.350130),
BP2_CONST6(-0.876893,1.109531,-0.258857,1.390321,0.418821,1.350774),
BP2_CONST6(-0.881990,1.105484,-0.263122,1.389521,0.416748,1.351415),
BP2_CONST6(-0.887068,1.101413,-0.267383,1.388707,0.414674,1.352052),
BP2_CONST6(-0.892127,1.097319,-0.271643,1.387880,0.412600,1.352687),
BP2_CONST6(-0.897168,1.093202,-0.275899,1.387040,0.410525,1.353318),
BP2_CONST6(-0.902189,1.089062,-0.280153,1.386187,0.408448,1.353946),
BP2_CONST6(-0.907191,1.084898,-0.284405,1.385321,0.406371,1.354571),
BP2_CONST6(-0.912174,1.080712,-0.288654,1.384442,0.404292,1.355193),
BP2_CONST6(-0.917138,1.076503,-0.292900,1.383550,0.402213,1.355812),
BP2_CONST6(-0.922082,1.072271,-0.297143,1.382645,0.400133,1.356427),
BP2_CONST6(-0.927007,1.068016,-0.301383,1.381727,0.398052,1.357039),
BP2_CONST6(-0.931912,1.063739,-0.305621,1.380795,0.395969,1.357648),
BP2_CONST6(-0.936797,1.059439,-0.309856,1.379851,0.393886,1.358254),
BP2_CONST6(-0.941663,1.055117,-0.314088,1.378894,0.391802,1.358857),
BP2_CONST6(-0.946508,1.050772,-0.318317,1.377924,0.389717,1.359456),
BP2_CONST6(-0.951334,1.046405,-0.322543,1.376941,0.387632,1.360052),
BP2_CONST6(-0.956140,1.042016,-0.326765,1.375945,0.385545,1.360645),
BP2_CONST6(-0.960925,1.037605,-0.330985,1.374936,0.383457,1.361235),
BP2_CONST6(-0.965689,1.033172,-0.335202,1.373914,0.381369,1.361822),
BP2_CONST6(-0.970434,1.028717,-0.339415,1.372879,0.379279,1.362405),
BP2_CONST6(-0.975158,1.024240,-0.343626,1.371831,0.377189,1.362985),
BP2_CONST6(-0.979861,1.019742,-0.347833,1.370771,0.375098,1.363562),
BP2_CONST6(-0.984543,1.015221,-0.352037,1.369697,0.373005,1.364136),
BP2_CONST6(-0.989205,1.010680,-0.356237,1.368611,0.370912,1.364707),
BP2_CONST6(-0.993845,1.006117,-0.360434,1.367511,0.368819,1.365274),
BP2_CONST6(-0.998465,1.001533,-0.364628,1.366399,0.366724,1.365838),
BP2_CONST6(-1.003063,0.996927,-0.368819,1.365274,0.364628,1.366399),
BP2_CONST6(-1.007641,0.992301,-0.373006,1.364136,0.362532,1.366957),
BP2_CONST6(-1.012196,0.987653,-0.377189,1.362985,0.360434,1.367511),
BP2_CONST6(-1.016731,0.982985,-0.381369,1.361822,0.358336,1.368063),
BP2_CONST6(-1.021244,0.978295,-0.385545,1.360645,0.356237,1.368611),
BP2_CONST6(-1.025735,0.973585,-0.389718,1.359456,0.354137,1.369156),
BP2_CONST6(-1.030205,0.968855,-0.393886,1.358254,0.352037,1.369697),
BP2_CONST6(-1.034652,0.964104,-0.398052,1.357039,0.349935,1.370236),
BP2_CONST6(-1.039078,0.959332,-0.402213,1.355812,0.347833,1.370771),
BP2_CONST6(-1.043481,0.954540,-0.406371,1.354571,0.345730,1.371303),
BP2_CONST6(-1.047863,0.949728,-0.410525,1.353318,0.343626,1.371831),
BP2_CONST6(-1.052223,0.944896,-0.414674,1.352052,0.341521,1.372357),
BP2_CONST6(-1.056560,0.940043,-0.418821,1.350774,0.339416,1.372879),
BP2_CONST6(-1.060875,0.935171,-0.422963,1.349482,0.337309,1.373398),
BP2_CONST6(-1.065167,0.930279,-0.427101,1.348179,0.335202,1.373914),
BP2_CONST6(-1.069437,0.925368,-0.431235,1.346862,0.333094,1.374427),
BP2_CONST6(-1.073684,0.920436,-0.435365,1.345532,0.330985,1.374936),
BP2_CONST6(-1.077909,0.915486,-0.439491,1.344190,0.328876,1.375442),
BP2_CONST6(-1.082110,0.910515,-0.443613,1.342836,0.326766,1.375945),
BP2_CONST6(-1.086289,0.905526,-0.447731,1.341468,0.324654,1.376445),
BP2_CONST6(-1.090444,0.900517,-0.451844,1.340088,0.322543,1.376941),
BP2_CONST6(-1.094577,0.895490,-0.455953,1.338696,0.320430,1.377434),
BP2_CONST6(-1.098686,0.890443,-0.460058,1.337291,0.318317,1.377924),
BP2_CONST6(-1.102772,0.885378,-0.464159,1.335873,0.316203,1.378411),
BP2_CONST6(-1.106835,0.880293,-0.468255,1.334443,0.314088,1.378894),
BP2_CONST6(-1.110874,0.875190,-0.472347,1.333000,0.311972,1.379374),
BP2_CONST6(-1.114890,0.870069,-0.476434,1.331544,0.309856,1.379851),
BP2_CONST6(-1.118882,0.864929,-0.480517,1.330076,0.307739,1.380325),
BP2_CONST6(-1.122851,0.859771,-0.484595,1.328596,0.305621,1.380795),
BP2_CONST6(-1.126796,0.854594,-0.488669,1.327103,0.303503,1.381263),
BP2_CONST6(-1.130717,0.849400,-0.492738,1.325598,0.301383,1.381727),
BP2_CONST6(-1.134613,0.844188,-0.496803,1.324080,0.299264,1.382187),
BP2_CONST6(-1.138486,0.838957,-0.500863,1.322549,0.297143,1.382645),
BP2_CONST6(-1.142335,0.833709,-0.504918,1.321007,0.295022,1.383099),
BP2_CONST6(-1.146160,0.828443,-0.508969,1.319451,0.292900,1.383550),
BP2_CONST6(-1.149960,0.823160,-0.513014,1.317883,0.290777,1.383997),
BP2_CONST6(-1.153736,0.817859,-0.517055,1.316303,0.288654,1.384442),
BP2_CONST6(-1.157488,0.812541,-0.521091,1.314711,0.286530,1.384883),
BP2_CONST6(-1.161215,0.807206,-0.525122,1.313106,0.284405,1.385321),
BP2_CONST6(-1.164917,0.801854,-0.529148,1.311489,0.282280,1.385756),
BP2_CONST6(-1.168594,0.796484,-0.533169,1.309859,0.280153,1.386187),
BP2_CONST6(-1.172248,0.791098,-0.537185,1.308217,0.278027,1.386615),
BP2_CONST6(-1.175876,0.785695,-0.541196,1.306563,0.275899,1.387040),
BP2_CONST6(-1.179479,0.780276,-0.545202,1.304897,0.273771,1.387462),
BP2_CONST6(-1.183057,0.774839,-0.549203,1.303218,0.271643,1.387880),
BP2_CONST6(-1.186611,0.769387,-0.553198,1.301527,0.269513,1.388295),
BP2_CONST6(-1.190139,0.763918,-0.557189,1.299824,0.267384,1.388707),
BP2_CONST6(-1.193642,0.758433,-0.561174,1.298108,0.265253,1.389115),
BP2_CONST6(-1.197119,0.752932,-0.565154,1.296380,0.263122,1.389520),
BP2_CONST6(-1.200571,0.747415,-0.569129,1.294640,0.260990,1.389922),
BP2_CONST6(-1.203998,0.741882,-0.573098,1.292888,0.258858,1.390321),
BP2_CONST6(-1.207399,0.736334,-0.577062,1.291124,0.256725,1.390717),
BP2_CONST6(-1.210775,0.730769,-0.581020,1.289347,0.254591,1.391109),
BP2_CONST6(-1.214125,0.725190,-0.584973,1.287558,0.252457,1.391498),
BP2_CONST6(-1.217450,0.719595,-0.588920,1.285758,0.250322,1.391883),
BP2_CONST6(-1.220748,0.713984,-0.592862,1.283945,0.248186,1.392266),
BP2_CONST6(-1.224021,0.708359,-0.596798,1.282120,0.246050,1.392645),
BP2_CONST6(-1.227268,0.702719,-0.600729,1.280283,0.243914,1.393020),
BP2_CONST6(-1.230489,0.697064,-0.604654,1.278434,0.241777,1.393393),
BP2_CONST6(-1.233684,0.691394,-0.608573,1.276573,0.239639,1.393762),
BP2_CONST6(-1.236852,0.685709,-0.612487,1.274700,0.237501,1.394128),
BP2_CONST6(-1.239995,0.680010,-0.616395,1.272815,0.235362,1.394491),
BP2_CONST6(-1.243111,0.674296,-0.620297,1.270918,0.233222,1.394850),
BP2_CONST6(-1.246201,0.668568,-0.624193,1.269009,0.231083,1.395206),
BP2_CONST6(-1.249264,0.662826,-0.628083,1.267088,0.228942,1.395559),
BP2_CONST6(-1.252301,0.657070,-0.631968,1.265155,0.226801,1.395909),
BP2_CONST6(-1.255312,0.651300,-0.635846,1.263210,0.224659,1.396255),
BP2_CONST6(-1.258296,0.645517,-0.639719,1.261253,0.222517,1.396598),
BP2_CONST6(-1.261253,0.639719,-0.643585,1.259285,0.220375,1.396938),
BP2_CONST6(-1.264184,0.633908,-0.647446,1.257304,0.218232,1.397274),
BP2_CONST6(-1.267088,0.628084,-0.651300,1.255312,0.216088,1.397607),
BP2_CONST6(-1.269965,0.622246,-0.655148,1.253308,0.213944,1.397937),
BP2_CONST6(-1.272815,0.616395,-0.658990,1.251292,0.211799,1.398264),
BP2_CONST6(-1.275638,0.610531,-0.662826,1.249265,0.209654,1.398587),
BP2_CONST6(-1.278434,0.604655,-0.666656,1.247225,0.207508,1.398907),
BP2_CONST6(-1.281203,0.598765,-0.670479,1.245174,0.205362,1.399224),
BP2_CONST6(-1.283945,0.592862,-0.674296,1.243111,0.203216,1.399537),
BP2_CONST6(-1.286660,0.586948,-0.678107,1.241037,0.201068,1.399847),
BP2_CONST6(-1.289347,0.581020,-0.681911,1.238950,0.198921,1.400154),
BP2_CONST6(-1.292007,0.575080,-0.685709,1.236852,0.196773,1.400457),
BP2_CONST6(-1.294640,0.569129,-0.689500,1.234743,0.194624,1.400758),
BP2_CONST6(-1.297246,0.563165,-0.693285,1.232622,0.192475,1.401054),
BP2_CONST6(-1.299824,0.557189,-0.697063,1.230489,0.190326,1.401348),
BP2_CONST6(-1.302374,0.551201,-0.700835,1.228345,0.188176,1.401638),
BP2_CONST6(-1.304896,0.545202,-0.704600,1.226189,0.186026,1.401925),
BP2_CONST6(-1.307392,0.539191,-0.708359,1.224021,0.183875,1.402209),
BP2_CONST6(-1.309859,0.533169,-0.712111,1.221842,0.181724,1.402489),
BP2_CONST6(-1.312299,0.527136,-0.715856,1.219652,0.179572,1.402766),
BP2_CONST6(-1.314710,0.521091,-0.719594,1.217450,0.177420,1.403040),
BP2_CONST6(-1.317095,0.515035,-0.723326,1.215236,0.175268,1.403311),
BP2_CONST6(-1.319451,0.508969,-0.727051,1.213012,0.173115,1.403578),
BP2_CONST6(-1.321779,0.502891,-0.730769,1.210775,0.170962,1.403842),
BP2_CONST6(-1.324080,0.496803,-0.734480,1.208527,0.168808,1.404103),
BP2_CONST6(-1.326352,0.490704,-0.738185,1.206269,0.166654,1.404360),
BP2_CONST6(-1.328596,0.484596,-0.741882,1.203998,0.164499,1.404614),
BP2_CONST6(-1.330812,0.478476,-0.745572,1.201716,0.162345,1.404865),
BP2_CONST6(-1.333000,0.472347,-0.749255,1.199423,0.160189,1.405112),
BP2_CONST6(-1.335159,0.466208,-0.752932,1.197119,0.158034,1.405356),
BP2_CONST6(-1.337291,0.460058,-0.756601,1.194803,0.155878,1.405597),
BP2_CONST6(-1.339394,0.453899,-0.760263,1.192477,0.153721,1.405834),
BP2_CONST6(-1.341468,0.447731,-0.763918,1.190138,0.151565,1.406068),
BP2_CONST6(-1.343515,0.441553,-0.767566,1.187789,0.149408,1.406299),
BP2_CONST6(-1.345532,0.435365,-0.771206,1.185429,0.147250,1.406527),
BP2_CONST6(-1.347522,0.429169,-0.774839,1.183057,0.145092,1.406751),
BP2_CONST6(-1.349482,0.422963,-0.778465,1.180674,0.142934,1.406972),
BP2_CONST6(-1.351414,0.416748,-0.782084,1.178281,0.140776,1.407189),
BP2_CONST6(-1.353318,0.410525,-0.785695,1.175876,0.138617,1.407404),
BP2_CONST6(-1.355193,0.404292,-0.789299,1.173460,0.136458,1.407615),
BP2_CONST6(-1.357039,0.398052,-0.792895,1.171033,0.134299,1.407822),
BP2_CONST6(-1.358857,0.391802,-0.796484,1.168595,0.132139,1.408027),
BP2_CONST6(-1.360645,0.385545,-0.800066,1.166146,0.129979,1.408228),
BP2_CONST6(-1.362405,0.379279,-0.803640,1.163685,0.127819,1.408426),
BP2_CONST6(-1.364136,0.373006,-0.807206,1.161214,0.125658,1.408620),
BP2_CONST6(-1.365838,0.366724,-0.810765,1.158733,0.123497,1.408811),
BP2_CONST6(-1.367512,0.360435,-0.814316,1.156240,0.121336,1.408999),
BP2_CONST6(-1.369156,0.354138,-0.817859,1.153736,0.119174,1.409183),
BP2_CONST6(-1.370771,0.347833,-0.821395,1.151221,0.117013,1.409364),
BP2_CONST6(-1.372357,0.341521,-0.824923,1.148696,0.114850,1.409542),
BP2_CONST6(-1.373914,0.335202,-0.828443,1.146160,0.112688,1.409717),
BP2_CONST6(-1.375442,0.328876,-0.831956,1.143613,0.110525,1.409888),
BP2_CONST6(-1.376941,0.322543,-0.835460,1.141055,0.108363,1.410056),
BP2_CONST6(-1.378411,0.316203,-0.838957,1.138486,0.106199,1.410221),
BP2_CONST6(-1.379851,0.309856,-0.842446,1.135907,0.104036,1.410382),
BP2_CONST6(-1.381263,0.303503,-0.845927,1.133317,0.101872,1.410540),
BP2_CONST6(-1.382645,0.297143,-0.849400,1.130717,0.099709,1.410694),
BP2_CONST6(-1.383998,0.290777,-0.852865,1.128105,0.097544,1.410846),
BP2_CONST6(-1.385321,0.284405,-0.856322,1.125484,0.095380,1.410994),
BP2_CONST6(-1.386615,0.278027,-0.859771,1.122851,0.093216,1.411138),
BP2_CONST6(-1.387880,0.271643,-0.863212,1.120208,0.091051,1.411279),
BP2_CONST6(-1.389115,0.265253,-0.866644,1.117554,0.088886,1.411417),
BP2_CONST6(-1.390321,0.258858,-0.870069,1.114890,0.086721,1.411552),
BP2_CONST6(-1.391498,0.252457,-0.873485,1.112216,0.084555,1.411684),
BP2_CONST6(-1.392645,0.246050,-0.876893,1.109531,0.082390,1.411812),
BP2_CONST6(-1.393762,0.239639,-0.880293,1.106835,0.080224,1.411936),
BP2_CONST6(-1.394850,0.233222,-0.883685,1.104129,0.078058,1.412058),
BP2_CONST6(-1.395909,0.226801,-0.887068,1.101413,0.075892,1.412176),
BP2_CONST6(-1.396938,0.220375,-0.890443,1.098686,0.073725,1.412291),
BP2_CONST6(-1.397937,0.213944,-0.893809,1.095949,0.071559,1.412402),
BP2_CONST6(-1.398907,0.207508,-0.897168,1.093202,0.069392,1.412510),
BP2_CONST6(-1.399847,0.201068,-0.900517,1.090444,0.067225,1.412615),
BP2_CONST6(-1.400758,0.194624,-0.903858,1.087677,0.065058,1.412716),
BP2_CONST6(-1.401639,0.188176,-0.907191,1.084898,0.062891,1.412815),
BP2_CONST6(-1.402490,0.181724,-0.910515,1.082110,0.060724,1.412909),
BP2_CONST6(-1.403311,0.175268,-0.913831,1.079311,0.058556,1.413001),
BP2_CONST6(-1.404103,0.168808,-0.917138,1.076503,0.056389,1.413089),
BP2_CONST6(-1.404865,0.162345,-0.920436,1.073684,0.054221,1.413174),
BP2_CONST6(-1.405597,0.155878,-0.923726,1.070855,0.052053,1.413255),
BP2_CONST6(-1.406299,0.149408,-0.927007,1.068016,0.049885,1.413333),
BP2_CONST6(-1.406972,0.142935,-0.930279,1.065167,0.047717,1.413408),
BP2_CONST6(-1.407615,0.136458,-0.933543,1.062308,0.045549,1.413480),
BP2_CONST6(-1.408228,0.129979,-0.936797,1.059439,0.043381,1.413548),
BP2_CONST6(-1.408811,0.123497,-0.940043,1.056560,0.041212,1.413613),
BP2_CONST6(-1.409364,0.117012,-0.943280,1.053671,0.039044,1.413674),
BP2_CONST6(-1.409888,0.110526,-0.946508,1.050772,0.036875,1.413733),
BP2_CONST6(-1.410382,0.104036,-0.949728,1.047863,0.034707,1.413788),
BP2_CONST6(-1.410845,0.097545,-0.952938,1.044944,0.032538,1.413839),
BP2_CONST6(-1.411279,0.091051,-0.956139,1.042016,0.030369,1.413887),
BP2_CONST6(-1.411683,0.084555,-0.959332,1.039078,0.028200,1.413932),
BP2_CONST6(-1.412058,0.078058,-0.962515,1.036130,0.026031,1.413974),
BP2_CONST6(-1.412402,0.071559,-0.965689,1.033172,0.023862,1.414012),
BP2_CONST6(-1.412716,0.065058,-0.968854,1.030204,0.021693,1.414047),
BP2_CONST6(-1.413001,0.058557,-0.972011,1.027227,0.019524,1.414079),
BP2_CONST6(-1.413255,0.052053,-0.975158,1.024240,0.017355,1.414107),
BP2_CONST6(-1.413480,0.045549,-0.978295,1.021243,0.015185,1.414132),
BP2_CONST6(-1.413674,0.039044,-0.981424,1.018237,0.013016,1.414154),
BP2_CONST6(-1.413839,0.032538,-0.984543,1.015222,0.010847,1.414172),
BP2_CONST6(-1.413974,0.026031,-0.987653,1.012196,0.008677,1.414187),
BP2_CONST6(-1.414079,0.019524,-0.990754,1.009161,0.006508,1.414199),
BP2_CONST6(-1.414153,0.013016,-0.993845,1.006117,0.004339,1.414207),
BP2_CONST6(-1.414199,0.006508,-0.996927,1.003063,0.002169,1.414212),
BP2_CONST6(-1.414214,0.000000,-1.000000,1.000000,0.000000,1.414214),
0,0,0,0,0,0 };

#endif	//  !defined(PLATFORM_LPC_DIRECT) 


#ifdef PLATFORM_LPC_LITDFT

#define BP2_CONST20(j,c1,s1,c2,s2,c3,s3,c4,s4,c5,s5,c6,s6,c7,s7,c8,s8,c9,s9,c10,s10) \
	BP2_FROM_FLOAT(c1),BP2_FROM_FLOAT(-s1),BP2_FROM_FLOAT(c2),BP2_FROM_FLOAT(-s2),     \
	BP2_FROM_FLOAT(c3),BP2_FROM_FLOAT(-s3),BP2_FROM_FLOAT(c4),BP2_FROM_FLOAT(-s4),     \
	BP2_FROM_FLOAT(c5),BP2_FROM_FLOAT(-s5),BP2_FROM_FLOAT(c6),BP2_FROM_FLOAT(-s6),     \
	BP2_FROM_FLOAT(c7),BP2_FROM_FLOAT(-s7),BP2_FROM_FLOAT(c8),BP2_FROM_FLOAT(-s8),     \
	BP2_FROM_FLOAT(c9),BP2_FROM_FLOAT(-s9),BP2_FROM_FLOAT(c10),BP2_FROM_FLOAT(-s10)

const BP2Type rgBP2LpcLitdftTrig[64*20] = {0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
BP2_CONST20(1,0.999998823452,0.001533980186,0.999995293810,0.003067956763,0.999989411082,0.004601926120,0.999981175283,0.006135884649,0.999970586431,0.007669828740,0.999957644552,0.009203754782,0.999942349676,0.010737659167,0.999924701839,0.012271538286,0.999904701083,0.013805388528,0.999882347454,0.015339206285),
BP2_CONST20(2,0.999995293810,0.003067956763,0.999981175283,0.006135884649,0.999957644552,0.009203754782,0.999924701839,0.012271538286,0.999882347454,0.015339206285,0.999830581796,0.018406729906,0.999769405351,0.021474080275,0.999698818696,0.024541228523,0.999618822495,0.027608145779,0.999529417501,0.030674803177),
BP2_CONST20(3,0.999989411082,0.004601926120,0.999957644552,0.009203754782,0.999904701083,0.013805388528,0.999830581796,0.018406729906,0.999735288261,0.023007681469,0.999618822495,0.027608145779,0.999481186966,0.032208025408,0.999322384588,0.036807222941,0.999142418725,0.041405640977,0.998941293187,0.046003182131),
BP2_CONST20(4,0.999981175283,0.006135884649,0.999924701839,0.012271538286,0.999830581796,0.018406729906,0.999698818696,0.024541228523,0.999529417501,0.030674803177,0.999322384588,0.036807222941,0.999077727753,0.042938256935,0.998795456205,0.049067674327,0.998475580573,0.055195244350,0.998118112900,0.061320736302),
BP2_CONST20(5,0.999970586431,0.007669828740,0.999882347454,0.015339206285,0.999735288261,0.023007681469,0.999529417501,0.030674803177,0.999264747287,0.038340120374,0.998941293187,0.046003182131,0.998559074230,0.053663537653,0.998118112900,0.061320736302,0.997618435139,0.068974327628,0.997060070339,0.076623861392),
BP2_CONST20(6,0.999957644552,0.009203754782,0.999830581796,0.018406729906,0.999618822495,0.027608145779,0.999322384588,0.036807222941,0.998941293187,0.046003182131,0.998475580573,0.055195244350,0.997925286199,0.064382630930,0.997290456679,0.073564563600,0.996571145791,0.082740264549,0.995767414468,0.091908956497),
BP2_CONST20(7,0.999942349676,0.010737659167,0.999769405351,0.021474080275,0.999481186966,0.032208025408,0.999077727753,0.042938256935,0.998559074230,0.053663537653,0.997925286199,0.064382630930,0.997176436735,0.075094300848,0.996312612183,0.085797312344,0.995333912140,0.096490431355,0.994240449453,0.107172424957),
BP2_CONST20(8,0.999924701839,0.012271538286,0.999698818696,0.024541228523,0.999322384588,0.036807222941,0.998795456205,0.049067674327,0.998118112900,0.061320736302,0.997290456679,0.073564563600,0.996312612183,0.085797312344,0.995184726672,0.098017140330,0.993906970002,0.110222207294,0.992479534599,0.122410675199),
BP2_CONST20(9,0.999904701083,0.013805388528,0.999618822495,0.027608145779,0.999142418725,0.041405640977,0.998475580573,0.055195244350,0.997618435139,0.068974327628,0.996571145791,0.082740264549,0.995333912140,0.096490431355,0.993906970002,0.110222207294,0.992290591348,0.123932975119,0.990485084256,0.137620121586),
BP2_CONST20(10,0.999882347454,0.015339206285,0.999529417501,0.030674803177,0.998941293187,0.046003182131,0.998118112900,0.061320736302,0.997060070339,0.076623861392,0.995767414468,0.091908956497,0.994240449453,0.107172424957,0.992479534599,0.122410675199,0.990485084256,0.137620121586,0.988257567731,0.152797185258),
BP2_CONST20(11,0.999857641006,0.016872987947,0.999430604555,0.033741171851,0.998719012234,0.050599749037,0.997723066644,0.067443919564,0.996443051350,0.084268887593,0.994879330795,0.101069862755,0.993032350198,0.117842061508,0.990902635428,0.134580708507,0.988490792853,0.151281037957,0.985797509168,0.167938294975),
BP2_CONST20(12,0.999830581796,0.018406729906,0.999322384588,0.036807222941,0.998475580573,0.055195244350,0.997290456679,0.073564563600,0.995767414468,0.091908956497,0.993906970002,0.110222207294,0.991709753669,0.128498110794,0.989176509965,0.146730474455,0.986308097245,0.164913120490,0.983105487431,0.183039887955),
BP2_CONST20(13,0.999801169888,0.019940428552,0.999204758618,0.039872927588,0.998211003360,0.059789570747,0.996820299291,0.079682437971,0.995033199438,0.099543618660,0.992850414460,0.119365214811,0.990272812363,0.139139344164,0.987301418158,0.158858143334,0.983937413449,0.178513770939,0.980182135968,0.198098410718),
BP2_CONST20(14,0.999769405351,0.021474080275,0.999077727753,0.042938256935,0.997925286199,0.064382630930,0.996312612183,0.085797312344,0.994240449453,0.107172424957,0.991709753669,0.128498110794,0.988721691960,0.149764534677,0.985277642389,0.170961888760,0.981379193314,0.192080397050,0.977028142658,0.213110319916),
BP2_CONST20(15,0.999735288261,0.023007681469,0.998941293187,0.046003182131,0.997618435139,0.068974327628,0.995767414468,0.091908956497,0.993389211148,0.114794926607,0.990485084256,0.137620121586,0.987056571306,0.160372457243,0.983105487431,0.183039887955,0.978633924429,0.205610413053,0.973644249651,0.228072083171),
BP2_CONST20(16,0.999698818696,0.024541228523,0.998795456205,0.049067674327,0.997290456679,0.073564563600,0.995184726672,0.098017140330,0.992479534599,0.122410675199,0.989176509965,0.146730474455,0.985277642389,0.170961888760,0.980785280403,0.195090322016,0.975702130039,0.219101240157,0.970031253195,0.242980179903),
BP2_CONST20(17,0.999659996744,0.026074717829,0.998640218180,0.052131704680,0.996941357765,0.078153241633,0.994564570734,0.104121633872,0.991511473319,0.130019222722,0.987784141645,0.155828397654,0.983385110322,0.181531608261,0.978317370720,0.207111376192,0.972584368935,0.232550307039,0.966190003445,0.257831102162),
BP2_CONST20(18,0.999618822495,0.027608145779,0.998475580573,0.055195244350,0.996571145791,0.082740264549,0.993906970002,0.110222207294,0.990485084256,0.137620121586,0.986308097245,0.164913120490,0.981379193314,0.192080397050,0.975702130039,0.219101240157,0.969281235357,0.245955050336,0.962121404269,0.272621355450),
BP2_CONST20(19,0.999575296047,0.029141508764,0.998301544934,0.058258264500,0.996179828596,0.087325535206,0.993211949235,0.116318630912,0.989400427791,0.145212924653,0.984748501802,0.173983873387,0.979260122649,0.202607038844,0.972939952206,0.231058108281,0.965793358874,0.259312915133,0.957826413028,0.287347459545),
BP2_CONST20(20,0.999529417501,0.030674803177,0.998118112900,0.061320736302,0.995767414468,0.091908956497,0.992479534599,0.122410675199,0.988257567731,0.152797185258,0.983105487431,0.183039887955,0.977028142658,0.213110319916,0.970031253195,0.242980179903,0.962121404269,0.272621355450,0.953306040354,0.302005949319),
BP2_CONST20(21,0.999481186966,0.032208025408,0.997925286199,0.064382630930,0.995333912140,0.096490431355,0.991709753669,0.128498110794,0.987056571306,0.160372457243,0.981379193314,0.192080397050,0.974683510689,0.223589029230,0.966976471045,0.254865659605,0.958266071408,0.285877834727,0.948561349916,0.316593375556),
BP2_CONST20(22,0.999430604555,0.033741171851,0.997723066644,0.067443919564,0.994879330795,0.101069862755,0.990902635428,0.134580708507,0.985797509168,0.167938294975,0.979569765685,0.201104634842,0.972226497079,0.234041958584,0.963776065795,0.266712757475,0.954228095109,0.299079826308,0.943593458162,0.331106305760),
BP2_CONST20(23,0.999377670388,0.035274238898,0.997511456140,0.070504573390,0.994403680058,0.105647153713,0.990058210262,0.140658239333,0.984480455383,0.175494253377,0.977677357825,0.210111836880,0.969657385124,0.244467902748,0.960430519416,0.278519689385,0.950008245002,0.312224813922,0.938403534063,0.345541324964),
BP2_CONST20(24,0.999322384588,0.036807222941,0.997290456679,0.073564563600,0.993906970002,0.110222207294,0.989176509965,0.146730474455,0.983105487431,0.183039887955,0.975702130039,0.219101240157,0.966976471045,0.254865659605,0.956940335732,0.290284677254,0.945607325381,0.325310292162,0.932992798835,0.359895036535),
BP2_CONST20(25,0.999264747287,0.038340120374,0.997060070339,0.076623861392,0.993389211148,0.114794926607,0.988257567731,0.152797185258,0.981672686197,0.190574754820,0.973644249651,0.228072083171,0.964184063952,0.265234030286,0.953306040354,0.302005949319,0.941026175051,0.338333766966,0.927362525650,0.374164062971),
BP2_CONST20(26,0.999204758618,0.039872927588,0.996820299291,0.079682437971,0.992850414460,0.119365214811,0.987301418158,0.158858143334,0.980182135968,0.198098410718,0.971503890986,0.237023605994,0.961280485811,0.275571819311,0.949528180593,0.313681740399,0.936265667170,0.351292756086,0.921514039342,0.388345046699),
BP2_CONST20(27,0.999142418725,0.041405640977,0.996571145791,0.082740264549,0.992290591348,0.123932975119,0.986308097245,0.164913120490,0.978633924429,0.205610413053,0.969281235357,0.245955050336,0.958266071408,0.285877834727,0.945607325381,0.325310292162,0.931326709081,0.364184789567,0.915448716088,0.402434650859),
BP2_CONST20(28,0.999077727753,0.042938256935,0.996312612183,0.085797312344,0.991709753669,0.128498110794,0.985277642389,0.170961888760,0.977028142658,0.213110319916,0.966976471045,0.254865659605,0.955141168306,0.296150888244,0.941544065183,0.336889853392,0.926210242138,0.377007410216,0.909167983091,0.416429560098),
BP2_CONST20(29,0.999010685854,0.044470771855,0.996044700901,0.088853552583,0.991107913723,0.133060525157,0.984210092387,0.177004220412,0.975364885117,0.220597690109,0.964589793290,0.263754678975,0.951906136808,0.306389795371,0.937339011913,0.348418680249,0.920917241529,0.389758174070,0.902673318237,0.430326481340),
BP2_CONST20(30,0.998941293187,0.046003182131,0.995767414468,0.091908956497,0.990485084256,0.137620121586,0.983105487431,0.183039887955,0.973644249651,0.228072083171,0.962121404269,0.272621355450,0.948561349916,0.316593375556,0.932992798835,0.359895036535,0.915448716088,0.402434650859,0.895966249756,0.444122144570),
BP2_CONST20(31,0.998869549914,0.047535484157,0.995480755492,0.094963495330,0.989841278459,0.142176803519,0.981963869110,0.189068664150,0.971866337480,0.235533059405,0.959571513082,0.281464937926,0.945107193285,0.326760452320,0.928506080473,0.371317193952,0.909805708105,0.415034424476,0.889048355855,0.457813303599),
BP2_CONST20(32,0.998795456205,0.049067674327,0.995184726672,0.098017140330,0.989176509965,0.146730474455,0.980785280403,0.195090322016,0.970031253195,0.242980179903,0.956940335732,0.290284677254,0.941544065183,0.336889853392,0.923879532511,0.382683432365,0.903989293123,0.427555093430,0.881921264348,0.471396736826),
BP2_CONST20(33,0.998719012234,0.050599749037,0.994879330795,0.101069862755,0.988490792853,0.151281037957,0.979569765685,0.201104634842,0.968139104746,0.250413006573,0.954228095109,0.299079826308,0.937872376440,0.346980410846,0.919113851690,0.393992040061,0.898000579741,0.439994271310,0.874586652278,0.484869248001),
BP2_CONST20(34,0.998640218180,0.052131704680,0.994564570734,0.104121633872,0.987784141645,0.155828397654,0.978317370720,0.207111376192,0.966190003445,0.257831102162,0.951435020969,0.307849640042,0.934092550404,0.357030961233,0.914209755704,0.405241314005,0.891840709392,0.452349587234,0.867046245516,0.498227666973),
BP2_CONST20(35,0.998559074230,0.053663537653,0.994240449453,0.107172424957,0.987056571306,0.160372457243,0.977028142658,0.213110319916,0.964184063952,0.265234030286,0.948561349916,0.316593375556,0.930205022892,0.367040345720,0.909167983091,0.416429560098,0.885510856136,0.464618686306,0.859301818357,0.511468850438),
BP2_CONST20(36,0.998475580573,0.055195244350,0.993906970002,0.110222207294,0.986308097245,0.164913120490,0.975702130039,0.219101240157,0.962121404269,0.272621355450,0.945607325381,0.325310292162,0.926210242138,0.377007410216,0.903989293123,0.427555093430,0.879012226429,0.476799230063,0.851355193105,0.524589682678),
BP2_CONST20(37,0.998389737407,0.056726821167,0.993564135521,0.113270952178,0.985538735312,0.169450291234,0.974339382786,0.225083911360,0.960002145738,0.279992643080,0.942573197601,0.333999651442,0.922108668743,0.386931005514,0.898674465694,0.438616238539,0.872346058894,0.488888896920,0.843208239642,0.537587076296),
BP2_CONST20(38,0.998301544934,0.058258264500,0.993211949235,0.116318630912,0.984748501802,0.173983873387,0.972939952206,0.231058108281,0.957826413028,0.287347459545,0.939459223602,0.342660717312,0.917900775621,0.396809987417,0.893224301196,0.449611329655,0.865513624091,0.500885382611,0.834862874986,0.550457972937),
BP2_CONST20(39,0.998211003360,0.059789570747,0.992850414460,0.119365214811,0.983937413449,0.178513770939,0.971503890986,0.237023605994,0.955594334131,0.294685372181,0.936265667170,0.351292756086,0.913587047945,0.406643216870,0.887639620403,0.460538710958,0.858516224264,0.512786400634,0.826321062846,0.563199344014),
BP2_CONST20(40,0.998118112900,0.061320736302,0.992479534599,0.122410675199,0.983105487431,0.183039887955,0.970031253195,0.242980179903,0.953306040354,0.302005949319,0.932992798835,0.359895036535,0.909167983091,0.416429560098,0.881921264348,0.471396736826,0.851355193105,0.524589682678,0.817584813152,0.575808191418),
BP2_CONST20(41,0.998022873771,0.062851757564,0.992099313142,0.125454983412,0.982252741366,0.187562128583,0.968522094274,0.248927605746,0.950961666312,0.309308760312,0.929640895843,0.368466829953,0.904644090578,0.426167888727,0.876070094195,0.482183772079,0.844031895490,0.536292979066,0.808656181588,0.588281548223),
BP2_CONST20(42,0.997925286199,0.064382630930,0.991709753669,0.128498110794,0.981379193314,0.192080397050,0.966976471045,0.254865659605,0.948561349916,0.316593375556,0.926210242138,0.377007410216,0.900015892016,0.435857079922,0.870086991109,0.492898192230,0.836547727224,0.547894059173,0.799537269108,0.600616479384),
BP2_CONST20(43,0.997825350411,0.065913352797,0.991310859846,0.131540028703,0.980484861773,0.196594597670,0.965394441698,0.260794117915,0.946105232370,0.323859366518,0.922701128334,0.385516053844,0.895283921039,0.445496016514,0.863972856122,0.503538383726,0.828904114772,0.559390711859,0.790230221437,0.612810082429),
BP2_CONST20(44,0.997723066644,0.067443919564,0.990902635428,0.134580708507,0.979569765685,0.201104634842,0.963776065795,0.266712757475,0.943593458162,0.331106305760,0.919113851690,0.393992040061,0.890448723245,0.455083587126,0.857728610000,0.514102744193,0.821102514991,0.570780745887,0.780737228572,0.624859488142),
BP2_CONST20(45,0.997618435139,0.068974327628,0.990485084256,0.137620121586,0.978633924429,0.205610413053,0.962121404269,0.272621355450,0.941026175051,0.338333766966,0.915448716088,0.402434650859,0.885510856136,0.464618686306,0.851355193105,0.524589682678,0.813144414849,0.582061990341,0.771060524262,0.636761861236),
BP2_CONST20(46,0.997511456140,0.070504573390,0.990058210262,0.140658239333,0.977677357825,0.210111836880,0.960430519416,0.278519689385,0.938403534063,0.345541324964,0.911706032005,0.410843171058,0.880470889052,0.474100214651,0.844853565250,0.534997619887,0.805031331143,0.593232295040,0.761202385484,0.648514401022),
BP2_CONST20(47,0.997402129901,0.072034653247,0.989622017463,0.143695033150,0.976700086129,0.214608810994,0.958703474896,0.284407537211,0.935725689481,0.352728555755,0.907886116488,0.419216888363,0.875329403104,0.483527078933,0.838224705555,0.545324988422,0.796764810208,0.604289530948,0.751165131910,0.660114342067),
BP2_CONST20(48,0.997290456679,0.073564563600,0.989176509965,0.146730474455,0.975702130039,0.219101240157,0.956940335732,0.290284677254,0.932992798835,0.359895036535,0.903989293123,0.427555093430,0.870086991109,0.492898192230,0.831469612303,0.555570233020,0.788346427627,0.615231590581,0.740951125355,0.671558954847),
BP2_CONST20(49,0.997176436735,0.075094300848,0.988721691960,0.149764534677,0.974683510689,0.223589029230,0.955141168306,0.296150888244,0.930205022892,0.367040345720,0.900015892016,0.435857079922,0.864744257519,0.502212474046,0.824589302785,0.565731810784,0.779777787923,0.626056388404,0.730562769228,0.682845546385),
BP2_CONST20(50,0.997060070339,0.076623861392,0.988257567731,0.152797185258,0.973644249651,0.228072083171,0.953306040354,0.302005949319,0.927362525650,0.374164062971,0.895966249756,0.444122144570,0.859301818357,0.511468850438,0.817584813152,0.575808191418,0.771060524262,0.636761861236,0.720002507961,0.693971460890),
BP2_CONST20(51,0.996941357765,0.078153241633,0.987784141645,0.155828397654,0.972584368935,0.232550307039,0.951435020969,0.307849640042,0.924465474325,0.381265769222,0.891840709392,0.452349587234,0.853760301138,0.520666254140,0.810457198253,0.585797857456,0.762196298135,0.647345968637,0.709272826439,0.704934080376),
BP2_CONST20(52,0.996820299291,0.079682437971,0.987301418158,0.158858143334,0.971503890986,0.237023605994,0.949528180593,0.313681740399,0.921514039342,0.388345046699,0.887639620403,0.460538710958,0.848120344803,0.529803624686,0.803207531481,0.595699304492,0.753186799044,0.657806693297,0.698376249409,0.715730825284),
BP2_CONST20(53,0.996696895203,0.081211446810,0.986809401814,0.161886393780,0.970402838688,0.241491885303,0.947585591018,0.319502030816,0.918508394325,0.395401478948,0.883363338666,0.468688822036,0.842382599643,0.538879908531,0.795836904609,0.605511041404,0.744033744180,0.668142041427,0.687315340892,0.726359155084),
BP2_CONST20(54,0.996571145791,0.082740264549,0.986308097245,0.164913120490,0.969281235357,0.245955050336,0.945607325381,0.325310292162,0.915448716088,0.402434650859,0.879012226429,0.476799230063,0.836547727224,0.547894059173,0.788346427627,0.615231590581,0.734738878096,0.678350043130,0.676092703575,0.736816568877),
BP2_CONST20(55,0.996443051350,0.084268887593,0.985797509168,0.167938294975,0.968139104746,0.250413006573,0.943593458162,0.331106305760,0.912335184623,0.409444148692,0.874586652278,0.484869248001,0.830616400309,0.556845037275,0.780737228572,0.624859488142,0.725303972373,0.688428752784,0.664710978203,0.747100605980),
BP2_CONST20(56,0.996312612183,0.085797312344,0.985277642389,0.170961888760,0.966976471045,0.254865659605,0.941544065183,0.336889853392,0.909167983091,0.416429560098,0.870086991109,0.492898192230,0.824589302785,0.565731810784,0.773010453363,0.634393284164,0.715730825284,0.698376249409,0.653172842954,0.757208846506),
BP2_CONST20(57,0.996179828596,0.087325535206,0.984748501802,0.173983873387,0.965793358874,0.259312915133,0.939459223602,0.342660717312,0.905947297807,0.423390474144,0.865513624091,0.500885382611,0.818467129580,0.574553355048,0.765167265622,0.643831542890,0.706021261449,0.708190637033,0.641481012809,0.767138911936),
BP2_CONST20(58,0.996044700901,0.088853552583,0.984210092387,0.177004220412,0.964589793290,0.263754678975,0.937339011913,0.348418680249,0.902673318237,0.430326481340,0.860866938638,0.508830142543,0.812250586585,0.583308652938,0.757208846506,0.653172842954,0.696177131491,0.717870045056,0.629638238915,0.776888465673),
BP2_CONST20(59,0.995907229417,0.090381360878,0.983662419212,0.180022901406,0.963365799781,0.268190857063,0.935183509939,0.354163525420,0.899346236979,0.437237173661,0.856147328375,0.516731799018,0.805940390571,0.591996694962,0.749136394523,0.662415777590,0.686200311680,0.727412628602,0.617647307938,0.786455213599),
BP2_CONST20(60,0.995767414468,0.091908956497,0.983105487431,0.183039887955,0.962121404269,0.272621355450,0.932992798835,0.359895036535,0.895966249756,0.444122144570,0.851355193105,0.524589682678,0.799537269108,0.600616479384,0.740951125355,0.671558954847,0.676092703575,0.736816568877,0.605511041404,0.795836904609),
BP2_CONST20(61,0.995625256381,0.093436335846,0.982539302287,0.186055151663,0.960856633108,0.277046080306,0.930766961079,0.365612997805,0.892533555403,0.450980989045,0.846490938774,0.532403127877,0.793041960479,0.609167012336,0.732654271672,0.680600997795,0.665856233666,0.746080073510,0.593232295040,0.805031331143),
BP2_CONST20(62,0.995480755492,0.094963495330,0.981963869110,0.189068664150,0.959571513082,0.281464937926,0.928506080473,0.371317193952,0.889048355855,0.457813303599,0.841554977437,0.540171472730,0.786455213599,0.617647307938,0.724247082951,0.689540544737,0.655492853000,0.755201376897,0.580813958096,0.814036329706),
BP2_CONST20(63,0.995333912140,0.096490431355,0.981379193314,0.192080397050,0.958266071408,0.285877834727,0.926210242138,0.377007410216,0.885510856136,0.464618686306,0.836547727224,0.547894059173,0.779777787923,0.626056388404,0.715730825284,0.698376249409,0.645004536816,0.764178740536,0.568258952670,0.822849781376)
};

#endif	// PLATFORM_LPC_LITDFT

#pragma MSVC_RESTORE_WARNING(4305)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\nsperror.h ===
/*M*
//
//               INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//        Copyright (c) 1995 Intel Corporation. All Rights Reserved.
//
//      $Workfile: nsperror.h $
//      $Revision: 3 $
//      $Modtime: Dec 16 1996 18:31:22 $
//
//  Purpose: NSP Error Handling Module
*M*/
#ifdef __cplusplus
extern "C" {
#endif

#if !defined (_NSPERROR_H) || defined (_OWN_BLDPCS)
    #define _NSPERROR_H

/* ------------------------------------------------------------------------*/

    #if !defined (_OWN_BLDPCS)

    typedef struct _NSPLibVersion
        {
        int    major;                   /* e.g. 3                          */
        int    minor;                   /* e.g. 00                         */
        int    build;                   /* e.g. 11                         */
        const char * Name;                    /* e.g. "nspp6l.lib","nspm5.dll"   */
        const char * Version;                 /* e.g. "v4.00"                    */
        const char * InternalVersion;         /* e.g. "[3.00.11, 07/12/96]"      */
        const char * BuildDate;               /* e.g. "Jun 1 96"                 */
        const char * CallConv;                /* e.g. "DLL",..                   */
        } NSPLibVersion;

/*--- NSPErrStatus,NSPErrMode Values Definition ---------------------------*/

/* common status code definitions */

        #define NSP_StsOk             0         /* everything is ok                */
        #define NSP_StsBackTrace     -1         /* pseudo error for back trace     */
        #define NSP_StsError         -2         /* unknown /unspecified error      */
        #define NSP_StsInternal      -3         /* internal error (bad state)      */
        #define NSP_StsNoMem         -4         /* out of memory                   */
        #define NSP_StsBadArg        -5         /* function arg/param is bad       */
        #define NSP_StsBadFunc       -6         /* unsupported function            */
        #define NSP_StsNoConv        -7         /* iter. didn't converge           */
        #define NSP_StsAutoTrace     -8         /* Tracing through nsptrace.h      */
        #define NSP_StsDivideByZero  -9
        #define NSP_StsNullPtr       -10
        #define NSP_StsBadSizeValue  -11
        #define NSP_StsBadPtr        -12
        #define NSP_StsBadStruct     -13
        #define NSP_StsBadLen        -14         /* bad vector length              */          

        #define NSP_ErrModeLeaf     0           /* Print error and exit program    */
        #define NSP_ErrModeParent   1           /* Print error and continue        */
        #define NSP_ErrModeSilent   2           /* Don't print and continue        */

/* custom status code definitions */
    /* nspsmpl */
        #define NSP_StsBadFact       -50        /* Negative FactorRange            */
    /* nspfirg */
        #define NSP_StsBadFreq       -51        /* bad frequency value             */
        #define NSP_StsBadRel        -52        /* bad relation between frequency  */ 



    typedef int (__STDCALL *NSPErrorCallBack)  (NSPStatus status,
                                                const char *funcname, const char *context,
                                                const char *file, int   line);

/* ------------------------------------------------------------------------*/
/* Flags for scaleMode parameter of nsp?Func(...,scaleMode,scaleFactor)    */

        #define NSP_NO_SCALE        0x0000      /* ignore factor                   */
        #define NSP_FIXED_SCALE     0x0002      /* fixed factor value              */
        #define NSP_AUTO_SCALE      0x0004      /* detect factor value             */

        #define NSP_OVERFLOW        0x0000      /* wrapround                       */
        #define NSP_SATURATE        0x0001      /* saturate                        */

/*--- Macros --------------------------------------------------------------*/

        #define NSP_ERROR(status,func,context)\
nspError((status),(func),(context),__FILE__,__LINE__)

        #define NSP_ERRCHK(func,context)\
   ((nspGetErrStatus() >= 0) ? NSP_StsOk \
: NSP_ERROR(NSP_StsBackTrace,(func),(context)))

        #define NSP_ASSERT(expr,func,context)\
   ((expr) ? NSP_StsOk \
: NSP_ERROR(NSP_StsInternal,(func),(context)))

        #define NSP_RSTERR() (nspSetErrStatus(NSP_StsOk))


    #endif
/*--- Get Library Version -------------------------------------------------*/
/* Returns pointer to NSP lib info structure                               */

    NSPAPI(const NSPLibVersion *,nspGetLibVersion,(void))

/*--- Get/Set ErrStatus ---------------------------------------------------*/

    NSPAPI(NSPStatus, nspGetErrStatus,(void))
    NSPAPI(void,      nspSetErrStatus,(NSPStatus status))

/*--- NspStdErrMode Declaration -------------------------------------------*/

    NSPAPI(int,  nspGetErrMode,(void))
    NSPAPI(void, nspSetErrMode,(int mode))

/*--- nspError,nspErrorStr Declaration ------------------------------------*/

    NSPAPI(NSPStatus,   nspError,(NSPStatus status, const char *func,
                                  const char *context, const char *file,int line))

    NSPAPI(const char*, nspErrorStr,(NSPStatus status))

/*--- nspRedirectError Declaration ----------------------------------------*/

    NSPAPI(NSPStatus, nspNulDevReport,(NSPStatus   status, const char *funcname,
                                       const char *context,const char *file,
                                       int   line))

    NSPAPI(NSPStatus, nspStdErrReport,(NSPStatus   status, const char *funcname,
                                       const char *context,const char *file,
                                       int   line))

    #if defined _WIN32   /* _WIN32 */
    NSPAPI(NSPStatus, nspGuiBoxReport,(NSPStatus   status, const char *funcname,
                                       const char *context,const char *file,
                                       int   line))
    #endif               /* _WIN32 */

    NSPAPI(NSPErrorCallBack, nspRedirectError,(NSPErrorCallBack nspErrorFunc))

#endif                                  /* _NSPERROR_H                     */
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\nspalloc.h ===
/*M*
//
//               INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//        Copyright (c) 1995 Intel Corporation. All Rights Reserved.
//
//      $Workfile: nspalloc.h $
//      $Revision: 3 $
//      $Modtime: 9/11/99 4:22p $
//
//  Purpose: NSP 32 bytes aligned allocator/deallocator
//
*M*/

#if !defined(_NSPALLOC_H) || defined (_OWN_BLDPCS)
#define _NSPALLOC_H

#ifdef __cplusplus
extern "C" {
#endif

NSPAPI(void*,  nspMalloc, (int length))
NSPAPI(float*, nspsMalloc,(int length))
NSPAPI(double*,nspdMalloc,(int length))
NSPAPI(SCplx*, nspcMalloc,(int length))
NSPAPI(DCplx*, nspzMalloc,(int length))
NSPAPI(short*, nspwMalloc,(int length))
NSPAPI(WCplx*, nspvMalloc,(int length))
NSPAPI(long*,  nspiMalloc,(int length))
NSPAPI(ICplx*, nspjMalloc,(int length))

NSPAPI(void,   nspFree,   (void* ptr ))
#ifdef __cplusplus
 }
#endif
#endif                                  /* _NSPALLOC_H                     */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\nspwarn.h ===
/*M*
//
//               INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//        Copyright (c) 1994 Intel Corporation. All Rights Reserved.
//
//      $Workfile: nspwarn.h $
//      $Revision: 3 $
//      $Modtime: 3/05/97 19:06 $
//
//   Purpose:
//
*M*/

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __NSPWARN_H__
#define __NSPWARN_H__

#if !defined (_OWN_BLDPCS)


#if _MSC_VER >= 1000

/* nonstandard extension used : nameless struct/union          */
#pragma warning(disable : 4201)
/* nonstandard extension used : bit field types other than int */
#pragma warning(disable : 4214)
/* unreferenced inline function has been removed               */
#pragma warning(disable : 4514)
/* named type definition in parentheses                        */
#pragma warning(disable : 4115)

#endif /* _MSC_VER >= 1000 */
#endif /* (_OWN_BLDPCS)    */


#endif /* __NSPWARN_H__    */

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\motioncomp_wmv.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

	MotionCompDec.h

Abstract:

	Decoder motion compensation routines 

Author:

	Ming-Chieh Lee (mingcl@microsoft.com) July-1998
	Joseph Wu (sjwu@microsoft.com) July-1998
    Chuang Gu (chuanggu@microsoft.com)

Revision History:

*************************************************************************/
#include "wmvdec_api.h"

#ifndef _MOTIONCOMPDEC_H_
#define _MOTIONCOMPDEC_H_

#define MOTION_COMP_ARGS 	        struct tagWMVDecInternalMember *pWMVDec, \
                                    PixelC*              ppxlcPredMB,   /* Predicted Block               */   \
	                                const PixelC*        ppxlcRef,      /* Refferance Block              */   \
                                    I32_WMV                  iWidthFrm,    /* predicted block width         */   \
                                    Bool_WMV                 bInterpolateX, /* need horizantal interpolation */   \
                                    Bool_WMV                 bInterpolateY, /* need vertical interpolation   */\
                                    I32_WMV                  iMixedPelMV

#define MOTION_COMP_ARGS_MC_VEC 	PixelC*              ppxlcPredMB,   /* Predicted Block               */   \
	                                const PixelC*        ppxlcRef,      /* Refferance Block              */   \
                                    I32_WMV                  iWidthPred,    /* predicted block width         */   \
                                    I32_WMV                  iWidthRef     /* referance block width         */  


#define MOTION_COMP_ADD_ERROR_ARGS  struct tagWMVDecInternalMember *pWMVDec, \
                                    PixelC __huge*       ppxlcCurrQMB,      \
                                    const Buffer __huge* ppxliErrorBuf,     \
                                    const PixelC __huge* ppxlcRef,          \
                                    I32_WMV                  iWidthFrm,         \
                                    Bool_WMV                 bXEven,            \
                                    Bool_WMV                 bYEven,    \
                                    I32_WMV iMixedPelMV	


#define MOTION_COMP_ADD_ERROR_ARGS_MC_VEC  PixelC __huge*       ppxlcCurrQMB,      \
                                    const PixelC __huge* ppxlcRef,          \
                                    const Buffer __huge* ppxliErrorBuf,     \
                                    I32_WMV                  iWidthFrm    

#define MOTION_COMP_ZERO_ARGS       PixelC __huge* ppxliCurrQYMB, \
	                                PixelC __huge* ppxliCurrQUMB, \
	                                PixelC __huge* ppxliCurrQVMB, \
	                                const PixelC __huge* ppxliRefYMB, \
	                                const PixelC __huge* ppxliRefUMB, \
	                                const PixelC __huge* ppxliRefVMB, \
	                                I32_WMV iWidthY, \
	                                I32_WMV iWidthUV

////////////////// External (Exported) //////////

Void_WMV g_InitMotionComp (U8_WMV *rgiClippingTable = NULL_WMV, Bool_WMV bAlwaysUseCVersion = FALSE);

#ifndef OPT_ZEROMOTION_ARM
Void_WMV g_MotionCompZeroMotion_WMV (MOTION_COMP_ZERO_ARGS);
#else
extern "C" Void_WMV g_MotionCompZeroMotion_WMV (MOTION_COMP_ZERO_ARGS);
#endif //OPT_ZEROMOTION_ARM
Void_WMV g_MotionCompAndAddError (MOTION_COMP_ADD_ERROR_ARGS);
Void_WMV g_MotionComp (MOTION_COMP_ARGS);
Void_WMV g_MotionCompAndAddErrorRndCtrl (MOTION_COMP_ADD_ERROR_ARGS);
Void_WMV g_MotionCompRndCtrl (MOTION_COMP_ARGS);

#ifdef OPT_MC_VEC
extern Void_WMV (* g_pMCTable[8])(MOTION_COMP_ARGS_MC_VEC);
extern Void_WMV (* g_pMCAndAddErrorTable[8])(MOTION_COMP_ADD_ERROR_ARGS_MC_VEC);
#endif

#if defined(_WMV_TARGET_X86_)
Void_WMV g_MotionCompZeroMotion_MMX_WMV (MOTION_COMP_ZERO_ARGS);
Void_WMV g_MotionCompAndAddError_MMX (MOTION_COMP_ADD_ERROR_ARGS);
Void_WMV g_MotionComp_MMX (MOTION_COMP_ARGS);
Void_WMV g_MotionComp_KNI (MOTION_COMP_ARGS);
Void_WMV g_MotionCompAndAddErrorRndCtrl_MMX (MOTION_COMP_ADD_ERROR_ARGS);
Void_WMV g_MotionCompRndCtrl_MMX (MOTION_COMP_ARGS);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\msaudio.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    MsAudio.h

Abstract:

    Implementation of public member functions for CAudioObject.

Author:

    Wei-ge Chen (wchen) 11-March-1998

Revision History:


*************************************************************************/

// Compile Time Flags normally defined in project seetings
// these vary from specific project to project
// BUILD_INTEGER - build integer version
// BUILD_INT_FLOAT - build float version of integer tree = !BUILD_INTEGER
// ENCODER - build encoder
// DECODER - build decoder = !ENCODER
// ENABLE_ALL_ENCOPT - build support for all encoder options (otherwise just HighRate)
// ENABLE_LPC - build LPC spectrogram weighting for LowRate configurations (only defined if ENABLE_ALL_ENCOPT)
// ENABLE_EQUALIZER - build support for equalizer
// Known Useful Combinations
//   ENCODER && !BUILD_INTEGER &&  ENABLE_ALL_ENCOPT &&  ENABLE_LPC	= Normal Encoder
//   ENCODER &&  BUILD_INTEGER &&  ENABLE_ALL_ENCOPT &&  ENABLE_LPC	= Partially Integerized Encoder
//   DECODER &&  BUILD_INTEGER &&  ENABLE_ALL_ENCOPT &&  ENABLE_LPC	= Normal Integer Do-It-All Decoder
//   DECODER &&  BUILD_INTEGER &&  ENABLE_ALL_ENCOPT && !ENABLE_LPC	= Normal Integer HighRate & MidRate Decoder
//   DECODER &&  BUILD_INTEGER && !ENABLE_ALL_ENCOPT && !ENABLE_LPC	= Normal Integer HighRate Only Decoder
//   DECODER && !BUILD_INTEGER &&  ENABLE_ALL_ENCOPT &&  ENABLE_LPC	= IntFloat Do-It-All Decoder
//   DECODER && !BUILD_INTEGER &&  ENABLE_ALL_ENCOPT && !ENABLE_LPC	= IntFloat HighRate & MidRate Decoder
//   DECODER && !BUILD_INTEGER && !ENABLE_ALL_ENCOPT && !ENABLE_LPC	= IntFloat HighRate Only Decoder
#ifndef __MSAUDIO_H_
#define __MSAUDIO_H_

#ifdef __cplusplus
extern "C" {  // only need to export C interface if
              // used by C++ source code
#endif

#include <stdlib.h>

#include "macros.h"
#include "DecTables.h"


// Encoder-only/decoder-only defines are no longer allowed. All audio components
// must be built with same defines so that encoder and decoder may both be linked into
// one EXE.
#if defined(ENCODER) || defined(DECODER)
#error Encoder- and Decoder-specific defines are no longer allowed. Encoder/decoder-specific code must perform encoder/decoder identification at runtime.
#endif  // defined(ENCODER) || defined(DECODER)

// The INTEGER_ENCODER #define was, where possible, replaced with BUILD_INTEGER.
// The remaining INTEGER_ENCODER's have remained as "tombstones" and should be replaced
// with a run-time decision of which codepath to take. As described above, encoder- and
// decoder-specific defines are no longer allowed.
#ifdef INTEGER_ENCODER
#error Encoder-specific defines no longer allowed. See above comments.
#endif  // INTEGER_ENCODER

#define MAX_SUBFRAMES       16

// Forward data type decl
typedef struct _CoefStream CoefStream;
typedef struct PerChannelInfoENC PerChannelInfoENC;

typedef enum {TT_NONE = 0, TT_SIMPLE} TRANSCODETYPE;
typedef enum {STEREO_INVALID = -1, STEREO_LEFTRIGHT = 0, STEREO_SUMDIFF} StereoMode;
typedef enum {CODEC_NULL, CODEC_STEADY, CODEC_DONE, CODEC_BEGIN, CODEC_LAST, CODEC_ONHOLD} Status;
typedef enum {FMU_DONE = 0, FMU_QUANTIZE, FMU_PROCESS} FMU_STATUS;
typedef enum {FFT_FORWARD = 0, FFT_INVERSE} FftDirection;

typedef struct PerChannelInfo 
{
//whenever the memory gest moved to buckets, update is needed
    // Decoder and Global Members
    I16*           m_rgiCoefQ;						//quantized coef
    Int*           m_rgiMaskQ;                      //quantized maskq ((could be I16))
    U8*            m_rgbBandNotCoded;               //band not coded
	FastFloat*	   m_rgffltSqrtBWRatio;				//MidRate/LowRate for Bands not coded
	Int*		   m_rgiNoisePower;
    const U16*     m_rgiHuffDecTbl;                 //decoder only
    const U16*     m_rgiRunEntry;                   //decoder only        
    const U16*     m_rgiLevelEntry;                 //decoder only
    Int            m_cSubbandActual;
    Int            m_iPower;                        //channel power
    Int            m_iActualPower;                  // Power as suggested by CoefQ/CoefRecon
    UInt*          m_rguiWeightFactor;				//weighting factor
    Int*           m_rgiCoefRecon;                  //reconstructed coef
	Int			   m_iMaxMaskQ;	

#define CURRGETPCM_INVALID  0x7FFF
    I16            m_iCurrGetPCM_SubFrame;          // reconstruction index
    Int*           m_rgiCoefReconCurr;  //current position in m_rgiCoefRecon
    I16*           m_piPrevOutput;      //prev history per channel
    I16*           m_piPrevOutputSign;  //sign of m_piPrevOutput
    I16*           m_piPrevOutputCurr;  //current position in m_piPrevOutput

	// These next five must be kept in this order for SH4 optimizations
    Int            m_iSin;    //floating value = (float)iSin/0x3FFFFFFF
    Int            m_iCos;    //floating value = (float)iCos/0x3FFFFFFF
	Int            m_iSin1;	 //previous sin value for recurrsion
	Int            m_iCos1;	 //previous cos value for recurrsion
	Int            m_iStep;	 // 2*sin(step increment)

    // Float-only members
#ifndef BUILD_INTEGER
#endif
    // The following is NOT YET INTEGERIZED but after it is,
    // it should be moved into the #ifndef BUILD_INTEGER above
    Float*         m_rgfltCoefRecon;                //reconstructed coef soon to be removed
    Float*         m_rgfltBandWeight;    

#ifdef BUILD_INTEGER
#else
#endif
    // The following are NOT YET INTEGERIZED but after they are,
    // they should be moved into the #ifndef BUILD_INTEGER above
    Float*         m_rgfltWeightFactor;
    WeightType     m_wtMaxWeight;


    // Pointer to encoder data, if applicable
    PerChannelInfoENC*  ppcinfoENC;

    // This is encoder-only but I've put it here to avoid having to #include "msaudioenc.h"
    // in common files.
    Bool*            m_rgfMaskNeededForBark;   // for header squeezing
} PerChannelInfo;

typedef struct SubFrameConfigInfo
{ 
    Int m_cSubFrame;
    Int m_rgiSubFrameSize [MAX_SUBFRAMES];
    Int m_rgiSubFrameStart [MAX_SUBFRAMES];
    Int m_iFirstTransientSubFrm;        //for enc only
    Int m_iLastTransientSubFrm;         //for enc only
    Int m_cMaskUpdate;                  //for enc only
    Int m_rgfMaskUpdate [MAX_SUBFRAMES];
} SubFrameConfigInfo;


typedef enum {LPC_MODE=0,BARK_MODE} WeightMode;

typedef struct CAudioObject
{
    //Step Size
    QuantStepType  m_qstQuantStep;
#if 0
	// no longer needed
    UInt    m_rgiQuantStepFract[QUANTSTEP_DENOMINATOR - 1]; // Exclude numerator of 0
#endif

    // packetization (has nothing to do with the rest)
    Int m_iPacketCurr;
    Int m_cBitPackedFrameSize;
    Int m_cBitPacketHeader;
    Int m_cdwPacketHeader;
    Int m_cBitPacketHeaderFractionDw;
    Int m_cBitPacketLength;

    //utility vars for entropy decoding for high rate only
    Int m_cRunOfZeros;
    I16 m_iLevel; 
    Int m_iSign;
    Int m_iHighCutOffCurr;
    Int m_iNextBarkIndex;

    Bool  m_fNoiseSub; 
    Float m_fltBitsPerSample;
    Float m_fltWeightedBitsPerSample;

    Int m_iMaxEscSize;          // in bits
    Int m_iMaxEscLevel;         // (1<<m_iMaxEscSize)

    
    Int     m_iVersion;
    Status	m_codecStatus;          //current status of the codec
    Bool    m_fSeekAdjustment;
    Bool    m_fPacketLossAdj;       //skip some samples when packetloss
    Int		m_iSamplingRate;        //audio sampling rate in Hz
    U16		m_cChannel;
    U32     m_nBytePerSample;
    Int		m_cSubband;				//no. of subbands in the MLT transform

    Bool    m_fAllowSuperFrame;
    Bool    m_fAllowSubFrame;
    Bool    m_fV5Lpc;
//!! reset
    Int     m_iCurrSubFrame;        //which subframe we are doing
    I16     m_iCurrReconCoef;       //which coef we are doing
    Bool    m_fHeaderReset;
//!! dupe? needed for inv-quantization
    Int     m_iSubFrameSizeWithUpdate;
    Int     m_iMaxSubFrameDiv;      //maximum no. division into subwindows
    Int     m_cMinSubFrameSample;   //min size of subframes in current frame; many change from frame to frame
    Int     m_cMinSubFrameSampleHalf;   //min size of subframes in current frame; many change from frame to frame
    Int     m_cMinSubFrameSampleQuad;   //min size of subframes in current frame; many change from frame to frame
    Int     m_cPossibleWinSize; 
    Int     m_iIncr;                //log2(longest winsize / curr winsize)
    Int     m_cSubFrameSample;      //for long win, same as m_cFrameSample
    Int     m_cSubFrameSampleHalf;
    Int     m_cSubFrameSampleQuad;
//!! yes!
    SubFrameConfigInfo  m_subfrmconfigPrev;
    SubFrameConfigInfo  m_subfrmconfigCurr;
    SubFrameConfigInfo  m_subfrmconfigNext;

    //should be reset every subfrm in next version
    Int		m_cBitsSubbandMax;	    //no. of bits for m_cSubband; 
    Int		m_cFrameSample;         //no. of input/output samples = 2 * cSubband
    Int		m_cFrameSampleHalf;     //no. of input/output samples = cSubband
    Int		m_cFrameSampleQuad;     //no. of input/output samples = cSubband / 2

    Int		m_cLowCutOff;           //How many coeffs to zero at the low end of spectrum
    Int		m_cHighCutOff;			//How many coeffs to zero at the high end of spectrum
    Int		m_cLowCutOffLong;
    Int		m_cHighCutOffLong;		

    Int		m_iWeightingMode;
//!! yes!
    StereoMode  m_stereoMode;       // left-right or sum-difference coding 
    Int     m_iEntropyMode;         //entropy coding mode
    Float	m_fltDitherLevel;	    //=.12; Relative intensity of Roberts' pseudo-random noise quantization
    Int		m_iQuantStepSize;
    Float	m_fltFlatenFactor;	    //Excess spectral noise power factor. Typical values are
    							    //in the range 0.4 -- 0.9; best choice is 0.5
    Float   m_fltDctScale;
    Int		m_cValidBarkBand;       //valid bark band in range; some are out of range in the subband decompositio
    const Int*	m_rgiBarkIndex;     //corresponding coef index for each valid bark


#if defined(BUILD_INTEGER)
	I32     m_iSinRampUpStart;
	I32     m_iCosRampUpStart;
	I32     m_iSinRampUpPrior;
	I32     m_iCosRampUpPrior;
	I32     m_iSinRampUpStep;
	I32     m_iSinRampDownStart;
	I32     m_iCosRampDownStart;
	I32     m_iSinRampDownPrior;
	I32     m_iCosRampDownPrior;
	I32     m_iSinRampDownStep;
	I32     m_iSinInit[4];			// still need these for encoder (MsAudioEnc) until its recurrsion is fixed
	I32     m_iCosInit[4];			// still need these for encoder (MsAudioEnc) until its recurrsion is fixed
#endif

#if !defined(BUILD_INTEGER)
	V4V5COMPARE    m_fltSinRampUpStart;
	V4V5COMPARE    m_fltCosRampUpStart;
	V4V5COMPARE    m_fltSinRampUpPrior;
	V4V5COMPARE    m_fltCosRampUpPrior;
	V4V5COMPARE    m_fltSinRampUpStep;
	// These next five must be kept in this order for SH4 optimizations
	V4V5COMPARE    m_fltSinRampDownStart;
	V4V5COMPARE    m_fltCosRampDownStart;
	V4V5COMPARE    m_fltSinRampDownPrior;
	V4V5COMPARE    m_fltCosRampDownPrior;
	V4V5COMPARE    m_fltSinRampDownStep;
#endif

    Int     m_iSizePrev;
    Int     m_iSizeCurr;
    Int     m_iSizeNext;

    Int     m_iCoefRecurQ1;
    Int     m_iCoefRecurQ2;
    Int     m_iCoefRecurQ3;
    Int     m_iCoefRecurQ4;

    I16*	m_rgiCoefQ;             // just a pointer

    //random accessed memory
    //overall
    own PerChannelInfo*     m_rgpcinfo;

    //transform
	own Int*	m_rgiCoefReconOrig;
    //weighting
//!!yes? invQ needs it
    own Int*	m_rgiMaskQ;
    own Int*	m_rgcValidBarkBand;
    own Int*	m_rgiBarkIndexOrig;  

    //output
//!!yes? invQ needs it
    own I16*	m_piPrevOutput;        // previous encoded output; bottom half += top half of Curr; then gone
//!!yes? invQ needs it
    I32         m_iDiscardSilence;

#ifdef ENABLE_ALL_ENCOPT
    Float   m_fltFirstNoiseFreq;
    Int		m_iFirstNoiseBand;
    Int     m_iFirstNoiseIndex;
    Int     m_iNoisePeakIgnoreBand; // Num of coefficients to ignore when detecting peaks during noise substitution

    //only used for NoiseSub mode
    own Int*        m_rgiFirstNoiseBand;
//!!yes
    own U8*         m_rgbBandNotCoded;
	own FastFloat*	m_rgffltSqrtBWRatio;
//!!yes
    own Int*        m_rgiNoisePower;
//!!for invQ
    own Float*      m_rgfltBandWeight;

#if defined(_DEBUG) && defined(LPC_COMPARE)
    Float* m_rgfltLpsSpecCos [LPCORDER];
    Float* m_rgfltLpsSpecSin [LPCORDER];
#endif  // _DEBUG
#else   // ENABLE_ALL_ENCOPT
#endif  // ENABLE_ALL_ENCOPT

    Float*  m_rgfltWeightFactor; 
    UInt*	m_rguiWeightFactor;   //share with m_rgiMaskQ when bark

    U32 m_iFrameNumber; // frame counter to the common code

#if defined(INTERPOLATED_DOWNSAMPLE)
    Bool    m_fLowPass;             // Specify independently of downsampling
    Bool    m_fDownsample;          // Eg, Downsample 32kHz output to 22kHz for some devices
    Int     m_iInterpolSrcBlkSize;  // Size of 1 indivisible source block
    Int     m_iInterpolDstBlkSize;  // Size of 1 indivisible destination block
    Int     m_iInterpolIncr;        // Pointer increment
    Int     m_iInterpolCarry;       // Pointer increment "carry", +1 from time to time
    I32     m_iInterpolWeightIncr;  // FixedPt increment to interpolation weight
    Int     m_iInterpolAddInterval; // Add an extra sample at this interval of output samples
    Int     m_iInterpolNextAdd;     // Countdown to extra sample
#endif  // defined(INTERPOLATED_DOWNSAMPLE)

#if defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
    Bool    m_fHalfTransform;
    Bool    m_fUpsample;
    Bool    m_fPad2XTransform;
	I16		m_iPriorSample[2];		// warning: maximum number of channels is currently 2

    // the following values are adjusted to reflect HalfTransform or PAd2XTransform
    // They are used for the DCT and for Reconstruction.
    Int		m_cSubbandAdjusted;
    Int     m_cFrameSampleAdjusted; 
    Int     m_cFrameSampleHalfAdjusted;
    Int     m_cSubFrameSampleAdjusted;
    Int     m_cSubFrameSampleHalfAdjusted;
    Int     m_cSubFrameSampleQuadAdjusted;
    Int		m_cHighCutOffAdjusted;
    // m_iCoefRecurQ1..4 and Trig values only exist in their adjusted states
#else   // defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
    // Without these features, no need for adjusted values, 
    // so make the code use the regular values
#   define  m_cSubbandAdjusted            m_cSubband
#   define  m_cFrameSampleAdjusted        m_cFrameSample
#   define  m_cFrameSampleHalfAdjusted    m_cFrameSampleHalf
#   define  m_cSubFrameSampleAdjusted     m_cSubFrameSample
#   define  m_cSubFrameSampleHalfAdjusted m_cSubFrameSampleHalf
#   define  m_cSubFrameSampleQuadAdjusted m_cSubFrameSampleQuad
#   define	m_cHighCutOffAdjusted         m_cHighCutOff
#endif  // defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)


    // Function Pointers
    WMARESULT (*aupfnInverseQuantize) (struct CAudioObject* pau,
        PerChannelInfo* ppcinfo, Int* rgiWeightFactor);
    FastFloat (*aupfnCalcSqrtBWRatio)(const PerChannelInfo *ppcinfo,
        const Int iNoiseBand, const Int cNoiseBand);
    WMARESULT (*prvpfnInverseTransformMono) (struct CAudioObject* pau,
        PerChannelInfo* ppcinfo, I16* piOutput, I16* piPrevOutput,
        I16* piPrevOutputSign, Bool fForceTransformAll);
    WMARESULT (*aupfnGetNextRun) (Void* paudec, PerChannelInfo* ppcinfo, Int *piBitCnt);

    WMARESULT (*aupfnReconstruct) (struct CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll);

    WMARESULT (*aupfnDctIV) (struct CAudioObject* pau, CoefType* rgiCoef, Float fltAfterScaleFactor, U32 *piMagnitude);
    void (*aupfnFFT) (CoefType data[], Int nLog2np, FftDirection fftDirection);

#if !defined(BUILD_INTEGER) && !defined(UNDER_CE) && defined(WMA_TARGET_X86) && !defined(_Embedded_x86)
    Bool    m_fIntelFFT;    // Intel FFT needs setup/takedown, so we need to know this
#endif  // !defined(BUILD_INTEGER) && !defined(UNDER_CE) && defined(WMA_TARGET_X86)

	tRandState m_tRandState;

#ifdef USE_SIN_COS_TABLES
    //Tables for reconstruction sin values
    BP2Type *m_piSinForRecon2048;
    BP2Type *m_piSinForRecon1024;
    BP2Type *m_piSinForRecon512;
    BP2Type *m_piSinForRecon256;
    BP2Type *m_piSinForRecon128;
    BP2Type *m_piSinForRecon64;
    BP2Type *m_piSinForRecon;

    BP2Type *m_piSinForSaveHistory;
#endif

} CAudioObject;


//public and protected
#ifdef __cplusplus
extern "C" {  // only need to export C interface if
              // used by C++ source code
#endif


#if defined(HALF_TRANSFORM)
#   define HALFTRANSFORM_ONLY(x)   (x)
#   define UPSAMPLE_ONLY(x)        (x)
#   define HALF(fHalfTransform, x)  ((fHalfTransform) ? ((x)/2) : (x))
#else   // defined(HALF_TRANSFORM)
#   define HALFTRANSFORM_ONLY(x)
#   define UPSAMPLE_ONLY(x)
#   define HALF(fUpsample, x)  (x)
#endif  // defined(HALF_TRANSFORM)

#if defined(PAD2X_TRANSFORM)
#   define PAD2XTRANSFORM_ONLY(x)	(x)
#   define DOUBLE(fPad2X, x)  ((fPad2X) ? ((x)*2) : (x))
#else   // defined(PAD2X_TRANSFORM)
#   define PAD2XTRANSFORM_ONLY(x)
#   define DOUBLE(fUpsample, x)    (x)
#endif  // defined(PAD2X_TRANSFORM)

//#if defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
//#   define HALF_OR_DOUBLE(fHalfTransform, fPad2X, x)  ((fHalfTransform) ? ((x)/2) : ((fPad2X) ? ((x)*2) : (x)))
//#else   // defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
//#   define HALF_OR_DOUBLE(fUpsample, fPad2X, x)      (x)
//#endif  // defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)


U32 MaxSamplesPerPacket(U32 ulVersion, U32 ulSamplingRate, U32 ulChannels, U32 ulBitrate);
I32 msaudioGetSamplePerFrame (Int   cSamplePerSec, 
                              U32   dwBitPerSec, 
                              Int   cChannel,
                              Int   iVersion);

CAudioObject* auNew ();
Void    auDelete (CAudioObject* pau);        //destructor
WMARESULT auInit (CAudioObject* pau, Int iVersionNumber, Int cSubband, 
                  Int iSamplingRate, U16 cChannel, 
                  Int cBytePerSec, Int cbPacketLength,
                  U16 iEncodeOpt, U16 iPlayerOpt);

Void    auPreGetPCM (CAudioObject* pau, U16* pcSampleDecoded);
WMARESULT auGetPCM (CAudioObject* pau, U16* pcSample, U8* pbDst, U32 cbDstLength);
WMARESULT auReconstruct (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll);
WMARESULT auSaveHistoryMono (CAudioObject* pau, PerChannelInfo* ppcinfo, 
                            Bool fForceTransformAll);

WMARESULT auAdaptToSubFrameConfig (CAudioObject* pau);
WMARESULT auAdaptToSubFrameConfigDEC (CAudioObject* pau);
WMARESULT prvAdaptTrigToSubframeConfig(CAudioObject *pau);
WMARESULT prvAdaptTrigToSubframeConfig_INT(CAudioObject *pau);


Int     auPowerToRMS(CAudioObject* pau, Int iCurrMaskQ, Int iPrevMaskQ, Int iPrevResult);
Void    auUpdateMaxEsc(CAudioObject* pau, Int iQuantStepSize);

WMARESULT auDctIV(CAudioObject* pau, CoefType* rgiCoef, 
				   Float fltAfterScaleFactor, U32 *piMagnitude);  // DCT type 4

// LPC functions
#ifdef ENABLE_ALL_ENCOPT
Void    auResampleWeightFactorLPC (CAudioObject* pau, PerChannelInfo* ppcinfo);
Void    auLsp2lpc(CAudioObject* pau, U8 *lsfQ, LpType *lpc, Int order);
#endif //ENABLE_ALL_ENCOPT

WMARESULT prvAllocate (CAudioObject* pau);

#ifdef __cplusplus
}
#endif

//private:

// *** TEMPORARY: prvAllocate moved from here to extern "C" block above ***

Void    prvSetBarkIndex (CAudioObject* pau);
WMARESULT prvInverseQuantizeHighRate (CAudioObject* pau, PerChannelInfo* ppcinfo, Int* rgiWeightFactor);
WMARESULT auReconCoefficentsHighRate (CAudioObject* pau, Void* pcaller,
                                      PerChannelInfo* ppcinfo, Int* piBitCnt);


WMARESULT prvInverseTransformMono (CAudioObject* pau, PerChannelInfo* ppcinfo, I16* piOutput,
                                 I16* piPrevOutput, I16* piPrevOutputSign,
                                 Bool fForceTransformAll);

WMARESULT auReconMono ( CAudioObject* pau,PerChannelInfo* ppcinfo,I16* piOutput,I16* pcSampleGet,Bool fForceTransformAll);


#if defined(WMA_TARGET_MIPS) && defined(BUILD_INTEGER)
//This function initalizes the function pointers for mips transforms
WMARESULT auInitMIPS(CAudioObject* pau);
#endif


#if defined(WMA_TARGET_X86)
WMARESULT auDctIV_KNI(CAudioObject* pau, CoefType* rgiCoef, Float fltAfterScaleFactor, U32 *piMagnitude);
WMARESULT auDctIV_INTEL(CAudioObject* pau, CoefType* rgiCoef, Float fltAfterScaleFactor, U32 *piMagnitude);

#if !defined(BUILD_INTEGER) && !defined(UNDER_CE) && !defined(_Embedded_x86)
typedef enum {INTELFFT_INIT_PROCESS, INTELFFT_INIT_THREAD,
    INTELFFT_FREE_THREAD, INTELFFT_FREE_PROCESS} INTELFFT_INITCODE;

void prvFFT4DCT_INTEL(CoefType data[], Int nLog2np, FftDirection fftDirection);
WMARESULT auInitIntelFFT(const CAudioObject *pau, const INTELFFT_INITCODE iCode);
WMARESULT auFreeIntelFFT(const CAudioObject *pau, const INTELFFT_INITCODE iCode);
#endif  // !defined(BUILD_INTEGER) && !defined(UNDER_CE)


#ifdef USE_SIN_COS_TABLES
#ifndef BUILD_INTEGER
WMARESULT auReconstruct_X86 (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll);
WMARESULT auReconMono_X86 ( CAudioObject* pau,PerChannelInfo* ppcinfo,I16* piOutput,I16* pcSampleGet,Bool fForceTransformAll);
WMARESULT auReconStereo_MMX (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll);
WMARESULT auReconStereo_SIMDFP (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll);
#else
WMARESULT auReconstruct_MMX (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll);
WMARESULT auReconMono_MMX ( CAudioObject* pau,PerChannelInfo* ppcinfo,I16* piOutput,I16* pcSampleGet,Bool fForceTransformAll);
#endif //#ifndef BUILD_INTEGER
#endif //#ifdef USE_SIN_COS_TABLES
WMARESULT prvInverseTransformMono_MMX (CAudioObject* pau, Float* rgfltCoefRecon,
                                     I32* piCurrOutput, Bool fForceTransformAll);
#endif // defined(WMA_TARGET_X86)

#if !(defined(WMA_TARGET_MIPS)&&defined(BUILD_INTEGER))
Void    prvFFT_Int(Int data[], Int np);
Void    prvFFT4DCT(CoefType data[], Int nLog2np, FftDirection fftDirection);

#endif // !WMA_TARGET_MIPS

#ifdef ENABLE_ALL_ENCOPT
//for noise sub and low rates only
WMARESULT prvInitNoiseSub (CAudioObject* pau);
WMARESULT prvInverseQuantizeMidRate (CAudioObject* pau, PerChannelInfo* ppcinfo, Int* rgiWeightFactor);
WMARESULT prvInverseQuantizeLowRate (CAudioObject* pau, PerChannelInfo* ppcinfo, Int* rgiWeightFactor);

//private lpc functions
WMARESULT prvLpcToSpectrum (CAudioObject* pau, const LpType* rgfltLpcCoef, PerChannelInfo* ppcinfo);
Void prvInitInverseQuadRootTable (CAudioObject* pau);
#endif //ENABLE_ALL_ENCOPT

#ifdef __cplusplus
}
#endif

#ifndef PREVOUTPUT_16BITS
// **************************************************************************
// Signbit Macros
// I've put them here because they're used in both msaudio.c and float.c
// **************************************************************************
#define I17_MIN ((signed) 0xFFFF0000)
#define I17_MAX ((signed) 0x0000FFFF)
#define CALC_SIGN_OFFSETS(piSrcBase, piSrc, piSrcSignBase, piSrcSign,           \
                           uiSignbitData, uiSignbitCount, cChan)                \
    {                                                                           \
    const int c_iOffset = (piSrc - piSrcBase)>>(cChan-1);                       \
    const int c_iSignOffset = (c_iOffset+((BITS_PER_BYTE * sizeof(I16))-1))		\
							/ (BITS_PER_BYTE * sizeof(I16));					\
    piSrcSign = piSrcSignBase + c_iSignOffset;                                  \
    uiSignbitCount = 16 - (c_iOffset % (BITS_PER_BYTE * sizeof(I16)));          \
	if (uiSignbitCount == 16)													\
		uiSignbitData = *piSrcSign++;                                           \
	else																		\
		uiSignbitData = *(piSrcSign-1);											\
    }

#define RECORD_SIGNBIT(iResult, piDstSign, uiSignbitData, uiSignbitCount, incr) \
    uiSignbitData <<= 1;                                                        \
    uiSignbitData |= ((iResult >> 31) & 0x00000001);                            \
    uiSignbitCount += 1;                                                        \
    if (uiSignbitCount >= 16)                                                   \
    {   /* Signbit register is full! Write it out */                            \
        *piDstSign = (I16) uiSignbitData;                                       \
        piDstSign += incr;                                                      \
        DEBUG_ONLY( uiSignbitData = 0 );                                        \
        uiSignbitCount = 0;                                                     \
    }

#define COMBINE_SIGNBIT(iResult, iSrc, piSrcSign, uiSignbitData, uiSignbitCount) \
    if (0 == uiSignbitCount)                                                     \
    {   /* Signbit register is empty! Read new one in */                         \
        uiSignbitData = *piSrcSign;                                              \
        piSrcSign += 1;                                                          \
        uiSignbitCount = 16;                                                     \
    }                                                                            \
    if (uiSignbitData & 0x00008000)                                              \
        iResult = (-1) & 0xFFFF0000;                                             \
    else                                                                         \
        iResult = 0;                                                             \
    iResult |= (iSrc & 0x0000FFFF);                                              \
    uiSignbitData <<= 1;                                                         \
    uiSignbitCount -= 1;

#define SAVE_SIGNBIT_STATE(piSrcSign,uiSignbitData)								 \
	if (0 != uiSignbitCount)													 \
		*(piSrcSign-1) = (I16)uiSignbitData;	/* must save partial shift */

#define ASSERT_SIGNBIT_POINTER(piSrcOrDstSign)								     \
	assert( piSrcOrDstSign != NULL );

#else   // PREVOUTPUT_16BITS

// Use I16 min/max in place of I17
#define I17_MIN SHRT_MIN
#define I17_MAX SHRT_MAX

#define CALC_SIGN_OFFSETS(piSrcBase, piSrc, piSrcSignBase, piSrcSign,            \
                           uiSignData, uiSignCount, cChan)                             
#define RECORD_SIGNBIT(iResult, piDstSign, uiSignbitData, uiSignbitCount, incr)
#define COMBINE_SIGNBIT(iResult, iSrc, piSrcSign, uiSignbitData, uiSignbitCount) \
    iResult = iSrc
#define SAVE_SIGNBIT_STATE(piSrcSign,uiSignData)
#define ASSERT_SIGNBIT_POINTER(piSrcOrDstSign)

#endif  // PREVOUTPUT_16BITS


#if defined(INTERPOLATED_DOWNSAMPLE)

#define INTERPOL_FRACTBITS  30

void prvInterpolateInit(CAudioObject *pau, Int iSrcSampleRate,
                        Int iDstSampleRate, Int iAddInterval);

#ifdef BUILD_INTEGER
void auLowPass(CAudioObject *pau, Int *rgiCoef, Int iNumCoefs);
#else
void auLowPass(CAudioObject *pau, Float *rgfltCoef, Int iNumCoefs);
#endif  // BUILD_INTEGER
#endif  // defined(INTERPOLATED_DOWNSAMPLE)

#ifdef INTERPOLATED_DOWNSAMPLE
#define DOWNSAMPLE_ONLY(x)  (x)
void prvInterpolate(CAudioObject *pau, I16 *piSourceBuffer, Int iNumSrcSamples, Int iChannels,
                    I16 *piDestBuffer, Int *piNumDstSamples, U16* pcSamples);
#else   // INTERPOLATED_DOWNSAMPLE
#define DOWNSAMPLE_ONLY(x)
#endif  // INTERPOLATED_DOWNSAMPLE

#ifndef BUILD_INTEGER
// do not scale WeightFactor when using float
#undef WEIGHTFACTOR_FRACT_BITS
#define WEIGHTFACTOR_FRACT_BITS 0
#endif

//Void auCalcQuantStep(Int iQuantStepSize, U32 *piQuantStep, U32 *piFractBits);
QuantStepType qstCalcQuantStep(Int iQuantStepSize);
QuantFloat prvWeightedQuantization(CAudioObject *pau, PerChannelInfo *ppcinfo, Int iBark);


void SetActualPower(const I16 *piCoefQ, const int iCount,
                    PerChannelInfo *ppcinfo, const Status codecStatus);
void SetActualPowerHighRate(const I32 *piCoefRecon, const int iCount,
                    PerChannelInfo *ppcinfo, const Status codecStatus);


// **************** Monitor Range of Values for Debugging ******************************
// Place MONITOR_RANGE(name,variable) in the code where you want to monitor a variable,
// and use DUMP_MONITOR_RANGES(0) in the exit code where you want to print out the results
// If you want to dump on a frame-by-frame basis, use REINIT_MONITOR_RANGE after the dump
// Finally, add an appropriate DECL_MONITOR_RANGE(name) in wmaOS.c 
// and add DUMP_MONITOR_RANGE(name) to the DumpMonitorRanges() function there.
// **************************************************************************************
#if defined(_DEBUG) && defined(WMA_MONITOR)
// some MONITOR_RANGE variations can be defined.
// First variation is to print the variable to stdout
//#	define WMA_MONITOR_PRINT "gMR_rgfltWeightFactor"
// Second variation allows you to break when the fabs(variable) exceeds a threshold
//#	define WMA_MONITOR_BREAK "gMR_rgfltWeightFactor"
//#	define WMA_MONITOR_BREAK_THRESHOLD 50
// both of these variations are slow because strcmp is done at runtime instead of compile time - but this is debug code.
#	ifdef WMA_MONITOR_PRINT
#		define MONITOR_RANGE(a,x) { extern double a[]; extern long lc##a; if ((double)(x)<a[0]) a[0]=(double)(x); if ((double)(x)>a[1]) a[1]=(double)(x); a[2] += (x); a[3] += (x)*(x); lc##a++; \
									if (strcmp(#a,WMA_MONITOR_PRINT)==0) printf("%14.6g\n",(double)(x));  }
#	elif defined(WMA_MONITOR_BREAK)
#		define MONITOR_RANGE(a,x) { extern double a[]; extern long lc##a; if ((double)(x)<a[0]) a[0]=(double)(x); if ((double)(x)>a[1]) a[1]=(double)(x); a[2] += (x); a[3] += (x)*(x); lc##a++; \
									if (strcmp(#a,WMA_MONITOR_BREAK)==0 && fabs(x)>WMA_MONITOR_BREAK_THRESHOLD) DEBUG_BREAK();  }
#	else
#		define MONITOR_RANGE(a,x) { extern double a[]; extern long lc##a; if ((double)(x)<a[0]) a[0]=(double)(x); if ((double)(x)>a[1]) a[1]=(double)(x); a[2] += (x); a[3] += (x)*(x); lc##a++; }
#	endif
#	define MONITOR_RANGE_CONDITIONAL(cond,a,x) if (cond) { extern double a[]; extern long lc##a; if ((double)(x)<a[0]) a[0]=(double)(x); if ((double)(x)>a[1]) a[1]=(double)(x); a[2] += (x); a[3] += (x)*(x); lc##a++; }
#	define MONITOR_COUNT(a,c) { extern long lc##a; lc##a+=c; }
#	define MONITOR_COUNT_CONDITIONAL(cond,a,c) if (cond) { extern long lc##a; lc##a+=c; }
#	define DUMP_MONITOR_RANGES(fAppend) { void DumpMonitorRanges(int f); DumpMonitorRanges(fAppend); }
#	define REINIT_MONITOR_RANGE(a) { extern double a[]; extern long lc##a; a[1] = -( a[0] = 1.0e30 );  a[2] = a[3] = 0; lc##a = 0; }
#	define DUMP_MONITOR_RANGE(a) { extern double a[]; extern long lc##a; if ( a[0] == 1.0e30 && a[3]==0 ) { a[0] = a[1] = 0; } if (lc##a>0) printf("%14.6g %14.6g %14.6g %14.6g %8ld " #a "\n", a[0], a[1], a[2]/lc##a, sqrt((lc##a*a[3]-a[2]*a[2])/((double)(lc##a)*(lc##a-1))), lc##a ); }
#else // not (defined(_DEBUG) && defined(WMA_MONITOR))
#	define MONITOR_RANGE(a,x)
#	define MONITOR_RANGE_CONDITIONAL(cond,a,x)
#	define MONITOR_COUNT(a,c)
#	define MONITOR_COUNT_CONDITIONAL(cond,a,c)
#	define DUMP_MONITOR_RANGES(fAppend)
#	define REINIT_MONITOR_RANGE(a)
#	define DUMP_MONITOR_RANGE(a) 
#endif

#if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
    void prvWmaShowFrames(CAudioObject* pau, const char* pszID, const char* pszFmt, ...);
#endif

#if defined(HEAP_DEBUG_TEST) && defined(_DEBUG)
void HeapDebugCheck();
#define HEAP_DEBUG_CHECK HeapDebugCheck()
#else
#define HEAP_DEBUG_CHECK
#endif

// **************************************************************************
// Encoding Options
// **************************************************************************
#define ENCOPT_BARK             0x0001
#define ENCOPT_V5LPC            0x0020
#define ENCOPT_SUPERFRAME       0x0002
#define ENCOPT_SUBFRAME         0x0004

#define ENCOPT_SUBFRAMEDIVMASK  0x0018
#define ENCOPT_SUBFRAMEDIVSHR   3



// **************************************************************************
// Player Options
// **************************************************************************
#define PLAYOPT_DOWNSAMPLE32TO22 0x0001
#define PLAYOPT_HALFTRANSFORM    0x0002
#define PLAYOPT_UPSAMPLE         0x0004
#define PLAYOPT_PAD2XTRANSFORM   0x0008


//mallocAligned allocates a buffer of size (+iAlignToBytes for allignment padding) bytes 
//which is alligned on an iAllignToBytes byte boundary
//the buffer must be deallocated using freeAligned
//and it is only safe to use size bytes as the padding could be at the begining or ending
void *mallocAligned(size_t size,Int iAlignToBytes);
void freeAligned(void *ptr);

// ----- Memory Allocation Functions -----
typedef enum {MAS_ALLOCATE, MAS_LOCKED, MAS_DELETE} MEMALLOCSTATE;

I32 auMallocGetCount(void);
void auMallocSetState(const MEMALLOCSTATE maState, void *pBuf, const I32 iBufSize);
void *auMalloc(const size_t iSize);
void auFree(void *pFree);



//***************************************************************************
// Encoder/Decoder Separation
//***************************************************************************

#define PRECESSION_BITS_FOR_INVQUADROOT 12

#if defined(_DEBUG) && defined(LPC_COMPARE)
void prvSetupLpcSpecTrig(CAudioObject* pau);
#define SETUP_LPC_SPEC_TRIG(pau) prvSetupLpcSpecTrig(pau)
#else
#define SETUP_LPC_SPEC_TRIG(pau) 
#endif


#endif //__MSAUDIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\msaudiodec.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    MsAudioDec.h

Abstract:

    Header file for CAudioObjectDecoder.

Author:

    Wei-ge Chen (wchen) 14-July-1998

Revision History:


*************************************************************************/

#ifndef __MSAUDIODEC_H_
#define __MSAUDIODEC_H_

#include <math.h>
#include <limits.h>
#include "stdio.h"

#include "msaudio.h"
#include "strmdec_wma.h"

typedef enum {BEGIN_PACKET, BEGIN_FRAME, BEGIN_SUBFRAME, DECODE_SUBFRAME, END_SUBFRAME1, END_SUBFRAME2} DecodeStatus;
typedef enum {SUBFRM_HDR, SUBFRM_COEF, SUBFRM_DONE} SubFrmDecodeStatus;
typedef enum {HDR_SIZE, HDR_QUANT, HDR_NOISE1, HDR_NOISE2, HDR_MSKUPD, HDR_BARK, HDR_DONE} HdrDecodeStatus; //and a lot more
typedef enum {VLC, FRAME_END, NORMAL, ESCAPE} RunLevelStatus;

typedef struct CAudioObjectDecoder 
{
    CAudioObject* pau;
    //packetization stuff
    Bool  m_fPacketLoss;
    I16   m_cFrmInPacket;
    U8*   m_pbSrcCurr;  //ptr to src of curr packet, only for non-strm mode
    U16   m_cbSrcCurrLength; //only for non-strm mode
    DecodeStatus       m_decsts;
    SubFrmDecodeStatus m_subfrmdecsts;
    HdrDecodeStatus    m_hdrdecsts;
    RunLevelStatus     m_rlsts;
    I16                m_iChannel;  //current channel we are doing
    I16                m_iBand;     //current band we are doing
    Bool  m_fNoMoreData;

    Bool        m_fLastSubFrame;
    CWMAInputBitStream	m_ibstrm;

    //I don't think we need any of these now
    I16*        m_rgiRunEntry44ssQb;
    I16*        m_rgiLevelEntry44ssQb;
    I16*        m_rgiRunEntry44smQb;
    I16*        m_rgiLevelEntry44smQb;
    I16*        m_rgiRunEntry44ssOb;
    I16*        m_rgiLevelEntry44ssOb;
    I16*        m_rgiRunEntry44smOb;
    I16*        m_rgiLevelEntry44smOb;

    I16*        m_rgiRunEntry16ssOb;
    I16*        m_rgiLevelEntry16ssOb;
    I16*        m_rgiRunEntry16smOb;
    I16*        m_rgiLevelEntry16smOb;

#if 0
    UInt        m_rgiQuantStepFract[QUANTSTEP_DENOMINATOR - 1]; // Exclude numerator of 0
#endif	// !defined(SILSMOD)

#if defined(UNDER_CE) && defined(_ARM_)
    U32         lPrivate1;  // Used by ARMStub to keep track of ARM structures
    U32         lPrivate2;  // Used by ARMStub to keep track of current buffer pos
#endif

#ifdef ENABLE_EQUALIZER
#define MAX_NO_EQBAND 10
    Float       m_rgfltEqBandWeight[MAX_NO_EQBAND];
    U16         m_rgwEqBandBoundary[MAX_NO_EQBAND + 1];
    I8          m_cEqBand;
    Bool        m_fNoEq; 
    I8          m_rgbBandPower[MAX_NO_EQBAND];
    Bool        m_fComputeBandPower;
    Int         m_iEqFrameSize;
#endif // ENABLE_EQUALIZER

#if defined(SEEK_DECODE_TEST)
    tRandState *m_pSaveRandState;
#endif // SEEK_DECODE_TEST

    WMARESULT (*m_pfnDecodeSubFrame) (struct CAudioObjectDecoder* paudec, Int* piBitCnt);
    WMARESULT (*m_pfnDecodeCoefficient) (struct CAudioObjectDecoder* paudec, PerChannelInfo* ppcinfo, Int* piBitCnt);	

} CAudioObjectDecoder;

#ifdef __cplusplus
extern "C" {  // only need to export C interface if
              // used by C++ source code
#endif
//public:
CAudioObjectDecoder* audecNew(void *pMemBuf, const I32 iMemBufSize);
Void audecDelete (CAudioObjectDecoder* paudec);

WMARESULT audecInit (
    CAudioObjectDecoder* paudec, 
    Int iVersionNumber,
    Int cSubband, 
    Int iSamplingRate, 
    U16 cChannel, 
    Int cBytePerSec, 
    Int cbPacketLength,
    U16 wEncodeOpt,
    U16 wPlayerOpt,
    PFNGETMOREDATA pfnGetMoreData,
    U32 dwUserData,
    I32 *piMemBufUsed);
WMARESULT audecReset (CAudioObjectDecoder* paudec);
WMARESULT audecFlush (
    CAudioObjectDecoder* paudec, 
    U8   *pbDst, 
    Int   cbDstLength,
    Int*  pcbDstUsed,
    U8*   pbEqu,
    Int   cbEquLength,
    Int*  pcbEquUsed,
    U32*  pcSamplesFromBefore);

U32 audecOutputBufferSize(Int iVersion, Int iSamplingRate, Int cChannels, Int cBytePerSec, U16 wEncodeOpt);

//streaming decoding interface
WMARESULT audecDecodeInfo (CAudioObjectDecoder* paudec);
WMARESULT audecDecodeData (CAudioObjectDecoder* paudec, U16* pcSampleReady);
WMARESULT audecGetPCM (CAudioObjectDecoder* paudec, U16* pcSampleReady, U8* pbDst, U32 cbDstLength);

// This function is optionally implemented by the user, but if the user opts for
// non-streaming mode, we supply a standard implementation. Streaming-mode callers
// MUST supply their own version of this function.
WMARESULT prvWMAGetMoreData(U8 **ppBuffer, U32 *pcbBuffer,
                            U32 dwUserData);

//alternative decoding interface
WMARESULT audecDecode (CAudioObjectDecoder* paudec, 
                     const U8*   pbSrc,
                     Int         cbSrcLength,
                     Int*        pcbSrcUsed,
                     U8*         pbDst,
                     Int         cbDstLength,
                     Int*        pcbDstUsed,
                     U8*         pbEqu,
                     Int         cbEqu,
                     Int*        pcbEquUsed,
                     I32*        pcSamplesFromBefore);

#ifdef ENABLE_EQUALIZER        	
WMARESULT audecSetEqualizer (CAudioObjectDecoder* paudec, Int iBand, Int iGainIndB);
WMARESULT audecResetEqualizer (CAudioObjectDecoder* paudec);  
Void    audecStartComputeBandPower (CAudioObjectDecoder* paudec);
Void    audecStopComputeBandPower (CAudioObjectDecoder* paudec);
WMARESULT audecGetBandPower (CAudioObjectDecoder* paudec, I8* rgbBandPower);
#endif //ENABLE_EQUALIZER
#ifdef __cplusplus
}
#endif

//private:
WMARESULT prvDecodePacket (CAudioObjectDecoder* paudec,
                           const U8*    pbSrc,
                           Int          cbSrcLength,
                           Int*         pcbSrcUsed,
                           U8*          pbDst,
                           Int          cbDstLength,
                           Int*         pcbDstUsed,
                           U8*          pbEqu,
                           Int          cbEquLength,
                           Int*         pcbEquUsed,
                           I32*         pcSamplesPrevPacket);
WMARESULT prvDecodeFrame (CAudioObjectDecoder* paudec,
                        const U8*   pbSrc, 
                        Int         cbSrcLength, 
                        Int*        pcbSrcUsed, 
                        I16*        piDst, 
                        Int         cbDstLength,
                        Int*        pcbDstUsed,
                        U8*         pbEqu,
                        Int         cbEquLength,
                        Int*        pcbEquUsed);

WMARESULT prvDecodeSubFrame (CAudioObjectDecoder* paudec, Int* piBitCnt);
WMARESULT prvDecodeSubFrameHighRate (CAudioObjectDecoder* paudec, Int* piBitCnt);

WMARESULT prvDecodeFrameHeader (CAudioObjectDecoder* paudec, Int* piBitCnt);
Void    prvSetDetTable  (CAudioObjectDecoder* paudec,  PerChannelInfo* ppcinfo);
WMARESULT prvDecodeFrameHeaderLpc (CAudioObjectDecoder* paudec, Int* piBitCnt);
WMARESULT prvDecodeFrameHeaderNoiseSub (CAudioObjectDecoder* paudec, Int* piBitCnt);
WMARESULT prvGetNextRunDEC (Void* pvoid, PerChannelInfo* ppcinfo, Int *piBitCnt);

// Void    prvGetBandWeightMidRate (CAudioObjectDecoder* paudec);
Void    prvGetBandWeightLowRate (CAudioObjectDecoder* paudec);
WMARESULT prvUpdateSubFrameConfig (CAudioObjectDecoder* paudec, Int iSizeNext, Int iSizePrev, Int iSizeCurr);

WMARESULT prvDecodeCoefficientMono	
                (CAudioObjectDecoder* paudec, PerChannelInfo* ppcinfo, Int* piBitCnt);
WMARESULT prvDecodeCoefficientStereo 
                (CAudioObjectDecoder* paudec, PerChannelInfo* ppcinfo, Int* piBitCnt);
WMARESULT prvDecodeRunLevel  (CAudioObjectDecoder* paudec, PerChannelInfo* ppcinfo,
						      Int iCoefFirst, 
						      Int iCoefLim, 
                              Int* piBitCnt);

//equalize
Void    prvAdaptEqToSubFrame(CAudioObjectDecoder* paudec);
WMARESULT prvEqualize (CAudioObjectDecoder* paudec, PerChannelInfo* ppcinfo);
Void    prvComputeBandPower (CAudioObjectDecoder* paudec);

INLINE Int WMA_get_fNoMoreData(U32 hWMA)
{
    return ((CAudioObjectDecoder *)hWMA)->m_fNoMoreData;
}

INLINE Void WMA_set_fNoMoreData(U32 hWMA, Int iVal)
{
    ((CAudioObjectDecoder *)hWMA)->m_fNoMoreData = iVal;
}

INLINE U8 WMA_get_nHdrBits(U32 hWMA)
{
    const CAudioObject *pau = ((CAudioObjectDecoder *)hWMA)->pau;

    if (pau->m_fAllowSuperFrame)
        return (U8) (pau->m_cBitPackedFrameSize + NBITS_FRM_CNT + NBITS_PACKET_CNT + 3);
    else
        return 0;
}

#endif  //__MSAUDIODEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\postfilter_wmv.hpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       postfilter.hpp
//
//--------------------------------------------------------------------------

#ifndef __POSTFILTER_H__
#define __POSTFILTER_H__

#include "wmvdec_api.h"

#define DEBLOCKMB_ARGS      tWMVDecInternalMember *pWMVDec, \
                            PixelC __huge        *ppxliY,           \
                            PixelC __huge        *ppxliU,           \
                            PixelC __huge        *ppxliV,           \
                            Bool_WMV                  bDoLeft,          \
                            Bool_WMV                  bDoRightHalfEdge, \
                            Bool_WMV                  bDoTop,           \
                            Bool_WMV                  bDoBottomHalfEdge,\
                            Bool_WMV                  bDoMiddle,        \
                            I32_WMV                   iStepSize,        \
                            I32_WMV                   iWidthPrevY,      \
                            I32_WMV                   iWidthPrevUV

#define APPLYSMOOTHING_ARGS PixelC                *pixel,           \
                            I32_WMV                   width,            \
                            I32_WMV                   max_diff,         \
                            I32_WMV                   thr

#define DETERMINETHR_ARGS   PixelC                *ptr,             \
                            I32_WMV                   *thr,             \
                            I32_WMV                   *range,           \
                            I32_WMV                   width

#define DERINGMB_ARGS       PixelC __huge        *ppxlcY,           \
                            PixelC __huge        *ppxlcU,           \
                            PixelC __huge        *ppxlcV,           \
                            I32_WMV                  iStepSize,         \
                            I32_WMV                  iWidthPrevY,       \
                            I32_WMV                  iWidthPrevUV


extern Void_WMV (*g_pDeblockMB)(DEBLOCKMB_ARGS);
extern Void_WMV (*g_pApplySmoothing)(APPLYSMOOTHING_ARGS);
extern Void_WMV (*g_pDetermineThreshold)(DETERMINETHR_ARGS);
extern Void_WMV (*g_pDeringMB)(DERINGMB_ARGS);

Void_WMV DeblockMB(DEBLOCKMB_ARGS);
Void_WMV DeblockMB_MMX(DEBLOCKMB_ARGS);
Void_WMV DeblockMB_FASTEST_MMX(DEBLOCKMB_ARGS);
Void_WMV DeblockMB_KNI(DEBLOCKMB_ARGS);
Void_WMV DeringMB(DERINGMB_ARGS);
Void_WMV ApplySmoothing(APPLYSMOOTHING_ARGS);
Void_WMV ApplySmoothing_MMX(APPLYSMOOTHING_ARGS);
Void_WMV DetermineThreshold(DETERMINETHR_ARGS);
Void_WMV DetermineThreshold_MMX(DETERMINETHR_ARGS);
Void_WMV DetermineThreshold_KNI(DETERMINETHR_ARGS);
Void_WMV DetermineThreshold_MMX(U8_WMV *srcptr, I32_WMV *thr, I32_WMV *range, I32_WMV width);

Void_WMV g_InitPostFilter (Bool_WMV bFastDeblock);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\repeatpad_wmv.h ===
/*************************************************************************

Copyright (C) 1996 -- 1998  Microsoft Corporation

Module Name:

	repeatpad_wmv.h

Abstract:


Author:


Revision History:

*************************************************************************/

/////////// main external API's /////////////////

#define RepeatRef0YArgs 	PixelC* ppxlcRef0Y,     \
                        	CoordI  iStart,         \
                            CoordI  iEnd,           \
                        	I32_WMV     iOldLeftOffet,  \
                        	Bool_WMV    fTop,           \
                            Bool_WMV    fBottom,        \
                            I32_WMV     iWidthY,        \
                            I32_WMV     iWidthYPlusExp, \
                            I32_WMV     iWidthPrevY


#define RepeatRef0UVArgs	PixelC* ppxlcRef0U,     \
                        	PixelC* ppxlcRef0V,     \
   	                        CoordI  iStart,         \
                            CoordI  iEnd,           \
	                        I32_WMV     iOldLeftOffet,  \
	                        Bool_WMV    fTop,           \
                            Bool_WMV    fBottom,        \
                            I32_WMV     iWidthUV,       \
                            I32_WMV     iWidthUVPlusExp,\
                            I32_WMV     iWidthPrevUV


extern Void_WMV (*g_pRepeatRef0UV) (RepeatRef0UVArgs);
extern Void_WMV (*g_pRepeatRef0Y) (RepeatRef0YArgs);

///////////////////////////////////////////////////////

#ifndef OPT_REPEATPAD_ARM
Void_WMV g_RepeatRef0Y     (RepeatRef0YArgs);
Void_WMV g_RepeatRef0UV     (RepeatRef0UVArgs);
#else
extern "C" Void_WMV g_RepeatRef0Y     (RepeatRef0YArgs);
extern "C" Void_WMV g_RepeatRef0UV     (RepeatRef0UVArgs);
#endif
Void_WMV g_RepeatRef0Y_MMX (RepeatRef0YArgs);
Void_WMV g_RepeatRef0UV_MMX (RepeatRef0UVArgs);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\nspfft.h ===
/*M*
//
//               INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//        Copyright (c) 1996 Intel Corporation. All Rights Reserved.
//
//      $Workfile: nspfft.h $
//      $Revision: 3 $
//      $Modtime: Dec 16 1996 17:47:06  $
//
//  Purpose: NSP Fourier Transforms 
*M*/
#ifdef __cplusplus
extern "C" {
#endif
#if !defined (_NSPFFT_H) || defined (_OWN_BLDPCS)

    #define _NSPFFT_H

/* ======================================================================== */

    #if !defined (_OWN_BLDPCS)

        #define  NSP_Forw              1
        #define  NSP_Inv               2
        #define  NSP_Init              4
        #define  NSP_Free              8
        #define  NSP_NoScale          16
        #define  NSP_NoBitRev         32
        #define  NSP_InBitRev         64
        #define  NSP_OutBitRev       128
        #define  NSP_OutRCPack       256
        #define  NSP_OutRCPerm       512
        #define  NSP_InRCPack       1024
        #define  NSP_InRCPerm       4096
        #define  NSP_DoIntCore      8192
        #define  NSP_DoFloatCore   16384
        #define  NSP_DoFastMMX     32768

    #endif

/* ------------------------------------------------------------------------ */
/*                                                                          */
/*                                  Dft                                     */
/*                                                                          */
/* Compute the forward  or inverse discrete Fourier transform  (DFT)        */
/* of a complex signal.                                                     */
/*                                                                          */
/* ------------------------------------------------------------------------ */

    NSPAPI(void,nspvDft,(const WCplx *inSamps,  WCplx  *outSamps,
                         int    length,   int     flags,
                         int    scaleMode,int    *scaleFactor))
    NSPAPI(void,nspcDft,(const SCplx *inSamps,  SCplx *outSamps,
                         int    length,   int    flags))
    NSPAPI(void,nspzDft,(const DCplx *inSamps,  DCplx *outSamps,
                         int    length,   int    flags))

/* ------------------------------------------------------------------------ */
/*                                                                          */
/*                                  Fft                                     */
/*                                                                          */
/* Compute  the forward  or inverse   fast Fourier  transform (FFT)         */
/* of a complex signal.                                                     */
/*                                                                          */
/* ------------------------------------------------------------------------ */

    NSPAPI(void,nspvFft,(WCplx  *samps, int order, int flags,
                         int     scaleMode,        int *scaleFactor))

    NSPAPI(void,nspcFft,(SCplx  *samps, int order, int flags))
    NSPAPI(void,nspzFft,(DCplx  *samps, int order, int flags))


    NSPAPI(void,nspvFftNip,(const WCplx *inSamps,  WCplx  *outSamps,
                            int    order,    int     flags,
                            int    scaleMode,int   *scaleFactor))

    NSPAPI(void,nspcFftNip,(const SCplx *inSamps,  SCplx  *outSamps,
                            int    order,    int     flags))

    NSPAPI(void,nspzFftNip,(const DCplx *inSamps,  DCplx  *outSamps,
                            int    order,    int     flags))


    NSPAPI(void,nspvrFft,(short  *reSamps, short  *imSamps, int order, int flags,
                          int    scaleMode,int    *scaleFactor))

    NSPAPI(void,nspcrFft,(float  *reSamps, float  *imSamps, int order, int flags))

    NSPAPI(void,nspzrFft,(double *reSamps, double *imSamps, int order, int flags))


    NSPAPI(void,nspvrFftNip,(const short *reInSamps,  const short *imInSamps,
                             short *reOutSamps,       short *imOutSamps,
                             int    order,            int    flags,
                             int    scaleMode,        int   *scaleFactor))

    NSPAPI(void,nspcrFftNip,(const float  *reInSamps, const float  *imInSamps,
                             float  *reOutSamps,      float  *imOutSamps,
                             int     order,           int     flags))

    NSPAPI(void,nspzrFftNip,(const double *reInSamps, const double *imInSamps,
                             double *reOutSamps,      double *imOutSamps,
                             int     order,           int     flags))

/* ------------------------------------------------------------------------ */
/*                                                                          */
/*                         RealFftl, RealFftlNip                            */
/*                                                                          */
/* Compute the  forward or inverse FFT  of a real signal  using RCPack or   */
/* RCPerm format.                                                           */
/*                                                                          */
/* ------------------------------------------------------------------------ */

    NSPAPI(void,nspwRealFftl,(short  *samps, int order, int  flags,
                              int     scaleMode,        int *scaleFactor))

    NSPAPI(void,nspsRealFftl,(float  *samps, int order, int  flags))

    NSPAPI(void,nspdRealFftl,(double *samps, int order, int  flags))


    NSPAPI(void,nspwRealFftlNip,(const short  *inSamps,  short  *outSamps,
                                 int     order,    int     flags,
                                 int     scaleMode,int    *scaleFactor))

    NSPAPI(void,nspsRealFftlNip,(const float  *inSamps,  float  *outSamps,
                                 int     order,    int     flags))

    NSPAPI(void,nspdRealFftlNip,(const double *inSamps,  double *outSamps,
                                 int     order,    int     flags))

/* ------------------------------------------------------------------------ */
/*                                                                          */
/*                            CcsFftl, CcsFftlNip                           */
/*                                                                          */
/* Compute the  forward or inverse  FFT of a  complex conjugate-symmetric   */
/* (CCS) signal using RCPack or RCPerm format.                              */
/*                                                                          */
/* ------------------------------------------------------------------------ */

    NSPAPI(void,nspwCcsFftl,(short  *samps,    int  order, int flags,
                             int     scaleMode,int *scaleFactor))

    NSPAPI(void,nspsCcsFftl,(float  *samps,    int  order, int flags))

    NSPAPI(void,nspdCcsFftl,(double *samps,    int  order, int flags))


    NSPAPI(void,nspwCcsFftlNip,(const short *inSamps,  short  *outSamps,
                                int    order,    int     flags,
                                int    scaleMode,int    *scaleFactor))

    NSPAPI(void,nspsCcsFftlNip,(const float  *inSamps, float  *outSamps,
                                int     order,   int     flags))

    NSPAPI(void,nspdCcsFftlNip,(const double *inSamps, double *outSamps,
                                int     order,   int     flags))

/* ------------------------------------------------------------------------ */
/*                                                                          */
/*                       MpyRCPack2, MpyRCPack3                             */
/*                                                                          */
/* Multiply two vectors stored in RCPack format.                            */
/*                                                                          */
/* ------------------------------------------------------------------------ */

    NSPAPI(void,nspwMpyRCPack2,(const short *src,  short  *dst, int order,
                                int    scaleMode,         int *scaleFactor))

    NSPAPI(void,nspsMpyRCPack2,(const float  *src, float  *dst, int order))

    NSPAPI(void,nspdMpyRCPack2,(const double *src, double *dst, int order))


    NSPAPI(void,nspwMpyRCPack3,(const short  *srcA,const short  *srcB,short  *dst,
                                int     order,
                                int     scaleMode, int    *scaleFactor))

    NSPAPI(void,nspsMpyRCPack3,(const float  *srcA,const float  *srcB,float  *dst,
                                int     order))

    NSPAPI(void,nspdMpyRCPack3,(const double *srcA,const double *srcB,double *dst,
                                int     order))

/* ------------------------------------------------------------------------ */
/*                                                                          */
/*                        MpyRCPerm2, MpyRCPerm3                            */
/*                                                                          */
/* Multiply two vectors stored in RCPerm format.                            */
/*                                                                          */
/* ------------------------------------------------------------------------ */

    NSPAPI(void,nspwMpyRCPerm2,(const short  *src, short  *dst, int order,
                                int     scaleMode,        int *scaleFactor))

    NSPAPI(void,nspsMpyRCPerm2,(const float  *src, float  *dst, int order))

    NSPAPI(void,nspdMpyRCPerm2,(const double *src, double *dst, int order))


    NSPAPI(void,nspwMpyRCPerm3,(const short  *srcA,const short  *srcB,short  *dst,
                                int     order,
                                int     scaleMode, int    *scaleFactor))

    NSPAPI(void,nspsMpyRCPerm3,(const float  *srcA,const float  *srcB,float  *dst,
                                int     order))

    NSPAPI(void,nspdMpyRCPerm3,(const double *srcA,const double *srcB,double *dst,
                                int     order))
/* ------------------------------------------------------------------------ */
/*                                                                          */
/*                        RealFft,  RealFftNip                              */
/*                                                                          */
/* Compute the forward or inverse FFT of a real signal.                     */
/*                                                                          */
/* ------------------------------------------------------------------------ */

    NSPAPI(void,nspwRealFft,(short  *samps, int order,  int  flags,
                             int     scaleMode,         int *scaleFactor))

    NSPAPI(void,nspsRealFft,(float  *samps, int order,  int  flags))
    NSPAPI(void,nspdRealFft,(double *samps, int order,  int  flags))


    NSPAPI(void,nspwRealFftNip,(const short  *inSamps,  WCplx *outSamps,
                                int     order,    int    flags,
                                int     scaleMode,int   *scaleFactor))

    NSPAPI(void,nspsRealFftNip,(const float  *inSamps,  SCplx *outSamps,
                                int     order,    int    flags))

    NSPAPI(void,nspdRealFftNip,(const double *inSamps,  DCplx *outSamps,
                                int     order,    int    flags))

/* ------------------------------------------------------------------------ */
/*                                                                          */
/*                            CcsFft, CcsFftNip                             */
/*                                                                          */
/* Compute the  forward or inverse  FFT of a  complex conjugate-symmetric   */
/* (CCS) signal.                                                            */
/*                                                                          */
/* ------------------------------------------------------------------------ */

    NSPAPI(void,nspwCcsFft,(short  *samps, int order, int flags,
                            int     scaleMode,        int *scaleFactor))

    NSPAPI(void,nspsCcsFft,(float  *samps, int order, int flags))
    NSPAPI(void,nspdCcsFft,(double *samps, int order, int flags))


    NSPAPI(void,nspwCcsFftNip,(const WCplx *inSamps,  short *outSamps,
                               int    order,    int    flags,
                               int    scaleMode,int   *scaleFactor))

    NSPAPI(void,nspsCcsFftNip,(const SCplx *inSamps, float  *outSamps,
                               int    order,   int     flags))

    NSPAPI(void,nspdCcsFftNip,(const DCplx *inSamps, double *outSamps,
                               int    order,   int     flags))

/* ------------------------------------------------------------------------ */
/*                                                                          */
/*                    nsp?Real2Fft, nsp?Real2FftNip                         */
/*                                                                          */
/* Compute the forward or inverse FFT of two real signals.                  */
/*                                                                          */
/* ------------------------------------------------------------------------ */

    NSPAPI(void,nspwReal2Fft,(short *xSamps, short *ySamps, int order, int flags,
                              int scaleMode, int *scaleFactor))

    NSPAPI(void,nspsReal2Fft,(float *xSamps, float *ySamps, int order, int flags))

    NSPAPI(void,nspdReal2Fft,(double *xSamps, double *ySamps, int order, int flags))


    NSPAPI(void,nspwReal2FftNip,(const short *xInSamps, WCplx  *xOutSamps,
                                 const short *yInSamps, WCplx  *yOutSamps,
                                 int order, int flags,
                                 int scaleMode, int *scaleFactor))

    NSPAPI(void,nspsReal2FftNip,(const float *xInSamps, SCplx  *xOutSamps,
                                 const float *yInSamps, SCplx  *yOutSamps,
                                 int order, int flags))

    NSPAPI(void,nspdReal2FftNip,(const double *xInSamps, DCplx *xOutSamps,
                                 const double *yInSamps, DCplx *yOutSamps,
                                 int order, int flags))

/* ------------------------------------------------------------------------ */
/*                                                                          */
/*                    nsp?Ccs2Fft, nsp?Ccs2FftNip                           */
/*                                                                          */
/* Compute the forward or reverse  FFT of two complex conjugate-symmetric   */
/* (CCS) signals.                                                           */
/*                                                                          */
/* ------------------------------------------------------------------------ */

    NSPAPI(void,nspwCcs2Fft,(short  *xSamps, short  *ySamps, int order,int flags,
                             int     scaleMode, int *scaleFactor))

    NSPAPI(void,nspsCcs2Fft,(float  *xSamps, float  *ySamps, int order,int flags))

    NSPAPI(void,nspdCcs2Fft,(double *xSamps, double *ySamps, int order,int flags))


    NSPAPI(void,nspwCcs2FftNip,(const WCplx *xInSamps, short  *xOutSamps,
                                const WCplx *yInSamps, short  *yOutSamps,
                                int order, int flags,
                                int scaleMode, int *scaleFactor))

    NSPAPI(void,nspsCcs2FftNip,(const SCplx *xInSamps, float  *xOutSamps,
                                const SCplx *yInSamps, float  *yOutSamps,
                                int order, int flags))

    NSPAPI(void,nspdCcs2FftNip,(const DCplx *xInSamps, double *xOutSamps,
                                const DCplx *yInSamps, double *yOutSamps,
                                int order, int flags))

/* ======================================================================== */

#endif                                                         /* _NSPFFT_H */
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\opcodes.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

	opcodes.h
         
Abstract:

    Header for unsupported assembly instructions.

Author:

	Marc Holder (marchold@microsoft.com) 16-July-1998

Revision History:

*************************************************************************/
#ifndef _USE_INTEL_COMPILER

//Conditional move opcode macros
#define cmoves  _asm _emit 0x0F  _asm _emit 0x48
#define cmovz   _asm _emit 0x0F  _asm _emit 0x44
#define cmove   _asm _emit 0x0F  _asm _emit 0x44
#define cmovne  _asm _emit 0x0F  _asm _emit 0x45
#define cmovnz  _asm _emit 0x0F  _asm _emit 0x45
#define cmovge  _asm _emit 0x0F  _asm _emit 0x4D
#define cmovg   _asm _emit 0x0F  _asm _emit 0x4F

//Registers encoding opcode macros
#define edx_edi _asm _emit 0xD7
#define edx_eax _asm _emit 0xD0
#define ebx_eax _asm _emit 0xD8
#define edi_eax _asm _emit 0xF8
#define esi_eax _asm _emit 0xF0
#define eax_edi _asm _emit 0xC7
#define eax_edx _asm _emit 0xC2



//Katmai new instructions opcodes
#define pavgb       _asm _emit 0x0F _asm _emit 0xE0  //packed byte avarage, takes 2 mmx registers  
#define psadbw      _asm _emit 0x0F _asm _emit 0xF6  //packed byte to word sun absolute diffrences, takes 2 mmx registers
#define pshufw      _asm _emit 0x0F _asm _emit 0x70  //pshufw takes 2 mmx registers and 1 byte which must be emited  
#define pmulhuw     _asm _emit 0x0F _asm _emit 0xE4  //pmulhuw packed unsigned multiply keep high words takes 2 mmx registers
#define pinsrw      _asm _emit 0x0F _asm _emit 0xC4
#define pmovmskb    _asm _emit 0x0F _asm _emit 0xD7  
#define pminub      _asm _emit 0x0F _asm _emit 0xDA
#define pmaxub      _asm _emit 0x0F _asm _emit 0xDE
#define pminsw      _asm _emit 0x0F _asm _emit 0xEA
#define pextrw      _asm _emit 0x0F _asm _emit 0xC5
#define pshufw      _asm _emit 0x0F _asm _emit 0x70
#define prefetchnta _asm _emit 0x0F _asm _emit 0x18 _asm _emit 0x44
#define prefetcht0  _asm _emit 0x0F _asm _emit 0x18 _asm _emit 0x4C
#define prefetcht1  _asm _emit 0x0F _asm _emit 0x18 _asm _emit 0x54
#define prefetcht2  _asm _emit 0x0F _asm _emit 0x18 _asm _emit 0x5C

//Katmai SIMD FP instruction opcodes
#define movaps  _asm _emit 0x0F _asm _emit 0x28  //128 bit aligned move

//defines opcodes for mm?,[esi+offset],imm to use with pinsrw
#define mm0_esi(offset,imm) _asm _emit 0x46 _asm _emit offset _asm _emit imm
#define mm1_esi(offset,imm) _asm _emit 0x4E _asm _emit offset _asm _emit imm
#define mm2_esi(offset,imm) _asm _emit 0x56 _asm _emit offset _asm _emit imm

//For mmx,eax,offset to use with pinsrw
#define mm0_eax_(offset) _asm _emit 0xC0 _asm _emit offset
#define mm1_eax_(offset) _asm _emit 0xC8 _asm _emit offset
#define mm2_eax_(offset) _asm _emit 0xD0 _asm _emit offset
#define mm3_eax_(offset) _asm _emit 0xD8 _asm _emit offset
#define mm4_eax_(offset) _asm _emit 0xE0 _asm _emit offset
#define mm5_eax_(offset) _asm _emit 0xE8 _asm _emit offset
#define mm6_eax_(offset) _asm _emit 0xF0 _asm _emit offset
#define mm7_eax_(offset) _asm _emit 0xF8 _asm _emit offset

//For mmx,ebx,offset to use with pinsrw
#define mm0_ebx_(offset) _asm _emit 0xC3 _asm _emit offset
#define mm1_ebx_(offset) _asm _emit 0xCB _asm _emit offset
#define mm2_ebx_(offset) _asm _emit 0xD3 _asm _emit offset
#define mm3_ebx_(offset) _asm _emit 0xDB _asm _emit offset
#define mm4_ebx_(offset) _asm _emit 0xE3 _asm _emit offset
#define mm5_ebx_(offset) _asm _emit 0xEB _asm _emit offset
#define mm6_ebx_(offset) _asm _emit 0xF3 _asm _emit offset
#define mm7_ebx_(offset) _asm _emit 0xFB _asm _emit offset

//For mmx,ecx,offset to use with pinsrw
#define mm0_ecx_(offset) _asm _emit 0xC1 _asm _emit offset
#define mm1_ecx_(offset) _asm _emit 0xC9 _asm _emit offset
#define mm2_ecx_(offset) _asm _emit 0xD1 _asm _emit offset
#define mm3_ecx_(offset) _asm _emit 0xD9 _asm _emit offset
#define mm4_ecx_(offset) _asm _emit 0xE1 _asm _emit offset
#define mm5_ecx_(offset) _asm _emit 0xE9 _asm _emit offset
#define mm6_ecx_(offset) _asm _emit 0xF1 _asm _emit offset
#define mm7_ecx_(offset) _asm _emit 0xF9 _asm _emit offset

//For eax,mmx,offset for use with pextrw
#define eax_mm0_(offset) _asm _emit 0xC0 _asm _emit offset
#define eax_mm1_(offset) _asm _emit 0xC1 _asm _emit offset
#define eax_mm2_(offset) _asm _emit 0xC2 _asm _emit offset
#define eax_mm3_(offset) _asm _emit 0xC3 _asm _emit offset
#define eax_mm4_(offset) _asm _emit 0xC4 _asm _emit offset
#define eax_mm5_(offset) _asm _emit 0xC5 _asm _emit offset
#define eax_mm6_(offset) _asm _emit 0xC6 _asm _emit offset
#define eax_mm7_(offset) _asm _emit 0xC7 _asm _emit offset

//For ebx,mmx,offset for use with pextrw
#define ebx_mm0_(offset) _asm _emit 0xD8 _asm _emit offset
#define ebx_mm1_(offset) _asm _emit 0xD9 _asm _emit offset
#define ebx_mm2_(offset) _asm _emit 0xDA _asm _emit offset
#define ebx_mm3_(offset) _asm _emit 0xDB _asm _emit offset
#define ebx_mm4_(offset) _asm _emit 0xDC _asm _emit offset
#define ebx_mm5_(offset) _asm _emit 0xDD _asm _emit offset
#define ebx_mm6_(offset) _asm _emit 0xDE _asm _emit offset
#define ebx_mm7_(offset) _asm _emit 0xDF _asm _emit offset

//For ecx,mmx,offset for use with pextrw
#define ecx_mm0_(offset) _asm _emit 0xC8 _asm _emit offset
#define ecx_mm1_(offset) _asm _emit 0xC9 _asm _emit offset
#define ecx_mm2_(offset) _asm _emit 0xCA _asm _emit offset
#define ecx_mm3_(offset) _asm _emit 0xCB _asm _emit offset
#define ecx_mm4_(offset) _asm _emit 0xCC _asm _emit offset
#define ecx_mm5_(offset) _asm _emit 0xCD _asm _emit offset
#define ecx_mm6_(offset) _asm _emit 0xCE _asm _emit offset
#define ecx_mm7_(offset) _asm _emit 0xCF _asm _emit offset

//For edx,mmx,offset for use with pextrw
#define edx_mm0_(offset) _asm _emit 0xD0 _asm _emit offset
#define edx_mm1_(offset) _asm _emit 0xD1 _asm _emit offset
#define edx_mm2_(offset) _asm _emit 0xD2 _asm _emit offset
#define edx_mm3_(offset) _asm _emit 0xD3 _asm _emit offset
#define edx_mm4_(offset) _asm _emit 0xD4 _asm _emit offset
#define edx_mm5_(offset) _asm _emit 0xD5 _asm _emit offset
#define edx_mm6_(offset) _asm _emit 0xD6 _asm _emit offset
#define edx_mm7_(offset) _asm _emit 0xD7 _asm _emit offset

//For mmx,[edi]
#define mm0_edi _asm _emit 0x07
#define mm1_edi _asm _emit 0x0F
#define mm2_edi _asm _emit 0x17
#define mm3_edi _asm _emit 0x1F
#define mm4_edi _asm _emit 0x27
#define mm6_edi _asm _emit 0x37 
#define mm7_edi _asm _emit 0x3F

//For mmx,[esi+edx+offset]
#define mm1_esi_edx_(offset) _asm emit 0x4C _asm _emit 0x16 _asm _emit offset 
#define mm7_esi_edx_(offset) _asm emit 0x7C _asm _emit 0x16 _asm _emit offset 

//For mmx,[esi+offset]
#define mm1_esi_(offset)    _asm _emit 0x4E _asm _emit offset

//For mmx,[edi+offset]
#define mm5_edi_(offset)    _asm _emit 0x6F _asm _emit offset
#define mm6_edi_(offset)    _asm _emit 0x77 _asm _emit offset
#define mm7_edi_(offset)    _asm _emit 0x7F _asm _emit offset

//for cmov
#define eax_ebx             _asm _emit 0xC3
#define ecx_ebx             _asm _emit 0xCB
#define edx_ebx             _asm _emit 0xD3

//for eax,mm4
#define eax_mm4             _asm _emit 0xC4
#define eax_mm7             _asm _emit 0xC7

// for prefetch
#define esi_eax_(scale,offset)  _asm _emit 0x6|scale<<6 _asm _emit offset

//MMX redister encoding opcode macros
#define mm0_mm0 _asm _emit 0xC0
#define mm0_mm1 _asm _emit 0xC1
#define mm0_mm2 _asm _emit 0xC2
#define mm0_mm3 _asm _emit 0xC3
#define mm0_mm4 _asm _emit 0xC4
#define mm0_mm5 _asm _emit 0xC5
#define mm0_mm6 _asm _emit 0xC6
#define mm0_mm7 _asm _emit 0xC7
#define mm1_mm0 _asm _emit 0xC8
#define mm1_mm1 _asm _emit 0xC9
#define mm1_mm2 _asm _emit 0xCA
#define mm1_mm3 _asm _emit 0xCB
#define mm1_mm4 _asm _emit 0xCC
#define mm1_mm5 _asm _emit 0xCD
#define mm1_mm6 _asm _emit 0xCE
#define mm1_mm7 _asm _emit 0xCF
#define mm2_mm0 _asm _emit 0xD0
#define mm2_mm1 _asm _emit 0xD1
#define mm2_mm2 _asm _emit 0xD2
#define mm2_mm3 _asm _emit 0xD3
#define mm2_mm4 _asm _emit 0xD4
#define mm2_mm5 _asm _emit 0xD5
#define mm2_mm6 _asm _emit 0xD6
#define mm2_mm7 _asm _emit 0xD7
#define mm3_mm0 _asm _emit 0xD8
#define mm3_mm1 _asm _emit 0xD9
#define mm3_mm2 _asm _emit 0xDA
#define mm3_mm3 _asm _emit 0xDB
#define mm3_mm4 _asm _emit 0xDC
#define mm3_mm5 _asm _emit 0xDD
#define mm3_mm7 _asm _emit 0xDF
#define mm4_mm0 _asm _emit 0xE0
#define mm4_mm1 _asm _emit 0xE1
#define mm4_mm2 _asm _emit 0xE2
#define mm4_mm5 _asm _emit 0xE5
#define mm4_mm6 _asm _emit 0xE6
#define mm4_mm7 _asm _emit 0xE7
#define mm5_mm0 _asm _emit 0xE8
#define mm5_mm1 _asm _emit 0xE9
#define mm5_mm2 _asm _emit 0xEA
#define mm5_mm3 _asm _emit 0xEB
#define mm5_mm4 _asm _emit 0xEC
#define mm5_mm5 _asm _emit 0xED
#define mm5_mm6 _asm _emit 0xEE
#define mm5_mm7 _asm _emit 0xEF
#define mm6_mm0 _asm _emit 0xF0
#define mm6_mm1 _asm _emit 0xF1
#define mm6_mm2 _asm _emit 0xF2
#define mm6_mm3 _asm _emit 0xF3
#define mm6_mm4 _asm _emit 0xF4
#define mm6_mm5 _asm _emit 0xF5
#define mm6_mm6 _asm _emit 0xF6
#define mm6_mm7 _asm _emit 0xF7
#define mm7_mm0 _asm _emit 0xF8
#define mm7_mm1 _asm _emit 0xF9
#define mm7_mm2 _asm _emit 0xFA
#define mm7_mm3 _asm _emit 0xFB
#define mm7_mm4 _asm _emit 0xFC
#define mm7_mm5 _asm _emit 0xFD
#define mm7_mm6 _asm _emit 0xFE
#define mm7_mm7 _asm _emit 0xFF

#define emit _asm _emit

#define CPU_ID _asm _emit 0x0f _asm _emit 0xa2
#define RDTSC  _asm _emit 0x0f _asm _emit 0x31

#else

//Conditional move opcode macros
#define cmoves  cmoves
#define cmovz   cmovz
#define cmove   cmove
#define cmovne  cmovne
#define cmovnz  cmovnz
#define cmovge  cmovge
#define cmovg   cmovg

//Registers encoding opcode macros
#define edx_edi edx,edi
#define edx_eax edx,eax
#define ebx_eax ebx,eax
#define edi_eax edi,eax
#define esi_eax esi,eax
#define eax_edi eax,edi
#define eax_edx eax,edx

//Katmai new instructions opcodes
#define pavgb  pavgb
#define psadbw psadbw
#define pshufw pshufw

//MMX redister encoding opcode macros
#define mm0_mm1 mm0,mm1
#define mm0_mm7 mm0,mm7
#define mm0_mm3 mm0,mm3
#define mm1_mm2 mm1,mm2
#define mm1_mm7 mm1,mm7
#define mm2_mm3 mm2,mm3
#define mm2_mm7 mm2,mm7
#define mm3_mm2 mm3,mm2
#define mm3_mm4 mm3,mm4
#define mm3_mm7 mm3,mm7
#define mm4_mm2 mm4,mm2
#define mm4_mm5 mm4,mm5
#define mm4_mm7 mm4,mm7
#define mm5_mm6 mm5,mm6
#define mm5_mm7 mm5,mm7
#define mm6_mm7 mm6,mm7
#define mm7_mm0 mm7,mm0
#define mm7_mm1 mm7,mm1


#define emit ,

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\spatialpredictor_wmv.hpp ===
/*************************************************************************

Copyright (c) 1996 -- 2000  Microsoft Corporation

Module Name:

	spatialPredictor.hpp

Abstract:

	Include file for spatial prediction

Revision History:

    Sridhar Srinivasan: 7/20/00

*************************************************************************/

typedef struct t_SpatialPredictor {
    const  U8_WMV   *m_pClampTable;

#ifdef _XBOX
    static const Bool_WMV m_bIsMMX = TRUE;
#else
    static Bool_WMV m_bIsMMX;
#endif

    const PixelC    *m_pRef;
    I32_WMV         m_iRefStride;
    Bool_WMV        m_bFlat;
    I32_WMV         m_iDcValue;
    PixelC          *m_pLeft, *m_pTop;
    PixelC          *m_pNeighbors;
    Bool_WMV        m_bInitZeroPredictor;
    U16_WMV         *m_pSums;
    U16_WMV         *m_pLeftSum;
    U16_WMV         *m_pTopSum;
    I16_WMV         *m_pBuffer16; // buffer for setupZeroPredictor speedup
} t_CSpatialPredictor;

t_SpatialPredictor *t_SpatialPredictorConstruct ();
Void_WMV    t_SpatialPredictorDestruct (t_SpatialPredictor *pSp);
Void_WMV    predictDec (t_SpatialPredictor *pSp, const I32_WMV iOrient,
                 PixelC *pRef, const I32_WMV iRefStride, PixelI *pDelta,
                 Bool_WMV bClear);
Void_WMV    predict_0 (t_SpatialPredictor *pSp, const I32_WMV iOrient,
                 PixelC *pRef, const I32_WMV iRefStride);

#ifdef _WMV_TARGET_X86_ //_M_IX86
Void_WMV    predictDec_MMX (t_SpatialPredictor *pSp, const I32_WMV iOrient,
                 PixelC *pRef, const I32_WMV iRefStride, PixelI *pDelta,
                 Bool_WMV bClear);
Void_WMV    predict_0_MMX (U16_WMV *pTSum, U16_WMV *pLSum, U16_WMV *pWts,
                        PixelC *pRef, I32_WMV iRefStride);
Void_WMV    SetupZeroPredictor_MMX (t_SpatialPredictor *pSp);
Void_WMV    GetRange (U8_WMV *pTop, U8_WMV *pLeft, I32_WMV &iRange,
                      I32_WMV &iDC);
#endif // _M_IX86

/****************************************************************
  Class CContext: local store of contextual information
  Used by encoder and decoder for consistent context generation
****************************************************************/

typedef struct t_ContextWMV {
    I32_WMV m_iRow;
    I32_WMV m_iCol;
    I32_WMV m_iColGt2;
    U8_WMV *m_pData; // one copy enough?
} t_CContextWMV;

t_ContextWMV *t_ContextWMVConstruct (I32_WMV iCol, I32_WMV iRow);
Void_WMV    t_ContextWMVDestruct (t_ContextWMV *pContext);
Void_WMV    t_ContextGetDec (t_ContextWMV *pContext, I32_WMV iX, I32_WMV iY,
              I32_WMV iStepSize, I32_WMV *iPredOrient, I32_WMV *iEstRun);
Void_WMV    t_ContextPutDec (t_ContextWMV *pContext, I32_WMV iX, I32_WMV iY,
                             I32_WMV iOrientContext, I32_WMV iRunContext);
I32_WMV     t_ContextGetChromaDec (t_ContextWMV *pContext, I32_WMV blockX,
                                   I32_WMV blockY);// chroma context
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\strmdecdbg.hpp ===
/*************************************************************************

Copyright (C) 2001  Microsoft Corporation

Module Name:

    strmdecdbg.hpp

Abstract:

    Decoder BitStream Debugging & Performancer Analysis

Author:

    Sil Sanders (sils@microsoft.com) 14-Feb-2001

Revision History:

*************************************************************************/

#ifndef __STRMDECDBG_HPP_
#define __STRMDECDBG_HPP_

// #define OPT_HUFFMAN_DBGDMP
// #define OPT_HUFFMAN_GET

#ifdef __STREAMING_MODE_DECODE_
//#undef OPT_HUFFMAN_GET
#endif

#ifndef UNDER_CE
    // The follow defines help model CE behavior on the desktop x86
    // define HUFFMANGET_DEBUG_DUMP to get info about each huffman decode
    // warning the resulting file can be large.  e.g. 30 seconds cif => 50MB.
    //#   define HUFFMANGET_DEBUG_DUMP

    // define HUFFMANGET_DEBUG_DUMP_CACHE to dump info about each table reference in each huffman decode
    // warning the resulting file can be large.  e.g. 30 seconds cif => 50MB.
    //#   define HUFFMANGET_DEBUG_DUMP_CACHE

    // define HUFFMANGET_DEBUG_CACHE to dump frame-by-frame summary info about cache accessed based on the cache model below.
    //#   define HUFFMANGET_DEBUG_CACHE
#endif

#ifdef HUFFMANGET_DEBUG_CACHE
    // Select a cache model
#   if 1    // 8k suitable for ARM Intel SA1100 and SA1110
#       define DBG_DCACHE_LINE_SIZE 32
#       define DBG_DCACHE_WAYS 32
#       define DBG_DCACHE_WAYLINES 8
#       define DBG_CACHE_CONFLICT 64
#       define DBG_DPAGTBL_WAYS 32
#       define DBG_DPAGTBL_WAYENTRIES 1
#       define DBG_DPAGTBL_CONFLICTS 0
#   elif 1  // 16k suitable for SH3-7709a (HP540)
            // This is an I/D cache- either reduce # ways below 4 to reflect instruction use or raise conflict
#       define DBG_DCACHE_LINE_SIZE 16
#       define DBG_DCACHE_WAYS 2        // 4 -> 2 pretend other half used by instructions :O(...
#       define DBG_DCACHE_WAYLINES 256
#       define DBG_CACHE_CONFLICT 0
#       define DBG_DPAGTBL_WAYS 4
#       define DBG_DPAGTBL_WAYENTRIES 32
#       define DBG_DPAGTBL_CONFLICTS 0
#   elif 1  // 16k one-way data cache on the SH4 
#       define DBG_DCACHE_LINE_SIZE 32
#       define DBG_DCACHE_WAYS 1
#       define DBG_DCACHE_WAYLINES 512
#       define DBG_CACHE_CONFLICT 0
#       define DBG_DPAGTBL_WAYS 64
#       define DBG_DPAGTBL_WAYENTRIES 1
#       define DBG_DPAGTBL_CONFLICTS 0
#   elif 1  // 16k one-way data cache on the MIPS VR4122 (Casio E-125).  
            // The Vr4121 (E-115) is 8k (16 x 1 x 512)
#       define DBG_DCACHE_LINE_SIZE 16
#       define DBG_DCACHE_WAYS 1
#       define DBG_DCACHE_WAYLINES 1024
#       define DBG_CACHE_CONFLICT 3
#       define DBG_DPAGTBL_WAYS 32
#       define DBG_DPAGTBL_WAYENTRIES 1
#       define DBG_DPAGTBL_CONFLICTS 0
#   else   // 32k two-way data cache on the MIPS VR5432 (confirm params)
#       define DBG_DCACHE_LINE_SIZE 32
#       define DBG_DCACHE_WAYS 2
#       define DBG_DCACHE_WAYLINES 512
#       define DBG_CACHE_CONFLICT 3
#       define DBG_DPAGTBL_WAY 48
#       define DBG_DPAGTBL_WAYENTRIES 1
#       define DBG_DPAGTBL_CONFLICTS 0
#   endif
#       define DBG_DPAGTBL_PAGESIZE 4096
#endif // HUFFMANGET_DEBUG_CACHE

#ifdef OPT_HUFFMAN_DBGDMP
    // be careful about the size file you decode with this option - unprotected overflow.
    extern U32 opt_huffman_dbgdmp[0x20000];
    extern int opt_huffman_dbgdmp_idx;
#   define HUFFMANGET_DBG_DMP(x,t,i,c) opt_huffman_dbgdmp[opt_huffman_dbgdmp_idx++]=(x)
#   define HUFFMANGET_DBG_GLOBALS
#   define HUFFMANGET_DBG_CACHE(t,i,c)
#   define HUFFMANGET_DBG_STATUS(a,b,c)
#   define HUFFMANGET_DBG_HEADER(a,b)
#   define HUFFMANGET_DEBUG_ONLY(x)
#elif defined(HUFFMANGET_DEBUG_CACHE)
    // Model a RISC cache system
    extern FILE* fpHuffmanDump;
    extern int giDbgDCacheWays[DBG_DCACHE_WAYS*DBG_DCACHE_WAYLINES];
    extern int giDbgDCacheHits, giDbgDCacheMisses, giDbgDCacheFills, giDbgFillWay, giDbgIdx, giDbgLineAdr, giDbgModAdr;
    extern char gszDbgHeader[];
#   define HUFFMANGET_DBG_GLOBALS                                   \
    int giDbgDCacheWays[DBG_DCACHE_WAYS*DBG_DCACHE_WAYLINES] = {0}; \
    int giDbgDCacheHits = 0;                                        \
    int giDbgDCacheMisses = 0;                                      \
    int giDbgDCacheFills = 0;                                       \
    int giDbgFillWay = 0;                                           \
    int giDbgIdx, giDbgLineAdr, giDbgModAdr;                        \
    char gszDbgHeader[30] = {0};
#   define HUFFMANGET_DBG_DMP(x,t,i,c)
#   define HUFFMANGET_DBG_CACHE(t,i,c)                                                          \
        giDbgLineAdr = (int(t)+i*c)/DBG_DCACHE_LINE_SIZE;                                       \
        giDbgModAdr  = giDbgLineAdr%DBG_DCACHE_WAYLINES;                                        \
        for( giDbgIdx = 0; giDbgIdx < DBG_DCACHE_WAYS; giDbgIdx++ ) {                           \
            if (giDbgDCacheWays[giDbgIdx*DBG_DCACHE_WAYLINES+giDbgModAdr] == giDbgLineAdr)      \
                break;                                                                          \
        }                                                                                       \
        if (giDbgIdx < DBG_DCACHE_WAYS)                                                         \
            giDbgDCacheHits++;                                                                  \
        else {                                                                                  \
            giDbgDCacheMisses++;                                                                \
            if ( (++giDbgFillWay) >= DBG_DCACHE_WAYS )                                          \
                giDbgFillWay = 0;                                                               \
            if ( giDbgDCacheWays[giDbgFillWay*DBG_DCACHE_WAYLINES+giDbgModAdr]==0 )             \
                giDbgDCacheFills++;                                                             \
            assert( giDbgDCacheFills <= (DBG_DCACHE_WAYS*DBG_DCACHE_WAYLINES)  );               \
            giDbgDCacheWays[giDbgFillWay*DBG_DCACHE_WAYLINES+giDbgModAdr] = giDbgLineAdr;       \
        }                                                                                       \
        /* model others using the cache */                                                      \
        for( giDbgIdx = 0; giDbgIdx < DBG_CACHE_CONFLICT; giDbgIdx++ ) {                        \
            giDbgLineAdr = rand()%(DBG_DCACHE_WAYS*DBG_DCACHE_WAYLINES);                        \
            if ( giDbgDCacheWays[giDbgLineAdr] != 0 )                                           \
                giDbgDCacheWays[giDbgLineAdr] = -1;                                             \
        }
#   define HUFFMANGET_DBG_STATUS(a,b,c)
#   define HUFFMANGET_DBG_HEADER(s,t)                                                   \
        if (fpHuffmanDump!=NULL) {                                                      \
            if ( (giDbgDCacheHits+giDbgDCacheMisses+giDbgDCacheFills)!=0 )              \
                fprintf(fpHuffmanDump,"%s# %d %d %d\n",                                 \
                    gszDbgHeader,giDbgDCacheHits,giDbgDCacheMisses,giDbgDCacheFills );  \
            strncpy( gszDbgHeader, s, 29 );                                             \
        }                                                                               \
        memset(giDbgDCacheWays,0,DBG_DCACHE_WAYS*DBG_DCACHE_WAYLINES*sizeof(int));      \
        giDbgDCacheHits = giDbgDCacheMisses = giDbgDCacheFills = 0;
#   define HUFFMANGET_DEBUG_ONLY(x) x
#   define HUFFMANGET_DEBUG
#elif defined(HUFFMANGET_DEBUG_DUMP) || defined(HUFFMANGET_DEBUG_DUMP_CACHE)
    // usage:
    // to get a list of gets per table, use:
    //   _sort -k 1,8 HuffmanGet.txt | uniq -c -w 8
    // where column 1 is the count and column 2 is the table address
    // to get a list of the tables and indexes used:
    //   _sort -k 1,8 -u HuffmanGet.txt 
    // where column 1 is the table, column 2 is the index and column 3 is the value returned.
	// to get a list of tables and their sizes
	//   _grep -i -e "  " -e "_x8" HuffmanGet.txt
    extern FILE* fpHuffmanDump;
#   define HUFFMANGET_DBG_GLOBALS
#   if defined(HUFFMANGET_DEBUG_DUMP)
#     define HUFFMANGET_DBG_DMP(x,t,i,c) if (fpHuffmanDump!=NULL) { fprintf(fpHuffmanDump,"%08x_ %d %d %d\r\n",((int)t),(i),(x),(c)); }
#   else
#     define HUFFMANGET_DBG_DMP(x,t,i,c)
#   endif
#   if defined(HUFFMANGET_DEBUG_DUMP_CACHE)
#     define HUFFMANGET_DBG_CACHE(t,i,c) if (fpHuffmanDump!=NULL) { fprintf(fpHuffmanDump,"%08x~ %d %d\r\n",((int)t),(i),(c)); }
#   else
#     define HUFFMANGET_DBG_CACHE(t,i,c)
#   endif
#   define HUFFMANGET_DBG_STATUS(a,b,c)  if (fpHuffmanDump!=NULL) { fprintf(fpHuffmanDump,"%08x  %d %x\r\n",((int)a),(b),(c)); }
#   define HUFFMANGET_DBG_HEADER(s,t)    if (fpHuffmanDump!=NULL) { fprintf(fpHuffmanDump,"%s\r\n",(s) ); }
#   define HUFFMANGET_DEBUG_ONLY(x) x
#   define HUFFMANGET_DEBUG
#else
#   define HUFFMANGET_DBG_DMP(x,t,i,c)
#   define HUFFMANGET_DBG_GLOBALS
#   define HUFFMANGET_DBG_CACHE(t,i,c)
#   define HUFFMANGET_DBG_STATUS(a,b,c)
#   if defined(PROFILE) && defined(PROFILE_FRAMES)
        extern void TypeFrameProfile( int iType );
#       define HUFFMANGET_DBG_HEADER(a,t) TypeFrameProfile(t);
#   elif defined(PROFILE_FRAMES)
#       define HUFFMANGET_DBG_HEADER(a,t) printf("%s\r\n",a);
#   else
#       define HUFFMANGET_DBG_HEADER(a,t)
#   endif
#   define HUFFMANGET_DEBUG_ONLY(x)
#endif

#ifndef DEBUG_ONLY
#   if defined(DEBUG) || defined(_DEBUG)
#       define DEBUG_ONLY(a) a
#   else
#       define DEBUG_ONLY(a)
#   endif
#endif // DEBUG_ONLY

#endif // __STRMDECDBG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\strmdec_wma.h ===
/*************************************************************************

Copyright (C) 1996-1999  Microsoft Corporation

Module Name:

	strmdec_wma.h

Abstract:

	Decoder BitStream

Author:

	Craig Dowell (craigdo@microsoft.com) 10-December-1996
	Ming-Chieh Lee (mingcl@microsoft.com) 10-December-1996
	Bruce Lin (blin@microsoft.com) 10-December-1996

Revision History:
	Bruce Lin (blin@microsoft.com) 02-May-1997
	Add getMaxBits()
    Wei-ge Chen (wchen@microsoft.com) 20-July-1999
    Make it in C.

*************************************************************************/

#ifndef __STRMDEC_WMA_H_
#define __STRMDEC_WMA_H_

#define VALID				0
#define END_OF_FILE			1
#define ILLEGAL_PATTERN		3
#ifndef EOF
#define EOF                 (-1)
#endif

#define NONSUPER_WRAPAROUND 1024

#ifdef __cplusplus
extern "C" {  // only need to export C interface if
              // used by C++ source code
#endif

extern const UInt getMask [33];

#if defined(_DEBUG) || defined(BITRATE_REPORT)
extern Int g_cBitGet;
#endif  // _DEBUG || BITRATE_REPORT

typedef WMARESULT (*PFNGETMOREDATA)(U8 **ppBuffer, U32 *pcbBuffer, U32 user_data);

typedef struct CWMAInputBitStream {

//wchen: add for streaming mode
    PFNGETMOREDATA  m_pfnGetMoreData;
    U32             m_dwUser;
    U32             m_dwOwner;

    U32     m_dwHeaderBuf;      // hold the packet header data
    U8	    *m_pBufferBegin;    // begining of packet for reset
    U32	    m_cbBuflenBegin;    // used in association of m_pBufferBegin	

    U8		*m_pBuffer;
    Int		m_cbBuflen;
    UInt	m_dwDot;
    UInt	m_dwBitsLeft;
    Int     m_iPrevPacketNum;
    Bool    m_fAllowPackets;
    Bool    m_fSuppressPacketLoss;

    WMARESULT (*ibstrmpfnPeekBits) (struct CWMAInputBitStream *pibstrm, register UInt dwNumBits,
                                    U32 *piNumBits);

} CWMAInputBitStream;

Void        ibstrmInit (CWMAInputBitStream* pibstrm, Bool fAllowPackets);
Void        ibstrmAttach(CWMAInputBitStream *pibstrm, U32 dwDot, U32 dwBitsLeft, U8* pbSrc, I32 cbSrc);
Void ibstrmReset(CWMAInputBitStream *pibstrm);
INLINE UInt ibstrmBitsLeft (const CWMAInputBitStream* pibstrm) {return pibstrm->m_dwBitsLeft;}
INLINE U32  ibstrmDwBuf (const CWMAInputBitStream* pibstrm) {return pibstrm->m_dwDot;}
INLINE U8*  ibstrmBuf (const CWMAInputBitStream* pibstrm) {return pibstrm->m_pBuffer;}
INLINE Int  ibstrmBufLen (const CWMAInputBitStream* pibstrm) {return pibstrm->m_cbBuflen;}

INLINE Void ibstrmSetGetMoreData(CWMAInputBitStream *pibs, PFNGETMOREDATA pfnGetMoreData)
                        { pibs->m_pfnGetMoreData = pfnGetMoreData; }
INLINE Void ibstrmSetUserData(CWMAInputBitStream *pibs, U32 dwUser) 
                        { pibs->m_dwUser = dwUser; }
INLINE Void ibstrmSetOwner(CWMAInputBitStream *pibs, U32 dwOwner) 
                        { pibs->m_dwOwner = dwOwner; }
INLINE U32  ibstrmGetPacketHeader(CWMAInputBitStream *pibs) 
                        { return pibs->m_dwHeaderBuf; }
INLINE Void ibstrmSetPacketHeader(CWMAInputBitStream *pibs, U32 iVal) 
                        { pibs->m_dwHeaderBuf = iVal; }
Void        ibstrmResetPacket(CWMAInputBitStream *pibstrm); // reset to the beginning of packet
WMARESULT   ibstrmGetMoreData(CWMAInputBitStream *pibstrm, U32 *piBufLen);
WMARESULT   ibstrmPeekBitsNonStop (CWMAInputBitStream *pibstrm, register UInt dwNumBits,
                                   U32 *piNumBits);
WMARESULT   ibstrmPeekBits (CWMAInputBitStream *pibstrm, register UInt dwNumBits,
                            U32 *piNumBits);
WMARESULT   ibstrmLookForBits (CWMAInputBitStream *pibstrm, UInt dwNumBits);
WMARESULT   ibstrmFlushBits (CWMAInputBitStream *pibstrm, register UInt dwNumBits);
INLINE Void ibstrmFlush (CWMAInputBitStream* pibstrm) 
                        { pibstrm->m_dwBitsLeft -= (pibstrm->m_dwBitsLeft % 8); } 

//private
WMARESULT prvFinalLoad(CWMAInputBitStream* pibstrm,
                       UInt             dwRetval,
                       UInt             dwBitsToAdd,
                       U32             *piResult);

/*INLINE*/ WMARESULT ibstrmGetBits (CWMAInputBitStream* pibstrm, register UInt dwNumBits,
                                    U32 *piResult);

/*
{
    register UInt dwRetval;
    register UInt dwShift;

#ifdef _DEBUG
    g_cBitGet += dwNumBits;
#endif  // _DEBUG


    if (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen <= 0)
        ibstrmGetMoreData (pibstrm);
    assert (dwNumBits <= 24);
    //wchen: since the dwDot is always 24bits or more 
    //the following code can be greatly simplified. Do it later.

    //
    // This is a little unwieldly, but make sure the end-of-file test falls
    // through in the usual (not end-of-file) case to avoid CPU pipeline stalls
    // due to a branch (or mispredictions on more sophisticated processors).
    //
    if (pibstrm->m_fStreamStaus == VALID && 
        ((UInt) (pibstrm->m_cbBuflen << 3) >= dwNumBits || 
        pibstrm->m_dwBitsLeft + (pibstrm->m_cbBuflen << 3) >= dwNumBits)) {
        //
        // Do the most common case first.  If this doesn't play, we have one branch
        // to get to the next most common case (usually 1/32 of the time in the case
        // of the codec doing a huffman decode).  Note that we use a mask array to
        // avoid a special case branch when the bitcount is 32 (even though this is
        // relatively unlikely) since a left shift operation where the shift count
        // is equal to or greater than the number of bits in the destination is
        // undefined.
        //
        if (dwNumBits <= pibstrm->m_dwBitsLeft) {
            pibstrm->m_dwBitsLeft -= dwNumBits;
			return (pibstrm->m_dwDot >> pibstrm->m_dwBitsLeft) & getMask[dwNumBits];
        }
        //
        // The next most common case is when we have lots of data left in the buffer.
        // and we can fully load (i.e., all 32-bits) our accumulator.  This is
        // hard-wired to allow an optimizer to go crazy with all of the constants.
        // Note that the data is byte-swapped on the way in.
        //
        dwRetval = pibstrm->m_dwDot & getMask[pibstrm->m_dwBitsLeft];
        dwShift = dwNumBits - pibstrm->m_dwBitsLeft;

        if (pibstrm->m_cbBuflen >= 4) {
            register UInt     dwAcc;

            dwAcc = (UInt)pibstrm->m_pBuffer[3];
            dwAcc |= (UInt)(pibstrm->m_pBuffer[2]) << 8;
            dwAcc |= (UInt)(pibstrm->m_pBuffer[1]) << 16;
            dwAcc |= (UInt)(pibstrm->m_pBuffer[0]) << 24;
            pibstrm->m_dwDot = dwAcc;
            pibstrm->m_pBuffer += 4;
            pibstrm->m_cbBuflen -= 4;
            dwRetval <<= dwShift;
            dwRetval |= (dwAcc >> (32 - dwShift));// & getMask[dwShift];
            pibstrm->m_dwBitsLeft = 32 - dwShift;
            return dwRetval;
        }
        //
        // The final, and least likely case, is when we're at the end of the buffer.
        // Since there's really no point in having this inlined since it'll only
        // happen once, I'll call a function to make it happen and save the space
        // in the inline instances of getBits().
        //
		return prvFinalLoad(pibstrm, dwRetval, dwShift);
    }
	else {
        pibstrm->m_fStreamStaus = END_OF_FILE;
        return 0;
    }
}
*/
#ifdef __cplusplus
}
#endif

#endif // __STRMDEC_WMA_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\tables_wmv.h ===
#ifndef __TABLES_WMV_H_
#define __TABLES_WMV_H_

#include "wmvdec_api.h"

#ifdef __cplusplus
extern "C" {
#endif
extern const U8_WMV g_rgiClapTabDecWMV [1024];
#ifdef __cplusplus
}
#endif

#ifdef  _WMV_TARGET_X86_
#ifdef _XBOX
#define g_bSupportMMX_WMV ((Bool_WMV)TRUE)
#else
extern Bool_WMV g_bSupportMMX_WMV;
#endif
#endif //  _WMV_TARGET_X86_

// For encoder and decoder;
extern I8_WMV* gmvUVtable4;
extern I8_WMV gmvUVtableNew[128];
extern U8_WMV grgiZigzagInv [BLOCK_SQUARE_SIZE+1];
extern U8_WMV  grgiHorizontalZigzagInv [BLOCK_SQUARE_SIZE];
extern U8_WMV  grgiVerticalZigzagInv [BLOCK_SQUARE_SIZE];
extern U8_WMV  grgiZigzagInvRotated [BLOCK_SQUARE_SIZE];

extern U8_WMV grgiZigzagInv_NEW [BLOCK_SQUARE_SIZE+1];
extern U8_WMV grgiZigzagInv_NEW_I [BLOCK_SQUARE_SIZE+1];
extern U8_WMV grgiHorizontalZigzagInv_NEW [BLOCK_SQUARE_SIZE];
extern U8_WMV grgiVerticalZigzagInv_NEW [BLOCK_SQUARE_SIZE];
extern U8_WMV grgiZigzagInvRotated_NEW [BLOCK_SQUARE_SIZE];
extern U8_WMV grgiZigzagInvRotated_NEW_I [BLOCK_SQUARE_SIZE+1];
extern U8_WMV grgiHorizontalZigzagInvRotated_NEW [BLOCK_SQUARE_SIZE];
extern U8_WMV grgiVerticalZigzagInvRotated_NEW [BLOCK_SQUARE_SIZE];

extern U8_WMV grgi8x4ZigzagInv[33];
extern U8_WMV grgi4x8ZigzagInv[33];
extern U8_WMV grgi8x4ZigzagInvRotated[33];
extern U8_WMV grgi4x8ZigzagInvRotated[33];

/// Tabls for HighMotion
extern U8_WMV sm_rgIfNotLastNumOfLevelAtRunIntraY_HghMt [31]; 
extern U8_WMV sm_rgIfLastNumOfLevelAtRunIntraY_HghMt [38]; 
extern U8_WMV sm_rgIfNotLastNumOfRunAtLevelIntraY_HghMt [20];
extern U8_WMV sm_rgIfLastNumOfRunAtLevelIntraY_HghMt [7];
extern U8_WMV sm_rgIfLastNumOfLevelAtRun_HghMt [37];
extern U8_WMV sm_rgIfNotLastNumOfLevelAtRun_HghMt [27];
extern U8_WMV sm_rgIfNotLastNumOfRunAtLevel_HghMt [24];
extern U8_WMV sm_rgIfLastNumOfRunAtLevel_HghMt [10];

/// Tabls for Talking
extern U8_WMV sm_rgIfNotLastNumOfLevelAtRunIntraY_Talking [21]; 
extern U8_WMV sm_rgIfLastNumOfLevelAtRunIntraY_Talking [27]; 
extern U8_WMV sm_rgIfNotLastNumOfRunAtLevelIntraY_Talking [17];
extern U8_WMV sm_rgIfLastNumOfRunAtLevelIntraY_Talking [5];
extern U8_WMV sm_rgIfLastNumOfLevelAtRun_Talking [44];
extern U8_WMV sm_rgIfNotLastNumOfLevelAtRun_Talking [30];
extern U8_WMV sm_rgIfNotLastNumOfRunAtLevel_Talking [15];
extern U8_WMV sm_rgIfLastNumOfRunAtLevel_Talking [6];

/// Tabls for MPEG4
extern U8_WMV sm_rgIfNotLastNumOfLevelAtRunIntraY_MPEG4 [15]; 
extern U8_WMV sm_rgIfLastNumOfLevelAtRunIntraY_MPEG4 [21]; 
extern U8_WMV sm_rgIfNotLastNumOfRunAtLevelIntraY_MPEG4 [28];
extern U8_WMV sm_rgIfLastNumOfRunAtLevelIntraY_MPEG4 [9];
extern U8_WMV sm_rgIfLastNumOfLevelAtRun_MPEG4 [41];
extern U8_WMV sm_rgIfNotLastNumOfLevelAtRun_MPEG4 [27];
extern U8_WMV sm_rgIfNotLastNumOfRunAtLevel_MPEG4 [13];
extern U8_WMV sm_rgIfLastNumOfRunAtLevel_MPEG4 [4];

// g_rgDitherMap
// all DCT, MV tables

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\strmdec_wmv.hpp ===
/*************************************************************************

Copyright (C) 1996, 1997  Microsoft Corporation

Module Name:

    strmdec.hpp

Abstract:

    Decoder BitStream

Author:

    Craig Dowell (craigdo@microsoft.com) 10-December-1996
    Ming-Chieh Lee (mingcl@microsoft.com) 10-December-1996
    Bruce Lin (blin@microsoft.com) 10-December-1996
    Chuang Gu (chuanggu@microsoft.com) 2-Feb-2000

Revision History:
    Bruce Lin (blin@microsoft.com) 02-May-1997
    Add getMaxBits()

*************************************************************************/

#ifndef __STRMDEC_HPP_
#define __STRMDEC_HPP_

#if DBG
extern DWORD g_TotalBits;
#endif DBG

Class istream;

// Hide Debugging/Analysis macros called HUFFMANGET_DBG... in another file
#include "strmdecdbg.hpp"

#ifdef __STREAMING_MODE_DECODE_
    extern  I32_WMV getVideoData(I32_WMV ioffset, U8_WMV** ppBuffer, U32_WMV* dwBufferLen, Bool_WMV* bNotEndOfFrame);
#endif

#define VALID               0
#define END_OF_FILE         1
#define ILLEGAL_PATTERN     3
//#define EOF                 (-1)

extern U32_WMV GetMask_WMV [33];

#ifdef FORCEINLINE
#undef FORCEINLINE
#endif

#if defined(OPT_HUFFMAN_GET_WMV) && defined(UNDER_CE) && !defined(DEBUG)
#   define FORCEINLINE __forceinline
#else
#   define FORCEINLINE inline
#endif

inline U32_WMV ReadIntNBO(U8_WMV *pos)
{
  U32_WMV tmp;
  tmp=*(U32_WMV *)pos;
  return (tmp<<24)|(tmp>>24)|((tmp&0xff00)<<8)|((tmp>>8)&0xff00);
}

//class CVideoObjectDecoder ;
//class CDCTTableInfo_Dec;

typedef struct tagCInputBitStream_WMV {


#   if defined(OPT_HUFFMAN_GET_WMV)
        // IMPORTANT: these components must be at the their exact offsets to the base of the class, or the implementation won't work
        // - weidongz Nov.3, 2000
        union
        {
            U8_WMV  *m_pBuffer;
            I32_WMV OPT_HUFFMAN_GET_WMV_CBSbase;
        };
        I32_WMV     m_cbBuflen;
        U32_WMV     m_currBits;
        U32_WMV     m_nextBits;

        union
        {
            I32_WMV m_BNS_base;
            struct 
            {
                I16_WMV m_BNS_base16L;
                I16_WMV m_BNS_base16H;
            } m_BNS16;
            struct 
            {
                U8_WMV  m_wBitsLeft;
                U8_WMV  m_wNextBitsSkip;
                I8_WMV  m_fStreamStaus;
                I8_WMV  m_stuff;
            } m_BMS8;
        };
#   else // defined(OPT_HUFFMAN_GET_WMV)
        U8_WMV      *m_pBuffer;
        I32_WMV     m_cbBuflen;
            U32_WMV    m_dwDot;
            U32_WMV    m_dwBitsLeft;
        I32_WMV     m_fStreamStaus;

#   endif // defined(OPT_HUFFMAN_GET_WMV)

#       ifdef __STREAMING_MODE_DECODE_
            Bool_WMV    m_bNotEndOfFrame;
#       endif 
    U32_WMV m_uiUserData;
}CInputBitStream_WMV;

#   ifdef OPT_HUFFMAN_GET_WMV
inline Bool_WMV BS_invalid (CInputBitStream_WMV * pThis)  { return pThis->m_BMS8.m_fStreamStaus; }
inline  Void_WMV BS_setInvalid(CInputBitStream_WMV * pThis) { pThis->m_BMS8.m_fStreamStaus = ILLEGAL_PATTERN; }
inline  U32_WMV BS_BitsLeft (CInputBitStream_WMV * pThis)  { return pThis->m_BMS8.m_wBitsLeft; }
inline  Void_WMV BS_flush (CInputBitStream_WMV * pThis) { pThis->m_BMS8.m_wBitsLeft -= (((U8_WMV)pThis->m_BMS8.m_wBitsLeft) % 8u); }
#   else
inline Bool_WMV BS_invalid (CInputBitStream_WMV * pThis)  { return pThis->m_fStreamStaus; }
inline        Void_WMV BS_setInvalid(CInputBitStream_WMV * pThis) { pThis->m_fStreamStaus = ILLEGAL_PATTERN; }
inline        U32_WMV BS_BitsLeft (CInputBitStream_WMV * pThis)  { return pThis->m_dwBitsLeft; }
inline        Void_WMV BS_flush (CInputBitStream_WMV * pThis) { pThis->m_dwBitsLeft -= (pThis->m_dwBitsLeft % 8u); }
#   endif

#       ifdef OPT_HUFFMAN_GET_WMV
I32_WMV BS_getBits2(CInputBitStream_WMV * pThis, I32_WMV dwNumBits);
I32_WMV BS_getMaxBits2(CInputBitStream_WMV * pThis, I32_WMV dwNumBits, U8_WMV* rgCodeSymSize);
U32_WMV BS_peekBits2 (CInputBitStream_WMV * pThis, const U32_WMV numBits);
Void_WMV BS_updateCurrNext(CInputBitStream_WMV * pThis);
#else
U32_WMV BS_finalLoad( CInputBitStream_WMV * pThis, U32_WMV    dwRetval, U32_WMV       dwBitsToAdd);
Void_WMV
BS_addDataToBuffer(
    CInputBitStream_WMV * pThis,
    U8_WMV          *pBuffer,
    U32_WMV        dwBuflen,
    Bool_WMV        bNotEndOfFrame
    );
#endif

inline Bool_WMV WMVDecCBGetDataWithPadding(CInputBitStream_WMV* pThis)
{
    Bool_WMV bNotEndOfFrame;
    U32_WMV  dwBufferLen;
    U8_WMV*  pBuffer;
    U8_WMV tmp[6];
    memcpy(tmp, pThis->m_pBuffer, pThis->m_cbBuflen);
    WMVDecCBGetData(pThis->m_uiUserData,
                    pThis->m_cbBuflen,
                    &pBuffer,
                    4,
                    &dwBufferLen,
                    &bNotEndOfFrame);

    if (pBuffer == NULL || (bNotEndOfFrame && dwBufferLen == 0)) {
        BS_setInvalid(pThis);
        return FALSE_WMV;
    }

    memcpy(pBuffer, tmp, pThis->m_cbBuflen);
    BS_addDataToBuffer(pThis, pBuffer, dwBufferLen, bNotEndOfFrame);
    return TRUE_WMV;
}

    FORCEINLINE U32_WMV BS_getBits (CInputBitStream_WMV * pThis, register U32_WMV     dwNumBits)
    {      
        assert((dwNumBits>0)&&(dwNumBits<32));

#if DBG
g_TotalBits += dwNumBits;
#endif

#       ifdef OPT_HUFFMAN_GET_WMV
            // assuming padding bytes always exists at the end of a frame, so don't have to worry about m_nextBits 
            // most common case
            I32_WMV wBitsLeft;
            if ((wBitsLeft=(pThis->m_BMS8.m_wBitsLeft-(I16_WMV)dwNumBits))>=0) 
            {
                // result=(m_currBits >> m_dwBitsLeft) & GetMask[dwNumBits];
                HUFFMANGET_DBG_DMP((pThis->m_currBits >> pThis->m_BMS8.m_wBitsLeft) & (((U32_WMV)0xffffffff)>>(32-dwNumBits)),0,0,0);
                pThis->m_BMS8.m_wBitsLeft=wBitsLeft;
                return (pThis->m_currBits >> wBitsLeft) & (((U32_WMV)0xffffffff)>>(32-dwNumBits));
            }
            int result=BS_getBits2( pThis, dwNumBits);
            HUFFMANGET_DBG_DMP(result,0,0,0);
            return result;
#       else
            //
            // This is a little unwieldly, but make sure the end-of-file test falls
            // through in the usual (not end-of-file) case to avoid CPU pipeline stalls
            // due to a branch (or mispredictions on more sophisticated processors).
            //
            int result;
            //
            // Do the most common case first.  If this doesn't play, we have one branch
            // to get to the next most common case (usually 1/32 of the time in the case
            // of the codec doing a huffman decode).  Note that we use a mask array to
            // avoid a special case branch when the bitcount is 32 (even though this is
            // relatively unlikely) since a left shift operation where the shift count
            // is equal to or greater than the number of bits in the destination is
            // undefined.
            //
            if (dwNumBits <= pThis->m_dwBitsLeft) {
                pThis->m_dwBitsLeft -= dwNumBits;
                int result= (pThis->m_dwDot >> pThis->m_dwBitsLeft) & GetMask_WMV[dwNumBits];
                HUFFMANGET_DBG_DMP(result,0,0,0);
                return result;
            }
            //
            // The next most common case is when we have lots of data left in the buffer.
            // and we can fully load (i.e., all 32-bits) our accumulator.  This is
            // hard-wired to allow an optimizer to go crazy with all of the constants.
            // Note that the data is byte-swapped on the way in.
            //
            register U32_WMV dwRetval = pThis->m_dwDot & GetMask_WMV[pThis->m_dwBitsLeft];
            register U32_WMV dwShift = dwNumBits - pThis->m_dwBitsLeft;
#               ifdef __STREAMING_MODE_DECODE_
                // 6 (instead of 4) is to make sure if not addData to buffer 
                // buffer still has at least 2 bytes left after taking 4 bytes away
                // 2 bytes is minimal for peeking (or showbits)
                if (pThis->m_cbBuflen <= 6 && pThis->m_bNotEndOfFrame) {
                    if (!WMVDecCBGetDataWithPadding(pThis))
                        return 0;
                }
#               endif
            if (pThis->m_cbBuflen >= 4) {
                register U32_WMV     dwAcc;

                dwAcc = (U32_WMV)pThis->m_pBuffer[3];
                dwAcc |= (U32_WMV)(pThis->m_pBuffer[2]) << 8;
                dwAcc |= (U32_WMV)(pThis->m_pBuffer[1]) << 16;
                dwAcc |= (U32_WMV)(pThis->m_pBuffer[0]) << 24;
                pThis->m_dwDot = dwAcc;
                pThis->m_pBuffer += 4;
                pThis->m_cbBuflen -= 4;
                dwRetval <<= dwShift;
                dwRetval |= (dwAcc >> (32 - dwShift));// & GetMask[dwShift];
                pThis->m_dwBitsLeft = 32 - dwShift;
                HUFFMANGET_DBG_DMP(dwRetval,0,0,0);
                return dwRetval;
            }
            //
            // The final, and least likely case, is when we're at the end of the buffer.
            // Since there's really no point in having this inlined since it'll only
            // happen once, I'll call a function to make it happen and save the space
            // in the inline instances of getBits().
            //
            result=BS_finalLoad(pThis, dwRetval, dwShift);
            HUFFMANGET_DBG_DMP(result,0,0,0);
                return result;
#       endif
    }
    
    inline U8_WMV BS_getMaxBits (CInputBitStream_WMV * pThis, register U32_WMV dwNumBits, U8_WMV* rgCodeSymSize) {

#if DBG
        g_TotalBits += dwNumBits;
#endif


        assert((dwNumBits>0)&&(dwNumBits<32));

#       ifdef OPT_HUFFMAN_GET_WMV
           I32_WMV iBitPattern, result;
           register I32_WMV bitsshift;
            // assuming padding bytes always exists at the end of a frame, so don't have to worry about m_nextBits 
            // most common case
            bitsshift=pThis->m_BMS8.m_wBitsLeft-dwNumBits ;
            if (bitsshift>=0) 
            {
                // iBitPattern = ((m_currBits >> bitsshift) & GetMask[dwNumBits])<<1; //0x00000fff;
                iBitPattern = ((pThis->m_currBits >> bitsshift) & (((U32_WMV)0xffffffff)>>(32-dwNumBits)))<<1; //0x00000fff;
                pThis->m_BMS8.m_wBitsLeft -= rgCodeSymSize[iBitPattern];
                result=rgCodeSymSize [iBitPattern+1];
                if (result == 255)
                {
                        pThis->m_BMS8.m_wBitsLeft=0;
                        pThis->m_BMS8.m_wNextBitsSkip=32;
                        pThis->m_cbBuflen=0;
                        pThis->m_BMS8.m_fStreamStaus = ILLEGAL_PATTERN;
                }
                HUFFMANGET_DBG_CACHE(rgCodeSymSize,iBitPattern+1,2);
                HUFFMANGET_DBG_DMP(result,rgCodeSymSize,iBitPattern+1,0);
                return result;
            }
            result=BS_getMaxBits2(pThis, dwNumBits,rgCodeSymSize);
            HUFFMANGET_DBG_DMP(result,rgCodeSymSize,0,1);
            return result;
#       else
            //
            // This is a little unwieldly, but make sure the end-of-file test falls
            // through in the usual (not end-of-file) case to avoid CPU pipeline stalls
            // due to a branch (or mispredictions on more sophisticated processors).
            I32_WMV iBitPattern;
            //      //assert ( dwNumBits <=16);
                    //if (m_fEof == FALSE && ((U32_WMV) (m_cbBuflen << 3) >= dwNumBits || m_dwBitsLeft + (m_cbBuflen << 3) >= dwNumBits)) {
            //
            // Do the most common case first.  If this doesn't play, we have one branch
            // to get to the next most common case (usually 1/32 of the time in the case
            // of the codec doing a huffman decode).  Note that we use a mask array to
            // avoid a special case branch when the bitcount is 32 (even though this is
            // relatively unlikely) since a left shift operation where the shift count
            // is equal to or greater than the number of bits in the destination is
            // undefined.
            //
            if (dwNumBits <= pThis->m_dwBitsLeft) {
                iBitPattern = ((pThis->m_dwDot >> (pThis->m_dwBitsLeft - dwNumBits)) & GetMask_WMV[dwNumBits])<<1; //0x00000fff;
                pThis->m_dwBitsLeft -= rgCodeSymSize[iBitPattern];
                if (rgCodeSymSize [iBitPattern+1] == 255)
                    pThis->m_fStreamStaus = ILLEGAL_PATTERN;
                HUFFMANGET_DBG_CACHE(rgCodeSymSize,iBitPattern,2);
                HUFFMANGET_DBG_DMP(rgCodeSymSize [iBitPattern+1],rgCodeSymSize,iBitPattern+1,1);
                return rgCodeSymSize [iBitPattern+1];
            }
            //
            // The next most common case is when we have lots of data left in the buffer.
            // and we can fully load (i.e., all 32-bits) our accumulator.  This is
            // hard-wired to allow an optimizer to go crazy with all of the constants.
            // Note that the data is byte-swapped on the way in.
            //

#           ifdef __STREAMING_MODE_DECODE_
                if (pThis->m_cbBuflen <= 4 && pThis->m_bNotEndOfFrame) {
                    if (!WMVDecCBGetDataWithPadding(pThis))
                        return 255;
                }
#           endif
            if (pThis->m_cbBuflen >= 2) {
                pThis->m_dwDot <<= 16;
                pThis->m_dwDot |= (U32_WMV)(pThis->m_pBuffer[1]);
                pThis->m_dwDot |= (U32_WMV)(pThis->m_pBuffer[0]) << 8;
                pThis->m_pBuffer += 2;
                pThis->m_cbBuflen -= 2;
                pThis->m_dwBitsLeft += 16;
                iBitPattern = ((pThis->m_dwDot >> (pThis->m_dwBitsLeft - dwNumBits)) & GetMask_WMV[dwNumBits])<<1;
                pThis->m_dwBitsLeft -= rgCodeSymSize[iBitPattern];
                if (rgCodeSymSize[iBitPattern+1] == 255)
                    pThis->m_fStreamStaus = ILLEGAL_PATTERN;
                HUFFMANGET_DBG_CACHE(rgCodeSymSize,iBitPattern,2);
                HUFFMANGET_DBG_DMP(rgCodeSymSize [iBitPattern+1],rgCodeSymSize,iBitPattern+1,1);
                return rgCodeSymSize[iBitPattern+1];
            }
            //
            // The final, and least likely case, is when we're at the end of the buffer.
            // Since there's really no point in having this inlined since it'll only
            // happen once, I'll call a function to make it happen and save the space
            // in the inline instances of getBits().
            //
            for (; pThis->m_cbBuflen;) {
                pThis->m_dwDot <<= 8;
                pThis->m_dwDot |= *pThis->m_pBuffer++;
                --pThis->m_cbBuflen;
                pThis->m_dwBitsLeft += 8;
            }
            if (pThis->m_dwBitsLeft >= dwNumBits){ 
                iBitPattern = ((pThis->m_dwDot >> (pThis->m_dwBitsLeft - dwNumBits)) & GetMask_WMV[dwNumBits])<<1;
                pThis->m_dwBitsLeft -= rgCodeSymSize[iBitPattern];
                if (rgCodeSymSize[iBitPattern+1] == 255)
                    pThis->m_fStreamStaus = ILLEGAL_PATTERN;
                HUFFMANGET_DBG_CACHE(rgCodeSymSize,iBitPattern,2);
                HUFFMANGET_DBG_DMP(rgCodeSymSize [iBitPattern+1],rgCodeSymSize,iBitPattern+1,1);
                return rgCodeSymSize[iBitPattern+1];
            }
            else {
                iBitPattern = (pThis->m_dwDot & GetMask_WMV[pThis->m_dwBitsLeft]) << (dwNumBits - pThis->m_dwBitsLeft + 1);
                if (pThis->m_dwBitsLeft >= (U32_WMV) rgCodeSymSize[iBitPattern]){
                    pThis->m_dwBitsLeft -= rgCodeSymSize[iBitPattern];
                    if (rgCodeSymSize[iBitPattern+1] == 255)
                        pThis->m_fStreamStaus = ILLEGAL_PATTERN;
                    HUFFMANGET_DBG_CACHE(rgCodeSymSize,iBitPattern,2);
                    HUFFMANGET_DBG_DMP(rgCodeSymSize [iBitPattern+1],rgCodeSymSize,iBitPattern+1,1);
                    return rgCodeSymSize[iBitPattern+1];
                }
                else {
                    pThis->m_fStreamStaus = END_OF_FILE;
                    HUFFMANGET_DBG_CACHE(rgCodeSymSize,iBitPattern,2);
                    HUFFMANGET_DBG_DMP(255,rgCodeSymSize,iBitPattern+1,1);
                    return 255;
                }
            }
#       endif
    }

    //inline U32_WMV getBit () {
    FORCEINLINE U32_WMV BS_getBit (CInputBitStream_WMV * pThis) {

#if DBG
g_TotalBits += 1;
#endif

#       ifdef OPT_HUFFMAN_GET_WMV
            // assuming padding bytes always exists at the end of a frame, so don't have to worry about m_nextBits 
            I32_WMV wBitsLeft;
            if ((wBitsLeft=(pThis->m_BMS8.m_wBitsLeft-1))>=0) 
            {
                // result=(m_currBits >> m_dwBitsLeft) & GetMask[dwNumBits];
                pThis->m_BMS8.m_wBitsLeft=wBitsLeft;
                return (pThis->m_currBits >> wBitsLeft) & 1;
            }
            return BS_getBits2(pThis, 1);
#       else
            int result;
            //
            // This is a little unwieldly, but make sure the end-of-file test falls
            // through in the usual (not end-of-file) case to avoid CPU pipeline stalls
            // due to a branch. 
            //
            //
            // Do the most common case first.  If this doesn't play, we have one branch
            // to get to the next most common case (usually 1/32 of the time in the case
            // of the codec doing a huffman decode).  Note that we use a mask array to
            // avoid a special case branch when the bitcount is 32 (even though this is
            // relatively unlikely) since a left shift operation where the shift count
            // is equal to or greater than the number of bits in the destination is
            // undefined.
            //
            if (pThis->m_dwBitsLeft >= 1) {
                pThis->m_dwBitsLeft--;
                result=(pThis->m_dwDot >> pThis->m_dwBitsLeft) & 0x00000001;
                HUFFMANGET_DBG_DMP(result,0,0,0);
                return result;
            }
            //
            // The next most common case is when we have lots of data left in the buffer.
            // and we can fully load (i.e., all 32-bits) our accumulator.  This is
            // hard-wired to allow an optimizer to go crazy with all of the constants.
            // Note that the data is byte-swapped on the way in.
            //
#               ifdef __STREAMING_MODE_DECODE_
                // 6 (instead of 4) is to make sure if not addData to buffer 
                // buffer still has at least 2 bytes left after taking 4 bytes away
                // 2 bytes is minimal for peeking (or showbits)
                if (pThis->m_cbBuflen <= 6 && pThis->m_bNotEndOfFrame) {
                    if (!WMVDecCBGetDataWithPadding(pThis))
                        return 0;
                }
#               endif
            if (pThis->m_cbBuflen >= 4) {
                pThis->m_dwDot = (U32_WMV)pThis->m_pBuffer[3];
                pThis->m_dwDot |= (U32_WMV)(pThis->m_pBuffer[2]) << 8;
                pThis->m_dwDot |= (U32_WMV)(pThis->m_pBuffer[1]) << 16;
                pThis->m_dwDot |= (U32_WMV)(pThis->m_pBuffer[0]) << 24;
                pThis->m_pBuffer += 4;
                pThis->m_cbBuflen -= 4;
                pThis->m_dwBitsLeft = 31;
                HUFFMANGET_DBG_DMP((pThis->m_dwDot >> 31) & 0x00000001,0,0,0);
                return (pThis->m_dwDot >> 31) & 0x00000001;
            }
            //
            // The final, and least likely case, is when we're at the end of the buffer.
            // Since there's really no point in having this inlined since it'll only
            // happen once, I'll call a function to make it happen and save the space
            // in the inline instances of getBits().
            //
            result=BS_finalLoad (pThis, 0, 1);
            HUFFMANGET_DBG_DMP(result,0,0,0);
            return result;
#       endif
    }

inline   I32_WMV BS_bytesLeft (CInputBitStream_WMV * pThis) {return pThis->m_cbBuflen;}

inline Void_WMV BS_flushMPEG4 (CInputBitStream_WMV * pThis, I32_WMV nExtraBits=0) {
#       ifdef OPT_HUFFMAN_GET_WMV
            if((((U8_WMV)pThis->m_BMS8.m_wBitsLeft) % 8u)==0) {
                BS_getBits(pThis, nExtraBits);
            }
            else {
                pThis->m_BMS8.m_wBitsLeft -= (((U8_WMV)pThis->m_BMS8.m_wBitsLeft) % 8u);
            }
#       else
            if((pThis->m_dwBitsLeft % 8u)==0) {
                BS_getBits(pThis, nExtraBits);
            }
            else {
                pThis->m_dwBitsLeft -= (pThis->m_dwBitsLeft % 8u);
            }
#       endif
    }
#   ifdef OPT_HUFFMAN_GET_WMV
        FORCEINLINE U32_WMV BS_peekBits (CInputBitStream_WMV * pThis, const U32_WMV numBits)
        {
            assert((numBits>0)&&(numBits<32));

            I32_WMV tmp_dwBitsLeft;
            if ((tmp_dwBitsLeft=(pThis->m_BMS8.m_wBitsLeft-numBits))>=0) 
            {
                // result= (m_currBits >> tmp_dwBitsLeft) & GetMask[numBits];
                return (pThis->m_currBits >> tmp_dwBitsLeft) & (((U32_WMV)0xffffffff)>>(32-numBits));

            }

            return BS_peekBits2 (pThis, numBits);
        }

        U32_WMV BS_peekBits2 (CInputBitStream_WMV * pThis, const U32_WMV numBits);

        // following a peekbits and numBits is guaranteed to be smaller than m_wBitsLeft
        FORCEINLINE Void_WMV BS_adjustBits(CInputBitStream_WMV * pThis, const U8_WMV numBits)
        {
#if DBG
g_TotalBits += dwNumBits;
#endif

            pThis->m_BMS8.m_wBitsLeft-=numBits;
        }
#   else
        U32_WMV BS_peekBits (CInputBitStream_WMV * pThis, const U32_WMV numBits);            //peek bits
#   endif
    U32_WMV BS_peekBitsTillByteAlign (CInputBitStream_WMV * pThis, I32_WMV & nBitsToPeek);
    U32_WMV BS_peekBitsFromByteAlign (CInputBitStream_WMV * pThis, I32_WMV numBits); // peek from byte bdry
 inline   I32_WMV BS_eof(CInputBitStream_WMV * pThis)  {
#       ifdef OPT_HUFFMAN_GET_WMV
            if (pThis->m_BMS8.m_fStreamStaus == END_OF_FILE) 
                return EOF;
#       else
            if (pThis->m_fStreamStaus == END_OF_FILE) 
                return EOF;
#       endif
        return (~EOF); 
    }
#endif // __STRMDEC_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\userdll.h ===
/*M*
//
//               INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//        Copyright (c) 1999 Intel Corporation. All Rights Reserved.
//
//  Purpose: Declarations of the required functions
//   
*M*/

/***********************************************************/
/* Only copy the function prototype of all the             */
/* functions you want from the release include files       */
/***********************************************************/
#ifdef __USERLIST__

// Used by audio encoder and decoder
#if defined(INTELFFT_AUDIO)
    NSPAPI(void,nspcFft,     (SCplx  *samps, int order, int flags))
#endif  // INTELFFT_AUDIO

// Used by audio encoder and speech (encoder and decoder)
#if (defined(INTELFFT_AUDIO) && defined(INTELFFT_ENCODER)) || defined(INTELFFT_SPEECH)
    NSPAPI(void,nspsCcsFft,  (float  *samps, int order, int flags))
#endif  // (defined(INTELFFT_AUDIO) && defined(INTELFFT_ENCODER)) || defined(INTELFFT_SPEECH)

// Used by speech (encoder and decoder)
#if defined(INTELFFT_SPEECH)
    NSPAPI(void,nspsRealFft, (float  *samps, int order,  int  flags))
    NSPAPI(void,nspsDct,     (const float* src, float* dst, int len, int flags))
#endif  // INTELFFT_SPEECH

#endif /* __USERLIST__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\wavfileexio.h ===
/* -------------------------------------------------------------------------
 *
 *  Microsoft Windows Media
 *
 *  Copyright (C) Microsoft Corporation, 1999 - 2000
 *
 *  File:       wavfileexio.h
 *              This is a variation of wavfileio that works with 
 *              WAVEFORMATEXTENSIBLE, rather than with WAVEFORMATEX. 
 *              Deals with both WAVE_FORMAT_PCM and WAVE_FORMAT_EXTENSIBLE 
 *              format types.
 *              It is aware of multi-channel, and > 16 bits/sample.
 *              Updates from wavfileio.h were made by Thumpudi Naveen
 *              1/31/2000.
 *              
 * ---------------------------------------------------------------------- */

#ifndef _WAV_FILE_EX_IO_H_
#define _WAV_FILE_EX_IO_H_

/* use this to turn off the use of mmio* calls */
#define WFIO_NO_WIN32 1

/* use this to control the endian-ness */
#define WFIO_LITTLE_ENDIAN 1

#if WFIO_NO_WIN32

#include <stdio.h>
#include "macros.h"

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct {          // size is 16
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[8];
} GUID;

#endif // !GUID_DEFINED

#ifndef _WAVEFORMATEXTENSIBLE_
#define _WAVEFORMATEXTENSIBLE_
#ifndef _Embedded_x86
#pragma COMPILER_PACKALIGN(1)
#endif

#ifndef _XBOX
#if !defined (WINMMAPI)
#ifndef _WAVEFORMATEX_
#define _WAVEFORMATEX_
typedef struct 
{
    U16     wFormatTag;        /* format type */
    U16     nChannels;         /* number of channels (i.e. mono, stereo...) */
    U32     nSamplesPerSec;    /* sample rate */
    U32     nAvgBytesPerSec;   /* for buffer estimation */
    U16     nBlockAlign;       /* block size of data */
    U16     wBitsPerSample;    /* Number of bits per sample of mono data */
    U16     cbSize;            /* The count in bytes of the size of
                                * extra information (after cbSize) */
                               
} WAVEFORMATEX, *PWAVEFORMATEX, *LPWAVEFORMATEX;
#endif // _WAVEFORMATEX_
#endif // WINMMAPI
#endif

typedef struct 
{
    WAVEFORMATEX Format;       /* The traditional wave file header */
    union {
        unsigned short wValidBitsPerSample; /* bits of precision */
        unsigned short wSamplesPerBlock;    /* valid if wBitsPerSample==0 */
        unsigned short wReserved;           /* If neither applies, set to zero */
    } Samples;
    unsigned long    dwChannelMask;        /* which channels are present in stream */
    GUID SubFormat;           /* specialization */
} WAVEFORMATEXTENSIBLE, *PWAVEFORMATEXTENSIBLE;
#ifndef _Embedded_x86
#pragma COMPILER_PACKALIGN_DEFAULT
#endif
#endif /* _WAVEFORMATEXTENSIBLE_ */

#ifndef MMSYSERR_NOERROR
#define MMSYSERR_NOERROR     0
#define MMSYSERR_ERROR       1
#define MMSYSERR_NOMEM       7
#define MMSYSERR_READERROR   16
#define MMSYSERR_WRITEERROR  17
#endif /* MMSYSERR_NOERROR */

#ifndef WAVE_FORMAT_PCM
#define WAVE_FORMAT_PCM 1
#endif /* WAVE_FORMAT_PCM */

#ifndef WAVE_FORMAT_EXTENSIBLE
#define WAVE_FORMAT_EXTENSIBLE 65534
#endif /* WAVE_FORMAT_EXTENSIBLE */

#ifndef _SPEAKER_POSITIONS_
#define _SPEAKER_POSITIONS_
/* Speaker Positions for dwChannelMask in WAVEFORMATEXTENSIBLE: from ksmedia.h */
#define SPEAKER_FRONT_LEFT              0x1
#define SPEAKER_FRONT_RIGHT             0x2
#define SPEAKER_FRONT_CENTER            0x4
#define SPEAKER_LOW_FREQUENCY           0x8
#define SPEAKER_BACK_LEFT               0x10
#define SPEAKER_BACK_RIGHT              0x20
#define SPEAKER_FRONT_LEFT_OF_CENTER    0x40
#define SPEAKER_FRONT_RIGHT_OF_CENTER   0x80
#define SPEAKER_BACK_CENTER             0x100
#define SPEAKER_SIDE_LEFT               0x200
#define SPEAKER_SIDE_RIGHT              0x400
#define SPEAKER_TOP_CENTER              0x800
#define SPEAKER_TOP_FRONT_LEFT          0x1000
#define SPEAKER_TOP_FRONT_CENTER        0x2000
#define SPEAKER_TOP_FRONT_RIGHT         0x4000
#define SPEAKER_TOP_BACK_LEFT           0x8000
#define SPEAKER_TOP_BACK_CENTER         0x10000
#define SPEAKER_TOP_BACK_RIGHT          0x20000
#endif /* _SPEAKER_POSITIONS_ */

#else  /* WFIO_NO_WIN32 */
#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <ks.h>
#include <ksmedia.h>
#include "macros.h"

#endif /* WFIO_NO_WIN32 */

#define IS_KSDATAFORMAT_SUBTYPE_PCM(guid)\
    (((guid)->Data1       == 0x01) &&\
     ((guid)->Data2       == 0x00) &&\
     ((guid)->Data3       == 0x10) &&\
     ((guid)->Data4[0] == 0x80) &&\
     ((guid)->Data4[1] == 0x00) &&\
     ((guid)->Data4[2] == 0x00) &&\
     ((guid)->Data4[3] == 0xaa) &&\
     ((guid)->Data4[4] == 0x00) &&\
     ((guid)->Data4[5] == 0x38) &&\
     ((guid)->Data4[6] == 0x9b) &&\
     ((guid)->Data4[7] == 0x71))

#define COPY_KSDATAFORMAT_SUBTYPE_PCM(guid)\
     (guid)->Data1       = 0x01;\
     (guid)->Data2       = 0x00;\
     (guid)->Data3       = 0x10;\
     (guid)->Data4[0] = 0x80;\
     (guid)->Data4[1] = 0x00;\
     (guid)->Data4[2] = 0x00;\
     (guid)->Data4[3] = 0xaa;\
     (guid)->Data4[4] = 0x00;\
     (guid)->Data4[5] = 0x38;\
     (guid)->Data4[6] = 0x9b;\
     (guid)->Data4[7] = 0x71;


#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */
  
  /* flag for WavFileIO */
  enum
  {
    wfioModeRead = 0,
    wfioModeWrite
  };
  
  /* ===========================================================================
   * WavFileIO struct
   */
  typedef struct WavFileIO_tag
  {
    I32      m_mode;
    
#if WFIO_NO_WIN32
    FILE    *m_fpWav;
    
    size_t   m_posRiffLength;
    size_t   m_posDataLength;
#else  /* WFIO_NO_WIN32 */
    HMMIO    m_hmmio;
    MMIOINFO m_mmioinfo;
    
    MMCKINFO m_ckWave;
    MMCKINFO m_ck;
#endif /* WFIO_NO_WIN32 */
    
    WAVEFORMATEXTENSIBLE *m_pFormat;      /* but allocated using BYTEs...  */
    U32   m_sizeFormat;
    
    U32   m_sizeData;
    U32   m_posDataStart;
    
  } WavFileIO;
  
  
  /* ---------------------------------------------------------------------------
   * member functions
   */
  
  WavFileIO * wfioNew();
  void wfioDelete(WavFileIO *pwfio);
  
  /* pFormat and cbFormat are only for writing.
   * Upgrades the format to WAVE_FORMAT_EXTENSIBLE, if sources with
   * > 2 channels or samples with > 16 bits are to be saved. In such an upgrade
   * process, it "guesses" speaker positions.
   */
  I32 wfioOpen(WavFileIO *pwfio, const char *szFile, WAVEFORMATEXTENSIBLE *pFormat, U32 cbFormat, I32 mode);
  void wfioClose(WavFileIO *pwfio);
  
  /* origin can be SEEK_SET, SEEK_CUR, or SEEK_END */
  I32 wfioSeek(WavFileIO *pwfio, I32 position, I32 origin);
  
  I32 wfioRead(WavFileIO *pwfio, U8 *pBuf, I32 cbBuf);
  I32 wfioWrite(WavFileIO *pwfio, U8 *pBuf, I32 cbBuf);
  
  WAVEFORMATEXTENSIBLE * wfioGetFormat(WavFileIO *pwfio);
  U32 wfioGetFormatLength(WavFileIO *pwfio);
  
  U32 wfioGetSampleSize(WavFileIO *pwfio);
  U32 wfioGetDataLength(WavFileIO *pwfio);
  
  I32 wfioGetMode(WavFileIO *pwfio);
  I32 wfioIsOpened(WavFileIO *pwfio);
  
  /* utility functions */
  U16 adjustByteOrder16(U16 val);
  U32 adjustByteOrder32(U32 val);
  
#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif /* _WAV_FILE_EX_IO_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\typedef.hpp ===
/*************************************************************************

Copyright (c) Microsoft Corporation 1996 - 1999

Module Name:

	typedef.hpp

Abstract:

    Basic types:
		CVector2D, CPixel, CMotionVector, 

Author:

	Ming-Chieh Lee (mingcl@microsoft.com) 20-March-1996
	Wei-ge Chen (wchen@microsoft.com) 20-March-1996
	Bruce Lin	(blin@microsoft.com) 14-April-1996
	Chuang Gu (chuanggu@microsoft.com) 5-June-1996

Revision History:


*************************************************************************/


#ifndef __TYPEDEF_HPP_
#define __TYPEDEF_HPP_

#include "wmvdec_api.h"

#include "macros_wmv.h"

#ifdef UNDER_CE
#ifdef DEBUG
#include <windows.h>
#include <vfw_ce.h>
#define assert(x) if((x)==0) DebugBreak();
#else
#define assert(x)
#endif
#else
#include "assert.h"
#endif

#include <string.h>


/////////////////////////////////////////////
//
//  Typedefs for basic types
//
/////////////////////////////////////////////
#define Class		class

//typedef void *LPVoid_WMV;
//typedef unsigned long U32;
//typedef int I32;
//typedef unsigned short U16;
//typedef short I16;
//typedef double Double;
//typedef float Float;
//typedef float Float32;
//typedef float F32;
//typedef unsigned char U8;
//typedef signed char I8;
//typedef void Void_WMV;
//typedef char Char;
typedef __int64 Int64;
typedef __int64 I64;
typedef unsigned __int64 U64;

typedef I16_WMV PixelI;
typedef U8_WMV PixelC;
//typedef U32 UInt;
//typedef I32 Int;
//typedef I32 Long;
//typedef U32 ULong;
//typedef I32 Bool;
typedef I32_WMV CoordI;
typedef I32_WMV Wide;
typedef U32_WMV UWide;
typedef I32_WMV PixelI32;

#ifdef macintosh
typedef long long Time;
#else
typedef __int64 Time;
#endif

typedef enum {MP4S, MPG4, MP42, MP43, WMV1, WMV2} CodecVersion;
enum {XFORMMODE_8x8, XFORMMODE_8x4, XFORMMODE_4x8};
typedef enum BlockNum {
	ALL_Y_BLOCKS	= 0,
	Y_BLOCK1		= 1,
	Y_BLOCK2		= 2,
	Y_BLOCK3		= 3,
	Y_BLOCK4		= 4,
	U_BLOCK			= 5,
	V_BLOCK			= 6,
	A_BLOCK1		= 7,
	A_BLOCK2		= 8,
	A_BLOCK3		= 9,
	A_BLOCK4		= 10,
	ALL_A_BLOCKS	= 11
} BlockNum;


/////////////////////////////////////////////
// Control flag for varius compiler
//
/////////////////////////////////////////////

//some platforms might not support inline assemb
#ifdef _WMV_TARGET_X86_
#define _SCRUNCH_INLINEASM
#else
#undef _SCRUNCH_INLINEASM
#endif // _WMV_TARGET_X86_

/////////////////////////////////////////////
//
//  Motion Vectors
//
/////////////////////////////////////////////

union Buffer {
    I16_WMV i16[64];
    I32_WMV i32[64];
};

typedef struct tagCVector
{
	I8_WMV x;
	I8_WMV y;
} CVector;

typedef struct tagCWMVMBMode // MacroBlock Mode
{
	// Some extra data member
    U32_WMV m_bSkip : 1;	// is the Macroblock skiped. = COD in H.263
    U32_WMV m_bCBPAllZero : 1;	// are the CBP for 6 blocks all zero?
    U32_WMV m_bZeroMV : 1; //whether the MB has four motion vectors (for forward vectors)
    U32_WMV m_bBlkXformSwitchOn : 1;   // Boolean which indicates whether the MB or block-based transform switching is chosen
    U32_WMV m_iMBXformMode : 2;         // Transform type for the macroblock
    U32_WMV m_iDCTTable_MB_Index : 2;
    U32_WMV m_iMVPredDirection : 2; // 2: use original pred direction; 0: from left MB; 1: from up MB.
    U32_WMV m_dctMd : 1; // is the Macroblock inter- or intra- coded    
    U8_WMV m_rgbCodedBlockPattern;// bitfield(Y1,Y2,Y3,Y4,U,V=0) for each block, 1 = some non-DC components are coded
    U8_WMV m_rgbDCTCoefPredPattern; //bitfield(V,U,Y4,Y3,Y2,Y1,ALLBLOCK=0) [NUM_BLOCKS + 1]; //for each block, 1 = some non-DC components are coded

} CWMVMBMode;

typedef struct tagPackHuffmanCode_WMV
{
    U32_WMV code   : 26;
    U32_WMV length : 6;
} tPackHuffmanCode_WMV;
#endif // __BASIC_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\wmadecS_api.h ===
#ifndef _WMADECRAW_API_H_
#define _WMADECRAW_API_H_


#ifndef _WMARESULT_DEFINED
#define _WMARESULT_DEFINED

typedef int WMARESULT;

// SUCCESS codes
static const WMARESULT WMA_OK               = 0x00000000;
static const WMARESULT WMA_S_FALSE          = 0x00000001;
static const WMARESULT WMA_S_BUFUNDERFLOW   = 0x00000002;
static const WMARESULT WMA_S_NEWPACKET      = 0x00000003;
static const WMARESULT WMA_S_NO_MORE_FRAME  = 0x00000004;
static const WMARESULT WMA_S_NO_MORE_SRCDATA= 0x00000005;

// ERROR codes
static const WMARESULT WMA_E_FAIL           = 0x80004005;
static const WMARESULT WMA_E_OUTOFMEMORY    = 0x8007000E;
static const WMARESULT WMA_E_INVALIDARG     = 0x80070057;
static const WMARESULT WMA_E_NOTSUPPORTED   = 0x80040000;
static const WMARESULT WMA_E_LOSTPACKET     = 0x80040001;
static const WMARESULT WMA_E_BROKEN_FRAME   = 0x80040002;
static const WMARESULT WMA_E_BUFFEROVERFLOW = 0x80040003;
static const WMARESULT WMA_E_ONHOLD         = 0x80040004; 
static const WMARESULT WMA_E_NOMOREINPUT    = 0x8004000A; // Streaming mode: absolutely no more data (returned via GetMoreData callback)

#define WMARAW_SUCCEEDED(Status) ((WMARESULT)(Status) >= 0)
#define WMARAW_FAILED(Status) ((WMARESULT)(Status)<0)

#endif // _WMARESULT_DEFINED


// define basic types
typedef unsigned long U32_WMARawDec;
typedef long I32_WMARawDec;
typedef unsigned short U16_WMARawDec;
typedef short I16_WMARawDec;
typedef unsigned char U8_WMARawDec;


typedef void* WMARawDecHandle;

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


WMARESULT WMARawDecInit (
    WMARawDecHandle* phWMARawDec,
    U32_WMARawDec dwUserData,
    U16_WMARawDec iVersionNumber,
    U16_WMARawDec cSamplesPerBlock, 
    U16_WMARawDec cSamplesPerSecond, 
    U16_WMARawDec cChannel, 
    U16_WMARawDec cBytePerSec, 
    U16_WMARawDec cPacketLength,
    U16_WMARawDec cEncodeOpt,
    U16_WMARawDec cPlayerOpt
);

// **************************************************************************
// Player Options
// **************************************************************************
#define PLAYOPT_DOWNSAMPLE32TO22 0x0001
#define PLAYOPT_HALFTRANSFORM    0x0002
#define PLAYOPT_UPSAMPLE         0x0004
#define PLAYOPT_PAD2XTRANSFORM   0x0008

    
WMARESULT WMARawDecClose (WMARawDecHandle* phWMARawDec);
WMARESULT WMARawDecReset (WMARawDecHandle hWMARawDec);
WMARESULT WMARawDecStatus (WMARawDecHandle hWMARawDec);
WMARESULT WMARawDecDecodeData (WMARawDecHandle hWMARawDec, U32_WMARawDec *pnDecodedSamples);
WMARESULT WMARawDecGetPCM (WMARawDecHandle hWMARawDec, U16_WMARawDec* pcSampleReady, U8_WMARawDec* pbDst, U32_WMARawDec cbDstBufferLength);

extern WMARESULT WMARawDecCBGetData (U8_WMARawDec **ppBuffer, U32_WMARawDec* pcbBuffer, U32_WMARawDec dwUserData);
#ifdef __cplusplus
}
#endif  // __cplusplus


#endif // _WMADECRAW_API_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\wavfileio.h ===
/* -------------------------------------------------------------------------
 *
 *  Microsoft Windows Media
 *
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:       wavfileio.h
 *
 * ---------------------------------------------------------------------- */

#ifndef _WAV_FILE_IO_H_
#define _WAV_FILE_IO_H_

/* use this to turn off the use of mmio* calls */
#define WFIO_NO_WIN32 1

/* use this to control the endian-ness */
#define WFIO_LITTLE_ENDIAN 1

#if WFIO_NO_WIN32

#include <stdio.h>
#include "macros.h"

#ifndef _WAVEFORMATEX_
#define _WAVEFORMATEX_
#ifndef _Embedded_x86
#pragma COMPILER_PACKALIGN(1)
#endif
typedef struct tWAVEFORMATEX
{
    U16     wFormatTag;        /* format type */
    U16     nChannels;         /* number of channels (i.e. mono, stereo...) */
    U32     nSamplesPerSec;    /* sample rate */
    U32     nAvgBytesPerSec;   /* for buffer estimation */
    U16     nBlockAlign;       /* block size of data */
    U16     wBitsPerSample;    /* Number of bits per sample of mono data */
    U16     cbSize;            /* The count in bytes of the size of
                                    extra information (after cbSize) */

} WAVEFORMATEX, *PWAVEFORMATEX, *LPWAVEFORMATEX;
#ifndef _Embedded_x86
#pragma COMPILER_PACKALIGN_DEFAULT
#endif
#endif /* _WAVEFORMATEX_ */

#ifndef MMSYSERR_NOERROR
#define MMSYSERR_NOERROR     0
#define MMSYSERR_ERROR       1
#define MMSYSERR_NOMEM       7
#define MMSYSERR_READERROR   16
#define MMSYSERR_WRITEERROR  17
#endif /* MMSYSERR_NOERROR */

#ifndef WAVE_FORMAT_PCM
#define WAVE_FORMAT_PCM 1
#endif /* WAVE_FORMAT_PCM */

#else  /* WFIO_NO_WIN32 */

#include <mmsystem.h>
#include <mmreg.h>

#endif /* WFIO_NO_WIN32 */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

/* flag for WavFileIO */
enum
{
    wfioModeRead = 0,
    wfioModeWrite
};

/* ===========================================================================
 * WavFileIO struct
 */
typedef struct WavFileIO_tag
{
    I32      m_mode;

#if WFIO_NO_WIN32
    FILE    *m_fpWav;

    size_t   m_posRiffLength;
    size_t   m_posDataLength;
#else  /* WFIO_NO_WIN32 */
    HMMIO    m_hmmio;
    MMIOINFO m_mmioinfo;

    MMCKINFO m_ckWave;
    MMCKINFO m_ck;
#endif /* WFIO_NO_WIN32 */

    WAVEFORMATEX *m_pFormat;      /* but allocated using BYTEs...  */
    U32   m_sizeFormat;

    U32   m_sizeData;
    U32   m_posDataStart;

} WavFileIO;


/* ---------------------------------------------------------------------------
 * member functions
 */

WavFileIO * wfioNew();
void wfioDelete(WavFileIO *pwfio);

/* pFormat and cbFormat are only for writing... */
I32 wfioOpen(WavFileIO *pwfio, const char *szFile, WAVEFORMATEX *pFormat, U32 cbFormat, I32 mode);
void wfioClose(WavFileIO *pwfio);

/* origin can be SEEK_SET, SEEK_CUR, or SEEK_END */
I32 wfioSeek(WavFileIO *pwfio, I32 position, I32 origin);

I32 wfioRead(WavFileIO *pwfio, U8 *pBuf, I32 cbBuf);
I32 wfioWrite(WavFileIO *pwfio, U8 *pBuf, I32 cbBuf);

WAVEFORMATEX * wfioGetFormat(WavFileIO *pwfio);
U32 wfioGetFormatLength(WavFileIO *pwfio);

U32 wfioGetSampleSize(WavFileIO *pwfio);
U32 wfioGetDataLength(WavFileIO *pwfio);

I32 wfioGetMode(WavFileIO *pwfio);
I32 wfioIsOpened(WavFileIO *pwfio);

/* utility functions */
U16 adjustByteOrder16(U16 val);
U32 adjustByteOrder32(U32 val);

#ifdef __cplusplus
}
#endif  /* __cplusplus */


#endif /* _WAV_FILE_IO_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\wmcguids.h ===
#ifndef __WMCGUIDS__
#define __WMCGUIDS__

#include "wmc_type.h"

#ifndef EXTERN_C
# ifdef __cplusplus
#  define EXTERN_C extern "C"
# else
#  define EXTERN_C extern
# endif
#endif

#ifndef GUID_WMC_DEFINED
#define GUID_WMC_DEFINED
typedef struct _GUID_WMC {          // size is 16
    U32_WMC   Data1;
    U16_WMC    Data2;
    U16_WMC    Data3;
    U8_WMC    Data4[8];
} GUID_WMC;
#endif // GUID_WMC_DEFINED

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY  __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifdef INITGUID_WMC
#define DEFINE_GUID_WMC(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID_WMC DECLSPEC_SELECTANY name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#else // INITGUID_WMC
#define DEFINE_GUID_WMC(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID_WMC name
#endif // INITGUID_WMC

#ifndef IsEqualGUID_WMC
#define IsEqualGUID_WMC(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))
#endif // IsEqualGUID_WMC

DEFINE_GUID_WMC(CLSID_CAsfNullClockType,
    0x1d70b760,0x748e,0x11cf,0x9c,0x0f,0x00,0xa0,0xc9,0x03,0x49,0xcb);

DEFINE_GUID_WMC(CLSID_CAsfHeaderObjectV0,
    0x75b22630,0x668e,0x11cf,0xa6,0xd9,0x00,0xaa,0x00,0x62,0xce,0x6c);

DEFINE_GUID_WMC(CLSID_CAsfPropertiesObjectV0,
    0x75b22631,0x668e,0x11cf,0xa6,0xd9,0x00,0xaa,0x00,0x62,0xce,0x6c);

DEFINE_GUID_WMC(CLSID_CAsfPropertiesObjectV1,
    0x2df6b870,0x8836,0x11cf,0xa9,0x04,0x00,0x80,0x5f,0x5c,0x44,0x2b);

DEFINE_GUID_WMC(CLSID_CAsfPropertiesObjectV2, 
    0x8cabdca1, 0xa947, 0x11cf, 0x8e, 0xe4, 0x0, 0xc0, 0xc, 0x20, 0x53, 0x65);

DEFINE_GUID_WMC(CLSID_CAsfStreamPropertiesObjectV0,
    0x75b22632,0x668e,0x11cf,0xa6,0xd9,0x00,0xaa,0x00,0x62,0xce,0x6c);

DEFINE_GUID_WMC(CLSID_CAsfStreamPropertiesObjectV1, 
    0xb7dc0791, 0xa9b7, 0x11cf, 0x8e, 0xe6, 0x0, 0xc0, 0xc, 0x20, 0x53, 0x65);

DEFINE_GUID_WMC(CLSID_CAsfContentDescriptionObjectV0,
    0x75b22633,0x668e,0x11cf,0xa6,0xd9,0x00,0xaa,0x00,0x62,0xce,0x6c);

DEFINE_GUID_WMC(CLSID_CAsfMarkerObjectV0, 
    0xf487cd01, 0xa951, 0x11cf, 0x8e, 0xe6, 0x0, 0xc0, 0xc, 0x20, 0x53, 0x65);

DEFINE_GUID_WMC(CLSID_CAsfIndexObjectV0,
    0x75b22634,0x668e,0x11cf,0xa6,0xd9,0x00,0xaa,0x00,0x62,0xce,0x6c);

DEFINE_GUID_WMC(CLSID_CAsfIndexObjectV1, // obsolete
    0xdb92ea11, 0xa951, 0x11cf, 0x8e, 0xe6, 0x0, 0xc0, 0xc, 0x20, 0x53, 0x65);

DEFINE_GUID_WMC(CLSID_CAsfIndexObjectV2,
    0x33000890, 0xe5b1, 0x11cf, 0x89, 0xf4, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0xcb);

DEFINE_GUID_WMC(CLSID_CAsfErrorCorrectionObjectV0,
    0x75b22635,0x668e,0x11cf,0xa6,0xd9,0x00,0xaa,0x00,0x62,0xce,0x6c);

DEFINE_GUID_WMC(CLSID_CAsfDataObjectV0,
    0x75b22636,0x668e,0x11cf,0xa6,0xd9,0x00,0xaa,0x00,0x62,0xce,0x6c);

DEFINE_GUID_WMC(CLSID_CAsfFramesObjectV0,
    0x75b22637,0x668e,0x11cf,0xa6,0xd9,0x00,0xaa,0x00,0x62,0xce,0x6c);

DEFINE_GUID_WMC(CLSID_CAsfClockObjectV0, 
    0x5fbf03b5, 0xa92e, 0x11cf, 0x8e, 0xe3, 0x0, 0xc0, 0xc, 0x20, 0x53, 0x65);

DEFINE_GUID_WMC(CLSID_CAsfStreamRoutingObjectV0, 
    0x6ba83691, 0xb8d7, 0x11cf, 0x96, 0xc, 0x0, 0xa0, 0xc9, 0xa, 0x8e, 0x34);

// {1EFB1A30-0B62-11d0-A39B-00A0C90348F6}
DEFINE_GUID_WMC(CLSID_CAsfScriptCommandObjectV0,
    0x1efb1a30, 0xb62, 0x11d0, 0xa3, 0x9b, 0x0, 0xa0, 0xc9, 0x3, 0x48, 0xf6);

// {4B1ACBE3-100B-11d0-A39B-00A0C90348F6}
DEFINE_GUID_WMC(CLSID_AsfXScriptCommandIndex, 
            0x4b1acbe3,0x100b,0x11d0,0xa3,0x9b,0x0,0xa0,0xc9,0x3,0x48,0xf6);

// {86D15240-311D-11d0-A3A4-00A0C90348F6}
DEFINE_GUID_WMC(CLSID_CAsfCodecObjectV0, 
    0x86d15240, 0x311d, 0x11d0, 0xa3, 0xa4, 0x0, 0xa0, 0xc9, 0x3, 0x48, 0xf6);

//
// ASF Mutual Exclusion Object == {0xD6E229DC-35DA-11D1-9034-00A0C90349BE}
//
DEFINE_GUID_WMC( CLSID_CAsfMutualExclusionObject,
    0xD6E229DC, 0x35DA, 0x11D1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE );

//
// Same content different bitrates == {0xD6E22A01-35DA-11D1-9034-00A0C90349BE}
//
DEFINE_GUID_WMC( CLSID_SameContentDifferentBitrates,
    0xD6E22A01, 0x35DA, 0x11D1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE );

//
// ASF Extended Stream Properties Object == {7BF875CE-468D-11d1-8D82-006097C9A2B2}
//
DEFINE_GUID_WMC( CLSID_CAsfExtendedStreamPropertiesObject,
    0x7bf875ce, 0x468d, 0x11d1, 0x8d, 0x82, 0x0, 0x60, 0x97, 0xc9, 0xa2, 0xb2 );

//
// ASF Content Branding Object == {2211B3FA-BD23-11d2-B4B7-00A0C955FC6E}
//
DEFINE_GUID_WMC( CLSID_CAsfContentBrandingObject, 
    0x2211b3fa, 0xbd23, 0x11d2, 0xb4, 0xb7, 0x0, 0xa0, 0xc9, 0x55, 0xfc, 0x6e );

//
// ASF Content Encryption Object == {2211B3FB-BD23-11d2-B4B7-00A0C955FC6E}
//
DEFINE_GUID_WMC( CLSID_CAsfContentEncryptionObject, 
    0x2211b3fb, 0xbd23, 0x11d2, 0xb4, 0xb7, 0x0, 0xa0, 0xc9, 0x55, 0xfc, 0x6e );

DEFINE_GUID_WMC( CLSID_CAsfContentEncryptionObjectEx,
    0x298ae614, 0x2622, 0x4c17, 0xb9, 0x35, 0xda, 0xe0, 0x7e, 0xe9, 0x28, 0x9c);

//
// ASF Digital Signature Object == {2211B3FC-BD23-11d2-B4B7-00A0C955FC6E}
//
DEFINE_GUID_WMC( CLSID_CAsfDigitalSignatureObject, 
    0x2211b3fc, 0xbd23, 0x11d2, 0xb4, 0xb7, 0x0, 0xa0, 0xc9, 0x55, 0xfc, 0x6e );

//
// ASF Extended Content Desc Object == {D2D0A440-E307-11d2-97F0-00A0C95EA850}
//
DEFINE_GUID_WMC( CLSID_CAsfExtendedContentDescObject, 
    0xd2d0a440, 0xe307, 0x11d2, 0x97, 0xf0, 0x0, 0xa0, 0xc9, 0x5e, 0xa8, 0x50);

// Clock types

// {ABD3D211-A9BA-11cf-8EE6-00C00C205365}
DEFINE_GUID_WMC(CLSID_CAsfPacketClock1, 
    0xabd3d211, 0xa9ba, 0x11cf, 0x8e, 0xe6, 0x0, 0xc0, 0xc, 0x20, 0x53, 0x65);

// {ABD3D213-A9BA-11cf-8EE6-00C00C205365}
DEFINE_GUID_WMC(CLSID_CAsfPacketClock2, 
    0xabd3d213, 0xa9ba, 0x11cf, 0x8e, 0xe6, 0x0, 0xc0, 0xc, 0x20, 0x53, 0x65);

// {ABD3D214-A9BA-11cf-8EE6-00C00C205365}
DEFINE_GUID_WMC(CLSID_CAsfPacketClock3, 
    0xabd3d214, 0xa9ba, 0x11cf, 0x8e, 0xe6, 0x0, 0xc0, 0xc, 0x20, 0x53, 0x65);

// marker support
//
// {4CFEDB20-75F6-11cf-9C0F-00A0C90349CB}
DEFINE_GUID_WMC( CLSID_AsfXMarkerIndex, 0x4cfedb20, 0x75f6, 0x11cf, 0x9c, 0xf, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0xcb);

DEFINE_GUID_WMC( CLSID_CAsfLicenseStoreObject, 
    0x8fa7857b, 0xddc0, 0x11d3, 0xb6, 0xbd, 0x0, 0xc0, 0x4f, 0x61, 0xd, 0x62);


DEFINE_GUID_WMC(CLSID_AsfXNPlus1Parity,
    0x541d0f50,0x5b4b,0x11cf,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b);

/*
 * ======================================================================
 * A Null error masking strategy for use until we get smarter.
 * ======================================================================
 */

DEFINE_GUID_WMC(CLSID_AsfXNullErrorMaskingStrategy,
    0x20fb5700,0x5b55,0x11cf,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b);

DEFINE_GUID_WMC(CLSID_AsfXAcmAudioErrorMaskingStrategy,
    0xbfc3cd50,0x618f,0x11cf,0x8b,0xb2,0x00,0xaa,0x00,0xb4,0xe2,0x20);

// {49F1A440-4ECE-11d0-A3AC-00A0C90348F6}
DEFINE_GUID_WMC(CLSID_AsfXSignatureAudioErrorMaskingStrategy, 
    0x49f1a440, 0x4ece, 0x11d0, 0xa3, 0xac, 0x0, 0xa0, 0xc9, 0x3, 0x48, 0xf6);

DEFINE_GUID_WMC(CLSID_AsfXStreamTypeAcmAudio,
    0xf8699e40,0x5b4d,0x11cf,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b);

DEFINE_GUID_WMC(CLSID_AsfXStreamTypeUncompressedDibVideo,
    0x3725b2e0,0x5b4e,0x11cf,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b);

DEFINE_GUID_WMC(CLSID_AsfXStreamTypeIcmVideo,
    0xbc19efc0,0x5b4d,0x11cf,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b);

DEFINE_GUID_WMC(CLSID_AsfXStreamTypeJpegJfifVideo,
    0xb61be100,0x5b4e,0x11cf,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b);

DEFINE_GUID_WMC(CLSID_AsfXStreamTypeAnsiUrl,
    0x14082850,0x5b4f,0x11cf,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b);

DEFINE_GUID_WMC(CLSID_AsfXStreamTypeDegradableJpeg,
    0x35907de0,0xe415,0x11cf,0xa9,0x17,0x00,0x80,0x5f,0x5c,0x44,0x2b);

// {59DACFC0-59E6-11d0-A3AC-00A0C90348F6}
DEFINE_GUID_WMC(CLSID_AsfXStreamTypeScriptCommand, 
    0x59dacfc0, 0x59e6, 0x11d0, 0xa3, 0xac, 0x0, 0xa0, 0xc9, 0x3, 0x48, 0xf6);


// {86D15241-311D-11d0-A3A4-00A0C90348F6}
DEFINE_GUID_WMC(CLSID_AsfXCodecList, 
    0x86d15241, 0x311d, 0x11d0, 0xa3, 0xa4, 0x0, 0xa0, 0xc9, 0x3, 0x48, 0xf6);

//
// Good old SCR and duration clock license
//
// {97F6F860-747E-11cf-9C0F-00A0C90349CB}
DEFINE_GUID_WMC( CLSID_AsfXPacketClock, 0x97f6f860, 0x747e, 0x11cf, 0x9c, 0xf, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0xcb );

//DEFINE_GUID_WMC( CLSID_AsfXMetaDataObject, 0xa69609e7, 0x517b, 0x11d2, 0xb6, 0xaf, 0x00, 0xc0, 0x4f, 0xd9, 0x08, 0xe9 );

DEFINE_GUID_WMC( CLSID_AsfXMetaDataObject, 0xC5F8CBEA, 0x5BAF, 0x4877, 0x84, 0x67, 0xAA, 0x8C, 0x44, 0xFA, 0x4C, 0xCA );


#endif //__ASFGUIDS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\wmcdecode.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 2001

Module Name:

    wmcdecode.h

Abstract:

    API's for WMC SDK Decoder.

Revision History:

*************************************************************************/

#ifndef _WMC_DECODE_H_
#define _WMC_DECODE_H_

#include "wmc_type.h"

#if defined (macintosh) || defined (HITACHI)
#include "wmMacSp.h"
#endif 

#ifdef __cplusplus
extern "C" {
#endif 


#define CHECK_NONSDMI_LIC	1
#define CHECK_SDMI_LIC		2
#define CHECK_ALL_LICENSE	3
#define WMC_LICENCE_DATA_REQUESTED  172


typedef struct tagWMCDecFileLicParams
{
    U8_WMC *pPMID;       /* portable media id */
    U32_WMC cbPMID;      /* length of the pPMID buffer */

} tWMCDecFileLicParams;

typedef enum tWMCDecStatus
{
    WMCDec_Succeeded = 0,
    WMCDec_BadAsfHeader,
    WMCDec_BadPacketHeader,
    WMCDec_BadMemory,
    WMCDec_InValidArguments,
    WMCDec_InproperOutputType,
	WMCDec_UnSupportedCompressedFormats,
	WMCDec_NoOutput,

    WMADec_Failed,
    WMADec_BadMemory,
    WMADec_UnSupportedCompressedFormat,
    WMADec_InValidArguments,
    WMADec_BadSource,
    WMADec_BrokenFrame,
    WMADec_NoMoreOutput,

    WMVDec_Failed,
    WMVDec_BadMemory,
    WMVDec_UnSupportedCompressedFormat,
    WMVDec_UnSupportedOutputFormat,
    WMVDec_InValidArguments,
    WMVDec_BadSource,
    WMVDec_BrokenFrame,
    WMVDec_NoMoreOutput,
    WMVDec_NoKeyFrameDecoded,
    WMVDec_CorruptedBits,

    WMBDec_Failed,
    WMBDec_BadMemory,
    
    WMCDec_DRMFail,
    WMCDec_DRMInitFail,
    WMCDec_Fail,
    WMCDec_BufferTooSmall,
    WMCDec_BadData,
    WMCDec_InvalidStreamType,
    WMCDec_DecodeComplete,
    WMCDec_InvalidIndex

} tWMCDecStatus;

typedef void * HWMCDECODER;
typedef void * HDRMMGR;

/*
 *        WMCDecCreate
 *        =============
 *
 * Description
 * -----------
 *   This function Create the decoder object. Must be called before calling any function.
 * 
 *
 * Syntax
 * ------
 *   HWMCDECODER WMCDecCreate (U32_WMC u32UserContext);
 *
 *
 * where:
 * 
 * u32UserContext   Anydata need to pass to WMCDecCBGetData
 *
 * Return Value
 * ------------
 *   WMC decoder object, NULL if there is an error.            
 *
 */
HWMCDECODER WMCDecCreate (U32_WMC u32UserContext);

/*
 *        WMCDecInit
 *        =============
 *
 * Description
 * -----------
 *   This function initializes the decoder object. Must be called before calling any function.
 * 
 *
 * Syntax
 * ------
 *   tWMCDecStatus WMCDecInit (HWMCDECODER* phWMCDec, tVideoFormat_WMC tVideoOutputFormat, Bool_WMC bDiscardIndex,I32_WMC iPostProcLevel);
 *
 *
 * where:
 *
 *   phWMCDec		        Pointer to the decoder object HWMCDECODER..
 *   tVideoOutputFormat	    Output Video Format defined in wmc_types.h
 *   bDiscardIndex          If TRUE then Index will not be read. It should be true if you cannot seek to the end of file
 *							to read Index ( One case is when you are streaming from network ). If it is true, SEEK may 
 *							not work precisely.
 *   iPostProcLevel         Post proc level for Video
 *							-1 : Let decoder decide post processing
 *							0: No post processing
 *							1 -4 : different levels of post processing
 *
 * Return Value
 * ------------
 *   Error code. WMCDec_Succeeded if succeeds.          
 *
 */
tWMCDecStatus WMCDecInit (HWMCDECODER* phWMCDec, tVideoFormat_WMC tVideoOutputFormat, Bool_WMC bDiscardIndex,I32_WMC iPostProcLevel);

/*
 *        WMCDecGetHeaderInfo
 *        =============
 *
 * Description
 * -----------
 *   This function gives the header information of asf file.
 * 
 *
 * Syntax
 * ------
 *   tWMCDecStatus WMCDecGetHeaderInfo (HWMCDECODER hWMCDec, strHeaderInfo_WMC* pstrHeaderInfo);
 *
 *
 * where:
 *
 *   phWMCDec		        Decoder object HWMCDECODER..
 *   pstrHeaderInfo			Pointer to a structure for getting header info. It is defined in wmc_types.h
 *
 * Return Value
 * ------------
 *   Error code. WMCDec_Succeeded if succeeds.          
 *
 */


tWMCDecStatus WMCDecGetHeaderInfo (HWMCDECODER hWMCDec, strHeaderInfo_WMC* pstrHeaderInfo);

/*
 *        WMCDecGetStreamInfo
 *        ======================
 *
 * Description
 * -----------
 *   Get the audio and video information of the ASF stream/file.
 * 
 *
 * Syntax
 * ------
 *   tWMCDecStatus WMCDecGetStreamInfo (HWMCDECODER hWMCDec, U32_WMC* pnNumStreams, tStreamIdnMediaType_WMC** pptMediaTypeStreams);
 *
 *
 * where:
 *
 *   hWMCDec		            Decoder object HWMCDECODER.
 *   pnNumStreams	            Pointer to an indtger. The decoder fills in this value with number of streams.
 *   pptMediaTypeStreams        Pointer to the array pointer. The decoder return an array of tStreamIdnMediaType_WMC.
 *
 * Return Value
 * ------------
 *   Error code. WMCDec_Succeeded if succeeds.          
 *
 */
tWMCDecStatus WMCDecGetStreamInfo (HWMCDECODER hWMCDec, U32_WMC* pnNumStreams, tStreamIdnMediaType_WMC** pptMediaTypeStreams);

/*
 *        WMCDecSetDecodePatternForStreams
 *        ================================
 *
 * Description
 * -----------
 *   Sets the Decoding pattern for all multimedia streams in the file. Each stream can be set for Decompressed_WMC or 
 *   Compressed_WMC or Discard_WMC. Must be called before start decoding. If the codec is not supported, and application asked
 *   for Decompressed_WMC, it will not give any output.
 * 
 *
 * Syntax
 * ------
 *   tWMCDecStatus WMCDecSetDecodePatternForStreams (HWMCDECODER* phWMCDec, const tStreamIdPattern_WMC* ptStreamDecodePattern);
 *
 *
 * where:
 *
 *   hWMCDec		            Pointer to the decoder object HWMCDECODER.
 *   ptStreamDecodePattern      Pointer to the array of tStreamIdPattern_WMC structure which contains pattern for each stream.
 *                              The structure tStreamIdPattern_WMC is defined in wmc_types.h.
 *
 * Return Value
 * ------------
 *   Error code. WMCDec_Succeeded if succeeds.          
 *
 */
tWMCDecStatus WMCDecSetDecodePatternForStreams (HWMCDECODER* phWMCDec, const tStreamIdPattern_WMC* ptStreamDecodePattern);

/*
 *        WMCDecGetAudioInfo
 *        =============
 *
 * Description
 * -----------
 *   This function gives the Audio Stream information.
 * 
 *
 * Syntax
 * ------
 *   tWMCDecStatus WMCDecGetAudioInfo (HWMCDECODER hWMCDec, U32_WMC nStreamNum, strAudioInfo_WMC* pstrAudioInfo);
 *
 *
 * where:
 *
 *   phWMCDec		        Decoder object HWMCDECODER.
 *   nStreamNum				Stream Id
 *   pstrAudioInfo			Pointer to a structure for getting Audio info. It is defined in wmc_types.h
 *
 * Return Value
 * ------------
 *   Error code. WMCDec_Succeeded if succeeds.WMCDec_InValidArguments if nStreamNum is not Audio          
 *
 */

tWMCDecStatus WMCDecGetAudioInfo (HWMCDECODER hWMCDec, U32_WMC nStreamNum, strAudioInfo_WMC* pstrAudioInfo);

/*
 *        WMCDecGetVideoInfo
 *        =============
 *
 * Description
 * -----------
 *   This function gives the Video Stream information.
 * 
 *
 * Syntax
 * ------
 *   tWMCDecStatus WMCDecGetVideoInfo (HWMCDECODER hWMCDec, U32_WMC nStreamNum, strVideoInfo_WMC* pstrVideoInfo);
 *
 *
 * where:
 *
 *   phWMCDec		        Decoder object HWMCDECODER.
 *   nStreamNum				Stream Id
 *   pstrVideoInfo			Pointer to a structure for getting Video info. It is defined in wmc_types.h
 *
 * Return Value
 * ------------
 *   Error code. WMCDec_Succeeded if succeeds.WMCDec_InValidArguments if nStreamNum is not Video          
 *
 */

tWMCDecStatus WMCDecGetVideoInfo (HWMCDECODER hWMCDec, U32_WMC nStreamNum, strVideoInfo_WMC* pstrVideoInfo);

/*
 *        WMCDecGetBinaryInfo
 *        =============
 *
 * Description
 * -----------
 *   This function gives the Binary Stream information.
 * 
 *
 * Syntax
 * ------
 *   tWMCDecStatus WMCDecGetBinaryInfo (HWMCDECODER hWMCDec, U32_WMC nStreamNum, strBinaryInfo_WMC* pstrBinaryInfo);
 *
 *
 * where:
 *
 *   phWMCDec		        Decoder object HWMCDECODER.
 *   nStreamNum				Stream Id
 *   pstrBinaryInfo			Pointer to a structure for getting Binary info. It is defined in wmc_types.h
 *
 * Return Value
 * ------------
 *   Error code. WMCDec_Succeeded if succeeds.WMCDec_InValidArguments if nStreamNum is not Binary          
 *
 */


tWMCDecStatus WMCDecGetBinaryInfo (HWMCDECODER hWMCDec, U32_WMC nStreamNum, strBinaryInfo_WMC* pstrBinaryInfo);


/*
 *        WMCDecSetVideoOutputFormat
 *        ==========================
 *
 * Description
 * -----------
 *   This function sets the output format for all video streams. Must be set before decoding.
 * 
 *
 * Syntax
 * ------
 *   tWMCDecStatus WMCDecSetVideoOutputFormat (HWMCDECODER hWMCDec, tVideoFormat_WMC tVideoOutputFormat);
 *
 *
 * where:
 *
 *   phWMCDec		        Decoder object HWMCDECODER.
 *   tVideoOutputFormat		Output Format.tVideoFormat_WMC is defined in wmc_types.h and 
 *							contains the valid uncompressed formats.
 *
 * Return Value
 * ------------
 *   Error code. WMCDec_Succeeded if succeeds.WMVDec_UnSupportedOutputFormat if output format is not supported          
 *
 */

tWMCDecStatus WMCDecSetVideoOutputFormat (HWMCDECODER hWMCDec, tVideoFormat_WMC tVideoOutputFormat);


/*
 *        WMCDecDecodeData
 *        =========
 *
 * Description
 * -----------
 * This function decodes the packets of the input file.
 * Parses the packet and calls Audio/Video decoders (depending on packet info). 
 * 
 *
 * Syntax
 * ------
 *   tWMCDecStatus WMCDecDecodeData (HWMCDECODER hWMCDec, U32_WMC* pnStreamReadyForOutput, U32_WMC* pnNumberOfSamples, I32_WMC iHurryUp);
 *
 *
 * where:
 *
 *   hWMCDec		            Decoder object HWMCDECODER.
 *   pnStreamReadyForOutput
 *   pnNumberOfSamples          the number of samples decoded for this call for pnStreamReadyForOutput.
 *                              For Video, it is in number of frames.
 *                              For Audio, it is in number of samples.
 *                              For binary stream or compressed output, it is in number of bytes.
 *
 *	iHurryUp					It is used for Video. Value is from -2 to +2. -2 is slower, 0 is no hurry up and +2 is faster.
 * Return Value
 * ------------
 *   WMCDec_Succeeded           OK and there are more packets to be decoded.
 *	 WMCDec_DecodeComplete	    When all packets are decoded.
 *   WMCDec_InValidArguments    bad argument(s)
 *	 WMCDec_Fail			    Error   
 *
 */
tWMCDecStatus WMCDecDecodeData (HWMCDECODER hWMCDec, U32_WMC* pnStreamReadyForOutput, U32_WMC* pnNumberOfSamples, I32_WMC iHurryUp);

/*
 *       WMCDecGetAudioOutput
 *       =============
 *
 * Description
 * -----------
 * Write PCM samples from the WMAudio bitstream previously decoded by
 * WMCDecDecodeData().
 *
 *
 * Syntax
 * ------
 *   tWMCDecStatus WMCDecGetAudioOutput (HWMCDECODER hWMCDec, I16_WMC *pi16Channel0, 
 *                        I16_WMC* pi16Channel1, U32_WMC nNumSamplesRequest, 
 *                       U32_WMC* nNumSamplesReturn, I64_WMC* ptPresentationTime);
 *
 *
 * where:
 *
 *   
 *   hWMCDec            Decoder object HWMCDECODER.
 *   pi16Channel0       pointer to output buffer for left-channel PCM, or the entire PCM output if it is inter-leaved form
 *   pi16Channel1       pointer to output buffer for right-channel PCM, NULL if the output PCM is in parallel form
 *   nNumSamplesRequest Number of samples request
 *   nNumSamplesReturn  Pointer to actual sample return
 *   ptPresentationTime TimeStamp for the output
 *
 * Return Value
 * ------------
 *   WMCDec_Succeeded			OK
 *   WMADec_Failed				Error     
 *   WMCDec_InValidArguments    bad argument(s)
 */
tWMCDecStatus WMCDecGetAudioOutput (
    HWMCDECODER hWMCDec,
    I16_WMC *pi16Channel0, I16_WMC* pi16Channel1,
    U32_WMC nNumSamplesRequest, U32_WMC* nNumSamplesReturn,
    I64_WMC* ptPresentationTime
);

/*
 *       WMCDecGetVideoOutput
 *       =============
 *
 * Description
 * -----------
 * Write Video Frame from the Video bitstream previously decoded by
 * WMCDecDecodeData().
 *
 *
 * Syntax
 * ------
 *   tWMCDecStatus WMCDecGetVideoOutput (HWMCDECODER hWMCDec, U8_WMC *pu8VideoOutBuffer, U32_WMC u32VideoOutBufferSize, U32_WMC * pu32OutDataSize, I64_WMC* ptPresentationTime, Bool_WMC *bIsKeyFrame, tWMCDecodeDispRotateDegree tDispRotateDegree);
 *
 *
 * where:
 *
 *   
 *   
 *   hWMCDec                Decoder object HWMCDECODER.
 *   pu8VideoOutBuffer      pointer to output buffer.
 *   u32VideoOutBufferSize  Size of output buffer
 *   pu32OutDataSize        Point to return data size
 *   ptPresentationTime     TimeStamp for the output
 *   bIsKeyFrame            Pointer to get whether the current output farme is key frame or not
 *	 tDispRotateDegree      Video rotataion. It is defined in wmc_types.h 
 *
 * Return Value
 * ------------
 *   WMCDec_Succeeded			OK
 *   WMVDec_Failed				Error     
 *   WMCDec_InValidArguments    bad argument(s)
 *   WMVDec_BrokenFrame         If frame is broken.
 */
tWMCDecStatus WMCDecGetVideoOutput (HWMCDECODER hWMCDec, U8_WMC *pu8VideoOutBuffer, U32_WMC u32VideoOutBufferSize, U32_WMC * pu32OutDataSize, I64_WMC* ptPresentationTime, Bool_WMC *bIsKeyFrame, tWMCDecodeDispRotateDegree tDispRotateDegree);

/*
 *       WMCDecGetBinaryOutput
 *       =============
 *
 * Description
 * -----------
 * Write Binary samples from the Binary bitstream previously decoded by
 * WMCDecDecodeData().
 *
 *
 * Syntax
 * ------
 * tWMCDecStatus WMCDecGetBinaryOutput (HWMCDECODER hWMCDec, U8_WMC *pu8BinaryOutBuffer,
 *               U32_WMC nSizeRequest, U32_WMC* pnSizeReturn, I64_WMC* ptPresentationTime);
 *
 *
 * where:
 *
 *   
 *   
 *   hWMCDec                Decoder object HWMCDECODER.
 *   pu8BinaryOutBuffer     pointer to output buffer.
 *   nSizeRequest           Size of data request
 *   pnSizeReturn           Point to return data size
 *   ptPresentationTime     TimeStamp for the output
 *
 * Return Value
 * ------------
 *   WMCDec_Succeeded			OK
 *   WMCDec_InValidArguments    bad argument(s)
 *
 */

tWMCDecStatus WMCDecGetBinaryOutput (
    HWMCDECODER hWMCDec, 
    U8_WMC *pu8BinaryOutBuffer,
    U32_WMC nSizeRequest, U32_WMC* pnSizeReturn,
    I64_WMC* ptPresentationTime
);

/*
 *        WMCDecodeSeek
 *        =============
 *
 * Description
 * -----------
 * Seek to the location of time specified by u64TimeRequest.  
 * 
 *
 * Syntax
 * ------
 *  tWMCDecStatus WMCDecSeek (HWMCDECODER hWMCDec, U64_WMC u64TimeRequest, U64_WMC* pu64TimeReturn);
 *
 * where:
 *
 *   hWMCDec                   Decoder object HWMCDECODER 
 *   u64TimeRequest            Request time in ms.
 *   pu64TimeReturn            Actual time in ms.
 *
 * Return Value
 * ------------
 *   WMCDec_Succeeded			OK
 *   WMCDec_InValidArguments    bad argument(s)
 *
 */
tWMCDecStatus WMCDecSeek (HWMCDECODER hWMCDec, U64_WMC u64TimeRequest, U64_WMC* pu64TimeReturn);

/*
 *        WMCDecodeClose
 *        ================
 *
 * Description
 * -----------
 * Closes the decoder object and releases all the buffers.
 * 
 *
 * Syntax
 * ------
 *   tWMCDecStatus WMCDecClose (HWMCDECODER* phWMCDec);
 *
 * where:
 *
 *   phWMCDec		            Pointer to the decoder object HWMCDECODER.
 *
 * Return Value
 * ------------
 *   WMCDec_Succeeded			OK
 *   WMCDec_InValidArguments    bad argument(s)
 *   
 *
 */
tWMCDecStatus WMCDecClose (HWMCDECODER* phWMCDec);

/*
 *       WMCDecGetContentDesc
 *       =================
 * Description
 * -----------
 * Retrieves the content descriptions for the ASF file.  Not all ASF files have Content Descriptions.
 *
 * Syntax
 * ------
 * tWMCDecStatus WMCDecGetContentDesc (HWMCDECODER hWMCDec, const WMCContentDescription **ppDesc);
 *
 * where:
 *
 *   hWMCDec		            Decoder object HWMCDECODER.
 *   ppDesc                     Pointer of the pointer to the structure that
 *                              holds the ASF file content description info
 *                              (defined in wmc_type.h)
 *
 * Return Value
 * ------------
 *   WMCDec_Succeeded			OK
 *   WMCDec_InValidArguments    bad argument(s)
 *   pDesc is the pointer of pointer to the ASF extended content desc object. 
 ***** DO NOT RELEASE THIS POINTER *************   
 *
 */

tWMCDecStatus WMCDecGetContentDesc (HWMCDECODER hWMCDec, const WMCContentDescription **ppDesc);


/*		WMCGetExtendedContentDesc
 *      ==========================   
 *
 * Description
 * -----------
 * Retrieves the extended content descriptions for the ASF file.
 * Not all ASF files have extended content descriptions.
 *
 * Syntax
 * ------
 * tWMCDecStatus WMCDecGetExtendedContentDesc (HWMCDECODER hWMCDec, const WMCExtendedContentDesc **ppECDesc);
 *
 * where:
 *
 *   hWMCDec		            Decoder object HWMFDECODER.
 *   ppECDesc                   Pointer of pointer to the structure that holds
 *                              in the ASF file extended content description
 *                              info (defined in wmc_type.h)
 *
 * Return Value
 * ------------
 *   WMCDec_Succeeded			OK
 *   WMCDec_InValidArguments    bad argument(s)
 *   pECDesc is the pointer of pointer to the ASF extended content desc object. 
 ***** DO NOT RELEASE THIS POINTER *************   
 */
tWMCDecStatus WMCDecGetExtendedContentDesc (HWMCDECODER hWMCDec, const WMCExtendedContentDesc **ppECDesc);

/*
 *        WMCGetScriptCommand
 *
 * Description
 * -----------
 * Retrieves the script command for the ASF file.
 * Not all ASF files have script commands.
 *
 *
 * Syntax
 * ------
 * tWMCDecStatus WMCGetScriptCommand (HWMCDECODER hWMCDec, const WMCScriptCommand **ppSCObject);
 *
 * where:
 *
 *   hWMCDec		            Decoder object HWMFDECODER.
 *   ppSCObject                 Pointer of pointer to the structure that holds
 *                              the ASF file script command info (defined in
 *                              wmc_type.h)
 *
 * Return Value
 * ------------
 *   WMCDec_Succeeded			OK
 *   WMCDec_InValidArguments    bad argument(s)
 *   pSCObject is the pointer of pointer to the ASF script command object  
 ***** DO NOT RELEASE THIS POINTER *************   
 *
 */
tWMCDecStatus WMCGetScriptCommand (HWMCDECODER hWMCDec, const WMCScriptCommand **ppSCObject);

/*
 *       WMCGetNumberOfMarkers  
 *       =======================
 *
 * Description
 * -----------
 * Return the number of Markers for the ASF file.  
 *
 * Not all ASF files have content descriptions.
 *
 * Syntax
 * ------
 *   tWMCDecStatus WMCDecGetNumberOfMarkers (HWMCDECODER hWMCDec, U16_WMC *pu16NumMarkers);  
 *
 * where:
 *
 *   hWMCDec		            Decoder object HWMCDECODER.
 *   pu16NumMarkers				Pointer to U16_WMC where it will receive the number of markers.
 *
 * Return Value
 * ------------
 *   WMCDec_Succeeded			OK
 *   WMCDec_InValidArguments    bad argument(s)
 *
 */
tWMCDecStatus WMCDecGetNumberOfMarkers (HWMCDECODER hWMCDec, U16_WMC *pu16NumMarkers);

/*
 *       WMCGetMarker
 *       =======================
 *
 * Description
 * -----------
 * Retrieves the Marker in the ASF file spicifed by an index .  
 *
 * Not all ASF files have content descriptions.
 *
 * Syntax
 * ------
 *   tWMCDecStatus WMCDecGetMarker (HWMCDECODER hWMCDec, U16_WMC iIndex, WMCMarkerEntry *pEntry); 
 *
 * where:
 *
 *   hWMCDec		            Decoder object HWMCDECODER.
 *   iIndex                     index specifying which Marker to get
 *   pEntry                     pointer the structure allocated by the application for holding the
 *                              marker spefified by iIndex.
 *
 * Return Value
 * ------------
 *   WMCDec_Succeeded			OK
 *   WMCDec_InValidArguments    bad argument(s)
 *   WMCDec_Fail				Error
 *
 ***** DO NOT RELEASE THIS POINTER *************   
 */
tWMCDecStatus WMCDecGetMarker (HWMCDECODER hWMCDec, U16_WMC iIndex, WMCMarkerEntry *pEntry); 

/*
 *       WMCSkipToNextKey
 *       =======================
 *
 * Description
 * -----------
 * Skips to next Key Frame while decoding  
 *
 * 
 * Syntax
 * ------
 *   tWMCDecStatus WMCSkipToNextKey (HWMCDECODER hWMCDec);
 *
 * where:
 *
 *   hWMCDec		            Decoder object HWMCDECODER.
 *
 * Return Value
 * ------------
 *   WMCDec_Succeeded			OK
 *   WMCDec_InValidArguments    bad argument(s)
 *
 */

tWMCDecStatus WMCSkipToNextKey (HWMCDECODER hWMCDec);

/*
 *        WMCDecCBGetData
 *        ==================
 *
 * Description
 * -----------
 * Its a callback function from the SDK to get the ASF data for decoding.
 * This is not implemented by the SDK. It should be implemented by the app that calls the SDK.
 * 
 *
 * Syntax
 * ------
 *  extern U32_WMC WMCDecCBGetData (HWMCDECODER hWMCDec, U64_WMC nOffset, U32_WMC nNumBytesRequest
 *                                  U8_WMC **ppData,    U32_WMC u32UserData);
 *
 *
 * where:
 *
 *   hWMCDec				 Decoder object HWMCDECODER.
 *   U64_WMC nOffset         Offset of the requested data (from beginning),
 *   nNumBytesRequest        Size of the requested data (in bytes).
 *   ppData                  Pointer to the buffer for filling in the ASF data
 *   u32UserData             Extra info From App. Given by user in WMCDecCreate().
 *
 * Return Value
 * ------------
 *   The number of bytes actually being filled in            
 *   
 *
 */
extern U32_WMC WMCDecCBGetData (
    HWMCDECODER hWMCDec,
    U64_WMC nOffset,
    U32_WMC nNumBytesRequest/*, U32_WMC* pnNumBytesReturn*/,
    U8_WMC **ppData,
    U32_WMC u32UserData
);

/*
 *       WMCDecGetCodecCount  
 *       =======================
 *
 * Description
 * -----------
 * Return the number of Codecs Used in the ASF file.  
 *
 * All ASF files may not contain CodecListObject.
 *
 * Syntax
 * ------
 *   tWMCDecStatus WMCDecGetCodecCount (HWMCDECODER hWMCDec, U32_WMC * pnNumCodec);
 *
 * where:
 *
 *   hWMCDec		            Decoder object HWMCDECODER.
 *   pnNumCodec				    Pointer to U32_WMC where it will receive the number of codecs.
 *
 * Return Value
 * ------------
 *   WMCDec_Succeeded			OK
 *   WMCDec_InValidArguments    bad argument(s)
 *
 */

tWMCDecStatus WMCDecGetCodecCount (HWMCDECODER hWMCDec, U32_WMC * pnNumCodec);

/*
 *       WMCDecGetCodecEntry
 *       =======================
 *
 * Description
 * -----------
 * Retrieves the Codecs Description in the ASF file spicifed by an index .  
 *
 * 
 *
 * Syntax
 * ------
 *   tWMCDecStatus WMCDecGetCodecEntry (HWMCDECODER hWMCDec, U16_WMC iIndex, WMCCodecEntry *pEntry); 
 *
 * where:
 *
 *   hWMCDec		            Decoder object HWMCDECODER.
 *   iIndex                     index specifying which Codec Description to get
 *   pEntry                     pointer the structure allocated by the application for holding the
 *                              Codec Description spefified by iIndex.
 *
 * Return Value
 * ------------
 *   WMCDec_Succeeded			OK
 *   WMCDec_InValidArguments    bad argument(s)
 *   WMCDec_Fail				Error
 *
 ***** DO NOT RELEASE THIS POINTER *************   
 */

tWMCDecStatus WMCDecGetCodecEntry (HWMCDECODER hWMCDec, U16_WMC iIndex, WMCCodecEntry *pEntry); 

#ifdef __cplusplus
}
#endif 




#endif // _WMC_DECODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\wmc_type.h ===
#ifndef _WMC_TYPES_H_
#define _WMC_TYPES_H_

/*********  Basic type Definitions  *************/

#ifndef WMC_TYPE_DEFINED
#define WMC_TYPE_DEFINED

typedef void Void_WMC;
typedef long I32_WMC;
typedef unsigned long U32_WMC;
typedef short I16_WMC;
typedef unsigned short U16_WMC;

#if defined(_Embedded_x86)
typedef unsigned short U16Char_WMC;
#elif defined(macintosh)
typedef wchar_t U16Char_WMC;
#else
typedef unsigned short U16Char_WMC;
#endif

typedef char I8_WMC;
typedef unsigned char U8_WMC;
typedef long Bool_WMC;
typedef double Double_WMC;
typedef float Float_WMC;
typedef struct tQWORD_WMC
{
    U32_WMC   dwLo;
    U32_WMC   dwHi;

}   QWORD_WMC;

#ifdef macintosh
typedef unsigned long long QWORD;
#endif

#ifdef _XBOX
typedef unsigned __int64    U64_WMC;
typedef __int64    I64_WMC;
#elif defined(macintosh) || defined(_Embedded_x86)
typedef unsigned long long  U64_WMC;
typedef long long  I64_WMC;
#elif defined(HITACHI)
typedef struct tU64_WMC
{
    U32_WMC   dwLo;
    U32_WMC   dwHi;
}   U64_WMC;
typedef struct tI64_WMC
{
    I32_WMC   dwLo;
    I32_WMC   dwHi;
}   I64_WMC;
#else
typedef unsigned __int64    U64_WMC;
typedef __int64    I64_WMC;
#endif

typedef struct tRect_WMC
{
    I32_WMC iLeft;
    I32_WMC iTop;
    I32_WMC iRight;
    I32_WMC iBottom;
}   Rect_WMC;

#define TRUE_WMC    1
#define FALSE_WMC   0
#define NULL_WMC   0
#define MIN_WANTED 512
typedef void * HWMCFILE;
typedef enum tagMediaType_WMC
{
    Audio_WMC, 
    Video_WMC, 
    Binary_WMC
} tMediaType_WMC;



typedef struct tagStreamIdnMediaType_WMC
{
    U16_WMC wStreamId;
    tMediaType_WMC MediaType;
} tStreamIdnMediaType_WMC;


typedef enum tagOutputType_WMC
{
    Discard_WMC,
    Compressed_WMC, 
    Decompressed_WMC
} tOutputType_WMC;
/************************************************************************/
#ifndef MAKEFOURCC_WMC
#define MAKEFOURCC_WMC(ch0, ch1, ch2, ch3) \
        ((U32_WMC)(U8_WMC)(ch0) | ((U32_WMC)(U8_WMC)(ch1) << 8) |   \
        ((U32_WMC)(U8_WMC)(ch2) << 16) | ((U32_WMC)(U8_WMC)(ch3) << 24 ))

#define mmioFOURCC_WMC(ch0, ch1, ch2, ch3)  MAKEFOURCC_WMC(ch0, ch1, ch2, ch3)
#endif




/******* video output type guids, in preference order  *****/
#define FOURCC_WMV3     mmioFOURCC_WMC('W','M','V','3')
#define FOURCC_WMV2     mmioFOURCC_WMC('W','M','V','2')
#define FOURCC_WMV1     mmioFOURCC_WMC('W','M','V','1')
#define FOURCC_M4S2     mmioFOURCC_WMC('M','4','S','2')
#define FOURCC_MP43     mmioFOURCC_WMC('M','P','4','3')
#define FOURCC_mp43     mmioFOURCC_WMC('m','m','4','3')
#define FOURCC_MP4S     mmioFOURCC_WMC('M','P','4','S')
#define FOURCC_mp4s     mmioFOURCC_WMC('m','p','4','s')
#define FOURCC_MP42     mmioFOURCC_WMC('M','P','4','2')
#define FOURCC_mp42     mmioFOURCC_WMC('m','m','4','2')
#define FOURCC_MSS1     mmioFOURCC_WMC('M','S','S','1')
#define FOURCC_MSS2     mmioFOURCC_WMC('M','S','S','2')
#define FOURCC_WMS2     mmioFOURCC_WMC('W','M','S','2')
#define FOURCC_WMS1     mmioFOURCC_WMC('W','M','S','1')
#define FOURCC_MPG4     mmioFOURCC_WMC('M','P','G','4')
#define FOURCC_MSS1     mmioFOURCC_WMC('M','S','S','1')
#define FOURCC_MSS2     mmioFOURCC_WMC('M','S','S','2')

/***********************************************************/


/******* video intput type guids, in preference order  *****/

#define FOURCC_I420		        0x30323449
#define FOURCC_IYUV		        0x56555949
#define FOURCC_YV12		        0x32315659
#define FOURCC_YUY2		        0x32595559
#define FOURCC_UYVY		        0x59565955
#define FOURCC_YVYU		        0x55595659
#define FOURCC_YVU9		        0x39555659
#define FOURCC_BI_RGB   	    0x00000000
#define FOURCC_BI_BITFIELDS	    0x00000003
#define FOURCC_BI_RLE8   	    0x00000001
#define FOURCC_BI_RLE4   	    0x00000002


////////////////////////////////////////////

#define WAVE_FORMAT_PCM_WMC     0x0001
#define WAVE_FORMAT_WMA1_WMC    0x0160
#define WAVE_FORMAT_WMA8_WMC    0x0161
#define WAVE_FORMAT_WMA9_WMC    0x0162
#define WAVE_FORMAT_WMSP9_WMC    0x000A

///////////////////////////////////////////

typedef struct tagStreamIdPattern_WMC
{
    U16_WMC wStreamId;
    tOutputType_WMC tPattern;
} tStreamIdPattern_WMC;

typedef struct tagPlannedOutputId_WMC
{
    U16_WMC wStreamIndex;
    tMediaType_WMC tMediaType;
	Bool_WMC	bDone;
} tPlannedOutputId_WMC;

typedef struct tagPlannedOutput_WMC
{
    U16_WMC wTotalOutput;
    tPlannedOutputId_WMC tPlannedId[127];
} tPlannedOutputWMC;




typedef enum tagVideoFormat_WMC
{
    // uncompressed
    YUY2_WMV, 
    UYVY_WMV, 
    YVYU_WMV, 
    RGB24_WMV, 
    RGB555_WMV, 
    RGB565_WMV, 
    RGB32_WMV, 
    RGB8_WMV, 
    IYUV_WMV, 
    I420_WMV, 
    YVU9_WMV, 

    // compressed
    WMV2_WMV, 
    WMV1_WMV, 

	// Ignore Audio Only
	IGNORE_VIDEO
	/*
    WMS2_WMV, 
    WMS1_WMV, 
    M4S2_WMV, 
    MP4S_WMV, 
    MP43_WMV, 
    MP42_WMV, 
    MPG4_WMV
*/
} tVideoFormat_WMC;

typedef enum tagWMCDecodeDispRotateDegree
{
    WMC_DispRotate0 = 0,
    WMC_DispRotate90,
    WMC_DispFlip,
    WMC_DispRotate270
} tWMCDecodeDispRotateDegree;



typedef enum tagAudioType_WMC
{
    // uncompressed
    PCM_WMA, 
    WMA3_WMA, 
    WMA2_WMA, 
    WMA1_WMA
} tAudioType_WMC;


typedef struct strAudioStreamInfo_WMC
{
    U16_WMC         u16FormatTag;
    U32_WMC         u32BitsPerSecond;
    U16_WMC         u16BitsPerSample;
    U16_WMC         u16SamplesPerSecond;
    U16_WMC         u16NumChannels;
    U32_WMC         u32BlockSize;
    U16_WMC         u16ValidBitsPerSample; // bits of precision 
    U32_WMC         u32ChannelMask;       // which channels are present in stream 
    U16_WMC         u16StreamId;

} strAudioInfo_WMC;

typedef struct strVideoStreamInfo_WMC
{
    U32_WMC           u32Compression; 
    U32_WMC           u32BitsPerSecond;
    Float_WMC         fltFramesPerSecond; //is always 0
    I32_WMC           i32Width;
    I32_WMC           i32Height;
    U8_WMC            bPalette[3*256]; // Palette
    U16_WMC           u16StreamId;
    U16_WMC           u16VideoOutputBitCount;
    U32_WMC           u32VideoOutputPixelType;
} strVideoInfo_WMC;

typedef struct strBinaryStreamInfo_WMC
{
    Bool_WMC         bNothing;
    U16_WMC          u16StreamId;
} strBinaryInfo_WMC;


typedef struct strHeaderInfo_WMC
{
    U32_WMC     u32PlayDuration;
    U32_WMC     u32Preroll;
    U32_WMC     u32SendDuration;
    U32_WMC     u32MaxBitrate;
    U8_WMC      u8HasDRM;
	U32_WMC		u32PacketSize;
} strHeaderInfo_WMC;


typedef struct tagWMCContentDescription
{
    /* *_len: as [in], they specify how large the corresponding
     *        buffers below are.
     *        as [out], they specify how large the returned
     *        buffers actually are.
     */

    U16_WMC uiTitle_len;
    U16_WMC uiAuthor_len;
    U16_WMC uiCopyright_len;
    U16_WMC uiDescription_len;   /* rarely used */
    U16_WMC uiRating_len;        /* rarely used */

    /* these are two-byte strings
     *   for ASCII-type character set, to convert these
     *   into a single-byte characters, simply skip
     *   over every other bytes.
     */

    U16Char_WMC *pchTitle;
    U16Char_WMC *pchAuthor;
    U16Char_WMC *pchCopyright;
    U16Char_WMC *pchDescription;
    U16Char_WMC *pchRating;

} WMCContentDescription;

/******************************************************************
**   Extended content description types:
**   ECD_STRING -- wchar string
**   ECD_BINARY -- binary (byte) data
**   ECD_BOOL   -- BOOL (int) data
**   ECD_WORD  -- contains one word,
**   ECD_DWORD  -- contains one dword,
**   ECD_QWORD  -- contains one qword,
*******************************************************************/

enum {
    ECD_STRING = 0,
    ECD_BINARY = 1,
    ECD_BOOL = 2,
    ECD_DWORD = 3,
    ECD_QWORD = 4,
    ECD_WORD = 5
};

typedef struct _ECD_DESCRIPTOR {
    U16_WMC         cbName;
    U16Char_WMC     *pwszName;
    U16_WMC         data_type;
    U16_WMC         cbValue;
    union {
        U16Char_WMC *pwszString;
        U8_WMC *pbBinary;
        Bool_WMC *pfBool;
        U32_WMC *pdwDword;
        U64_WMC *pqwQword;
        U16_WMC  *pwWord;
    } uValue;
} ECD_DESCRIPTOR;

typedef struct tagWMCExtendedContentDescription
{
    U16_WMC cDescriptors;             // number of descriptors
    ECD_DESCRIPTOR *pDescriptors;  // pointer to all the descriptors
} WMCExtendedContentDesc;


typedef struct _WMCCommandEntry {
    U32_WMC         time;
    U16_WMC         type;
    U16Char_WMC     *param;
} WMCCommandEntry;

typedef struct tagWMCScriptCommand
{
    U16_WMC num_commands;      // number of script commands
    U16_WMC num_types;         // number of types of commands
    U16Char_WMC **type_names;     // command names, URL, FILENAME, CAPTION, etc
    I32_WMC *type_name_len;     // length of the command name
    I32_WMC *command_param_len; // length of command parameters
    WMCCommandEntry *commands; // pointer to all the commands
} WMCScriptCommand;


typedef struct tagWMCMarkerEntry {
    U64_WMC     m_qOffset;
    U64_WMC     m_qtime;
    U16_WMC     m_wEntryLen;
    U32_WMC     m_dwSendTime;
    U32_WMC     m_dwFlags;
    U32_WMC     m_dwDescLen;
    U16Char_WMC *m_pwDescName;
} WMCMarkerEntry;

typedef struct tagWMCIndexEntries
{
	U32_WMC	dwPacket;
	U16_WMC	wSpan;
} WMCINDEXENTRIES;


typedef struct tagWMCIndexInfo
{
	U16_WMC	nStreamId;
    U32_WMC   time_deltaMs;
    U32_WMC   max_packets;
    U32_WMC   num_entries;
    WMCINDEXENTRIES *pIndexEntries;
} WMCINDEXINFO;


typedef struct tagWMCCodecEntry {
    tMediaType_WMC     m_wCodecType;
    U16_WMC     m_wCodecNameLength;
    U16Char_WMC * m_pwCodecName;
    U16_WMC     m_wCodecDescLength;
    U16Char_WMC * m_pwCodecDescription;
    U16_WMC     m_wCodecInfoLen;
    U8_WMC		*m_pbCodecInfo;
} WMCCodecEntry;

typedef struct tagWMCMetaDataDescRecords {
    U16_WMC     wLangIdIndex;
    U16_WMC     wStreamNumber;
    U16_WMC     wNameLenth;
    U16_WMC     wDataType;
    U32_WMC     wDataLength;
    U16Char_WMC *pwName;
	Void_WMC	*pData;
} WMCMetaDataDescRecords;


typedef struct tagWMCMetaDataEntry {
    U16_WMC     m_wDescRecordsCount;
	WMCMetaDataDescRecords *pDescRec;
} WMCMetaDataEntry;

typedef struct tagBITMAPINFOHEADER_WMC{
        unsigned long      biSize;
        long               biWidth;
        long               biHeight;
        unsigned short     biPlanes;
        unsigned short     biBitCount;
        unsigned long      biCompression;
        unsigned long      biSizeImage;
        long               biXPelsPerMeter;
        long               biYPelsPerMeter;
        unsigned long      biClrUsed;
        unsigned long      biClrImportant;
} BITMAPINFOHEADER_WMC;

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\wmf.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       wmf.h
//
//--------------------------------------------------------------------------

#ifndef WMF_H
#define WMF_H

#ifdef __cplusplus
extern "C" {
#endif

#include "wmcdecode.h"

/****************************************************************************/
#if( !defined(_MSC_VER) && !defined(__stdcall) )
#define __stdcall
#endif

#ifndef WMAAPI
#ifndef x86
#define WMAAPI  __stdcall
#else
#define WMAAPI
#endif
#endif

#define STREAMVIDEO 0x0002
#define STREAMAUDIO 0x0001
#define LARGEBUFFER 0x8000

typedef struct tPacketList
{
	I8_WMC				*pBuff;
	I32_WMC					cbUsed;
	I32_WMC					cbFinished;
	I32_WMC					cbFrame;
	struct tPacketList	*Next;
}PacketList;

#ifdef _ZMDRM_
tWMCDecStatus WMFOpenDecoder(const U8_WMC *pbHeader, U32_WMC cbHeader, HWMCDECODER *phDecoder, HDRMMGR *hDRM, U8_WMC *pAppCert, U32_WMC Rights, const U8_WMC* pbHwId, U32_WMC cbHwId);
#else
tWMCDecStatus WMFOpenDecoder(const U8_WMC *pbHeader, U32_WMC cbHeader, HWMCDECODER *phDecoder);
#endif


/*
 *        WMFCloseDecoder
 *        ===============
 *
 * Description
 * -----------
 * Close a WMA decoder instance.
 *
 * Syntax
 * ------
 *   WMAERR WMAAPI WMFCloseDecoder(HWMFDECODER hDecoder);
 *
 * where:
 *
 *   hDecoder       the handle to the WMA instance
 *
 * Return Value
 * ------------
 *   WMAERR_OK                 closed okay
 *   WMAERR_INVALIDARG         invalid handle
 *
 */

tWMCDecStatus WMFCloseDecoder(HWMCDECODER hDecoder);





/*
 *        WMFDecTimeToOffset
 *        ==================
 *
 * Description
 * -----------
 * Use the millisecond offset to locate the offset to the
 * corresponding packet.
 *
 * Syntax
 * ------
 *   WMAERR WMAAPI WMFDecTimeToOffset(HWMFDECODER hDecoder,
 *                                    U32_WMC msSeek,
 *                                    U64_WMC *pcbPacketOffset);
 *
 * where:
 *
 *   hDecoder         the handle from WMFOpenDecoder
 *   msSeek           the time offset in milliseconds
 *   pcbPacketOffset  the offset into the beginning of the
 *                    corresponding ASF packet
 *
 * Return Value
 * ------------
 *   WMAERR_OK                 retreived okay
 *   WMAERR_INVALIDARG         invalid handle
 *
 */
tWMCDecStatus WMFDecTimeToOffset(HWMCDECODER hDecoder,
                                 U32_WMC msSeek,
                                 U64_WMC *pcbPacketOffset);


/*
 *        WMFDecDRM
 *        =========
 *
 * Description
 * -----------
 * Is the content DRM'ed?
 *
 * Syntax
 * ------
 *   WMAERR WMAAPI WMFDecDRM(HWMFDECODER hDecoder,
 *                           U32_WMC *pfDRM);
 *
 * where:
 *
 *   hDecoder         the handle from WMFOpenDecoder
 *   pfDRM            pointer to the flag to indicate whether
 *                    the content is DRM'ed or not
 *
 * Return Value
 * ------------
 *   WMAERR_OK                 retreived okay
 *   WMAERR_INVALIDARG         invalid handle
 *
 */
tWMCDecStatus WMFDecDRM(HWMCDECODER hDecoder,
                        U32_WMC *pfDRM);




/*
 *        WMFDrmGetLicFileName
 *        ====================
 *
 * Description
 * -----------
 * Get the path to the license filename.
 *
 * Syntax
 * ------
 *   WMAERR WMAAPI WMFDrmGetLicFileName(HWMFDECODER hDecoder,
 *                                      I8_WMC *pszLicFileName,
 *                                      U32_WMC *pdwLicFileName);
 *
 * where:
 *
 *   hDecoder       the handle from WMFOpenDecoder
 *   pszLicFileName the pointer to hold the filename
 *   pdwLicFileName the pointer to hold the length of the filename
 *                  when pszLicFileName is set to NULL, it holds the
 *                  size necessary to hold the filename
 *
 * Return Value
 * ------------
 *   WMAERR_OK                 the filename retreived okay
 *   WMAERR_INVALIDARG         invalid pointers
 *   WMAERR_MOREDATA           the length is retrieved, need to call again
 *                             to get the name
 *   WMAERR_DRMFAIL            the DRM lib failed
 *
 */
tWMCDecStatus WMFDrmGetLicFileName(HWMCDECODER hDecoder,
                                   I8_WMC *pszLicFileName,
                                   U32_WMC *pdwLicFileName);


/*
 *        WMFDrmInitLicense
 *        =================
 *
 * Description
 * -----------
 * Initialize the DRM license.
 *
 * Syntax
 * ------
 *   WMAERR WMAAPI WMFDrmInitLicense(HWMFDECODER hDecoder,
 *                                   U8_WMC *pbPMID,
 *                                   U32_WMC dwPMID,
 *                                   U8_WMC *pbLicData,
 *                                   U32_WMC *pdwOffset,
 *                                   U32_WMC *pdwLen);
 *
 * where:
 *
 *   hDecoder       the handle from WMFOpenDecoder
 *   pbPMID         the pointer to a buffer that holds the portable
 *                  media id
 *   dwPMID         the size of the pbPMID buffer
 *   pbLicData      the pointer to the license file buffer
 *   pdwOffset      the pointer to hold the offset into the license
 *                  file, from the beginning
 *   pdwLen         the pointer to hold the length of the pbLicData
 *                  buffer
 *
 * Return Value
 * ------------
 *   WMAERR_OK                 license checked okay
 *   WMAERR_INVALIDARG         invalid pointers
 *   WMAERR_MOREDATA           need to provide next bytes starting
 *                             at *pdwOffset
 *   WMAERR_DRMFAIL            the DRM lib failed
 *
 */
tWMCDecStatus WMFDrmInitLicense(HWMCDECODER hDecoder,
                                U8_WMC *pbPMID,
                                U32_WMC dwPMID,
                                U8_WMC *pbLicData,
                                U32_WMC *pdwOffset,
                                U32_WMC *pdwLen);


tWMCDecStatus WMFDecodeInit_All (HWMCDECODER hDecoder,
                          U32_WMC u32VideoOutputPixelType,
                          U16_WMC u16VideoOutputBitCount
#ifdef _ZMDRM_
                          ,HDRMMGR *phDRM,
                          U8_WMC *pAppCert,
                          U32_WMC Rights,
                          const U8_WMC *pbHwId,
                          U32_WMC cbHwId
#endif
);

#ifdef __cplusplus
}
#endif


#endif  /* WMF_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\wmaOS.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    WmaOS.h

Abstract:

    OS-specific data types and defines.

Author:

    Raymond Cheng (raych)       Aug 25, 1999

Revision History:


*************************************************************************/


#ifndef _WMA_OS_H_
#define _WMA_OS_H_


// Specify the OS target here


#if defined(_XBOX)
#define WMA_OSTARGET_XBOX
#elif  defined(_Embedded_x86)
#define WMA_OSTARGET_LINUX
#elif defined(S_SUNOS5)
#define WMA_OSTARGET_SUNOS5
#elif defined(__QNX__)
#define WMA_OSTARGET_QNX
#elif defined(_WIN32) 
#ifndef macintosh
#define WMA_OSTARGET_WIN32
#endif 
#endif





// **************************************************************************
// OS-Specific #ifdefs
// **************************************************************************

// ======================================================
// Win32 OS
// ======================================================
#if defined(WMA_OSTARGET_WIN32)

#ifdef COMMONMACROS_OUTPUT_TARGET
#pragma COMPILER_MESSAGE("-----WMAOS.H: Compiling for Win32 OS")
#endif // COMMONMACROS_OUTPUT_TARGET

#define _SCRUNCH_INLINE_ASM
#define PLATFORM_SPECIFIC_OUTPUTDEBUGSTRING
#define PLATFORM_SPECIFIC_PERFTIMER
#define PLATFORM_SPECIFIC_DEBUGINFRASTRUCTURE

#ifndef DISABLE_ASSERTS
#define PLATFORM_SPECIFIC_DEBUGBREAK

/* CE x86em platform does not have DebugBreak */
#ifdef _WIN32_WCE
#undef PLATFORM_SPECIFIC_DEBUGBREAK
#endif  // _WIN32_WCE
#endif  // DISABLE_ASSERTS

#ifdef UNDER_CE
// avoid threading on WinCE 
// TODO: verify if it can be used and how it effects performance)
#define WMA_SERIALIZE 
#endif

#include "win32.h"


// ======================================================
// Generic OS
// ======================================================
#else

#ifdef COMMONMACROS_OUTPUT_TARGET
#pragma COMPILER_MESSAGE("-----WMAOS.H: Compiling for GENERIC OS")
#endif // COMMONMACROS_OUTPUT_TARGET

#define WMA_SERIALIZE // No threading services are available

#endif // WMA_OSTARGET_WIN32

#ifdef WMA_OSTARGET_XBOX
#undef PLATFORM_SPECIFIC_DEBUGBREAK
#endif

// **************************************************************************
// Common to All OS's
// **************************************************************************

// ----- Performance Timer Functions -----
#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus
typedef struct tagPERFTIMERINFO PERFTIMERINFO;

PERFTIMERINFO *PerfTimerNew(long lSamplesPerSecOutput);
void PerfTimerStart(PERFTIMERINFO *pInfo);
void PerfTimerStop(PERFTIMERINFO *pInfo, long lSamplesDecoded);
void PerfTimerStopElapsed(PERFTIMERINFO *pInfo);
void PerfTimerReport(PERFTIMERINFO *pInfo);
float fltPerfTimerDecodeTime(PERFTIMERINFO *pInfo);
void PerfTimerFree(PERFTIMERINFO *pInfo);
#ifdef __cplusplus
}
#endif  // __cplusplus

// ----- Debug Infrastructure Functions and Macros -----
void TraceInfo(const char *pszFmt, ...);

#ifdef _DEBUG
#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus
void TraceInfoHelper(const char *pszFile, int iLine, const char *pszFmt, ...);
WMARESULT MyOutputDbgStr(WMARESULT wmaReturn, const char *pszFmt, ...);
#ifdef __cplusplus
}
#endif  // __cplusplus

// raych: The __FILE__ and __LINE__ might cause cross-platform compiler problems. Fix later...
#define TraceInfo0(text)            TraceInfoHelper(__FILE__, __LINE__, text)
#define TraceInfo1(text,one)        TraceInfoHelper(__FILE__, __LINE__, text, one)
#define TraceInfo2(text,one,two)    TraceInfoHelper(__FILE__, __LINE__, text, one, two)
#define TraceInfo3(text,one,two,three)                                      \
    TraceInfoHelper(__FILE__, __LINE__, text, one, two, three)

#define TraceInfo4(text,one,two,three,four)                                 \
    TraceInfoHelper(__FILE__, __LINE__, text, one, two, three, four)

#define TraceInfo5(text,one,two,three,four,five)                            \
    TraceInfoHelper(__FILE__, __LINE__, text, one, two, three, four, five)

#ifdef WANT_TRACE_ONHOLD
// Tracing ONHOLD for decapp produces too many benign error messages.  But Wei-ge assures us that
// for wmadec_s, it can be useful.  If you want it, define the symbol above.
#define TraceResult(code)   MyOutputDbgStr((code), "%s(%d) : *** TRACE *** code = 0x%x!\n", \
                                    __FILE__, __LINE__, (code))
#else   // WANT_TRACE_ONHOLD
#define TraceResult(code)   ( ((code)==WMA_E_ONHOLD || (code)==WMA_OK) ?  (code) :              \
                                MyOutputDbgStr((code), "%s(%d) : *** TRACE *** code = 0x%x!\n", \
                                    __FILE__, __LINE__, (code)) )
#endif  // WANT_TRACE_ONHOLD

#define TraceError(code)    {   /* wmaFOOFOO to avoid naming collisions */                      \
                                WMARESULT wmaFOOFOO = (code);                                   \
                                if (WMA_FAILED(wmaFOOFOO))                                      \
                                    TraceResult(wmaFOOFOO);                                     \
                            }

#else   // _DEBUG
#define TraceInfo0(text)
#define TraceInfo1(text,one)
#define TraceInfo2(text,one,two)
#define TraceResult(code)   (code)
#define TraceError(code)
#endif  // _DEBUG

#define TRACEWMA_EXIT(wmaResult, action) \
                            (wmaResult) = (action);                                             \
                            if (WMA_FAILED(wmaResult))                                          \
                            {                                                                   \
                                TraceResult(wmaResult);                                         \
                                goto exit;                                                      \
                            } else {}
    
#define ASSERTWMA_EXIT(wmaResult, action) \
                            (wmaResult) = (action);                                             \
                            if (WMA_FAILED(wmaResult))                                          \
                            {                                                                   \
                                DEBUG_ONLY(DEBUG_BREAK()); /* assert(WMAB_FALSE); */            \
                                TraceResult(wmaResult);                                         \
                                goto exit;                                                      \
                            } else {}

#define CHECKWMA_EXIT(wmaResult) \
                            if (WMA_FAILED(wmaResult))                                          \
                            {                                                                   \
                                TraceResult(wmaResult);                                         \
                                goto exit;                                                      \
                            } else {}

#define TRACEWMA_RET(wmaResult, action) \
                            (wmaResult) = (action);                                             \
                            if (WMA_FAILED(wmaResult))                                          \
                            {                                                                   \
                                return TraceResult(wmaResult);                                  \
                            } else {}


// **************************************************************************
// Overridable Macros (optimized for some platforms, but not all)
// **************************************************************************
// The following can be overridden within a particular platform OS file

//---------------------------------------------------------------------------
#ifndef PLATFORM_SPECIFIC_OUTPUTDEBUGSTRING
#define OUTPUT_DEBUG_STRING(sz) printf(sz)
#endif  // PLATFORM_SPECIFIC_OUTPUTDEBUGSTRING

//---------------------------------------------------------------------------
#if defined(_DEBUG) && !defined(DISABLE_ASSERTS)
#ifndef PLATFORM_SPECIFIC_DEBUGBREAK
#define DEBUG_BREAK()   *((U32 *)0) = 55    // Brute-force debug break
#endif // PLATFORM_SPECIFIC_DEBUGBREAK
#else   // defined(_DEBUG) && !defined(DISABLE_ASSERTS)
#undef DEBUG_BREAK
#define DEBUG_BREAK()
#endif  // defined(_DEBUG) && !defined(DISABLE_ASSERTS)

#endif // _WMA_OS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\wmfparse.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       wmaparse.h
//
//--------------------------------------------------------------------------

#ifndef WMFPARSE_H
#define WMFPARSE_H

#include "wmftypes.h"
#ifdef macintosh
#include "wmMacSp.h"
#endif
#include "wmc_type.h"
#include "wmcguids.h"

#define MIN_OBJECT_SIZE     24
#define DATA_OBJECT_SIZE    50
#define MAX_PACKET_PAYLOADS 64


#ifdef __cplusplus
extern "C" {
#endif



/****************************************************************************/
tWMCDecStatus LoadHeaderObject(HWMCDECODER *phDecoder);
/****************************************************************************/
tWMCDecStatus LoadPropertiesObject(
                    U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder);

/****************************************************************************/
tWMCDecStatus LoadEncryptionObject(
                    U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder);
/****************************************************************************/
tWMCDecStatus LoadEncryptionObjectEx(
                    U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder);

/****************************************************************************/
tWMCDecStatus LoadAudioObjectSize(
                    U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder);

/****************************************************************************/
tWMCDecStatus LoadContentDescriptionObject(
                    U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder);
/****************************************************************************/
tWMCDecStatus LoadMarkerObject(
                    U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder);

/****************************************************************************/
tWMCDecStatus LoadExtendedContentDescriptionObject(
                    U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder);
/****************************************************************************/
tWMCDecStatus LoadScriptCommandObject(
                    U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder);
/****************************************************************************/
tWMCDecStatus LoadLicenseStoreObject(
                    U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder);
/****************************************************************************/
tWMCDecStatus LoadExtendedStreamPropertiesObject(
                    U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder);

/****************************************************************************/
tWMCDecStatus LoadIndexObject(HWMCDECODER *phDecoder,
                    U64_WMC cbOffset,
                    U32_WMC cbBuffer,
                    U16_WMC wStreamId,
					WMCINDEXINFO *pIndexInfo
                    );

/****************************************************************************/
tWMCDecStatus LoadObjectHeader(
              HWMCDECODER *phDecoder, GUID_WMC *pObjectId, U64_WMC *pqwSize);

/****************************************************************************/
tWMCDecStatus ParseAsfHeader(
               HWMCDECODER *phDecoder, U8_WMC isFull);
/****************************************************************************/
tWMCDecStatus WMCDecParsePayloadHeader(HWMCDECODER phDecoder);
/****************************************************************************/
tWMCDecStatus WMCDecParsePacketHeader(HWMCDECODER phDecoder);
/****************************************************************************/
LoadCodecListObject(U32_WMC cbBuffer, HWMCDECODER *phDecoder);
/****************************************************************************/
tWMCDecStatus LoadVirtualMetaDataObject(U32_WMC cbBuffer,
                    HWMCDECODER *phDecoder, U32_WMC Offset);
/****************************************************************************/
tWMCDecStatus LoadClockObject(U32_WMC cbBuffer, HWMCDECODER *phDecoder);
/****************************************************************************/

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\wmfdec.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       wmadec.h
//
//--------------------------------------------------------------------------

#ifndef WMADEC_H
#define WMADEC_H

#if defined(_XBOX)
#include <xtl.h>
#endif

#if !defined(_Embedded_x86) && !defined(HITACHI)
#ifdef macintosh
#include <MacTypes.h>
#include <Errors.h>
#include <Endian.h>
#include <MacMemory.h>
#define BIGENDIAN
#else
#include <windows.h>
#include <memory.h>
#include <mmsystem.h>
#endif 
#endif

#include "wmftypes.h"

//#include "wmadec_api.h"
#include "wmadecS_api.h"
#ifndef WMFAPI_NO_DRM
#ifdef _ZMDRM_
#include "drmmanager_api.h"
#else
#include "drmbase.h"
#include "drmpd.h"
#endif
#endif
#include "wmc_type.h"
#include "wmcdecode.h"
#include "wmcguids.h"
typedef struct tPacketInfo
{
	U32_WMC	nSamplesPerSec;
	U64_WMC	cbPacketOffset;	
	U64_WMC	cbLastPacketOffset;	
	U32_WMC	cbPacketSize;	
	U32_WMC	cbMaxAudioSize;
	U16_WMC	nChannels;	
	U32_WMC	fccHandler;
	U32_WMC	dwScale;
	U32_WMC	dwRate;
	BITMAPINFOHEADER BitmapInfo;
	WAVEFORMATEX		tWaveFormat;	
	U8_WMC	bHasValidVideo;
	U8_WMC	bHasValidAudio;
	U8_WMC	bInit;

} WMINITINFO;

typedef enum tagWMCParseState
{
    csWMC_NotValid = 0,

    csWMCHeaderStart,
    csWMCHeaderError,

    csWMCNewAsfPacket,

    /* packet parsing states */

    csWMCDecodePayloadStart,
    csWMCDecodePayload,
    csWMCDecodePayloadHeader,
    csWMCDecodeLoopStart,
    csWMCDecodePayloadEnd,
    csWMCDecodeCompressedPayload,

    csWMCEnd
} tWMCParseState;



typedef struct tBitRateInfo
{
    U16_WMC   wStreamId;
    U32_WMC   dwBitRate;

} BITRATEINFO;


typedef struct tHeaderInfo
{
	U64_WMC	    cbPacketOffset;	
	U64_WMC	    cbLastPacketOffset;	
	U64_WMC	    cbCurrentPacketOffset;	
	U64_WMC	    cbFirstPacketOffset;	
	U64_WMC	    cbNextPacketOffset;	

    U32_WMC     cbHeader;
    U32_WMC     cbPacketSize;
    U32_WMC     cPackets;
    U32_WMC     msDuration;
    U32_WMC     msPreroll;
    U32_WMC     msSendDuration;
	U32_WMC     dwMaxBitrate;
    U16_WMC     wNoOfStreams;
    U16_WMC     wNoOfAudioStreams;
    U16_WMC     wNoOfVideoStreams;
    U16_WMC     wNoOfBinaryStreams;
    
    BITRATEINFO tBitRateInfo[127];
    PACKET_PARSE_INFO_EX ppex;

    PAYLOAD_MAP_ENTRY_EX payload;
    U32_WMC     iPayload;
    U16_WMC     wPayStart;
    Bool_WMC    bHasBitRateInfo;
    U32_WMC     dwPayloadOffset;
    

} HEADERINFO;


typedef struct tAudioStreamInfo
{
    U16_WMC    nVersion;
    U16_WMC    wFormatTag;
    U32_WMC    nSamplesPerSec;
    U32_WMC    nAvgBytesPerSec;
    U32_WMC    nBlockAlign;
    U16_WMC    nChannels;


    U32_WMC    nSamplesPerBlock;
    U16_WMC    nEncodeOpt;

    I32_WMC	   nBitsPerSample;
    U16_WMC    wValidBitsPerSample; // actual valid data depth in the decoded stream
    U32_WMC    dwChannelMask;
    GUID_WMC   SubFormat;
    U16_WMC    wOriginalBitDepth; // actual valid data depth in the original source (informational)
    U16_WMC    wStreamId;
    U32_WMC    cbAudioSize;
    WMARawDecHandle     hMSA;
    Bool_WMC   bTobeDecoded;
    Bool_WMC   bIsDecodable;
    Bool_WMC   bWantOutput;
    WMARESULT  wmar;
    Bool_WMC   bTimeToChange;
    Bool_WMC   bTimeToChangex;
    Bool_WMC   bFirstTime;
    U8_WMC     bAudioBuffer[MIN_WANTED];
	U8_WMC     *pbAudioBuffer;
    U32_WMC    dwFrameSize; 
    U32_WMC    dwAudioBufSize;
    U32_WMC    dwAudioBufCurOffset;
	U32_WMC    cbNbFramesAudBuf;
    U32_WMC    dwAudioBufDecoded;
    U32_WMC    dwAudioPayloadSize;
	U8_WMC     bBlockStart;
	U32_WMC    dwBlockLeft;
	U32_WMC    dwPayloadLeft;
	U32_WMC    dwAudPayloadPresTime;
    Double_WMC dwAudioTimeStamp;
	U8_WMC*	   pStoreFrameStartPointer;			
	U8_WMC*	   pStoreNextFrameStartPointer;			
	U8_WMC*	   pDecodeFrameStartPointer;			
	U8_WMC*	   pDecodeNextFrameStartPointer;
    Bool_WMC   bBufferIncreased;
    Bool_WMC   bStopReading;
	Bool_WMC   bGotCompOutput;	
	Bool_WMC   bOutputisReady;	
//  for non buffer mode
#ifdef WMC_NO_BUFFER_MODE
	U64_WMC	    cbPacketOffset;	
	U64_WMC	    cbCurrentPacketOffset;	
	U64_WMC	    cbNextPacketOffset;	
    PACKET_PARSE_INFO_EX ppex;
    PAYLOAD_MAP_ENTRY_EX payload;
    U32_WMC     iPayload;
    U16_WMC     wPayStart;
    U32_WMC     dwPayloadOffset;
    tWMCParseState         parse_state;
    Bool_WMC   bPayloadGiven;
#endif
	
} AUDIOSTREAMINFO;

typedef struct tVideoStreamInfo
{
	U32_WMC    windowWidth;
    U32_WMC    windowHeight;
    U8_WMC     flags;
    U16_WMC    imageInfoLen;

	U32_WMC    biSize; 
	I32_WMC    biWidth; 
	I32_WMC    biHeight; 
	U16_WMC    biPlanes; 
	U16_WMC    biBitCount; 
	U32_WMC    biCompression; 
	U32_WMC    biSizeImage; 
	I32_WMC    biXPelsPerMeter; 
	I32_WMC    biYPelsPerMeter; 
	U32_WMC    biClrUsed; 
	U32_WMC    biClrImportant;

    U16_WMC    biBitCountOut; 
	U32_WMC    biCompressionOut; 
	U32_WMC    biSizeImageOut; 

	void	   *pVDec;
    U16_WMC    wStreamId;
    Bool_WMC   bTobeDecoded;
    Bool_WMC   bIsDecodable;
    Bool_WMC   bWantOutput;
    Bool_WMC   bFirst;
	U8_WMC     *pbVideoBuffer;
    U32_WMC    dwVideoBufSize;
    U32_WMC    dwVideoBufCurOffset;
	U8_WMC     bBlockStart;
	U32_WMC    dwBlockLeft;
	U32_WMC    dwPayloadLeft;
	U32_WMC    dwFrameLeft;
	U32_WMC    cbNbFramesVidBuf;
    U32_WMC    dwVideoBufDecoded;
//	U8_WMC	   *pVideoBuffer;
    U32_WMC    dwVideoTimeStamp;
    U32_WMC    dwNbFrames;
	U8_WMC     bAdditionalInfo[1024];
    U8_WMC     bPalette[3*256];
    U8_WMC     bVideoBuffer[MIN_WANTED+10];
    Bool_WMC   bInitStage; 
	U32_WMC    cbUsed;
    U32_WMC    dwFrameSize; 
	U32_WMC    cbFrame;
    Bool_WMC   bIsKeyFrame;
    U8_WMC*    pSCInBuffer;
    U8_WMC*    pSCOutBuffer;
    Bool_WMC   bScOutGiven; 
	U8_WMC*	   pStoreFrameStartPointer;			
	U8_WMC*	   pStoreNextFrameStartPointer;			
	U8_WMC*	   pDecodeFrameStartPointer;			
	U8_WMC*	   pDecodeNextFrameStartPointer;			
    Bool_WMC   bBufferIncreased;
    Bool_WMC   bStopReading;
	Bool_WMC   bGotCompOutput;	
	Bool_WMC   bOutputisReady;
	Bool_WMC   bHasGivenAnyOutput;
	Bool_WMC   bNowStopReadingAndDecoding;

	tVideoFormat_WMC tOutVideoFormat;

#ifdef WMC_NO_BUFFER_MODE
	U64_WMC	    cbPacketOffset;	
	U64_WMC	    cbCurrentPacketOffset;	
	U64_WMC	    cbNextPacketOffset;	
    PACKET_PARSE_INFO_EX ppex;
    PAYLOAD_MAP_ENTRY_EX payload;
    U32_WMC     iPayload;
    U16_WMC     wPayStart;
    U32_WMC     dwPayloadOffset;
    tWMCParseState         parse_state;
    U32_WMC    dwNextVideoTimeStamp;
    Bool_WMC   bFrameGiven;
#endif    

} VIDEOSTREAMINFO;


typedef struct tBinaryStreamInfo
{
//    Bool_WMC   bTobeDecoded;
    U16_WMC    wStreamId;
    Bool_WMC   bWantOutput;
    U32_WMC    dwBinaryBufSize;
	U8_WMC     *pbBinaryBuffer;
    U32_WMC    dwBinaryBufCurOffset;
    U32_WMC    dwBinaryTimeStamp;
	U32_WMC    cbNbFramesBinBuf;
	U32_WMC    dwBlockLeft;
	U32_WMC    dwPayloadLeft;
	U32_WMC    dwFrameLeft;
   	U32_WMC    cbUsed;
    U32_WMC    dwFrameSize; 
	U32_WMC    cbFrame;
    U32_WMC    dwNbFrames;
    U32_WMC    dwBinaryBufDecoded;
	U8_WMC*	   pStoreFrameStartPointer;			
	U8_WMC*	   pStoreNextFrameStartPointer;			
	U8_WMC*	   pDecodeFrameStartPointer;			
	U8_WMC*	   pDecodeNextFrameStartPointer;			
    Bool_WMC   bBufferIncreased;
    Bool_WMC   bStopReading;
	Bool_WMC   bGotCompOutput;	
	Bool_WMC   bOutputisReady;	

	Bool_WMC   bHasGivenAnyOutput;
	Bool_WMC   bNowStopReadingAndDecoding;

#ifdef WMC_NO_BUFFER_MODE
	U64_WMC	    cbPacketOffset;	
	U64_WMC	    cbCurrentPacketOffset;	
	U64_WMC	    cbNextPacketOffset;	
    PACKET_PARSE_INFO_EX ppex;
    PAYLOAD_MAP_ENTRY_EX payload;
    U32_WMC     iPayload;
    U16_WMC     wPayStart;
    U32_WMC     dwPayloadOffset;
    tWMCParseState         parse_state;
    U32_WMC    dwNextBinaryTimeStamp;
    Bool_WMC   bFrameGiven;
#endif    

    
} BINARYSTREAMINFO;

typedef struct tWMFDecoderEx
{
    HEADERINFO            tHeaderInfo;
    AUDIOSTREAMINFO *     tAudioStreamInfo[127];
    VIDEOSTREAMINFO *     tVideoStreamInfo[127];
    BINARYSTREAMINFO *    tBinaryStreamInfo[127];

#ifndef WMFAPI_NO_DRM
#ifdef _ZMDRM_
    HDRMMGR hDRM;
#else
    CDrmPD *hDRM;
#endif
#endif

    U8_WMC*                pszType;
    U8_WMC*                pszKeyID;
 
    U32_WMC                cbEnhData;
    U8_WMC*                pbEnhData;
    U32_WMC                cbSecData;
    U8_WMC*                pbSecData;
    tWMCParseState         parse_state;
    /* Marker */
    U32_WMC                m_dwMarkerNum;
    WMCContentDescription  *m_pContentDesc;
    WMCMarkerEntry            *m_pMarkers;
    WMCExtendedContentDesc *m_pExtendedContentDesc;
    WMCScriptCommand       *m_pScriptCommand;
        /* License Store */
    U32_WMC                m_dwLicenseLen;
    U8_WMC                 *m_pLicData;
    U8_WMC                 bHasDRM;
    // Adding for index entry
    U8_WMC                 cTotalIndexs;
    WMCINDEXINFO           tIndexInfo[127];
    Bool_WMC               bParsed;
    I32_WMC                i32CurrentAudioStreamIndex;
    I32_WMC                i32CurrentVideoStreamIndex;
    I32_WMC                i32CurrentBinaryStreamIndex;
    tPlannedOutputWMC      tPlannedOutputInfo;
    tStreamIdnMediaType_WMC *pStreamIdnMediaType;
    U32_WMC                 u32UserData;
    Bool_WMC               bSkipToNextI;
	U32_WMC				   m_dwNumCodec;
	WMCCodecEntry		   *m_pCodecEntry;
	U64_WMC				   u64SeekTimeRequest;
	Bool_WMC			   bInSeekState;
	tWMCDecodeDispRotateDegree tDispRotateDegree;
	I32_WMC					i32PostProc;
	I32_WMC					iHurryUp;
	Bool_WMC				bIsNoBufferMode;
	WMCMetaDataEntry        tMetaDataEntry;
}WMFDecoderEx;





#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\x86macros.h ===
#ifndef __X86MACROS_H_
#define __X86MACROS_H_

#ifdef WMA_TARGET_X86

#pragma MSVC_DISABLE_WARNING(4035)

// ======================================================
// Typedefs
// ======================================================
#define FASTCALL    __fastcall


// ======================================================
// Macros
// ======================================================
#define MULT_HI_DWORD_DOWN(a,b) MultiplyHighDwordDown(a,b)
#define MULT_HI_DWORD(a,b)      MultiplyHighDword(a,b)
#define MULT_HI_UDWORD(a,b)     MultiplyHighUDword(a,b)

#pragma warning(disable: 4035)

#ifndef WMA_ANSI_COMPATIBILITY_MODE
// The following two functions, ROUNDF and ROUNDD, use the "round to nearest
// (even)" rounding mode in the Intel processor. This means -0.7 goes to -1,
// 1.3 goes to 1, 11.5 goes to 12 and 12.5 goes to 12. This unfortunately
// is a pain to do in software, so ANSI just rounds up in the case of 0.5
// (-0.7 to -1, 1.3 to 1, 11.5 to 12 and 12.5 to 13). Don't use these rounding
// macros if we want to compare x86 output with ANSI.
//-------------------------------------------------------

#ifdef PLATFORM_SPECIFIC_ROUND
INLINE Int FASTCALL ROUNDF(float f) {
    __int64 intval;
    _asm {
        fld         f
        fistp       dword ptr [intval]
        mov         eax,dword ptr [intval]
    }
}

//-------------------------------------------------------
INLINE Int FASTCALL ROUNDD(double f) {
    _asm {
        fld         f
        fistp       dword ptr [f]
        mov         eax,dword ptr [f]
    }
}
#endif // PLATFORM_SPECIFIC_ROUND
#endif // WMA_ANSI_COMPATIBILITY_MODE


//-------------------------------------------------------
INLINE I32 FASTCALL MultiplyHighDwordDown(I32 reg1, I32 reg2){
__asm{  mov     eax,reg1
        mov     edx,reg2
        imul    edx
        mov     eax,edx
        shl     eax,2
     }
}

//-------------------------------------------------------
INLINE I32 FASTCALL MultiplyHighDword(I32 reg1, I32 reg2){
__asm{  mov     eax,reg1
        mov     edx,reg2
        imul    edx
        mov     eax,edx
     }
}

//-------------------------------------------------------
INLINE I32 FASTCALL MultiplyHighUDword(U32 reg1, U32 reg2){
__asm{  mov     eax,reg1
        mov     edx,reg2
        mul     edx
        mov     eax,edx
     }
}


//-------------------------------------------------------
INLINE U32 FASTCALL ByteSwap(U32 i){
    __asm
    {
        mov     eax, i
        bswap   eax
    }
}

#pragma warning(default: 4035)

#ifdef PLATFORM_SPECIFIC_BITCOPY
//-------------------------------------------------------
//assuming dwsrc is zeroed out
INLINE void FASTCALL bitCpy (const U8* pbSrc, Int iBitStartSrc,
                                 Int cBits, U8* pbDst)
{
    const U32* pdwSrc = (U32 *) pbSrc;
    const U32* pdwSrcEnd;
    U32* pdwDst = (U32 *) pbDst;
    Int iShiftDown;
    U32 dw2, dw1;


    assert (pdwSrc != NULL && pdwDst != NULL);
    assert (iBitStartSrc < BITS_PER_DWORD && iBitStartSrc >= 0);
    assert (cBits >= 0);

    pdwSrcEnd = pdwSrc + (iBitStartSrc > 0) + 
                            (((cBits - iBitStartSrc) + 31) & ~31) / 32; //open
    iShiftDown = (BITS_PER_DWORD - iBitStartSrc);
    dw1 = DEFAULTENDIAN_TO_BIGENDIAN(*pdwSrc);
    while (pdwSrc < pdwSrcEnd) {
        pdwSrc++;
        dw2 = DEFAULTENDIAN_TO_BIGENDIAN(*pdwSrc);
        *pdwDst = BIGENDIAN_TO_DEFAULTENDIAN((dw1 << iBitStartSrc) | (dw2 >> iShiftDown));
        dw1 = dw2;
        pdwDst++;
    }
}
#endif  // PLATFORM_SPECIFIC_BITCOPY

#pragma MSVC_RESTORE_WARNING(4035)
//wchen: mmx detection has 25db mismatch with C version. Off for now.
#undef PLATFORM_SPECIFIC_FNPTR
#define PLATFORM_SPECIFIC_FNPTR                                                     \
    if (g_SupportMMX()){                                                            \
        if (g_SupportCMOV()) {                                                      \
            pauenc->m_pfnGetLowMedHiPowerStereo_48 = g_GetLowMedHiPower_48_MMX;     \
            pauenc->m_pfnGetLowMedHiPowerStereo_44 = g_GetLowMedHiPower_44_MMX;     \
            pauenc->m_pfnGetLowMedHiPowerStereo_32 = g_GetLowMedHiPower_32_MMX;     \
            pauenc->m_pfnGetLowMedHiPowerStereo_22 = g_GetLowMedHiPower_22_MMX;     \
        }                                                                           \
    }
#endif // WMA_TARGET_X86
#endif // __X86MACROS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\wmftypes.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       wmftypes.h
//
//--------------------------------------------------------------------------

#ifndef WMFTYPES_H
#define WMFTYPES_H

#ifdef _MSC_VER
#define USE_PACK_HEADERS
#define PACKED
#elif defined(macintosh) || defined(HITACHI)
#define PACKED  
#elif defined (_Embedded_x86) 
#include "wmc_type.h"
#define PACKED 
#else
#define PACKED  __packed
#endif

#ifdef USE_PACK_HEADERS
#include <pshpack1.h>
#endif


/****************************************************************************/
#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

#if (defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(UNDER_CE)) && !defined(x86)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif



/****************************************************************************/
//#ifndef __LONG_DEFINED__
//#define __LONG_DEFINED__
//typedef long LONG;
//#endif

#ifdef _Embedded_x86
typedef unsigned long ULONG;
#define BYTE U8_WMC
#define DWORD U32_WMC
#define BOOL Bool_WMC
#endif
#ifndef __QU16_WMC_DEFINED__
#define __QU16_WMC_DEFINED__
#endif

/****************************************************************************/
#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef PACKED struct tGUID
{
    U32_WMC Data1;
    U16_WMC Data2;
    U16_WMC Data3;
    U8_WMC  Data4[ 8 ];

}	GUID;

#endif

#ifdef _XBOX
#ifndef _BITMAPINFOHEADER
#define _BITMAPINFOHEADER
typedef struct tagBITMAPINFOHEADER{ // bmih
    U32_WMC  biSize;
    I32_WMC   biWidth;
    I32_WMC   biHeight;
    U16_WMC   biPlanes;
    U16_WMC   biBitCount;
    U32_WMC  biCompression;
    U32_WMC  biSizeImage;
    I32_WMC   biXPelsPerMeter;
    I32_WMC   biYPelsPerMeter;
    U32_WMC  biClrUsed;
    U32_WMC  biClrImportant;
} BITMAPINFOHEADER;
#endif
#endif // xbox

/****************************************************************************/
#ifndef _WAVEFORMATEX_
#define _WAVEFORMATEX_


#ifndef _XBOX
typedef PACKED struct tWAVEFORMATEX
{
    U16_WMC    wFormatTag;         /* format type */
    U16_WMC    nChannels;          /* number of channels (i.e. mono, stereo...) */
    U32_WMC   nSamplesPerSec;     /* sample rate */
    U32_WMC   nAvgBytesPerSec;    /* for buffer estimation */
    U16_WMC    nBlockAlign;        /* block size of data */
    U16_WMC    wBitsPerSample;     /* number of bits per sample of mono data */
    U16_WMC    cbSize;             /* the count in bytes of the size of */

}   WAVEFORMATEX, *PWAVEFORMATEX, *NPWAVEFORMATEX, *LPWAVEFORMATEX;
typedef const WAVEFORMATEX *LPCWAVEFORMATEX;
#endif
#endif

#ifndef _WAVEFORMATEXTENSIBLE_
#define _WAVEFORMATEXTENSIBLE_
typedef PACKED struct tWAVEFORMATEXTENSIBLE
{
    WAVEFORMATEX Format;       /* The traditional wave file header */
    union {
        unsigned short wValidBitsPerSample; /* bits of precision */
        unsigned short wSamplesPerBlock;    /* valid if wBitsPerSample==0 */
        unsigned short wReserved;           /* If neither applies, set to zero */
    } Samples;
    unsigned long    dwChannelMask;        /* which channels are present in stream */
    GUID SubFormat;           /* specialization */
} WAVEFORMATEXTENSIBLE, *PWAVEFORMATEXTENSIBLE,  *NPWAVEFORMATEXTENSIBLE, *LPWAVEFORMATEXTENSIBLE;
typedef const WAVEFORMATEXTENSIBLE *LPCWAVEFORMATEXTENSIBLE;
#endif // _WAVEFORMATEXTENSIBLE_

#ifdef _Embedded_x86
#ifndef _BITMAPINFOHEADER
#define _BITMAPINFOHEADER
typedef struct tagBITMAPINFOHEADER{
        U32_WMC      biSize;
        I32_WMC       biWidth;
        I32_WMC       biHeight;
        U16_WMC       biPlanes;
        U16_WMC       biBitCount;
        U32_WMC      biCompression;
        U32_WMC      biSizeImage;
        I32_WMC       biXPelsPerMeter;
        I32_WMC       biYPelsPerMeter;
        U32_WMC      biClrUsed;
        U32_WMC      biClrImportant;
} BITMAPINFOHEADER, *LPBITMAPINFOHEADER;

#endif
#ifndef _COLORSCHEME
#define _COLORSCHEME
#define BI_RGB	0
#define BI_BITFIELDS  3L
#endif
#define INT int
#define LPVOID void*
#define FALSE 0
#define FAILED(Status) ((HRESULT)(Status)<0)

#endif



#define WAVE_FORMAT_MSAUDIO1  0x0160
typedef struct tMSAUDIO1WAVEFORMAT
{
    WAVEFORMATEX wfx;
    U16_WMC         wSamplesPerBlock;
    U16_WMC         wEncodeOptions;

}   MSAUDIO1WAVEFORMAT;

#define WAVE_FORMAT_WMAUDIO2  0x0161
typedef PACKED struct tWMAUDIO2WAVEFORMAT
{
    WAVEFORMATEX wfx;
    U32_WMC        dwSamplesPerBlock;
    U16_WMC         wEncodeOptions;
    U32_WMC        dwSuperBlockAlign;

}   WMAUDIO2WAVEFORMAT;

#if !defined (WAVE_FORMAT_WMAUDIO3)
#define WAVE_FORMAT_WMAUDIO3  0x0162

typedef struct wmaudio3waveformat_tag {
  WAVEFORMATEX wfx;
  WORD         wValidBitsPerSample; // bits of precision 
  DWORD        dwChannelMask;       // which channels are present in stream 
  DWORD        dwReserved1;
  DWORD        dwReserved2;
  WORD         wEncodeOptions;
  WORD         wReserved3;
} WMAUDIO3WAVEFORMAT;
#endif
#define WMAUDIO2_WFX_EXTRA_BYTES    (sizeof(WMAUDIO2WAVEFORMAT) - sizeof(WAVEFORMATEX))

#define WAVE_FORMAT_MSSPEECH  10

/****************************************************************************/


typedef PACKED struct tAsfXAcmAudioErrorMaskingData
{
    U8_WMC    span;
    U16_WMC    virtualPacketLen;
    U16_WMC    virtualChunkLen;
    U16_WMC    silenceLen;
    U8_WMC    silence[1];

}   AsfXAcmAudioErrorMaskingData;


/****************************************************************************/
typedef PACKED struct tAsfXSignatureAudioErrorMaskingData
{
    U32_WMC maxObjectSize;
    U16_WMC  chunkLen;
    U16_WMC  signatureLen;
    U8_WMC  signature[1];

}   AsfXSignatureAudioErrorMaskingData;
/****************************************************************************/
// Added by Amit on 02/24/00 for Video Parsing
typedef PACKED struct tAsfXGenericImageTypeSpecific
{

    U32_WMC       windowWidth;
    U32_WMC       windowHeight;
    U8_WMC        flags;
    U16_WMC        imageInfoLen;
    U8_WMC        imageInfo[1];
}AsfXGenericImageTypeSpecific;

/****************************************************************************/
typedef struct tPACKET_PARSE_INFO_EX
{
    Bool_WMC fParityPacket;
    U32_WMC cbParseOffset;

    Bool_WMC fEccPresent;
    U8_WMC bECLen;

    U8_WMC bPacketLenType;
    U32_WMC cbPacketLenTypeOffset;

    U8_WMC bPadLenType;
    U8_WMC bSequenceLenType;

    Bool_WMC fMultiPayloads;

    U8_WMC bOffsetBytes;

    U8_WMC bOffsetLenType;

    U32_WMC cbPacketLenOffset;

    U32_WMC cbExplicitPacketLength; 

    U32_WMC cbSequenceOffset;
    
    U32_WMC dwSequenceNum; 

    U32_WMC cbPadLenOffset;
    U32_WMC cbPadding;

    U32_WMC dwSCR;
    U16_WMC wDuration;

    U8_WMC bPayLenType;
    U8_WMC bPayBytes;
    U32_WMC cbPayLenTypeOffset;

    U32_WMC cPayloads;

}   PACKET_PARSE_INFO_EX;


/****************************************************************************/
typedef struct tPAYLOAD_MAP_ENTRY_EX
{
    U16_WMC cbPacketOffset;
    U16_WMC cbTotalSize;

    U8_WMC bStreamId;
    U8_WMC bObjectId;

    U32_WMC cbObjectOffset;
    U32_WMC cbObjectSize;
    U32_WMC msObjectPres;

    U8_WMC cbRepData;
    U8_WMC bJunk;
    U16_WMC cbPayloadSize;
	U8_WMC bIsKeyFrame;
	U8_WMC bFrameRate;
	U16_WMC wTotalDataBytes;
	U32_WMC dwDeltaPresTime;
    U8_WMC bIsCompressedPayload;

    U16_WMC wBytesRead;
    U8_WMC bSubPayloadState;
    U8_WMC bNextSubPayloadSize;
    U16_WMC wSubpayloadLeft;
	U16_WMC  wSubCount;	



}   PAYLOAD_MAP_ENTRY_EX;


#ifdef USE_PACK_HEADERS
#include <poppack.h>
#endif

#endif  /* WMFTYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\wmvdec_api.h ===
/*************************************************************************

Copyright (c) 2000 - 2001  Microsoft Corporation

Module Name:

	wmvdec_api.h

Abstract:

	Decoder API's for WMV.
        decodes WMV2, WMV1, MP43, MP42, MP4S

Author:


Revision History:

*************************************************************************/

#ifndef __WMVDEC_API_H_
#define __WMVDEC_API_H_

// basic types
typedef void* HWMVDecoder;

typedef void Void_WMV;
//typedef long I32_WMV;
typedef int I32_WMV;
typedef unsigned long U32_WMV;
typedef short I16_WMV;
typedef unsigned short U16_WMV;
typedef unsigned short U16Char_WMV;
typedef char I8_WMV;
typedef unsigned char U8_WMV;
typedef long Bool_WMV;
typedef double Double_WMV;
typedef float Float_WMV;

#define TRUE_WMV    1
#define FALSE_WMV   0
#define NULL_WMV   0

typedef enum tagWMVDecodeStatus
{
    WMV_Succeeded = 0,
    WMV_Failed,
    WMV_BadMemory,
    WMV_NoKeyFrameDecoded,
    WMV_CorruptedBits,
    WMV_UnSupportedOutputPixelFormat,
    WMV_UnSupportedCompressedFormat,
    WMV_InValidArguments,
    WMV_BadSource,

    WMV_NoMoreOutput,
    WMV_EndOfFrame,
    WMV_BrokenFrame
} tWMVDecodeStatus;


// GUID definiton
//// SHOULD MERGE WITH WMF_TYPES.H

#ifndef MAKEFOURCC_WMV
#define MAKEFOURCC_WMV(ch0, ch1, ch2, ch3) \
        ((U32_WMV)(U8_WMV)(ch0) | ((U32_WMV)(U8_WMV)(ch1) << 8) |   \
        ((U32_WMV)(U8_WMV)(ch2) << 16) | ((U32_WMV)(U8_WMV)(ch3) << 24 ))

#define mmioFOURCC_WMV(ch0, ch1, ch2, ch3)  MAKEFOURCC_WMV(ch0, ch1, ch2, ch3)
#endif


/******* video output type guids, in preference order  *****/
#define FOURCC_WMV2_WMV     mmioFOURCC_WMV('W','M','V','2')
#define FOURCC_wmv2_WMV     mmioFOURCC_WMV('w','m','v','2')
#define FOURCC_WMV1_WMV     mmioFOURCC_WMV('W','M','V','1')
#define FOURCC_wmv1_WMV     mmioFOURCC_WMV('w','m','v','1')
#define FOURCC_M4S2_WMV     mmioFOURCC_WMV('M','4','S','2')
#define FOURCC_m4s2_WMV     mmioFOURCC_WMV('m','4','s','2')
#define FOURCC_MP43_WMV     mmioFOURCC_WMV('M','P','4','3')
#define FOURCC_mp43_WMV     mmioFOURCC_WMV('m','p','4','3')
#define FOURCC_MP4S_WMV     mmioFOURCC_WMV('M','P','4','S')
#define FOURCC_mp4s_WMV     mmioFOURCC_WMV('m','p','4','s')
#define FOURCC_MP42_WMV     mmioFOURCC_WMV('M','P','4','2')
#define FOURCC_mp42_WMV     mmioFOURCC_WMV('m','p','4','2')

/***********************************************************/


/******* video intput type guids, in preference order  *****/

#define FOURCC_I420_WMV		        0x30323449
#define FOURCC_IYUV_WMV		        0x56555949
#define FOURCC_YV12_WMV		        0x32315659
#define FOURCC_YUY2_WMV		        0x32595559
#define FOURCC_UYVY_WMV		        0x59565955
#define FOURCC_YVYU_WMV		        0x55595659
#define FOURCC_YVU9_WMV		        0x39555659
#define FOURCC_BI_RGB_WMV 	        0x00000000
#define FOURCC_BI_BITFIELDS_WMV	    0x00000003

/***********************************************************/


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

tWMVDecodeStatus WMVideoDecInit (
    HWMVDecoder*    phWMVDecoder,
    U32_WMV         uiUserData,
    U32_WMV         uiFOURCCCompressed,
    Float_WMV       fltFrameRate,
    Float_WMV       fltBitRate,
    I32_WMV         iWidthSource,
    I32_WMV         iHeightSource,
    I32_WMV         iPostFilterLevel
);

tWMVDecodeStatus WMVideoDecClose (HWMVDecoder phWMVDecoder);

tWMVDecodeStatus WMVideoDecDecodeSequenceHeader (HWMVDecoder hWMVDecoder);

tWMVDecodeStatus WMVideoDecDecodeData (HWMVDecoder hWMVDecoder, U16_WMV* puiNumDecodedFrames);

tWMVDecodeStatus WMVideoDecGetOutput (
    HWMVDecoder     hWMVDecoder,
    U32_WMV         uiFOURCCOutput,
    U16_WMV         uiBitsPerPixelOutput,
    U8_WMV*         pucDecodedOutput
);

tWMVDecodeStatus WMVideoDecReset (HWMVDecoder hWMVDecoder);

extern tWMVDecodeStatus WMVDecCBGetData (
    U32_WMV     uiUserData,
    U32_WMV     uintPadBeginning,
    U8_WMV **ppchBuffer, 
    U32_WMV uintUserDataLength,
    U32_WMV* puintActualBufferLength,
    Bool_WMV*    pbNotEndOfFrame
);

#ifdef __cplusplus
}
#endif  // __cplusplus

#endif // __WMVDEC_API_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\wmvdec_function.h ===
#include "wmvdec_api.h"
#include "wmvdec_member.h"

#ifndef __WMVDEC_FUNCTION_H_
#define __WMVDEC_FUNCTION_H_


// ===========================================================================
// private functions
// ===========================================================================

// inits
tWMVDecodeStatus WMVInternalMemberInit (
    tWMVDecInternalMember *pWMVDec,
    U32_WMV uiUserData,
    U32_WMV uiFOURCCCompressed,
    Float_WMV fltFrameRate,
    Float_WMV fltBitRate,
    I32_WMV iWidthSource,
    I32_WMV iHeightSource,
    I32_WMV iPostFilterLevel
);

// destroys
tWMVDecodeStatus WMVInternalMemberDestroy (tWMVDecInternalMember *pWMVDec);

// Sequence level decoding
tWMVDecodeStatus setSliceCode (tWMVDecInternalMember *pWMVDec, I32_WMV iSliceCode);
tWMVDecodeStatus decodeVOLHead (tWMVDecInternalMember *pWMVDec);

// frame level decoding

Void_WMV WMVideoDecAssignMotionCompRoutines (tWMVDecInternalMember *pWMVDec);
Void_WMV WMVideoDecSwapCurrAndRef (tWMVDecInternalMember *pWMVDec);
tWMVDecodeStatus WMVideoDecDecodeFrameHead (tWMVDecInternalMember *pWMVDec);
tWMVDecodeStatus WMVideoDecDecodeClipInfo (tWMVDecInternalMember *pWMVDec);

tWMVDecodeStatus WMVideoDecDecodeI_X8 (tWMVDecInternalMember *pWMVDec);
tWMVDecodeStatus WMVideoDecDecodeI (tWMVDecInternalMember *pWMVDec);
tWMVDecodeStatus WMVideoDecDecodeP (tWMVDecInternalMember *pWMVDec);
#ifdef _SUPPORT_POST_FILTERS_
tWMVDecodeStatus WMVideoDecDecodeIDeblock (tWMVDecInternalMember *pWMVDec);
tWMVDecodeStatus WMVideoDecDecodePDeblock (tWMVDecInternalMember *pWMVDec);
#endif

// BMP/color conversion routines

tWMVDecodeStatus WMVideoDecInitBMPInfo (tWMVDecInternalMember *pWMVDec);
tWMVDecodeStatus WMVideoDecColorConvert (tWMVDecInternalMember *pWMVDec, U8_WMV* pucDecodedOutput);

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_GRAY4) || defined (OUTPUT_RGB8) || defined (OUTPUT_RGB12) ||defined (OUTPUT_RGB16) || defined (OUTPUT_RGB24) || defined (OUTPUT_RGB32)
tWMVDecodeStatus g_InitDstTables_WMV (tWMVDecInternalMember *pWMVDec);
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB8) || defined (OUTPUT_RGB16) || defined (OUTPUT_RGB24) || defined (OUTPUT_RGB32)

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_GRAY4)
Void_WMV WMVideoDecUpdateDstPartialMBGRAY4 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iRgbWidth, I32_WMV iRgbHeight
);
Void_WMV WMVideoDecUpdateDstMBGRAY4 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
);
Void_WMV WMVideoDecUpdateDstBlkGRAY4 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
);
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB16)

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB8)
Void_WMV g_InitDstDitherMap_WMV ();
Void_WMV WMVideoDecUpdateDstPartialMBRGB8 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iRgbWidth, I32_WMV iRgbHeight
);
Void_WMV WMVideoDecUpdateDstMBRGB8 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
);
Void_WMV WMVideoDecUpdateDstBlkRGB8 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
);
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB8)

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB12)
Void_WMV WMVideoDecUpdateDstPartialMBRGB12 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iRgbWidth, I32_WMV iRgbHeight
);
#   ifndef OPT_DECOLORCONV_ARM
Void_WMV WMVideoDecUpdateDstMBRGB12 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
);
Void_WMV WMVideoDecUpdateDstBlkRGB12 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
);
#else
extern "C" Void_WMV WMVideoDecUpdateDstMBRGB12 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
);
extern "C" Void_WMV WMVideoDecUpdateDstBlkRGB12 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
);
#endif
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB16)

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB16)
Void_WMV WMVideoDecUpdateDstPartialMBRGB16 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iRgbWidth, I32_WMV iRgbHeight
);
#   ifndef OPT_DECOLORCONV_ARM
    Void_WMV WMVideoDecUpdateDstMBRGB16 (
        tWMVDecInternalMember *pWMVDec,
        U8_WMV* pBits,
        const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
        I32_WMV iWidthY, I32_WMV iWidthUV,
        I32_WMV iBitmapWidth
    );
    Void_WMV WMVideoDecUpdateDstBlkRGB16 (
        tWMVDecInternalMember *pWMVDec,
        U8_WMV* pBits,
        const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
        I32_WMV iWidthY, I32_WMV iWidthUV,
        I32_WMV iBitmapWidth
    );
#   else
    extern "C" Void_WMV WMVideoDecUpdateDstMBRGB16 (
        tWMVDecInternalMember *pWMVDec,
        U8_WMV* pBits,
        const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
        I32_WMV iWidthY, I32_WMV iWidthUV,
        I32_WMV iBitmapWidth
    );
    extern "C" Void_WMV WMVideoDecUpdateDstBlkRGB16 (
        tWMVDecInternalMember *pWMVDec,
        U8_WMV* pBits,
        const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
        I32_WMV iWidthY, I32_WMV iWidthUV,
        I32_WMV iBitmapWidth
    );
#   endif //OPT_DECOLORCONV_ARM
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB16)

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB24)
Void_WMV WMVideoDecUpdateDstPartialMBRGB24 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iRgbWidth, I32_WMV iRgbHeight
);

#   if	!defined(OPT_DECOLORCONV_SH4)
Void_WMV WMVideoDecUpdateDstMBRGB24 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
);
Void_WMV WMVideoDecUpdateDstBlkRGB24 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV *pBits,
    const U8_WMV *pucCurrYMB, const U8_WMV *pucCurrUMB, const U8_WMV *pucCurrVMB,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
);

#   else
    extern "C" Void_WMV WMVideoDecUpdateDstMBRGB24 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
);
    extern "C" Void_WMV WMVideoDecUpdateDstBlkRGB24 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
);


//	extern "C" Void_WMV WMVVideoDecInitDecolorSH4 (float *matrix); This is defined if we use a vector transformation for decolor

#endif //OPT_DECOLORCONV_SH4
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB24)

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB32)
Void_WMV WMVideoDecUpdateDstPartialMBRGB32 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iRgbWidth, I32_WMV iRgbHeight
);
Void_WMV WMVideoDecUpdateDstMBRGB32 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
);
Void_WMV WMVideoDecUpdateDstBlkRGB32 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
);
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB32)

// packed YUV formats

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_YUY2)
Void_WMV WMVideoDecUpdateDstPartialMBYUY2 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iRgbWidth, I32_WMV iRgbHeight
);
Void_WMV WMVideoDecUpdateDstMBYUY2 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrYMB, const U8_WMV* pucCurrUMB, const U8_WMV* pucCurrVMB,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
);
Void_WMV WMVideoDecUpdateDstBlkYUY2 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrYMB, const U8_WMV* pucCurrUMB, const U8_WMV* pucCurrVMB,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
);
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_YUY2)

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_UYVY)
Void_WMV WMVideoDecUpdateDstPartialMBUYVY (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iRgbWidth, I32_WMV iRgbHeight
);
Void_WMV WMVideoDecUpdateDstMBUYVY (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrYMB, const U8_WMV* pucCurrUMB, const U8_WMV* pucCurrVMB,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
);
Void_WMV WMVideoDecUpdateDstBlkUYVY (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrYMB, const U8_WMV* pucCurrUMB, const U8_WMV* pucCurrVMB,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
);
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_UYVY)

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_YVYU)
Void_WMV WMVideoDecUpdateDstPartialMBYVYU (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iRgbWidth, I32_WMV iRgbHeight
);

Void_WMV WMVideoDecUpdateDstMBYVYU (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
);
Void_WMV WMVideoDecUpdateDstBlkYVYU (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
);
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_UYVY)

//Init routines
tWMVDecodeStatus VodecConstruct (
    tWMVDecInternalMember *pWMVDec, 
    U32_WMV               dwFOURCC,
    I32_WMV                 iFrameRate,
    I32_WMV                 iWidthSource, 
    I32_WMV                 iHeightSource,
    CInputBitStream_WMV     *pInputBitstream//,
);
tWMVDecodeStatus  VodecDestruct (tWMVDecInternalMember *pWMVDec);
Void_WMV    m_InitFncPtrAndZigzag(tWMVDecInternalMember *pWMVDec);
Void_WMV    setRefreshPeriod(tWMVDecInternalMember *pWMVDec);
Void_WMV    decideMMXRoutines (tWMVDecInternalMember *pWMVDec);
I32_WMV     assignVODataMembers (tWMVDecInternalMember *pWMVDec);
Void_WMV    g_InitDecGlobalVars ();
tWMVDecodeStatus InitDataMembers (
    tWMVDecInternalMember *pWMVDec,     
    I32_WMV                iWidthSource, 
    I32_WMV                iHeightSource
);

Void_WMV DecodeSkipBit(tWMVDecInternalMember *pWMVDec);
Void_WMV decodeVOPHead_WMV2 (tWMVDecInternalMember *pWMVDec);
Void_WMV UpdateDCStepSize(tWMVDecInternalMember *pWMVDec, I32_WMV iStepSize);

// Loopfilter
#if defined(_ARM_ASM_LOOPFILTER_OPT_) || defined(_SH4_ASM_LOOPFILTER_OPT_)
extern "C" Void_WMV g_FilterHorizontalEdge_WMV(U8_WMV* pV, I32_WMV iPixelDistance, I32_WMV iStepSize, I32_WMV iNumPixel);
extern "C" Void_WMV g_FilterVerticalEdge_WMV(U8_WMV* pV, I32_WMV iPixelDistance, I32_WMV iStepSize, I32_WMV iNumPixel);
#else
Void_WMV g_FilterHorizontalEdge_WMV(U8_WMV* pV, I32_WMV iPixelDistance, I32_WMV iStepSize, I32_WMV iNumPixel);
Void_WMV g_FilterVerticalEdge_WMV(U8_WMV* pV, I32_WMV iPixelDistance, I32_WMV iStepSize, I32_WMV iNumPixel);
#endif //_ARM_ASM_LOOPFILTER_OPT_
#ifdef _WMV_TARGET_X86_
Void_WMV g_FilterHorizontalEdge_MMX(U8_WMV* pV, I32_WMV iPixelDistance, I32_WMV iStepSize, I32_WMV iNumPixel);
Void_WMV g_FilterVerticalEdge_MMX(U8_WMV* pV, I32_WMV iPixelDistance, I32_WMV iStepSize, I32_WMV iNumPixel);
#endif //_WMV_TARGET_X86_
Void_WMV DeblockSLFrame (
    tWMVDecInternalMember *pWMVDec, 
    U8_WMV* ppxliY, U8_WMV* ppxliU, U8_WMV* ppxliV,
    Bool_WMV bMultiThread, U32_WMV iThreadID, I32_WMV iMBStartX, I32_WMV iMBEndX, I32_WMV iMBStartY, I32_WMV iMBEndY
); 

//Deblocking 
Void_WMV DeblockIFrame (
    tWMVDecInternalMember *pWMVDec, 
    U8_WMV* ppxliY,
    U8_WMV* ppxliU,
    U8_WMV* ppxliV,
    U32_WMV iMBStartY, U32_WMV iMBEndY
    );
Void_WMV DeblockPFrame (
    tWMVDecInternalMember *pWMVDec, 
    U8_WMV* ppxliY,
    U8_WMV* ppxliU,
    U8_WMV* ppxliV,
    U32_WMV iMBStartY, U32_WMV iMBEndY
    );
Void_WMV AssignDeblokRoutines (tWMVDecInternalMember *pWMVDec);
#if defined(_SUPPORT_POST_FILTERS_) && defined(_WMV_TARGET_X86_)
tWMVDecodeStatus WMVDecideDeblokLevel (tWMVDecInternalMember *pWMVDec, I32_WMV iWidth, I32_WMV iHeight);
#endif

// Block based routines
tWMVDecodeStatus DecodeIMBAcPred (
    tWMVDecInternalMember *pWMVDec, 
    CWMVMBMode*        pmbmd, 
    U8_WMV*  ppxliTextureQMBY, 
    U8_WMV*  ppxliTextureQMBU, 
    U8_WMV*  ppxliTextureQMBV, 
    I16_WMV*            piQuanCoefACPred, 
    I16_WMV**           piQuanCoefACPredTable, 
    Bool_WMV            bLeftMB, 
    Bool_WMV            bTopMB, 
    Bool_WMV            bLeftTopMB
);

tWMVDecodeStatus DecodeIMBAcPred_PFrame (
    tWMVDecInternalMember *pWMVDec, 
    CWMVMBMode*        pmbmd, 
    U8_WMV*  ppxliTextureQMBY, 
    U8_WMV*  ppxliTextureQMBU, 
    U8_WMV*  ppxliTextureQMBV, 
    I16_WMV*            piQuanCoefACPred, 
    I16_WMV**           piQuanCoefACPredTable, 
    Bool_WMV            bLeftMB, 
    Bool_WMV            bTopMB, 
    Bool_WMV            bLeftTopMB
);

#ifndef _EMB_WMV2_
tWMVDecodeStatus DecodePMB (
    tWMVDecInternalMember *pWMVDec, 
    CWMVMBMode*        pmbmd,
	U8_WMV* ppxlcCurrQYMB,
	U8_WMV* ppxlcCurrQUMB,
	U8_WMV* ppxlcCurrQVMB,
	CoordI xRefY, CoordI yRefY,
	CoordI xRefUV, CoordI yRefUV
);
#endif //_EMB_WMV2_

// decode MB header 
tWMVDecodeStatus decodeMBOverheadOfIVOP_MSV (tWMVDecInternalMember *pWMVDec, CWMVMBMode* pmbmd, I32_WMV imbX, I32_WMV imbY);
tWMVDecodeStatus decodeMBOverheadOfPVOP_MSV (tWMVDecInternalMember *pWMVDec, CWMVMBMode* pmbmd);
// decode MV
Bool_WMV decideHybridMVOn (tWMVDecInternalMember *pWMVDec, CoordI x, Bool_WMV bNot1stRowInSlice, const CVector* pmv);
Void_WMV find16x16MVpred (
    tWMVDecInternalMember *pWMVDec, 
    CVector& vecPredHalfPel, 
    const CVector* pmv,
    const CWMVMBMode* pmbmd,
    Bool_WMV bLeftBndry, 
    Bool_WMV bRightBndry, 
    Bool_WMV bTopBndry
);
tWMVDecodeStatus decodeMVMSV (tWMVDecInternalMember *pWMVDec, CVector* pmv, const CWMVMBMode* pmbmd, Bool_WMV bLeftBndry, Bool_WMV bRightBndry, Bool_WMV bTopBndry, Huffman_WMV* pHufMVDec, U8_WMV* uXMvFromIndex, U8_WMV* uYMvFromIndex);

// Decode Coefs
tWMVDecodeStatus DecodeInverseInterBlockQuantizeEscCode (tWMVDecInternalMember *pWMVDec, CDCTTableInfo_Dec* InterDCTTableInfo_Dec, U8_WMV* pZigzag, I32_WMV iXformMode);
tWMVDecodeStatus DecodeInverseInterBlockQuantizeEscCode_MMX (tWMVDecInternalMember *pWMVDec, CDCTTableInfo_Dec* InterDCTTableInfo_Dec, U8_WMV* pZigzag, I32_WMV iXformMode);
tWMVDecodeStatus DecodeInverseIntraBlockQuantizeAcPred_MPEG4 (tWMVDecInternalMember *pWMVDec, CDCTTableInfo_Dec* IntraDCTTableInfo_Dec, Bool_WMV CBP, I16_WMV* pDct, U8_WMV* piZigzagInv);
tWMVDecodeStatus DecodeInverseIntraBlockQuantizeAcPred (tWMVDecInternalMember *pWMVDec, 
	CDCTTableInfo_Dec* IntraDCTTableInfo_Dec, 
	Bool_WMV CBP, 
	I16_WMV* pDct, 
	U8_WMV* piZigzagInv
);

tWMVDecodeStatus decodeIntraBlockAcPred (tWMVDecInternalMember *pWMVDec, 
	CDCTTableInfo_Dec* IntraDCTTableInfo_Dec, 
	CWMVMBMode*        pmbmd,
    U8_WMV   *ppxliTextureQMB,        //place to set the pixels
    I32_WMV             iOffsetToNextRowForDCT,
	I32_WMV             ib, 
    I16_WMV*            piQuanCoef1stRowColAC, 
    I16_WMV*            pRef, 
    Bool_WMV            bPredPattern
);
Void_WMV decodeBitsOfESCCode (tWMVDecInternalMember *pWMVDec);


// Motion Compensation
#ifndef _EMB_WMV2_
Void_WMV MotionCompMixed (MOTION_COMP_ARGS);
Void_WMV MotionCompMixedAndAddError (MOTION_COMP_ADD_ERROR_ARGS);
#endif //_EMB_WMV2_

Void_WMV MotionCompMixed_MMX (MOTION_COMP_ARGS);
Void_WMV MotionCompMixedAndAddError_MMX (MOTION_COMP_ADD_ERROR_ARGS);

Void_WMV MotionCompMixed_KNI (MOTION_COMP_ARGS);
Void_WMV MotionCompMixedAndAddError_KNI (MOTION_COMP_ADD_ERROR_ARGS);


// AC_DC Pred    
I16_WMV* decodeDiffDCTCoef(
    tWMVDecInternalMember *pWMVDec, 
    I16_WMV**   piQuanCoefACPredTable,
    Bool_WMV    bLeftMB,
    Bool_WMV    bTopMB,
    Bool_WMV    bLeftTopMB, 
    Bool_WMV&   bPredPattern
);
I16_WMV* decodeDiffDCTCoef_WMV(
    tWMVDecInternalMember *pWMVDec, 
    U8_WMV* ppxliTextureQMB,
    I16_WMV**   piQuanCoefACPredTable,
    Bool_WMV    bLeftMB,
    Bool_WMV    bTopMB,
    Bool_WMV    bLeftTopMB, 
    Bool_WMV    bLeftMBAndInter,
    Bool_WMV    bTopMBAndInter,
    Bool_WMV    bLeftTopMBAndInter, 
    Bool_WMV&   bPredPattern,
    I32_WMV     iWidthPrev,
    I32_WMV     iStepSize
);
I16_WMV* decodeDiffDCTCoef_WMV_Y23(
    I16_WMV** piQuanCoefACPredTable, 
    Bool_WMV bLeftMB, 
    Bool_WMV bTopMB, 
    Bool_WMV bLeftTopMB, 
    Bool_WMV& bPredPattern
);
Void_WMV decodeIntraDCAcPredMSV (tWMVDecInternalMember *pWMVDec, tWMVDecodeStatus* pError, Huffman_WMV* hufDCTDCDec, I32_WMV iTCOEF_ESCAPE);
I32_WMV BlkAvgX8(const U8_WMV* ppxlcCurrRecnMB, I32_WMV iWidthPrev, I32_WMV iStepSize);
I32_WMV BlkAvgX8_MMX(const U8_WMV* ppxlcCurrRecnMB, I32_WMV iWidthPrev, I32_WMV iStepSize);


// Routines to support MP4X's routines.
//#ifdef _WMVONLY_
tWMVDecodeStatus DecodeIMBAcPred_MP4X(tWMVDecInternalMember *pWMVDec, CWMVMBMode* pmbmd, U8_WMV* ppxliTextureQMBY, U8_WMV* ppxliTextureQMBU, U8_WMV* ppxliTextureQMBV, 
    I16_WMV* piQuanCoefACPred, I16_WMV** piQuanCoefACPredTable, Bool_WMV bLeftMB, Bool_WMV bTopMB, Bool_WMV bLeftTopMB);
Void_WMV decodeIntraDCAcPred (tWMVDecInternalMember *pWMVDec, tWMVDecodeStatus* pError, U8_WMV DecodeCodeTableIntraDC[], I32_WMV iMaxCodeWordLngIntraDC);
tWMVDecodeStatus decodeMBOverheadOfIVOP_New (tWMVDecInternalMember *pWMVDec, CWMVMBMode* pmbmd, I32_WMV imbX, I32_WMV imbY);
tWMVDecodeStatus decodeMBOverheadOfPVOP_New (tWMVDecInternalMember *pWMVDec, CWMVMBMode* pmbmd);
tWMVDecodeStatus decodeMV (tWMVDecInternalMember *pWMVDec, CVector* pmv, const CWMVMBMode* pmbmd, Bool_WMV bLeftBndry, Bool_WMV bRightBndry, Bool_WMV bTopBndry);
I32_WMV checkResyncMarker(tWMVDecInternalMember *pWMVDec);
tWMVDecodeStatus decodeMBOverheadOfIVOP_MPEG4 (tWMVDecInternalMember *pWMVDec, CWMVMBMode* pmbmd, I32_WMV imbX, I32_WMV imbY);
tWMVDecodeStatus decodeMBOverheadOfPVOP_MPEG4 (tWMVDecInternalMember *pWMVDec, CWMVMBMode* pmbmd);
Void_WMV decodeIntraDCAcPred_MPEG4 (tWMVDecInternalMember *pWMVDec, tWMVDecodeStatus* pError, U8_WMV DecodeCodeTableIntraDC[], I32_WMV iMaxCodeWordLngIntraDC);
tWMVDecodeStatus DecodeInverseInterBlockQuantizeEscCode_MPEG4(tWMVDecInternalMember *pWMVDec, CDCTTableInfo_Dec* InterDCTTableInfo_Dec, U8_WMV *pZigzagInv, I32_WMV iXformMode);
tWMVDecodeStatus DecodeInverseInterBlockQuantizeEscCode_MMX_MPEG4(tWMVDecInternalMember *pWMVDec, CDCTTableInfo_Dec* InterDCTTableInfo_Dec, U8_WMV *pZigzagInv, I32_WMV iXformMode);
tWMVDecodeStatus DecodeInverseIntraBlockQuantizeAcPred_MPEG4 (tWMVDecInternalMember *pWMVDec, CDCTTableInfo_Dec* IntraDCTTableInfo_Dec, Bool_WMV CBP, I16_WMV* pDct, U8_WMV* piZigzagInv);
tWMVDecodeStatus decodeVOLHeadMP4S(tWMVDecInternalMember *pWMVDec);
I32_WMV	decodeVideoPacketHeader(tWMVDecInternalMember *pWMVDec, I32_WMV& iCurrentQP);
Void_WMV getDiffMV (tWMVDecInternalMember *pWMVDec, CVector& vctDiffMV);
Void_WMV fitMvInRange (CVector& vctSrc, I32_WMV iMvRange);

#ifdef _EMB_WMV2_
tWMVDecodeStatus DecodeInverseInterBlockQuantizeEscCode_MPEG4_EMB(tWMVDecInternalMember *pWMVDec, CDCTTableInfo_Dec* InterDCTTableInfo_Dec, U8_WMV *pZigzagInv, I32_WMV iXformMode);

tWMVDecodeStatus DecodePMB_EMB (
    tWMVDecInternalMember *pWMVDec,
    CWMVMBMode*            pmbmd, 
//    const Bool* rgCBP, 
    U8_WMV* ppxlcCurrQYMB,
    U8_WMV* ppxlcCurrQUMB,
    U8_WMV* ppxlcCurrQVMB,
    CoordI xRefY, CoordI yRefY,
    CoordI xRefUV, CoordI yRefUV
);

Void_WMV InitEMB_FuncTable(tWMVDecInternalMember *pWMVDec);

extern "C"  Void_WMV MotionCompMixed011(U8_WMV*   ppxlcPredMB, const U8_WMV*  ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV * pErrorBuf);
extern "C" Void_WMV MotionCompMixed010(U8_WMV*   ppxlcPredMB, const U8_WMV*  ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV * pErrorBuf);
extern "C" Void_WMV MotionCompMixed110(U8_WMV*   ppxlcPredMB, const U8_WMV*  ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV * pErrorBuf);
extern "C" Void_WMV MotionCompMixed001(U8_WMV*   ppxlcPredMB, const U8_WMV*  ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV * pErrorBuf);
extern "C" Void_WMV MotionCompMixed101(U8_WMV*   ppxlcPredMB, const U8_WMV*  ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV * pErrorBuf);
extern "C" Void_WMV MotionCompMixed000(U8_WMV*   ppxlcPredMB, const U8_WMV*  ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV * pErrorBuf);
extern "C" Void_WMV MotionCompMixed100(U8_WMV*   ppxlcPredMB, const U8_WMV*  ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV * pErrorBuf);
extern "C" Void_WMV MotionCompMixed111(U8_WMV*   ppxlcPredMB, const U8_WMV*  ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV * pErrorBuf);
extern "C" Void_WMV MotionCompWAddError01(U8_WMV __huge* ppxlcPredMB, const U8_WMV __huge*ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV *pErrorBuf);
extern "C" Void_WMV MotionCompWAddError10(U8_WMV __huge* ppxlcPredMB, const U8_WMV __huge*ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV *pErrorBuf);
extern "C" Void_WMV MotionCompWAddError00(U8_WMV __huge* ppxlcPredMB, const U8_WMV __huge*ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV *pErrorBuf);
extern "C" Void_WMV MotionCompMixedAlignBlock(U8_WMV*   pBlock, const U8_WMV*  ppxlcRefMB, I32_WMV iWidthPrev);
extern "C" Void_WMV MotionCompMixedHQHI(U8_WMV* ppxlcPredMB,  const U8_WMV* ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV * ppxliErrorBuf, U8_WMV* alignedBlock);

extern "C" Void_WMV MotionCompMixed011Complete(U8_WMV*   ppxlcPredMB, const U8_WMV*  ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV * pErrorBuf);
extern "C" Void_WMV MotionCompMixed010Complete(U8_WMV*   ppxlcPredMB, const U8_WMV*  ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV * pErrorBuf);
extern "C" Void_WMV MotionCompMixed110Complete(U8_WMV*   ppxlcPredMB, const U8_WMV*  ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV * pErrorBuf);
extern "C" Void_WMV MotionCompMixed001Complete(U8_WMV*   ppxlcPredMB, const U8_WMV*  ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV * pErrorBuf);
extern "C" Void_WMV MotionCompMixed101Complete(U8_WMV*   ppxlcPredMB, const U8_WMV*  ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV * pErrorBuf);
extern "C" Void_WMV MotionCompMixed000Complete(U8_WMV*   ppxlcPredMB, const U8_WMV*  ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV * pErrorBuf);
extern "C" Void_WMV MotionCompMixed100Complete(U8_WMV*   ppxlcPredMB, const U8_WMV*  ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV * pErrorBuf);
extern "C" Void_WMV MotionCompMixed111Complete(U8_WMV*   ppxlcPredMB, const U8_WMV*  ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV * pErrorBuf);
extern "C" Void_WMV MotionCompWAddError01Complete(U8_WMV __huge* ppxlcPredMB, const U8_WMV __huge*ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV *pErrorBuf);
extern "C" Void_WMV MotionCompWAddError10Complete(U8_WMV __huge* ppxlcPredMB, const U8_WMV __huge*ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV *pErrorBuf);
extern "C" Void_WMV MotionCompWAddError00Complete(U8_WMV __huge* ppxlcPredMB, const U8_WMV __huge*ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV *pErrorBuf);
extern "C" Void_WMV MotionCompMixedAlignBlockComplete(U8_WMV*   pBlock, const U8_WMV*  ppxlcRefMB, I32_WMV iWidthPrev);
extern "C" Void_WMV MotionCompMixedHQHIComplete(U8_WMV* ppxlcPredMB, const U8_WMV* ppxlcRefMB, I32_WMV iWidthPrev, I32_WMV * ppxliErrorBuf, U8_WMV* alignedBlock);

 tWMVDecodeStatus DecodeInverseInterBlockQuantizeEscCodeEMB (tWMVDecInternalMember *pWMVDec, CDCTTableInfo_Dec* InterDCTTableInfo_Dec, U8_WMV* pZigzag, EMB_DecodeP_ShortCut *);

#ifdef OPT_IDCT_ARM
extern "C" Void_WMV g_IDCTDec_WMV2_16bit (Buffer __huge* piDst, Buffer __huge* piSrc, I32_WMV iOffsetToNextRowForDCT, I32_WMV iDCTHorzFlags);
extern "C" Void_WMV g_8x4IDCTDec_WMV2_16bit (Buffer __huge* piDstBuf, I32_WMV iOffsetToNextRowForDCT, const Buffer __huge* rgiCoefReconBuf, I32_WMV iHalfAndiDCTHorzFlags);
extern "C" Void_WMV g_4x8IDCTDec_WMV2_16bit (Buffer __huge* piDstBuf, I32_WMV iOffsetToNextRowForDCT, const Buffer __huge* rgiCoefReconBuf, I32_WMV iHalfAndiDCTHorzFlags);
#else
Void_WMV g_IDCTDec_WMV2_16bit (Buffer __huge* piDst, Buffer __huge* piSrc, I32_WMV iOffsetToNextRowForDCT, I32_WMV iDCTHorzFlags);
Void_WMV g_8x4IDCTDec_WMV2_16bit (Buffer __huge* piDstBuf, I32_WMV iOffsetToNextRowForDCT, const Buffer __huge* rgiCoefReconBuf, I32_WMV iHalfAndiDCTHorzFlags);
Void_WMV g_4x8IDCTDec_WMV2_16bit (Buffer __huge* piDstBuf, I32_WMV iOffsetToNextRowForDCT, const Buffer __huge* rgiCoefReconBuf, I32_WMV iHalfAndiDCTHorzFlags);
#endif //OPT_IDCT_ARM

Void_WMV InitEMB_DecodePShortcut(tWMVDecInternalMember *pWMVDec);
#endif

#ifdef COMBINE_LOOPFILTER_RENDERING
tWMVDecodeStatus combine_loopfilter_rendering ( tWMVDecInternalMember *pWMVDec,  U8_WMV* pucDecodedOutput);  // Frame-based deblocking
    //#endif
#endif

Void_WMV Huffman_WMV_construct(Huffman_WMV * pThis);
Void_WMV Huffman_WMV_destruct(Huffman_WMV * pThis);
VResult Huffman_WMV_init (Huffman_WMV * pThis, U32_WMV uiUserData, tPackHuffmanCode_WMV huffArray[], I32_WMV *maxBits, I32_WMV iMAX_STAGES);

#ifdef OPT_HUFFMAN_GET_WMV

//I32_WMV getHuffman(CInputBitStream_WMV *bs,void * data);
U32_WMV getHuffman(CInputBitStream_WMV *bs,TableInfo *tableInfo, HuffDecInfo *decTable);

inline I32_WMV Huffman_WMV_get(Huffman_WMV * pThis, CInputBitStream_WMV *bs)
  {
	  //return getHuffman(bs, pThis);
      return getHuffman(bs, pThis->m_tableInfo, pThis->m_decInfo);
	  
  }
#else
I32_WMV Huffman_WMV_get(Huffman_WMV * pThis, CInputBitStream_WMV *bs);
#endif

Void_WMV BS_construct (CInputBitStream_WMV * pThis, U32_WMV uiUserData);
Void_WMV
BS_reset(
    CInputBitStream_WMV * pThis,
    U8_WMV          *pBuffer,
    U32_WMV        dwBuflen,
    Bool_WMV        bNotEndOfFrame
    );

#ifdef DYNAMIC_EDGEPAD
Void_WMV edgePadInit(tWMVDecInternalMember *pWMVDec, tWMVEdgePad * pEdgePad );
Void_WMV edgePadDestroy(tWMVEdgePad * pEdgePad );
Void_WMV edgePadSetup(tWMVDecInternalMember *pWMVDec, tWMVEdgePad * pEdgePad );
#endif

#if defined(_6BIT_COLORCONV_OPT_) || defined(OUTPUT_ALL_FORMATS) || defined(OUTPUT_RGB12) || defined (OUTPUT_GRAY4)
Void_WMV g_EndDstTables_WMV(tWMVDecInternalMember *pWMVDec);
#endif

#endif // __WMVDEC_FUNCTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\wmf_loadstuff.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       loadStuff.h
//
//--------------------------------------------------------------------------

#ifndef LOADSTUFF_H
#define LOADSTUFF_H

#include "wmc_type.h"

#if defined(_MSC_VER) || defined(LINUX_x86)
#define LITTLE_ENDIAN
#endif

#ifdef LITTLE_ENDIAN

#define GetUnalignedWord( pb, w )   (w) = *(UNALIGNED U16_WMC*)(pb); 

#define GetUnalignedDword( pb, dw ) (dw) = *(UNALIGNED U32_WMC*)(pb);

#define GetUnalignedQword( pb, qw ) (qw) = *(UNALIGNED U64_WMC*)(pb);

#define GetUnalignedDouble( pb, d ) (d) = *(UNALIGNED Double_WMC*)(pb);

#else

#define GetUnalignedWord( pb, w ) \
            (w) = ((U16_WMC) *(pb + 1) << 8) + *pb;

#define GetUnalignedDword( pb, dw ) \
            (dw) = ((U32_WMC) *(pb + 3) << 24) + \
                   ((U32_WMC) *(pb + 2) << 16) + \
                   ((U16_WMC) *(pb + 1) << 8) + *pb;
/*
#define GetUnalignedQword( pb, qw ) \
            GetUnalignedDword( pb, (qw).dwLo ); \
            GetUnalignedDword( (pb + 4), (qw).dwHi );
*/
#define GetUnalignedQword( pb, qw ) \
            GetUnalignedDword( pb, (*((U32_WMC *)(&(qw)))) ); \
            GetUnalignedDword( (pb + 4), (*(((U32_WMC *)(&(qw)))+1)) );

#define GetUnalignedDouble( pb, d ) (d) = *(UNALIGNED Double_WMC*)(pb);

#endif

#define GetUnalignedWordEx( pb, w )     GetUnalignedWord( pb, w ); (pb) += sizeof(U16_WMC);
#define GetUnalignedDwordEx( pb, dw )   GetUnalignedDword( pb, dw ); (pb) += sizeof(U32_WMC);
#define GetUnalignedQwordEx( pb, qw )   GetUnalignedQword( pb, qw ); (pb) += sizeof(U64_WMC);
#define GetUnalignedDoubleEx( pb, d )   GetUnalignedDouble( pb, d ); (pb) += sizeof(Double_WMC);

#define LoadBYTE( b, p )    b = *(U8_WMC *)p;  p += sizeof( U8_WMC )

#define LoadWORD( w, p )    GetUnalignedWordEx( p, w )
#define LoadDWORD( dw, p )  GetUnalignedDwordEx( p, dw )
#define LoadQWORD( qw, p )  GetUnalignedQwordEx( p, qw )

#define LoadGUID( g, p ) \
        { \
            LoadDWORD( g.Data1, p ); \
            LoadWORD( g.Data2, p ); \
            LoadWORD( g.Data3, p ); \
            LoadBYTE( g.Data4[0], p ); \
            LoadBYTE( g.Data4[1], p ); \
            LoadBYTE( g.Data4[2], p ); \
            LoadBYTE( g.Data4[3], p ); \
            LoadBYTE( g.Data4[4], p ); \
            LoadBYTE( g.Data4[5], p ); \
            LoadBYTE( g.Data4[6], p ); \
            LoadBYTE( g.Data4[7], p ); \
        }

#endif  // LOADSTUFF_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\wmvdec_member.h ===
#ifndef __WMVDEC_MEMBER_H_
#define __WMVDEC_MEMBER_H_
#include "wmvdec_api.h"
#include "typedef.hpp"

#include "xplatform.h"
#include "stdio.h"
#include "Huffman_wmv.hpp"
#include "strmdec_wmv.hpp"
#include "motioncomp_wmv.h"
#include "bitfields.h"
#include "wmvdec_api.h"

//class CInputBitStream_WMV;
class ifstream;
class istream;
//class Huffman_WMV;

#ifdef _6BIT_COLORCONV_OPT_
typedef struct
{
    I8_WMV g_iYscale [256];
    I8_WMV g_iVtoR [256];
    I8_WMV g_iVtoG [256];
    I8_WMV g_iUtoG [256];
    I8_WMV g_iUtoB [256];
    
}
YUV2RGB_6BIT_TABLE;

#endif

#ifdef _EMB_WMV2_

/* the relative offsets of the fields of these classes are important for CE assembly optimizations. Affected files are:
    blkdec_ce_arm.s
*/

struct tagWMVDecInternalMember;

typedef struct _CDCTTableInfo_Dec {
	Huffman_WMV* hufDCTACDec; 
	U32_WMV  iTcoef_ESCAPE;
	U32_WMV  iStartIndxOfLastRunMinus1;
    U8_WMV* puiNotLastNumOfLevelAtRun; 
    U8_WMV* puiLastNumOfLevelAtRun; 
    U8_WMV* puiNotLastNumOfRunAtLevel; 
    U8_WMV* puiLastNumOfRunAtLevel;
    I8_WMV* pcLevelAtIndx; 
    U8_WMV* puiRunAtIndx; 
}CDCTTableInfo_Dec;

/* the relative offsets of the fields of these classes are important for CE assembly optimizations. Affected files are:
    blkdec_ce_arm.s
*/
typedef struct tagEMB_DecodeP_ShortCut
{

    struct tagWMVDecInternalMember * pVideoDecoderObject;

    I32_WMV * m_rgiCoefRecon;
    own CInputBitStream_WMV * m_pbitstrmIn;
    I32_WMV m_i2DoublePlusStepSize;
    I32_WMV m_iDoubleStepSize;
    I32_WMV m_iStepMinusStepIsEven;

    I32_WMV XFormMode;
    I32_WMV m_iDCTHorzFlags;

}EMB_DecodeP_ShortCut;

#else

typedef struct _CDCTTableInfo_Dec {
	Huffman_WMV* hufDCTACDec; 
	U32_WMV  iTcoef_ESCAPE;
	U32_WMV  iStartIndxOfLastRunMinus1;
    U8_WMV* puiNotLastNumOfLevelAtRun; 
    U8_WMV* puiLastNumOfLevelAtRun; 
    U8_WMV* puiNotLastNumOfRunAtLevel; 
    U8_WMV* puiLastNumOfRunAtLevel;
    I8_WMV* pcLevelAtIndx; 
    U8_WMV* puiRunAtIndx; 
}CDCTTableInfo_Dec;

#endif


enum THREADTYPE_DEC {REPEATPAD, DECODE, RENDER, LOOPFILTER, DEBLOCK, DEBLOCK_RENDER};
enum KEYS {FPPM, CPPM, PPM, RES, BITRATE};
enum SKIPBITCODINGMODE {Normal = 0, RowPredict, ColPredict};
//I32_WMV AccessRegistry(enum KEYS k, char rw, I32_WMV iData);

struct t_ContextWMV;
struct t_SpatialPredictor;
struct t_AltTablesDecoder;
// WMV2's new routines

#ifdef DYNAMIC_EDGEPAD
typedef struct
{
    I32_WMV m_iStartOfLastLine;
    I16_WMV m_iPMBMV_limit_x;  //m_iWidth-BLOCKSIZE_PLUS_2EDGES
    I16_WMV m_iPMBMV_limit_y;  //m_iHeight-BLOCKSIZE_PLUS_2EDGES
    I16_WMV m_iWidth;    
    I16_WMV m_iHeight;
}EdgePad_Y_UV_Data;

typedef struct
{
    U8_WMV * m_ppxliRef; //MB(Y) or Blk(UV) starting address for ref plane
    U8_WMV * m_ppxliCurr; //MB(Y) or Blk(UV) starting address for curr plane
    U8_WMV * m_ppxliRef0; //origins of ref for the YUV planes
         
    I32_WMV m_BlkInc;  //block incremental in the normal case
}
EdgePad_Blk_Data;

typedef struct _WMVEdgePad
{
    I16_WMV m_iPBMV_x;  //position of the (enlarged) block : block + surrounding edges
    I16_WMV m_iPBMV_y;  
    I16_WMV m_iWidthYMinusAllEdges;  
    I16_WMV m_iHeightYMinusAllEdges;  
    I16_WMV x_off_left;
    I16_WMV x_off_right;
    I32_WMV src_offset; 
    U8_WMV * ppxlcRefBufferOrig; 
    U8_WMV * ppxlcRef; 
    U8_WMV * ppxlcCurr;
    U32_WMV m_iWidthCombine;
    U32_WMV m_iround_ctrl;

    EdgePad_Y_UV_Data y_uv_data[2];

    EdgePad_Blk_Data blk_data[6];
    

    U8_WMV * buffer;

}
tWMVEdgePad;

#endif
// basic structs

typedef enum tagFrameType_WMV
{
//    IFRAME_WMV = 0, 
//    PFRAME_WMV
      IVOP = 0, 
      PVOP
} tFrameType_WMV;

typedef struct tagYUV420Frame_WMV
{
    U8_WMV* m_pucYPlane;
    U8_WMV* m_pucUPlane;
    U8_WMV* m_pucVPlane;

    U8_WMV* m_pucYPlane_Unaligned;
    U8_WMV* m_pucUPlane_Unaligned;
    U8_WMV* m_pucVPlane_Unaligned;

} tYUV420Frame_WMV;

typedef struct tagMotionVector_WMV
{
    I16_WMV m_iMVX;
    I16_WMV m_iMVY;
} tMotionVector_WMV;


// ===========================================================================
// private data members
// ===========================================================================
struct tagWMVDecInternalMember;
typedef struct tagWMVDecInternalMember 
{
    // Don't add any thing before this variable! It has been used by ARM assembly code
    #if defined(OUTPUT_ALL_FORMATS) || defined(OUTPUT_RGB12) || defined(OUTPUT_GRAY4)
        U8_WMV* m_rgiClapTab4BitDec;
        U32_WMV* m_rgiDithering;
        I32_WMV m_iDitheringIndex;
    #endif

    U32_WMV m_uiUserData;

    // sequence layer info
CInputBitStream_WMV     *m_pInputBitstream;
    own CInputBitStream_WMV* m_pbitstrmIn;
    U32_WMV m_uiFOURCCCompressed;
    I32_WMV m_iPostFilterLevel;
    Float_WMV m_fltFrameRate;
    Float_WMV m_fltBitRate;
    I32_WMV m_iFrameRate;
    I32_WMV m_iBitRate; // in Kbps

    //VOLMode m_volmd; // vol mode
    //VOPMode m_vopmd; // vop mode
    Bool_WMV m_fPrepared;
    Bool_WMV m_fDecodedI;

    U16_WMV m_uiNumFramesLeftForOutput;

    // size info
    I32_WMV m_iWidthSource; // source width, might not be MB aligned
    I32_WMV m_iHeightSource; // source height, might not be MB aligned
    I32_WMV m_iWidthInternal; // internal width, MB aligned
    I32_WMV m_iWidthInternalTimesMB;
    I32_WMV m_iHeightInternal;
    I32_WMV m_iWidthInternalUV;
    I32_WMV m_iWidthInternalUVTimesBlk;
    I32_WMV m_iHeightInternalUV;
    Bool_WMV m_bSizeMBAligned;
    U32_WMV m_uiNumMB, m_uiNumMBX, m_uiNumMBY;
U32_WMV m_uintNumMBX, m_uintNumMBY, m_uintNumMB, m_uiRightestMB;

    Bool_WMV m_bMBAligned;

    I32_WMV m_iFrmWidthSrc, m_iFrmHeightSrc; // original, non-MB-aligned size of input bitmap
    I32_WMV m_iWidthYRepeatPad, m_iWidthUVRepeatPad; // equal original for MP43, else = m_iWidthY
    I32_WMV m_iHeightYRepeatPad, m_iHeightUVRepeatPad; // equal original for MP43, else = m_iHeightY
    I32_WMV m_iWidthY, m_iWidthYPlusExp, m_iHeightY;
    I32_WMV m_iWidthUV, m_iWidthUVPlusExp, m_iHeightUV;
    I32_WMV m_iWidthPrevY, m_iWidthPrevUV;
    I32_WMV m_iHeightPrevY, m_iHeightPrevUV;
    I32_WMV m_iWidthPrevYXExpPlusExp, m_iWidthPrevUVXExpPlusExp;
	I32_WMV m_iMBSizeXWidthPrevY; // MB size (16) * width of Y-Plane, for accessing MB data
	I32_WMV m_iBlkSizeXWidthPrevUV;
    I32_WMV m_iWidthPrevYxBlkMinusBlk;
    I32_WMV m_iMVLeftBound, m_iMVRightBound;

    // tables
    const U8_WMV* m_rgiClapTabDec;


    // pictures, frame's data
    tYUV420Frame_WMV* m_pfrmCurrQ;
    tYUV420Frame_WMV* m_pfrmPrev;
    tYUV420Frame_WMV* m_pfrmPostQ;
 	U8_WMV* m_ppxliCurrQPlusExpY;
	U8_WMV* m_ppxliCurrQPlusExpU;
	U8_WMV* m_ppxliCurrQPlusExpV;
    U8_WMV* m_ppxliRef0Y;
    U8_WMV* m_ppxliRef0U;
    U8_WMV* m_ppxliRef0V;
    U8_WMV* m_ppxliRef0YPlusExp;
    U8_WMV* m_ppxliPostQY;
    U8_WMV* m_ppxliPostQU;
    U8_WMV* m_ppxliPostQV;
    U8_WMV* m_ppxliPostQPlusExpY;
    U8_WMV* m_ppxliPostQPlusExpU;
    U8_WMV* m_ppxliPostQPlusExpV;

    CVector* m_rgmv;                    // 2 MB row's MV
    CWMVMBMode*	m_rgmbmd;               // 2 MB row's MV
    CWMVMBMode*	m_pmbmdZeroCBPCY;       // Pointer to the ZeroCBPCY
    U8_WMV* m_rgchSkipPrevFrame;            // Prev frame's Skip bits

    // sequence layer info
    Bool_WMV m_bIFrameDecoded;
    Bool_WMV m_bXintra8Switch;
    Bool_WMV m_bXformSwitch;
    Bool_WMV m_bSKIPBIT_CODING_;
    Bool_WMV m_bNEW_PCBPCY_TABLE;
    Bool_WMV m_bMixedPel;
    Bool_WMV m_bLoopFilter;
    Bool_WMV m_bRndCtrlOn;
    I32_WMV m_iRndCtrl;
//    Bool_WMV m_iSliceCode;
    I32_WMV m_iSliceCode;
    U32_WMV m_uintNumMBYSlice; // slice size (number of MB's vertically)
    CodecVersion m_cvCodecVersion;
    Bool_WMV m_bMainProfileOn;
    Bool_WMV m_bMMXSupport;

    // picture layer info.
    tFrameType_WMV m_tFrmType;
    SKIPBITCODINGMODE m_SkipBitCodingMode;
    Bool_WMV m_bXintra8;
    Bool_WMV m_bFrmHybridMVOn;
    Bool_WMV m_bDCTTable_MB, m_bDCTTable_MB_ENABLED, m_bDCPred_IMBInPFrame;
    Bool_WMV m_bCODFlagOn;          // COD flag is on (coded) for a P frame
    I32_WMV m_iMvResolution;        // Indicate current frame's MV resolution

    I32_WMV m_iStepSize;

    I32_WMV m_iDCStepSize, m_iDCStepSizeC;
    I32_WMV m_i2DoublePlusStepSize, m_i2DoublePlusStepSizeNeg;
    I32_WMV m_iDoubleStepSize, m_iStepMinusStepIsEven;
    Bool_WMV m_bStepSizeIsEven;

    // MB layer info
    Bool_WMV m_bMBHybridMV;         // Indicates whether MB-based HybridMV is on
    Bool_WMV m_bMBXformSwitching;   // Indicates whether MB-based transform switching is chosen for the frame
    I32_WMV m_iMixedPelMV;          // 0 -> True MV, 1 -> Mixed
    I32_WMV m_iFrameXformMode;      // Transform mode (8x8, 8x4 or 4x8) for entire frame
    I32_WMV m_iOffsetToTopMB;       // m_uintNumMBX or -m_uintNumMBX to cycle 2 rows of MB data
       
    // Block layer buffers
    U8_WMV m_riReconBuf[64*4+32];   // IDCT coeff recon buffer. Allow enough space for 32-byte alignment
    U8_WMV m_riPixelError[64*4+32]; // Pixel error buffer. Allow enough space for 32-byte alignment
    PixelI32 __huge* m_rgiCoefReconPlus1;
    PixelI32 __huge* m_rgiCoefRecon;   
    Buffer __huge* m_ppxliErrorQ;
    Buffer __huge* m_rgiCoefReconBuf;

    // zigzag scan
    Bool_WMV m_bRotatedIdct;
    U8_WMV* m_pZigzagInv_I;
    U8_WMV* m_pHorizontalZigzagInv;
    U8_WMV* m_pVerticalZigzagInv;
    U8_WMV* m_pZigzagInvRotated_I;
    U8_WMV* m_pHorizontalZigzagInvRotated;
    U8_WMV* m_pVerticalZigzagInvRotated;
    U8_WMV* m_pZigzagInvRotated;
    U8_WMV* m_pZigzagInv;
    //zigzag of _XFORMSWITCHING_
    U8_WMV* m_pZigzagScanOrder;
    U8_WMV* m_p8x4ZigzagInv;
    U8_WMV* m_p4x8ZigzagInv;
    U8_WMV* m_p8x4ZigzagInvRotated;
    U8_WMV* m_p4x8ZigzagInvRotated;
    U8_WMV* m_p8x4ZigzagScanOrder;
    U8_WMV* m_p4x8ZigzagScanOrder;

    // for DCT AC pred. 
    I32_WMV m_iNumOfQuanDctCoefForACPredPerRow;
    I16_WMV* m_rgiQuanCoefACPred;
    I16_WMV** m_rgiQuanCoefACPredTable;
    I16_WMV* m_pAvgQuanDctCoefDec;
    I16_WMV* m_pAvgQuanDctCoefDecC;
    I16_WMV* m_pAvgQuanDctCoefDecLeft;
    I16_WMV* m_pAvgQuanDctCoefDecTop;

    // Misc
    U32_WMV m_iEscRunDiffV2V3; // Correct EscRunCoding error in MP42
    I32_WMV m_iDCPredCorrect;   // Correct DC Pred error in MP42
    I32_WMV m_iDCTHorzFlags;    // Sparse IDCT flag
    Bool_WMV m_bFirstEscCodeInFrame;                    //WMV1 vlc EscCoding
    I32_WMV m_iNUMBITS_ESC_LEVEL, m_iNUMBITS_ESC_RUN;   //WMV1 vlc EscCoding
    I32_WMV sm_iIDCTDecCount;    // idct resource counter
    U32_WMV m_uiNumProcessors;  // processor #

//    Bool_WMV* m_pbSkipMB;

    // for X8 : nonflat quantization
    I32_WMV  m_iNonflatQuant;
    t_SpatialPredictor  *m_pSp;
    t_ContextWMV        *m_pContext;
    t_AltTablesDecoder  *m_pAltTables;

    // output BMP info
    Bool_WMV m_bBMPInitialized;
    U32_WMV m_uiFOURCCOutput;
    U16_WMV m_uiBitsPerPixelOutput;
    Bool_WMV m_bRefreshBMP;

//I32_WMV m_iPostProcessMode;
    Bool_WMV m_bYUVDstBMP;
    U32_WMV m_uiRedscale, m_uiGreenscale;
    U32_WMV m_uiRedmask, m_uiGreenmask;
    U8_WMV m_rgDitherMap [4] [4] [3] [256];
    I32_WMV* m_piYscale;
    I32_WMV* m_piVtoR;
    I32_WMV* m_piUtoG;
    I32_WMV* m_piVtoG;
    I32_WMV* m_piUtoB;
    I32_WMV m_iWidthBMP;
    I32_WMV m_iBMPPointerStart; 
    I32_WMV m_iBMPMBIncrement, m_iBMPBlkIncrement;
    I32_WMV m_iBMPMBHeightIncrement, m_iBMPBlkHeightIncrement;
    // bitmap conversion
    U8_WMV* m_pBMPBits;
    I32_WMV m_iWidthPrevYTimes8Minus8, m_iWidthPrevUVTimes4Minus4; 


    // Huffman_WMV Tables
	U8_WMV* m_puXMvFromIndex;
	U8_WMV* m_puYMvFromIndex;
	Huffman_WMV* m_pHufMVDec;
    Huffman_WMV m_hufMVDec_Talking;
    Huffman_WMV m_hufMVDec_HghMt;

	Huffman_WMV* m_pHufMVDec_Set[2];
	U8_WMV* m_puMvFromIndex_Set[4];
    U32_WMV m_iMVTable;

//I32_WMV m_iPostProcessMode;

    // IntraDC
	//def _DCTDC
    Huffman_WMV m_hufDCTDCyDec_Talking;
    Huffman_WMV m_hufDCTDCcDec_Talking;
    Huffman_WMV m_hufDCTDCyDec_HghMt;
    Huffman_WMV m_hufDCTDCcDec_HghMt;

    U32_WMV m_iIntraDCTDCTable;
    Huffman_WMV* m_pHufDCTDCyDec;
    Huffman_WMV* m_pHufDCTDCcDec;
	Huffman_WMV* m_pHufDCTDCDec_Set[4];
    
    //NEW_PCBPCY_TABLE
    Huffman_WMV m_hufICBPCYDec, m_hufPCBPCYDec;
	Huffman_WMV* m_pHufNewPCBPCYDec;
	Huffman_WMV m_hufPCBPCYDec_HighRate; 
	Huffman_WMV m_hufPCBPCYDec_MidRate;
	Huffman_WMV m_hufPCBPCYDec_LowRate;
	//_DCTAC
	// For Table switching
    Huffman_WMV m_hufDCTACInterDec_HghMt;
    Huffman_WMV m_hufDCTACIntraDec_HghMt;
    Huffman_WMV m_hufDCTACInterDec_Talking;
    Huffman_WMV m_hufDCTACIntraDec_Talking;
    Huffman_WMV m_hufDCTACInterDec_MPEG4;
    Huffman_WMV m_hufDCTACIntraDec_MPEG4;

	CDCTTableInfo_Dec InterDCTTableInfo_Dec_HghMt;
	CDCTTableInfo_Dec IntraDCTTableInfo_Dec_HghMt;
	CDCTTableInfo_Dec InterDCTTableInfo_Dec_Talking;
	CDCTTableInfo_Dec IntraDCTTableInfo_Dec_Talking;
	CDCTTableInfo_Dec InterDCTTableInfo_Dec_MPEG4;
	CDCTTableInfo_Dec IntraDCTTableInfo_Dec_MPEG4;

	CDCTTableInfo_Dec* m_pInterDCTTableInfo_Dec;
	CDCTTableInfo_Dec* m_pIntraDCTTableInfo_Dec;
	CDCTTableInfo_Dec* m_pInterDCTTableInfo_Dec_Set[3];
	CDCTTableInfo_Dec* m_pIntraDCTTableInfo_Dec_Set[3];
    U32_WMV m_iDCTACInterTableIndx;
    U32_WMV m_iDCTACIntraTableIndx;

//I32_WMV m_iPostProcessMode;
    // function pointers
    Void_WMV (*m_pWMVideoDecUpdateDstMB) (
        struct tagWMVDecInternalMember *pWMVDec,
        U8_WMV* pBits,
        const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
        I32_WMV iWidthY, I32_WMV iWidthUV,
        I32_WMV iBitmapWidth
    );
    Void_WMV (*m_pWMVideoDecUpdateDstPartialMB) (
        struct tagWMVDecInternalMember *pWMVDec,
        U8_WMV* pBits,
        const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
        I32_WMV iWidthY, I32_WMV iWidthUV,
        I32_WMV iRgbWidth, I32_WMV iRgbHeight
    );

    Void_WMV (*m_pWMVideoDecUpdateDstBlk) (
        struct tagWMVDecInternalMember *pWMVDec,
        U8_WMV* pBits,
        const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
        I32_WMV iWidthY, I32_WMV iWidthUV,
        I32_WMV iBitmapWidth
    );

    tWMVDecodeStatus (*m_pDecodeI) (struct tagWMVDecInternalMember *pWMVDec);
    tWMVDecodeStatus (*m_pDecodeP) (struct tagWMVDecInternalMember *pWMVDec);
    tWMVDecodeStatus (*m_pDecodeIMBAcPred) (
        struct tagWMVDecInternalMember *pWMVDec,
        CWMVMBMode*            pmbmd, 
        U8_WMV*      ppxliTextureQMBY,
        U8_WMV*      ppxliTextureQMBU, 
        U8_WMV*      ppxliTextureQMBV, 
        I16_WMV*                piQuanCoefACPred, 
        I16_WMV**                piQuanCoefACPredTable, 
        Bool_WMV                bLeftMB, 
        Bool_WMV                bTopMB, 
        Bool_WMV                bLeftTopMB);
     tWMVDecodeStatus (*m_pDecodePMB) (
        struct tagWMVDecInternalMember *pWMVDec,
        CWMVMBMode*        pmbmd,
	    U8_WMV* ppxlcCurrQYMB,
	    U8_WMV* ppxlcCurrQUMB,
	    U8_WMV* ppxlcCurrQVMB,
	    CoordI xRefY, CoordI yRefY,
	    CoordI xRefUV, CoordI yRefUV
    );

    // Decoder MB Header
    tWMVDecodeStatus (* m_pDecodeMBOverheadOfIVOP) (struct tagWMVDecInternalMember *pWMVDec, CWMVMBMode* pmbmd, I32_WMV imbX, I32_WMV imbY);
    tWMVDecodeStatus (* m_pDecodeMBOverheadOfPVOP) (struct tagWMVDecInternalMember *pWMVDec, CWMVMBMode* pmbmd);

    //block decoding fuctions
    tWMVDecodeStatus (*m_pDecodeInverseInterBlockQuantize) (struct tagWMVDecInternalMember *pWMVDec, CDCTTableInfo_Dec* InterDCTTableInfo_Dec, U8_WMV* pZigzag, I32_WMV iXformMode);

//I32_WMV m_iPostProcessMode;
    // IDCT routines
    Void_WMV (*m_pIntraIDCT_Dec) (U8_WMV* piDst, I32_WMV iOffsetToNextRowForDCT, const PixelI32 __huge* rgiCoefRecon);
    Void_WMV (*m_pInterIDCT_Dec) (Buffer __huge* piDst, Buffer __huge* piSrc, I32_WMV iOffsetToNextRowForDCT, I32_WMV iDCTHorzFlags);
    Void_WMV (*m_pInter8x4IDCT_Dec) (Buffer __huge* piDst, I32_WMV iOffsetToNextRowForDCT, const Buffer __huge* rgiCoefRecon, I32_WMV iHalf);
    Void_WMV (*m_pInter4x8IDCT_Dec) (Buffer __huge* piDst, I32_WMV iOffsetToNextRowForDCT, const Buffer __huge* rgiCoefRecon, I32_WMV iHalf);
    // Motion Comp
    Void_WMV (*m_pMotionCompAndAddError) (MOTION_COMP_ADD_ERROR_ARGS);
    Void_WMV (*m_pMotionComp) (MOTION_COMP_ARGS);
    Void_WMV (*m_pMotionCompAndAddErrorRndCtrlOn) (MOTION_COMP_ADD_ERROR_ARGS);
    Void_WMV (*m_pMotionCompRndCtrlOn) (MOTION_COMP_ARGS);
    Void_WMV (*m_pMotionCompAndAddErrorRndCtrlOff) (MOTION_COMP_ADD_ERROR_ARGS);
    Void_WMV (*m_pMotionCompRndCtrlOff) (MOTION_COMP_ARGS);
    Void_WMV (*m_pMotionCompZero) (MOTION_COMP_ZERO_ARGS);
    Void_WMV (*m_pMotionCompUV) (MOTION_COMP_ARGS);
    Void_WMV (*m_pMotionCompAndAddErrorUV) (MOTION_COMP_ADD_ERROR_ARGS);
    Void_WMV (*m_pMotionCompMixed) (MOTION_COMP_ARGS);
    Void_WMV (*m_pMotionCompMixedAndAddError) (MOTION_COMP_ADD_ERROR_ARGS);

//I32_WMV m_iPostProcessMode;

	// Deblocking filter
    Void_WMV (*m_pFilterHorizontalEdge)(U8_WMV* pV, I32_WMV iPixelDistance, I32_WMV iStepSize, I32_WMV iNumPixel);
    Void_WMV (*m_pFilterVerticalEdge)(U8_WMV* pV, I32_WMV iPixelDistance, I32_WMV iStepSize, I32_WMV iNumPixel);
    // IMBInPFrame DC Pred
    I32_WMV (*m_pBlkAvgX8_MMX) (const U8_WMV* ppxlcCurrRecnMB, I32_WMV iWidthPrev, I32_WMV iStepSize);

//I32_WMV m_iPostProcessMode;

// MPEG4-compliant variables
    U32_WMV uiFCode;
    I32_WMV iRange;
    I32_WMV iScaleFactor;
    I32_WMV m_iClockRate;

    Time m_t; // current time
    I32_WMV m_iVPMBnum;
    Time m_tModuloBaseDecd;
    Time m_tModuloBaseDisp;
    Time m_tOldModuloBaseDecd;
    Time m_tOldModuloBaseDisp;
    I32_WMV m_iNumBitsTimeIncr;
    Bool_WMV m_bResyncDisable;
    // For MPG4
#ifdef _MPG4_
    I32_WMV m_rgiDCRef [3]; // intra DC predictor
#endif

#ifndef _SLIM_C_
    // Multithread event for clearing frame
    // for multi-thread handles
    Bool_WMV m_bRenderFromPostBuffer;
    Bool_WMV m_bDisplay_AllMB;
    HANDLE hDecEvent0, hDecDone0;
    HANDLE hDecEvent1, hDecDone1;
    HANDLE threadDec0, threadDec1; //, threadDec2, threadDec3;
    Bool_WMV m_bShutdownThreads;
    THREADTYPE_DEC m_iMultiThreadType;
    I32_WMV m_iCurrQYOffset1, m_iCurrQUVOffset1;
    //Move to vo.hpp
    U32_WMV m_uiMBStart0, m_uiMBEnd0, m_uiMBEndX0; 
	CoordI m_iStartY0, m_iEndY0;
	CoordI m_iStartUV0, m_iEndUV0;
	I32_WMV m_iOffsetPrevY0, m_iOffsetPrevUV0;
    U32_WMV m_uiMBStart1, m_uiMBEnd1, m_uiMBEndX1; 
	CoordI m_iStartY1, m_iEndY1;
	CoordI m_iStartUV1, m_iEndUV1;
	I32_WMV m_iOffsetPrevY1, m_iOffsetPrevUV1;
#endif
    //Color Conv, Deblocking, Color Contrl, Possibly removable
//I32_WMV m_iPostProcessMode;

    Bool_WMV m_bDeblockOn;
    Bool_WMV m_bDeringOn; // deblock must be on for dering to be on
    I32_WMV m_bUseOldSetting;
    Bool_WMV m_bRefreshDisplay_AllMB_Enable;
    Bool_WMV m_bRefreshDisplay_AllMB;
    I32_WMV m_iRefreshDisplay_AllMB_Cnt;

    I32_WMV m_iRefreshDisplay_AllMB_Period;
    Bool_WMV m_bCopySkipMBToPostBuf;
    Bool_WMV m_bDefaultColorSetting;
    Bool_WMV m_bCPUQmoved;
    I32_WMV m_iPostProcessMode;

#ifdef _EMB_WMV2_

    U32_WMV m_iMotionCompRndCtrl;
    EMB_DecodeP_ShortCut m_EMBDecodePShortCut;
    tWMVDecodeStatus (*m_CoefDecoderAndIdctDecTable[4])(struct tagWMVDecInternalMember * pThis, CDCTTableInfo_Dec* pInterDCTTableInfo_Dec, I32_WMV iXFormMode);
    tWMVDecodeStatus (*m_pCoefDecoderAndIdctDec8x4or4x8Table[8])(struct tagWMVDecInternalMember * pThis, CDCTTableInfo_Dec* pInterDCTTableInfo_Dec);
    Void_WMV (*m_MotionCompAndAddErrorTable[16])(U8_WMV * ppxlcCurrQMB, const U8_WMV * ppxlcRef, I32_WMV iWidthFrm, I32_WMV * pErrorBuf);

#endif

#ifdef DYNAMIC_EDGEPAD
    tWMVEdgePad m_tEdgePad;
#endif

#ifdef _6BIT_COLORCONV_OPT_
    YUV2RGB_6BIT_TABLE *p_yuv2rgb_6bit_table;
    U8_WMV * m_rgiClapTab6BitDec;
#endif
} tWMVDecInternalMember;
#include "dectable_c.h"

/*
// basic structs
typedef enum tagFrameType_WMV 
{
    IFRAME_WMV = 0, 
    PFRAME_WMV
} tFrameType_WMV;

typedef struct tagYUV420Frame_WMV
{
    U8_WMV* m_pucYPlane;
    U8_WMV* m_pucUPlane;
    U8_WMV* m_pucVPlane;
} tYUV420Frame_WMV;

typedef struct tagMotionVector_WMV
{
    I16_WMV m_iMVX;
    I16_WMV m_iMVY;
} tMotionVector_WMV;

// ===========================================================================
// private data members
// ===========================================================================

typedef struct tagWMVDecInternalMember 
{
    tHuffmanDecoder_WMV* m_pHuffDec;
    tStreamParser_WMV* m_pStrmParse;
    U32_WMV m_uiFOURCCCompressed;
    Float_WMV m_fltFrameRate;
    Float_WMV m_fltBitRate;
    U16_WMV m_uiPostFilterLevel;

    // size info
    I32_WMV m_iWidthSource; // source width, might not be MB aligned
    I32_WMV m_iHeightSource; // source height, might not be MB aligned
    I32_WMV m_iWidthInternal; // internal width, MB aligned
    I32_WMV m_iWidthInternalTimesMB;
    I32_WMV m_iHeightInternal;
    I32_WMV m_iWidthInternalUV;
    I32_WMV m_iWidthInternalUVTimesBlk;
    I32_WMV m_iHeightInternalUV;
    Bool_WMV m_bSizeMBAligned;
    U32_WMV m_uiNumMB, m_uiNumMBX, m_uiNumMBY;

    // tables
    const U8_WMV* m_rgiClapTabDec;

    // pictures/frames data
    tYUV420Frame_WMV* m_pfrCurr;
    tYUV420Frame_WMV* m_pfrPrev;

    // sequence layer info
    Bool_WMV m_bIFrameDecoded;
    Bool_WMV m_bXformSwitch;
    Bool_WMV m_bXintra8Switch;
    Bool_WMV m_bRndCtrlOn;
    Bool_WMV m_iSliceCode;

    // picture layer info.
    tFrameType_WMV m_tFrmType;
    Bool_WMV m_bXintra8;
    Bool_WMV m_bMixedPel;
    Bool_WMV m_bLoopFilter;
    Bool_WMV m_bFrmHybridMVOn;
    Bool_WMV m_bDCTTable_MB_ENABLED;
    I32_WMV m_iStepSize;

    // MB layer info
    Bool_WMV* m_pbSkipMB;

    // output BMP info
    Bool_WMV m_bBMPInitialized;
    U32_WMV m_uiFOURCCOutput;
    U16_WMV m_uiBitsPerPixelOutput;
    Bool_WMV m_bRefreshBMP;

    Bool_WMV m_bYUVDstBMP;
    U32_WMV m_uiRedscale, m_uiGreenscale;
    U32_WMV m_uiRedmask, m_uiGreenmask;
    U8_WMV m_rgDitherMap [4] [4] [3] [256];
    I32_WMV* m_piYscale;
    I32_WMV* m_piVtoR;
    I32_WMV* m_piUtoG;
    I32_WMV* m_piVtoG;
    I32_WMV* m_piUtoB;
    I32_WMV m_iWidthBMP;
    I32_WMV m_iBMPPointerStart; 
    I32_WMV m_iBMPMBIncrement, m_iBMPBlkIncrement;
    I32_WMV m_iBMPMBHeightIncrement, m_iBMPBlkHeightIncrement;

    // function pointers
    Void_WMV_WMV (*m_pWMVideoDecUpdateDstMB) (
        Void_WMV_WMV *pWMVDec,
        U8_WMV* pBits,
        const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
        I32_WMV iWidthY, I32_WMV iWidthUV,
        I32_WMV iBitmapWidth
    );
    Void_WMV_WMV (*m_pWMVideoDecUpdateDstPartialMB) (
        Void_WMV_WMV *pWMVDec,
        U8_WMV* pBits,
        const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
        I32_WMV iWidthY, I32_WMV iWidthUV,
        I32_WMV iRgbWidth, I32_WMV iRgbHeight
    );

    Void_WMV_WMV (*m_pWMVideoDecUpdateDstBlk) (
        Void_WMV_WMV *pWMVDec,
        U8_WMV* pBits,
        const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
        I32_WMV iWidthY, I32_WMV iWidthUV,
        I32_WMV iBitmapWidth
    );


} tWMVDecInternalMember;
*/
#endif // __WMVDEC_MEMBER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\test\debugstats.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation. All rights reserved.

Module Name:

    debugstats.cpp

Abstract:

    Debug information and statistics

--*/

#include "wmvplay.h"

#ifdef DEBUGSTATS

ULONGLONG TotalAudioData;
ULONG MaxAudioPacketSize, MinAudioPacketSize;
ULONG TotalVideoPackets, TotalAudioPackets;
ULONG LongestVideoStretch, LongestAudioStretch;
ULONG LastStretchType, LastStretchLength;
REFERENCE_TIME NextSpewTime;
MEMORYSTATUS StartMemStatus, StopMemStatus;

struct HEAPSTATUS {
    ULONG AllocedElementCount;
    ULONG AllocedElementBytes;
};
HEAPSTATUS StartHeapStatus, StopHeapStatus;

inline VOID UpdateStretch(ULONG type) {
    if (type != LastStretchType) {
        if (LastStretchType & PACKETFLAG_SOUND)
            LongestAudioStretch = max(LongestAudioStretch, LastStretchLength);
        if (LastStretchType & PACKETFLAG_VIDEO)
            LongestVideoStretch = max(LongestVideoStretch, LastStretchLength);
        LastStretchType = type;
        LastStretchLength = 0;
    }
}

//
// Obtain current process heap stats
//
VOID GetProcessHeapStatus(HEAPSTATUS* heapstats)
{
    HANDLE heap = GetProcessHeap();
    PROCESS_HEAP_ENTRY entry;

    memset(heapstats, 0, sizeof(*heapstats));
    memset(&entry, 0, sizeof(entry));

    BOOL lockok = HeapLock(heap);
    ASSERT(lockok);
    
    while (HeapWalk(heap, &entry)) {
        if (entry.wFlags & PROCESS_HEAP_ENTRY_BUSY) {
            heapstats->AllocedElementCount++;
            heapstats->AllocedElementBytes += entry.cbData;
        }
    }

    lockok = HeapUnlock(heap);
    ASSERT(lockok);
}

//
// Start collecting debug stats
//
VOID StartDebugStats()
{
    TotalAudioData = 0;
    MaxAudioPacketSize = 0;
    MinAudioPacketSize = ULONG_MAX;
    LongestAudioStretch = LongestVideoStretch = 0;
    TotalAudioPackets = TotalVideoPackets = 0;
    LastStretchType = 0;
    LastStretchLength = 0;
    NextSpewTime = 0;

    StartMemStatus.dwLength = sizeof(StartMemStatus);
    GlobalMemoryStatus(&StartMemStatus);
    GetProcessHeapStatus(&StartHeapStatus);
}

//
// Stop collecting debug stats and dump out the results
//
VOID StopDebugStats()
{
    UpdateStretch(0);

    VERBOSE("Total # of video packets: %d\n", TotalVideoPackets);
    VERBOSE("  longest stretch: %d\n", LongestVideoStretch);
    VERBOSE("Total # of audio packets: %d\n", TotalAudioPackets);
    VERBOSE("  longest stretch: %d\n", LongestAudioStretch);
    if (TotalAudioPackets) {
        VERBOSE("  average size: %d bytes\n", (ULONG) (TotalAudioData / TotalAudioPackets));
        VERBOSE("  max size: %d bytes\n", MaxAudioPacketSize);
        VERBOSE("  min size: %d bytes\n", MinAudioPacketSize);
    }

    StopMemStatus.dwLength = sizeof(StopMemStatus);
    GlobalMemoryStatus(&StopMemStatus);

    if (StopMemStatus.dwAvailPhys != StartMemStatus.dwAvailPhys) {
        VERBOSE("Physical memory delta: 0x%x - 0x%x = 0x%x\n",
            StartMemStatus.dwAvailPhys,
            StopMemStatus.dwAvailPhys,
            StartMemStatus.dwAvailPhys - StopMemStatus.dwAvailPhys);
    }
    
    GetProcessHeapStatus(&StopHeapStatus);
    if (StartHeapStatus.AllocedElementBytes != StopHeapStatus.AllocedElementBytes) {
        VERBOSE("Heap state before: %d elements, %d bytes\n",
                StartHeapStatus.AllocedElementCount,
                StartHeapStatus.AllocedElementBytes);
        VERBOSE("Heap state after: %d elements, %d bytes\n",
                StopHeapStatus.AllocedElementCount,
                StopHeapStatus.AllocedElementBytes);
        VERBOSE("Total delta: %d elements, %d bytes\n",
                StopHeapStatus.AllocedElementCount - StartHeapStatus.AllocedElementCount,
                StopHeapStatus.AllocedElementBytes - StartHeapStatus.AllocedElementBytes);
    }
}

//
// Update debug stats
//
VOID UpdateDebugStats(Packet* pkt)
{
    UpdateStretch(pkt->flags);
    LastStretchLength++;

    if (pkt->flags & PACKETFLAG_SOUND) {
        TotalAudioPackets++;
        TotalAudioData += pkt->completedSize;
        MaxAudioPacketSize = max(MaxAudioPacketSize, pkt->completedSize);
        MinAudioPacketSize = min(MinAudioPacketSize, pkt->completedSize);
    } else {
        TotalVideoPackets++;
    }

    if (pkt->timestamp >= NextSpewTime) {
        VERBOSE("%c %d\n",
                (pkt->flags & PACKETFLAG_SOUND) ? 'a' : 'v',
                (LONG) (pkt->timestamp / 10000));
        NextSpewTime += 1000*10000;
    }
}

#endif // DEBUGSTATS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\x86opcodes.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

	opcodes.h
         
Abstract:

    Header for unsupported assembly instructions.

Author:

	Marc Holder (marchold@microsoft.com) 16-July-1998

Revision History:

*************************************************************************/

// MSVC Now understands conditional move opcodes
//Conditional move opcode macros
#define cmoves  cmoves
#define cmovz   cmovz
#define cmove   cmove
#define cmovne  cmovne
#define cmovnz  cmovnz
#define cmovge  cmovge
#define cmovg   cmovg

//Registers encoding opcode macros
#define edx_edi edx,edi
#define edx_eax edx,eax
#define ebx_eax ebx,eax
#define edi_eax edi,eax
#define esi_eax esi,eax
#define eax_edi eax,edi
#define eax_edx eax,edx



#ifndef _USE_INTEL_COMPILER

//Katmai new instructions opcodes
#define pavgb       _asm _emit 0x0F _asm _emit 0xE0  //packed byte avarage, takes 2 mmx registers  
#define psadbw      _asm _emit 0x0F _asm _emit 0xF6  //packed byte to word sun absolute diffrences, takes 2 mmx registers
#define pshufw      _asm _emit 0x0F _asm _emit 0x70  //pshufw takes 2 mmx registers and 1 byte which must be emited  
#define pmulhuw     _asm _emit 0x0F _asm _emit 0xE4  //pmulhuw packed unsigned multiply keep high words takes 2 mmx registers
#define pinsrw      _asm _emit 0x0F _asm _emit 0xC4
#define pmovmskb    _asm _emit 0x0F _asm _emit 0xD7  
#define pminub      _asm _emit 0x0F _asm _emit 0xDA
#define pmaxub      _asm _emit 0x0F _asm _emit 0xDE
#define pminsw      _asm _emit 0x0F _asm _emit 0xEA

//Katmai SIMD FP instruction opcodes
#define movaps  _asm _emit 0x0F _asm _emit 0x28  //128 bit aligned move
#define movups  _asm _emit 0x0F _asm _emit 0x10  //128 bit unaligned move
#define shufps(reg,funct) _asm emit 0x0F _asm _emit 0xC6 reg _asm _emit funct
#define unpcklps _asm _emit 0x0F _asm _emit 0x14
#define unpckhps _asm _emit 0x0F _asm _emit 0x15
#define mulps _asm _emit 0x0F _asm _emit 0x59
#define cvtps2pi _asm _emit 0x0F _asm _emit 0x2D 
#define xorps _asm _emit 0x0F _asm _emit 0x57
#define subps _asm _emit 0x0F _asm _emit 0x5C
#define addps _asm _emit 0x0F _asm _emit 0x58
#define addss _asm _emit 0xF3 _asm _emit 0x0F _asm _emit 0x58
#define mulss _asm _emit 0xF3 _asm _emit 0x0F _asm _emit 0x59
#define movssFROMMEM _asm _emit 0xF3 _asm _emit 0x0F _asm _emit 0x10
#define movssTOMEM _asm _emit 0xF3 _asm _emit 0x0F _asm _emit 0x11
#define movhlps _asm _emit 0x0F _asm _emit 0x12
#define movlhps _asm _emit 0x0F _asm _emit 0x16

#define xmm3_ebx _asm _emit 0x1B
#define xmm4_ecx _asm _emit 0x21
#define xmm2_edx _asm _emit 0x12 

#define xmm0_esiBASE    _asm _emit 0x06     // xmm0, [esi]
#define xmm1_esiBASE    _asm _emit 0x0E     // xmm1, [esi]
#define xmm2_esiBASE    _asm _emit 0x16     // xmm2, [esi]
#define xmm3_esiBASE    _asm _emit 0x1E     // xmm3, [esi]
#define xmm4_esiBASE    _asm _emit 0x26     // xmm4, [esi]
#define xmm5_esiBASE    _asm _emit 0x2E     // xmm5, [esi]
#define xmm6_esiBASE    _asm _emit 0x36     // xmm6, [esi]
#define xmm7_esiBASE    _asm _emit 0x3E     // xmm6, [esi]

#define xmm0_ediBASE    _asm _emit 0x07     // xmm0, [edi]
#define xmm1_ediBASE    _asm _emit 0x0F     // xmm1, [edi]
#define xmm2_ediBASE    _asm _emit 0x17     // xmm2, [edi]
#define xmm3_ediBASE    _asm _emit 0x1F     // xmm3, [edi]
#define xmm4_ediBASE    _asm _emit 0x27     // xmm4, [edi]
#define xmm5_ediBASE    _asm _emit 0x2F     // xmm5, [edi]
#define xmm6_ediBASE    _asm _emit 0x37     // xmm6, [edi]

#define xmm0_edxBASE    _asm _emit 0x02     // xmm0, [edx]
#define xmm1_edxBASE    _asm _emit 0x0A     // xmm1, [edx]
#define xmm2_edxBASE    _asm _emit 0x12     // xmm2, [edx]
#define xmm3_edxBASE    _asm _emit 0x1A     // xmm3, [edx]
#define xmm4_edxBASE    _asm _emit 0x22     // xmm4, [edx]
#define xmm5_edxBASE    _asm _emit 0x2A     // xmm5, [edx]
#define xmm6_edxBASE    _asm _emit 0x32     // xmm6, [edx]


#define xmm3_espBASE    _asm _emit 0x1c _asm _emit 0x24 // xmm3, [esp]
#define xmm4_espBASE    _asm _emit 0x24 _asm _emit 0x24 // xmm4, [esp]
#define eaxBASE_xmm3    _asm _emit 0x18     // [eax], xmm3


//defines opcodes for mm?,[esi+offset],imm to use with pinsrw
#define mm0_esi(offset,imm) _asm _emit 0x46 _asm _emit offset _asm _emit imm
#define mm1_esi(offset,imm) _asm _emit 0x4E _asm _emit offset _asm _emit imm
#define mm2_esi(offset,imm) _asm _emit 0x56 _asm _emit offset _asm _emit imm

//For mmx,[edi]
#define mm0_edi _asm _emit 0x07
#define mm1_edi _asm _emit 0x0F
#define mm2_edi _asm _emit 0x17
#define mm3_edi _asm _emit 0x1F
#define mm4_edi _asm _emit 0x27
#define mm6_edi _asm _emit 0x37 
#define mm7_edi _asm _emit 0x3F

//For mmx,[esi+edx+offset]
#define mm1_esi_edx_(offset) _asm emit 0x4C _asm _emit 0x16 _asm _emit offset 
#define mm7_esi_edx_(offset) _asm emit 0x7C _asm _emit 0x16 _asm _emit offset 

//For mmx,[esi+offset]
#define mm1_esi_(offset)    _asm _emit 0x4E _asm _emit offset

//For mmx,[edi+offset]
#define mm5_edi_(offset)    _asm _emit 0x6F _asm _emit offset
#define mm6_edi_(offset)    _asm _emit 0x77 _asm _emit offset
#define mm7_edi_(offset)    _asm _emit 0x7F _asm _emit offset

//for cmov
#define eax_ebx             _asm _emit 0xC3
#define ecx_ebx             _asm _emit 0xCB
#define edx_ebx             _asm _emit 0xD3

//for eax,mm4
#define eax_mm4             _asm _emit 0xC4
#define eax_mm7             _asm _emit 0xC7

//MMX redister encoding opcode macros
#define mm0_mm0 _asm _emit 0xC0
#define mm0_mm1 _asm _emit 0xC1
#define mm0_mm2 _asm _emit 0xC2
#define mm0_mm3 _asm _emit 0xC3
#define mm0_mm4 _asm _emit 0xC4
#define mm0_mm5 _asm _emit 0xC5
#define mm0_mm6 _asm _emit 0xC6
#define mm0_mm7 _asm _emit 0xC7
#define mm1_mm1 _asm _emit 0xC9
#define mm1_mm2 _asm _emit 0xCA
#define mm1_mm3 _asm _emit 0xCB
#define mm1_mm4 _asm _emit 0xCC
#define mm1_mm5 _asm _emit 0xCD
#define mm1_mm6 _asm _emit 0xCE
#define mm1_mm7 _asm _emit 0xCF
#define mm2_mm0 _asm _emit 0xD0
#define mm2_mm1 _asm _emit 0xD1
#define mm2_mm2 _asm _emit 0xD2
#define mm2_mm3 _asm _emit 0xD3
#define mm2_mm4 _asm _emit 0xD4
#define mm2_mm5 _asm _emit 0xD5
#define mm2_mm6 _asm _emit 0xD6
#define mm2_mm7 _asm _emit 0xD7
#define mm3_mm0 _asm _emit 0xD8
#define mm3_mm1 _asm _emit 0xD9
#define mm3_mm2 _asm _emit 0xDA
#define mm3_mm3 _asm _emit 0xDB
#define mm3_mm4 _asm _emit 0xDC
#define mm3_mm7 _asm _emit 0xDF
#define mm4_mm0 _asm _emit 0xE0
#define mm4_mm1 _asm _emit 0xE1
#define mm4_mm2 _asm _emit 0xE2
#define mm4_mm4 _asm _emit 0xE4
#define mm4_mm5 _asm _emit 0xE5
#define mm4_mm6 _asm _emit 0xE6
#define mm4_mm7 _asm _emit 0xE7
#define mm5_mm0 _asm _emit 0xE8
#define mm5_mm1 _asm _emit 0xE9
#define mm5_mm2 _asm _emit 0xEA
#define mm5_mm3 _asm _emit 0xEB
#define mm5_mm4 _asm _emit 0xEC
#define mm5_mm5 _asm _emit 0xED
#define mm5_mm6 _asm _emit 0xEE
#define mm5_mm7 _asm _emit 0xEF
#define mm6_mm0 _asm _emit 0xF0
#define mm6_mm1 _asm _emit 0xF1
#define mm6_mm2 _asm _emit 0xF2
#define mm6_mm3 _asm _emit 0xF3
#define mm6_mm4 _asm _emit 0xF4
#define mm6_mm5 _asm _emit 0xF5
#define mm6_mm6 _asm _emit 0xF6
#define mm6_mm7 _asm _emit 0xF7
#define mm7_mm0 _asm _emit 0xF8
#define mm7_mm1 _asm _emit 0xF9
#define mm7_mm2 _asm _emit 0xFA
#define mm7_mm3 _asm _emit 0xFB
#define mm7_mm4 _asm _emit 0xFC
#define mm7_mm5 _asm _emit 0xFD
#define mm7_mm6 _asm _emit 0xFE
#define mm7_mm7 _asm _emit 0xFF

//SIMD_FP registers
#define xmm0_xmm0 _asm _emit 0xC0
#define xmm0_xmm1 _asm _emit 0xC1
#define xmm0_xmm2 _asm _emit 0xC2
#define xmm0_xmm3 _asm _emit 0xC3
#define xmm0_xmm4 _asm _emit 0xC4
#define xmm0_xmm5 _asm _emit 0xC5
#define xmm0_xmm6 _asm _emit 0xC6
#define xmm0_xmm7 _asm _emit 0xC7
#define xmm1_xmm0 _asm _emit 0xC8
#define xmm1_xmm1 _asm _emit 0xC9
#define xmm1_xmm2 _asm _emit 0xCA
#define xmm1_xmm3 _asm _emit 0xCB
#define xmm1_xmm4 _asm _emit 0xCC
#define xmm1_xmm5 _asm _emit 0xCD
#define xmm1_xmm6 _asm _emit 0xCE
#define xmm1_xmm7 _asm _emit 0xCF
#define xmm2_xmm0 _asm _emit 0xD0
#define xmm2_xmm1 _asm _emit 0xD1
#define xmm2_xmm2 _asm _emit 0xD2
#define xmm2_xmm3 _asm _emit 0xD3
#define xmm2_xmm4 _asm _emit 0xD4
#define xmm2_xmm5 _asm _emit 0xD5
#define xmm2_xmm6 _asm _emit 0xD6
#define xmm2_xmm7 _asm _emit 0xD7
#define xmm3_xmm0 _asm _emit 0xD8
#define xmm3_xmm1 _asm _emit 0xD9
#define xmm3_xmm2 _asm _emit 0xDA
#define xmm3_xmm3 _asm _emit 0xDB
#define xmm3_xmm4 _asm _emit 0xDC
#define xmm3_xmm5 _asm _emit 0xDD
#define xmm3_xmm7 _asm _emit 0xDF
#define xmm4_xmm0 _asm _emit 0xE0
#define xmm4_xmm1 _asm _emit 0xE1
#define xmm4_xmm2 _asm _emit 0xE2
#define xmm4_xmm3 _asm _emit 0xE3
#define xmm4_xmm4 _asm _emit 0xE4
#define xmm4_xmm5 _asm _emit 0xE5
#define xmm4_xmm6 _asm _emit 0xE6
#define xmm4_xmm7 _asm _emit 0xE7
#define xmm5_xmm0 _asm _emit 0xE8
#define xmm5_xmm1 _asm _emit 0xE9
#define xmm5_xmm2 _asm _emit 0xEA
#define xmm5_xmm3 _asm _emit 0xEB
#define xmm5_xmm4 _asm _emit 0xEC
#define xmm5_xmm5 _asm _emit 0xED
#define xmm5_xmm6 _asm _emit 0xEE
#define xmm5_xmm7 _asm _emit 0xEF
#define xmm6_xmm0 _asm _emit 0xF0
#define xmm6_xmm1 _asm _emit 0xF1
#define xmm6_xmm2 _asm _emit 0xF2
#define xmm6_xmm3 _asm _emit 0xF3
#define xmm6_xmm4 _asm _emit 0xF4
#define xmm6_xmm5 _asm _emit 0xF5
#define xmm6_xmm6 _asm _emit 0xF6
#define xmm6_xmm7 _asm _emit 0xF7
#define xmm7_xmm0 _asm _emit 0xF8
#define xmm7_xmm1 _asm _emit 0xF9
#define xmm7_xmm2 _asm _emit 0xFA
#define xmm7_xmm3 _asm _emit 0xFB
#define xmm7_xmm4 _asm _emit 0xFC
#define xmm7_xmm5 _asm _emit 0xFD
#define xmm7_xmm6 _asm _emit 0xFE
#define xmm7_xmm7 _asm _emit 0xFF

#define mm0_xmm4 _asm _emit 0xC4
#define mm1_xmm0 _asm _emit 0xC8
#define mm1_xmm2 _asm _emit 0xCA
#define mm2_xmm4 _asm _emit 0xD4
#define mm3_xmm0 _asm _emit 0xD8
#define mm3_xmm2 _asm _emit 0xDA

#define emit _asm _emit

#define CPU_ID _asm _emit 0x0f _asm _emit 0xa2
#define RDTSC  _asm _emit 0x0f _asm _emit 0x31



#else   // _USE_INTEL_COMPILER

//Katmai new instructions opcodes
#define pavgb  pavgb
#define psadbw psadbw
#define pshufw pshufw
#define shufps shufps

//MMX redister encoding opcode macros
#define mm0_mm0 mm0,mm0
#define mm0_mm1 mm0,mm1
#define mm0_mm7 mm0,mm7
#define mm0_mm3 mm0,mm3
#define mm1_mm1 mm1,mm1
#define mm1_mm2 mm1,mm2
#define mm1_mm7 mm1,mm7
#define mm2_mm2 mm2,mm2
#define mm2_mm3 mm2,mm3
#define mm2_mm7 mm2,mm7
#define mm3_mm2 mm3,mm2
#define mm3_mm4 mm3,mm4
#define mm3_mm7 mm3,mm7
#define mm4_mm2 mm4,mm2
#define mm4_mm5 mm4,mm5
#define mm4_mm7 mm4,mm7
#define mm5_mm6 mm5,mm6
#define mm5_mm7 mm5,mm7
#define mm6_mm7 mm6,mm7
#define mm7_mm0 mm7,mm0
#define mm7_mm1 mm7,mm1

//Katmai SIMD FP instruction opcodes
#define movaps movaps
#define movups movups
#define shufps(reg,funct) shufps reg,funct
#define unpcklps unpcklps
#define mulps mulps
#define cvtps2pi cvtps2pi
#define unpckhps unpckhps
#define xorps xorps
#define subps subps
#define addps addps
#define addss addss
#define mulss mulss
#define movssFROMMEM    movss
#define movssTOMEM      movss
#define movhlps         movhlps

#define xmm3_ebx xmm3,[ebx]
#define xmm4_ecx xmm4,[ecx]
#define xmm2_edx xmm2,[edx]

#define xmm0_esiBASE    xmm0, [esi]
#define xmm1_esiBASE    xmm1, [esi]
#define xmm2_esiBASE    xmm2, [esi]
#define xmm3_esiBASE    xmm3, [esi]
#define xmm4_esiBASE    xmm4, [esi]
#define xmm5_esiBASE    xmm5, [esi]
#define xmm6_esiBASE    xmm6, [esi]
#define xmm7_esiBASE    xmm7, [esi]

#define xmm0_ediBASE    xmm0, [edi]
#define xmm1_ediBASE    xmm1, [edi]
#define xmm2_ediBASE    xmm2, [edi]
#define xmm3_ediBASE    xmm3, [edi]
#define xmm4_ediBASE    xmm4, [edi]
#define xmm5_ediBASE    xmm5, [edi]
#define xmm6_ediBASE    xmm6, [edi]

#define xmm0_edxBASE    xmm0, [edx]
#define xmm1_edxBASE    xmm1, [edx]
#define xmm2_edxBASE    xmm2, [edx]
#define xmm3_edxBASE    xmm3, [edx]
#define xmm4_edxBASE    xmm4, [edx]
#define xmm5_edxBASE    xmm5, [edx]
#define xmm6_edxBASE    xmm6, [edx]


#define xmm3_espBASE    xmm3, [esp]
#define xmm4_espBASE    xmm4, [esp]
#define eaxBASE_xmm3    [eax], xmm3

#define xmm0_xmm0 xmm0,xmm0
#define xmm0_xmm1 xmm0,xmm1
#define xmm1_xmm1 xmm1,xmm1
#define xmm0_xmm3 xmm0,xmm3
#define xmm1_xmm2 xmm1,xmm2
#define xmm2_xmm2 xmm2,xmm2
#define xmm1_xmm4 xmm1,xmm4
#define xmm3_xmm0 xmm3,xmm0
#define xmm4_xmm4 xmm4,xmm4

#define xmm1_xmm0 xmm1,xmm0
#define xmm3_xmm5 xmm3,xmm5

#define mm0_xmm4 mm0,xmm4
#define mm1_xmm0 mm1,xmm0
#define mm1_xmm2 mm1,xmm2
#define mm2_xmm4 mm2,xmm4
#define mm3_xmm0 mm3,xmm0
#define mm3_xmm2 mm3,xmm2

#define emit ,

#define CPU_ID cpuid

#endif  // _USE_INTEL_COMPILER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\include\xplatform.h ===
#ifndef __XPLATFORM__
#define __XPLATFORM__

#ifdef __MACVIDEO__
#include "MacPort.h"
#define NO_WINDOWS
#endif

#ifdef _XBOX
#include <xtl.h>
#endif

//**************************************************************************************************
#ifdef _Embedded_x86
#   define NO_WINDOWS
#   undef _USE_INTEL_COMPILER
    typedef unsigned long       DWORD;
    typedef unsigned short      WORD;
    typedef long LONG;
    typedef unsigned char BYTE;
    typedef void *HANDLE; 
    typedef void *LPVOID; 
    typedef unsigned int UINT; // IW
#ifndef _XBOX
    typedef long HDC; // IW
    typedef BYTE BOOL; //IW
    typedef void VOID;
#endif
    // IW #define I32 long
    //#define Bool int
#   define NULL    0//((void *)0)
#   define NOERROR             0
#   define TRUE	1
#   define FALSE	0
#   define AVIIF_KEYFRAME  0x00000010L

#   undef WMAPI
#   define WMAPI
#   undef _stdcall
#   define _stdcall

#   define CONST const
#endif

#if defined(_Embedded_x86) || defined(_XBOX)
#   define BI_BITFIELDS     3L
#   define BI_RGB           0

#   ifndef _HRESULT_DEFINED
#       define _HRESULT_DEFINED
        typedef LONG HRESULT;
#   endif // !_HRESULT_DEFINED

#   define RtlEqualMemory(Destination,Source,Length) (!memcmp((Destination),(Source),(Length)))
#   define RtlMoveMemory(Destination,Source,Length) memmove((Destination),(Source),(Length))
#   define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))
#   define RtlFillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#   define RtlZeroMemory(Destination,Length) memset((Destination),0,(Length))
#   define MoveMemory RtlMoveMemory
#   define CopyMemory RtlCopyMemory
#   define FillMemory RtlFillMemory
#   define ZeroMemory RtlZeroMemory

#   define min(a,b)    (((a) < (b)) ? (a) : (b))

#   ifndef _BITMAPINFOHEADER
#       define _BITMAPINFOHEADER
        typedef struct tagBITMAPINFOHEADER{
            DWORD      biSize;
            LONG       biWidth;
            LONG       biHeight;
            WORD       biPlanes;
            WORD       biBitCount;
            DWORD      biCompression;
            DWORD      biSizeImage;
            LONG       biXPelsPerMeter;
            LONG       biYPelsPerMeter;
            DWORD      biClrUsed;
            DWORD      biClrImportant;
        } BITMAPINFOHEADER, *LPBITMAPINFOHEADER;
#   endif

#   ifndef _BITMAPINFO
#       define _BITMAPINFO
        /*
        typedef struct tagRGBQUAD {
            BYTE    rgbBlue; 
            BYTE    rgbGreen; 
            BYTE    rgbRed; 
            BYTE    rgbReserved; 
        } RGBQUAD; 
        typedef struct tagBITMAPINFO {
            BITMAPINFOHEADER    bmiHeader;
            RGBQUAD             bmiColors[1];
        } BITMAPINFO;
        */
#   endif

    //IW check MAKEFOURCC
#ifndef _XBOX
#   define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
		((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |   \
		((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))
#endif
#   ifndef mmioFOURCC
#       define mmioFOURCC(ch0, ch1, ch2, ch3)  MAKEFOURCC(ch0, ch1, ch2, ch3)
#   endif
#ifndef _XBOX
#   ifndef _WAVEFORMATEX_
#       define _WAVEFORMATEX_
        typedef struct tWAVEFORMATEX
        {
            WORD    wFormatTag;         /* format type */
            WORD    nChannels;          /* number of channels (i.e. mono, stereo...) */
            DWORD   nSamplesPerSec;     /* sample rate */
            DWORD   nAvgBytesPerSec;    /* for buffer estimation */
            WORD    nBlockAlign;        /* block size of data */
            WORD    wBitsPerSample;     /* number of bits per sample of mono data */
            WORD    cbSize;             /* the count in bytes of the size of */
        }   WAVEFORMATEX;
#   endif

#endif // xbox
#endif // EMbedded_x86 || xbox

//**************************************************************************************************
#if defined(__arm)
    // Embedded ARM
#   define _CE_WMV2_
#   define __huge
#   define NO_WINDOWS
    typedef void* LPVOID;
    typedef void* HANDLE;
    typedef long long LARGE_INTEGER;
    typedef char TCHAR;
    typedef char* LPCTSTR;
#   define _T(a) a
#   define TEXT(a) a
#   define _stprintf sprintf
#   define UINT_MAX  0xffffffffU
    typedef unsigned long DWORD;
#endif

//**************************************************************************************************
#if defined(UNDER_CE) && !defined(macintosh) // only works with little-endian for now, so no PowerPC
#   define _EMB_WMV2_
#   define __STREAMING_MODE_DECODE_
#   define _SLIM_C_                 // no multithread
#   define OUTPUT_ALL_FORMATS       // all color conversion
#endif



#ifdef _EMB_WMV2_                     //  conditional defines for CE devices
#   define COMBINE_LOOPFILTER_RENDERING
#   define DYNAMIC_EDGEPAD          // Verify: setting of motioncomp_arm.s -PD "DYNAMIC_EDGEPAD SETA 1", repeatpad_arm.s as -PD"EXPANDY_REFVOP SETA 8"
#   define DYNAMIC_EDGEPAD_0
#   define OPT_HUFFMAN_GET_WMV          // from wmvideo optimization - OK for all the platforms
#   define OPT_SMALL_CODE_SIZE      // without this, some loops get unrolled
    ////#    define OPT_TINY_CODE_SIZE       // trade-off for smaller code size with added complexity within loops.
#   if defined(OPT_TINY_CODE_SIZE) && !defined(OPT_SMALL_CODE_SIZE)
#       define OPT_SMALL_CODE_SIZE
#   endif




#   if defined(_ARM_) || defined(__arm) 
#       define _EMB_ASM_ARM_STRMHUFF_
#       define IPAQ_HACK
#       define _ARM_ASM_MOTIONCOMP_OPT_
#       define _ARM_ASM_LOOPFILTER_OPT_
#       define _ARM_ASM_BLKDEC_OPT_
#       define IDCTDEC_32BIT_INPUT      // To enable using ARM multiple load/stores
#       define OPT_IDCT_ARM
#       define OPT_DECOLORCONV_ARM
#       ifdef OPT_DECOLORCONV_ARM
#           define OUTPUT_RGB12
#       endif
//#       define IPP_COLORCONV
#       define OPT_ZEROMOTION_ARM
#       define OPT_REPEATPAD_ARM
#       define OPT_X8_ARM
#       if defined(DYNAMIC_EDGEPAD)
#           define _ARM_ASM_DYNAMICPAD_OPT_
#       endif
      // define STINGER in Stinger specific project files
#       if defined(STINGER)
#           define _WMVONLY_
#           ifdef OUTPUT_ALL_FORMATS
#               undef OUTPUT_ALL_FORMATS
#           endif
#           ifndef OUTPUT_RGB12
#               define OUTPUT_RGB12
#           endif
#           define STATIC_PAD_0
#       endif
      // ARM7 should define OPT_SLOW_MULTIPLY
#   endif
#   if defined(__arm)
//#       define CE_DECODEPMB_GLOBAL_FUNCTABLE    // otherwise C++ errors in vopdec_ce.cpp
#   endif

#   ifdef _SH3_
//#       define USE_SH3_ASM
#   endif


#	ifdef _SH4_
#       define _SH4_ASM_LOOPFILTER_OPT_
#       define OPT_DECOLORCONV_SH4
#	endif


#   ifdef _MIPS_
#       define _MIPS_ASM_MOTIONCOMP_OPT_
#       define _MIPS_ASM_LOOPFILTER_OPT_
#       define _6BIT_COLORCONV_OPT_
#       define _MIPS_ASM_IDCTDEC_OPT_
#       define _MIPS_ASM_X8_OPT_
#   endif
#endif //_EMB_WMV2_


//**************************************************************************************************
// memcpy of aligned U32_WMV with cbSiz = number of bytes to copy
// assumes pDst and pSrc are aligned, but casts them in case they are actually byte or short pointers.
#define ALIGNED32_MEMCPY(pDst,pSrc,cbSiz) {                 \
            U32_WMV* pD = (U32_WMV*)(pDst), *pS = (U32_WMV*)(pSrc);     \
            for(int j=(cbSiz)>>2; j>0;j--)                  \
                *pD++ = *pS++;                              \
        }
#define ALIGNED32_MEMCPY16(pDst,pSrc) {                     \
            U32_WMV* pD = (U32_WMV*)(pDst), *pS = (U32_WMV*)(pSrc);     \
            *pD++ = *pS++;                                  \
            *pD++ = *pS++;                                  \
            *pD++ = *pS++;                                  \
            *pD   = *pS;                                    \
        }
#define ALIGNED32_MEMCPY8(pDst,pSrc) {                      \
            U32_WMV* pD = (U32_WMV*)(pDst), *pS = (U32_WMV*)(pSrc);     \
            *pD++ = *pS++;                                  \
            *pD   = *pS;                                    \
        }
// memset of aligned U32_WMV with cbSiz = number of bytes to copy
#define ALIGNED32_MEMSET_U32(pDst,u32C,cbSiz) {             \
            U32_WMV* pD=(U32_WMV*)(pDst);                           \
            for(int j=(cbSiz)>>2; j>0;j--)                  \
                *pD++ = u32C;                               \
        }
#define ALIGNED32_MEMSET_2U32(pDst,u32C) {                  \
            U32_WMV* pD = (U32_WMV*)(pDst);                         \
            *pD++ = u32C;                                   \
            *pD   = u32C;                                   \
        }
// replicate a byte 4 times in an U32_WMV.
#ifndef OPT_SLOW_MULTIPLY
#   define ALIGNED32_REPLICATE_4U8(a) (((U8_WMV)(a)) * 0x01010101u)
#else
#   define ALIGNED32_REPLICATE_4U8(a) (((U8_WMV)(a)<<24) | ((U8_WMV)(a)<<16) | ((U8_WMV)(a)<<8) | (U8_WMV)(a))
#endif
// memset of aligned U32_WMV with a replicated U8_WMV constant
#define ALIGNED32_MEMSET_U8(pDst,u8C,cbSiz) {               \
            const U8_WMV  u8T = (U8_WMV)(u8C);                      \
            const U16_WMV u16T = (u8T<<8) | u8T;                \
            const U32_WMV u32C = (u16T<<16) | u16T;             \
            ALIGNED32_MEMSET_U32( (pDst), u32C, (cbSiz) );  \
        }
#define ALIGNED32_MEMSET_8U8(pDst,u8C) {                    \
            const U8_WMV  u8T = (U8_WMV)(u8C);                      \
            const U16_WMV u16T = (u8T<<8) | u8T;                \
            const U32_WMV u32C = (u16T<<16) | u16T;             \
            U32_WMV* pD=(U32_WMV*)(pDst);                           \
            *pD++ = u32C;                                   \
            *pD   = u32C;                                   \
        }
#ifndef OPT_SMALL_CODE_SIZE
#   define ALIGNED32_MEMSET_20U8(pDst,u8C) {                \
            const U8_WMV  u8T = (U8_WMV)(u8C);                      \
            const U16_WMV u16T = (u8T<<8) | u8T;                \
            const U32_WMV u32C = (u16T<<16) | u16T;             \
            U32_WMV* pD=(U32_WMV*)(pDst);                           \
            *pD++ = u32C;                                   \
            *pD++ = u32C;                                   \
            *pD++ = u32C;                                   \
            *pD++ = u32C;                                   \
            *pD   = u32C;                                   \
        }
#   define ALIGNED32_MEMSET_24U8(pDst,u8C) {                \
            const U8_WMV  u8T = (U8_WMV)(u8C);                      \
            const U16_WMV u16T = (u8T<<8) | u8T;                \
            const U32_WMV u32C = (u16T<<16) | u16T;             \
            U32_WMV* pD=(U32_WMV*)(pDst);                           \
            *pD++ = u32C;                                   \
            *pD++ = u32C;                                   \
            *pD++ = u32C;                                   \
            *pD++ = u32C;                                   \
            *pD++ = u32C;                                   \
            *pD   = u32C;                                   \
        }
#   define ALIGNED32_MEMCLR_128U8(pDst) {                   \
            U32_WMV* pD=(U32_WMV*)(pDst);                           \
            *pD++ = 0;  *pD++ = 0;  *pD++ = 0; *pD++ = 0;   \
            *pD++ = 0;  *pD++ = 0;  *pD++ = 0; *pD++ = 0;   \
            *pD++ = 0;  *pD++ = 0;  *pD++ = 0; *pD++ = 0;   \
            *pD++ = 0;  *pD++ = 0;  *pD++ = 0; *pD++ = 0;   \
            *pD++ = 0;  *pD++ = 0;  *pD++ = 0; *pD++ = 0;   \
            *pD++ = 0;  *pD++ = 0;  *pD++ = 0; *pD++ = 0;   \
            *pD++ = 0;  *pD++ = 0;  *pD++ = 0; *pD++ = 0;   \
            *pD++ = 0;  *pD++ = 0;  *pD++ = 0; *pD++ = 0;   \
        }
#else // OPT_SMALL_CODE_SIZE
#   define ALIGNED32_MEMSET_20U8(pDst,u8C) ALIGNED32_MEMSET_U8((pDst),(u8C),20)
#   define ALIGNED32_MEMSET_24U8(pDst,u8C) ALIGNED32_MEMSET_U8((pDst),(u8C),24)
#   define ALIGNED32_MEMCLR_128U8(pDst)    ALIGNED32_MEMSET_U32((pDst),0,128)
#endif
// Average of 8 bytes
#define ALIGNED32_AVERAGE_8U8(avg,pSrc,Rnd) {                                                                           \
            const U32_WMV u32S0 = *((U32_WMV*)(pSrc)), u32S1 = *((U32_WMV*)(pSrc+4));                                               \
            avg = (u32S0 & 0x00ff00ff) + ((u32S0>>8) & 0x00ff00ff) + (u32S1 & 0x00ff00ff) + ((u32S1>>8) & 0x00ff00ff);  \
            avg = ((avg & 0x0000ffff) + ((avg>>16) & 0x0000ffff) + Rnd) >> 3;                                           \
        }
// Sum of 8 bytes (takes 13 ops + 2 reads)
#define ALIGNED32_SUM_8U8(sum,pSrc) {                                                                                   \
            const U32_WMV u32S0 = *((U32_WMV*)(pSrc)), u32S1 = *((U32_WMV*)(pSrc+4));                                               \
            sum = (u32S0 & 0x00ff00ff) + ((u32S0>>8) & 0x00ff00ff) + (u32S1 & 0x00ff00ff) + ((u32S1>>8) & 0x00ff00ff);  \
            sum = (sum & 0x0000ffff) + ((sum>>16) & 0x0000ffff);                                                        \
        }

//**************************************************************************************************
#ifdef PROFILE
#   include "AutoProfile.h"
#else
#   define FUNCTION_PROFILE(fp)
#   define FUNCTION_PROFILE_START(fp,id)
#   define FUNCTION_PROFILE_STOP(fp)
#   define FUNCTION_PROFILE_DECL_START(fp,id)
#   define FUNCTION_PROFILE_SWITCH(fp,id)
#endif

//**************************************************************************************************
#ifndef DEBUG_ONLY
#   if defined(DEBUG) || defined(_DEBUG)
#       define DEBUG_ONLY(a) a
#   else
#       define DEBUG_ONLY(a)
#   endif
#endif // DEBUG_ONLY
#ifndef DEBUG_CON_ONLY
#   if (defined(DEBUG) || defined(_DEBUG)) && !defined(UNDER_CE)
        // Some winCE platforms do not support printf.
#       define DEBUG_CON_ONLY(a) a
#   else
#       define DEBUG_CON_ONLY(a)
#   endif
#endif // DEBUG_CON_ONLY
#ifndef DEBUG_HEAP_ADD
#   if defined(WANT_HEAP_MEASURE)
#       define DEBUG_HEAP_ADD(c,a) { g_cbHeapSize[g_iHeapLastClass=c] += a;  if (g_cbHeapSize[c]>g_cbMaxHeapSize[c]) g_cbMaxHeapSize[c] = g_cbHeapSize[c]; }
#       define DEBUG_HEAP_SUB(c,a) { g_cbHeapSize[g_iHeapLastClass=c] -= a; }
#       ifdef __cplusplus
            extern "C"
#       else
            extern 
#       endif
        unsigned int g_cbHeapSize[6], g_cbMaxHeapSize[6], g_iHeapLastClass;
#       define DHEAP_STRUCT 0
#       define DHEAP_FRAMES 1
#       define DHEAP_HUFFMAN 2
#       define DHEAP_LOCALHUFF 3
#       define DHEAP_LOCAL_COUNT 4
#   else
#       define DEBUG_HEAP_ADD(c,a)
#       define DEBUG_HEAP_SUB(c,a)
#   endif
#endif // DEBUG_HEAP_MEASURE


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\test\graphics.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation. All rights reserved.

Module Name:

    graphics.cpp

Abstract:

    WMV playback sample application - graphics related functions

--*/

#include "wmvplay.h"


//
// Vertical blank callback (runs at DPC level)
//
volatile DWORD VBlankCount;
VOID __cdecl VBlankCallback(D3DVBLANKDATA* data) {
    VBlankCount = data->VBlank;
}

//
// One-time initialization of D3D
//
IDirect3DDevice8* TextureBufferQueue::d3ddev;
LONG TextureBufferQueue::refreshInterval;

VOID TextureBufferQueue::InitializeD3D()
{
    IDirect3D8* d3d = Direct3DCreate8(D3D_SDK_VERSION);
    ASSERT(d3d != NULL);

    D3DPRESENT_PARAMETERS d3dpp;
    memset(&d3dpp, 0, sizeof(d3dpp));

    d3dpp.BackBufferWidth                 = SCREENWIDTH;
    d3dpp.BackBufferHeight                = SCREENHEIGHT;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount                 = 0;
    d3dpp.Windowed                        = FALSE;
    d3dpp.EnableAutoDepthStencil          = TRUE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;

    HRESULT hr = d3d->CreateDevice(
                        D3DADAPTER_DEFAULT,
                        D3DDEVTYPE_HAL,
                        NULL,
                        D3DCREATE_HARDWARE_VERTEXPROCESSING,
                        &d3dpp,
                        &d3ddev);
    ASSERT(SUCCEEDED(hr));
    d3d->Release();

    D3DDISPLAYMODE mode;
    hr = d3ddev->GetDisplayMode(&mode);
    if (SUCCEEDED(hr) && mode.RefreshRate) {
        refreshInterval = 1000*10000 / mode.RefreshRate;
    } else {
        // Default to 16msecs
        refreshInterval = 16*10000;
    }
}

//
// Initialize the graphics playback module
//
BOOL TextureBufferQueue::Initialize()
{
    maxCount = MAX_TEXTURES;
    maxPacketSize = VideoInfo.dwHeight * VideoInfo.dwWidth * VideoInfo.dwOutputBitsPerPixel / 8;
    ASSERT(maxPacketSize % 4 == 0);

    d3ddev->Clear(0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 0, 1.0f, 0);
    d3ddev->Present(NULL, NULL, NULL, NULL);

    d3ddev->SetVerticalBlankCallback(VBlankCallback);
    d3ddev->EnableOverlay(TRUE);

    //
    // Create textures
    //
    for (INT i=0; i < MAX_TEXTURES; i++) {
        TexturePacket* pkt = &textures[i];
        
        HRESULT hr = d3ddev->CreateTexture(
                        VideoInfo.dwWidth,
                        VideoInfo.dwHeight,
                        0,
                        0,
                        D3DFMT_YUY2,
                        NULL,
                        &pkt->d3dtex);
        if (FAILED(hr)) return FALSE;

        D3DLOCKED_RECT lockrect;
        hr = pkt->d3dtex->LockRect(0, &lockrect, NULL, 0);
        if (FAILED(hr)) return FALSE;

        pkt->flags = PACKETFLAG_VIDEO;
        pkt->xmp.pvBuffer = lockrect.pBits;
        pkt->d3dtex->UnlockRect(0);

        freeList.AddTail(pkt);
    }

    discardedFrames = overlayBlocks = 0;
    return PacketQueue::Initialize();
}

//
// Process video frames
//
VOID TextureBufferQueue::Process()
{
    //
    // Retire any frames that have already been rendered:
    //  A frame in the busy queue can be freed if there is another frame after it
    //  and the current vblank count is >= the value in the later packet.
    //
    Packet* pkt;
    while ((pkt = busyList.head) != NULL) {
        Packet* next = pkt->next;
        if (next == NULL || (LONG) (VBlankCount - next->status) < 0)
            break;

        busyList.RemoveHead();
        freeList.AddTail(pkt);
    }

    #ifndef DONT_PLAY_VIDEO

    //
    // Render frames that're ready for display
    //
    while ((pkt = readyList.head) != NULL) {

#if 0

        // Forget it if there is another update pending
        if (!d3ddev->GetOverlayUpdateStatus()) {
            overlayBlocks++;
            return;
        }

        // Render the frame if it's time
        readyList.RemoveHead();

        RenderFrame((TexturePacket*) pkt);
        busyList.AddTail(pkt);

#else

        REFERENCE_TIME timediff = pkt->timestamp - CurrentPlayTime;

        if (timediff < -refreshInterval) {
            // The frame is too old, just discard it
            discardedFrames++;
            ReleaseFreePacket(readyList.RemoveHead());
        } else {
            if (timediff < refreshInterval) {
                // Forget it if there is another update pending
                if (!d3ddev->GetOverlayUpdateStatus()) {
                    overlayBlocks++;
                    return;
                }

                // Render the frame if it's time
                readyList.RemoveHead();

                RenderFrame((TexturePacket*) pkt);
                busyList.AddTail(pkt);
            }
            break;
        }

#endif
    }

    #else // DONT_PLAY_VIDEO

    while (!readyList.IsEmpty()) {
        freeList.AddTail(readyList.RemoveHead());
    }

    #endif // DONT_PLAY_VIDEO
}

//
// Stop graphics playback
//
VOID TextureBufferQueue::Shutdown()
{
    d3ddev->EnableOverlay(FALSE);

    // Wait for two vblanks
    DWORD vblanks = VBlankCount+2;
    while ((LONG) (VBlankCount - vblanks) < 0)
        ;

    if (discardedFrames) {
        VERBOSE("Discarded video frames: %d (%d)\n", discardedFrames, overlayBlocks);
    }

    while (!busyList.IsEmpty()) {
        freeList.AddTail(busyList.RemoveHead());
    }
}

//
// Render the frame
//
VOID TextureBufferQueue::RenderFrame(TexturePacket* pkt)
{
    RECT srcrect = { 0, 0, VideoInfo.dwWidth, VideoInfo.dwHeight };
    RECT dstrect = { 0, 0, SCREENWIDTH, SCREENHEIGHT };

    if (!FullScreenMode) {
        //
        // We need to adjust the destination rectangle and
        // possibly the source rectangle when in 1:1 mode. 
        //
        if (VideoInfo.dwWidth <= SCREENWIDTH) {
            // Horizontal centering
            dstrect.left = (SCREENWIDTH - VideoInfo.dwWidth) / 2;
            dstrect.right = dstrect.left + VideoInfo.dwWidth;
        } else {
            // Clipping
            srcrect.left = (VideoInfo.dwWidth - SCREENWIDTH) / 2;
            srcrect.right = srcrect.left + SCREENWIDTH;
        }

        if (VideoInfo.dwHeight <= SCREENHEIGHT) {
            // Vertical centering
            dstrect.top = (SCREENHEIGHT - VideoInfo.dwHeight) / 2;
            dstrect.bottom = dstrect.top + VideoInfo.dwHeight;
        } else {
            // Clipping
            srcrect.top = (VideoInfo.dwHeight - SCREENHEIGHT) / 2;
            srcrect.bottom = dstrect.top + SCREENHEIGHT;
        }
    }

    d3ddev->UpdateOverlay(
                (D3DSurface*) pkt->d3dtex,
                &srcrect,
                &dstrect,
                FALSE,
                0);

    // Retire this packet after two VBlank interrupts
    pkt->status = VBlankCount+2;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\test\input.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation. All rights reserved.

Module Name:

    input.cpp

Abstract:

    WMV playback sample application - input functions

--*/

#include "wmvplay.h"
#include "xboxp.h"

//
// IR remote key codes
//
#define IRKEY_POWER     0x0AD5
#define IRKEY_REVERSE   0x0AE2
#define IRKEY_PLAY      0x0AEA
#define IRKEY_FORWARD   0x0AE3
#define IRKEY_SKIPBACK  0x0ADD
#define IRKEY_STOP      0x0AE0
#define IRKEY_PAUSE     0x0AE6
#define IRKEY_SKIPFWD   0x0ADF
#define IRKEY_GUIDE     0x0AE5
#define IRKEY_INFO      0x0AC3
#define IRKEY_MENU      0x0AF7
#define IRKEY_BACK      0x0AD8
#define IRKEY_UP        0x0AA6
#define IRKEY_LEFT      0x0AA9
#define IRKEY_SELECT    0x0A0B
#define IRKEY_RIGHT     0x0AA8
#define IRKEY_DOWN      0x0AA7
#define IRKEY_0         0x0ACF
#define IRKEY_1         0x0ACE
#define IRKEY_2         0x0ACD
#define IRKEY_3         0x0ACC
#define IRKEY_4         0x0ACB
#define IRKEY_5         0x0ACA
#define IRKEY_6         0x0AC9
#define IRKEY_7         0x0AC8
#define IRKEY_8         0x0AC7
#define IRKEY_9         0x0AC6
#define IRKEY_NONE      0xFFFF

enum {
    BUTTON_ANALOG,
    BUTTON_A = BUTTON_ANALOG,
    BUTTON_B,
    BUTTON_X,
    BUTTON_Y,
    BUTTON_BLACK,
    BUTTON_WHITE,
    BUTTON_LTRIGGER,
    BUTTON_RTRIGGER,

    BUTTON_DIGITAL,
    BUTTON_UP = BUTTON_DIGITAL,
    BUTTON_DOWN,
    BUTTON_LEFT,
    BUTTON_RIGHT,
    BUTTON_START,
    BUTTON_BACK,
    BUTTON_LTHUMB,
    BUTTON_RTHUMB,

    BUTTON_MAX
};

//
// Handle input
//
VOID ButtonPressed(INT button)
{
    switch (button) {
    case BUTTON_X:
        //
        // Toggle fullscreen mode
        //
        FullScreenMode = !FullScreenMode;
        VERBOSE("Full screen mode: %d\n", FullScreenMode);
        break;

    case BUTTON_B:
        //
        // Switch between D and A drive
        //
        TestDVDFiles = !TestDVDFiles;
        TestFileIndex = -1;

        // Fall through

    case BUTTON_START:
        //
        // Move on to the next test file
        //
        TestFileIndex++;
        AbortDecoding();
        break;

    case BUTTON_BACK:
        //
        // Move back to the previous test file
        //
        if (TestFileIndex > 0) {
            TestFileIndex--;
            AbortDecoding();
        }
        break;

    case BUTTON_A:
        //
        // Replay the current file
        //
        AbortDecoding();
        break;

    case BUTTON_Y:
        //
        // Toggle the continuous play mode
        //
        ContinuousMode = !ContinuousMode;
        VERBOSE("Continuous play mode: %d\n", ContinuousMode);
        break;

    case BUTTON_BLACK:
        //
        // Stop the test
        //
        DecodingFlag = DECODING_EXIT;
        break;
    }
}

VOID NumberPressed(INT n)
{
    TestFileIndex = n;
    AbortDecoding();
}

//
// Map IR remote keys to equivalent controller buttons
//
INT MapIRKey(WORD keycode)
{
    static const struct {
        WORD keycode;
        WORD button;
    } mappingTable[] = {
        { IRKEY_SELECT,     BUTTON_A },
        { IRKEY_PLAY,       BUTTON_A },
        { IRKEY_BACK,       BUTTON_B },
        { IRKEY_SKIPFWD,    BUTTON_START },
        { IRKEY_SKIPBACK,   BUTTON_BACK },
        { IRKEY_STOP,       BUTTON_BLACK },
        { IRKEY_UP,         BUTTON_UP },
        { IRKEY_DOWN,       BUTTON_DOWN },
        { IRKEY_LEFT,       BUTTON_LEFT },
        { IRKEY_RIGHT,      BUTTON_RIGHT },
        { IRKEY_GUIDE,      BUTTON_Y },
        { IRKEY_MENU,       BUTTON_X },

        { IRKEY_NONE,       BUTTON_MAX },
    };

    INT i = 0;
    while (mappingTable[i].keycode != IRKEY_NONE) {
        if (keycode == mappingTable[i].keycode)
            return mappingTable[i].button;
        i++;
    }

    return -1;
}

//
// Poll controllers for input
//
#define MAXDEVICES 4

HANDLE controllers[MAXDEVICES];
HANDLE irdevices[MAXDEVICES];

struct {
    DWORD lastPacketNumber;
    DWORD buttons;
} ctlrState[MAXDEVICES];

struct {
    DWORD lastPacketNumber;
    WORD lastKeyCode;
    WORD lastKeyTime;
} irState[MAXDEVICES];

VOID PollInput()
{
    DWORD insertions, removals;
    INT i, j;

    //
    // Check if any controller device has been added or removed
    //
    if (XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &insertions, &removals)) {
        for (i=0; i < MAXDEVICES; i++) {
            if ((removals & (1 << i)) && controllers[i]) {
                XInputClose(controllers[i]);
                controllers[i] = NULL;
            }
        }

        for (i=0; i < MAXDEVICES; i++) {
            if (insertions & (1 << i)) {
                controllers[i] = XInputOpen(XDEVICE_TYPE_GAMEPAD, i, XDEVICE_NO_SLOT, NULL);
                ctlrState[i].lastPacketNumber = -1;
                ctlrState[i].buttons = 0;
            }
        }
    }

    //
    // Check for IR remote devices
    //
    if (XGetDeviceChanges(XDEVICE_TYPE_IR_REMOTE, &insertions, &removals)) {
        for (i=0; i < MAXDEVICES; i++) {
            if ((removals & (1 << i)) && irdevices[i]) {
                XInputClose(irdevices[i]);
                irdevices[i] = NULL;
            }
        }

        for (i=0; i < MAXDEVICES; i++) {
            if (insertions & (1 << i)) {
                irdevices[i] = XInputOpen(XDEVICE_TYPE_IR_REMOTE, i, XDEVICE_NO_SLOT, NULL);
                irState[i].lastPacketNumber = -1;
                irState[i].lastKeyCode = IRKEY_NONE;
                irState[i].lastKeyTime = 0;
            }
        }

    }

    //
    // Poll controller inputs
    //
    for (i=0; i < MAXDEVICES; i++) {
        if (controllers[i] == NULL) continue;

        XINPUT_STATE states;
        DWORD err = XInputGetState(controllers[i], &states);
        if (err != ERROR_SUCCESS) continue;

        if (states.dwPacketNumber != ctlrState[i].lastPacketNumber) {
            DWORD buttons = 0;

            // Figure out which analog buttons are pressed
            for (j=0; j < 8; j++) {
                if (states.Gamepad.bAnalogButtons[j] >= 0x20)
                    buttons |= (1 << (BUTTON_ANALOG+j));
            }

            // Figure out which digital buttons are pressed
            for (j=0; j < 8; j++) {
                if (states.Gamepad.wButtons & (1 << j))
                    buttons |= (1 << (BUTTON_DIGITAL+j));
            }

            // NOTE: We're only interested in button-down event, i.e.
            // the previous state is up and the current state is down
            for (j=0; j < BUTTON_MAX; j++) {
                if ((ctlrState[i].buttons & (1 << j)) == 0 &&
                    (buttons & (1 << j)) != 0) {
                    ButtonPressed(j);
                }
            }
            ctlrState[i].buttons = buttons;
        }
        ctlrState[i].lastPacketNumber = states.dwPacketNumber;
    }

    //
    // Poll IR remote inputs
    //
    for (i=0; i < MAXDEVICES; i++) {
        if (irdevices[i] == NULL) continue;

        XINPUT_STATE_INTERNAL states;
        DWORD err = XInputGetState(irdevices[i], (XINPUT_STATE*) &states);
        if (err != ERROR_SUCCESS) continue;

        if (states.dwPacketNumber != irState[i].lastPacketNumber) {
            XINPUT_IR_REMOTE* irstate = &states.IrRemote;
            BOOL newkey = TRUE;

            if (irstate->wKeyCode != irState[i].lastKeyCode ||
                irstate->wTimeDelta >= 100) {
                //
                // If the new key is different from the old one,
                // or if the new key is not an auto-repeat
                //
                irState[i].lastKeyCode = irstate->wKeyCode;
                irState[i].lastKeyTime = 0;
            } else {
                //
                // If the new key is an auto-repeat,
                // we'll limit the repeat rate to a max of twice per second.
                //
                irState[i].lastKeyTime += irstate->wTimeDelta;
                if (irState[i].lastKeyTime >= 500)
                    irState[i].lastKeyTime %= 500;
                else
                    newkey = FALSE;
            }

            if (newkey) {
                if (irState[i].lastKeyCode >= IRKEY_9 && irState[i].lastKeyCode <= IRKEY_0) {
                    j = 9 - (irState[i].lastKeyCode - IRKEY_9);
                    NumberPressed(j);
                } else {
                    j = MapIRKey(irState[i].lastKeyCode);
                    if (j >= 0) {
                        ButtonPressed(j);
                    }
                }
            }
        }

        irState[i].lastPacketNumber = states.dwPacketNumber;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\test\sound.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation. All rights reserved.

Module Name:

    sound.cpp

Abstract:

    WMV playback sample application - sound related functions

--*/

#include "wmvplay.h"

//
// Initialize the sound packet queue
//
LPDIRECTSOUND8 SoundPacketQueue::dsound;

BOOL SoundPacketQueue::Initialize()
{
    maxCount = MAX_SOUND_PACKETS;
    maxPacketSize = MAX_SAMPLES_PER_SOUND_PACKET * AudioInfo.nBlockAlign;

    DWORD pktsize = sizeof(Packet) + maxPacketSize;
    BYTE* buf = (BYTE*) malloc(pktsize * MAX_SOUND_PACKETS);
    if (!buf) return FALSE;

    packetArray = buf;
    for (LONG i=0; i < maxCount; i++) {
        Packet* pkt = (Packet*) (buf + i * pktsize);
        pkt->flags = PACKETFLAG_SOUND;
        pkt->xmp.pvBuffer = pkt + 1;
        freeList.AddTail(pkt);
    }

    if (!PacketQueue::Initialize())
        return FALSE;

    DSSTREAMDESC ddsd;
    memset(&ddsd, 0, sizeof(ddsd));
    ddsd.dwMaxAttachedPackets = MAX_SOUND_PACKETS;
    ddsd.lpwfxFormat = &AudioInfo;

    HRESULT hr = DirectSoundCreateStream(&ddsd, &soundStream);
    return SUCCEEDED(hr);
}

//
// Check if any of the actively playing sound packets are finished
//
BOOL SoundPacketQueue::RetireBusyList()
{
    #ifndef DONT_PLAY_SOUND
    DirectSoundDoWork();
    #endif

    Packet* pkt;
    while (pkt = busyList.head) {
        if (pkt->status == XMEDIAPACKET_STATUS_PENDING)
            return TRUE;

        busyList.RemoveHead();
        ReleaseFreePacket(pkt);
    }

    return FALSE;
}

//
// Process the sound packets
//
VOID SoundPacketQueue::Process()
{
    //
    // Check if any sound packets are ready to be scheduled
    //
    while (!readyList.IsEmpty()) {
        Packet* pkt = readyList.RemoveHead();

        #ifndef DONT_PLAY_SOUND
        soundStream->Process(&pkt->xmp, NULL);
        #else
        pkt->status = XMEDIAPACKET_STATUS_SUCCESS;
        #endif

        busyList.AddTail(pkt);
    }

    RetireBusyList();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\test\wmvplay.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation. All rights reserved.

Module Name:

    wmvplay.cpp

Abstract:

    WMV playback sample application - main (decoder) thread

--*/

#include "wmvplay.h"
#include <stdio.h>

WMVVIDEOINFO VideoInfo;
TextureBufferQueue* TextureQ;
WAVEFORMATEX AudioInfo;
SoundPacketQueue* SoundQ;
LPWMVDECODER wmvdecoder;
REFERENCE_TIME PlayDuration, Preroll;
REFERENCE_TIME StartPresentationTime, CurrentPlayTime;
REFERENCE_TIME StartingSeekPosition;
BOOL FullScreenMode = TRUE;
INT DecodingFlag = DECODING_IDLE;
BOOL ContinuousMode = FALSE;
BOOL TestDVDFiles = FALSE;
INT TestFileIndex = 0;
CHAR CurrentFilename[MAX_PATH];
DWORD NumFilesPlayed;

//
// Process a decoded audio or video packet
//
VOID ProcessDecodedPacket(PacketQueue* pktq, Packet* pkt)
{
    if (pkt->completedSize) {
        UpdateDebugStats(pkt);

        if (pkt->timestamp < PlayDuration) {
            if (pkt->flags & PACKETFLAG_SOUND) {
                // NOTE: We ignore the sound timestamp here
                // and just assume the stream is continous.
                pkt->timestamp = 0;
            } else {
                pkt->timestamp = pkt->timestamp - StartingSeekPosition + StartPresentationTime;
            }

            pktq->ScheduleReadyPacket(pkt);
            return;
        }

        VERBOSE("Bogus timestamp: %c %d\n",
            (pkt->flags & PACKETFLAG_SOUND) ? 'a' : 'v',
            (LONG) (pkt->timestamp / 10000));
    }

    pktq->ReleaseFreePacket(pkt);
}

VOID SeekToStartingPosition()
{
    HRESULT hr;

    #if 0

    //
    // Seek directly by calling the decoder
    //
    REFERENCE_TIME seekpos = StartingSeekPosition;
    VERBOSE("Seeking to position: %d\n", (LONG) (seekpos / 10000));
    hr = wmvdecoder->Seek(&seekpos);
    VERBOSE("Actual position: %d\n", (LONG) (seekpos / 10000));

    #else

    //
    // Seek manually by decoding and skipping past unwanted packets
    //
    REFERENCE_TIME videotime, audiotime;
    DWORD videostatus, audiostatus;
    DWORD videosize, audiosize;
    XMEDIAPACKET videopkt, audiopkt;
    REFERENCE_TIME spewtime = 0;
    REFERENCE_TIME lasttime = 0;

    VERBOSE("Skipping");

    videopkt.dwMaxSize = VideoInfo.dwWidth * VideoInfo.dwOutputBitsPerPixel / 8;
    videopkt.dwMaxSize = (videopkt.dwMaxSize + 63) & ~63;
    videopkt.dwMaxSize = videopkt.dwMaxSize * VideoInfo.dwHeight;
    videopkt.pvBuffer = malloc(videopkt.dwMaxSize);
    videopkt.pdwCompletedSize = &videosize;
    videopkt.pdwStatus = &videostatus;
    videopkt.pContext = NULL;
    videopkt.prtTimestamp = &videotime;

    audiopkt.dwMaxSize = 512 * AudioInfo.nBlockAlign;
    audiopkt.pvBuffer = malloc(audiopkt.dwMaxSize);
    audiopkt.pdwCompletedSize = &audiosize;
    audiopkt.pdwStatus = &audiostatus;
    audiopkt.pContext = NULL;
    audiopkt.prtTimestamp = &audiotime;

    do {
        hr = wmvdecoder->ProcessMultiple(&videopkt, &audiopkt);
        ASSERT(hr == S_OK);

        if (videosize > 0) lasttime = videotime;
        if (audiosize > 0) lasttime = audiotime;

        if (lasttime >= spewtime) {
            VERBOSE(".");
            spewtime += 10000000;
        }

    } while (lasttime < StartingSeekPosition);
    StartingSeekPosition = lasttime;

    VERBOSE("\n");

    free(videopkt.pvBuffer);
    free(audiopkt.pvBuffer);

    #endif
}

//
// Play a WMV file
//
VOID PlayWMVFile()
{
    if (TestDVDFiles) {
        sprintf(CurrentFilename, "A:\\test%02d.wmv", TestFileIndex);
    } else {
        sprintf(CurrentFilename, "D:\\movies\\test%02d.wmv", TestFileIndex);
    }

    NumFilesPlayed++;
    VERBOSE("(%d) Opening movie file: %s\n", NumFilesPlayed, CurrentFilename);

    wmvdecoder = NULL;
    HRESULT hr = WmvCreateDecoder(
                    CurrentFilename,
                    NULL,
                    WMVVIDEOFORMAT_YUY2,
                    NULL,
                    &wmvdecoder);
    if (FAILED(hr)) goto exit;

    hr = wmvdecoder->GetVideoInfo(&VideoInfo);
    if (hr == WMVERR_NO_VIDEO_STREAM) {
        // Audio only file - fake the video info
        memset(&VideoInfo, 0, sizeof(VideoInfo));
        VideoInfo.dwWidth = 160;
        VideoInfo.dwHeight = 120;
        VideoInfo.dwOutputBitsPerPixel = 16;
    } else if (FAILED(hr))
        goto exit;

    hr = wmvdecoder->GetAudioInfo(&AudioInfo);
    if (hr == WMVERR_NO_AUDIO_STREAM) {
        // Video only file - fake the audio info
        AudioInfo.wFormatTag = WAVE_FORMAT_PCM;
        AudioInfo.nChannels = 1;
        AudioInfo.nSamplesPerSec = 44100;
        AudioInfo.wBitsPerSample = 16;
        AudioInfo.nBlockAlign = 2;
        AudioInfo.nAvgBytesPerSec = 2*44100;
        AudioInfo.cbSize = 0;
    } else if (FAILED(hr))
        goto exit;

    hr = wmvdecoder->GetPlayDuration(&PlayDuration, &Preroll);
    if (FAILED(hr)) goto exit;

    VERBOSE(
        "Movie info:\n"
        "  video %dx%dx%d %dbps\n"
        "  sound %dx%d-bit %dHz\n"
        "  play duration %d msecs\n"
        "  preroll %d msecs\n",
        VideoInfo.dwWidth,
        VideoInfo.dwHeight,
        VideoInfo.dwOutputBitsPerPixel,
        VideoInfo.dwBitsPerSecond,
        AudioInfo.nChannels,
        AudioInfo.wBitsPerSample,
        AudioInfo.nSamplesPerSec,
        (LONG) (PlayDuration / 10000),
        (LONG) (Preroll / 10000));

    if (StartingSeekPosition != 0) {
        SeekToStartingPosition();
    }

    TextureQ = TextureBufferQueue::Create();
    SoundQ = SoundPacketQueue::Create();
    ASSERT(TextureQ && SoundQ);

    DWORD starttick = GetTickCount();

    DecodingFlag = DECODING_INPROGRESS;
    SoundQ->GetTime(&StartPresentationTime);

    do {
        //
        // Update the current play time
        //
        SoundQ->GetTime(&CurrentPlayTime);

        //
        // Handle controller input
        //
        PollInput();

        //
        // Keep decoding if there are both free sound and video packets available
        // NOTE: We don't decode more than 3 video frames per iteration.
        //
        INT videocnt = 0;

        while (DecodingInProgress() &&
               videocnt < 3 &&
               !SoundQ->freeList.IsEmpty() &&
               !TextureQ->freeList.IsEmpty()) {
            Packet* audiopkt = SoundQ->GetFreeListHead();
            Packet* videopkt = TextureQ->GetFreeListHead();

            hr = wmvdecoder->ProcessMultiple(&videopkt->xmp, &audiopkt->xmp);
            if (FAILED(hr)) {
                AbortDecoding();
                break;
            }

            // Decoding has finished:
            //  we'll now wait until the sound playback is stopped
            if (hr == S_FALSE) {
                VERBOSE("Decoding completed\n");
                DecodingFlag = DECODING_COMPLETED;
            }

            ProcessDecodedPacket(SoundQ, audiopkt);

            if (videopkt->completedSize) videocnt++;
            ProcessDecodedPacket(TextureQ, videopkt);
        }

        //
        // Handle sound playback
        //
        SoundQ->Process();

        //
        // Handle video playback
        //
        TextureQ->Process();
    } while (DecodingInProgress() || !SoundQ->busyList.IsEmpty());

    VERBOSE("Decode / play time: %d msecs\n", GetTickCount() - starttick);
    SoundQ->Shutdown();
    TextureQ->Shutdown();

    delete SoundQ;
    SoundQ = NULL;

    delete TextureQ;
    TextureQ = NULL;

exit:
    if (FAILED(hr)) {
        VERBOSE("Decoding failed: %08x\n", hr);
        DecodingFlag = DECODING_COMPLETED;
    }

    if (wmvdecoder) {
        wmvdecoder->Release();
    }

    //
    // If the decoding completes normally, decide what to do next:
    //  either pause or move on to the next file
    //
    if (DecodingFlag == DECODING_COMPLETED) {
        if (ContinuousMode) {
            if (FAILED(hr) && GetFileAttributes(CurrentFilename) == 0xffffffff)
                TestFileIndex = 0;
            else
                TestFileIndex++;
            DecodingFlag = DECODING_IDLE;
        } else {
            DecodingFlag = DECODING_PAUSED;
        }
    }
}

//
// Main program entrypoint - decode thread
//
void __cdecl main()
{
    VERBOSE("Test started\n");

    XInitDevices(0, NULL);
    XSetFileCacheSize(1024*1024);

    TextureBufferQueue::InitializeD3D();
    SoundPacketQueue::InitializeDSound();

    while (DecodingFlag != DECODING_EXIT) {
        if (DecodingFlag != DECODING_PAUSED) {
            //
            // Dynamically load/unload WMVDEC sections
            //
            VOID* wmvdec_section = XLoadSection("WMVDEC");
            ASSERT(wmvdec_section);

            StartDebugStats();
            PlayWMVFile();
            StopDebugStats();

            BOOL freeok = XFreeSection("WMVDEC");
            ASSERT(freeok);
        }
        PollInput();
    }

    TextureBufferQueue::CleanupD3D();
    SoundPacketQueue::CleanupDSound();

    VERBOSE("Test completed\n");
    Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\common\debug.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       debug.cpp
 *  Content:    Debugger helper object.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  05/23/00    dereks  Created.
 *
 ***************************************************************************/

#include "dscommon.h"

#ifdef USEDPF

#ifdef BUILDING_DSOUND

DWORD &CDebug::m_dwDpfLevel = g_dwDirectSoundDebugLevel;
DWORD &CDebug::m_dwDpfBreakLevel = g_dwDirectSoundDebugBreakLevel;
BOOL &CDebug::m_fDebugBreak = g_fDirectSoundDebugBreak;

#else // BUILDING_DSOUND

DWORD CDebug::m_dwDpfLevel = DPFLVL_DEFAULT;
DWORD CDebug::m_dwDpfBreakLevel = DPFLVL_DEFAULT_BREAK;
BOOL CDebug::m_fDebugBreak = FALSE;

#endif // BUILDING_DSOUND

LPFNDPFCALLBACK CDebug::m_pfnDpfCallback = NULL;
DPFCONTEXT CDebug::m_aContext[DEBUG_CONTEXT_COUNT] = { 0 };

#endif // USEDPF

#ifdef USEDEBUGLOG

CHAR CDebug::m_aszLog[DEBUGLOG_ENTRY_COUNT][DEBUGLOG_ENTRY_LENGTH] = { 0 };
DWORD CDebug::m_dwLogIndex = 0;

#endif // USEDEBUGLOG


/***************************************************************************
 *
 *  dstrcpy
 *
 *  Description:
 *      Copies one string to another.
 *
 *  Arguments:
 *      LPSTR [in/out]: destination string.
 *      LPCSTR [in]: source string.
 *
 *  Returns:  
 *      LPSTR: pointer to the end of the string.
 *
 ***************************************************************************/

__inline LPSTR 
dstrcpy
(
    LPSTR                   dst, 
    LPCSTR                  src
)
{
    while(*dst = *src)
    {
        dst++;
        src++;
    }
    
    return dst;
}


/****************************************************************************
 *
 *  PrintStaticV
 *
 *  Description:
 *      Prints a string to the debugger.
 *
 *  Arguments:
 *      DWORD [in]: option flags.
 *      DWORD [in]: debug level.
 *      LPCSTR [in]: file called from.
 *      UINT [in]: line called from.
 *      LPCSTR [in]: function called from.
 *      LPCSTR [in]: format string.
 *      va_list [in]: format arguments.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef USEDPF

void __cdecl 
CDebug::PrintStaticV
(
    DWORD                   dwFlags, 
    DWORD                   dwLevel,     
    LPCSTR                  pszFile, 
    UINT                    nLine, 
    LPCSTR                  pszFunction, 
    LPCSTR                  pszLibrary,
    LPCSTR                  pszFormat,
    va_list                 va
)
{
    CHAR                    szDebug[0x400];
    CHAR                    szText[0x400];
    LPSTR                   pszWorking;
    DWORD                   dwWritten;

    if(dwLevel <= m_dwDpfLevel)
    {
        pszWorking = szDebug;

#ifdef DEBUG

        //
        // Add the library name
        //

        if((dwFlags & DPF_FLAGS_LIBRARY) && pszLibrary && *pszLibrary)
        {
            pszWorking += sprintf(pszWorking, "%s: ", pszLibrary);
        }

        //
        // Add the source file and line number
        //

        if((dwFlags & DPF_FLAGS_FILELINE) && pszFile && *pszFile)
        {
            pszWorking += sprintf(pszWorking, "%hs(%lu): ", pszFile, nLine);
        }

        //
        // Add the function name
        //

        if((dwFlags & DPF_FLAGS_FUNCTIONNAME) && pszFunction && *pszFunction)
        {
            pszWorking += sprintf(pszWorking, "%hs: ", pszFunction);
        }

        //
        // Add process and thread id
        //

        if(dwFlags & DPF_FLAGS_PROCESSTHREADID)
        {
            pszWorking += sprintf(pszWorking, "%.8lx: ", GetCurrentThreadId());
        }

        //
        // Add the type of message it is (i.e. error or warning)
        //

        switch(dwLevel)
        {
            case DPFLVL_ERROR:
                pszWorking = dstrcpy(pszWorking, "Error: ");
                break;

            case DPFLVL_RESOURCE:
                pszWorking = dstrcpy(pszWorking, "Resource failure: ");
                break;

            case DPFLVL_WARNING:
                pszWorking = dstrcpy(pszWorking, "Warning: ");
                break;
        }

#endif // DEBUG

        //
        // Add the debug string
        //

        vsprintf(szText, pszFormat, va);

#ifdef DEBUG

        pszWorking = dstrcpy(pszWorking, szText);

        //
        // Add a carriage-return since OutputDebugString doesn't
        //

        pszWorking = dstrcpy(pszWorking, "\n");

        //
        // Output to the debugger
        //

        OutputDebugStringA(szDebug);

        //
        // Break into the debugger
        //

        if(dwLevel && (dwLevel <= m_dwDpfBreakLevel))
        {
            Break();
        }

#endif // DEBUG

        //
        // Hand off to the callback routine
        //

        if(m_pfnDpfCallback)
        {
            m_pfnDpfCallback(dwLevel, szText);
        }
    }
}

#endif // USEDPF


/****************************************************************************
 *
 *  PrintStatic
 *
 *  Description:
 *      Prints a string to the debugger.
 *
 *  Arguments:
 *      DWORD [in]: option flags.
 *      DWORD [in]: debug level.
 *      LPCSTR [in]: file called from.
 *      UINT [in]: line called from.
 *      LPCSTR [in]: function called from.
 *      LPCSTR [in]: format string.
 *      va_list [in]: format arguments.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef USEDPF

void __cdecl 
CDebug::PrintStatic
(
    DWORD                   dwFlags, 
    DWORD                   dwLevel,     
    LPCSTR                  pszFile, 
    UINT                    nLine, 
    LPCSTR                  pszFunction, 
    LPCSTR                  pszLibrary,
    LPCSTR                  pszFormat,
    ...
)
{
    va_list                 va;

    va_start(va, pszFormat);
    PrintStaticV(dwFlags, dwLevel, pszFile, nLine, pszFunction, pszLibrary, pszFormat, va);
    va_end(va);
}

#endif // USEDPF


/****************************************************************************
 *
 *  SetContext
 *
 *  Description:
 *      Sets context for a DPF.
 *
 *  Arguments:
 *      DWORD [in]: option flags.
 *      DWORD [in]: debug level.
 *      LPCSTR [in]: file called from.
 *      UINT [in]: line called from.
 *      LPCSTR [in]: function called from.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef USEDPF

void __cdecl 
CDebug::SetContext
(
    DWORD                   dwFlags, 
    DWORD                   dwLevel,     
    LPCSTR                  pszFile, 
    UINT                    nLine, 
    LPCSTR                  pszFunction,
    LPCSTR                  pszLibrary
)
{

#ifdef _XBOX

    const KIRQL             irql    = KeGetCurrentIrql();

#else // _XBOX

    static const UINT       irql    = 0;

#endif // _XBOX

    m_aContext[irql].dwFlags = dwFlags;
    m_aContext[irql].dwLevel = dwLevel;
    m_aContext[irql].pszFile = pszFile;
    m_aContext[irql].nLine = nLine;
    m_aContext[irql].pszFunction = pszFunction;
    m_aContext[irql].pszLibrary = pszLibrary;
}

#endif // USEDPF


/****************************************************************************
 *
 *  Print
 *
 *  Description:
 *      Prints a string to the debugger.
 *
 *  Arguments:
 *      LPCSTR [in]: format string.
 *      ... [in]: format arguments.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef USEDPF

void __cdecl 
CDebug::Print
(
    LPCSTR                  pszFormat,
    ...
)
{

#ifdef _XBOX

    const KIRQL             irql    = KeGetCurrentIrql();

#else // _XBOX

    static const UINT       irql    = 0;

#endif // _XBOX

    va_list                 va;

    va_start(va, pszFormat);
    PrintStaticV(m_aContext[irql].dwFlags, m_aContext[irql].dwLevel, m_aContext[irql].pszFile, m_aContext[irql].nLine, m_aContext[irql].pszFunction, m_aContext[irql].pszLibrary, pszFormat, va);
    va_end(va);
}

#endif // USEDPF


/****************************************************************************
 *
 *  Assert
 *
 *  Description:
 *      Breaks into the debugger.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to assert.
 *      LPCSTR [in]: expression string.
 *      LPCSTR [in]: file called from.
 *      UINT [in]: line number called from.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef USEDPF

void __cdecl 
CDebug::Assert
(
    BOOL                    fAssert,
    LPCSTR                  pszExpression,
    LPCSTR                  pszFile,
    UINT                    nLine
)
{
    static const LPCSTR     pszBanner           = "******************************************************************************";
    CHAR                    szMessage[0x400];
    LPSTR                   pszMessage;

    if(fAssert)
    {
        pszMessage = szMessage;

        pszMessage = dstrcpy(pszMessage, pszBanner);
        pszMessage = dstrcpy(pszMessage, "\n");
        pszMessage = dstrcpy(pszMessage, "Assertion failed in ");
        pszMessage = dstrcpy(pszMessage, pszFile);
        pszMessage = dstrcpy(pszMessage, ", line ");
    
        _itoa(nLine, pszMessage, 10);
        pszMessage += strlen(pszMessage);

        pszMessage = dstrcpy(pszMessage, ":\n");
        pszMessage = dstrcpy(pszMessage, pszExpression);
        pszMessage = dstrcpy(pszMessage, "\n");
        pszMessage = dstrcpy(pszMessage, pszBanner);
        pszMessage = dstrcpy(pszMessage, "\n");

        OutputDebugStringA(szMessage);
        Break();
    }
}

#endif // USEDPF


/****************************************************************************
 *
 *  Break
 *
 *  Description:
 *      Breaks into the debugger.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef USEDPF

void __cdecl 
CDebug::Break
(
    void
)
{
    //
    // Break in the debugger
    //
    
    __asm int 3;

#ifdef _XBOX

    //
    // If we're at DISPATCH_LEVEL or higher, the VC debugger won't catch
    // the break.
    //
    
    if(KeGetCurrentIrql() >= DISPATCH_LEVEL)
    {
        m_fDebugBreak = TRUE;
    }

#endif // _XBOX

}

#endif // USEDPF


/****************************************************************************
 *
 *  Log
 *
 *  Description:
 *      Adds an entry to the debug log.
 *
 *  Arguments:
 *      LPCSTR [in]: format string.
 *      ...
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef USEDEBUGLOG

void __cdecl 
CDebug::Log
(
    LPCSTR                  pszFormat, 
    ...
)
{
    va_list                 va;
    int                     i;

    va_start(va, pszFormat);
    i = vsprintf(m_aszLog[m_dwLogIndex], pszFormat, va);
    va_end(va);
    
    for(i = i + 1; i < NUMELMS(m_aszLog[m_dwLogIndex]); i++)
    {
        m_aszLog[m_dwLogIndex][i] = 0;
    }

    m_dwLogIndex = (m_dwLogIndex + 1) % NUMELMS(m_aszLog);
}

#endif // USEDEBUGLOG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\test\wmvplay.h ===
/*++

Copyright (c) 2001  Microsoft Corporation. All rights reserved.

Module Name:

    wmvplay.h

Abstract:

    WMV playback sample - header file

--*/

#include <xtl.h>
#include <wmvxmo.h>

//
// Debug macros
//
#if DBG
extern "C" ULONG __cdecl DbgPrint(CHAR*, ...);
#define VERBOSE DbgPrint
#define ASSERT(cond) do { \
            if (!(cond)) { \
                DbgPrint("Error on line %d: %s\n", __LINE__, #cond); \
                DebugBreak(); \
            } \
        } while (0)
#else
#define VERBOSE 1 ? (void)0 : (void)
#define ASSERT(cond)
#endif

//
// Maximum number of active sound packets
//  and the max size of each packets (in samples)
//
#define MAX_SOUND_PACKETS 256
#define MAX_SAMPLES_PER_SOUND_PACKET 512

//
// Maximum number of textures (must be >= 2)
//
#define MAX_TEXTURES            12
#define SCREENWIDTH             640
#define SCREENHEIGHT            480

//
// Packet queue structures
//
#define PACKETFLAG_SOUND        0x01
#define PACKETFLAG_VIDEO        0x02

struct Packet {
    Packet* next;
    DWORD flags;
    DWORD completedSize;
    DWORD status;
    REFERENCE_TIME timestamp;
    XMEDIAPACKET xmp;
};

struct PacketList {
    Packet* head;
    Packet* tail;

    PacketList() { head = tail = NULL; }

    BOOL IsEmpty() { return head == NULL; }

    Packet* RemoveHead() {
        Packet* pkt = head;

        if ((head = pkt->next) == NULL)
            tail = NULL;
        else
            pkt->next = NULL;

        return pkt;
    }
    
    VOID AddTail(Packet* pkt) {
        if (tail)
            tail->next = pkt;
        else
            head = pkt;

        tail = pkt;
        pkt->next = NULL;
    }
};

class PacketQueue {
public:
    //
    // Return the first packet in the free packet list to the decoder
    //
    Packet* GetFreeListHead() {
        Packet* pkt = freeList.RemoveHead();

        pkt->completedSize = 0;
        pkt->xmp.dwMaxSize = maxPacketSize;
        return pkt;
    }

    //
    // Return the packet to the free packet list
    //
    VOID ReleaseFreePacket(Packet* pkt) {
        freeList.AddTail(pkt);
    }

    //
    // This is called by the decoder when it has a packet ready
    // for the render threads.
    //
    VOID ScheduleReadyPacket(Packet* pkt) {
        pkt->xmp.dwMaxSize = pkt->completedSize;
        readyList.AddTail(pkt);
    }

    PacketList freeList;
    PacketList readyList;
    PacketList busyList;

protected:
    PacketQueue() {
        maxCount = 0;
        maxPacketSize = 0;
    }

    BOOL Initialize() {
        Packet* pkt = freeList.head;
        do {
            pkt->xmp.pdwCompletedSize = &pkt->completedSize;
            pkt->xmp.pdwStatus = &pkt->status;
            pkt->xmp.prtTimestamp = &pkt->timestamp;
            pkt = pkt->next;
        } while (pkt);

        return TRUE;
    }

    LONG maxCount;
    DWORD maxPacketSize;
};

//
// Sound packet queue
//
class SoundPacketQueue : public PacketQueue {
public:
    static SoundPacketQueue* Create() {
        SoundPacketQueue* soundq = new SoundPacketQueue();
        if (soundq && soundq->Initialize())
            return soundq;

        delete soundq;
        return NULL;
    }

    static VOID InitializeDSound() {
        HRESULT hr = DirectSoundCreate(NULL, &dsound, NULL);
        ASSERT(SUCCEEDED(hr));
    }

    static VOID CleanupDSound() {
        if (dsound) {
            dsound->Release();
            dsound = NULL;
        }
    }

    ~SoundPacketQueue() {
        if (packetArray) {
            free(packetArray);
        }

        if (soundStream) {
            soundStream->Release();
        }
    }

    VOID GetTime(REFERENCE_TIME* time) {
        // This is in 1/48Khz unit
        DWORD dstime = DirectSoundGetSampleTime();

        // Convert to 100ns unit
        *time = (ULONGLONG) dstime * 10000 / 48;
    }

    VOID Process();
    VOID Shutdown() {
         while (!busyList.IsEmpty()) {
            RetireBusyList();
        }
    }

private:
    SoundPacketQueue() {
        dsound = NULL;
        soundStream = NULL;
        packetArray = NULL;
    }

    BOOL Initialize();
    BOOL RetireBusyList();

    LPDIRECTSOUNDSTREAM soundStream;
    VOID* packetArray;

    static LPDIRECTSOUND8 dsound;
};

//
// Texture buffer queue
//
struct TexturePacket : public Packet {
    IDirect3DTexture8* d3dtex;
};

class TextureBufferQueue : public PacketQueue {
public:
    static VOID InitializeD3D();
    static VOID CleanupD3D() {
        if (d3ddev) {
            d3ddev->Release();
            d3ddev = NULL;
        }
    }

    static TextureBufferQueue* Create() {
        TextureBufferQueue* textureq = new TextureBufferQueue();
        if (textureq && textureq->Initialize())
            return textureq;
        delete textureq;
        return NULL;
    }

    ~TextureBufferQueue() {
        for (INT i=0; i < MAX_TEXTURES; i++) {
            if (textures[i].d3dtex) {
                textures[i].d3dtex->Release();
            }
        }
    }

    VOID Process();
    VOID Shutdown();

private:
    TextureBufferQueue() {
        memset(textures, 0, sizeof(textures));
    }

    BOOL Initialize();
    IDirect3DVertexBuffer8* CreateVertexBuffer(BOOL fullscreen);
    VOID RenderFrame(TexturePacket* pkt);
    
    TexturePacket textures[MAX_TEXTURES];
    LONG discardedFrames, overlayBlocks;

    static IDirect3DDevice8* d3ddev;
    static LONG refreshInterval;
};

extern WAVEFORMATEX AudioInfo;
extern SoundPacketQueue* SoundQ;
extern WMVVIDEOINFO VideoInfo;
extern TextureBufferQueue* TextureQ;
extern REFERENCE_TIME StartPresentationTime, CurrentPlayTime;
extern BOOL FullScreenMode;
extern INT DecodingFlag;
extern BOOL ContinuousMode;
extern BOOL TestDVDFiles;
extern INT TestFileIndex;

//
// Poll controllers for input
//
VOID PollInput();

//
// Decoding flags
//
enum {
    DECODING_IDLE,
    DECODING_PAUSED,
    DECODING_ABORTED,
    DECODING_INPROGRESS,
    DECODING_COMPLETED,
    DECODING_EXIT,
};

inline VOID AbortDecoding() { DecodingFlag = DECODING_ABORTED; }
inline BOOL DecodingInProgress() { return DecodingFlag == DECODING_INPROGRESS; }

//
// Debug information and statistics
//
#if DBG && defined(DONT_PLAY_SOUND) && defined(DONT_PLAY_VIDEO)
#define DEBUGSTATS
#endif

#ifdef DEBUGSTATS
VOID StartDebugStats();
VOID StopDebugStats();
VOID UpdateDebugStats(Packet* pkt);
#else
#define StartDebugStats()
#define StopDebugStats()
#define UpdateDebugStats(pkt)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\common\debug.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       debug.h
 *  Content:    Debugger helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/21/97     dereks  Created.
 *
 ***************************************************************************/

#ifndef __DEBUG_H__
#define __DEBUG_H__

#include "macros.h"

#undef ASSERTMSG
#undef ASSERT
#undef BREAK

#pragma warning(disable:4002)

#if defined(DEBUG) && !defined(USEDPF)
#define USEDPF
#endif // USEDPF

#ifndef DPF_LIBRARY
#error DPF_LIBRARY not defined
#endif // DPF_LIBRARY

//
// Preprocessor hacks
//

#define QUOTE0(a) \
    #a

#define QUOTE1(a) \
    QUOTE0(a)

//
// DPF definitions
//
                                
BEGIN_DEFINE_STRUCT()
    DWORD   dwFlags;
    DWORD   dwLevel;
    LPCSTR  pszFile;
    UINT    nLine;
    LPCSTR  pszFunction;
    LPCSTR  pszLibrary;
END_DEFINE_STRUCT(DPFCONTEXT);

typedef void (CALLBACK *LPFNDPFCALLBACK)(DWORD dwLevel, LPCSTR pszString);

//
// #pragma Reminders
//

#define MESSAGE(msg) \
    message(__FILE__ "(" QUOTE1(__LINE__) "): " msg)

#define TODO(msg) \
    MESSAGE("TODO: " msg)

#define BUGBUG(msg) \
    MESSAGE("BUGBUG: " msg)

#define HACKHACK(msg) \
    MESSAGE("HACKHACK: " msg)

//
// Debug flags
//

#define DPF_FLAGS_LIBRARY           0x00000001
#define DPF_FLAGS_FILELINE          0x00000002
#define DPF_FLAGS_PROCESSTHREADID   0x00000004
#define DPF_FLAGS_FUNCTIONNAME      0x00000008

#ifndef DPF_FLAGS_DEFAULT
#ifdef _XBOX
#define DPF_FLAGS_DEFAULT           (DPF_FLAGS_LIBRARY | DPF_FLAGS_FUNCTIONNAME)
#else // _XBOX
#define DPF_FLAGS_DEFAULT           (DPF_FLAGS_LIBRARY | DPF_FLAGS_FUNCTIONNAME)
#endif // _XBOX
#endif // DPF_FLAGS_DEFAULT

//
// Debug levels
//

#define DPFLVL_ABSOLUTE         0   // Disregard level
#define DPFLVL_ERROR            1   // Errors
#define DPFLVL_RESOURCE         2   // Resource allocation failures
#define DPFLVL_WARNING          3   // Warnings
#define DPFLVL_INFO             4   // General info
#define DPFLVL_BLAB             5   // Mostly useless info
#define DPFLVL_ENTERLEAVE       9   // Function enter/leave

#define DPFLVL_FIRST            DPFLVL_ABSOLUTE
#define DPFLVL_LAST             DPFLVL_ENTERLEAVE

#ifndef DPFLVL_DEFAULT
#define DPFLVL_DEFAULT          DPFLVL_WARNING
#endif // DPFLVL_DEFAULT

#ifndef DPFLVL_DEFAULT_BREAK
#define DPFLVL_DEFAULT_BREAK    DPFLVL_RESOURCE
#endif // DPFLVL_DEFAULT_BREAK

#ifdef _XBOX
#define DEBUG_CONTEXT_COUNT     (HIGH_LEVEL + 1)
#else // _XBOX
#define DEBUG_CONTEXT_COUNT     1
#endif // _XBOX

#define DEBUGLOG_ENTRY_LENGTH   64
#define DEBUGLOG_ENTRY_COUNT    1024

#ifdef __cplusplus

//
// Debug object
//

namespace DirectSound
{
    class CDebug
    {
    public:

#ifdef USEDPF

#ifdef BUILDING_DSOUND

        static DWORD &          m_dwDpfLevel;
        static DWORD &          m_dwDpfBreakLevel;
        static BOOL &           m_fDebugBreak;

#else // BUILDING_DSOUND

        static DWORD            m_dwDpfLevel;
        static DWORD            m_dwDpfBreakLevel;
        static BOOL             m_fDebugBreak;

#endif // BUILDING_DSOUND

        static LPFNDPFCALLBACK  m_pfnDpfCallback;

#endif // USEDPF

    protected:

#ifdef USEDPF

        static DPFCONTEXT       m_aContext[DEBUG_CONTEXT_COUNT];

#endif // USEDPF

#ifdef USEDEBUGLOG

        static CHAR             m_aszLog[DEBUGLOG_ENTRY_COUNT][DEBUGLOG_ENTRY_LENGTH];
        static DWORD            m_dwLogIndex;

#endif // USEDEBUGLOG

    public:

#ifdef USEDPF
        
        // DPF functions
        static void __cdecl SetContext(DWORD dwFlags, DWORD dwLevel, LPCSTR pszFile, UINT nLine, LPCSTR pszFunction, LPCSTR pszLibrary);
        static void __cdecl Print(LPCSTR pszFormat, ...);
        static void __cdecl PrintStatic(DWORD dwFlags, DWORD dwLevel, LPCSTR pszFile, UINT nLine, LPCSTR pszFunction, LPCSTR pszLibrary, LPCSTR pszFormat, ...);
        static void __cdecl PrintStaticV(DWORD dwFlags, DWORD dwLevel, LPCSTR pszFile, UINT nLine, LPCSTR pszFunction, LPCSTR pszLibrary, LPCSTR pszFormat, va_list va);
        static void __cdecl Assert(BOOL fAssert, LPCSTR pszExpression, LPCSTR pszFile, UINT nLine);
        static void __cdecl Break(void);

#endif // USEDPF

#ifdef USEDEBUGLOG

        // Debug log functions
        static void __cdecl Log(LPCSTR pszFormat, ...);

#endif // USEDEBUGLOG

    };
};

#ifdef USEDPF

#define DPF_ABSOLUTE \
    DirectSound::CDebug::SetContext(DPF_FLAGS_DEFAULT, DPFLVL_ABSOLUTE, __FILE__, __LINE__, DPF_FNAME, DPF_LIBRARY), \
    DirectSound::CDebug::Print

#define DPF_ERROR \
    DirectSound::CDebug::SetContext(DPF_FLAGS_DEFAULT, DPFLVL_ERROR, __FILE__, __LINE__, DPF_FNAME, DPF_LIBRARY), \
    DirectSound::CDebug::Print

#define DPF_RESOURCE \
    DirectSound::CDebug::SetContext(DPF_FLAGS_DEFAULT, DPFLVL_RESOURCE, __FILE__, __LINE__, DPF_FNAME, DPF_LIBRARY), \
    DirectSound::CDebug::Print

#define DPF_WARNING \
    DirectSound::CDebug::SetContext(DPF_FLAGS_DEFAULT, DPFLVL_WARNING, __FILE__, __LINE__, DPF_FNAME, DPF_LIBRARY), \
    DirectSound::CDebug::Print

#define DPF_INFO \
    DirectSound::CDebug::SetContext(DPF_FLAGS_DEFAULT, DPFLVL_INFO, __FILE__, __LINE__, DPF_FNAME, DPF_LIBRARY), \
    DirectSound::CDebug::Print

#define DPF_BLAB \
    DirectSound::CDebug::SetContext(DPF_FLAGS_DEFAULT, DPFLVL_BLAB, __FILE__, __LINE__, DPF_FNAME, DPF_LIBRARY), \
    DirectSound::CDebug::Print

#ifdef DPF_ENABLE_ENTERLEAVE

#define DPF_ENTERLEAVE \
    DirectSound::CDebug::SetContext(DPF_FLAGS_DEFAULT, DPFLVL_ENTERLEAVE, __FILE__, __LINE__, DPF_FNAME, DPF_LIBRARY), \
    DirectSound::CDebug::Print

#else // DPF_ENTERLEAVE
                                
#define DPF_ENTERLEAVE(a)

#endif // DPF_ENTERLEAVE
                                
#define ASSERT(a) \
    DirectSound::CDebug::Assert(!(a), #a, __FILE__, __LINE__)

#define ASSERTMSG(a) \
    DirectSound::CDebug::Assert(TRUE, a, __FILE__, __LINE__)

#define BREAK() \
    DirectSound::CDebug::Break()

#else // USEDPF

#define DPF_ABSOLUTE(a)
#define DPF_ERROR(a)
#define DPF_RESOURCE(a)
#define DPF_WARNING(a)
#define DPF_INFO(a)
#define DPF_BLAB(a)
#define DPF_ENTERLEAVE(a)

#define ASSERT(a)
#define ASSERTMSG(a)
#define BREAK()

#endif // USEDPF
                                
#define DPF_ENTER()             DPF_ENTERLEAVE("Enter")
#define DPF_LEAVE(a)            DPF_ENTERLEAVE("Leave, returning %#x", (DWORD)(a))
#define DPF_LEAVE_VOID()        DPF_ENTERLEAVE("Leave")

#define DPF_LEAVE_HRESULT(a)    DPF_LEAVE(a)
#define DPF_LEAVE_WINERROR(a)   DPF_LEAVE(a)
#define DPF_LEAVE_NTSTATUS(a)   DPF_LEAVE(a)

#undef DPF_FNAME
#define DPF_FNAME               NULL

#ifdef USEDEBUGLOG

#define DEBUGLOG DirectSound::CDebug::Log

#else // USEDEBUGLOG

#define DEBUGLOG(a)

#endif // USEDEBUGLOG

#endif // __cplusplus

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\common\drvhlp.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       drvhlp.h
 *  Content:    Miscelaneous NT-style driver helper functions and objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/07/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __DRVHLP_H__
#define __DRVHLP_H__

#if defined(_XBOX) && defined(__cplusplus)

// 
// Raised IRQL object
//

namespace DirectSound
{
    class CIrql
    {
    private:
        KIRQL                   m_irql;
        BOOL                    m_fRaised;

    public:
        CIrql(void);

    public:
        void Raise(void);
        void Lower(void);
    };

    __inline CIrql::CIrql(void)
    {
        m_fRaised = FALSE;
    }
    
    __inline void CIrql::Raise(void)
    {
        if(m_fRaised = (KeGetCurrentIrql() < DISPATCH_LEVEL))
        {
            m_irql = KfRaiseIrql(DISPATCH_LEVEL);
        }
    }

    __inline void CIrql::Lower(void)
    {
        if(m_fRaised)
        {
            KfLowerIrql(m_irql);
            m_fRaised = FALSE;
        }
    }
}

//
// Automatic (function-scope) raised IRQL
//

namespace DirectSound
{
    class CAutoIrql
        : public CIrql
    {
    public:
        CAutoIrql(void);
        ~CAutoIrql(void);
    };

    __inline CAutoIrql::CAutoIrql(void)
    {
        Raise();
    }

    __inline CAutoIrql::~CAutoIrql(void)
    {
        Lower();
    }
}

#define AutoIrql() \
    DirectSound::CAutoIrql __AutoIrql

//
// Floating point state
//

namespace DirectSound
{
    class CFpState
    {
    private:
        static DWORD            m_dwRefCount;
        static KFLOATING_SAVE   m_fps;

    public:
        void Save(void);
        void Restore(void);
    };

    __inline void CFpState::Save(void)
    {
        if(KeIsExecutingDpc())
        {
            if(!m_dwRefCount++)
            {
                KeSaveFloatingPointState(&m_fps);
            }
        }
    }

    __inline void CFpState::Restore(void)
    {
        if(KeIsExecutingDpc())
        {
            if(!--m_dwRefCount)
            {
                KeRestoreFloatingPointState(&m_fps);
            }
        }
    }
}

//
// Automatic (function-scope) floating-point state
//

namespace DirectSound
{
    class CAutoFpState
        : private CFpState
    {
    public:
        CAutoFpState(void);
        ~CAutoFpState(void);
    };

    __inline CAutoFpState::CAutoFpState(void)
    {
        Save();
    }

    __inline CAutoFpState::~CAutoFpState(void)
    {
        Restore();
    }
}

#define AutoFpState() \
    DirectSound::CAutoFpState __AutoFpState

#endif // defined(_XBOX) && defined(__cplusplus)

#ifdef __cplusplus

//
// Interlocked and/or operations
//

static void __fastcall and(volatile unsigned short *dst, unsigned short src)
{
    __asm
    {
        and word ptr [ecx], dx
    }
}

static void __fastcall or(volatile unsigned short *dst, unsigned short src)
{
    __asm
    {
        or word ptr [ecx], dx
    }
}

static void __fastcall and(volatile unsigned long *dst, unsigned long src)
{
    __asm
    {
        and dword ptr [ecx], edx
    }                        
}

static void __fastcall or(volatile unsigned long *dst, unsigned long src)
{
    __asm
    {
        or dword ptr [ecx], edx
    }
}

#endif // __cplusplus

#endif // __DRVHLP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\common\dscommon.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1997-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dscommon.cpp
 *  Content:    DirectSound common source file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/10/01    dereks  Created.
 *
 ***************************************************************************/

#include "dscommon.h"
#include "debug.cpp"
#include "memmgr.cpp"
#include "format.cpp"
#include "waveldr.cpp"
#include "drvhlp.cpp"
#include "imaadpcm.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\common\drvhlp.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       drvhlp.cpp
 *  Content:    Miscelaneous NT-style driver helper functions and objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/07/01    dereks  Created.
 *
 ****************************************************************************/

#include "dscommon.h"

#ifdef _XBOX

DWORD CFpState::m_dwRefCount = 0;
KFLOATING_SAVE CFpState::m_fps;

#endif // _XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\common\dscommon.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dscommon.h
 *  Content:    DirectSound common header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/10/01    dereks  Created.
 *
 ***************************************************************************/

#ifndef __DSCOMMON_H__
#define __DSCOMMON_H__

//
// Preprocessor definitions
//

#if DBG && !defined(DEBUG)
#define DEBUG
#endif

#if defined(DEBUG) && !defined(VALIDATE_PARAMETERS)
#define VALIDATE_PARAMETERS
#endif

//
// Public includes
//

#ifdef _XBOX

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>
#include <pci.h>

#ifdef __cplusplus
}
#endif // __cplusplus

#define NODSOUND
#include <xtl.h>
#undef NODSOUND

#ifdef DSNDVER
#include <dsndver.h>
#endif // DSNDVER

#include <xboxp.h>
#include <dsoundp.h>

#else // _XBOX

#include <windows.h>
#include <commctrl.h>
#include <objbase.h>
#include <mmsystem.h>
#include <mmreg.h>

#endif // _XBOX

#include <stdio.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdlib.h>
#include <xboxverp.h>
#include <tchar.h>

//
// Private includes
//

#include "macros.h"
#include "debug.h"
#include "ntlist.h"
#include "memmgr.h"
#include "format.h"
#include "drvhlp.h"
#include "refcount.h"
#include "waveldr.h"
#include "imaadpcm.h"

//
// Namespaces
//

#ifdef __cplusplus

using namespace DirectSound;

#endif // __cplusplus

#endif // __DSCOMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\common\format.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       format.cpp
 *  Content:    WAVEFORMATEX helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/10/00    dereks  Created.
 *
 ****************************************************************************/

#include "dscommon.h"

#ifndef _XBOX

#define DSBFREQUENCY_MIN 1
#define DSBFREQUENCY_MAX 0x7FFFFFFF

#endif // _XBOX


/****************************************************************************
 *
 *  CreatePcmFormat
 *
 *  Description:
 *      Creates a PCM wave format structure.
 *
 *  Arguments:
 *      WORD [in]: channel count.
 *      DWORD [in]: sampling rate.
 *      WORD [in]: count of bits per sample.
 *      LPWAVEFORMATEX [out]: format data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "WaveFormat::CreatePcmFormat"

void 
WaveFormat::CreatePcmFormat
(
    WORD                    nChannels, 
    DWORD                   nSamplesPerSec, 
    WORD                    wBitsPerSample, 
    LPWAVEFORMATEX          pwfx
)
{
    DPF_ENTER();
    
    ASSERT(pwfx);

    pwfx->wFormatTag = WAVE_FORMAT_PCM;
    pwfx->nChannels = nChannels;
    pwfx->nSamplesPerSec = nSamplesPerSec;
    pwfx->wBitsPerSample = wBitsPerSample;
    pwfx->nBlockAlign = nChannels * wBitsPerSample / 8;
    pwfx->nAvgBytesPerSec = nSamplesPerSec * pwfx->nBlockAlign;
    pwfx->cbSize = 0;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CreateXboxAdpcmFormat
 *
 *  Description:
 *      Creates an Xbox ADPCM wave format structure.
 *
 *  Arguments:
 *      WORD [in]: channel count.
 *      DWORD [in]: sampling rate.
 *      LPWAVEFORMATEX [out]: format data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "WaveFormat::CreateXboxAdpcmFormat"

void 
WaveFormat::CreateXboxAdpcmFormat
(
    WORD                    nChannels, 
    DWORD                   nSamplesPerSec, 
    LPXBOXADPCMWAVEFORMAT   pwfx
)
{
    DPF_ENTER();
    
    ASSERT(pwfx);

    pwfx->wfx.wFormatTag = WAVE_FORMAT_XBOX_ADPCM;
    pwfx->wfx.nChannels = nChannels;
    pwfx->wfx.nSamplesPerSec = nSamplesPerSec;
    pwfx->wfx.wBitsPerSample = XBOX_ADPCM_BITS_PER_SAMPLE;
    pwfx->wfx.nBlockAlign = nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;
    pwfx->wfx.nAvgBytesPerSec = nSamplesPerSec / XBOX_ADPCM_SAMPLES_PER_BLOCK * XBOX_ADPCM_ENCODED_BLOCK_SIZE;
    pwfx->wfx.cbSize = sizeof(*pwfx) - sizeof(pwfx->wfx);
    pwfx->wSamplesPerBlock = XBOX_ADPCM_SAMPLES_PER_BLOCK;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CreateInternalFormat
 *
 *  Description:
 *      Initializes a DSWAVEFORMAT structure based on a PCMWAVEFORMAT,
 *      WAVEFORMATEX or WAVEFORMATEX derivitave.
 *
 *  Arguments:
 *      LPDSWAVEFORMAT [out]: DirectSound format structure.
 *      LPCWAVEFORMATEX [in]: generic format structure.
 *
 *  Returns:  
 *      DWORD: mixbin assignment mask, if any.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WaveFormat::CreateInternalFormat"

DWORD
WaveFormat::CreateInternalFormat
(
    LPDSWAVEFORMAT          pDest,
    LPCWAVEFORMATEX         pSource
)
{
    DWORD                   dwChannelMask   = 0;
    
    DPF_ENTER();

    ASSERT(pDest);
    ASSERT(pSource);

    switch(pSource->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            PcmToInternalFormat(pDest, pSource);
            break;

        case WAVE_FORMAT_XBOX_ADPCM:
            AdpcmToInternalFormat(pDest, (LPCXBOXADPCMWAVEFORMAT)pSource);
            break;

#if defined(_XBOX) && !defined(MCPX_BOOT_LIB)

        case WAVE_FORMAT_EXTENSIBLE:
            dwChannelMask = ExtensibleToInternalFormat(pDest, (LPCWAVEFORMATEXTENSIBLE)pSource);
            break;

#endif // defined(_XBOX) && !defined(MCPX_BOOT_LIB)

        default:
            ASSERTMSG("Unexpected format tag");
            break;
    }

    DPF_LEAVE(dwChannelMask);

    return dwChannelMask;
}
            

/****************************************************************************
 *
 *  IsValidFormat
 *
 *  Description:
 *      Validates a format structure.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WaveFormat::IsValidFormat"

BOOL
WaveFormat::IsValidFormat
(
    LPCWAVEFORMATEX         pwfx
)
{
    BOOL                    fSuccess;
    
    DPF_ENTER();

    ASSERT(pwfx);

    switch(pwfx->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            fSuccess = IsValidPcmFormat(pwfx);
            break;

        case WAVE_FORMAT_XBOX_ADPCM:
            fSuccess = IsValidAdpcmFormat((LPCXBOXADPCMWAVEFORMAT)pwfx);
            break;

#if defined(_XBOX) && !defined(MCPX_BOOT_LIB)

        case WAVE_FORMAT_EXTENSIBLE:
            fSuccess = IsValidExtensibleFormat((LPCWAVEFORMATEXTENSIBLE)pwfx);
            break;

#endif // defined(_XBOX) && !defined(MCPX_BOOT_LIB)

        default:
            DPF_ERROR("Unsupported format tag");
            fSuccess = FALSE;
            break;
    }

    DPF_LEAVE(fSuccess);

    return fSuccess;
}
            

/****************************************************************************
 *
 *  PcmToInternalFormat
 *
 *  Description:
 *      Initializes a DSWAVEFORMAT structure based on a PCMWAVEFORMAT 
 *      structure.
 *
 *  Arguments:
 *      LPDSWAVEFORMAT [out]: DirectSound format structure.
 *      LPCWAVEFORMATEX [in]: generic format structure.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WaveFormat::PcmToInternalFormat"

void
WaveFormat::PcmToInternalFormat
(
    LPDSWAVEFORMAT          pDest,
    LPCWAVEFORMATEX         pSource
)
{
    DPF_ENTER();

    ASSERT(pDest);
    ASSERT(pSource);

    ASSERT(pSource->nChannels <= 0xFF);
    ASSERT(pSource->wBitsPerSample <= 0xFF);
    ASSERT(pSource->nBlockAlign <= 0xFF);

    pDest->wFormatTag = WAVE_FORMAT_PCM;
    pDest->nChannels = (BYTE)pSource->nChannels;
    pDest->wBitsPerSample = (BYTE)pSource->wBitsPerSample;
    pDest->nSamplesPerSec = pSource->nSamplesPerSec;
    pDest->nBlockAlign = (BYTE)pSource->nBlockAlign;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  IsValidPcmFormat
 *
 *  Description:
 *      Validates a format structure.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WaveFormat::IsValidPcmFormat"

BOOL 
WaveFormat::IsValidPcmFormat
(
    LPCWAVEFORMATEX         pwfx
)
{
    BOOL                    fValid  = TRUE;

    DPF_ENTER();

    ASSERT(pwfx);

    if(WAVE_FORMAT_PCM != pwfx->wFormatTag)
    {
        DPF_ERROR("Format tag not PCM");
        fValid = FALSE;
    }
    
    if((1 != pwfx->nChannels) && (2 != pwfx->nChannels) && (4 != pwfx->nChannels) && (6 != pwfx->nChannels))
    {
        DPF_ERROR("Invalid channel count");
        fValid = FALSE;
    }

    if((8 != pwfx->wBitsPerSample) && (16 != pwfx->wBitsPerSample))
    {
        DPF_ERROR("Invalid sample bit resolution");
        fValid = FALSE;
    }

    if((pwfx->nSamplesPerSec < DSBFREQUENCY_MIN) || (pwfx->nSamplesPerSec > DSBFREQUENCY_MAX))
    {
        DPF_ERROR("Invalid sampling rate");
        fValid = FALSE;
    }

    if(pwfx->nChannels * pwfx->wBitsPerSample / 8 != pwfx->nBlockAlign)
    {
        DPF_ERROR("Bad block alignment");
        fValid = FALSE;
    }

    DPF_LEAVE(fValid);

    return fValid;
}


/****************************************************************************
 *
 *  AdpcmToInternalFormat
 *
 *  Description:
 *      Initializes a DSWAVEFORMAT structure based on an XBOXADPCMWAVEFORMAT 
 *      structure.
 *
 *  Arguments:
 *      LPDSWAVEFORMAT [out]: DirectSound format structure.
 *      LPCXBOXADPCMWAVEFORMAT [in]: generic format structure.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WaveFormat::AdpcmToInternalFormat"

void
WaveFormat::AdpcmToInternalFormat
(
    LPDSWAVEFORMAT          pDest,
    LPCXBOXADPCMWAVEFORMAT  pSource
)
{
    static const BYTE       wBitsPerSample      = 4;

    DPF_ENTER();

    ASSERT(pDest);
    ASSERT(pSource);

    ASSERT(pSource->wfx.nChannels <= 0xFF);
    ASSERT(pSource->wfx.wBitsPerSample <= 0xFF);
    ASSERT(pSource->wfx.nBlockAlign <= 0xFF);

    pDest->wFormatTag = WAVE_FORMAT_XBOX_ADPCM;
    pDest->nChannels = (BYTE)pSource->wfx.nChannels;
    pDest->wBitsPerSample = (BYTE)wBitsPerSample;
    pDest->nSamplesPerSec = pSource->wfx.nSamplesPerSec;
    pDest->nBlockAlign = (BYTE)pSource->wfx.nBlockAlign;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  IsValidAdpcmFormat
 *
 *  Description:
 *      Validates a format structure.
 *
 *  Arguments:
 *      LPCXBOXADPCMWAVEFORMAT [in]: format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WaveFormat::IsValidAdpcmFormat"

BOOL 
WaveFormat::IsValidAdpcmFormat
(
    LPCXBOXADPCMWAVEFORMAT  pwfx
)
{
    static const WORD       wSamplesPerBlock    = 64;
    static const WORD       wBitsPerSample      = 4;
    static const WORD       wBytesPerBlock      = 36;
    BOOL                    fValid              = TRUE;

    DPF_ENTER();

    ASSERT(pwfx);

    if(WAVE_FORMAT_XBOX_ADPCM != pwfx->wfx.wFormatTag)
    {
        DPF_ERROR("Format tag not XBOX_ADPCM");
        fValid = FALSE;
    }
    
    if(sizeof(*pwfx) - sizeof(pwfx->wfx) != pwfx->wfx.cbSize)
    {
        DPF_ERROR("cbSize not %lu", sizeof(*pwfx) - sizeof(pwfx->wfx));
        fValid = FALSE;
    }
    
    if((pwfx->wfx.nChannels < 1) || (pwfx->wfx.nChannels > 2))
    {
        DPF_ERROR("Invalid channel count");
        fValid = FALSE;
    }

    if((pwfx->wfx.nSamplesPerSec < DSBFREQUENCY_MIN) || (pwfx->wfx.nSamplesPerSec > DSBFREQUENCY_MAX))
    {
        DPF_ERROR("Invalid sampling rate");
        fValid = FALSE;
    }

    if(wBitsPerSample != pwfx->wfx.wBitsPerSample)
    {
        DPF_ERROR("Invalid sample bit resolution");
        fValid = FALSE;
    }

    if(wSamplesPerBlock != pwfx->wSamplesPerBlock)
    {
        DPF_ERROR("Invalid samples per block");
        fValid = FALSE;
    }

    if(wBytesPerBlock * pwfx->wfx.nChannels != pwfx->wfx.nBlockAlign)
    {
        DPF_ERROR("Bad block-alignment");
        fValid = FALSE;
    }

    DPF_LEAVE(fValid);

    return fValid;
}


/****************************************************************************
 *
 *  ExtensibleToInternalFormat
 *
 *  Description:
 *      Initializes a DSWAVEFORMAT structure based on a WAVEFORMATEXTENSIBLE
 *      structure.
 *
 *  Arguments:
 *      LPDSWAVEFORMAT [out]: DirectSound format structure.
 *      LPCWAVEFORMATEXTENSIBLE [in]: generic format structure.
 *
 *  Returns:  
 *      DWORD: mixbin assignment mask, if any.
 *
 ****************************************************************************/

#if defined(_XBOX) && !defined(MCPX_BOOT_LIB)

#undef DPF_FNAME
#define DPF_FNAME "WaveFormat::ExtensibleToInternalFormat"

DWORD
WaveFormat::ExtensibleToInternalFormat
(
    LPDSWAVEFORMAT          pDest,
    LPCWAVEFORMATEXTENSIBLE pSource
)
{
    DPF_ENTER();

    ASSERT(pDest);
    ASSERT(pSource);

    if(IsEqualGUID(pSource->SubFormat, KSDATAFORMAT_SUBTYPE_PCM))
    {
        PcmToInternalFormat(pDest, &pSource->Format);
    }
    else if(IsEqualGUID(pSource->SubFormat, KSDATAFORMAT_SUBTYPE_XBOX_ADPCM))
    {
        AdpcmToInternalFormat(pDest, (LPCXBOXADPCMWAVEFORMAT)&pSource->Format);
    }
    else
    {
        ASSERTMSG("Unexpected subformat");
    }

    DPF_LEAVE(pSource->dwChannelMask);

    return pSource->dwChannelMask;
}

#endif // defined(_XBOX) && !defined(MCPX_BOOT_LIB)


/****************************************************************************
 *
 *  IsValidExtensibleFormat
 *
 *  Description:
 *      Validates a format structure.
 *
 *  Arguments:
 *      LPCWAVEFORMATEXTENSIBLE [in]: format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#if defined(_XBOX) && !defined(MCPX_BOOT_LIB)

#undef DPF_FNAME
#define DPF_FNAME "WaveFormat::IsValidExtensibleFormat"

BOOL 
WaveFormat::IsValidExtensibleFormat
(
    LPCWAVEFORMATEXTENSIBLE pwfx
)
{
    BOOL                    fValid  = TRUE;

    DPF_ENTER();

    ASSERT(pwfx);

    if(WAVE_FORMAT_EXTENSIBLE != pwfx->Format.wFormatTag)
    {
        DPF_ERROR("Format tag not EXTENSIBLE");
        fValid = FALSE;
    }
    
    if(sizeof(*pwfx) - sizeof(pwfx->Format) != pwfx->Format.cbSize)
    {
        DPF_ERROR("cbSize not %lu", sizeof(*pwfx) - sizeof(pwfx->Format));
        fValid = FALSE;
    }
    
    if(IsEqualGUID(pwfx->SubFormat, KSDATAFORMAT_SUBTYPE_PCM))
    {
        if(!IsValidPcmFormat(&pwfx->Format))
        {
            fValid = FALSE;
        }

        if(pwfx->Samples.wValidBitsPerSample != pwfx->Format.wBitsPerSample)
        {
            DPF_ERROR("wValidBitsPerSample must equal wBitsPerSample");
            fValid = FALSE;
        }

        if(pwfx->Samples.wReserved)
        {
            DPF_ERROR("wReserved must be 0 for SUBTYPE_PCM");
            fValid = FALSE;
        }
    }
    else if(IsEqualGUID(pwfx->SubFormat, KSDATAFORMAT_SUBTYPE_XBOX_ADPCM))
    {
        if(!IsValidAdpcmFormat((LPCXBOXADPCMWAVEFORMAT)&pwfx->Format))
        {
            fValid = FALSE;
        }
    }
    else
    {
        DPF_ERROR("Invalid sub-format identifier");
        fValid = FALSE;
    }

    if(pwfx->dwChannelMask & ~SPEAKER_MASK)
    {
        DPF_ERROR("Invalid channel mask");
        fValid = FALSE;
    }

    DPF_LEAVE(fValid);

    return fValid;
}

#endif // defined(_XBOX) && !defined(MCPX_BOOT_LIB)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\common\imaadpcm.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       imaadpcm.h
 *  Content:    IMA ADPCM CODEC.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/29/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __IMAADPCM_H__
#define __IMAADPCM_H__

#include "macros.h"

#define IMAADPCM_BITS_PER_SAMPLE        4
#define IMAADPCM_HEADER_LENGTH          4
                                        
#define IMAADPCM_MAX_CHANNELS           2
#define IMAADPCM_PCM_BITS_PER_SAMPLE    16

#ifdef _XBOX

DEFINETYPE(IMAADPCMWAVEFORMAT, XBOXADPCMWAVEFORMAT);

#else // _XBOX

DEFINELPCTYPE(IMAADPCMWAVEFORMAT);

#endif // _XBOX

#ifdef __cplusplus

//
// IMA ADPCM encoder function prototype
//

typedef BOOL (*LPFNIMAADPCMCONVERT)(LPBYTE pbSrc, LPBYTE pbDst, UINT cBlocks, UINT nBlockAlignment, UINT cSamplesPerBlock, LPINT pnStepIndexL, LPINT pnStepIndexR);

//
// IMA ADPCM CODEC
//

namespace DirectSound
{
    class CImaAdpcmCodec
    {
    protected:
        IMAADPCMWAVEFORMAT      m_wfxEncode;                // Encoded format description
        BOOL                    m_fEncoder;                 // Is the object acting as an encoder?

    private:
        static const short      m_asNextStep[16];           // Step increment array
        static const short      m_asStep[89];               // Step value array
        int                     m_nStepIndexL;              // Left-channel stepping index
        int                     m_nStepIndexR;              // Right-channel stepping index
        LPFNIMAADPCMCONVERT     m_pfnConvert;               // Conversion function

    public:
        CImaAdpcmCodec(void);
        virtual ~CImaAdpcmCodec(void);

    public:
        // Initialization
        BOOL Initialize(LPCIMAADPCMWAVEFORMAT pwfxEncode, BOOL fEncoder);

        // Size conversions
        WORD GetEncodeAlignment(void);
        WORD GetDecodeAlignment(void);
        WORD GetSourceAlignment(void);
        WORD GetDestinationAlignment(void);

        // Data conversions
        BOOL Convert(LPCVOID pvSrc, LPVOID pvDst, UINT cBlocks);
        void Reset(void);

        // Format descriptions
        static void CreatePcmFormat(WORD nChannels, DWORD nSamplesPerSec, LPWAVEFORMATEX pwfxFormat);
        static void CreateImaAdpcmFormat(WORD nChannels, DWORD nSamplesPerSec, WORD nSamplesPerBlock, LPIMAADPCMWAVEFORMAT pwfxFormat);

        static BOOL IsValidPcmFormat(LPCWAVEFORMATEX pwfxFormat);
        static BOOL IsValidImaAdpcmFormat(LPCIMAADPCMWAVEFORMAT pwfxFormat);

    private:
        // En/decoded data alignment
        static WORD CalculateEncodeAlignment(WORD nSamplesPerBlock, WORD nChannels);
    
        // Data conversion functions
        static BOOL EncodeM16(LPBYTE pbSrc, LPBYTE pbDst, UINT cBlocks, UINT nBlockAlignment, UINT cSamplesPerBlock, LPINT pnStepIndexL, LPINT pnStepIndexR);
        static BOOL EncodeS16(LPBYTE pbSrc, LPBYTE pbDst, UINT cBlocks, UINT nBlockAlignment, UINT cSamplesPerBlock, LPINT pnStepIndexL, LPINT pnStepIndexR);
        static BOOL DecodeM16(LPBYTE pbSrc, LPBYTE pbDst, UINT cBlocks, UINT nBlockAlignment, UINT cSamplesPerBlock, LPINT pnStepIndexL, LPINT pnStepIndexR);
        static BOOL DecodeS16(LPBYTE pbSrc, LPBYTE pbDst, UINT cBlocks, UINT nBlockAlignment, UINT cSamplesPerBlock, LPINT pnStepIndexL, LPINT pnStepIndexR);

        static int EncodeSample(int nInputSample, int *nPredictedSample, int nStepSize);
        static int DecodeSample(int nInputSample, int nPredictedSample, int nStepSize);

        static int NextStepIndex(int nEncodedSample, int nStepIndex);
        static BOOL ValidStepIndex(int nStepIndex);
    };

    __inline WORD CImaAdpcmCodec::GetSourceAlignment(void)
    {
        return m_fEncoder ? GetDecodeAlignment() : GetEncodeAlignment();
    }

    __inline WORD CImaAdpcmCodec::GetDestinationAlignment(void)
    {
        return m_fEncoder ? GetEncodeAlignment() : GetDecodeAlignment();
    }

    __inline int CImaAdpcmCodec::NextStepIndex(int nEncodedSample, int nStepIndex)
    {
        nStepIndex += m_asNextStep[nEncodedSample];

        if(nStepIndex < 0)
        {
            nStepIndex = 0;
        }
        else if(nStepIndex >= NUMELMS(m_asStep))
        {
            nStepIndex = NUMELMS(m_asStep) - 1;
        }

        return nStepIndex;
    }

    __inline BOOL CImaAdpcmCodec::ValidStepIndex(int nStepIndex)
    {
        return (nStepIndex >= 0) && (nStepIndex < NUMELMS(m_asStep));
    }
}

#endif // __cplusplus

#endif // __IMAADPCM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\common\memmgr.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memmgr.cpp
 *  Content:    Memory manager.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/21/00    dereks  Created.
 *
 ****************************************************************************/

#include "dscommon.h"

// #define MEM_SIZE_CHECK

#ifdef BUILDING_DSOUND

DWORD &CMemoryManager::m_dwPoolMemoryUsage = g_dwDirectSoundPoolMemoryUsage;
DWORD &CMemoryManager::m_dwPhysicalMemoryUsage = g_dwDirectSoundPhysicalMemoryUsage;

#else // BUILDING_DSOUND

DWORD CMemoryManager::m_dwPoolMemoryUsage = 0;
DWORD CMemoryManager::m_dwPhysicalMemoryUsage = 0;

#endif // BUILDING_DSOUND

#ifdef TRACK_MEMORY_USAGE

LIST_ENTRY CMemoryManager::m_lstMemoryTracking = { 0 };

#endif // TRACK_MEMORY_USAGE


/****************************************************************************
 *
 *  PoolAlloc
 *
 *  Description:
 *      Allocates pool memory.
 *
 *  Arguments:
 *      ULONG [in]: buffer size, in bytes.
 *      DWORD [in]: pool tag.
 *      BOOL [in]: TRUE to zero-initialize the buffer data.
 *
 *  Returns:  
 *      LPVOID: allocation.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMemoryManager::PoolAlloc"

LPVOID 
CMemoryManager::PoolAlloc
(
    DSOUND_POOL_TAG         nPoolTag,
    ULONG                   cbBuffer,
    BOOL                    fZeroInit
)
{
    static const ULONG      cbLowerThreshold    = 0x20;
    static const DWORD      cbUpperThreshold    = 0xFD8;
    LPVOID                  pvBuffer;

    ASSERT(cbBuffer);

#ifdef _XBOX

#ifdef MEM_SIZE_CHECK

#pragma TODO("Don't ship with this check turned on")
    
    if((DSOUND_OBJECT_POOL_TAG == nPoolTag) && (cbBuffer >= cbUpperThreshold))
    {
        ASSERTMSG("Allocating an object larger than the pool threshold");
    }
    else if((DSOUND_DATA_POOL_TAG == nPoolTag) && (cbBuffer < cbLowerThreshold))
    {
        ASSERTMSG("Allocating a buffer smaller than 32 bytes");
    }

#endif // _MEM_SIZE_CHECK

    if(pvBuffer = ExAllocatePoolWithTag(cbBuffer, nPoolTag))
    {
        cbBuffer = ExQueryPoolBlockSize(pvBuffer);
        m_dwPoolMemoryUsage += cbBuffer;

        if(fZeroInit)
        {
            ZeroMemory(pvBuffer, cbBuffer);
        }
    }

#else // _XBOX

    if(pvBuffer = LocalAlloc(fZeroInit ? LPTR : LMEM_FIXED, cbBuffer))
    {
        cbBuffer = LocalSize(pvBuffer);
        m_dwPoolMemoryUsage += cbBuffer;
    }

#endif // _XBOX

    else
    {
        DPF_RESOURCE("Out of pool memory");
    }

    return pvBuffer;
}


/****************************************************************************
 *
 *  PoolFree
 *
 *  Description:
 *      Frees memory allocated with PoolAlloc.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMemoryManager::PoolFree"

void 
CMemoryManager::PoolFree
(
    LPVOID                  pvBuffer
)
{
    DWORD                   cbBuffer;

    ASSERT(pvBuffer);

#ifdef _XBOX

    cbBuffer = ExQueryPoolBlockSize(pvBuffer);

    ASSERT(m_dwPoolMemoryUsage >= cbBuffer);
    m_dwPoolMemoryUsage -= cbBuffer;

    ExFreePool(pvBuffer);

#else // _XBOX

    cbBuffer = LocalSize(pvBuffer);

    ASSERT(m_dwPoolMemoryUsage >= cbBuffer);
    m_dwPoolMemoryUsage -= cbBuffer;

    LocalFree(pvBuffer);

#endif // _XBOX

}


/****************************************************************************
 *
 *  PhysicalAlloc
 *
 *  Description:
 *      Allocates physically contiguous memory.
 *
 *  Arguments:
 *      ULONG [in]: buffer size, in bytes.
 *      ULONG [in]: buffer alignment, in bytes.
 *      DWORD [in]: allocation flags.
 *      BOOL [in]: TRUE to zero-initialize the buffer data.
 *
 *  Returns:  
 *      LPVOID: buffer pointer.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMemoryManager::PhysicalAlloc"

LPVOID 
CMemoryManager::PhysicalAlloc
(
    ULONG                   cbBuffer, 
    ULONG                   cbAlignment, 
    DWORD                   dwFlags,
    BOOL                    fZeroInit
)
{
    LPVOID                  pvBuffer;

    ASSERT(cbBuffer);
    ASSERT(dwFlags);
    
#ifdef _XBOX

    if(pvBuffer = MmAllocateContiguousMemoryEx(cbBuffer, 0, 0xFFFFFFFF, cbAlignment, dwFlags))
    {
        cbBuffer = MmQueryAllocationSize(pvBuffer);
        m_dwPhysicalMemoryUsage += cbBuffer;

        if(fZeroInit)
        {
            ZeroMemory(pvBuffer, cbBuffer);
        }
    }

#else // _XBOX

    if(pvBuffer = VirtualAlloc(NULL, cbBuffer, MEM_COMMIT, dwFlags))
    {

#pragma TODO("Not able to query for size of VirtualAlloc'd buffer")

        if(fZeroInit)
        {
            ZeroMemory(pvBuffer, cbBuffer);
        }
    }

#endif // _XBOX

    else
    {
        DPF_RESOURCE("Out of contiguous memory");
    }

    return pvBuffer;
}


/****************************************************************************
 *
 *  PhysicalFree
 *
 *  Description:
 *      Frees memory allocated with PhysicalAlloc.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMemoryManager::PhysicalFree"

void 
CMemoryManager::PhysicalFree
(
    LPVOID                  pvBuffer
)
{
    DWORD                   cbBuffer;

    ASSERT(pvBuffer);

#ifdef _XBOX

    cbBuffer = MmQueryAllocationSize(pvBuffer);

    ASSERT(m_dwPhysicalMemoryUsage >= cbBuffer);
    m_dwPhysicalMemoryUsage -= cbBuffer;

    MmFreeContiguousMemory(pvBuffer);

#else // _XBOX

#pragma TODO("Not able to query for size of VirtualAlloc'd buffer")

    VirtualFree(pvBuffer, 0, MEM_RELEASE);

#endif // _XBOX

}


/****************************************************************************
 *
 *  MemAlloc
 *
 *  Description:
 *      Allocates pool memory.
 *
 *  Arguments:
 *      ULONG [in]: buffer size, in bytes.
 *      DWORD [in]: pool tag.
 *      BOOL [in]: TRUE to zero-initialize the buffer data.
 *
 *  Returns:  
 *      LPVOID: allocation.
 *
 ****************************************************************************/

#ifdef ENABLE_SLOP_MEMORY_RECOVERY

#undef DPF_FNAME
#define DPF_FNAME "CMemoryManager::MemAlloc"

LPVOID 
CMemoryManager::MemAlloc
(
    DSOUND_POOL_TAG         nPoolTag,
    ULONG                   cbBuffer,
    BOOL                    fZeroInit
)
{
    static const ULONG      cbLowerThreshold    = 0x20;
    static const DWORD      cbUpperThreshold    = 0xFD8;
    LPVOID                  pvBuffer;

    ASSERT(cbBuffer);

#ifdef MEM_SIZE_CHECK

#pragma TODO("Don't ship with this check turned on")
    
    if((DSOUND_OBJECT_POOL_TAG == nPoolTag) && (cbBuffer >= cbUpperThreshold))
    {
        ASSERTMSG("Allocating an object larger than the pool threshold");
    }
    else if((DSOUND_DATA_POOL_TAG == nPoolTag) && (cbBuffer < cbLowerThreshold))
    {
        ASSERTMSG("Allocating a buffer smaller than 32 bytes");
    }

#endif // MEM_SIZE_CHECK

    if(CMcpxSlopMemoryHeap::m_pSlopMemoryHeap)
    {
        if(pvBuffer = CMcpxSlopMemoryHeap::m_pSlopMemoryHeap->Alloc(cbBuffer))
        {
            ASSERT(DSOUND_ALLOCATOR_SLOP == *((LPDWORD)pvBuffer - 1));

            if(fZeroInit)
            {
                ZeroMemory(pvBuffer, cbBuffer);
            }
        }
    }
    else
    {
        pvBuffer = NULL;
    }

    if(!pvBuffer)
    {
        if(pvBuffer = PoolAlloc(nPoolTag, cbBuffer + sizeof(DWORD), fZeroInit))
        {
            *(LPDWORD)pvBuffer = DSOUND_ALLOCATOR_POOL;
            pvBuffer = (LPDWORD)pvBuffer + 1;
        }
    }

    return pvBuffer;
}

#endif // ENABLE_SLOP_MEMORY_RECOVERY


/****************************************************************************
 *
 *  MemFree
 *
 *  Description:
 *      Frees memory allocated with MemAlloc.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef ENABLE_SLOP_MEMORY_RECOVERY

#undef DPF_FNAME
#define DPF_FNAME "CMemoryManager::MemFree"

void 
CMemoryManager::MemFree
(
    LPVOID                  pvBuffer
)
{
    LPDWORD                 pdwSignature;
    DWORD                   cbBuffer;

    ASSERT(pvBuffer);

    pdwSignature = (LPDWORD)pvBuffer - 1;
    
    if(DSOUND_ALLOCATOR_POOL == *pdwSignature)
    {
        PoolFree(pdwSignature);
    }
    else if(DSOUND_ALLOCATOR_SLOP == *pdwSignature)
    {
        if(CMcpxSlopMemoryHeap::m_pSlopMemoryHeap)
        {
            CMcpxSlopMemoryHeap::m_pSlopMemoryHeap->Free(pvBuffer);
        }
        else
        {
            ASSERTMSG("Slop memory heap does not exist");
        }
    }
    else
    {
        ASSERTMSG("Invalid memory free");
    }
}

#endif // ENABLE_SLOP_MEMORY_RECOVERY


/****************************************************************************
 *
 *  TrackAlloc
 *
 *  Description:
 *      Completes a memory tracking operation by adding the allocation to
 *      the list and fixing up the base pointer.
 *
 *  Arguments:
 *      LPVOID [in]: allocation base address.
 *      LPCSTR [in]: file the allocation comes from.
 *      ULONG [in]: line number the allocation comes from.
 *      LPCSTR [in]: class being allocated.
 *      DWORD [in]: allocator tag.
 *      ULONG [in]: size of allocation.
 *
 *  Returns:  
 *      LPVOID: allocation base address.
 *
 ****************************************************************************/

#ifdef TRACK_MEMORY_USAGE

#undef DPF_FNAME
#define DPF_FNAME "CMemoryManager::TrackAlloc"

LPVOID
CMemoryManager::TrackAlloc
(
    LPVOID                  pvBaseAddress,
    ULONG                   cbTracking,
    LPCSTR                  pszFile,
    ULONG                   nLine,
    LPCSTR                  pszClass,
    DSOUND_ALLOCATOR_TAG    nAllocatorTag,
    ULONG                   cbSize
)
{
    LPDSMEMTRACK            pTracking;
    
    ASSERT(pvBaseAddress);
    ASSERT(cbTracking >= sizeof(*pTracking));
    ASSERT(cbSize);
    
    //
    // Because of alignment issues, the base address may be incremented more
    // than sizeof(DSMEMTRACK).  For this reason, we store the tracking data
    // directly behind the allocation, but allocate more than cbSize +
    // sizeof(DSMEMTRACK).
    //

    pTracking = (LPDSMEMTRACK)((LPBYTE)pvBaseAddress + cbTracking - sizeof(*pTracking));

    //
    // Create the tracking info
    //

    pTracking->pszFile = pszFile;
    pTracking->nLine = nLine;
    pTracking->pszClass = pszClass;
    pTracking->nAllocatorTag = nAllocatorTag;
    pTracking->cbSize = cbSize;
    pTracking->pvBaseAddress = pvBaseAddress;

#ifdef _XBOX

    //
    // Raise IRQL for synchronization
    //

    AutoIrql();

#endif // _XBOX

    //
    // Add the allocation to the list
    //

    if(!m_lstMemoryTracking.Flink && !m_lstMemoryTracking.Blink)
    {
        InitializeListHead(&m_lstMemoryTracking);
    }
    
    InsertTailListUninit(&m_lstMemoryTracking, &pTracking->leListEntry);

    //
    // Fix up the base address
    //

    return pTracking + 1;
}

#endif // TRACK_MEMORY_USAGE


/****************************************************************************
 *
 *  ForgetAlloc
 *
 *  Description:
 *      Removes a tracked allocation from the list.
 *
 *  Arguments:
 *      LPVOID [in]: allocation base address.
 *      DSOUND_ALLOCATOR_TAG [in]: allocator tag.
 *
 *  Returns:  
 *      LPVOID: allocation base address.
 *
 ****************************************************************************/

#ifdef TRACK_MEMORY_USAGE

#undef DPF_FNAME
#define DPF_FNAME "CMemoryManager::ForgetAlloc"

LPVOID
CMemoryManager::ForgetAlloc
(
    LPVOID                  pvBaseAddress,
    DSOUND_ALLOCATOR_TAG    nAllocatorTag
)
{
    LPDSMEMTRACK            pTracking   = (LPDSMEMTRACK)pvBaseAddress - 1;

    ASSERT(pvBaseAddress);

    //
    // Assert that the tag matches what we expect
    //

    ASSERT(nAllocatorTag == pTracking->nAllocatorTag);
    
#ifdef _XBOX

    //
    // Raise IRQL for synchronization
    //

    AutoIrql();

#endif // _XBOX

    //
    // Remove the allocation from the list
    //

    RemoveEntryList(&pTracking->leListEntry);

    //
    // Return the proper base address
    //

    return pTracking->pvBaseAddress;
}

#endif // TRACK_MEMORY_USAGE


/****************************************************************************
 *
 *  TrackingPoolAlloc
 *
 *  Description:
 *      Allocates pool memory.
 *
 *  Arguments:
 *      LPCSTR [in]: file the allocation comes from.
 *      ULONG [in]: line number the allocation comes from.
 *      LPCSTR [in]: class being allocated.
 *      ULONG [in]: buffer size, in bytes.
 *      DWORD [in]: pool tag.
 *      BOOL [in]: TRUE to zero-initialize the buffer data.
 *
 *  Returns:  
 *      LPVOID: allocation.
 *
 ****************************************************************************/

#ifdef TRACK_MEMORY_USAGE

#undef DPF_FNAME
#define DPF_FNAME "CMemoryManager::TrackingPoolAlloc"

LPVOID 
CMemoryManager::TrackingPoolAlloc
(
    LPCSTR                  pszFile,
    ULONG                   nLine,
    LPCSTR                  pszClass,
    DSOUND_POOL_TAG         nPoolTag,
    ULONG                   cbBuffer,
    BOOL                    fZeroInit
)
{

#ifdef _XBOX

    static const ULONG      cbTracking  = PAGE_SIZE;

#else // _XBOX

    static const ULONG      cbTracking  = sizeof(DSMEMTRACK);

#endif // _XBOX

    LPVOID                  pvBuffer;
    
    //
    // Do the actual allocation
    //
    
    if(pvBuffer = PoolAlloc(nPoolTag, cbBuffer + cbTracking, fZeroInit))
    {
        //
        // Complete the tracking
        //

        pvBuffer = TrackAlloc(pvBuffer, cbTracking, pszFile, nLine, pszClass, DSOUND_ALLOCATOR_POOL, cbBuffer);
    }

    return pvBuffer;
}

#endif // TRACK_MEMORY_USAGE


/****************************************************************************
 *
 *  TrackingPoolFree
 *
 *  Description:
 *      Frees memory allocated with TrackingPoolAlloc.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef TRACK_MEMORY_USAGE

#undef DPF_FNAME
#define DPF_FNAME "CMemoryManager::TrackingPoolFree"

void 
CMemoryManager::TrackingPoolFree
(
    LPVOID                  pvBuffer
)
{
    //
    // Free tracking information
    //

    pvBuffer = ForgetAlloc(pvBuffer, DSOUND_ALLOCATOR_POOL);

    //
    // Free memory
    //

    PoolFree(pvBuffer);
}

#endif // TRACK_MEMORY_USAGE


/****************************************************************************
 *
 *  TrackingPhysicalAlloc
 *
 *  Description:
 *      Allocates physically contiguous memory.
 *
 *  Arguments:
 *      ULONG [in]: buffer size, in bytes.
 *      ULONG [in]: buffer alignment, in bytes.
 *      DWORD [in]: allocation flags.
 *      BOOL [in]: TRUE to zero-initialize the buffer data.
 *
 *  Returns:  
 *      LPVOID: buffer pointer.
 *
 ****************************************************************************/

#ifdef TRACK_MEMORY_USAGE

#undef DPF_FNAME
#define DPF_FNAME "CMemoryManager::TrackingPhysicalAlloc"

LPVOID 
CMemoryManager::TrackingPhysicalAlloc
(
    LPCSTR                  pszFile,
    ULONG                   nLine,
    LPCSTR                  pszClass,
    ULONG                   cbBuffer, 
    ULONG                   cbAlignment, 
    DWORD                   dwFlags,
    BOOL                    fZeroInit
)
{
    ULONG                   cbTracking;
    LPVOID                  pvBuffer;

    //
    // Make sure we allocate enough information for the tracking data
    //

    if(cbAlignment >= sizeof(DSMEMTRACK))
    {
        cbTracking = cbAlignment;
    }
    else
    {
        cbTracking = BLOCKALIGNPAD(sizeof(DSMEMTRACK), cbAlignment);
    }
    
    //
    // Do the actual allocation
    //
    
    if(pvBuffer = PhysicalAlloc(cbBuffer + cbTracking, cbAlignment, dwFlags, fZeroInit))
    {
        //
        // Complete the tracking
        //

        pvBuffer = TrackAlloc(pvBuffer, cbTracking, pszFile, nLine, pszClass, DSOUND_ALLOCATOR_PHYS, cbBuffer);
    }

    return pvBuffer;
}

#endif // TRACK_MEMORY_USAGE


/****************************************************************************
 *
 *  TrackingPhysicalFree
 *
 *  Description:
 *      Frees memory allocated with TrackingPhysicalAlloc.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef TRACK_MEMORY_USAGE

#undef DPF_FNAME
#define DPF_FNAME "CMemoryManager::TrackingPhysicalFree"

void 
CMemoryManager::TrackingPhysicalFree
(
    LPVOID                  pvBuffer
)
{
    //
    // Free tracking information
    //

    pvBuffer = ForgetAlloc(pvBuffer, DSOUND_ALLOCATOR_PHYS);

    //
    // Free memory
    //

    PhysicalFree(pvBuffer);
}

#endif // TRACK_MEMORY_USAGE


/****************************************************************************
 *
 *  TrackingMemAlloc
 *
 *  Description:
 *      Allocates pool memory.
 *
 *  Arguments:
 *      ULONG [in]: buffer size, in bytes.
 *      DWORD [in]: pool tag.
 *      BOOL [in]: TRUE to zero-initialize the buffer data.
 *
 *  Returns:  
 *      LPVOID: allocation.
 *
 ****************************************************************************/

#if defined(TRACK_MEMORY_USAGE) && defined(ENABLE_SLOP_MEMORY_RECOVERY)

#undef DPF_FNAME
#define DPF_FNAME "CMemoryManager::TrackingMemAlloc"

LPVOID 
CMemoryManager::TrackingMemAlloc
(
    LPCSTR                  pszFile,
    ULONG                   nLine,
    LPCSTR                  pszClass,
    DSOUND_POOL_TAG         nPoolTag,
    ULONG                   cbBuffer,
    BOOL                    fZeroInit
)
{
    static const ULONG      cbTracking  = sizeof(DSMEMTRACK);
    LPVOID                  pvBuffer;
    
    //
    // Do the actual allocation
    //
    
    if(pvBuffer = MemAlloc(nPoolTag, cbBuffer + cbTracking, fZeroInit))
    {
        //
        // Complete the tracking
        //

        pvBuffer = TrackAlloc(pvBuffer, cbTracking, pszFile, nLine, pszClass, DSOUND_ALLOCATOR_SLOP, cbBuffer);
    }

    return pvBuffer;
}

#endif // defined(TRACK_MEMORY_USAGE) && defined(ENABLE_SLOP_MEMORY_RECOVERY)


/****************************************************************************
 *
 *  TrackingMemFree
 *
 *  Description:
 *      Frees memory allocated with TrackingMemAlloc.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#if defined(TRACK_MEMORY_USAGE) && defined(ENABLE_SLOP_MEMORY_RECOVERY)

#undef DPF_FNAME
#define DPF_FNAME "CMemoryManager::TrackingMemFree"

void 
CMemoryManager::TrackingMemFree
(
    LPVOID                  pvBuffer
)
{
    //
    // Free tracking information
    //

    pvBuffer = ForgetAlloc(pvBuffer, DSOUND_ALLOCATOR_SLOP);

    //
    // Free memory
    //

    MemFree(pvBuffer);
}

#endif // defined(TRACK_MEMORY_USAGE) && defined(ENABLE_SLOP_MEMORY_RECOVERY)


/****************************************************************************
 *
 *  DumpMemoryUsage
 *
 *  Description:
 *      Dumps current memory usage to the debugger.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to assert that there is no memory allocated.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMemoryManager::DumpMemoryUsage"

void
CMemoryManager::DumpMemoryUsage
(
    BOOL                    fAssertNone
)
{

#ifdef DEBUG

    static const LPCSTR     pszBanner           = "------------------------------------------------------------------------------";

#ifdef TRACK_MEMORY_USAGE

    PLIST_ENTRY             pleEntry;
    LPDSMEMTRACK            pTracking;

#endif // TRACK_MEMORY_USAGE

    CDebug::SetContext(DPF_FLAGS_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);
    CDebug::Print(pszBanner);
    CDebug::Print("Begin memory usage dump");
    CDebug::Print(pszBanner);
    
#ifdef TRACK_MEMORY_USAGE

#ifdef _XBOX

    //
    // Raise IRQL for synchronization
    //

    AutoIrql();

#endif // _XBOX
   
    //
    // Show specifically what allocations are remaining
    //
    
    if(m_lstMemoryTracking.Flink)
    {
        if(!IsListEmpty(&m_lstMemoryTracking))
        {
            for(pleEntry = m_lstMemoryTracking.Flink; pleEntry != &m_lstMemoryTracking; pleEntry = pleEntry->Flink)
            {
                AssertValidEntryList(pleEntry, ASSERT_IN_LIST);
            
                pTracking = CONTAINING_RECORD(pleEntry, DSMEMTRACK, leListEntry);

                CDebug::SetContext(DPF_FLAGS_FILELINE, DPFLVL_ABSOLUTE, pTracking->pszFile, pTracking->nLine, DPF_FNAME, DPF_LIBRARY);
                CDebug::Print("%x (%lu bytes, type %s)", pTracking + 1, pTracking->cbSize, pTracking->pszClass);
            }

            CDebug::SetContext(DPF_FLAGS_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);
            CDebug::Print(pszBanner);
        }
    }

#endif // TRACK_MEMORY_USAGE

    CDebug::SetContext(DPF_FLAGS_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);
    CDebug::Print("Pool memory used:  %lu", m_dwPoolMemoryUsage);
    CDebug::Print("Physical memory used:  %lu", m_dwPhysicalMemoryUsage);

#ifdef ENABLE_SLOP_MEMORY_RECOVERY

    CDebug::Print("Physical memory available for recovery:  %lu", CMcpxSlopMemoryHeap::m_dwAvailable);
    CDebug::Print("Physical memory recovered:  %lu", CMcpxSlopMemoryHeap::m_dwUsed);

#endif // ENABLE_SLOP_MEMORY_RECOVERY

    CDebug::Print(pszBanner);
    CDebug::Print("End memory usage dump");
    CDebug::Print(pszBanner);

#ifdef ENABLE_SLOP_MEMORY_RECOVERY

    if(m_dwPoolMemoryUsage || m_dwPhysicalMemoryUsage || CMcpxSlopMemoryHeap::m_dwAvailable || CMcpxSlopMemoryHeap::m_dwUsed)

#else // ENABLE_SLOP_MEMORY_RECOVERY

    if(m_dwPoolMemoryUsage || m_dwPhysicalMemoryUsage)

#endif // ENABLE_SLOP_MEMORY_RECOVERY

    {
        if(fAssertNone)
        {
            __asm int 3
        }

#ifdef TRACK_MEMORY_USAGE

        ASSERT(!IsListEmpty(&m_lstMemoryTracking));

#endif // TRACK_MEMORY_USAGE

    }

#ifdef TRACK_MEMORY_USAGE

    else
    {
        ASSERT(IsListEmpty(&m_lstMemoryTracking));
    }

#endif // TRACK_MEMORY_USAGE

#endif // DEBUG

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\common\format.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       format.h
 *  Content:    Wave format helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/10/00    dereks  Created.
 *
 ****************************************************************************/

#ifndef __FORMAT_H__
#define __FORMAT_H__

#ifdef __cplusplus

#include "macros.h"

//
// Xbox ADPCM definitions
//

#ifndef _XBOX

#define WAVE_FORMAT_XBOX_ADPCM 0x0069

DEFINETYPE(XBOXADPCMWAVEFORMAT, IMAADPCMWAVEFORMAT);

#endif // _XBOX

#define XBOX_ADPCM_SAMPLES_PER_BLOCK    64  // 64 samples per block
#define XBOX_ADPCM_BITS_PER_SAMPLE      4   // 4 bits per sample
#define XBOX_ADPCM_ENCODED_BLOCK_SIZE   36  // 64 mono PCM samples == 36 encoded bytes (72 for stereo)

//
// Format initialization macros
//

#define INIT_PCM_WAVEFORMAT_EX(channels, frequency, samplebits, containerbits) \
    { \
        WAVE_FORMAT_PCM, \
        (WORD)(channels), \
        (DWORD)(frequency), \
        (DWORD)(frequency) * (DWORD)(channels) * (DWORD)(containerbits) / 8, \
        (WORD)(channels) * (WORD)(containerbits) / 8, \
        (WORD)(samplebits), \
        0 \
    }

#define INIT_PCM_WAVEFORMAT(channels, frequency, samplebits) \
    INIT_PCM_WAVEFORMAT_EX(channels, frequency, samplebits, samplebits)

#define INIT_XBOX_ADPCM_WAVEFORMAT(channels, frequency) \
    { \
        { \
            WAVE_FORMAT_XBOX_ADPCM, \
            (WORD)(channels), \
            (DWORD)(frequency), \
            (DWORD)(frequency) / XBOX_ADPCM_SAMPLES_PER_BLOCK * XBOX_ADPCM_ENCODED_BLOCK_SIZE, \
            (WORD)(channels) * XBOX_ADPCM_ENCODED_BLOCK_SIZE, \
            XBOX_ADPCM_BITS_PER_SAMPLE, \
            2 \
        }, \
        XBOX_ADPCM_SAMPLES_PER_BLOCK \
    }

#ifdef _XBOX

#define INIT_PCM_WAVEFORMATEXTENSIBLE(channels, frequency, samplebits, containerbits, channelmask) \
    { \
        { \
            WAVE_FORMAT_EXTENSIBLE, \
            (WORD)(channels), \
            (DWORD)(frequency), \
            (DWORD)(frequency) * (DWORD)(channels) * (DWORD)(containerbits) / 8, \
            (WORD)(channels) * (WORD)(containerbits) / 8, \
            (WORD)(samplebits), \
            0 \
        }, \
        (WORD)(containerbits), \
        (DWORD)(channelmask), \
        KSDATAFORMAT_SUBTYPE_PCM \
    }
        
#define INIT_XBOX_ADPCM_WAVEFORMATEXTENSIBLE(channels, frequency, channelmask) \
    { \
        { \
            WAVE_FORMAT_EXTENSIBLE, \
            (WORD)(channels), \
            (DWORD)(frequency), \
            (DWORD)(frequency) / XBOX_ADPCM_SAMPLES_PER_BLOCK * XBOX_ADPCM_ENCODED_BLOCK_SIZE, \
            (WORD)(channels) * XBOX_ADPCM_ENCODED_BLOCK_SIZE, \
            XBOX_ADPCM_BITS_PER_SAMPLE, \
            2 \
        }, \
        XBOX_ADPCM_SAMPLES_PER_BLOCK \
        (DWORD)(channelmask), \
        KSDATAFORMAT_SUBTYPE_XBOX_ADPCM \
    }

#endif // _XBOX

//
// DirectSound internal format structure
//

BEGIN_DEFINE_STRUCT()
    WORD    wFormatTag;             // Format tag
    BYTE    nChannels;              // Channel count
    BYTE    wBitsPerSample;         // Count of bits per mono sample
    DWORD   nSamplesPerSec;         // Sampling rate
    DWORD   nBlockAlign;            // Block size of data (32-bit for alignment only)
END_DEFINE_STRUCT(DSWAVEFORMAT);

//
// Wave format helper functions
//

namespace DirectSound
{
    namespace WaveFormat
    {
        void CreatePcmFormat(WORD nChannels, DWORD nSamplesPerSec, WORD wBitsPerSample, LPWAVEFORMATEX pwfx);
        void CreateXboxAdpcmFormat(WORD nChannels, DWORD nSamplesPerSec, LPXBOXADPCMWAVEFORMAT pwfx);
        DWORD CreateInternalFormat(LPDSWAVEFORMAT pDest, LPCWAVEFORMATEX pSource);
        BOOL IsValidFormat(LPCWAVEFORMATEX pwfx);
        void PcmToInternalFormat(LPDSWAVEFORMAT pDest, LPCWAVEFORMATEX pSource);
        BOOL IsValidPcmFormat(LPCWAVEFORMATEX pwfx);
        void AdpcmToInternalFormat(LPDSWAVEFORMAT pDest, LPCXBOXADPCMWAVEFORMAT pSource);
        BOOL IsValidAdpcmFormat(LPCXBOXADPCMWAVEFORMAT pwfx);

#if defined(_XBOX) && !defined(MCPX_BOOT_LIB)

        DWORD ExtensibleToInternalFormat(LPDSWAVEFORMAT pDest, LPCWAVEFORMATEXTENSIBLE pSource);
        BOOL IsValidExtensibleFormat(LPCWAVEFORMATEXTENSIBLE pwfx);

#endif // defined(_XBOX) && !defined(MCPX_BOOT_LIB)
    
    };
}

#ifndef _XBOX

#define XAudioCreatePcmFormat DirectSound::WaveFormat::CreatePcmFormat
#define XAudioCreateAdpcmFormat DirectSound::WaveFormat::CreateXboxAdpcmFormat

#endif // _XBOX

using namespace DirectSound::WaveFormat;

#endif // __cplusplus

#endif // __FORMAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\common\imaadpcm.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       imaadpcm.cpp
 *  Content:    IMA ADPCM CODEC.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/29/01    dereks  Created.
 *
 ****************************************************************************/

#include "dscommon.h"


/****************************************************************************
 *
 *  CImaAdpcmCodec
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

//
// This array is used by NextStepIndex to determine the next step index to use.  
// The step index is an index to the m_asStep[] array, below.
//

const short CImaAdpcmCodec::m_asNextStep[16] =
{
    -1, -1, -1, -1, 2, 4, 6, 8,
    -1, -1, -1, -1, 2, 4, 6, 8
};

//
// This array contains the array of step sizes used to encode the ADPCM
// samples.  The step index in each ADPCM block is an index to this array.
//

const short CImaAdpcmCodec::m_asStep[89] =
{
        7,     8,     9,    10,    11,    12,    13,
       14,    16,    17,    19,    21,    23,    25,
       28,    31,    34,    37,    41,    45,    50,
       55,    60,    66,    73,    80,    88,    97,
      107,   118,   130,   143,   157,   173,   190,
      209,   230,   253,   279,   307,   337,   371,
      408,   449,   494,   544,   598,   658,   724,
      796,   876,   963,  1060,  1166,  1282,  1411,
     1552,  1707,  1878,  2066,  2272,  2499,  2749,
     3024,  3327,  3660,  4026,  4428,  4871,  5358,
     5894,  6484,  7132,  7845,  8630,  9493, 10442,
    11487, 12635, 13899, 15289, 16818, 18500, 20350,
    22385, 24623, 27086, 29794, 32767
};

CImaAdpcmCodec::CImaAdpcmCodec
(
    void
)
{
}


/****************************************************************************
 *
 *  ~CImaAdpcmCodec
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

CImaAdpcmCodec::~CImaAdpcmCodec
(
    void
)
{
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPCIMAADPCMWAVEFORMAT [in]: encoded data format.
 *      BOOL [in]: TRUE to initialize the object as an encoder.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

BOOL
CImaAdpcmCodec::Initialize
(
    LPCIMAADPCMWAVEFORMAT               pwfxEncode, 
    BOOL                                fEncoder
)
{
    static const LPFNIMAADPCMCONVERT    apfnConvert[2][2] = 
    { 
        {
            DecodeM16,
            DecodeS16 
        },
        {
            EncodeM16,
            EncodeS16 
        }
    };
    
    if(!IsValidImaAdpcmFormat(pwfxEncode))
    {
        return FALSE;
    }

    //
    // Save the format data
    //

    m_wfxEncode = *pwfxEncode;
    m_fEncoder = !!fEncoder;

    //
    // Set up the conversion function
    //

    m_pfnConvert = apfnConvert[m_fEncoder][m_wfxEncode.wfx.nChannels - 1];

    //
    // Initialize the stepping indeces
    //

    m_nStepIndexL = m_nStepIndexR = 0;

    return TRUE;
}


/****************************************************************************
 *
 *  Convert
 *
 *  Description:
 *      Converts data from the source to destination format.
 *
 *  Arguments:
 *      LPCVOID [in]: source buffer.
 *      LPVOID [out]: destination buffer.
 *      UINT [in]: block count.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

BOOL
CImaAdpcmCodec::Convert
(
    LPCVOID                 pvSrc,
    LPVOID                  pvDst,
    UINT                    cBlocks
)
{
    return m_pfnConvert((LPBYTE)pvSrc, (LPBYTE)pvDst, cBlocks, m_wfxEncode.wfx.nBlockAlign, m_wfxEncode.wSamplesPerBlock, &m_nStepIndexL, &m_nStepIndexR);
}


/****************************************************************************
 *
 *  Reset
 *
 *  Description:
 *      Resets the conversion operation.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void
CImaAdpcmCodec::Reset
(
    void
)
{
    //
    // Reset the stepping indeces
    //

    m_nStepIndexL = m_nStepIndexR = 0;
}


/****************************************************************************
 *
 *  GetEncodeAlignment
 *
 *  Description:
 *      Gets the alignment of an encoded buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      WORD: alignment, in bytes.
 *
 ****************************************************************************/

WORD
CImaAdpcmCodec::GetEncodeAlignment
(
    void
)
{
    return m_wfxEncode.wfx.nBlockAlign;
}


/****************************************************************************
 *
 *  GetDecodeAlignment
 *
 *  Description:
 *      Gets the alignment of a decoded buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: alignment, in bytes.
 *
 ****************************************************************************/

WORD
CImaAdpcmCodec::GetDecodeAlignment
(
    void
)
{
    return m_wfxEncode.wSamplesPerBlock * m_wfxEncode.wfx.nChannels * IMAADPCM_PCM_BITS_PER_SAMPLE / 8;
}


/****************************************************************************
 *
 *  CalculateEncodeAlignment
 *
 *  Description:
 *      Calculates an encoded data block alignment based on a PCM sample
 *      count and an alignment multiplier.
 *
 *  Arguments:
 *      WORD [in]: channel count.
 *      WORD [in]: PCM samples per block.
 *
 *  Returns:  
 *      WORD: alignment, in bytes.
 *
 ****************************************************************************/

WORD
CImaAdpcmCodec::CalculateEncodeAlignment
(
    WORD                    nChannels,
    WORD                    nSamplesPerBlock
)
{
    const WORD              nEncodedSampleBits  = nChannels * IMAADPCM_BITS_PER_SAMPLE;
    const WORD              nHeaderBytes        = nChannels * IMAADPCM_HEADER_LENGTH;
    WORD                    nBlockAlign;

    //
    // Calculate the raw block alignment that nSamplesPerBlock dictates.  This
    // value may include a partial encoded sample, so be sure to round up.
    //
    // Start with the samples-per-block, minus 1.  The first sample is actually
    // stored in the header.
    //

    nBlockAlign = nSamplesPerBlock - 1;

    //
    // Convert to encoded sample size
    //

    nBlockAlign *= nEncodedSampleBits;
    nBlockAlign += 7;
    nBlockAlign /= 8;

    //
    // The stereo encoder requires that there be at least two DWORDs to process
    //

    nBlockAlign += 7;
    nBlockAlign /= 8;
    nBlockAlign *= 8;

    //
    // Add the header
    //

    nBlockAlign += nHeaderBytes;

    return nBlockAlign;
}


/****************************************************************************
 *
 *  CreatePcmFormat
 *
 *  Description:
 *      Creates a PCM format descriptor.
 *
 *  Arguments:
 *      WORD [in]: channel count.
 *      DWORD [in]: sampling rate.
 *      LPWAVEFORMATEX [out]: format descriptor.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void
CImaAdpcmCodec::CreatePcmFormat
(
    WORD                    nChannels, 
    DWORD                   nSamplesPerSec, 
    LPWAVEFORMATEX          pwfx
)
{
    pwfx->wFormatTag = WAVE_FORMAT_PCM;
    pwfx->nChannels = nChannels;
    pwfx->nSamplesPerSec = nSamplesPerSec;
    pwfx->nBlockAlign = nChannels * IMAADPCM_PCM_BITS_PER_SAMPLE / 8;
    pwfx->nAvgBytesPerSec = pwfx->nBlockAlign * pwfx->nSamplesPerSec;
    pwfx->wBitsPerSample = IMAADPCM_PCM_BITS_PER_SAMPLE;
}


/****************************************************************************
 *
 *  CreateImaAdpcmFormat
 *
 *  Description:
 *      Creates an IMA ADPCM format descriptor.
 *
 *  Arguments:
 *      WORD [in]: channel count.
 *      DWORD [in]: sampling rate.
 *      LPIMAADPCMWAVEFORMAT [out]: format descriptor.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void
CImaAdpcmCodec::CreateImaAdpcmFormat
(
    WORD                    nChannels, 
    DWORD                   nSamplesPerSec, 
    WORD                    nSamplesPerBlock,
    LPIMAADPCMWAVEFORMAT    pwfx
)
{
    pwfx->wfx.wFormatTag = WAVE_FORMAT_XBOX_ADPCM;
    pwfx->wfx.nChannels = nChannels;
    pwfx->wfx.nSamplesPerSec = nSamplesPerSec;
    pwfx->wfx.nBlockAlign = CalculateEncodeAlignment(nChannels, nSamplesPerBlock);
    pwfx->wfx.nAvgBytesPerSec = nSamplesPerSec * pwfx->wfx.nBlockAlign / nSamplesPerBlock;
    pwfx->wfx.wBitsPerSample = IMAADPCM_BITS_PER_SAMPLE;
    pwfx->wfx.cbSize = sizeof(*pwfx) - sizeof(pwfx->wfx);
    pwfx->wSamplesPerBlock = nSamplesPerBlock;
}


/****************************************************************************
 *
 *  IsValidPcmFormat
 *
 *  Description:
 *      Validates a format structure.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

BOOL 
CImaAdpcmCodec::IsValidPcmFormat
(
    LPCWAVEFORMATEX         pwfx
)
{
    if(WAVE_FORMAT_PCM != pwfx->wFormatTag)
    {
        return FALSE;
    }
    
    if((pwfx->nChannels < 1) || (pwfx->nChannels > IMAADPCM_MAX_CHANNELS))
    {
        return FALSE;
    }

    if(IMAADPCM_PCM_BITS_PER_SAMPLE != pwfx->wBitsPerSample)
    {
        return FALSE;
    }

    if(pwfx->nChannels * pwfx->wBitsPerSample / 8 != pwfx->nBlockAlign)
    {
        return FALSE;
    }

    if(pwfx->nBlockAlign * pwfx->nSamplesPerSec != pwfx->nAvgBytesPerSec)
    {
        return FALSE;
    }

    return TRUE;
}


/****************************************************************************
 *
 *  IsValidXboxAdpcmFormat
 *
 *  Description:
 *      Validates a format structure.
 *
 *  Arguments:
 *      LPCIMAADPCMWAVEFORMAT [in]: format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

BOOL 
CImaAdpcmCodec::IsValidImaAdpcmFormat
(
    LPCIMAADPCMWAVEFORMAT   pwfx
)
{
    if(WAVE_FORMAT_XBOX_ADPCM != pwfx->wfx.wFormatTag)
    {
        return FALSE;
    }

    if(sizeof(*pwfx) - sizeof(pwfx->wfx) != pwfx->wfx.cbSize)
    {
        return FALSE;
    }
    
    if((pwfx->wfx.nChannels < 1) || (pwfx->wfx.nChannels > IMAADPCM_MAX_CHANNELS))
    {
        return FALSE;
    }

    if(IMAADPCM_BITS_PER_SAMPLE != pwfx->wfx.wBitsPerSample)
    {
        return FALSE;
    }

    if(CalculateEncodeAlignment(pwfx->wfx.nChannels, pwfx->wSamplesPerBlock) != pwfx->wfx.nBlockAlign)
    {
        return FALSE;
    }

    return TRUE;
}


/****************************************************************************
 *
 *  EncodeSample
 *
 *  Description:
 *      Encodes a sample.
 *
 *  Arguments:
 *      int [in]: the sample to be encoded.
 *      LPINT [in/out]: the predicted value of the sample.
 *      int [in]: the quantization step size used to encode the sample.
 *
 *  Returns:  
 *      int: the encoded ADPCM sample.
 *
 ****************************************************************************/

int
CImaAdpcmCodec::EncodeSample
(
    int                 nInputSample,
    LPINT               pnPredictedSample,
    int                 nStepSize
)
{
    int                 nPredictedSample;
    LONG                lDifference;
    int                 nEncodedSample;
    
    nPredictedSample = *pnPredictedSample;

    lDifference = nInputSample - nPredictedSample;
    nEncodedSample = 0;

    if(lDifference < 0) 
    {
        nEncodedSample = 8;
        lDifference = -lDifference;
    }

    if(lDifference >= nStepSize)
    {
        nEncodedSample |= 4;
        lDifference -= nStepSize;
    }

    nStepSize >>= 1;

    if(lDifference >= nStepSize)
    {
        nEncodedSample |= 2;
        lDifference -= nStepSize;
    }

    nStepSize >>= 1;

    if(lDifference >= nStepSize)
    {
        nEncodedSample |= 1;
        lDifference -= nStepSize;
    }

    if(nEncodedSample & 8)
    {
        nPredictedSample = nInputSample + lDifference - (nStepSize >> 1);
    }
    else
    {
        nPredictedSample = nInputSample - lDifference + (nStepSize >> 1);
    }

    if(nPredictedSample > 32767)
    {
        nPredictedSample = 32767;
    }
    else if(nPredictedSample < -32768)
    {
        nPredictedSample = -32768;
    }

    *pnPredictedSample = nPredictedSample;
    
    return nEncodedSample;
}


/****************************************************************************
 *
 *  DecodeSample
 *
 *  Description:
 *      Decodes an encoded sample.
 *
 *  Arguments:
 *      int [in]: the sample to be decoded.
 *      int [in]: the predicted value of the sample.
 *      int [i]: the quantization step size used to encode the sample.
 *
 *  Returns:  
 *      int: the decoded PCM sample.
 *
 ****************************************************************************/

int
CImaAdpcmCodec::DecodeSample
(
    int                 nEncodedSample,
    int                 nPredictedSample,
    int                 nStepSize
)
{
    LONG                lDifference;
    LONG                lNewSample;

    lDifference = nStepSize >> 3;

    if(nEncodedSample & 4) 
    {
        lDifference += nStepSize;
    }

    if(nEncodedSample & 2) 
    {
        lDifference += nStepSize >> 1;
    }

    if(nEncodedSample & 1) 
    {
        lDifference += nStepSize >> 2;
    }

    if(nEncodedSample & 8)
    {
        lDifference = -lDifference;
    }

    lNewSample = nPredictedSample + lDifference;

    if((LONG)(short)lNewSample != lNewSample)
    {
        if(lNewSample < -32768)
        {
            lNewSample = -32768;
        }
        else
        {
            lNewSample = 32767;
        }
    }

    return (int)lNewSample;
}


/****************************************************************************
 *
 *  Conversion Routines
 *
 *  Description:
 *      Converts a PCM buffer to ADPCM, or the reverse.
 *
 *  Arguments:
 *      LPBYTE [in]: source buffer.
 *      LPBYTE [out]: destination buffer.
 *      UINT [in]: block count.
 *      UINT [in]: block alignment of the ADPCM data, in bytes.
 *      UINT [in]: the number of samples in each ADPCM block (not used in
 *                 decoding).
 *      LPINT [in/out]: left-channel stepping index.
 *      LPINT [in/out]: right-channel stepping index.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

BOOL
CImaAdpcmCodec::EncodeM16
(
    LPBYTE                  pbSrc,
    LPBYTE                  pbDst,
    UINT                    cBlocks,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    LPINT                   pnStepIndexL,
    LPINT                   pnStepIndexR
)
{
    LPBYTE                  pbBlock;
    UINT                    cSamples;
    int                     nSample;
    int                     nStepSize;
    int                     nEncSample1;
    int                     nEncSample2;
    int                     nPredSample;
    int                     nStepIndex;

    //
    // Save a local copy of the step index so we're not constantly 
    // dereferencing a pointer.
    //
    
    nStepIndex = *pnStepIndexL;

    //
    // Enter the main loop
    //
    
    while(cBlocks--)
    {
        pbBlock = pbDst;
        cSamples = cSamplesPerBlock - 1;

        //
        // Block header
        //

        nPredSample = *(short *)pbSrc;
        pbSrc += sizeof(short);

        *(LONG *)pbBlock = MAKELONG(nPredSample, nStepIndex);
        pbBlock += sizeof(LONG);

        //
        // We have written the header for this block--now write the data
        // chunk (which consists of a bunch of encoded nibbles).  Note
        // that if we don't have enough data to fill a complete byte, then
        // we add a 0 nibble on the end.
        //

        while(cSamples)
        {
            //
            // Sample 1
            //

            nSample = *(short *)pbSrc;
            pbSrc += sizeof(short);
            cSamples--;

            nStepSize = m_asStep[nStepIndex];
            nEncSample1 = EncodeSample(nSample, &nPredSample, nStepSize);
            nStepIndex = NextStepIndex(nEncSample1, nStepIndex);

            //
            // Sample 2
            //

            if(cSamples)
            {
                nSample = *(short *)pbSrc;
                pbSrc += sizeof(short);
                cSamples--;

                nStepSize = m_asStep[nStepIndex];
                nEncSample2 = EncodeSample(nSample, &nPredSample, nStepSize);
                nStepIndex = NextStepIndex(nEncSample2, nStepIndex);
            }
            else
            {
                nEncSample2 = 0;
            }

            //
            // Write out encoded byte.
            //

            *pbBlock++ = (BYTE)(nEncSample1 | (nEncSample2 << 4));
        }

        //
        // Skip padding
        //

        pbDst += nBlockAlignment;
    }

    //
    // Restore the value of the step index to be used on the next buffer.
    //

    *pnStepIndexL = nStepIndex;

    return TRUE;
}


BOOL
CImaAdpcmCodec::EncodeS16
(
    LPBYTE                  pbSrc,
    LPBYTE                  pbDst,
    UINT                    cBlocks,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    LPINT                   pnStepIndexL,
    LPINT                   pnStepIndexR
)
{
    LPBYTE                  pbBlock;
    UINT                    cSamples;
    UINT                    cSubSamples;
    int                     nSample;
    int                     nStepSize;
    DWORD                   dwLeft;
    DWORD                   dwRight;
    int                     nEncSampleL;
    int                     nPredSampleL;
    int                     nStepIndexL;
    int                     nEncSampleR;
    int                     nPredSampleR;
    int                     nStepIndexR;
    UINT                    i;

    //
    // Save a local copy of the step indeces so we're not constantly 
    // dereferencing a pointer.
    //
    
    nStepIndexL = *pnStepIndexL;
    nStepIndexR = *pnStepIndexR;

    //
    // Enter the main loop
    //
    
    while(cBlocks--)
    {
        pbBlock = pbDst;
        cSamples = cSamplesPerBlock - 1;

        //
        // LEFT channel block header
        //

        nPredSampleL = *(short *)pbSrc;
        pbSrc += sizeof(short);

        *(LONG *)pbBlock = MAKELONG(nPredSampleL, nStepIndexL);
        pbBlock += sizeof(LONG);

        //
        // RIGHT channel block header
        //

        nPredSampleR = *(short *)pbSrc;
        pbSrc += sizeof(short);

        *(LONG *)pbBlock = MAKELONG(nPredSampleR, nStepIndexR);
        pbBlock += sizeof(LONG);

        //
        // We have written the header for this block--now write the data
        // chunk.  This consists of 8 left samples (one DWORD of output)
        // followed by 8 right samples (also one DWORD).  Since the input
        // samples are interleaved, we create the left and right DWORDs
        // sample by sample, and then write them both out.
        //

        while(cSamples)
        {
            dwLeft = 0;
            dwRight = 0;

            cSubSamples = min(cSamples, 8);

            for(i = 0; i < cSubSamples; i++)
            {
                //
                // LEFT channel
                //

                nSample = *(short *)pbSrc;
                pbSrc += sizeof(short);

                nStepSize = m_asStep[nStepIndexL];
                
                nEncSampleL = EncodeSample(nSample, &nPredSampleL, nStepSize);

                nStepIndexL = NextStepIndex(nEncSampleL, nStepIndexL);
                dwLeft |= (DWORD)nEncSampleL << (4 * i);

                //
                // RIGHT channel
                //

                nSample = *(short *)pbSrc;
                pbSrc += sizeof(short);

                nStepSize = m_asStep[nStepIndexR];
                
                nEncSampleR = EncodeSample(nSample, &nPredSampleR, nStepSize);

                nStepIndexR = NextStepIndex(nEncSampleR, nStepIndexR);
                dwRight |= (DWORD)nEncSampleR << (4 * i);
            }

            //
            // Write out encoded DWORDs.
            //

            *(LPDWORD)pbBlock = dwLeft;
            pbBlock += sizeof(DWORD);

            *(LPDWORD)pbBlock = dwRight;
            pbBlock += sizeof(DWORD);

            cSamples -= cSubSamples;
        }

        //
        // Skip padding
        //

        pbDst += nBlockAlignment;
    }

    //
    // Restore the value of the step index to be used on the next buffer.
    //
    
    *pnStepIndexL = nStepIndexL;
    *pnStepIndexR = nStepIndexR;

    return TRUE;

}


BOOL
CImaAdpcmCodec::DecodeM16   
(
    LPBYTE                  pbSrc,
    LPBYTE                  pbDst,
    UINT                    cBlocks,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    LPINT                   pnStepIndexL,
    LPINT                   pnStepIndexR
)
{
    BOOL                    fSuccess    = TRUE;
    LPBYTE                  pbBlock;
    UINT                    cSamples;
    BYTE                    bSample;
    int                     nStepSize;
    int                     nEncSample;
    int                     nPredSample;
    int                     nStepIndex;
    DWORD                   dwHeader;

    //
    // Enter the main loop
    //
    
    while(cBlocks--)
    {
        pbBlock = pbSrc;
        cSamples = cSamplesPerBlock - 1;
        
        //
        // Block header
        //

        dwHeader = *(LPDWORD)pbBlock;
        pbBlock += sizeof(DWORD);

        nPredSample = (int)(short)LOWORD(dwHeader);
        nStepIndex = (int)(BYTE)HIWORD(dwHeader);

        if(!ValidStepIndex(nStepIndex))
        {
            //
            // The step index is out of range - this is considered a fatal
            // error as the input stream is corrupted.  We fail by returning
            // zero bytes converted.
            //

            fSuccess = FALSE;
            break;
        }
        
        //
        // Write out first sample
        //

        *(short *)pbDst = (short)nPredSample;
        pbDst += sizeof(short);

        //
        // Enter the block loop
        //

        while(cSamples)
        {
            bSample = *pbBlock++;

            //
            // Sample 1
            //

            nEncSample = (bSample & (BYTE)0x0F);
            nStepSize = m_asStep[nStepIndex];
            nPredSample = DecodeSample(nEncSample, nPredSample, nStepSize);
            nStepIndex = NextStepIndex(nEncSample, nStepIndex);

            *(short *)pbDst = (short)nPredSample;
            pbDst += sizeof(short);

            cSamples--;

            //
            // Sample 2
            //

            if(cSamples)
            {
                nEncSample = (bSample >> 4);
                nStepSize = m_asStep[nStepIndex];
                nPredSample = DecodeSample(nEncSample, nPredSample, nStepSize);
                nStepIndex = NextStepIndex(nEncSample, nStepIndex);

                *(short *)pbDst = (short)nPredSample;
                pbDst += sizeof(short);

                cSamples--;
            }
        }

        //
        // Skip padding
        //

        pbSrc += nBlockAlignment;
    }

    return fSuccess;
}


BOOL
CImaAdpcmCodec::DecodeS16
(
    LPBYTE                  pbSrc,
    LPBYTE                  pbDst,
    UINT                    cBlocks,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    LPINT                   pnStepIndexL,
    LPINT                   pnStepIndexR
)
{
    BOOL                    fSuccess    = TRUE;
    LPBYTE                  pbBlock;
    UINT                    cSamples;
    UINT                    cSubSamples;
    int                     nStepSize;
    DWORD                   dwHeader;
    DWORD                   dwLeft;
    DWORD                   dwRight;
    int                     nEncSampleL;
    int                     nPredSampleL;
    int                     nStepIndexL;
    int                     nEncSampleR;
    int                     nPredSampleR;
    int                     nStepIndexR;
    UINT                    i;

    //
    // Enter the main loop
    //
    
    while(cBlocks--)
    {
        pbBlock = pbSrc;
        cSamples = cSamplesPerBlock - 1;

        //
        // LEFT channel header
        //

        dwHeader = *(LPDWORD)pbBlock;
        pbBlock += sizeof(DWORD);
        
        nPredSampleL = (int)(short)LOWORD(dwHeader);
        nStepIndexL = (int)(BYTE)HIWORD(dwHeader);

        if(!ValidStepIndex(nStepIndexL)) 
        {
            //
            // The step index is out of range - this is considered a fatal
            // error as the input stream is corrupted.  We fail by returning
            // zero bytes converted.
            //

            fSuccess = FALSE;
            break;
        }
        
        //
        // RIGHT channel header
        //

        dwHeader = *(LPDWORD)pbBlock;
        pbBlock += sizeof(DWORD);
        
        nPredSampleR = (int)(short)LOWORD(dwHeader);
        nStepIndexR = (int)(BYTE)HIWORD(dwHeader);

        if(!ValidStepIndex(nStepIndexR))
        {
            //
            // The step index is out of range - this is considered a fatal
            // error as the input stream is corrupted.  We fail by returning
            // zero bytes converted.
            //

            fSuccess = FALSE;
            break;
        }

        //
        // Write out first sample
        //

        *(LPDWORD)pbDst = MAKELONG(nPredSampleL, nPredSampleR);
        pbDst += sizeof(DWORD);

        //
        // The first DWORD contains 4 left samples, the second DWORD
        // contains 4 right samples.  We process the source in 8-byte
        // chunks to make it easy to interleave the output correctly.
        //

        while(cSamples)
        {
            dwLeft = *(LPDWORD)pbBlock;
            pbBlock += sizeof(DWORD);
            dwRight = *(LPDWORD)pbBlock;
            pbBlock += sizeof(DWORD);

            cSubSamples = min(cSamples, 8);
            
            for(i = 0; i < cSubSamples; i++)
            {
                //
                // LEFT channel
                //

                nEncSampleL = (dwLeft & 0x0F);
                nStepSize = m_asStep[nStepIndexL];
                nPredSampleL = DecodeSample(nEncSampleL, nPredSampleL, nStepSize);
                nStepIndexL = NextStepIndex(nEncSampleL, nStepIndexL);

                //
                // RIGHT channel
                //

                nEncSampleR = (dwRight & 0x0F);
                nStepSize = m_asStep[nStepIndexR];
                nPredSampleR = DecodeSample(nEncSampleR, nPredSampleR, nStepSize);
                nStepIndexR = NextStepIndex(nEncSampleR, nStepIndexR);

                //
                // Write out sample
                //

                *(LPDWORD)pbDst = MAKELONG(nPredSampleL, nPredSampleR);
                pbDst += sizeof(DWORD);

                //
                // Shift the next input sample into the low-order 4 bits.
                //

                dwLeft >>= 4;
                dwRight >>= 4;
            }

            cSamples -= cSubSamples;
        }

        //
        // Skip padding
        //

        pbSrc += nBlockAlignment;
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\common\memmgr.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memmgr.h
 *  Content:    DirectSound memory manager.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/21/00    dereks  Created.
 *
 ****************************************************************************/

#ifndef __MEMMGR_H__
#define __MEMMGR_H__

#include "macros.h"

#if defined(DEBUG) && !defined(TRACK_MEMORY_USAGE) && !defined(MCPX_BOOT_LIB)
#define TRACK_MEMORY_USAGE
#endif // defined(DEBUG) && !defined(TRACK_MEMORY_USAGE) && !defined(MCPX_BOOT_LIB)

BEGIN_DEFINE_ENUM()
    DSOUND_OBJECT_POOL_TAG  = 'boSD',
    DSOUND_DATA_POOL_TAG    = 'adSD'
END_DEFINE_ENUM(DSOUND_POOL_TAG);

BEGIN_DEFINE_ENUM()
    DSOUND_ALLOCATOR_POOL   = 'loop',
    DSOUND_ALLOCATOR_PHYS   = 'syhp',
    DSOUND_ALLOCATOR_SLOP   = 'pols'
END_DEFINE_ENUM(DSOUND_ALLOCATOR_TAG);

//
// Allocation tracking data
//

BEGIN_DEFINE_STRUCT()
    LIST_ENTRY              leListEntry;
    LPCSTR                  pszFile;
    ULONG                   nLine;
    LPCSTR                  pszClass;
    DSOUND_ALLOCATOR_TAG    nAllocatorTag;
    ULONG                   cbSize;
    LPVOID                  pvBaseAddress;
END_DEFINE_STRUCT(DSMEMTRACK);

#ifdef __cplusplus

//
// Memory manager
//

namespace DirectSound
{
    class CMemoryManager
    {
    public:

#ifdef BUILDING_DSOUND

        static DWORD &      m_dwPoolMemoryUsage;            // Pool memory usage, in bytes
        static DWORD &      m_dwPhysicalMemoryUsage;        // Physical memory usage, in bytes

#else // BUILDING_DSOUND

        static DWORD        m_dwPoolMemoryUsage;            // Pool memory usage, in bytes
        static DWORD        m_dwPhysicalMemoryUsage;        // Physical memory usage, in bytes

#endif // BUILDING_DSOUND

#ifdef TRACK_MEMORY_USAGE

    protected:
        static LIST_ENTRY   m_lstMemoryTracking;            // Allocation list

#endif // TRACK_MEMORY_USAGE
    
    public:
        // Pool memory
        static LPVOID PoolAlloc(DSOUND_POOL_TAG nTag, ULONG cbBuffer, BOOL fZeroInit);
        static void PoolFree(LPVOID pvBuffer);

        // Physically contiguous memory
        static LPVOID PhysicalAlloc(ULONG cbBuffer, ULONG cbAlignment, DWORD dwFlags, BOOL fZeroInit);
        static void PhysicalFree(LPVOID pvBuffer);

#ifdef ENABLE_SLOP_MEMORY_RECOVERY

        // Unused memory recovery
        static LPVOID MemAlloc(DSOUND_POOL_TAG nTag, ULONG cbBuffer, BOOL fZeroInit);
        static void MemFree(LPVOID pvBuffer);

#endif // ENABLE_SLOP_MEMORY_RECOVERY

#ifdef TRACK_MEMORY_USAGE

        // Usage tracking
        static LPVOID TrackingPoolAlloc(LPCSTR pszFile, ULONG nLine, LPCSTR pszClass, DSOUND_POOL_TAG nTag, ULONG cbBuffer, BOOL fZeroInit);
        static void TrackingPoolFree(LPVOID pvBuffer);

        static LPVOID TrackingPhysicalAlloc(LPCSTR pszFile, ULONG nLine, LPCSTR pszClass, ULONG cbBuffer, ULONG cbAlignment, DWORD dwFlags, BOOL fZeroInit);
        static void TrackingPhysicalFree(LPVOID pvBuffer);

#ifdef ENABLE_SLOP_MEMORY_RECOVERY

        static LPVOID TrackingMemAlloc(LPCSTR pszFile, ULONG nLine, LPCSTR pszClass, DSOUND_POOL_TAG nTag, ULONG cbBuffer, BOOL fZeroInit);
        static void TrackingMemFree(LPVOID pvBuffer);

#endif // ENABLE_SLOP_MEMORY_RECOVERY

#endif // TRACK_MEMORY_USAGE

        static void DumpMemoryUsage(BOOL fAssertNone);

#ifdef TRACK_MEMORY_USAGE

    private:
        // Tracking information
        static LPVOID TrackAlloc(LPVOID pvBaseAddress, ULONG cbTracking, LPCSTR pszFile, ULONG nLine, LPCSTR pszClass, DSOUND_ALLOCATOR_TAG nAllocatorTag, ULONG cbSize);
        static LPVOID ForgetAlloc(LPVOID pvBaseAddress, DSOUND_ALLOCATOR_TAG nAllocatorTag);

#endif // TRACK_MEMORY_USAGE

    };
}

#ifndef ENABLE_SLOP_MEMORY_RECOVERY

#define MemAlloc PoolAlloc
#define MemFree PoolFree

#ifdef TRACK_MEMORY_USAGE

#define TrackingMemAlloc TrackingPoolAlloc
#define TrackingMemFree TrackingPoolFree

#endif // TRACK_MEMORY_USAGE

#endif // ENABLE_SLOP_MEMORY_RECOVERY

#ifndef TRACK_MEMORY_USAGE

#define TrackingPoolAlloc(pszFile, nLine, pszClass, nTag, cbBuffer, fZeroInit) \
    PoolAlloc(nTag, cbBuffer, fZeroInit)

#define TrackingPoolFree(pvBuffer) \
    PoolFree(pvBuffer)

#define TrackingPhysicalAlloc(pszFile, nLine, pszClass, cbBuffer, cbAlignment, dwFlags, fZeroInit) \
    PhysicalAlloc(cbBuffer, cbAlignment, dwFlags, fZeroInit)

#define TrackingPhysicalFree(pvBuffer) \
    PhysicalFree(pvBuffer)

#define TrackingMemAlloc(pszFile, nLine, pszClass, nTag, cbBuffer, fZeroInit) \
    MemAlloc(nTag, cbBuffer, fZeroInit)

#define TrackingMemFree(pvBuffer) \
    MemFree(pvBuffer)

#endif // TRACK_MEMORY_USAGE

//
// Memory management macros
//

#define MEMALLOC(type, count) \
    ((type *)DirectSound::CMemoryManager::TrackingMemAlloc(__FILE__, __LINE__, #type, DSOUND_DATA_POOL_TAG, sizeof(type) * (count), TRUE))

#define MEMALLOC_NOINIT(type, count) \
    ((type *)DirectSound::CMemoryManager::TrackingMemAlloc(__FILE__, __LINE__, #type, DSOUND_DATA_POOL_TAG, sizeof(type) * (count), FALSE))

#define MEMFREE(p) \
    { \
        if(p) \
        { \
            DirectSound::CMemoryManager::TrackingMemFree(p); \
            (p) = NULL; \
        } \
    }

#define POOLALLOC(type, count) \
    ((type *)DirectSound::CMemoryManager::TrackingPoolAlloc(__FILE__, __LINE__, #type, DSOUND_DATA_POOL_TAG, sizeof(type) * (count), TRUE))

#define POOLALLOC_NOINIT(type, count) \
    ((type *)DirectSound::CMemoryManager::TrackingPoolAlloc(__FILE__, __LINE__, #type, DSOUND_DATA_POOL_TAG, sizeof(type) * (count), FALSE))

#define POOLFREE(p) \
    { \
        if(p) \
        { \
            DirectSound::CMemoryManager::TrackingPoolFree(p); \
            (p) = NULL; \
        } \
    }

#define PHYSALLOC(type, count, alignment, flags) \
    ((type *)DirectSound::CMemoryManager::TrackingPhysicalAlloc(__FILE__, __LINE__, #type, sizeof(type) * (count), alignment, flags, TRUE))

#define PHYSALLOC_NOINIT(type, count, alignment, flags) \
    ((type *)DirectSound::CMemoryManager::TrackingPhysicalAlloc(__FILE__, __LINE__, #type, sizeof(type) * (count), alignment, flags, FALSE))

#define PHYSFREE(p) \
    { \
        if(p) \
        { \
            DirectSound::CMemoryManager::TrackingPhysicalFree(p); \
            (p) = NULL; \
        } \
    }

//
// New and delete overrides
//

#ifndef DSOUND_NO_OVERRIDE_NEW_DELETE

static void *__cdecl operator new(size_t cbBuffer) 
{ 
    return DirectSound::CMemoryManager::TrackingMemAlloc("(none)", 0, "(unknown)", DSOUND_OBJECT_POOL_TAG, cbBuffer, TRUE); 
}

static void *__cdecl operator new[](size_t cbBuffer) 
{ 
    return DirectSound::CMemoryManager::TrackingMemAlloc("(none)", 0, "(unknown)", DSOUND_OBJECT_POOL_TAG, cbBuffer, TRUE);
}

#ifdef TRACK_MEMORY_USAGE

static void *__cdecl operator new(size_t cbBuffer, LPCSTR pszFile, ULONG nLine, LPCSTR pszClass)
{
    return DirectSound::CMemoryManager::TrackingMemAlloc(pszFile, nLine, pszClass, DSOUND_OBJECT_POOL_TAG, cbBuffer, TRUE); 
}

static void *__cdecl operator new[](size_t cbBuffer, LPCSTR pszFile, ULONG nLine, LPCSTR pszClass)
{
    return DirectSound::CMemoryManager::TrackingMemAlloc(pszFile, nLine, pszClass, DSOUND_OBJECT_POOL_TAG, cbBuffer, TRUE); 
}

#endif // TRACK_MEMORY_USAGE

static void __cdecl operator delete(void *pvBuffer) 
{ 
    DirectSound::CMemoryManager::TrackingMemFree(pvBuffer); 
}

static void __cdecl operator delete[](void *pvBuffer) 
{ 
    DirectSound::CMemoryManager::TrackingMemFree(pvBuffer); 
}

#endif // DSOUND_NO_OVERRIDE_NEW_DELETE

#ifdef TRACK_MEMORY_USAGE

#define NEW(type) \
    new(__FILE__, __LINE__, #type) type

#define NEW_A(type, count) \
    new(__FILE__, __LINE__, #type) type [count]

#else // TRACK_MEMORY_USAGE

#define NEW(type) \
    new type

#define NEW_A(type, count) \
    new type [count]

#endif // TRACK_MEMORY_USAGE

#undef DELETE
#define DELETE(p) \
    { \
        if(p) \
        { \
            delete (p); \
            (p) = NULL; \
        } \
    }

#define DELETE_A(p) \
    { \
        if(p) \
        { \
            delete [] (p); \
            (p) = NULL; \
        } \
    }

#endif // __cplusplus

#endif // __MEMMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\common\macros.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       macros.h
 *  Content:    Misc. helper macros.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/06/01    dereks  Created.
 *
 ***************************************************************************/

#ifndef __MACROS_H__
#define __MACROS_H__

#define DEFINEPTYPE(name) \
    typedef name *P##name

#define DEFINELPTYPE(name) \
    typedef name *LP##name

#define DEFINELPCTYPE(name) \
    typedef const name *LPC##name

#ifdef __cplusplus                  

#define DEFINEREFTYPE(name)  \
    typedef const name &REF##name

#else // __cplusplus                

#define DEFINEREFTYPE(name) \
    typedef const name *REF##name

#endif // __cplusplus               

#define DEFINETYPEFORMS(name) \
    DEFINEPTYPE(name); DEFINELPTYPE(name); DEFINELPCTYPE(name); DEFINEREFTYPE(name)

#define DEFINETYPE(name, type) \
    typedef type name; DEFINETYPEFORMS(name)
                                    
#define BEGIN_DEFINE_STRUCT() \
    typedef struct {

#define BEGIN_DEFINE_STRUCT_(name) \
    typedef struct name {

#define END_DEFINE_STRUCT(name) \
    } name; DEFINETYPEFORMS(name)

#define BEGIN_DEFINE_UNION() \
    typedef union {

#define BEGIN_DEFINE_UNION_(name) \
    typedef union name {

#define END_DEFINE_UNION(name) \
    } name; DEFINETYPEFORMS(name)

#define BEGIN_DEFINE_ENUM()  \
    typedef enum {

#define BEGIN_DEFINE_ENUM_(name) \
    typedef enum name {

#define END_DEFINE_ENUM(name) \
    } name; DEFINETYPEFORMS(name)

#define END_DEFINE_ENUM_() \
    }

#define DIVUP(a, b) \
    (((a) + ((b) - 1)) / (b))

#define BLOCKALIGN(a, b) \
    (((a) / (b)) * (b))

#define BLOCKALIGNPAD(a, b) \
    (DIVUP(a, b) * (b))

#define MAKEBOOL(a) \
    (!!(a))

#define NUMELMS(a) \
    (sizeof(a) / sizeof((a)[0]))

#define HRESULT_FROM_POINTER(p) \
    ((p) ? S_OK : E_OUTOFMEMORY)

#define HRFROMP(p) \
    HRESULT_FROM_POINTER(p)

#ifdef __cplusplus

#define IS_NULL_GUID(guid) \
    (!&(guid) || IsEqualGUID(guid, GUID_NULL))

#else // __cplusplus

#define IS_NULL_GUID(pguid) \
    (!(pguid) || IsEqualGUID(pguid, &GUID_NULL))

#endif // __cplusplus

#define IS_VALID_HANDLE_VALUE(h) \
    ((h) && (INVALID_HANDLE_VALUE != (h)))

#define CLOSE_HANDLE(h) \
    { \
        if(IS_VALID_HANDLE_VALUE(h)) \
        { \
            CloseHandle(h); \
            (h) = NULL; \
        } \
    }

#define INTERLOCKED_EXCHANGE(a, b) \
    InterlockedExchange((LPLONG)&(a), (LONG)(b))

#define INTERLOCKED_INCREMENT(a) \
    InterlockedIncrement((LPLONG)&(a))

#define INTERLOCKED_DECREMENT(a) \
    InterlockedDecrement((LPLONG)&(a))

#define CHECKRANGE(a, min, max) \
    { \
        if((a) < (min)) \
        { \
            (a) = (min); \
        } \
        else if((a) > (max)) \
        { \
            (a) = (max); \
        } \
    }

#endif // __MACROS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\common\refcount.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       refcount.h
 *  Content:    Basic reference-counting class.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/06/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __REFCOUNT_H__
#define __REFCOUNT_H__

#ifdef __cplusplus

namespace DirectSound
{
    class CRefCount
    {
    protected:
        DWORD                   m_dwRefCount;

    public:
        CRefCount(DWORD dwInitialRefCount = 1);
        virtual ~CRefCount(void);

    public:
        virtual DWORD STDMETHODCALLTYPE AddRef(void);
        virtual DWORD STDMETHODCALLTYPE Release(void);
    };

    __inline CRefCount::CRefCount(DWORD dwInitialRefCount)
        : m_dwRefCount(dwInitialRefCount)
    {
    }

    __inline CRefCount::~CRefCount(void)
    {
        ASSERT(!m_dwRefCount);
    }

    __inline DWORD CRefCount::AddRef(void)
    {
        ASSERT(m_dwRefCount < ~0UL);
        return ++m_dwRefCount;
    }

    __inline DWORD CRefCount::Release(void)
    {
        ASSERT(m_dwRefCount);

        if(m_dwRefCount > 0)
        {
            if(!--m_dwRefCount)
            {
                delete this;
                return 0;
            }
        }

        return m_dwRefCount;
    }

    template <class type> type *__AddRef(type *p)
    {
        if(p)
        {
            p->AddRef();
        }

        return p;
    }
}

#define ADDREF(p) \
    DirectSound::__AddRef(p)

#define RELEASE(p) \
    { \
        if(p) \
        { \
            (p)->Release(); \
            (p) = NULL; \
        } \
    }

#endif // __cplusplus

#endif // __REFCOUNT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\common\ntlist.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ntlist.h
 *  Content:    Overrides of the standard NT list management macros.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/06/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __NTLIST_H__
#define __NTLIST_H__

#ifdef __cplusplus

#include "macros.h"

#ifndef InitializeListHead

#define InitializeListHead(ListHead) \
    ((ListHead)->Blink = (ListHead)->Flink = (ListHead))

#endif // InitializeListHead

#ifndef IsListEmpty

#define IsListEmpty(ListHead) \
    ((ListHead) == (ListHead)->Flink)

#endif // IsListEmpty

#ifndef IsEntryInList

#define IsEntryInList(Entry) \
    (!IsListEmpty(Entry))

#endif // IsEntryInList

//
// Determine if the entry is valid
//

BEGIN_DEFINE_ENUM()
    ASSERT_VALID_ONLY = 0,
    ASSERT_IN_LIST,
    ASSERT_NOT_IN_LIST,
END_DEFINE_ENUM(ASSERT_VALID_ENTRY_LIST);

#ifdef DEBUG

__inline void __AssertValidEntryList(PLIST_ENTRY Entry, ASSERT_VALID_ENTRY_LIST nFlags, LPCSTR pszFile, UINT nLine)
{
    if(!Entry)
    {
        DirectSound::CDebug::Assert(TRUE, "NULL list entry pointer", pszFile, nLine);
    }
    else if(!Entry->Flink || !Entry->Blink)
    {
        DirectSound::CDebug::Assert(TRUE, "List entry contains NULL pointer", pszFile, nLine);
    }
    else if((Entry == Entry->Flink) || (Entry == Entry->Blink))
    {
        if((Entry != Entry->Flink) || (Entry != Entry->Blink))
        {
            DirectSound::CDebug::Assert(TRUE, "List entry partially points to itself", pszFile, nLine);
        }
    }
    else if(ASSERT_IN_LIST == nFlags)
    {
        if(!IsEntryInList(Entry))
        {
            DirectSound::CDebug::Assert(TRUE, "List entry not in list", pszFile, nLine);
        }
    }
    else if(ASSERT_NOT_IN_LIST == nFlags)
    {
        if(IsEntryInList(Entry))
        {
            DirectSound::CDebug::Assert(TRUE, "List entry in list", pszFile, nLine);
        }
    }
}

#define AssertValidEntryList(Entry, nFlags) \
    __AssertValidEntryList(Entry, nFlags, __FILE__, __LINE__)

#else // DEBUG

#define AssertValidEntryList(Entry, nFlags)

#endif // DEBUG

//
// Add an entry to the end of a list or add a node at the position before
// the given node
//

/*
#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }
*/

#undef InsertTailList
__inline void InsertTailList(PLIST_ENTRY ListHead, PLIST_ENTRY Entry)
{
    AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);
    AssertValidEntryList(Entry, ASSERT_NOT_IN_LIST);

    Entry->Flink = ListHead;
    Entry->Blink = ListHead->Blink;
    
    Entry->Blink->Flink = Entry;
    Entry->Flink->Blink = Entry;

    AssertValidEntryList(Entry, ASSERT_IN_LIST);
}    

//
// Add an entry to the end of a list or add a node at the position before
// the given node (no valid node check)
//

__inline void InsertTailListUninit(PLIST_ENTRY ListHead, PLIST_ENTRY Entry)
{
    AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);

    Entry->Flink = ListHead;
    Entry->Blink = ListHead->Blink;
    
    Entry->Flink->Blink = Entry;
    Entry->Blink->Flink = Entry;

    AssertValidEntryList(Entry, ASSERT_IN_LIST);
}    

//
// Add an entry to the head of a list or add a node at the position after
// the given node
//

/*
#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }
*/

#undef InsertHeadList
__inline void InsertHeadList(PLIST_ENTRY ListHead, PLIST_ENTRY Entry)
{
    AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);
    AssertValidEntryList(Entry, ASSERT_NOT_IN_LIST);

    Entry->Flink = ListHead->Flink;
    Entry->Blink = ListHead;
    
    Entry->Flink->Blink = Entry;
    Entry->Blink->Flink = Entry;

    AssertValidEntryList(Entry, ASSERT_IN_LIST);
}

//
// Add an entry to the head of a list or add a node at the position after
// the given node (no valid node check)
//

__inline void InsertHeadListUninit(PLIST_ENTRY ListHead, PLIST_ENTRY Entry)
{
    AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);

    Entry->Flink = ListHead->Flink;
    Entry->Blink = ListHead;
    
    Entry->Flink->Blink = Entry;
    Entry->Blink->Flink = Entry;

    AssertValidEntryList(Entry, ASSERT_IN_LIST);
}

//
// Remove an entry from a list
//

/*
#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }
*/

#undef RemoveEntryList
__inline PLIST_ENTRY RemoveEntryList(PLIST_ENTRY Entry)
{
    AssertValidEntryList(Entry, ASSERT_VALID_ONLY);

    if(IsEntryInList(Entry))
    {
        Entry->Flink->Blink = Entry->Blink;
        Entry->Blink->Flink = Entry->Flink;

        Entry->Flink = Entry->Blink = Entry;
    }

    return Entry;
}

/*
#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}
*/

#undef RemoveHeadList
#define RemoveHeadList(ListHead) \
    RemoveEntryList((ListHead)->Flink)

/*
#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}
*/

#undef RemoveTailList
#define RemoveTailList(ListHead) \
    RemoveEntryList((ListHead)->Blink)

//
// Move an entry from one list to the tail of another
//

__inline PLIST_ENTRY MoveEntryTailList(PLIST_ENTRY ListHead, PLIST_ENTRY Entry)
{
    AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);
    AssertValidEntryList(Entry, ASSERT_VALID_ONLY);

    Entry->Flink->Blink = Entry->Blink;
    Entry->Blink->Flink = Entry->Flink;

    Entry->Flink = ListHead;
    Entry->Blink = ListHead->Blink;

    Entry->Flink->Blink = Entry;
    Entry->Blink->Flink = Entry;

    AssertValidEntryList(Entry, ASSERT_IN_LIST);

    return Entry;
}

__inline PLIST_ENTRY MoveHeadTailList(PLIST_ENTRY DestListHead, PLIST_ENTRY SourceListHead)
{
    PLIST_ENTRY             Entry;
    
    AssertValidEntryList(SourceListHead, ASSERT_VALID_ONLY);

    if((Entry = SourceListHead->Flink) != SourceListHead)
    {
        MoveEntryTailList(DestListHead, Entry);
    }
    
    return Entry;
}

#endif // __cplusplus

#endif // __NTLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\common\waveldr.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       waveldr.cpp
 *  Content:    Wave file loader.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  06/08/00    dereks  Created.
 *
 ****************************************************************************/

#include "dscommon.h"

// #define WAVELDR_ENABLE_ERRORS
#ifndef WAVELDR_ENABLE_ERRORS

#undef DPF_ERROR
#undef DPF_WARNING

#ifdef DEBUG

#define DPF_ERROR DPF_INFO
#define DPF_WARNING DPF_INFO

#else // DEBUG

#define DPF_ERROR(a)
#define DPF_WARNING(a)

#endif // DEBUG

#endif // WAVELDR_ENABLE_ERRORS

#pragma warning(disable:4035)

static unsigned short __fastcall EndianSwapWord(unsigned short n)
{
    __asm
    {
        mov     eax, ecx
        sar     eax, 8
        and     eax, 0ffh

        mov     ebx, ecx
        shl     ebx, 8
        and     ebx, 0ff00h
        or      eax, ebx
    }
}

static unsigned long __fastcall EndianSwapDword(unsigned long n)
{
    __asm
    {
        mov     eax, ecx
        sar     eax, 24
        and     eax, 0ffh

        mov     ebx, ecx
        sar     ebx, 8
        and     ebx, 0ff00h
        or      eax, ebx

        mov     ebx, ecx
        shl     ebx, 8
        and     ebx, 0ff0000h
        or      eax, ebx

        mov     ebx, ecx
        shl     ebx, 24
        and     ebx, 0ff000000h
        or      eax, ebx
    }
}


/***************************************************************************
 *
 *  CStdFileStream
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStdFileStream::CStdFileStream"

CStdFileStream::CStdFileStream
(
    void
)
{
    DPF_ENTER();

    //
    // Initialize defaults
    //

    m_hFile = NULL;
    m_dwFlags = 0;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CStdFileStream
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStdFileStream::~CStdFileStream"

CStdFileStream::~CStdFileStream
(
    void
)
{
    DPF_ENTER();

    Close();

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Open
 *
 *  Description:
 *      Opens the stream.
 *
 *  Arguments:
 *      LPCSTR [in]: file name.
 *      DWORD [in]: access mask.
 *      DWORD [in]: share mask.
 *      DWORD [in]: creation distribution.
 *      DWORD [in]: attribute mask.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStdFileStream::Open"

HRESULT
CStdFileStream::Open
(
    LPCSTR                  pszFileName, 
    DWORD                   dwDesiredAccess, 
    DWORD                   dwShareMode, 
    DWORD                   dwCreationDisposition, 
    DWORD                   dwFlagsAndAttributes
)
{
    HRESULT                 hr  = S_OK;

    DPF_ENTER();

    ASSERT(!IS_VALID_HANDLE_VALUE(m_hFile));
    
    m_hFile = CreateFile(pszFileName, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);

    if(INVALID_HANDLE_VALUE == m_hFile)
    {
        m_hFile = NULL;
    }

    if(!m_hFile)
    {
        DPF_ERROR("Error %lu occurred trying to open %s", GetLastError(), pszFileName);
        hr = E_FAIL;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Attach
 *
 *  Description:
 *      Attaches the stream to an open file handle.
 *
 *  Arguments:
 *      HANDLE [in]: file handle.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStdFileStream::Attach"

void
CStdFileStream::Attach
(
    HANDLE                  hFile
)
{
    DPF_ENTER();

    ASSERT(!IS_VALID_HANDLE_VALUE(m_hFile));
    
    m_hFile = hFile;
    m_dwFlags |= FILESTREAM_FLAGS_ATTACHED;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Close
 *
 *  Description:
 *      Closes the object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStdFileStream::Close"

void
CStdFileStream::Close
(
    void
)
{
    DPF_ENTER();
    
    if(m_dwFlags & FILESTREAM_FLAGS_ATTACHED)
    {
        m_hFile = NULL;
        m_dwFlags &= ~FILESTREAM_FLAGS_ATTACHED;
    }
    else
    {
        CLOSE_HANDLE(m_hFile);
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Read
 *
 *  Description:
 *      Reads from the stream.
 *
 *  Arguments:
 *      LPVOID [in]: read buffer.
 *      DWORD [in]: size of above buffer, in bytes.
 *      LPDWORD [out]: amount read, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStdFileStream::Read"

HRESULT
CStdFileStream::Read
(
    LPVOID                  pvBuffer,
    DWORD                   dwBufferSize,
    LPDWORD                 pdwRead
)
{
    HRESULT                 hr      = S_OK;
    DWORD                   dwRead;

    DPF_ENTER();
    
    ASSERT(IS_VALID_HANDLE_VALUE(m_hFile));
    
    if(!ReadFile(m_hFile, pvBuffer, dwBufferSize, &dwRead, NULL))
    {
        DPF_ERROR("Error %lu occurred reading from the file", GetLastError());
        hr = E_FAIL;
    }

    if(SUCCEEDED(hr))
    {
        if(pdwRead)
        {
            *pdwRead = dwRead;
        }
        else if(dwRead != dwBufferSize)
        {
            DPF_ERROR("Not enough data was read from the file");
            hr = E_FAIL;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Write
 *
 *  Description:
 *      Writes to the stream.
 *
 *  Arguments:
 *      LPCVOID [in]: write buffer.
 *      DWORD [in]: size of above buffer, in bytes.
 *      LPDWORD [out]: amount written, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStdFileStream::Write"

HRESULT
CStdFileStream::Write
(
    LPCVOID                 pvBuffer,
    DWORD                   dwBufferSize,
    LPDWORD                 pdwWritten
)
{
    HRESULT                 hr          = S_OK;
    DWORD                   dwWritten;

    DPF_ENTER();
    
    ASSERT(IS_VALID_HANDLE_VALUE(m_hFile));
    
    if(!WriteFile(m_hFile, pvBuffer, dwBufferSize, &dwWritten, NULL))
    {
        DPF_ERROR("Error %lu occurred writing to the file", GetLastError());
        hr = E_FAIL;
    }

    if(SUCCEEDED(hr))
    {
        if(pdwWritten)
        {
            *pdwWritten = dwWritten;
        }
        else if(dwWritten != dwBufferSize)
        {
            DPF_ERROR("Not enough data was written from the file");
            hr = E_FAIL;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Seek
 *
 *  Description:
 *      Sets the current read or write position in the stream.
 *
 *  Arguments:
 *      LONG [in]: relative offset.
 *      DWORD [in]: offset origin.
 *      LPDWORD [out]: absolute stream position.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStdFileStream::Seek"

HRESULT
CStdFileStream::Seek
(
    LONG                    lOffset,
    DWORD                   dwOrigin,
    LPDWORD                 pdwAbsolute
)
{
    HRESULT                 hr          = S_OK;
    DWORD                   dwAbsolute;
    
    DPF_ENTER();

    ASSERT(IS_VALID_HANDLE_VALUE(m_hFile));
    
    if((dwAbsolute = SetFilePointer(m_hFile, lOffset, NULL, dwOrigin)) == INVALID_SET_FILE_POINTER)
    {
        DPF_ERROR("Error %lu occurred seeking the file", GetLastError());
        hr = E_FAIL;
    }

    if(SUCCEEDED(hr) && pdwAbsolute)
    {
        *pdwAbsolute = dwAbsolute;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetLength
 *
 *  Description:
 *      Gets the file size, in bytes.
 *
 *  Arguments:
 *      LPDWORD [out]: file size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStdFileStream::GetLength"

HRESULT
CStdFileStream::GetLength
(
    LPDWORD                 pdwLength
)
{
    HRESULT                 hr  = S_OK;
    
    DPF_ENTER();

    ASSERT(IS_VALID_HANDLE_VALUE(m_hFile));
    
    if((*pdwLength = GetFileSize(m_hFile, NULL)) == -1)
    {
        DPF_ERROR("Error %lu attempting to get the file size", GetLastError());
        hr = E_FAIL;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CRiffChunk
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      DWORD [in]: chunk identifier.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRiffChunk::CRiffChunk"

CRiffChunk::CRiffChunk
(
    void
)
{
    DPF_ENTER();

    //
    // Initialize defaults
    //

    m_pParentChunk = NULL;
    m_pStream = NULL;
    m_dwChunkId = 0;
    m_dwDataOffset = 0;
    m_dwDataSize = 0;
    m_dwFlags = 0;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CRiffChunk
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRiffChunk::~CRiffChunk"

CRiffChunk::~CRiffChunk
(
    void
)
{
    DPF_ENTER();
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Open
 *
 *  Description:
 *      Opens an existing chunk.
 *
 *  Arguments:
 *      CRiffChunk * [in]: parent chunk.
 *      CStdFileStream * [in]: stream.
 *      DWORD [in]: chunk identifier.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRiffChunk::Open"

HRESULT
CRiffChunk::Open
(
    CRiffChunk *            pParentChunk, 
    CStdFileStream *        pStream,
    DWORD                   dwChunkId
)
{
    LONG                    lOffset;
    RIFFHEADER              rhRiffHeader;
    HRESULT                 hr;

    DPF_ENTER();
    
    m_pParentChunk = pParentChunk;
    m_pStream = pStream;

    //
    // Seek to the first byte of the parent chunk's data section
    //

    if(m_pParentChunk)
    {
        lOffset = m_pParentChunk->m_dwDataOffset;

        //
        // Special case the RIFF chunk
        //

        if((WAVELDR_FOURCC_RIFF == m_pParentChunk->m_dwChunkId) || (WAVELDR_FOURCC_FORM == m_pParentChunk->m_dwChunkId))
        {
            lOffset += sizeof(DWORD);
        }
    }
    else
    {
        lOffset = 0;
    }

    //
    // If this is the top level chunk, just read the first 8 bytes.  If not,
    // search the parent chunk until we find the one we're looking for.
    //

    do
    {
        hr = m_pStream->Seek(lOffset, FILE_BEGIN, NULL);

        if(SUCCEEDED(hr))
        {
            hr = m_pStream->Read(&rhRiffHeader, sizeof(rhRiffHeader), NULL);
        }

        if(SUCCEEDED(hr) && m_pParentChunk)
        {
            if(WAVELDR_FOURCC_FORM == m_pParentChunk->m_dwChunkId)
            {
                rhRiffHeader.dwDataSize = EndianSwapDword(rhRiffHeader.dwDataSize);
            }
        }

        if(SUCCEEDED(hr) && (dwChunkId == rhRiffHeader.dwChunkId))
        {
            break;
        }

        if(SUCCEEDED(hr) && !m_pParentChunk)
        {
            hr = E_FAIL;
        }

        if(SUCCEEDED(hr))
        {
            lOffset += sizeof(rhRiffHeader) + rhRiffHeader.dwDataSize;
        }
    }
    while(SUCCEEDED(hr));

    //
    // Success
    //

    if(SUCCEEDED(hr))
    {
        m_dwChunkId = dwChunkId;
        m_dwDataOffset = lOffset + sizeof(rhRiffHeader);
        m_dwDataSize = rhRiffHeader.dwDataSize;
        m_dwFlags |= RIFFCHUNK_FLAGS_VALID;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Read
 *
 *  Description:
 *      Reads data from the chunk.
 *
 *  Arguments:
 *      DWORD [in]: chunk data position.
 *      LPVOID [out]: data buffer.
 *      DWORD [in]: data size.
 *      LPDWORD [out]: amount read.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRiffChunk::Read"

HRESULT
CRiffChunk::Read
(
    DWORD                   dwOffset, 
    LPVOID                  pvBuffer, 
    DWORD                   dwBufferSize, 
    LPDWORD                 pdwRead
)
{
    HRESULT                 hr  = S_OK;

    DPF_ENTER();

    if(dwOffset + dwBufferSize > m_dwDataSize)
    {
        if(dwOffset >= m_dwDataSize)
        {
            dwBufferSize = 0;
        }
        else
        {
            dwBufferSize = m_dwDataSize - dwOffset;
        }

        if(pdwRead)
        {
            *pdwRead = dwBufferSize;
        }
        else
        {
            DPF_ERROR("Attempted to read past the end of the chunk");
            hr = E_FAIL;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pStream->Seek(m_dwDataOffset + dwOffset, FILE_BEGIN, NULL);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pStream->Read(pvBuffer, dwBufferSize, NULL);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CWaveFile
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveFile::CWaveFile"

CWaveFile::CWaveFile
(
    void
)
{
    DPF_ENTER();

    m_dwFileType = -1;
    m_pwfxFormat = NULL;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CWaveFile
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveFile::~CWaveFile"

CWaveFile::~CWaveFile
(
    void
)
{
    DPF_ENTER();

    Close();

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Open
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPCSTR [in]: file name.
 *      HANDLE [in]: file handle.
 *
 *  Returns:  
 *      HRESULT: result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveFile::Open"

HRESULT
CWaveFile::Open
(
    LPCSTR                  pszFileName,
    HANDLE                  hFile
)
{
    HRESULT                 hr              = S_OK;
    DWORD                   dwType;
    CRiffChunk              VersionChunk;
    DWORD                   dwVersion;
    DWORD                   dwFormatSize;
    AIFFSOUNDHDR            AiffSoundHeader;

    DPF_ENTER();

    ASSERT((pszFileName || hFile) && !(pszFileName && hFile));
    
    //
    // If we're already open, close
    //

    Close();

    //
    // Open the file
    //

    if(pszFileName)
    {
        hr = m_Stream.Open(pszFileName, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING, 0);
    }
    else
    {
        m_Stream.Attach(hFile);
    }

    //
    // Determine the file type by opening the top-level chunk
    //

    if(SUCCEEDED(hr))
    {
        hr = m_ParentChunk.Open(NULL, &m_Stream, WAVELDR_FOURCC_RIFF);

        if(SUCCEEDED(hr))
        {
            m_dwFileType = WAVELDR_FILETYPE_WAVE;
        }
        else
        {
            hr = m_ParentChunk.Open(NULL, &m_Stream, WAVELDR_FOURCC_FORM);

            if(SUCCEEDED(hr))
            {
                m_dwFileType = WAVELDR_FILETYPE_AIFF;
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_ParentChunk.Read(0, &dwType, sizeof(dwType));

        if(SUCCEEDED(hr))
        {
            if(WAVELDR_FILETYPE_WAVE == m_dwFileType)
            {
                if(WAVELDR_FOURCC_WAVE != dwType)
                {
                    DPF_ERROR("The file type is not WAVE");
                    hr = E_FAIL;
                }
            }
            else
            {
                if((WAVELDR_FOURCC_AIFF != dwType) && (WAVELDR_FOURCC_AIFFC != dwType))
                {
                    DPF_ERROR("The file type is not AIFF/AIFF-C");
                    hr = E_FAIL;
                }
            }
        }
    }

    if(SUCCEEDED(hr) && (WAVELDR_FILETYPE_AIFF == m_dwFileType) && (WAVELDR_FOURCC_AIFFC == dwType))
    {
        hr = VersionChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_AIFF_VERSION);

        if(SUCCEEDED(hr))
        {
            hr = VersionChunk.Read(0, &dwVersion, sizeof(dwVersion));
        }

        if(SUCCEEDED(hr) && (WAVELDR_AIFFC_VERSION != dwVersion))
        {
            DPF_ERROR("The file's AIFF-C version is not supported");
            hr = E_FAIL;
        }
    }

    //
    // Initialize the required chunk objects
    //

    if(SUCCEEDED(hr))
    {
        hr = m_DataChunk.Open(&m_ParentChunk, &m_Stream, (WAVELDR_FILETYPE_WAVE == m_dwFileType) ? WAVELDR_FOURCC_DATA : WAVELDR_FOURCC_SOUND);
    }

    //
    // Load the file format
    //

    if(SUCCEEDED(hr))
    {
        if(WAVELDR_FILETYPE_WAVE == m_dwFileType)
        {
            hr = GetWaveFormat(NULL, 0, &dwFormatSize);
        }
        else
        {
            hr = GetAiffFormat(NULL, 0, &dwFormatSize);
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = HRFROMP(m_pwfxFormat = (LPWAVEFORMATEX)MEMALLOC(BYTE, dwFormatSize));
    }

    if(SUCCEEDED(hr))
    {
        if(WAVELDR_FILETYPE_WAVE == m_dwFileType)
        {
            hr = GetWaveFormat(m_pwfxFormat, dwFormatSize, NULL);
        }
        else
        {
            hr = GetAiffFormat(m_pwfxFormat, dwFormatSize, NULL);
        }
    }

    //
    // If this is an AIFF file, offset the start of the wave data
    //

    if(SUCCEEDED(hr) && (WAVELDR_FILETYPE_AIFF == m_dwFileType))
    {
        hr = m_DataChunk.Read(0, &AiffSoundHeader, sizeof(AiffSoundHeader));

        if(SUCCEEDED(hr))
        {
            m_DataChunk.m_dwDataOffset += sizeof(AiffSoundHeader) + AiffSoundHeader.dwOffset;
            m_DataChunk.m_dwDataSize -= sizeof(AiffSoundHeader) + AiffSoundHeader.dwOffset;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetFormat
 *
 *  Description:
 *      Gets the wave file format.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: file format.
 *      DWORD [in]: file format buffer size.
 *      LPDWORD [out]: bytes required.
 *
 *  Returns:  
 *      HRESULT: result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveFile::GetFormat"

HRESULT
CWaveFile::GetFormat
(
    LPWAVEFORMATEX          pwfxFormat, 
    DWORD                   dwFormatSize, 
    LPDWORD                 pdwRequiredSize
)
{
    DWORD                   dwValidSize;
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(m_pwfxFormat);
    
    dwValidSize = sizeof(*m_pwfxFormat) + m_pwfxFormat->cbSize;

    if(pwfxFormat && dwFormatSize)
    {
        CopyMemory(pwfxFormat, m_pwfxFormat, min(dwFormatSize, dwValidSize));

        if(dwFormatSize > dwValidSize)
        {
            ZeroMemory((LPBYTE)pwfxFormat + dwValidSize, dwFormatSize - dwValidSize);
        }
    }

    if(pdwRequiredSize)
    {
        *pdwRequiredSize = dwValidSize;
    }

    DPF_LEAVE_HRESULT(S_OK);

    return S_OK;
}


/***************************************************************************
 *
 *  GetWaveFormat
 *
 *  Description:
 *      Gets the wave file format.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: file format.
 *      DWORD [in]: file format buffer size.
 *      LPDWORD [out]: bytes required.
 *
 *  Returns:  
 *      HRESULT: result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveFile::GetWaveFormat"

HRESULT
CWaveFile::GetWaveFormat
(
    LPWAVEFORMATEX          pwfxFormat, 
    DWORD                   dwFormatSize, 
    LPDWORD                 pdwRequiredSize
)
{
    CRiffChunk              FormatChunk;
    DWORD                   dwValidSize;
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(WAVELDR_FILETYPE_WAVE == m_dwFileType);

    //
    // Read the format chunk into the buffer.  Make sure to fill in the full
    // WAVEFORMATEX structure, even if the data in the file isn't enough.
    //

    hr = FormatChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_FORMAT);

    if(SUCCEEDED(hr))
    {
        dwValidSize = FormatChunk.GetDataSize();

        hr = FormatChunk.Read(0, pwfxFormat, min(dwValidSize, dwFormatSize));
    }

    if(SUCCEEDED(hr) && (dwFormatSize > dwValidSize))
    {
        ZeroMemory((LPBYTE)pwfxFormat + dwValidSize, dwFormatSize - dwValidSize);
    }

    if(SUCCEEDED(hr) && pdwRequiredSize)
    {
        *pdwRequiredSize = max(dwValidSize, sizeof(*pwfxFormat));
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetAiffFormat
 *
 *  Description:
 *      Gets the wave file format.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: file format.
 *      DWORD [in]: file format buffer size.
 *      LPDWORD [out]: bytes required.
 *
 *  Returns:  
 *      HRESULT: result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveFile::GetAiffFormat"

HRESULT
CWaveFile::GetAiffFormat
(
    LPWAVEFORMATEX          pwfxFormat, 
    DWORD                   dwFormatSize, 
    LPDWORD                 pdwRequiredSize
)
{
    HRESULT                 hr          = S_OK;
    CRiffChunk              FormatChunk;
    DWORD                   dwValidSize;
    AIFFFORMAT              AiffFormat;
    WAVEFORMATEX            WaveFormat;

    DPF_ENTER();

    ASSERT(WAVELDR_FILETYPE_AIFF == m_dwFileType);

    if(pwfxFormat && dwFormatSize)
    {
        //
        // Open the format chunk
        //

        hr = FormatChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_COMM);
        
        //
        // Read the base format data
        //

        if(SUCCEEDED(hr))
        {
            dwValidSize = FormatChunk.GetDataSize();

            hr = FormatChunk.Read(0, &AiffFormat, min(sizeof(AiffFormat), dwValidSize));
        }

        if(SUCCEEDED(hr) && (sizeof(AiffFormat) > dwValidSize))
        {
            ZeroMemory((LPBYTE)&AiffFormat + dwValidSize, sizeof(AiffFormat) - dwValidSize);
        }

        //
        // If no compression type is specified, assume PCM
        //

        if(SUCCEEDED(hr) && !AiffFormat.dwCompression)
        {
            AiffFormat.dwCompression = WAVELDR_FOURCC_NONE;
        }

        //
        // Currently, only PCM is supported
        //

        if(SUCCEEDED(hr) && (WAVELDR_FOURCC_NONE != AiffFormat.dwCompression))
        {
            DPF_ERROR("Unsupported AIFF compression type");
            hr = E_FAIL;
        }

        //
        // Convert AIFF format to WAVE format
        //

        if(SUCCEEDED(hr))
        {
            AiffFormat.nChannels = EndianSwapWord(AiffFormat.nChannels);
            AiffFormat.wBitsPerSample = EndianSwapWord(AiffFormat.wBitsPerSample);
            AiffFormat.wFrequencyExponent = EndianSwapWord(AiffFormat.wFrequencyExponent);
            AiffFormat.dwFrequencyMantissa = EndianSwapDword(AiffFormat.dwFrequencyMantissa);

            XAudioCreatePcmFormat(AiffFormat.nChannels, AiffFormat.dwFrequencyMantissa >> (16414 - (AiffFormat.wFrequencyExponent & 0x7FFF)), AiffFormat.wBitsPerSample, &WaveFormat);
        }

        if(SUCCEEDED(hr))
        {
            CopyMemory(pwfxFormat, &WaveFormat, min(sizeof(WaveFormat), dwFormatSize));
        }

        if(SUCCEEDED(hr) && (dwFormatSize > sizeof(WaveFormat)))
        {
            ZeroMemory((LPBYTE)pwfxFormat + sizeof(WaveFormat), dwFormatSize - sizeof(WaveFormat));
        }
    }
    
    if(SUCCEEDED(hr) && pdwRequiredSize)
    {
        *pdwRequiredSize = sizeof(WaveFormat);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetLoopRegion
 *
 *  Description:
 *      Gets the loop region, if it exists.
 *
 *  Arguments:
 *      LPDWORD [out]: loop start offset, in bytes.
 *      LPDWORD [out]: loop length, in bytes.
 *
 *  Returns:  
 *      HRESULT: result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStdFileStream::GetLoopRegion"

HRESULT
CWaveFile::GetLoopRegion
(
    LPDWORD                 pdwLoopStart,
    LPDWORD                 pdwLoopLength
)
{
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(m_pwfxFormat);

    //
    // Read loop region data in samples
    //

    if(WAVELDR_FILETYPE_WAVE == m_dwFileType)
    {
        hr = GetWaveLoopRegion(pdwLoopStart, pdwLoopLength);
    }
    else
    {
        hr = GetAiffLoopRegion(pdwLoopStart, pdwLoopLength);
    }

    //
    // Convert to bytes
    //

    if(SUCCEEDED(hr))
    {
        if(WAVE_FORMAT_XBOX_ADPCM == m_pwfxFormat->wFormatTag)
        {
            *pdwLoopStart /= m_pwfxFormat->nChannels * XBOX_ADPCM_SAMPLES_PER_BLOCK;
            *pdwLoopStart *= m_pwfxFormat->nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

            *pdwLoopLength /= m_pwfxFormat->nChannels * XBOX_ADPCM_SAMPLES_PER_BLOCK;
            *pdwLoopLength *= m_pwfxFormat->nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;
        }
        else
        {
            *pdwLoopStart *= m_pwfxFormat->nBlockAlign;
            *pdwLoopLength *= m_pwfxFormat->nBlockAlign;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetWaveLoopRegion
 *
 *  Description:
 *      Gets the loop region.
 *
 *  Arguments:
 *      LPDWORD [out]: loop start offset, in samples.
 *      LPDWORD [out]: loop length, in samples.
 *
 *  Returns:  
 *      HRESULT: result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStdFileStream::GetWaveLoopRegion"

HRESULT
CWaveFile::GetWaveLoopRegion
(
    LPDWORD                 pdwLoopStart,
    LPDWORD                 pdwLoopLength
)
{
    CRiffChunk              InstrumentChunk;
    WAVESAMPLE              wsamp;
    WAVESAMPLE_LOOP         loop;
    DWORD                   dwOffset;
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(m_pwfxFormat);

    //
    // Open the instrument chunk
    //

    hr = InstrumentChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_WAVE_SAMPLE);

    //
    // Read the WAVESAMPLE header and first loop region
    //

    if(SUCCEEDED(hr))
    {
        hr = InstrumentChunk.Read(0, &wsamp, sizeof(wsamp));
    }

    //
    // Scan loop regions until we find one that's FORWARD or RELEASE
    //

    if(SUCCEEDED(hr))
    {
        dwOffset = sizeof(wsamp);
    
        while(SUCCEEDED(hr) && wsamp.dwSampleLoops)
        {
            hr = InstrumentChunk.Read(dwOffset, &loop, sizeof(loop));

            if(SUCCEEDED(hr))
            {
                if((WAVESAMPLE_LOOPTYPE_FORWARD == loop.dwLoopType) || (WAVESAMPLE_LOOPTYPE_RELEASE == loop.dwLoopType))
                {
                    break;
                }
            }
        
            dwOffset += sizeof(loop);

            wsamp.dwSampleLoops--;
        }
    }

    if(SUCCEEDED(hr))
    {
        if(!wsamp.dwSampleLoops)
        {
            DPF_ERROR("No FORWARD loop regions found");
            hr = E_FAIL;
        }
        else if(wsamp.dwSampleLoops > 1)
        {
            DPF_WARNING("Only the first FORWARD loop will be used");
        }
    }

    //
    // Success
    //

    if(SUCCEEDED(hr))
    {
        *pdwLoopStart = loop.dwLoopStart;
        *pdwLoopLength = loop.dwLoopLength;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetAiffLoopRegion
 *
 *  Description:
 *      Gets the loop region.
 *
 *  Arguments:
 *      LPDWORD [out]: loop start offset, in samples.
 *      LPDWORD [out]: loop length, in samples.
 *
 *  Returns:  
 *      HRESULT: result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CStdFileStream::GetAiffLoopRegion"

HRESULT
CWaveFile::GetAiffLoopRegion
(
    LPDWORD                 pdwLoopStart,
    LPDWORD                 pdwLoopLength
)
{
    LPAIFFMARKERHDR         pMarkers            = NULL;
    CRiffChunk              InstrumentChunk;
    AIFFINSTRUMENT          inst;
    LPAIFFLOOP              pLoop;
    CRiffChunk              MarkerChunk;
    DWORD                   dwMarkerSize;
    AIFFMARKERHDR           MarkerHeader;
    LPAIFFMARKER            pStartMarker;
    LPAIFFMARKER            pEndMarker;
    HRESULT                 hr;
    WORD                    i;

    DPF_ENTER();

    //
    // Open the instrument chunk
    //

    hr = InstrumentChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_INSTRUMENT);

    //
    // Read the instrument data
    //

    if(SUCCEEDED(hr))
    {
        hr = InstrumentChunk.Read(0, &inst, sizeof(inst));
    }

    //
    // Use the first loop that's FORWARD
    //

    if(SUCCEEDED(hr))
    {
        if(AIFFLOOP_MODE_FORWARD == EndianSwapWord(inst.SustainLoop.wPlayMode))
        {
            pLoop = &inst.SustainLoop;
        }
        else if(AIFFLOOP_MODE_FORWARD == EndianSwapWord(inst.ReleaseLoop.wPlayMode))
        {
            pLoop = &inst.ReleaseLoop;
        }
        else
        {
            DPF_ERROR("Neither loop is FORWARD");
            hr = E_FAIL;
        }
    }

    //
    // Open the marker chunk
    //

    if(SUCCEEDED(hr))
    {
        hr = MarkerChunk.Open(&m_ParentChunk, &m_Stream, WAVELDR_FOURCC_MARKER);
    }

    // 
    // Read marker data
    //

    if(SUCCEEDED(hr))
    {
        dwMarkerSize = MarkerChunk.GetDataSize();
        
        hr = HRFROMP(pMarkers = (LPAIFFMARKERHDR)MEMALLOC(BYTE, dwMarkerSize));
    }

    if(SUCCEEDED(hr))
    {
        hr = MarkerChunk.Read(0, pMarkers, dwMarkerSize);
    }

    if(SUCCEEDED(hr))
    {
        pMarkers->wMarkerCount = EndianSwapWord(pMarkers->wMarkerCount);
    }

    //
    // Find the loop markers
    //

    if(SUCCEEDED(hr))
    {
        pStartMarker = (LPAIFFMARKER)(pMarkers + 1);
        
        for(i = 0; i < pMarkers->wMarkerCount; i++)
        {
            ASSERT((DWORD)pStartMarker < (DWORD)pMarkers + dwMarkerSize);
            
            if(pStartMarker->wMarkerId == pLoop->wStartMarker)
            {
                break;
            }

            pStartMarker = (LPAIFFMARKER)((LPBYTE)pStartMarker + sizeof(*pStartMarker) + pStartMarker->bNameLength);
        }

        if(i >= pMarkers->wMarkerCount)
        {
            DPF_ERROR("Can't find loop start marker");
            hr = E_FAIL;
        }
    }

    if(SUCCEEDED(hr))
    {
        pEndMarker = (LPAIFFMARKER)(pMarkers + 1);
        
        for(i = 0; i < pMarkers->wMarkerCount; i++)
        {
            ASSERT((DWORD)pEndMarker < (DWORD)pMarkers + dwMarkerSize);
            
            if(pEndMarker->wMarkerId == pLoop->wEndMarker)
            {
                break;
            }

            pEndMarker = (LPAIFFMARKER)((LPBYTE)pEndMarker + sizeof(*pEndMarker) + pEndMarker->bNameLength);
        }

        if(i >= pMarkers->wMarkerCount)
        {
            DPF_ERROR("Can't find loop end marker");
            hr = E_FAIL;
        }
    }

    //
    // Double-check the marker validity
    //

    if(SUCCEEDED(hr))
    {
        pStartMarker->dwPosition = EndianSwapDword(pStartMarker->dwPosition);
        pEndMarker->dwPosition = EndianSwapDword(pEndMarker->dwPosition);

        if(pStartMarker->dwPosition >= pEndMarker->dwPosition)
        {
            DPF_ERROR("Loop end point less-than-or-equal-to start point");
            hr = E_FAIL;
        }
    }

    //
    // Success
    //

    if(SUCCEEDED(hr))
    {
        *pdwLoopStart = pStartMarker->dwPosition;
        *pdwLoopLength = pEndMarker->dwPosition - pStartMarker->dwPosition;
    }

    //
    // Clean up
    //
    
    MEMFREE(pMarkers);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  ReadSample
 *
 *  Description:
 *      Reads data from the audio file.
 *
 *  Arguments:
 *      DWORD [in]: file position, in bytes.
 *      LPVOID [out]: data.
 *      DWORD [in]: data size.
 *      LPDWORD [out]: amount read.
 *
 *  Returns:
 *      HRESULT: result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveFile::ReadSample"

HRESULT  
CWaveFile::ReadSample
(
    DWORD                   dwPosition, 
    LPVOID                  pvBuffer, 
    DWORD                   dwBufferSize, 
    LPDWORD                 pdwRead
)
{                                   
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_DataChunk.Read(dwPosition, pvBuffer, dwBufferSize, &dwBufferSize);

    if(SUCCEEDED(hr) && (WAVELDR_FILETYPE_AIFF == m_dwFileType))
    {
        ConvertAiffPcm(pvBuffer, dwBufferSize);
    }

    if(SUCCEEDED(hr) && pdwRead)
    {
        *pdwRead = dwBufferSize;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Close
 *
 *  Description:
 *      Closes the object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveFile::Close"

void
CWaveFile::Close
(
    void
)
{
    DPF_ENTER();

    m_Stream.Close();

    MEMFREE(m_pwfxFormat);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ConvertAiffPcm
 *
 *  Description:
 *      Converts AIFF PCM to standard PCM.
 *
 *  Arguments:
 *      LPVOID [in]: wave data.
 *      DWORD [in]: wave data buffer size, in bytes.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveFile::ConvertAiffPcm"

void
CWaveFile::ConvertAiffPcm
(
    LPVOID                  pvSource,
    DWORD                   cbSource
)
{
    BYTE *                  pbSource;
    BYTE                    bTemp;

    DPF_ENTER();

    ASSERT(m_pwfxFormat);
    ASSERT(WAVE_FORMAT_PCM == m_pwfxFormat->wFormatTag);

    ConvertAiffPcm(pvSource, cbSource, m_pwfxFormat->wBitsPerSample);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ConvertAiffPcm
 *
 *  Description:
 *      Converts AIFF PCM to standard PCM.
 *
 *  Arguments:
 *      LPCSOUNDBANKMINIWAVEFORMAT [in]: format.
 *      LPVOID [in]: wave data.
 *      DWORD [in]: wave data buffer size, in bytes.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveFile::ConvertAiffPcm"

void
CWaveFile::ConvertAiffPcm
(
    LPVOID                  pvSource,
    DWORD                   cbSource,
    DWORD                   dwBitDepth
)
{
    BYTE *                  pbSource;
    WORD *                  pwSource;
    BYTE                    bTemp;

    DPF_ENTER();

    if(16 == dwBitDepth)
    {
        cbSource /= 2;
        
        for(pwSource = (WORD *)pvSource; cbSource; cbSource--, pwSource++)
        {
            *pwSource = EndianSwapWord(*pwSource);
        }
    }
    else
    {
        ASSERT(8 == dwBitDepth);
        
        for(pbSource = (BYTE *)pvSource; cbSource; cbSource--, pbSource++)
        {
            *pbSource = *pbSource + 0x80;
        }
    }

    DPF_LEAVE_VOID();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\common\waveldr.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       waveldr.h
 *  Content:    Wave file loader.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  06/08/00    dereks  Created.
 *
 ****************************************************************************/

#ifndef __WAVELDR_H__
#define __WAVELDR_H__

#include "macros.h"

#pragma warning(disable:4200)
#pragma pack(push, 1)

//
// Supported file types
//

enum
{
    WAVELDR_FILETYPE_WAVE = 0,
    WAVELDR_FILETYPE_AIFF,
};

//
// Supported RIFF chunk identifiers
//

enum
{
    WAVELDR_FOURCC_RIFF         = 'FFIR',
    WAVELDR_FOURCC_WAVE         = 'EVAW',
    WAVELDR_FOURCC_FORMAT       = ' tmf',
    WAVELDR_FOURCC_DATA         = 'atad',
    WAVELDR_FOURCC_WAVE_SAMPLE  = 'pmsw',
};

//
// Supported AIFF/AIFF-C chunk identifiers
//

enum
{
    WAVELDR_FOURCC_FORM         = 'MROF',
    WAVELDR_FOURCC_AIFF         = 'FFIA',
    WAVELDR_FOURCC_AIFFC        = 'CFIA',
    WAVELDR_FOURCC_AIFF_VERSION = 'REVR',
    WAVELDR_FOURCC_COMM         = 'MMOC',
    WAVELDR_FOURCC_SOUND        = 'DNSS',
    WAVELDR_FOURCC_NONE         = 'ENON',
    WAVELDR_FOURCC_INSTRUMENT   = 'TSNI',
    WAVELDR_FOURCC_MARKER       = 'KRAM'
};

//
// Supported AIFF-C version
//

#define WAVELDR_AIFFC_VERSION   0xA2805140

//
// RIFF header
//

BEGIN_DEFINE_STRUCT()
    DWORD   dwChunkId;
    DWORD   dwDataSize;
END_DEFINE_STRUCT(RIFFHEADER);

//
// Wave instrument data
//

#define WAVESAMPLE_OPTIONS_NOTRUNCATION     0x00000001
#define WAVESAMPLE_OPTIONS_NOCOMPRESSION    0x00000002

#define WAVESAMPLE_LOOPTYPE_FORWARD         0x00000000
#define WAVESAMPLE_LOOPTYPE_RELEASE         0x00000001

BEGIN_DEFINE_STRUCT()
    DWORD   dwSize;
    DWORD   dwLoopType;
    DWORD   dwLoopStart;
    DWORD   dwLoopLength;
END_DEFINE_STRUCT(WAVESAMPLE_LOOP);

BEGIN_DEFINE_STRUCT()
    DWORD           dwSize;
    WORD            wUnityNote;
    SHORT           nFineTune;
    LONG            lGain;
    DWORD           dwOptions;
    DWORD           dwSampleLoops;
    WAVESAMPLE_LOOP aLoops[0];
END_DEFINE_STRUCT(WAVESAMPLE);

//
// AIFF/AIFF-C format data
//

BEGIN_DEFINE_STRUCT()
    WORD    nChannels;
    DWORD   dwSampleCount;
    WORD    wBitsPerSample;
    WORD    wFrequencyExponent;
    DWORD   dwFrequencyMantissa;
    WORD    wReserved;
    DWORD   dwCompression;
END_DEFINE_STRUCT(AIFFFORMAT);

//
// AIFF/AIFF-C sound data header
//

BEGIN_DEFINE_STRUCT()
    DWORD   dwOffset;
    DWORD   dwBlockSize;
END_DEFINE_STRUCT(AIFFSOUNDHDR);

//
// AIFF/AIFF-C instrument data
//

#define AIFFLOOP_MODE_NOLOOPING 0x0000
#define AIFFLOOP_MODE_FORWARD   0x0001
#define AIFFLOOP_MODE_BACKWARD  0x0002

BEGIN_DEFINE_STRUCT()
    WORD    wPlayMode;
    WORD    wStartMarker;
    WORD    wEndMarker;
END_DEFINE_STRUCT(AIFFLOOP);

BEGIN_DEFINE_STRUCT()
    BYTE        bBaseNote;
    BYTE        bDetune;
    BYTE        bLowNote;
    BYTE        bHighNote;
    BYTE        bLowVelocity;
    BYTE        bHighVelocity;
    SHORT       nGain;
    AIFFLOOP    SustainLoop;
    AIFFLOOP    ReleaseLoop;
END_DEFINE_STRUCT(AIFFINSTRUMENT);

//
// AIFF/AIFF-C marker data
//

BEGIN_DEFINE_STRUCT()
    WORD        wMarkerId;
    DWORD       dwPosition;
    BYTE        bNameLength;
    char        szMarkerName[1];
END_DEFINE_STRUCT(AIFFMARKER);

BEGIN_DEFINE_STRUCT()
    WORD        wMarkerCount;
END_DEFINE_STRUCT(AIFFMARKERHDR);

//
// Chunk flags
//

#define RIFFCHUNK_FLAGS_VALID       0x00000001      // Is the chunk valid?

//
// File stream flags
//

#define FILESTREAM_FLAGS_ATTACHED   0x00000001      // Do we own the file handle?

#pragma pack(pop)

#ifdef __cplusplus

//
// Standard file stream
//

namespace WaveLoader
{
    class CStdFileStream
    {
    protected:
        HANDLE                  m_hFile;            // File handle
        DWORD                   m_dwFlags;          // Flags

    public:
        CStdFileStream(void);
        ~CStdFileStream(void);

    public:
        // Initialization
        HRESULT Open(LPCSTR pszFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes);
        void Attach(HANDLE hFile);
        void Close(void);

        // I/O
        HRESULT Read(LPVOID pvBuffer, DWORD dwBufferSize, LPDWORD pdwRead = NULL);
        HRESULT Write(LPCVOID pvBuffer, DWORD dwBufferSize, LPDWORD pdwWritten = NULL);
        HRESULT Seek(LONG lOffset, DWORD dwOrigin, LPDWORD pdwAbsolute = NULL);

        // Properties
        HRESULT GetLength(LPDWORD pdwLength);

    public:
        operator HANDLE(void);
    };

    __inline CStdFileStream::operator HANDLE(void)
    {
        return m_hFile;
    }
}

//
// RIFF chunk utility class
//

namespace WaveLoader
{
    class CRiffChunk
    {
        friend class CWaveFile;

    protected:
        CRiffChunk *            m_pParentChunk;                 // Parent chunk
        CStdFileStream *        m_pStream;                      // File stream
        DWORD                   m_dwChunkId;                    // Chunk identifier
        DWORD                   m_dwDataOffset;                 // Chunk data offset
        DWORD                   m_dwDataSize;                   // Chunk data size
        DWORD                   m_dwFlags;                      // Chunk flags

    public:
        CRiffChunk(void);
        ~CRiffChunk(void);

    public:
        // Initialization
        HRESULT Open(CRiffChunk *pParentChunk, CStdFileStream *pStream, DWORD dwChunkId);

        // Data
        HRESULT Read(DWORD dwOffset, LPVOID pvBuffer, DWORD dwBufferSize, LPDWORD pdwRead = NULL);

        // Chunk information
        DWORD GetChunkId(void);
        DWORD GetDataOffset(void);
        DWORD GetDataSize(void);
        BOOL IsValid(void);
    };

    __inline DWORD CRiffChunk::GetChunkId(void)
    {
        return m_dwChunkId;
    }

    __inline BOOL CRiffChunk::IsValid(void)
    {
        return !!(m_dwFlags & RIFFCHUNK_FLAGS_VALID);
    }

    __inline DWORD CRiffChunk::GetDataOffset(void)
    {
        return m_dwDataOffset;
    }

    __inline DWORD CRiffChunk::GetDataSize(void)
    {
        return m_dwDataSize;
    }
}

//
// Wave file utility class
//

namespace WaveLoader
{
    class CWaveFile
    {
    protected:
        CStdFileStream          m_Stream;           // File stream
        CRiffChunk              m_ParentChunk;      // Top-level chunk
        CRiffChunk              m_DataChunk;        // Data chunk
        DWORD                   m_dwFileType;       // File type
        LPWAVEFORMATEX          m_pwfxFormat;       // File format
    
    public:
        CWaveFile(void);
        ~CWaveFile(void);

    public:
        // Initialization
        HRESULT Open(LPCSTR pszFileName);
        HRESULT Open(HANDLE hFile);
        void Close(void);

        // File format
        HRESULT GetFormat(LPWAVEFORMATEX pwfxFormat, DWORD dwFormatSize, LPDWORD pdwRequired = NULL);
        HRESULT GetFormat(LPCWAVEFORMATEX *ppwfxFormat);

        // File data
        HRESULT ReadSample(DWORD dwPosition, LPVOID pvBuffer, DWORD dwBufferSize, LPDWORD pdwRead = NULL);
        void ConvertAiffPcm(LPVOID pvSource, DWORD cbSource);
        static void ConvertAiffPcm(LPVOID pvSource, DWORD cbSource, DWORD dwBitDepth);

        // File properties
        HRESULT GetFileType(LPDWORD pdwType);
        HRESULT GetDataOffset(LPDWORD pdwDataOffset);
        HRESULT GetDuration(LPDWORD pdwDuration);
        HRESULT GetLoopRegion(LPDWORD pdwLoopStart, LPDWORD pdwLoopLength);

    protected:
        // Initialization
        HRESULT Open(LPCSTR pszFileName, HANDLE hFile);
    
        // File format
        HRESULT GetWaveFormat(LPWAVEFORMATEX pwfxFormat, DWORD dwFormatSize, LPDWORD pdwRequired);
        HRESULT GetAiffFormat(LPWAVEFORMATEX pwfxFormat, DWORD dwFormatSize, LPDWORD pdwRequired);

        // Loop points
        HRESULT GetWaveLoopRegion(LPDWORD pdwLoopStart, LPDWORD pdwLoopLength);
        HRESULT GetAiffLoopRegion(LPDWORD pdwLoopStart, LPDWORD pdwLoopLength);
    };

    __inline HRESULT CWaveFile::Open(LPCSTR pszFileName)
    {
        return Open(pszFileName, NULL);
    }

    __inline HRESULT CWaveFile::Open(HANDLE hFile)
    {
        return Open(NULL, hFile);
    }

    __inline HRESULT CWaveFile::GetFileType(LPDWORD pdwType)
    {
        *pdwType = m_dwFileType;
        return S_OK;
    }

    __inline HRESULT CWaveFile::GetDataOffset(LPDWORD pdwDataOffset)
    {
        *pdwDataOffset = m_DataChunk.GetDataOffset();
        return S_OK;
    }

    __inline HRESULT CWaveFile::GetDuration(LPDWORD pdwDuration)
    {
        *pdwDuration = m_DataChunk.GetDataSize();
        return S_OK;
    }

    __inline HRESULT CWaveFile::GetFormat(LPCWAVEFORMATEX *ppwfxFormat)
    {
        *ppwfxFormat = m_pwfxFormat;
        return S_OK;
    }
}

using namespace WaveLoader;

#endif // __cplusplus

#endif // __WAVELDR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\AC3Dolby3.h ===
0xD01B40, 0x000652, 0x030172, 0x8C0B50, 0x20000B, 0x0D1002, 0x00064B, 0x0D1080, 0x00063B, 0x57F400, 0x000010, 0x300000, 0x0D1080, 0x000233, 0x44F400, 0x000000, 0x200045, 0x057400, 0x0D1080, 0x00063F, 0x00000C, 0x46F461, 0x000010, 0x230700, 0x06D910, 0x00000A, 0x50D97C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F461, 0x000010, 0x230700, 0x50D97C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x06D910, 0x00000D, 0x56D900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x06D910, 0x00000D, 0x5ED900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x56D900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x5ED900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x61F400, 0x000D12, 0x46F400, 0x0000FF, 0x06D810, 0x00000E, 0x0C1C90, 0x200056, 0x51D800, 0x219900, 0x0C1D91, 0x4CE900, 0x20004B, 0x0C1C90, 0x200056, 0x219900, 0x0C1D91, 0x4CE900, 0x20004B, 0x0C1E91, 0x21AE00, 0x0C1C11, 0x00000C, 0x61F41B, 0x000E12, 0x46F400, 0x0000FF, 0x204800, 0x06D810, 0x00000D, 0x21AE5E, 0x44F800, 0x21B900, 0x0C1ED0, 0x200042, 0x4CE900, 0x200043, 0x218F56, 0x219900, 0x0C1ED1, 0x4CE900, 0x20004B, 0x0C1E91, 0x21AE00, 0x0C1C11, 0x00000C, 0x000418, 0x000418, 0x000418, 0x00042A, 0x00042A, 0x00042A, 0x000425, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x00044E, 0x00044E, 0x00044E, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x22B100, 0x231900, 0x204800, 0x204900, 0x45F41B, 0x000040, 0x51F400, 0x000C00, 0x44D801, 0x06DC10, 0x000003, 0x44D8A6, 0x505901, 0x240000, 0x447000, 0x000492, 0x240000, 0x447000, 0x000491, 0x231000, 0x22B800, 0x74F400, 0x0003A5, 0x65F400, 0x000B32, 0x44F000, 0x000B7B, 0x46F400, 0x000032, 0x2244D0, 0x0C1D2E, 0x44F440, 0x000C1C, 0x200040, 0x219600, 0x390100, 0x0B72CE, 0x000F1A, 0x23C400, 0x220745, 0x027040, 0x232474, 0x57E844, 0x205800, 0x45E800, 0x05A40D, 0x47F400, 0x0000D1, 0x06CC10, 0x000009, 0x21EE6C, 0x029060, 0x20582E, 0x45E82B, 0x21BD7D, 0x4CED00, 0x202F40, 0x21CF00, 0x225400, 0x44F461, 0x000100, 0x07EC94, 0x47F044, 0x000491, 0x0AE480, 0x57700D, 0x000493, 0x05F408, 0x20EE6D, 0x05F458, 0x0140C4, 0x000040, 0x202913, 0x218700, 0x050C53, 0x47F400, 0x000180, 0x050C50, 0x218600, 0x23CE00, 0x014785, 0x05A40D, 0x20CE00, 0x20000D, 0x05F408, 0x20EE6D, 0x05F408, 0x0140C4, 0x000040, 0x202913, 0x218700, 0x050C03, 0x47F400, 0x000180, 0x44F000, 0x000493, 0x56F04D, 0x000492, 0x557000, 0x000493, 0x059404, 0x232E00, 0x717000, 0x000492, 0x200003, 0x05A414, 0x050C1E, 0x20000D, 0x05F408, 0x20EE6D, 0x05F41A, 0x0140C4, 0x000040, 0x202913, 0x218700, 0x050C15, 0x47F400, 0x000140, 0x050C12, 0x200071, 0x0140C4, 0x000080, 0x202913, 0x218700, 0x050C0C, 0x44F001, 0x00048F, 0x44F044, 0x00048E, 0x547001, 0x00048B, 0x477044, 0x000491, 0x547074, 0x00048A, 0x050C1B, 0x56F000, 0x00048B, 0x44F000, 0x00048D, 0x44F044, 0x00048F, 0x218601, 0x45F044, 0x00048A, 0x44F055, 0x00048C, 0x029050, 0x547061, 0x00048B, 0x44F044, 0x00048E, 0x218601, 0x477044, 0x000491, 0x44F055, 0x00048B, 0x029050, 0x547074, 0x00048A, 0x200045, 0x029040, 0x44F000, 0x000490, 0x4EDE4C, 0x0C1C85, 0x202914, 0x200055, 0x029050, 0x546A00, 0x220E00, 0x23C400, 0x205A45, 0x0596D7, 0x00000C, 0x56F000, 0x0004B7, 0x44F003, 0x0004A2, 0x05A407, 0x20EE00, 0x240064, 0x06CC10, 0x000002, 0x445900, 0x050C4D, 0x64F400, 0x000CBA, 0x66F400, 0x0004A5, 0x57DA00, 0x46F04C, 0x0004BF, 0x20005C, 0x20291B, 0x0140CE, 0x001FE0, 0x5EDD58, 0x200075, 0x027070, 0x21C564, 0x014184, 0x219E00, 0x56D800, 0x46F414, 0x00003F, 0x202913, 0x0C1ECA, 0x200055, 0x027050, 0x219C00, 0x06DE10, 0x00000B, 0x56D800, 0x7EEC14, 0x202913, 0x0C1ECA, 0x765955, 0x027050, 0x219C00, 0x56EE00, 0x014180, 0x546E00, 0x7EEC00, 0x765900, 0x56EE00, 0x014180, 0x546E71, 0x200065, 0x057799, 0x00000C, 0x60F400, 0x000B68, 0x70F000, 0x000B40, 0x57E800, 0x44F000, 0x000B7A, 0x20004C, 0x20000B, 0x05140C, 0x200013, 0x567000, 0x000B66, 0x567000, 0x000B67, 0x567000, 0x0004A4, 0x567000, 0x000B6E, 0x0D10C0, 0x000027, 0x200013, 0x21D800, 0x44F000, 0x000B70, 0x200045, 0x059404, 0x56F400, 0x000009, 0x21D800, 0x200005, 0x05F409, 0x200013, 0x567000, 0x000B66, 0x567000, 0x000B67, 0x567000, 0x0004A4, 0x050C13, 0x56F400, 0x000001, 0x567000, 0x000B66, 0x21EE00, 0x230400, 0x200044, 0x0C1C06, 0x280000, 0x567000, 0x000B67, 0x0C1D06, 0x230400, 0x200040, 0x567000, 0x0004A4, 0x21C400, 0x20004C, 0x56F000, 0x000B40, 0x44F400, 0x000005, 0x200045, 0x052413, 0x56F000, 0x000B9F, 0x44F000, 0x000B7A, 0x200044, 0x44F000, 0x000B53, 0x200044, 0x21D900, 0x577000, 0x000B6E, 0x200003, 0x059404, 0x200005, 0x05F402, 0x050C03, 0x232400, 0x208F00, 0x56F000, 0x000B70, 0x200003, 0x05F40A, 0x44F400, 0x000001, 0x447000, 0x000B66, 0x44F000, 0x000B67, 0x200040, 0x567000, 0x000B67, 0x00000C, 0x221100, 0x22B200, 0x46F469, 0x000002, 0x06D810, 0x000005, 0x56C900, 0x218F14, 0x200050, 0x545A00, 0x234E00, 0x234432, 0x230440, 0x240044, 0x05A404, 0x06CC10, 0x000002, 0x445A00, 0x22B000, 0x229100, 0x65F400, 0x000D0D, 0x75F400, 0xFFFFFE, 0x06DA10, 0x000007, 0xF0B800, 0xF0B8D0, 0xD0B8D2, 0x2000D2, 0x200022, 0x585900, 0x00000C, 0x05F420, 0xFFFFFF, 0x0461A0, 0x0462A0, 0x0464A0, 0x0465A0, 0x0466A0, 0x00F3B8, 0x44F400, 0x000000, 0x20004D, 0x05A40C, 0x44F400, 0x000010, 0x20004D, 0x0D104A, 0x00000F, 0x300000, 0x56F400, 0x000000, 0x57F400, 0xFFFFFF, 0x00000C, 0x200013, 0x300000, 0x56F400, 0x000000, 0x57F400, 0x000608, 0x00000C, 0x56F000, 0x000B96, 0x200003, 0x05741E, 0x56F000, 0x000B40, 0x2E0003, 0x052402, 0x014180, 0x567000, 0x000B89, 0x0D1080, 0x00038B, 0x44F400, 0x0007B0, 0x447000, 0x000B72, 0x0D1080, 0x000014, 0x56F000, 0x000B40, 0x2E0003, 0x052403, 0x0D1080, 0x000353, 0x0D1080, 0x00009D, 0x56F000, 0x000B96, 0x200003, 0x052403, 0x0D1080, 0x00019C, 0x200013, 0x21101B, 0x00000C, 0x00000C, 0x44F400, 0x000001, 0x447000, 0x000B6F, 0x56F01B, 0x000B40, 0x200003, 0x052402, 0x000009, 0x517000, 0x0004C0, 0x300200, 0x310100, 0x320100, 0x350200, 0x0B70C4, 0x000C08, 0x447000, 0x00048D, 0x0B71C4, 0x000C04, 0x447000, 0x00048C, 0x0B72C4, 0x000C14, 0x447000, 0x00048F, 0x0B75C4, 0x000C18, 0x447000, 0x000490, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x00004E, 0x280100, 0x507000, 0x0004C0, 0x300400, 0x0B70C4, 0x000C0C, 0x447000, 0x00048E, 0x44F400, 0xFF8000, 0x447000, 0x00048A, 0x44F400, 0xFF8000, 0x447000, 0x00048B, 0x22C400, 0x46F400, 0x0000B5, 0x44F4D0, 0x0000FA, 0x0C1D2E, 0x200040, 0x219000, 0x22C400, 0x46F400, 0x0000B5, 0x44F4D0, 0x0000FA, 0x0C1D2E, 0x200040, 0x219500, 0x22C400, 0x46F400, 0x000032, 0x44F4D0, 0x000000, 0x0C1D2E, 0x200040, 0x219A00, 0x380000, 0x56F400, 0x000BA5, 0x22C400, 0x200040, 0x219100, 0x74E100, 0x76E100, 0x320000, 0x667000, 0x000B41, 0x0D03D7, 0x66F000, 0x000B41, 0x56F400, 0x0004C1, 0x22C400, 0x200040, 0x219000, 0x626000, 0x56F400, 0x000494, 0x22C400, 0x200040, 0x219000, 0x44F000, 0x00048A, 0x446000, 0x56F400, 0x000499, 0x22C400, 0x200040, 0x219000, 0x44F000, 0x00048B, 0x446000, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A41C, 0x280100, 0x507000, 0x0004C0, 0x300400, 0x0B70C4, 0x000C0C, 0x447000, 0x00048E, 0x44F400, 0xFF8000, 0x447000, 0x00048A, 0x44F400, 0xFF8000, 0x447000, 0x00048B, 0x60F400, 0x000483, 0x65F400, 0x000483, 0x72F400, 0x0004B8, 0x380000, 0x3C0700, 0x3E0700, 0x320000, 0x0D03D7, 0x00000C, 0x56F000, 0x000B40, 0x200003, 0x052404, 0x240000, 0x447000, 0x000B6E, 0x340000, 0x20001B, 0x44F000, 0x000B97, 0x06C410, 0x000003, 0x014188, 0x014188, 0x014188, 0x56F000, 0x000B7D, 0x200003, 0x052402, 0x014188, 0x56F000, 0x000B4A, 0x44F403, 0x000008, 0x05A402, 0x200048, 0x014188, 0x56F000, 0x000B89, 0x200003, 0x05A402, 0x014188, 0x56F000, 0x000B7D, 0x014285, 0x052407, 0x014188, 0x56F000, 0x000B40, 0x44F403, 0x000004, 0x202A48, 0x44F000, 0x000B97, 0x06C410, 0x000002, 0x014288, 0x56F000, 0x000B7E, 0x200003, 0x05A402, 0x014188, 0x56F400, 0x000B8A, 0x240000, 0x200040, 0x219000, 0x44F000, 0x000B97, 0x06C410, 0x000006, 0x56D800, 0x200003, 0x05A402, 0x014688, 0x000000, 0x60F400, 0x000B8A, 0x61F400, 0x000B91, 0x46F400, 0x000007, 0x44F000, 0x000B97, 0x06C410, 0x00000A, 0x56D800, 0x44D903, 0x05A406, 0x014488, 0x2000D0, 0x0C1D2E, 0x200018, 0x014288, 0x000000, 0x56F000, 0x000B7E, 0x200003, 0x05A408, 0x56F000, 0x000B8F, 0x44F403, 0x00000E, 0x05A403, 0x014488, 0x200048, 0x014188, 0x56F000, 0x000B90, 0x200003, 0x05A406, 0x014288, 0x014288, 0x014288, 0x014288, 0x014388, 0x014188, 0x56F000, 0x000B6F, 0x200003, 0x05A40E, 0x014688, 0x44F000, 0x000B97, 0x06C410, 0x