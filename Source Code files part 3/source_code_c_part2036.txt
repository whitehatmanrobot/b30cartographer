r.Close();

			return;
		}

		/// <summary>
		/// Calls SetInstanceDisplayName for each w3wp.exe process in the process map from a single machine.
		/// </summary>
		private static void WriteMappingsToDB(string MachineName, HybridDictionary processMap,ref SqlConnection XOnlineTestConn)
		{
			foreach (int PID in processMap.Keys)
			{
				InstanceNameAndAppPoolIDMap Mapping = (InstanceNameAndAppPoolIDMap)processMap[PID];
				SetInstanceDisplayName(MachineName, Mapping.AppPoolID, Mapping.InstanceName,ref XOnlineTestConn);
			}
		}

		/// <summary>
		/// Calls the main function for getting instance names and app pool IDs then stores the results in the DB.
		/// Cycles until instructed to shutdown.
		/// </summary>
		public static void InstanceMapperThread()
		{
			SqlConnection XOnlineTestConn;
			if(openPerfDBConn(out XOnlineTestConn) == false)
			{
				XBLPerfLogEvent.LogWarning("InstanceMapperThread exits after retry connection to perfdb for 1 hour");
				return;
			}

			// establish conection to perfDB successfully
			try
			{
				bool Exit = false;
				while (!Exit)
				{
					DateTime StartDT = DateTime.Now;

					string[] MachineNames = GetWebServerMachineNames(ref XOnlineTestConn);

					// Get the data
					InstanceNameAndAppPoolIDMapper oMapper = new InstanceNameAndAppPoolIDMapper();
					HybridDictionary MachineMaps = oMapper.GetInstanceNameAndAppPoolIDMaps(MachineNames);

					// Spew it out
					foreach (string MachineName in MachineMaps.Keys)
					{
						HybridDictionary ProcessMap = (HybridDictionary)MachineMaps[MachineName];
						WriteMappingsToConsole(MachineName, ProcessMap);
						try
						{
							WriteMappingsToDB(MachineName, ProcessMap, ref XOnlineTestConn);
						}
						catch(Exception e)
						{
							XBLPerfLogEvent.LogError("InstanceMapperThread:unexpected Exception in WriteMappingsToDB: " + e.Message + e.StackTrace,6,1);
						}
					}

					// Wait for another cycle or the exit signal
					int SleepSecs = SecsPerCycle - DateTime.Now.Subtract(StartDT).Seconds;
					if (SleepSecs < 0)
					{
						SleepSecs = 0;
					}
					Exit = XBLPerfLogMain.shutdown.WaitOne(SleepSecs * 1000, false);
				}
			}
			catch(Exception e)
			{
				XBLPerfLogEvent.LogError("InstanceMapperThread exits due to unexpected Exception: " + e.Message + e.StackTrace,6,1);
			}
			finally
			{
				if(XOnlineTestConn != null)
				{
					XOnlineTestConn.Close();
					XOnlineTestConn = null;
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\Report\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace Report 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.components = new System.ComponentModel.Container();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\SyncSqlProfileCounters\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\XBLPerfLogTool\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//        When specifying the KeyFile, the location of the KeyFile should be
//        relative to the "project output directory". The location of the project output
//        directory is dependent on whether you are working with a local or web project.
//        For local projects, the project output directory is defined as
//       <Project Directory>\obj\<Configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//        For web projects, the project output directory is defined as
//       %HOMEPATH%\VSWebCache\<Machine Name>\<Project Directory>\obj\<Configuration>.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\SyncSqlProfileCounters\ProfileDB.cs ===
using System;
using System.Data;
using System.Data.SqlClient;

namespace SyncSqlProfileCounters
{
	/// <summary>
	/// Summary description for ProfileDB.
	/// </summary>
	public class ProfileDB
	{
		static string myConnString = "Data Source=10.20.2.61 ;Initial Catalog=Profile;Integrated Security =true";
		

		public ProfileDB()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		public static  void  PushProfileData( DateTime starttime)
		{
			DateTime EndTime = starttime.AddMinutes(30);
			string mySelectQuery = "SELECT * FROM [Profile].[dbo].[spMetaData] where StartTime> '"+starttime.ToString()+"' and StartTime <= '"+EndTime.ToString()+"'";

			SqlConnection _PerfCnt =null;
			try
			{
				
				_PerfCnt= new SqlConnection(myConnString); 
				_PerfCnt.Open();


				SqlCommand myCommand = new SqlCommand(mySelectQuery, _PerfCnt);
				myCommand.CommandType = CommandType.Text;
				SqlDataReader myReader = myCommand.ExecuteReader();
				while(myReader.Read()) 
				{
					PerfDB.InsertCounterData(myReader.GetString(0),myReader.GetString(11),myReader.GetDateTime(1),myReader.GetInt32(6),myReader.GetInt32(4),myReader.GetInt32(8),myReader.GetInt32(10));
					
				}
				myReader.Close();

			}
			finally
			{
				if(_PerfCnt!=null)
				{
					_PerfCnt.Close();
					_PerfCnt=null;
				}

			}
			
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\SyncSqlProfileCounters\main.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;

namespace SyncSqlProfileCounters
{
	public class SPCounters
	{
		public int  Count;
		public DateTime LastEntry;

	}

	public class SPKey
	{
		string SpName;
		string ServerName;
		public SPKey(string name ,string server)
		{
			SpName=name;
			ServerName=server;
		}
		public override bool Equals(object obj)
		{
			return (SpName == ((SPKey)obj).SpName)
				&& (ServerName == ((SPKey)obj).ServerName);
		}
        
		public override int GetHashCode()
		{
			string tmp =(SpName + ServerName);
			return tmp.GetHashCode();
		}

	}

	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class SyncSqlProfileData
	{
		public static Hashtable SpMAp = new Hashtable();
		public static DateTime StartTime= DateTime.MinValue;
		public static Guid GUID ;
		public static DateTime StopTime= DateTime.MinValue;
		public static SyncStatus SyncState ;
		[STAThread]
		static void Main(string[] args)
		{
			System.Console.WriteLine("This program sync SQL profile data with Perf counter collection system.");

			while(true)
			{
				SyncSqlProfileData.Run();
				System.Console.WriteLine("Last data Synced at "+DateTime.Now);
				//System.Threading.Thread.Sleep(2600000);
				System.Threading.Thread.Sleep(600000);
			}

		}

		static void Run()
		{
			StartTime = PerfDB.GetCurrentRunStartTime();
			SyncState = PerfDB.GetCurrentSyncStatus();

			if(StartTime.Ticks >DateTime.MinValue.Ticks)
			{
				// start reading rows from Profile DB in interval of 5 minutes and update in Perfdb

				if(SyncState.Start.Ticks == DateTime.MinValue.Ticks)
				{
					SyncState.Start=StartTime;
					SyncState.guid=GUID;

					// this the first time sync is running 
					while(StartTime.Ticks<=StopTime.Ticks )
					{
						ProfileDB.PushProfileData(StartTime);
						StartTime = StartTime.AddMinutes(30);
						
					}
					SyncState.End=StopTime;
					PerfDB.UpdateCurrentSyncStatus(SyncState);
				}
				else
				{
					StartTime= SyncState.End;
					// we have synced before.
					while(StartTime.Ticks<=StopTime.Ticks )
					{
						ProfileDB.PushProfileData(StartTime);
						StartTime = StartTime.AddMinutes(30);
						
					}
					SyncState.End=StopTime;
					PerfDB.UpdateCurrentSyncStatus(SyncState);

				}
			}

		}
		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\XBLPerfLogTool\CounterInfo.cs ===
using System;
using System.Collections;

namespace XBLPerfLogTool
{

    enum AggType 
    {
        Normal = 0,
        Sum = 1,
        Average = 2
    };

    /// <summary>
    /// Summary description for AggCounterInfo.
    /// </summary>
    public class AggCounterInfo : CounterInfoBase
    {
        public ArrayList MachineNames = null;
        public string AggCounterName = null;

        public AggCounterInfo() : base()
        {
            MachineNames = new ArrayList(8);
            AggregateType = (int)AggType.Sum;
            AggCounterName = null;
        }

        public AggCounterInfo(
            ArrayList machines,
            string objectName,
            string counterName,
            int counterType,
            int defaultScale,
            string instanceName,
            string displayInstanceName,
            string aggCounterName,
            int aggCounterType,
            int catID,
            int compID,
            int counterID) :
            base(objectName, counterName, counterType, defaultScale, instanceName, displayInstanceName, (int)AggType.Normal, catID, compID, counterID)
        {
            if (machines == null)
                MachineNames = new ArrayList(8);
            else
                MachineNames = machines;
            AggregateType = aggCounterType;
            AggCounterName = aggCounterName;
        }

        public override string ToString()
        {
            string counterName = "";
            // note MachineName includes prefix "\\" at this point
			if (InstanceName != null && InstanceName.StartsWith("w3wp"))
			{
				InstanceName = "testthis";
			}
            counterName = "...\\" + ObjectName + "[" + InstanceName + "]" + "\\" + AggCounterName;
            return counterName;
        }

        public string ToStringMachines()
        {
            string counterName = "";
            string machineNames = "";
            bool first = true;
            foreach (object o in MachineNames)
            {
                if (first)
                    machineNames = (string)o;
                else
                    machineNames = machineNames + ", " + (string)o;
                first = false;
            }
            //counterName = machineNames + "\\" + ObjectName + "[" + InstanceName + "]" + "\\" + AggCounterName;
            counterName = machineNames;
            return counterName;
        }
    }

    /// <summary>
    /// Summary description for RealCounterInfo.
    /// </summary>
    public class RealCounterInfo : CounterInfoBase
    {
        public string MachineName = null;
   
        public RealCounterInfo() : base()
        {
            MachineName = null;
            AggregateType = (int)AggType.Normal;
        }

        public RealCounterInfo(
            string machineName,
            string objectName,
            string counterName,
            int counterType,
            int defaultScale,
            string instanceName,
            string displayInstanceName,
            int catID,
            int compID,
            int counterID) :
            base(objectName, counterName, counterType, defaultScale, instanceName, displayInstanceName, (int)AggType.Normal, catID, compID, counterID)
        {
            MachineName = machineName;
            AggregateType = (int)AggType.Normal;
        }

        public override string ToString()
        {
            string counterName = "";
			// note MachineName includes prefix "\\" at this point
			if (DisplayInstanceName != null)
			{
				counterName = MachineName + "\\" + ObjectName + "[" + DisplayInstanceName + "]" + "\\" + CounterName;
			}
			else
			{
				counterName = MachineName + "\\" + ObjectName + "[" + InstanceName + "]" + "\\" + CounterName;
			}
            return counterName;
        }
    }


    /// <summary>
	/// Summary description for CounterInfoBase.
	/// </summary>
    abstract public class CounterInfoBase
    {
        public string ObjectName = null;
        public string CounterName = null;
        public int CounterType = 0;
        public int DefaultScale = 0;
        public string InstanceName = null;
        public string DisplayInstanceName = null;
        public int AggregateType = 0;
        public int CatID = 0;
        public int CompID = 0;

        public int CounterID = 0;  // from database

        public CounterInfoBase()
        {
            ObjectName = null;
            CounterName = null;
            CounterType = 0;
            DefaultScale = 0;
            InstanceName = null;
            DisplayInstanceName = null;
            AggregateType = 0;
            CatID = 0;
            CompID = 0;
            CounterID = 0;
        }

        public CounterInfoBase(
            string objectName,
            string counterName,
            int counterType,
            int defaultScale,
            string instanceName,
            string displayInstanceName,
            int aggregateType,
            int catID,
            int compID,
            int counterID)
        {
            ObjectName = objectName;
            CounterName = counterName;
            CounterType = counterType;
            DefaultScale = defaultScale;
            InstanceName = instanceName;
            DisplayInstanceName = displayInstanceName;
            AggregateType = aggregateType;
            CatID = catID;
            CompID = compID;
            CounterID = counterID;
        }

        abstract new public string ToString();
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\Service\XBLPerfLog.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.Globalization;

namespace XBLPerfLog
{
    /// <summary>
    /// Summary description for Class1.
    /// </summary>
    class XBLPerfLogMain
    {
        public static string            sqlIP;
        public static int               updateInterval;
        public static Guid              guid = Guid.NewGuid();  // the Guid in the DisplayToID table

        public static Hashtable         machineHT = new Hashtable();
        public static Hashtable         aggCounterHT = new Hashtable();
		public static ReaderWriterLock  htLock = new ReaderWriterLock();

		public static CounterValueQueue globalQueue = new CounterValueQueue();
		public static ManualResetEvent	dataAvailable = new ManualResetEvent(false);
		public static Thread			writeDataThread;
		public static Thread			instanceMapperThread;

		// will be used by each machine thread:increment by 1 when a machine finishes collecting 
		// one round of it's own counters
		public static int				numMachineCollected = 0;
		public static int				recordIndex = 1;
		public static Mutex				indexMutex = new Mutex();

		public static ManualResetEvent	shutdown = new ManualResetEvent(false);

        public static void AddCounterToTable(SqlDataReader sqlReader)
        {
            XBLPerfCounter  xpc = new XBLPerfCounter();

            xpc.counterID       = (int)sqlReader.GetInt32(0);
            xpc.machineName     = (string)sqlReader.GetString(1);
            xpc.objectName      = (string)sqlReader.GetString(2);
            xpc.counterName     = (string)sqlReader.GetString(3);
            xpc.instanceName        = (string)sqlReader.GetString(4);               

            // create PerformanceCounter object in advance so that we don't
            // need to repeatedly create it during collection.
            xpc.pc = new PerformanceCounter();
            xpc.pc.CategoryName = xpc.objectName;
            xpc.pc.CounterName = xpc.counterName;
            xpc.pc.InstanceName = xpc.instanceName;
            xpc.pc.MachineName = xpc.machineName.Substring(2);	// remove leading \\ from machineName

            if(machineHT.ContainsKey(xpc.machineName) == false)
            {
                XBLServerBox    box = new XBLServerBox();
                box.machineName = xpc.machineName;
                box.counterList.Add(xpc);
                machineHT.Add(xpc.machineName, box);
            }
            else    // only add the counter for a specific machine
                ((XBLServerBox)machineHT[xpc.machineName]).counterList.Add(xpc);
        }

        public static void AddAggCounterToTable(SqlDataReader sqlReader)
        {
            int counterID = (int)sqlReader.GetInt32(0);
            string counterName = (string)sqlReader.GetString(1);
		    string machineName = sqlReader.GetString(2);
            int realCounterId = (int)sqlReader.GetInt32(3);

            if(aggCounterHT.ContainsKey(counterID)==false)
            {
                byte type = sqlReader.GetByte(4);
                AggType aggType;
                if(type == 1)
                    aggType = AggType.SUM;
                else if (type == 2)
                    aggType = AggType.AVG;
                else
                    throw new Exception("Aggregated counter type of " + type +
                        " is not supported. Counter name: " + counterName);

                XBLAggPerfCounter   apc = new XBLAggPerfCounter(aggType);
                apc.counterID = counterID;
                apc.counterName = counterName;

				aggCounterHT.Add(apc.counterID, apc);

				XBLPerfCounter counter = FindRealCounter(machineName, realCounterId);
				if(counter != null)
				{
					apc.realCounters.Add(counter);
				}
				else
				{	
					XBLPerfLogEvent.LogError("AddAggCounterToTable: " + machineName + "\\" + realCounterId  
						+ " for aggregated counter " + counterName + " does not exist",8,3);
				}
            }
            else 
            {
                XBLPerfCounter counter = FindRealCounter(machineName, realCounterId);
				if(counter != null)
				{
					((XBLAggPerfCounter)aggCounterHT[counterID]).realCounters.Add( counter );
				}
				else
				{
					XBLPerfLogEvent.LogError("AddAggCounterToTable: " + machineName + "\\" + realCounterId  
						+ " for aggregated counter " + counterName + " does not exist",8,3);
				}
            }
        }

        public static XBLPerfCounter FindRealCounter(string machineName, int counterID)
        {
            ArrayList counterList = ((XBLServerBox)machineHT[machineName]).counterList;
            int listSize = counterList.Count;
            for (int i = 0; i < listSize; ++i)
            {
                if (((XBLPerfCounter)counterList[i]).counterID==counterID )
                {
                    return (XBLPerfCounter)counterList[i];
                }
            }
            return null;
        }

		// p_GetNewInstances not only return old counters with instanceName changes, 
		// but also return any newly added counters, but we will ignore since it will 
		// be picked up by GetNewRealCounters sp
		public static void UpdateInstances(SqlDataReader newInstanceReader, ref bool lockAcquired)
		{
			int				tempCounterID;
			string			tempMachineName, tempInstanceName;
			PerformanceCounter	temp;

			while(newInstanceReader.Read())
			{
				tempCounterID = (int)newInstanceReader.GetInt32(0);
				tempMachineName = (string)newInstanceReader.GetString(1);
				tempInstanceName = (string)newInstanceReader.GetString(2);

				if(lockAcquired == false)
				{
					htLock.AcquireWriterLock(-1);
					lockAcquired = true;
				}

				if(tempMachineName == @"\\Aggregate")
					continue;

				if(machineHT.ContainsKey(tempMachineName) == true)
				{
					ArrayList	cl = ((XBLServerBox)machineHT[tempMachineName]).counterList;
					int c = cl.Count;
					for(int i = 0; i < c; i++)
					{
						if(((XBLPerfCounter)cl[i]).counterID == tempCounterID)
						{
							// this is an instance change
							((XBLPerfCounter)cl[i]).instanceName = tempInstanceName;
							((XBLPerfCounter)cl[i]).pc.InstanceName = tempInstanceName;
							temp = ((XBLPerfCounter)cl[i]).pc;
							XBLPerfLogEvent.LogWarning("UpdateInstances: "
													+ tempCounterID+":"+ temp.MachineName+"\\"+temp.CategoryName+"\\"
													+ temp.InstanceName+"\\"+ temp.CounterName 
													+ ";check why instance changed!");
							break;
						}
					}
				}
				else
				{
					XBLPerfLogEvent.LogError("Machine: " + tempMachineName + 
											" returned in p_GetNewInstances is invalid");
				}
			}
		}

		public static void AddNewCounters(SqlDataReader newCounterReader, ref bool lockAcquired)
		{
			while(newCounterReader.Read())
			{
				XBLPerfCounter  xpc  = new XBLPerfCounter();

				xpc.counterID        = (int)newCounterReader.GetInt32(0);
				xpc.machineName      = (string)newCounterReader.GetString(1);
				xpc.objectName       = (string)newCounterReader.GetString(2);
				xpc.counterName      = (string)newCounterReader.GetString(3);
				xpc.instanceName     = (string)newCounterReader.GetString(4);               

				xpc.pc = new PerformanceCounter();
				xpc.pc.CategoryName = xpc.objectName;
				xpc.pc.CounterName = xpc.counterName;
				xpc.pc.InstanceName = xpc.instanceName;
				xpc.pc.MachineName = xpc.machineName.Substring(2);	// remove leading \\ from machineName
        
				if(lockAcquired == false)
				{
					htLock.AcquireWriterLock(-1);
					lockAcquired = true;
				}

				((XBLServerBox)(XBLPerfLogMain.machineHT[xpc.machineName])).counterList.Add(xpc);
			}
		}

		public static void AddNewAggCounters(SqlDataReader newAggCounterReader, ref bool lockAcquired)
		{
			Hashtable	tempHt = new Hashtable();
			while(newAggCounterReader.Read())
			{
				int counterID = (int)newAggCounterReader.GetInt32(0);
				string counterName = (string)newAggCounterReader.GetString(1);
				string machineName = newAggCounterReader.GetString(2);
				int realCounterId = (int)newAggCounterReader.GetInt32(3);
				byte type = newAggCounterReader.GetByte(4);
				AggType aggType;
				if(type == 1)
					aggType = AggType.SUM;
				else if (type == 2)
					aggType = AggType.AVG;
				else
				{
					XBLPerfLogEvent.LogError("AddNewAggCounters: Aggregated counter type of " + type + 
											" is not supported. Counter name: " + counterName );
					continue;
				}

				if(lockAcquired == false)
				{
					htLock.AcquireWriterLock(-1);
					lockAcquired = true;
				}
				if(tempHt.Contains(counterID) == false)
				{
					XBLAggPerfCounter	apc = new XBLAggPerfCounter(aggType);
					apc.counterID = counterID;
					apc.counterName = counterName;

					aggCounterHT.Remove(counterID);
					tempHt.Add(counterID, counterID);
					aggCounterHT.Add(counterID,apc);
				}

				XBLPerfCounter		counter = FindRealCounter(machineName, realCounterId);
				if(counter == null)
				{
					XBLPerfLogEvent.LogError("CheckChangesThread: " + machineName + "\\" 
						+ realCounterId + " for aggregated counter " + counterName + " does not exist");
				}
				else
				{
					((XBLAggPerfCounter)aggCounterHT[counterID]).realCounters.Add(counter);
				}
			}
		}

		
		private static void RemoveRealCounters(SqlDataReader removedRealCounterReader, ref bool lockAcquired)
		{
			while(removedRealCounterReader.Read())
			{
				int		counterID	= (int)removedRealCounterReader.GetInt32(0);
				string	machineName = (string)removedRealCounterReader.GetString(1);
				XBLPerfCounter	xpc = FindRealCounter(machineName, counterID);

				if(xpc == null)
				{
					XBLPerfLogEvent.LogError("RemoveRealCounters: " + machineName + "\\" +
						counterID + " does not exist");
				}
				else
				{
					if(lockAcquired == false)
					{
						htLock.AcquireWriterLock(-1);
						lockAcquired = true;
					}

					((XBLServerBox)(XBLPerfLogMain.machineHT[xpc.machineName])).counterList.Remove(xpc);
				}
			}
		}

		private static void RemoveAggCounters(SqlDataReader removedAggCounterReader, ref bool lockAcquired)
		{
			while(removedAggCounterReader.Read())
			{
				int counterID = (int)removedAggCounterReader.GetInt32(0);

				if(lockAcquired == false)
				{
					htLock.AcquireWriterLock(-1);
					lockAcquired = true;
				}
				
				aggCounterHT.Remove(counterID);
			}
		}

		public static void WriteDataThread()
        {
			SqlConnection           mySqlConn = null;
            SqlCommand              myCommand = new SqlCommand();
            SqlParameter            ret = null;
            CounterValueQueue       localValueQueue = new CounterValueQueue();
            XBLPerfCounterValue     pcv;
			bool					connected = false;

			WaitHandle[]			events = new WaitHandle[2];
			events[0] = dataAvailable;
			events[1] = shutdown;

			try
			{
				while(true)
				{
					Debug.Assert((localValueQueue.head==null) && (localValueQueue.tail==null));

					// wait for data or shutdown signal
					int index = 0;
					do 
					{
						index = WaitHandle.WaitAny(events, 60*60*1000, false); 
						if (index==WaitHandle.WaitTimeout)
						{
							XBLPerfLogEvent.LogWarning("Timed out (1 hour) waiting for data.");
						}
						else 
						{
							break;
						}
					} while (true);

					if (index==1) 
					{
						return;
					}

					// move all the content in the globalQueue into WriteDataThread's 
					// local queue to minimize lock contention
					lock(globalQueue)
					{
						localValueQueue.head = globalQueue.head;
						localValueQueue.tail = globalQueue.tail;
						globalQueue.head = globalQueue.tail = null;
						dataAvailable.Reset();
					}

					// write data
					pcv = localValueQueue.Dequeue();
					while(pcv != null)
					{
						if (!connected) 
						{
							// open connection to perfDB first
							openPerfDBConn(out mySqlConn);
							connected = true;
		
							myCommand = new SqlCommand();
							myCommand.Connection = mySqlConn;
							myCommand.CommandType = CommandType.StoredProcedure;
							myCommand.CommandText = "p_InsertCounterData";
						}

						myCommand.Parameters.Clear();

						ret = new SqlParameter();
						ret.Direction = ParameterDirection.ReturnValue;

						myCommand.Parameters.Add(ret);
						myCommand.Parameters.Add("@GUID",SqlDbType.UniqueIdentifier).Value  = XBLPerfLogMain.guid;
						myCommand.Parameters.Add("@CounterID",SqlDbType.Int).Value  = pcv.counterID;
						myCommand.Parameters.Add("@RecordIndex",SqlDbType.Int).Value = pcv.recordIndex;
						myCommand.Parameters.Add("@CounterDateTime",SqlDbType.VarChar).Value = pcv.counterDateTime;
						myCommand.Parameters.Add("@CounterValue",SqlDbType.Float).Value = pcv.counterValue;
						myCommand.Parameters.Add("@FirstValueA",SqlDbType.Int).Value = pcv.firstValueA;
						myCommand.Parameters.Add("@FirstValueB",SqlDbType.Int).Value = pcv.firstValueB;
						myCommand.Parameters.Add("@SecondValueA",SqlDbType.Int).Value = pcv.secondValueA;
						myCommand.Parameters.Add("@SecondValueB",SqlDbType.Int).Value = pcv.secondValueB;
						myCommand.Parameters.Add("@MultiCount",SqlDbType.Int).Value = -1;
						myCommand.Parameters.Add("@MachineCount",SqlDbType.Int).Value = pcv.validCount;

						try
						{
							myCommand.ExecuteNonQuery();
							if((int)ret.Value != 0)
							{
								XBLPerfLogEvent.LogError("WriteDataThread:p_InsertCounterData failed for " + 
									pcv.counterID + "at " + pcv.counterDateTime + ":" + pcv.recordIndex);
							}
							pcv = localValueQueue.Dequeue();
						}
						catch (SqlException e)
						{
							XBLPerfLogEvent.LogError("SqlException in WriteDataThread for: " + pcv.counterID +
								"(recordIndex="+pcv.recordIndex+"):"+ e.Message + e.StackTrace,5,1);								
							if((mySqlConn.State == ConnectionState.Closed) || (mySqlConn.State == ConnectionState.Broken))
							{
								connected = false;
							}
							else
							{
								pcv = localValueQueue.Dequeue();
							}
						}
					}
				}
			}
			catch(Exception e)
			{
				System.Windows.Forms.MessageBox.Show("WriteDataThread Thread failed:"+e);
				XBLPerfLogEvent.LogError("WriteDataThread Exits: Unexpected exception caught:"+e,1,1);
			}
			finally
			{
				if(mySqlConn != null)
				{
					mySqlConn.Close();
					mySqlConn = null;
				}
			}
        }

        public static void CheckChangesThread()
        {
            SqlConnection       mySqlConn = null;
			bool				lockAcquired = false;
			SqlParameter		ret = null;
			SqlCommand          myCommand1 = new SqlCommand(), myCommand2 = new SqlCommand(), 
								myCommand3 = new SqlCommand(), myCommand4 = new SqlCommand(), myCommand5 = new SqlCommand();
			SqlDataReader       newCounterReader = null, newAggCounterReader = null, 
								newInstanceReader = null, removedRealCounterReader = null,
								removedAggCounterReader = null;
			bool				exit = false;

			try
			{
				bool	connected = false;
				while(exit == false)
				{
					// check instance changes every 15 minute
					Thread.Sleep(15*60*1000);

					if(!connected)
					{
						openPerfDBConn(out mySqlConn);
						connected = true;
					}

					myCommand1.Connection = mySqlConn;
					myCommand1.CommandType = CommandType.StoredProcedure;
					myCommand1.CommandText = "p_GetNewInstances";

					myCommand2.Connection = mySqlConn;
					myCommand2.CommandType = CommandType.StoredProcedure;
					myCommand2.CommandText = "p_GetNewRealCounter";

					myCommand3.Connection = mySqlConn;
					myCommand3.CommandType = CommandType.StoredProcedure;
					myCommand3.CommandText = "p_GetNewAggregateCounters";

					myCommand4.Connection = mySqlConn;
					myCommand4.CommandType = CommandType.StoredProcedure;
					myCommand4.CommandText = "p_GetDeletedRealCounter";

					myCommand5.Connection = mySqlConn;
					myCommand5.CommandType = CommandType.StoredProcedure;
					myCommand5.CommandText = "p_GetDeletedAggCounters";

					try
					{
						ret = new SqlParameter();
						ret.Direction = ParameterDirection.ReturnValue;
						myCommand1.Parameters.Clear();
						myCommand1.Parameters.Add(ret);
						newInstanceReader = myCommand1.ExecuteReader();

						// p_GetNewInstances: will return new counters also, but will ignore it
						// since it will be picked up when calling the p_GetNewRealCounters
						UpdateInstances(newInstanceReader, ref lockAcquired);					
						newInstanceReader.Close();
						newInstanceReader = null;
						if((int)ret.Value != 0)
						{
							XBLPerfLogEvent.LogError("Calling p_GetNewInstances failed");
						}

						// check every 15 minutes for newly added/removed counters
						ret = new SqlParameter();
						ret.Direction = ParameterDirection.ReturnValue;
						myCommand2.Parameters.Clear();
						myCommand2.Parameters.Add(ret);
						newCounterReader = myCommand2.ExecuteReader();
					
						AddNewCounters(newCounterReader, ref lockAcquired);
					
						newCounterReader.Close();
						newCounterReader = null;
						if((int)ret.Value != 0)
						{
							XBLPerfLogEvent.LogError("Calling p_GetNewRealCounter failed");
						}

						// check aggregatedCounters changes (adding/removing boxes or adding completely new agg)
						ret = new SqlParameter();
						ret.Direction = ParameterDirection.ReturnValue;
						myCommand3.Parameters.Clear();
						myCommand3.Parameters.Add(ret);
						newAggCounterReader = myCommand3.ExecuteReader();
					
						AddNewAggCounters(newAggCounterReader, ref lockAcquired);
					
						newAggCounterReader.Close();
						newAggCounterReader = null;
						if((int)ret.Value != 0)
						{
							XBLPerfLogEvent.LogError("Calling p_GetNewAggregateCounters failed");
						}

						// check removed real counters
						ret = new SqlParameter();
						ret.Direction = ParameterDirection.ReturnValue;
						myCommand4.Parameters.Clear();
						myCommand4.Parameters.Add(ret);
						removedRealCounterReader = myCommand4.ExecuteReader();

						RemoveRealCounters(removedRealCounterReader, ref lockAcquired);

						removedRealCounterReader.Close();
						removedRealCounterReader = null;
						if((int)ret.Value != 0)
						{
							XBLPerfLogEvent.LogError("Calling p_GetDeletedRealCounter failed");
						}

						// check removed aggregated counters
						ret = new SqlParameter();
						ret.Direction = ParameterDirection.ReturnValue;
						myCommand5.Parameters.Clear();
						myCommand5.Parameters.Add(ret);
						removedAggCounterReader = myCommand5.ExecuteReader();

						RemoveAggCounters(removedAggCounterReader, ref lockAcquired);

						removedAggCounterReader.Close();
						removedAggCounterReader = null;
						if((int)ret.Value != 0)
						{
							XBLPerfLogEvent.LogError("Calling p_GetDeletedAggCounters failed");
						}
						if(lockAcquired)
						{
							htLock.ReleaseWriterLock();
							lockAcquired = false;
						}
						exit = XBLPerfLogMain.shutdown.WaitOne(0,false);
					}
					catch(SqlException e)
					{
						XBLPerfLogEvent.LogError("CheckChangesThread SqlException: " + e.Message + e.StackTrace,5,1);
						if((mySqlConn.State == ConnectionState.Broken) || (mySqlConn.State == ConnectionState.Closed))
							connected = false;
						if(lockAcquired)
						{
							htLock.ReleaseWriterLock();
							lockAcquired = false;
						}
					}
				}
			}
			catch (Exception e)
			{
				System.Windows.Forms.MessageBox.Show("CheckChanges Thread failed:"+e);
				XBLPerfLogEvent.LogError("CheckChangesThread exists due to unexpected Exception: " + e.Message + e.StackTrace,2,1);
			}
			finally
			{
				if(mySqlConn!=null)
				{
					mySqlConn.Close();
					mySqlConn = null;
				}
				if(lockAcquired)
				{
					htLock.ReleaseWriterLock();
					lockAcquired = false;
				}
			}
        }

		public static void StartDataCollection()
		{
			IDictionaryEnumerator   ide = machineHT.GetEnumerator();
			int                     htCount = machineHT.Count;
			XBLServerBox            currentBox = null;

			for(int i = 0; i < htCount; i++)
			{
				if(ide.MoveNext())
				{
					currentBox = (XBLServerBox)(ide.Value);
					currentBox.StartCollection();
				}
			}
		}

		private static void openPerfDBConn(out SqlConnection mySqlConn)
		{
			mySqlConn = new SqlConnection("Data Source=" + sqlIP + @";Database=PerfDB" + 
										@";Trusted_Connection=true");
			bool	openConnFail = true;
			int		i = 0;

			while(openConnFail == true)
			{
				try
				{
					mySqlConn.Open();
					openConnFail = false;
				}
				catch (Exception e)
				{
					XBLPerfLogEvent.LogError(e.GetType().ToString()+": " + e.Message + e.StackTrace);
					Thread.Sleep(300000);	// wait for 5 minutes before try again
					i++;
					XBLPerfLogEvent.LogInfo("Retry to open connection to perfDB for: "+i+" times");
				}
			}
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\Service\XBLPerfLogParams.cs ===
using System;
using System.Collections;
using System.Threading;
using System.Diagnostics;
using System.Globalization;

namespace XBLPerfLog
{
	public class node
	{
		public XBLPerfCounterValue v;
		public node next;
		public node(XBLPerfCounterValue pcv)
		{
			v = pcv;
			next = null;
		}
	}
	public class CounterValueQueue
	{
		public node head;
		public node tail;

		public void Enqueue(XBLPerfCounterValue pcv)
		{
			if(head == null)	
				head = tail = new node(pcv);
			else
			{
				tail.next = new node(pcv);
				tail = tail.next;
			}
		}

		public XBLPerfCounterValue Dequeue()
		{
			if(head == null)
			{
				return null;
			}
			else if(head == tail)
			{
				node temp = head;
				head = tail = null;
				return temp.v;
			}
			else
			{
				node n = head;
				head = head.next;
				n.next = null;
				return n.v;
			}
		}

		public void MoveTo(CounterValueQueue q)
		{
			Debug.Assert(q!=null);

			lock(q)
			{
				if(q.head != null)
				{
					q.tail.next = this.head;
					q.tail = this.tail;
				}
				else
				{
					q.head = this.head;
					q.tail = this.tail;
				}
				this.head = this.tail = null;
			}
		}

		public CounterValueQueue()
		{
			head = tail = null;
		}
	}

	public class XBLPerfCounterValue
	{
		public int			counterID;
		public string		counterDateTime;
		public float		counterValue;
		public int			recordIndex;
		public int			firstValueA;
		public int			firstValueB;
		public int			secondValueA;
		public int			secondValueB;

		public int			validCount;	// 1 for real counter, n for aggCounter
	}

	public enum AggType
	{
		SUM = 1,
		AVG = 2
	};
	
	public class XBLPerfCounter
	{
		public int			counterID;
		public string		objectName;
		public string		counterName;
		public string		instanceName;
		public string		machineName;

		public float		counterValue;
		// if no response got back for a server, this counter's value will be set to invalid value
		public bool			valueValid = false;

		public PerformanceCounter	pc;

		// For failed NextValue call: 
		// only log error event ONCE for the 1st time if failed 10 times consecutively
		public uint			numFailedNextValueCall = 0;
		public bool			failToCollectData = false;// set to true only when failed consecutively for 10 times

		public XBLPerfCounter()
		{
		}
	}

	public class XBLAggPerfCounter
	{
		public	int			counterID;
		public	string		counterName;
		private AggType		aggType;
		public	ArrayList	realCounters;
		// the number of valid individual counter values used to calculate aggregated value
		public int			validCount;

		// log error event ONLY when it failed to collect counter values
		// consecutively for 10 times. 
		public uint			numFailedNextValueCall = 0;
		public bool			failToCollectData = false; // set to true only when failed consecutively for 10 times

		public XBLAggPerfCounter(AggType type)
		{
			aggType = type;
			realCounters = new ArrayList(100);
		}
		public float GetValue()
		{
			float result=0;
			int   count = realCounters.Count;

			validCount = 0;

			// SUM
			for (int i=0; i<count; ++i)
			{
				XBLPerfCounter counter = (XBLPerfCounter)realCounters[i];
				if (counter.valueValid)
				{
					result += counter.counterValue;
					validCount++;
					counter.valueValid = false;
				}
			}

			// AVG
			if (aggType==AggType.AVG)
			{
				if(validCount != 0)
					result /= validCount;
			}

			if(validCount == 0)
			{
				this.numFailedNextValueCall++;
				if(this.numFailedNextValueCall == 10)
				{
					XBLPerfLogEvent.LogError("The aggregated counter" + XBLPerfLogEvent.AggCounterToString(this)
						+ " has no valid real counter values associated with it");
					this.failToCollectData = true;
				}
			}
			else if (this.failToCollectData == true)// it failed to collect values for 10 times previoully
			{
				XBLPerfLogEvent.LogInfo("The aggregated counter" + XBLPerfLogEvent.AggCounterToString(this)+
										" starts collecting data successfully");
				this.numFailedNextValueCall = 0;
				this.failToCollectData = false;
			}

			return result;
		}
	}

	public class XBLServerBox
	{
		public ArrayList			counterList = new ArrayList(1000);
		public string				machineName = null;
		public Thread				CounterCollectionThread;
		public CounterValueQueue	localQueue;
//		private static int			previousRecordIndex;

		public XBLServerBox()
		{
			CounterCollectionThread = new Thread(new ThreadStart(CollectionThreadStart));
			localQueue       = new CounterValueQueue();
		}

		private void CollectCounters(int recordIndex)
		{
			XBLPerfCounter	counter;
			string			counterDateTime = null;
			int				count = 0;
			float			cookedValue = 0F;
			int				fA,fB;
			double			dcV;

			count = counterList.Count;
			for (int i=0; i<count; ++i)
			{
				counter = (XBLPerfCounter)counterList[i];

				PerformanceCounter pc = counter.pc;

				counterDateTime = DateTime.UtcNow.ToString("u",DateTimeFormatInfo.InvariantInfo);

				try
				{
					counter.counterValue = cookedValue = pc.NextValue();
					// it failed to collect counter data previouly for 10 times
					if(counter.failToCollectData == true)
					{
						XBLPerfLogEvent.LogInfo(XBLPerfLogEvent.RealCounterToString(counter)+" starts collecting data successfully");
					}
					counter.failToCollectData = false;
					counter.numFailedNextValueCall = 0;

					counter.valueValid = true;
				}
				catch (InvalidOperationException e)
				{
					counter.numFailedNextValueCall++;
					if(counter.numFailedNextValueCall == 10)
					{
						XBLPerfLogEvent.LogError(XBLPerfLogEvent.RealCounterToString(counter)+".NextValue() throws InvalidOperationException: " + e.Message + e.StackTrace,7,2);
						counter.failToCollectData = true;
					}
					// During testnet rebuild, service-related counters were deleted and reinstalled again
					// so need to create a new performanceCounter object instead of reusing the old one
					((XBLPerfCounter)counterList[i]).pc = pc = new PerformanceCounter();
					pc.CounterName = counter.counterName;
					pc.CategoryName = counter.objectName;
					pc.MachineName = counter.machineName.Substring(2);// remove leading \\
					pc.InstanceName = counter.instanceName;
				}
				catch (Exception e)
				{
					counter.numFailedNextValueCall++;
					cookedValue = 0;	// no response from server, enter 0 (right value?)
					if(counter.numFailedNextValueCall == 10)
					{	
						XBLPerfLogEvent.LogError(XBLPerfLogEvent.RealCounterToString(counter)+".NextValue() throws Exception " + e.Message + e.StackTrace+ " log 0 for the value",7,2);
						counter.failToCollectData = true;
					}
				}
				dcV = (double)cookedValue;
				unsafe
				{
					int *temp = (int *)&dcV;
					fA = *temp;
					temp++;
					fB = *temp;
				}

				XBLPerfCounterValue		cv = new XBLPerfCounterValue();
				cv.recordIndex = recordIndex;
				cv.counterID = counter.counterID;
				cv.counterValue = counter.counterValue;
				cv.counterDateTime = counterDateTime;
				cv.firstValueA = fA;
				cv.firstValueB = fB;
				cv.secondValueA = 0;
				cv.secondValueB = 0;
				cv.validCount = 1;
				localQueue.Enqueue(cv);

				// move local queue into global queue
				// to minimize lock contention, we will only move in batches
				if(((i % 100 == 0)&& (i != 0)) || (i == (count-1)))
				{
					localQueue.MoveTo(XBLPerfLogMain.globalQueue);
					XBLPerfLogMain.dataAvailable.Set();
				}
			}
		}

		private void CalculateAggCounters(int recordIndex)
		{
			IDictionaryEnumerator	ide;
			int						htCount = 0;
			double					dcV;
			int						fA,fB;

			ide = XBLPerfLogMain.aggCounterHT.GetEnumerator();
			htCount = XBLPerfLogMain.aggCounterHT.Count;

			XBLAggPerfCounter	currentApc = null;
			for(int i = 0; i < htCount; i++)
			{
				if(ide.MoveNext())
				{
					currentApc = (XBLAggPerfCounter)ide.Value;
							
					XBLPerfCounterValue		acv = new XBLPerfCounterValue();
					acv.recordIndex = recordIndex;
					acv.counterID = currentApc.counterID;
					acv.counterValue = currentApc.GetValue();
					acv.counterDateTime = DateTime.UtcNow.ToString("u",DateTimeFormatInfo.InvariantInfo);
					// needs to break up cookedValue 
					unsafe
					{
						dcV = (double)acv.counterValue;
						int *temp = (int *)&dcV;
						fA = *temp;
						temp++;
						fB = *temp;
					}

					acv.firstValueA = fA;
					acv.firstValueB = fB;
					acv.secondValueA = 0;
					acv.secondValueB = 0;

					acv.validCount = currentApc.validCount;

					localQueue.Enqueue(acv);
				}

				// to minimize lock contention, we will only move in batches
				if(((i % 100 == 0)&& (i != 0)) || (i == (htCount-1)))
				{
					localQueue.MoveTo(XBLPerfLogMain.globalQueue);
					XBLPerfLogMain.dataAvailable.Set();
				}
			}
		}

		public void StartCollection()
		{
			CounterCollectionThread.Start();
		}

		private void CollectionThreadStart()
		{
			int					recordIndex;
			bool				shutdown = false;
			DateTime			startTime;
			int					waitms;
			bool				lockRelease = false;
			int					lastRecordIndex = -1;

			while (shutdown != true)
			{
				lockRelease = false;
				try 
				{
					XBLPerfLogMain.htLock.AcquireReaderLock(-1);

					startTime = DateTime.UtcNow;

					// In reallife, there might be situations that one thread is significantly slower
					// than other threads (for example, number of counters on one box is much more than
					// the other; one box response slower; etc). When that happens, recordIndex isn't 
					// get updated, so no record was inserted into counterdata due to PK constraints.
					// To solve the problem, whenever the 1st thread enter the next cycle, it will update
					// recordIndex if it hasn't been updated.
					XBLPerfLogMain.indexMutex.WaitOne();
					recordIndex = XBLPerfLogMain.recordIndex;
					if(recordIndex == lastRecordIndex)
					{
						CalculateAggCounters(lastRecordIndex);
						XBLPerfLogMain.recordIndex++;
						XBLPerfLogMain.numMachineCollected = 0;
						recordIndex++;
						XBLPerfLogEvent.LogInfo("RecordIndex:Manually increment recordIndex to"+recordIndex);
					}
					XBLPerfLogMain.indexMutex.ReleaseMutex();

					lastRecordIndex = recordIndex;

					CollectCounters(recordIndex);

					// check if counter values needed to calculate aggCounter are already being
					// collected from all boxes
					XBLPerfLogMain.indexMutex.WaitOne();
					XBLPerfLogMain.numMachineCollected++;
					int numMachine = XBLPerfLogMain.numMachineCollected;
					if(numMachine == XBLPerfLogMain.machineHT.Count)
					{
						CalculateAggCounters(XBLPerfLogMain.recordIndex);
						XBLPerfLogMain.recordIndex++;
						XBLPerfLogMain.numMachineCollected = 0;
					}
					XBLPerfLogMain.indexMutex.ReleaseMutex();

					XBLPerfLogMain.htLock.ReleaseReaderLock();
					lockRelease = true;
					// wait until next polling period or shutdown event
					waitms = (XBLPerfLogMain.updateInterval * 1000) - 
						(int)((DateTime.UtcNow.Ticks - startTime.Ticks)*0.0001);
					if(waitms < 0)
						waitms = 0;
					shutdown = XBLPerfLogMain.shutdown.WaitOne(waitms, false);
				}
				catch (Exception e)
				{
					XBLPerfLogEvent.LogError("Exception: " + e.Message + e.StackTrace);
				}
				finally
				{
					if(lockRelease == false)
					{
						XBLPerfLogMain.htLock.ReleaseReaderLock();
					}
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\Service\XBLPerfLogEvent.cs ===
using System;
using System.Diagnostics;

namespace XBLPerfLog
{
	/// <summary>
	/// Summary description for XBLPerfLogEvent.
	/// </summary>
	public class XBLPerfLogEvent
	{
		public static EventLog log = new EventLog("Application",".","XBLPerfLog");
		/// <summary>
		/// 
		/// </summary>
		/// <param name="msg"></param>
		/// <param name="eventID">	1: WriteDataThreadExist
		///							2: ChangeDataTreadExist
		///							3: cannot find registry key settings
		///							4: service is not started
		///							5: sql exception
		///							6: instanceMapperThreadExist
		///							7: nextValue() call failed
		///							8: Aggregated Counter: real counter does not exit
		///							9: others
		///							</param>
		/// <param name="category">	1: most severe error
		///							2: nextValue() call failed
		///							3: Aggregated Counter: real counter does not exit
		///							4: others</param>
		public static void LogError(string msg, int eventID, short category)
		{
			log.WriteEntry(msg,EventLogEntryType.Error,eventID,category);
		}
		public static void LogError(string msg)
		{
			log.WriteEntry(msg,EventLogEntryType.Error,9,4);
		}
		public static void LogInfo(string msg)
		{
			log.WriteEntry(msg,EventLogEntryType.Information);
		}
		public static void LogWarning(string msg)
		{
			log.WriteEntry(msg,EventLogEntryType.Warning);
		}
		public static string RealCounterToString(XBLPerfCounter pc)
		{
			string counterString = String.Format("{0}\\{1}",pc.machineName,pc.objectName);
			if(pc.instanceName != null)
				counterString += '(' + pc.instanceName + ')';
			counterString += '\\' + pc.counterName;
			return counterString;
		}
		public static string AggCounterToString(XBLAggPerfCounter apc)
		{
			XBLPerfCounter	pc = (XBLPerfCounter)apc.realCounters[0];
			string counterString = String.Format(" {0}-{1}:\\{2}[{3}]\\{4}",apc.counterName,apc.counterID,pc.objectName,pc.instanceName,pc.counterName);
			return counterString;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\XBLPerfLogTool\CategoryDataset.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

namespace XBLPerfLogTool {
    using System;
    using System.Data;
    using System.Xml;
    using System.Runtime.Serialization;
    
    
    [Serializable()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Diagnostics.DebuggerStepThrough()]
    [System.ComponentModel.ToolboxItem(true)]
    public class CategoryDataset : DataSet {
        
        private CategoryDataTable tableCategory;
        
        public CategoryDataset() {
            this.InitClass();
            System.ComponentModel.CollectionChangeEventHandler schemaChangedHandler = new System.ComponentModel.CollectionChangeEventHandler(this.SchemaChanged);
            this.Tables.CollectionChanged += schemaChangedHandler;
            this.Relations.CollectionChanged += schemaChangedHandler;
        }
        
        protected CategoryDataset(SerializationInfo info, StreamingContext context) {
            string strSchema = ((string)(info.GetValue("XmlSchema", typeof(string))));
            if ((strSchema != null)) {
                DataSet ds = new DataSet();
                ds.ReadXmlSchema(new XmlTextReader(new System.IO.StringReader(strSchema)));
                if ((ds.Tables["Category"] != null)) {
                    this.Tables.Add(new CategoryDataTable(ds.Tables["Category"]));
                }
                this.DataSetName = ds.DataSetName;
                this.Prefix = ds.Prefix;
                this.Namespace = ds.Namespace;
                this.Locale = ds.Locale;
                this.CaseSensitive = ds.CaseSensitive;
                this.EnforceConstraints = ds.EnforceConstraints;
                this.Merge(ds, false, System.Data.MissingSchemaAction.Add);
                this.InitVars();
            }
            else {
                this.InitClass();
            }
            this.GetSerializationData(info, context);
            System.ComponentModel.CollectionChangeEventHandler schemaChangedHandler = new System.ComponentModel.CollectionChangeEventHandler(this.SchemaChanged);
            this.Tables.CollectionChanged += schemaChangedHandler;
            this.Relations.CollectionChanged += schemaChangedHandler;
        }
        
        [System.ComponentModel.Browsable(false)]
        [System.ComponentModel.DesignerSerializationVisibilityAttribute(System.ComponentModel.DesignerSerializationVisibility.Content)]
        public CategoryDataTable Category {
            get {
                return this.tableCategory;
            }
        }
        
        public override DataSet Clone() {
            CategoryDataset cln = ((CategoryDataset)(base.Clone()));
            cln.InitVars();
            return cln;
        }
        
        protected override bool ShouldSerializeTables() {
            return false;
        }
        
        protected override bool ShouldSerializeRelations() {
            return false;
        }
        
        protected override void ReadXmlSerializable(XmlReader reader) {
            this.Reset();
            DataSet ds = new DataSet();
            ds.ReadXml(reader);
            if ((ds.Tables["Category"] != null)) {
                this.Tables.Add(new CategoryDataTable(ds.Tables["Category"]));
            }
            this.DataSetName = ds.DataSetName;
            this.Prefix = ds.Prefix;
            this.Namespace = ds.Namespace;
            this.Locale = ds.Locale;
            this.CaseSensitive = ds.CaseSensitive;
            this.EnforceConstraints = ds.EnforceConstraints;
            this.Merge(ds, false, System.Data.MissingSchemaAction.Add);
            this.InitVars();
        }
        
        protected override System.Xml.Schema.XmlSchema GetSchemaSerializable() {
            System.IO.MemoryStream stream = new System.IO.MemoryStream();
            this.WriteXmlSchema(new XmlTextWriter(stream, null));
            stream.Position = 0;
            return System.Xml.Schema.XmlSchema.Read(new XmlTextReader(stream), null);
        }
        
        internal void InitVars() {
            this.tableCategory = ((CategoryDataTable)(this.Tables["Category"]));
            if ((this.tableCategory != null)) {
                this.tableCategory.InitVars();
            }
        }
        
        private void InitClass() {
            this.DataSetName = "CategoryDataset";
            this.Prefix = "";
            this.Namespace = "http://www.tempuri.org/CategoryDataset.xsd";
            this.Locale = new System.Globalization.CultureInfo("en-US");
            this.CaseSensitive = false;
            this.EnforceConstraints = true;
            this.tableCategory = new CategoryDataTable();
            this.Tables.Add(this.tableCategory);
        }
        
        private bool ShouldSerializeCategory() {
            return false;
        }
        
        private void SchemaChanged(object sender, System.ComponentModel.CollectionChangeEventArgs e) {
            if ((e.Action == System.ComponentModel.CollectionChangeAction.Remove)) {
                this.InitVars();
            }
        }
        
        public delegate void CategoryRowChangeEventHandler(object sender, CategoryRowChangeEvent e);
        
        [System.Diagnostics.DebuggerStepThrough()]
        public class CategoryDataTable : DataTable, System.Collections.IEnumerable {
            
            private DataColumn columnCategoryID;
            
            private DataColumn columnCategoryName;
            
            internal CategoryDataTable() : 
                    base("Category") {
                this.InitClass();
            }
            
            internal CategoryDataTable(DataTable table) : 
                    base(table.TableName) {
                if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
                    this.CaseSensitive = table.CaseSensitive;
                }
                if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
                    this.Locale = table.Locale;
                }
                if ((table.Namespace != table.DataSet.Namespace)) {
                    this.Namespace = table.Namespace;
                }
                this.Prefix = table.Prefix;
                this.MinimumCapacity = table.MinimumCapacity;
                this.DisplayExpression = table.DisplayExpression;
            }
            
            [System.ComponentModel.Browsable(false)]
            public int Count {
                get {
                    return this.Rows.Count;
                }
            }
            
            internal DataColumn CategoryIDColumn {
                get {
                    return this.columnCategoryID;
                }
            }
            
            internal DataColumn CategoryNameColumn {
                get {
                    return this.columnCategoryName;
                }
            }
            
            public CategoryRow this[int index] {
                get {
                    return ((CategoryRow)(this.Rows[index]));
                }
            }
            
            public event CategoryRowChangeEventHandler CategoryRowChanged;
            
            public event CategoryRowChangeEventHandler CategoryRowChanging;
            
            public event CategoryRowChangeEventHandler CategoryRowDeleted;
            
            public event CategoryRowChangeEventHandler CategoryRowDeleting;
            
            public void AddCategoryRow(CategoryRow row) {
                this.Rows.Add(row);
            }
            
            public CategoryRow AddCategoryRow(string CategoryName) {
                CategoryRow rowCategoryRow = ((CategoryRow)(this.NewRow()));
                rowCategoryRow.ItemArray = new object[] {
                        null,
                        CategoryName};
                this.Rows.Add(rowCategoryRow);
                return rowCategoryRow;
            }
            
            public CategoryRow FindByCategoryID(int CategoryID) {
                return ((CategoryRow)(this.Rows.Find(new object[] {
                            CategoryID})));
            }
            
            public System.Collections.IEnumerator GetEnumerator() {
                return this.Rows.GetEnumerator();
            }
            
            public override DataTable Clone() {
                CategoryDataTable cln = ((CategoryDataTable)(base.Clone()));
                cln.InitVars();
                return cln;
            }
            
            protected override DataTable CreateInstance() {
                return new CategoryDataTable();
            }
            
            internal void InitVars() {
                this.columnCategoryID = this.Columns["CategoryID"];
                this.columnCategoryName = this.Columns["CategoryName"];
            }
            
            private void InitClass() {
                this.columnCategoryID = new DataColumn("CategoryID", typeof(int), null, System.Data.MappingType.Element);
                this.Columns.Add(this.columnCategoryID);
                this.columnCategoryName = new DataColumn("CategoryName", typeof(string), null, System.Data.MappingType.Element);
                this.Columns.Add(this.columnCategoryName);
                this.Constraints.Add(new UniqueConstraint("Constraint1", new DataColumn[] {
                                this.columnCategoryID}, true));
                this.columnCategoryID.AutoIncrement = true;
                this.columnCategoryID.AllowDBNull = false;
                this.columnCategoryID.ReadOnly = true;
                this.columnCategoryID.Unique = true;
                this.columnCategoryName.AllowDBNull = false;
            }
            
            public CategoryRow NewCategoryRow() {
                return ((CategoryRow)(this.NewRow()));
            }
            
            protected override DataRow NewRowFromBuilder(DataRowBuilder builder) {
                return new CategoryRow(builder);
            }
            
            protected override System.Type GetRowType() {
                return typeof(CategoryRow);
            }
            
            protected override void OnRowChanged(DataRowChangeEventArgs e) {
                base.OnRowChanged(e);
                if ((this.CategoryRowChanged != null)) {
                    this.CategoryRowChanged(this, new CategoryRowChangeEvent(((CategoryRow)(e.Row)), e.Action));
                }
            }
            
            protected override void OnRowChanging(DataRowChangeEventArgs e) {
                base.OnRowChanging(e);
                if ((this.CategoryRowChanging != null)) {
                    this.CategoryRowChanging(this, new CategoryRowChangeEvent(((CategoryRow)(e.Row)), e.Action));
                }
            }
            
            protected override void OnRowDeleted(DataRowChangeEventArgs e) {
                base.OnRowDeleted(e);
                if ((this.CategoryRowDeleted != null)) {
                    this.CategoryRowDeleted(this, new CategoryRowChangeEvent(((CategoryRow)(e.Row)), e.Action));
                }
            }
            
            protected override void OnRowDeleting(DataRowChangeEventArgs e) {
                base.OnRowDeleting(e);
                if ((this.CategoryRowDeleting != null)) {
                    this.CategoryRowDeleting(this, new CategoryRowChangeEvent(((CategoryRow)(e.Row)), e.Action));
                }
            }
            
            public void RemoveCategoryRow(CategoryRow row) {
                this.Rows.Remove(row);
            }
        }
        
        [System.Diagnostics.DebuggerStepThrough()]
        public class CategoryRow : DataRow {
            
            private CategoryDataTable tableCategory;
            
            internal CategoryRow(DataRowBuilder rb) : 
                    base(rb) {
                this.tableCategory = ((CategoryDataTable)(this.Table));
            }
            
            public int CategoryID {
                get {
                    return ((int)(this[this.tableCategory.CategoryIDColumn]));
                }
                set {
                    this[this.tableCategory.CategoryIDColumn] = value;
                }
            }
            
            public string CategoryName {
                get {
                    return ((string)(this[this.tableCategory.CategoryNameColumn]));
                }
                set {
                    this[this.tableCategory.CategoryNameColumn] = value;
                }
            }
        }
        
        [System.Diagnostics.DebuggerStepThrough()]
        public class CategoryRowChangeEvent : EventArgs {
            
            private CategoryRow eventRow;
            
            private DataRowAction eventAction;
            
            public CategoryRowChangeEvent(CategoryRow row, DataRowAction action) {
                this.eventRow = row;
                this.eventAction = action;
            }
            
            public CategoryRow Row {
                get {
                    return this.eventRow;
                }
            }
            
            public DataRowAction Action {
                get {
                    return this.eventAction;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XeOfferLoader\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\SyncSqlProfileCounters\PerfDB.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Globalization;


namespace SyncSqlProfileCounters
{

	public class SyncStatus
	{
		public Guid guid = Guid.Empty;
		public DateTime Start = DateTime.MinValue;
		public DateTime End = DateTime.MinValue;
		public int lastIdx=0;
	}
	/// <summary>
	/// Summary description for PerfDB.
	/// </summary>
	public class PerfDB
	{
		static string myConnString = "Data Source=xetestsql001;Initial Catalog=perfdb;user id=sa";
		
		public PerfDB()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		public static DateTime GetCurrentRunStartTime()
		{
			DateTime tmp = DateTime.MinValue ;
			SqlConnection _PerfCnt =null;
			try
			{
				
				string mySelectQuery = "SELECT LogStartTime ,GUID ,LogStopTime FROM [perfdb].[dbo].[DisplayToID] where CurrentRun=1 ";
				
				_PerfCnt= new SqlConnection(myConnString); 
				_PerfCnt.Open();


				SqlCommand myCommand = new SqlCommand(mySelectQuery, _PerfCnt);
				myCommand.CommandType = CommandType.Text;
				SqlDataReader myReader = myCommand.ExecuteReader();
				while(myReader.Read()) 
				{
					string tstring = myReader.GetString(0);
					 tmp=DateTime.Parse(tstring);
					SyncSqlProfileData.GUID = myReader.GetGuid(1);
					string tstring2  = myReader.GetString(2);
					SyncSqlProfileData.StopTime =DateTime.Parse(tstring2);
					
				}
				myReader.Close();

			}
			finally
			{
				if(_PerfCnt!=null)
				{
					_PerfCnt.Close();
					_PerfCnt=null;
				}

			}
			return tmp;
		}


		public static SyncStatus GetCurrentSyncStatus()
		{
			SyncStatus tmp = new SyncStatus();
			SqlConnection _PerfCnt =null;
			try
			{
				
				string mySelectQuery = "SELECT GUID,Starttime,Endtime ,LastRecIdx FROM [perfdb].[dbo].[SqlProfileSyncState] where GUID='"+SyncSqlProfileData.GUID.ToString()+"'";
				
				_PerfCnt= new SqlConnection(myConnString); 
				_PerfCnt.Open();


				SqlCommand myCommand = new SqlCommand(mySelectQuery, _PerfCnt);
				myCommand.CommandType = CommandType.Text;
				SqlDataReader myReader = myCommand.ExecuteReader();
				while(myReader.Read()) 
				{
					if(!myReader.IsDBNull(0))
						tmp.guid = myReader.GetGuid(0);
					if(!myReader.IsDBNull(1))
						tmp.Start= myReader.GetDateTime(1);
					if(!myReader.IsDBNull(2))
						tmp.End= myReader.GetDateTime(2);
					if(!myReader.IsDBNull(3))
						tmp.lastIdx= myReader.GetInt32(3);
					else
						tmp.lastIdx=1;
										
				}
				myReader.Close();

			}
			finally
			{
				if(_PerfCnt!=null)
				{
					_PerfCnt.Close();
					_PerfCnt=null;
				}

			}
			return tmp;
		}

		public static void UpdateCurrentSyncStatus(SyncStatus data)
		{
			SqlConnection _PerfCnt =null;
			SqlDataReader   result  = null;
			try
			{
				
				_PerfCnt= new SqlConnection(myConnString); 
				_PerfCnt.Open();


				SqlCommand myCommand = new SqlCommand("UpdateCurrentSyncStatus", _PerfCnt);
				myCommand.CommandType = CommandType.StoredProcedure;
				
				SqlParameter ret = new SqlParameter();
				ret.Direction = ParameterDirection.ReturnValue;
				myCommand.Parameters.Add(ret);
				myCommand.Parameters.Add("@GUID", SqlDbType.UniqueIdentifier).Value =  data.guid;
				myCommand.Parameters.Add("@StartTime", SqlDbType.DateTime).Value =  data.Start;
				myCommand.Parameters.Add("@EndTime", SqlDbType.DateTime).Value =  data.End;
				myCommand.Parameters.Add("@LastRecIdx", SqlDbType.Int).Value =  data.lastIdx;
											
				// Execute the command
				result = myCommand.ExecuteReader();
				result.Close();

				if((int)ret.Value != 0)
				{
					System.Console.WriteLine("ERROR: p_Stats_ResetTitle returned "+ ret.Value);
					throw new Exception("ERROR: p_Stats_ResetTitle returned "+ ret.Value);
				}

			}
			finally
			{
				if(_PerfCnt!=null)
				{
					_PerfCnt.Close();
					_PerfCnt=null;
				}

			}
		}
		public static void AddCounterData( string SpNAme,int reqidx,string servername, string Countername ,DateTime time , int Value)
		{

			SqlConnection _PerfCnt =null;
			SqlDataReader   result  = null;
			try
			{
				
				_PerfCnt= new SqlConnection(myConnString); 
				_PerfCnt.Open();


				SqlCommand myCommand = new SqlCommand("p_InsertSQLProfileData", _PerfCnt);
				myCommand.CommandType = CommandType.StoredProcedure;
				
				SqlParameter ret = new SqlParameter();
				ret.Direction = ParameterDirection.ReturnValue;
				myCommand.Parameters.Add(ret);
				myCommand.Parameters.Add("@GUID", SqlDbType.UniqueIdentifier).Value =  SyncSqlProfileData.GUID;
				myCommand.Parameters.Add("@CounterName", SqlDbType.VarChar).Value =  SpNAme;
				string tmp=  "\\\\"+servername;
				myCommand.Parameters.Add("@MachineName", SqlDbType.VarChar).Value =  tmp.Trim();
				myCommand.Parameters.Add("@InstanceName", SqlDbType.VarChar).Value =  Countername;
				myCommand.Parameters.Add("@RecordIndex", SqlDbType.Int).Value =  reqidx;
				myCommand.Parameters.Add("@CounterDateTime", SqlDbType.VarChar).Value =  time.ToString("u",DateTimeFormatInfo.InvariantInfo);
				myCommand.Parameters.Add("@CounterValue", SqlDbType.Float).Value =  (float)Value;
				
				// Execute the command
				result = myCommand.ExecuteReader();
				result.Close();

				if((int)ret.Value != 0)
				{
					System.Console.WriteLine("ERROR: p_Stats_ResetTitle returned "+ ret.Value);
					throw new Exception("ERROR: p_Stats_ResetTitle returned "+ ret.Value);
				}

			}
			catch( Exception e)
			{
				System.Console.WriteLine(e);
			}
			finally
			{
				if(_PerfCnt!=null)
				{
					_PerfCnt.Close();
					_PerfCnt=null;
				}

			}
			

		}

		public static void  InsertCounterData(string SpName,string server, DateTime starttime ,int AvgCPU, int AvgDuration, int AvgReads,int AvgWrites)
		{
			int reqidx=1;

			SPKey key = new SPKey(SpName,server);
			if(SyncSqlProfileData.SpMAp.Contains(key))
			{
				SPCounters tmp = (SPCounters)SyncSqlProfileData.SpMAp[key];
				
				
				if(tmp.LastEntry<starttime)
				{
					tmp.LastEntry=starttime;
					reqidx= ++tmp.Count;
					if(reqidx>SyncSqlProfileData.SyncState.lastIdx)
						SyncSqlProfileData.SyncState.lastIdx=reqidx;
				}
				else
					return ;
			}
			else
			{
				SPCounters tmp  = new SPCounters();
				if(SyncSqlProfileData.SpMAp.Count==0)
					reqidx=tmp.Count =++SyncSqlProfileData.SyncState.lastIdx;
				else
					reqidx=tmp.Count =SyncSqlProfileData.SyncState.lastIdx;

				tmp.LastEntry=starttime;
				SyncSqlProfileData.SpMAp.Add(key,tmp);
			}

			AddCounterData( SpName,reqidx ,server, "AvgCPU",starttime ,AvgCPU);
			AddCounterData( SpName,reqidx ,server, "AvgDuration",starttime ,AvgDuration);
			AddCounterData( SpName,reqidx ,server, "AvgReads",starttime ,AvgReads);
			AddCounterData( SpName,reqidx ,server, "AvgWrites",starttime ,AvgWrites);
						
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\XBLPerfLogTool\ServerComm.cs ===
using System;
using System.ComponentModel;
using System.Collections;
using System.Diagnostics;
using System.Net;
using System.IO;
using System.Data.SqlClient;

namespace XBLPerfLogTool
{
	/// <summary>
	/// This was used as a temporary test of whether calling HealthXRL functions would cause an IIS component 
	/// to be loaded.  It does work.  However, this code has lots of ugly hard-coded addresses in it and
	/// needs to be generalized for a real solution.  At the very least, consolidate the 3 lists into
	/// 1 using a struct.  :) The hell was I thinking?
	/// </summary>
	public class ServerComm : System.ComponentModel.Component
	{
        public System.Data.SqlClient.SqlConnection sqlConnection;

        public Hashtable HealthXrlMap = new Hashtable();

        /// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public ServerComm(System.ComponentModel.IContainer container)
		{
			///
			/// Required for Windows.Forms Class Composition Designer support
			///
			container.Add(this);
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
            MyInitialize();
		}

		public ServerComm()
		{
			///
			/// Required for Windows.Forms Class Composition Designer support
			///
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
            MyInitialize();
		}


        /// <summary>
        ///  Initialize object
        /// </summary>
        protected void MyInitialize()
        {
			/*
			 *	select distinct intf.vc_component from t_server_type_interfaces sti
			 *	inner join t_interfaces intf on intf.vc_interface=sti.vc_interface
			 *	where sti.vc_server_type='frontdoor' or 'allinh'
			 */
			//category is frontdoor
            HealthXrlMap.Add("compplugins", "/xqry/health.ashx");
            HealthXrlMap.Add("cron", ":11210/cron/health.ashx");
			HealthXrlMap.Add("cronlib", "/cron/health.ashx");
		//	HealthXrlMap.Add("eventsink","");
            HealthXrlMap.Add("fbserver", ":10080/fbserver/health.ashx");
		//	HealthXrlMap.Add("querylib","");
            HealthXrlMap.Add("stfd", ":10150/stfd/health.ashx");
            HealthXrlMap.Add("stringsvr", ":10020/stringsvr/health.ashx");
		//	HealthXrlMap.Add("udpadpt","");
            HealthXrlMap.Add("xarb", ":10160/xarb/health.ashx");
            HealthXrlMap.Add("xbos", ":10090/xbos/health.ashx");
		//	HealthXrlMap.Add("xcache", "");
		//	HealthXrlMap.Add("xcbk","");
		    HealthXrlMap.Add("xmatchfd", ":10060/xmatch/health.ashx");
            HealthXrlMap.Add("xpnfd", ":11190/xpnfront/health.ashx");
			HealthXrlMap.Add("xqry",":10130/xqry/health.ashx");
		//	HealthXrlMap.Add("xrlscan","");
            HealthXrlMap.Add("xsig", ":10120/xsig/health.ashx");
            HealthXrlMap.Add("xstatsfd", ":10070/xstats/health.ashx");
		//	HealthXrlMap.Add("xsuppapi",":13010/");
		//	HealthXrlMap.Add("xtou",":10110/");
			HealthXrlMap.Add("xuacs", ":11050/xuacs/health.ashx");

			//category is allinh
			HealthXrlMap.Add("xarbInh", ":14160/xarbinh/health.ashx");
		//	HealthXrlMap.Add("xmgmtsrv","");
		//	HealthXrlMap.Add("xpserver","");
		//	HealthXrlMap.Add("lbsvr", "");
     
			//category is sg
		//	HealthXrlMap.Add("sgsvc", "");

			//cageory is xmacs_xkdc
		//	HealthXrlMap.Add("kdcsvc", "");

			//Category is webcache
			HealthXrlMap.Add("livecache", "/livecache/health.ashx");
			HealthXrlMap.Add("livepxy", "/livepxy/health.ashx");
		//	HealthXrlMap.Add("lspstrsrflt", "");
			HealthXrlMap.Add("wcalerts", "/wcalerts/health.ashx");
            HealthXrlMap.Add("wcgeneral", "/wcgeneral/health.ashx");
            HealthXrlMap.Add("wcmessaging", "/wcmessaging/health.ashx");
            HealthXrlMap.Add("wcpresence", "/wcpresence/health.ashx");
            HealthXrlMap.Add("wcquery", "/wcquery/health.ashx");
            HealthXrlMap.Add("wcsignature", "/wcsignature/health.ashx");
            HealthXrlMap.Add("wcstats", "/wcstats/health.ashx");
            HealthXrlMap.Add("wcstorage", "/wcstorage/health.ashx");
			HealthXrlMap.Add("wcteams","/wcteams/health.ashx");
			HealthXrlMap.Add("wctoolsmgmt","/wctoolsmgmt/health.ashx");
            HealthXrlMap.Add("wcusers", "/wcusers/health.ash");
		//	HealthXrlMap.Add("websg","");
		//	HealthXrlMap.Add("xcache", "");

			//Category is websg_xds
		//	HealthXrlMap.Add("download", "");
		//	HealthXrlMap.Add("websg", "");
			HealthXrlMap.Add("xds", "");

			//category is xboxcom_auth_iis
		//	HealthXrlMap.Add("xboxcom_auth", "");

			//category is xboxcom_enduser_iis
		//	HealthXrlMap.Add("xboxcom_www", "");
        }

		/// <summary> 
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

        public string responseString;

        /// <summary>
        /// Force server component to load
        /// </summary>
        /// <param name="friendlyName"></param>
        /// <param name="ip"></param>
        /// <returns></returns>
        public bool MakeRequest(string compName, string machine)
        {
            string name = compName.ToLower();
            if (!HealthXrlMap.ContainsKey(name))
            {
                // No key!
                return false;
            }
            string xrl = (string)HealthXrlMap[name];
            return AttemptHealthCheck(name, "http://" + machine + xrl, 5000);
        }

        /// <summary>
        /// Yanked from $corext\private\tools\Framework\CTitleMgr.cs
        /// </summary>
        /// <param name="sFriendlyName"></param>
        /// <param name="sHealthUrl"></param>
        /// <param name="iTimeout"></param>
        /// <returns>true if successful, false if error</returns>
        private bool AttemptHealthCheck(
            string sFriendlyName,
            string sHealthUrl,
            int iTimeout)
        {
            string [] sUrlParts = sHealthUrl.Split(';');
            string sMethod;
            string sUrl;

            if(sUrlParts.Length != 2)
            {
                //throw new ArgumentException("Health URL must be in the form <method>;<url>");
                // Assume to be GET since they all are for devnet2, at least
                sMethod = "GET";
                sUrl = sHealthUrl;
            }
            else 
            {
                sMethod = sUrlParts[0];
                sUrl = sUrlParts[1];
            }

            if(sMethod.ToUpper() != "GET" && sMethod.ToUpper() != "POST")
                throw new ArgumentException("Invalid HTTP method: " + sMethod);

            HttpWebRequest httpWebRequest = 
                (HttpWebRequest)WebRequest.Create(sUrl);

            // Turn off connection keep-alives.
            httpWebRequest.KeepAlive = false;

            // set the requested timeout, in milliseconds
            httpWebRequest.Timeout = iTimeout;

            // set method, and Content-Length
            httpWebRequest.Method = sMethod;
            if(sMethod == "POST")
                httpWebRequest.ContentLength = 0;
            
            HttpWebResponse httpWebResponse = null;
            try
            {
                httpWebResponse = (HttpWebResponse)httpWebRequest.GetResponse();
                string sResponse;
                try
                {
                    Stream stream = httpWebResponse.GetResponseStream();
                    StreamReader streamReader = new StreamReader(stream);
                    sResponse = streamReader.ReadToEnd();
                }
                catch (ProtocolViolationException)
                {
                    // no content to be had
                    sResponse = String.Empty;
                }

                if (httpWebResponse.StatusCode == HttpStatusCode.OK)
                {
                    responseString = "OK";
                    return true;
                }
                else
                {
                    responseString = 
                        "Error: " 
                        + sFriendlyName 
                        + " (" 
                        + sMethod + " " + sUrl 
                        + ") reports " 
                        + httpWebResponse.StatusCode.ToString();
                    return false;
                }
            }
            catch (WebException webException)
            {
                if (webException.Status == WebExceptionStatus.Timeout)
                {
                    responseString = "Error: " + sFriendlyName + " (" + sMethod + " " + sUrl + ") timed out";
                    return false;
                }
                responseString = 
                    "Error: " 
                    + sFriendlyName 
                    + " (" 
                    + sMethod + " " + sUrl 
                    + ") threw exception.";
                return false;
            }
            finally
            {
                if (httpWebResponse != null)
                {
                    httpWebResponse.Close();
                }
            }
        }


		#region Component Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.sqlConnection = new System.Data.SqlClient.SqlConnection();
            // 
            // sqlConnection
            // 
            this.sqlConnection.ConnectionString = "user id=PerfLogTool;password=PerfLogTool;data source=localhost;persist security info=False;initial catalog=PerfDB";

        }
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\XBLPerfLogTool\PerfLogToolBase.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data;
using System.Data.SqlClient;

namespace XBLPerfLogTool
{
	/// <summary>
	/// Summary description for PerfLogToolBase.
	/// </summary>
	public class PerfLogToolBase : System.Web.UI.Page
	{
        public const int COUNTER_TYPE = 0x12000;

        protected System.Security.Principal.WindowsImpersonationContext impersonationContext;
        protected ServerComm serverComm = new ServerComm();
        
        /// <summary>
        /// Sorts PerformanceCounterCategory objects
        /// </summary>
        protected class myCounterSorter : IComparer
        {
            int IComparer.Compare(Object x, Object y) 
            {
                PerformanceCounterCategory a = (PerformanceCounterCategory) x;
                PerformanceCounterCategory b = (PerformanceCounterCategory) y;
                return String.Compare(a.CategoryName, b.CategoryName, true);
            }
        }
 
        /// <summary>
        /// Stored in hashtable while user is adding counters
        /// </summary>
        protected class CounterInfo
        {
            public CounterInfo(int counterType, int count)
            {
                CounterType = counterType;
                Count = count;
            }
            public void Increment() { Count++; }
        
            public int CounterType = 0;
            public int Count = 0;
        }
        
        public PerfLogToolBase()
		{
			//
			// TODO: Add constructor logic here
			//
		}

        #region Handy Utilities


        /// <summary>
        /// Binds a list control to a SQL command
        /// </summary>
        /// <param name="control"></param>
        /// <param name="sqlCommand"></param>
        /// <param name="dataTextField"></param>
        /// <param name="dataValueField"></param>
        static public void BindList(ListControl control, SqlCommand sqlCommand, string dataTextField, string dataValueField)
        {
            SqlDataReader dReader = sqlCommand.ExecuteReader();
            control.DataSource = dReader;
            control.DataTextField = dataTextField;
            control.DataValueField = dataValueField;
            control.DataBind();

            dReader.Close();
        }

        /// <summary>
        /// Utility function to fill a list box control with strings from an array
        /// </summary>
        /// <param name="control"></param>
        /// <param name="name"></param>
        public void FillList(ListBox control, params string[] name)
        {
            foreach (string s in name)
            {
                control.Items.Add(s);
            }
            control.Items[0].Selected = true;
        }

        /// <summary>
        /// Utility function to select all items in a list box control
        /// </summary>
        /// <param name="control"></param>
        public void SelectAll(ListBox control)
        {
            foreach (ListItem item in control.Items)
            {
                item.Selected = true;
            }
        }

        /// <summary>
        /// Move all selected Items from one ListBox to another
        /// </summary>
        /// <param name="from">The 'from' ListControl</param>
        /// <param name="to">The 'to' ListControl</param>
        protected void MoveItems(ListControl from, ListControl to)
        {
            for (int i = from.Items.Count - 1; i >= 0; i--)
            {
                if (from.Items[i].Selected)
                {
                    to.Items.Add(from.Items[i]);
                    from.Items.RemoveAt(i);
                }
            }
        }

                /// <summary>
        /// Utility function to convert a ListBox control to an ArrayList of items
        /// </summary>
        /// <param name="list"></param>
        /// <returns></returns>
        public ArrayList ListToArrayList(ListBox list)
        {
            ArrayList array = new ArrayList(list.Items.Count);
            foreach (ListItem item in list.Items)
            {
                array.Add(item.Text);
            }
            return array;
        }
        
        /// <summary>
        /// Forces impersonation of current user's credentials
        /// </summary>
        public void Impersonate()
        {
            impersonationContext = ((System.Security.Principal.WindowsIdentity)User.Identity).Impersonate();
        }

        /// <summary>
        /// Stops impersonating
        /// </summary>
        public void UnImpersonate()
        {
            impersonationContext.Undo();
        }
        #endregion

		private void CounterCategoryFilter(string selectedService, string cname, ref SortedList finalCategories)
		{
			if(cname.IndexOf("XomLog") != -1)
				finalCategories.Add(cname,1);
				switch (selectedService)
				{
					case "cron":
					case "cronlib":
						if(cname.StartsWith("CRON"))
							finalCategories.Add(cname, 1);
						break;
					case "fbserver":
						if(cname.IndexOf("Feedback") != -1)
							finalCategories.Add(cname, 1);
						break;
					case "compplugins":
					case "querylib":
					case "xqry":
						if(cname.StartsWith("XQRY"))
							finalCategories.Add(cname, 1);
						break;
					case "stfd":
						if(cname.IndexOf("Storage") != -1 ||
							cname.IndexOf("Name Resolution") != -1)
							finalCategories.Add(cname, 1);
						break;
					case "stringsvr":
						if(cname.IndexOf("String") != -1)
							finalCategories.Add(cname, 1);
						break;
					case "xarb":
						if(cname.IndexOf("Arbitration") != -1)
							finalCategories.Add(cname, 1);
						break;
					case "xbos":
					case "xcbk":
					case "xsuppapi":
					case "xtou":
					case "xuacs":	
						if(cname.IndexOf("XBOS") != -1 ||
							cname.IndexOf("Billing") != -1 ||
							cname.IndexOf("XCBK") != -1 ||
							cname.IndexOf("XUACS") != -1 ||
							cname.IndexOf("XSupp") != -1 ||
							cname.IndexOf("Xuacs") != -1)
							finalCategories.Add(cname, 1);
						break;									
					case "xcache":
						if(cname.IndexOf("Xcache") != -1)
							finalCategories.Add(cname, 1);
						break;
					case "xmatchfd":
						if(cname.IndexOf("xmatchfd") != -1)
							finalCategories.Add(cname, 1);
						break;
					case "xsig":
						if(cname.StartsWith("Xsig"))
							finalCategories.Add(cname, 1);
						break;
					case "xstatsfd":
						if(cname.IndexOf("Statistics") != -1)
							finalCategories.Add(cname, 1);
						break;
					case "xpnfd":
						if(cname.IndexOf("Xbox Presence FD") != -1)
							finalCategories.Add(cname, 1);
						break;
					case "xmgmtsrv":
					case "udpadpt":
						finalCategories.Add(cname, 1);
						break;
					// the following are "allinh"
					case "lbsvr":	//TODO:
					case "xarbInh":
						if(cname.IndexOf("Arbitration") != -1)
							finalCategories.Add(cname, 1);
						break;
					case "xpserver":
						if(cname.IndexOf("Presence") != -1)
							finalCategories.Add(cname, 1);
						break;
					default:
						break;
				}						
		}

        /// <summary>
        /// Get union of performance counter categories on all machines, throwing out any categories
        /// not common to all machines.
        /// </summary>
        /// <param name="machines">List of machines to retrieve categories from</param>
        public void GetCategories(string selectedCategory, string selectedService, ArrayList machines, ref ListBox CategoryList)
        {
            PerformanceCounterCategory[] categories;
			string	cname;

            // Using a sorted list here is potentially slow, as we need to do lookups on each category name.
            // I think I originally used a hashtable, which is more appropriate, but I need the end result to
            // be sorted, so I switched.  A better solution is to sort the hashtable once at the end. If
            // performance sucks, this is one thing to look at.
            SortedList finalCategories = new SortedList(100);

            // Be the current user, not some lowly internet account
            //Impersonate();

            // Get categories from each machine and form intersecting set with each other
            foreach (object m in machines)
            {
                categories = PerformanceCounterCategory.GetCategories(m.ToString());
                foreach (PerformanceCounterCategory c in categories)
                {
					cname = c.CategoryName;
                    // If this counter already exists, increment its count by one, otherwise add it to the list
					if (finalCategories.ContainsKey(cname))
						finalCategories[cname] = (int)finalCategories[cname] + 1;
					else
					{	// before adding it to the final list, check if it belongs to the selectedService
						// so the UI only shows selected component's perf counter categories.
						if(selectedCategory.IndexOf("frontdoor") != -1)
						{	// add filter if it's service related performance counter categories
							if((cname.ToLower().StartsWith("x") && (cname.ToLower().StartsWith("xbox sginfo") == false))
								|| cname.ToLower().StartsWith("cron"))
									CounterCategoryFilter(selectedService,cname, ref finalCategories);
							else // add to final list if it's not service related perf counter categories
								finalCategories.Add(cname, 1);
						}
						else if (selectedCategory.IndexOf("allinh") != -1)
						{
							// add filter if it's service related performance counter categories
							if((cname.ToLower().StartsWith("x")) && 
								(cname.ToLower().StartsWith("xbox sginfo") == false))
							{	
								CounterCategoryFilter(selectedService, cname, ref finalCategories);
							}
							else
								finalCategories.Add(cname, 1);
						}
						else 
							finalCategories.Add(cname, 1);
					}
                }
            }

            //UnImpersonate();

            // Weed out non-common counter categories
            //DebugList.Items.Add("===== DISCARDED COUNTER CATEGORIES =====");
            foreach (System.Collections.DictionaryEntry c in finalCategories)
            {
                // If this counter existed on every machine we spoke with, keep it, otherwise throw it out
                if ((int)c.Value == machines.Count)
                {
                    CategoryList.Items.Add((string)c.Key);
                }
                else
                {
                    //DebugList.Items.Add((string)c.Key);  // debug
                }
            }
        }

        /// <summary>
        /// Gets all common performance object instances on the machines and fills a list box
        /// </summary>
        /// <param name="machines"></param>
        /// <param name="perfobjectName"></param>
        /// <param name="InstanceList"></param>
        public void GetInstances(string selectedCat, string selectedComp, ArrayList machines, string perfobjectName, ref ListBox InstanceList, out string exceptionMsg)
        {
            SortedList instances;

            // Get instances common to all selected machines
            instances = GetCommonInstances(selectedCat, selectedComp, machines, perfobjectName, out exceptionMsg);

            // Add to list box
            InstanceList.Items.Clear();
            foreach (string s in instances.Keys)
            {
                InstanceList.Items.Add(s);
            }
            if (InstanceList.Items.Count > 0)
                InstanceList.Items[0].Selected = true;
        }


        /// <summary>
        /// Gets common counters across all machines and fills list box with results
        /// </summary>
        /// <param name="machines"></param>
        /// <param name="InstanceList"></param>
        /// <param name="perfobjectName"></param>
        /// <param name="CounterList"></param>
        /// <returns></returns>
        public SortedList GetCounters(ArrayList machines, ListBox InstanceList, string perfobjectName, ref ListBox CounterList)
        {
            SortedList counters;

            // Get counters common to all selected machines
            if (InstanceList.Items.Count > 0)
                counters = GetCommonCounters(machines, InstanceList.SelectedItem.Text, perfobjectName);
            else
                counters = GetCommonCounters(machines, null, perfobjectName);

            // Add to list box
            CounterList.Items.Clear();
            CounterList.ClearSelection();
            for (int i = 0; i < counters.Count; i++)
            {
                //string type = String.Format("{0}", ((CounterInfo)counters.GetByIndex(i)).CounterType);
                //ListItem item = new ListItem((string)counters.GetKey(i), type);
                //CounterList.Items.Add(item);
                CounterList.Items.Add((string)counters.GetKey(i));
            }

            return counters;
        }

		private bool InstanceFilter(string service, string tempstring, ref SortedList finalInstances)
		{
			bool	addToFinalList = false;
			switch (service)
			{
				case "compplugins":
				case "cron":
				case "cronlib":
					if(tempstring.StartsWith("CRON") ||		// displayName for w3wp instance
						(tempstring.ToLower().IndexOf("cron")!=-1) )	// _lm_w3svc_xxx instance
						addToFinalList = true;
					break;
				case "fbserver":
					if(tempstring.IndexOf("FDBK") != -1 ||
						(tempstring.ToLower().IndexOf("fbserver") != -1))
						addToFinalList = true;
					break;
				case "querylib":
				case "xqry":
					if(tempstring.StartsWith("Query") ||
						(tempstring.ToLower().IndexOf("xqry") != -1))
						addToFinalList = true;
					break;
				case "stfd":
					if(tempstring.IndexOf("STFD") != -1 ||
						(tempstring.ToLower().IndexOf("stfd") != -1))
						addToFinalList = true;
					break;
				case "stringsvr":
					if(tempstring.IndexOf("STRI") != -1 ||
						(tempstring.ToLower().IndexOf("msgserver") != -1))
						addToFinalList = true;
					break;
				case "xarbInh":
				case "xarb":
					if(tempstring.IndexOf("XARB") != -1 ||
						(tempstring.ToLower().IndexOf("xarb") != -1))
						addToFinalList = true;
					break;
				case "xbos":
				case "xcbk":
				case "xsuppapi":
				case "xtou":
				case "xuacs":	
					if((tempstring.IndexOf("XBOS") != -1 ||
						tempstring.IndexOf("XCBK") != -1 ||
						tempstring.IndexOf("CUST") != -1 ) ||
						(tempstring.ToLower().IndexOf("xbos") != -1 ||
						tempstring.ToLower().IndexOf("xuacs") != -1 ||
						tempstring.ToLower().IndexOf("xcbk") != -1 ||
						tempstring.ToLower().IndexOf("xsuppapi") != -1))
						addToFinalList = true;
					break;									
				case "xcache":
					if(tempstring.IndexOf("xcache") != -1)
						addToFinalList = true;
					break;
				case "xmatchfd":
					if(tempstring.IndexOf("MTCH") != -1 ||
						(tempstring.ToLower().IndexOf("xmatch") != -1))
						addToFinalList = true;
					break;
				case "xsig":
					if(tempstring.StartsWith("Signature") ||
						(tempstring.ToLower().IndexOf("xsig") != -1))
						addToFinalList = true;
					break;
				case "xstatsfd":
					if(tempstring.IndexOf("Stats") != -1 ||
						(tempstring.ToLower().IndexOf("xstats") != -1))
						addToFinalList = true;
					break;
				case "xpnfd":
					if(tempstring.ToLower().IndexOf("xpnf") != -1)
						addToFinalList = true;
					break;
				case "xmgmtsrv":
				case "udpadpt":
					addToFinalList = true;
					break;
				default:
					break;
			}
			return addToFinalList;
		}
        /// <summary>
        /// Gets instances common to all machines and returns as a sorted list
        /// </summary>
        /// <param name="machines"></param>
        /// <param name="categoryName"></param>
        /// <returns></returns>
        public SortedList GetCommonInstances(string selectedCategory, string selectedService, ArrayList machines, string categoryName, out string exceptionMsg)
        {
			exceptionMsg = "";
            SortedList finalInstances = new SortedList(30);
            PerformanceCounterCategory category = new PerformanceCounterCategory(categoryName);
			bool	w3wpInstance = false;
            // Get list of instances from each machine
            foreach (object m in machines)
            {
                category.MachineName = m.ToString();
				string[]	instances;
				try
				{
					instances = category.GetInstanceNames();
				}
				catch(InvalidOperationException e)
				{
					exceptionMsg = e.Message + "\n" + e.StackTrace;
					// Some counter categories don't provide any instance information
					// all iis boxes: "WstAgent Servers","WstAgent Deployments","RAS Port"
					return finalInstances;
				}
                foreach (string s in instances)
                {
					w3wpInstance = false;
					string tempstring = s;
					if(tempstring.ToLower().StartsWith("w3wp"))
					{	// change the w3wp id to the display name first
						tempstring = p_GetInstanceDisplayName(category.MachineName, tempstring);
						w3wpInstance = true;
					}
					if (finalInstances.ContainsKey(tempstring))
					{
						finalInstances[tempstring] = (int)finalInstances[tempstring] + 1;					
					}
					else // add to finalInstances
					{
						if (w3wpInstance || 
							tempstring.ToLower().StartsWith(@"/lm/w3svc") ||
							tempstring.ToLower().StartsWith(@"_lm_w3svc") ||
							category.CategoryName.Equals("Web Service"))	
						{	// this instance is an w3swp#, need to add filter to only show selectedService's instances
							if(InstanceFilter(selectedService, tempstring, ref finalInstances))
								finalInstances.Add(tempstring, 1);
							else
								continue;
						}
						else
							finalInstances.Add(tempstring, 1);
					}
                }
            }

            // Weed out non-common ones. 
            for (int i = 0; i < finalInstances.Count; i++)
            {
                if ((int)finalInstances.GetByIndex(i) != machines.Count)
                {
                    //DebugList.Items.Add((string)finalInstances.GetKey(i));  // debug
                    finalInstances.RemoveAt(i);
                    i--;
                }
            }
            return finalInstances;
        }

        /// <summary>
        /// Gets counters common to all machines and returns as a sorted list
        /// </summary>
        /// <param name="machines"></param>
        /// <param name="instanceName"></param>
        /// <param name="categoryName"></param>
        /// <returns></returns>
        public SortedList GetCommonCounters(ArrayList machines, string instanceName, string categoryName)
        {
            PerformanceCounterCategory category = new PerformanceCounterCategory(categoryName);
            SortedList finalCounters = new SortedList(50);
            PerformanceCounter[] counters;

            try
            {
                // Get list of counters from each machine
                foreach (object m in machines)
                {
                    // Get performance counters
                    category.MachineName = m.ToString();
                    if (instanceName == null)
                        counters = category.GetCounters();
                    else
                        counters = category.GetCounters(instanceName);

                    foreach (PerformanceCounter c in counters)
                    {
                        if (finalCounters.ContainsKey(c.CounterName))
                        {
                            ((CounterInfo)finalCounters[c.CounterName]).Increment();
                        }
                        else 
                        {
                            finalCounters.Add(c.CounterName, new CounterInfo((int)c.CounterType, 1));
                        }
                    }
                }

                // Weed out non-common ones
                for (int i = 0; i < finalCounters.Count; i++) 
                {
                    if ((int)finalCounters.GetByIndex(i) != machines.Count)
                    {
                        //DebugList.Items.Add((string)finalCounters.GetKey(i));  // debug
                        finalCounters.RemoveAt(i);
                        i--;
                    }
                }
            
            }
            catch (System.Exception ex)
            {
                System.Console.WriteLine("Error: {0}", ex.ToString());
            }
            return finalCounters;
        }

        /// <summary>
        /// Main entry point for adding a counter to the database via the stored procedure.
        /// </summary>
        /// <param name="info"></param>
        /// <returns></returns>
        public int AddCounter(CounterInfoBase info)
        {
            // Is this a normal counter?
            if (info.GetType().Name == "RealCounterInfo")
            {
                RealCounterInfo info2 = (RealCounterInfo)info;
                p_AddCounterInfo(
					info2.MachineName,
					info2.ObjectName,
					info2.CounterName,
					info2.CounterType,
					info2.DefaultScale,
//					info2.InstanceName,
					info2.CatID,
					info2.CompID,
					info2.DisplayInstanceName,
					null,
					(int)AggType.Normal);
                return 1;
            }
                // Aggregate counter
            else if (info.GetType().Name == "AggCounterInfo")
            {
                AggCounterInfo info2 = (AggCounterInfo)info;
                int count = 0;
                foreach (object o in info2.MachineNames)
                {
                    string machine = (string)o;

                    // Add aggregate
                    p_AddCounterInfo(
                        machine,
                        info2.ObjectName,
                        info2.CounterName,
                        info2.CounterType,
                        info2.DefaultScale,
//                        info2.InstanceName,
                        info2.CatID,
                        info2.CompID,
                        info2.DisplayInstanceName,
                        info2.AggCounterName,
                        info2.AggregateType);
                    count++;
                }
                return count + 1;  // all normal counters + 1 agg counter
            }
            else 
            {
                throw new Exception("Unknown type of CounterInfoBase");
            }
        }

        // legacy for AddCounters.aspx
        public void AddCounter(object[] machines, string category, string instance, string counter, int counterType, int aggType)
        {

            // Always add normal (individual) counters, regardless of type
            foreach (object server in machines)
            {
                p_AddCounterInfo(server.ToString(), category, counter, counterType, 0, -1, -1);
            }

            // If not normal type
            if (aggType != 0)
            {
                AddCounterAggregate(machines, category, instance, counter, counterType, aggType);
            }
        }

        public void AddCounterAggregate(object[] machines, string category, string instance, string counter, int counterType, int type)
        {
            //Hashtable hash = (Hashtable)Session["CounterListHash"];
            string aggCounterName = ""; //CounterTypeList.SelectedItem.Text + "." + counter;
            string counterName;
            counterName = "\\\\...\\" + category + "[" + instance + "]" + "\\" + aggCounterName;
            //if (hash.ContainsKey(counterName))
            //    return;
            //hash.Add(counterName, null);
            //SelectedCountersList.Items.Add(counterName);

            foreach (object server in machines)
            {
                // make DB call here
                p_AddCounterInfo((string)server, category, counter, counterType, 0, -1, -1, null, aggCounterName, type);
            }
        }

        // 
        // The ugly code for interacting with the stored procedures is below.
        //
        #region Stored Procedures

        public int p_AddCounterInfo(
            string MachineName,
            string ObjectName,
            string CounterName,
            int CounterType,
            int DefaultScale,
            int CatID,
            int CompID)
        {
            return p_AddCounterInfo(MachineName, ObjectName, CounterName, CounterType, DefaultScale, CatID, CompID, null, null, (int)AggType.Normal);
        }
        
        public int p_AddCounterInfo(
            string MachineName,
            string ObjectName,
            string CounterName,
            int CounterType,
            int DefaultScale,
            int CatID,
            int CompID,
            string DisplayInstanceName,
            string AggCounterName,
            int AggregateType)
        {       
            SqlCommand sqlCommand = new SqlCommand("p_AddCounterInfo", serverComm.sqlConnection);
            sqlCommand.CommandType = CommandType.StoredProcedure;

            // return value parameter
            SqlParameter retval = new SqlParameter();
            retval.Direction = ParameterDirection.ReturnValue;
            sqlCommand.Parameters.Add(retval);

            sqlCommand.Parameters.Add("@MachineName", SqlDbType.VarChar, 1024).Value = "\\\\" + MachineName;
            sqlCommand.Parameters.Add("@ObjectName", SqlDbType.VarChar, 1024).Value = ObjectName;
            sqlCommand.Parameters.Add("@CounterName", SqlDbType.VarChar, 1024).Value = CounterName;
            sqlCommand.Parameters.Add("@CounterType", SqlDbType.Int).Value = CounterType;
            sqlCommand.Parameters.Add("@DefaultScale", SqlDbType.Int).Value = DefaultScale;
            if (DisplayInstanceName != null)
                sqlCommand.Parameters.Add("@DisplayInstanceName", SqlDbType.VarChar, 1024).Value = DisplayInstanceName;
            if (AggCounterName != null)
                sqlCommand.Parameters.Add("@AggCounterName", SqlDbType.VarChar, 1024).Value = AggCounterName;
            sqlCommand.Parameters.Add("@AggregateType", SqlDbType.Int).Value = AggregateType;
            if (CatID >= 0)
                sqlCommand.Parameters.Add("@CatID", SqlDbType.Int).Value = CatID;
            if (CompID >= 0)
                sqlCommand.Parameters.Add("@CompID", SqlDbType.Int).Value = CompID;
            serverComm.sqlConnection.Open();
            try 
            {
                sqlCommand.ExecuteNonQuery();
                serverComm.sqlConnection.Close();
                return (int)retval.Value;
            }
            catch (System.Data.SqlClient.SqlException e)
            {
		    throw (e);
            }
        }

        public ArrayList p_GetRealCounterInfo(
            int CategoryID,
            int ComponentID,
            string MachineName)
        {
            SqlCommand sqlCommand = new SqlCommand("p_GetRealCounterInfo", serverComm.sqlConnection);
            sqlCommand.CommandType = CommandType.StoredProcedure;

            // return value parameter
            SqlParameter retval = new SqlParameter();
            retval.Direction = ParameterDirection.ReturnValue;
            sqlCommand.Parameters.Add(retval);

            if (CategoryID >= 0) 
                sqlCommand.Parameters.Add("@CategoryID", SqlDbType.Int).Value = CategoryID;
            if (ComponentID >= 0)
                sqlCommand.Parameters.Add("@ComponentID", SqlDbType.Int).Value = ComponentID;
            if (MachineName != null)
                sqlCommand.Parameters.Add("@MachineName", SqlDbType.VarChar, 1024).Value = "\\\\" + MachineName;
			//else "All normal" is selected as "Machines"
            serverComm.sqlConnection.Open();
            SqlDataReader dReader = sqlCommand.ExecuteReader();
            //serverComm.sqlConnection.Close();
            //return (int)retval.Value;

            // Columns in the returned data reader
            const int COUNTERID = 0;
            const int MACHINENAME = 1;
            const int OBJECTNAME = 2;
            const int COUNTERNAME = 3;
            const int INSTANCENAME = 4;
			const int DISPLAYNAME = 5;

            ArrayList list = new ArrayList(16);
            while (dReader.Read())
            {
                RealCounterInfo info = new RealCounterInfo(
                    dReader.GetString(MACHINENAME),
                    dReader.GetString(OBJECTNAME),
                    dReader.GetString(COUNTERNAME),
                    COUNTER_TYPE,
                    0,
                    dReader.GetString(INSTANCENAME),
                    dReader.GetString(DISPLAYNAME),
                    CategoryID,
                    ComponentID,
                    dReader.GetInt32(COUNTERID));
                list.Add(info);
            }
            dReader.Close();
            serverComm.sqlConnection.Close();

            return list;
        }

        public int p_GetRealCounterInfo_Count(
            int CategoryID,
            int ComponentID,
            string MachineName)
        {
            SqlCommand sqlCommand = new SqlCommand("p_GetRealCounterInfo_Count", serverComm.sqlConnection);
            sqlCommand.CommandType = CommandType.StoredProcedure;

            // return value parameter
            SqlParameter retval = new SqlParameter();
            retval.Direction = ParameterDirection.ReturnValue;
            sqlCommand.Parameters.Add(retval);

            if (CategoryID >= 0) 
                sqlCommand.Parameters.Add("@CategoryID", SqlDbType.Int).Value = CategoryID;
            if (ComponentID >= 0)
                sqlCommand.Parameters.Add("@ComponentID", SqlDbType.Int).Value = ComponentID;
            if (MachineName != null)
                sqlCommand.Parameters.Add("@MachineName", SqlDbType.VarChar, 1024).Value = "\\\\" + MachineName;
            sqlCommand.Parameters.Add("@RowCount", SqlDbType.Int).Direction = ParameterDirection.Output;
            serverComm.sqlConnection.Open();
            sqlCommand.ExecuteNonQuery();
            serverComm.sqlConnection.Close();
            return (int)sqlCommand.Parameters["@RowCount"].Value;
        }

        public ArrayList p_GetAggCounterInfo(
            int CategoryID,
            int ComponentID)
        {
            SqlCommand sqlCommand = new SqlCommand("p_GetAggCounterInfo", serverComm.sqlConnection);
            sqlCommand.CommandType = CommandType.StoredProcedure;

            // return value parameter
            SqlParameter retval = new SqlParameter();
            retval.Direction = ParameterDirection.ReturnValue;
            sqlCommand.Parameters.Add(retval);

            if (CategoryID >= 0) 
                sqlCommand.Parameters.Add("@CategoryID", SqlDbType.Int).Value = CategoryID;
            if (ComponentID >= 0)
                sqlCommand.Parameters.Add("@ComponentID", SqlDbType.Int).Value = ComponentID;
            serverComm.sqlConnection.Open();
            SqlDataReader dReader = sqlCommand.ExecuteReader();
            //serverComm.sqlConnection.Close();
            //return (int)retval.Value;
            //return dReader;

            // Columns in the returned data reader
            const int COUNTERID = 0;
            const int OBJECTNAME = 1;
            const int COUNTERNAME = 2;
            const int TYPE = 3;
		//	const int DISPLAYNAME = 4;

            ArrayList list = new ArrayList(16);
            while (dReader.Read())
            {
                AggCounterInfo info = new AggCounterInfo(
                    null,  // machine names
                    dReader.GetString(OBJECTNAME),
                    null, // counter name
                    COUNTER_TYPE,
                    0,
                    null, //dReader.GetString(INSTANCENAME),
                    null,//dReader.GetString(INSTANCENAME),
                    dReader.GetString(COUNTERNAME), // aggCounterName
                    dReader.GetByte(TYPE),  // not sure about this column..
                    CategoryID,
                    ComponentID,
                    dReader.GetInt32(COUNTERID));
                list.Add(info);
            }
            dReader.Close();
            serverComm.sqlConnection.Close();
			
            return list;
        }            

        public int p_GetAggCounterInfo_Count(
            int CategoryID,
            int ComponentID)
        {
            SqlCommand sqlCommand = new SqlCommand("p_GetAggCounterInfo_Count", serverComm.sqlConnection);
            sqlCommand.CommandType = CommandType.StoredProcedure;

            // return value parameter
            SqlParameter retval = new SqlParameter();
            retval.Direction = ParameterDirection.ReturnValue;
            sqlCommand.Parameters.Add(retval);

            if (CategoryID >= 0) 
                sqlCommand.Parameters.Add("@CategoryID", SqlDbType.Int).Value = CategoryID;
            if (ComponentID >= 0)
                sqlCommand.Parameters.Add("@ComponentID", SqlDbType.Int).Value = ComponentID;
            sqlCommand.Parameters.Add("@RowCount", SqlDbType.Int).Direction = ParameterDirection.Output;
            serverComm.sqlConnection.Open();
            sqlCommand.ExecuteNonQuery();
            serverComm.sqlConnection.Close();
            return (int)sqlCommand.Parameters["@RowCount"].Value;
        }            

        public int p_GetAggCounterDetails(
            int CounterID,
            ref AggCounterInfo aggCounter)
        {
            SqlCommand sqlCommand = new SqlCommand("p_GetAggCounterDetails", serverComm.sqlConnection);
            sqlCommand.CommandType = CommandType.StoredProcedure;

            // return value parameter
            SqlParameter retval = new SqlParameter();
            retval.Direction = ParameterDirection.ReturnValue;
            sqlCommand.Parameters.Add(retval);

            sqlCommand.Parameters.Add("@CounterID", SqlDbType.Int).Value = CounterID;
            serverComm.sqlConnection.Open();
            SqlDataReader dReader = sqlCommand.ExecuteReader();

            // Columns in the returned data reader
            //const int REALCOUNTERID = 0;
            const int REALOBJECTNAME = 1;
            const int REALCOUNTERNAME = 2;
            const int REALINSTANCENAME = 3;
            const int REALMACHINENAME = 4;

            ArrayList list = new ArrayList(16);
            while (dReader.Read())
            {
                // Safety checks
                if (dReader.GetString(REALOBJECTNAME) != aggCounter.ObjectName)
                    throw new Exception("This aggregate counter detail doesn't match its parent");
                //if (dReader.GetString(REALCOUNTERNAME) != aggCounter.CounterName)
                //    throw new Exception("This aggregate counter detail doesn't match its parent");
                //if (dReader.GetString(REALINSTANCENAME) != aggCounter.InstanceName)
                //    throw new Exception("This aggregate counter detail doesn't match its parent");
                aggCounter.CounterName = dReader.GetString(REALCOUNTERNAME);
                aggCounter.CounterName = dReader.GetString(REALINSTANCENAME);
                // Append machine name to array
                aggCounter.MachineNames.Add(dReader.GetString(REALMACHINENAME));
            }
            dReader.Close();
            serverComm.sqlConnection.Close();
            return (int)retval.Value;
        }            

		public int p_DeleteCounterInfo(
			int CounterID, int CatID, int CompID)
		{
			SqlCommand sqlCommand = new SqlCommand("p_DeleteCounterInfo", serverComm.sqlConnection);
			sqlCommand.CommandType = CommandType.StoredProcedure;

			// return value parameter
			SqlParameter retval = new SqlParameter();
			retval.Direction = ParameterDirection.ReturnValue;
			sqlCommand.Parameters.Add(retval);

			sqlCommand.Parameters.Add("@CounterID", SqlDbType.Int).Value = CounterID;
			sqlCommand.Parameters.Add("@Componentid", SqlDbType.Int).Value = CompID;
			sqlCommand.Parameters.Add("@Categoryid", SqlDbType.Int).Value = CatID;
			serverComm.sqlConnection.Open();
			sqlCommand.ExecuteNonQuery();
			serverComm.sqlConnection.Close();
			return (int)retval.Value;
		}   

		public string p_GetInstanceDisplayName(
			string MachineName ,
			string InstanceName )
		{
			string DisplayName;
			SqlCommand sqlCommand = new SqlCommand("p_GetInstanceDisplayName", serverComm.sqlConnection);
			sqlCommand.CommandType = CommandType.StoredProcedure;

			// return value parameter
			SqlParameter retval = new SqlParameter();
			retval.Direction = ParameterDirection.ReturnValue;
			sqlCommand.Parameters.Add(retval);

			
			if (MachineName != null)
				if (!MachineName.StartsWith ("\\"))
				{
					MachineName = "\\\\" + MachineName;
				}
				sqlCommand.Parameters.Add("@MachineName", SqlDbType.VarChar, 1024).Value = MachineName;
			if (InstanceName != null)
				sqlCommand.Parameters.Add("@InstanceName", SqlDbType.VarChar, 1024).Value = InstanceName;
			serverComm.sqlConnection.Open();
			SqlDataReader dReader = sqlCommand.ExecuteReader();

			// Columns in the returned data reader
			//const int REALCOUNTERID = 0;
			const int DISPLAYNAME = 0;
			
			if (dReader.Read())
			{
				// Safety checks
				if (dReader.GetString(DISPLAYNAME) != "")
				{
					DisplayName = dReader.GetString(DISPLAYNAME);
				}
				else
				{
					DisplayName = InstanceName;
				}
			}
			else
			{
				DisplayName = InstanceName;
			}
			dReader.Close();
			serverComm.sqlConnection.Close();
			return DisplayName;
		}
        #endregion


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\XBLPerfLogTool\PerfLogTool.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace XBLPerfLogTool
{
   
	/// <summary>
	/// Summary description for PerfLogTool.
	/// </summary>
	public class PerfLogTool : PerfLogToolBase
	{
        #region Control declarations

        protected System.Web.UI.WebControls.Label FilterResultsLabel;
        protected System.Web.UI.WebControls.ListBox ExistingCountersList;
        protected System.Web.UI.WebControls.Button AddNewBtn;
        protected System.Web.UI.WebControls.LinkButton FilterResultsLnk;
        protected System.Data.SqlClient.SqlCommand sqlcmdSelectCategoriesAll;
        protected System.Data.SqlClient.SqlCommand sqlcmdSelectComponents;
        protected System.Web.UI.WebControls.Panel FilterPanel;
        protected System.Data.SqlClient.SqlCommand sqlcmdSelectComponentsAll;
        protected System.Data.SqlClient.SqlCommand sqlcmdSelectMachinesAll;
        protected System.Data.SqlClient.SqlCommand sqlcmdSelectMachinesCat;
        protected System.Data.SqlClient.SqlCommand sqlcmdSelectMachinesComp;
        protected System.Data.SqlClient.SqlCommand sqlcmdSelectMachinesBoth;
        protected System.Web.UI.WebControls.Panel EditPanel;
        protected System.Web.UI.WebControls.Panel DetailsPanel;
        protected System.Web.UI.WebControls.Label Label1;
        protected System.Web.UI.WebControls.Button SaveChangesBtn;
        protected System.Web.UI.WebControls.Button CancelBtn;
        protected System.Web.UI.WebControls.DropDownList CategoryList1;
        protected System.Web.UI.WebControls.DropDownList ComponentList1;
        protected System.Web.UI.WebControls.DropDownList MachineList1;
        protected System.Web.UI.WebControls.DropDownList PerfObjectList1;
        protected System.Web.UI.WebControls.Label CategoryLabel1;
        protected System.Web.UI.WebControls.Label ComponentLabel1;
        protected System.Web.UI.WebControls.Label MachineLabel1;
        protected System.Web.UI.WebControls.Label PerfObjectLabel1;
        protected System.Web.UI.WebControls.Label CategoryLabel;
        protected System.Web.UI.WebControls.Label ComponentLabel;
        protected System.Web.UI.WebControls.Label PerfObjectLabel;
        protected System.Web.UI.WebControls.Label InstanceLabel;
        protected System.Web.UI.WebControls.Label CounterLabel;
        protected System.Web.UI.WebControls.ListBox PerfObjectList;
        protected System.Web.UI.WebControls.ListBox InstanceList;
        protected System.Web.UI.WebControls.ListBox CounterList;
        protected System.Web.UI.WebControls.Label CounterTypeLabel;
        protected System.Web.UI.WebControls.Label CounterNameLabel;
        protected System.Web.UI.WebControls.DropDownList CounterTypeList;
        protected System.Web.UI.WebControls.TextBox CounterNameText;
        protected System.Web.UI.WebControls.Button AddCounterBtn;
        protected System.Web.UI.WebControls.Button RemoveCounterBtn;
        protected System.Web.UI.WebControls.ListBox CountersToAddList;
        protected System.Web.UI.WebControls.Button SaveBtn;
        protected System.Web.UI.WebControls.Button SaveCloseBtn;
        protected System.Web.UI.WebControls.Label EditStatusLabel;
        protected System.Web.UI.WebControls.Label EditStatusLabel2;
        protected System.Web.UI.WebControls.Panel PanelMachines;
        protected System.Web.UI.WebControls.Label AllMachinesLabel;
        protected System.Web.UI.WebControls.Label SelectedMachinesLabel;
        protected System.Web.UI.WebControls.ListBox AllMachinesList;
        protected System.Web.UI.WebControls.Button AddMachineBtn;
        protected System.Web.UI.WebControls.Button RemoveMachineBtn;
        protected System.Web.UI.WebControls.ListBox SelectedMachinesList;
    //    protected System.Web.UI.WebControls.Button RefreshCountersBtn;
		protected System.Web.UI.WebControls.Button DeleteBtn;
		protected System.Web.UI.WebControls.Button RefreshBtn;
		protected System.Web.UI.WebControls.Label DetailsComponent;
		protected System.Web.UI.WebControls.Label DetailsCategory;
		protected System.Web.UI.WebControls.Label DetailsMachines;
		protected System.Web.UI.WebControls.Label DetailsCounterID;
		protected System.Web.UI.WebControls.Label Label2;
		protected System.Web.UI.WebControls.Button reloadCountersBtn;
		protected System.Web.UI.WebControls.Label EditLabel3;
		protected System.Web.UI.WebControls.Panel MenuPanel;
        protected System.Data.SqlClient.SqlConnection sqlConnection1;

        #endregion

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.sqlConnection1 = new System.Data.SqlClient.SqlConnection();
			this.sqlcmdSelectCategoriesAll = new System.Data.SqlClient.SqlCommand();
			this.sqlcmdSelectComponents = new System.Data.SqlClient.SqlCommand();
			this.sqlcmdSelectComponentsAll = new System.Data.SqlClient.SqlCommand();
			this.sqlcmdSelectMachinesAll = new System.Data.SqlClient.SqlCommand();
			this.sqlcmdSelectMachinesBoth = new System.Data.SqlClient.SqlCommand();
			this.sqlcmdSelectMachinesCat = new System.Data.SqlClient.SqlCommand();
			this.sqlcmdSelectMachinesComp = new System.Data.SqlClient.SqlCommand();
			// 
			// sqlConnection1
			// 
			this.sqlConnection1.ConnectionString = "user id=PerfLogTool;password=PerfLogTool;data source=localhost;persist security i" +
				"nfo=False;initial catalog=PerfDB";
			// 
			// sqlcmdSelectCategoriesAll
			// 
			this.sqlcmdSelectCategoriesAll.CommandText = "SELECT CategoryID, CategoryName FROM Category ORDER BY CategoryName";
			this.sqlcmdSelectCategoriesAll.Connection = this.sqlConnection1;
			// 
			// sqlcmdSelectComponents
			// 
			this.sqlcmdSelectComponents.CommandText = @"SELECT DISTINCT Component.ComponentID AS ComponentID, Component.ComponentName AS ComponentName FROM Component INNER JOIN CompCatMach ON Component.ComponentID = CompCatMach.ComponentID WHERE (CompCatMach.CategoryID = @catid) ORDER BY Component.ComponentName";
			this.sqlcmdSelectComponents.Connection = this.sqlConnection1;
			this.sqlcmdSelectComponents.Parameters.Add(new System.Data.SqlClient.SqlParameter("@catid", System.Data.SqlDbType.Int, 4, "CategoryID"));
			// 
			// sqlcmdSelectComponentsAll
			// 
			this.sqlcmdSelectComponentsAll.CommandText = "SELECT ComponentID, ComponentName FROM Component";
			this.sqlcmdSelectComponentsAll.Connection = this.sqlConnection1;
			// 
			// sqlcmdSelectMachinesAll
			// 
			this.sqlcmdSelectMachinesAll.CommandText = "SELECT MachineID, MachineName FROM Machines ORDER BY MachineName";
			this.sqlcmdSelectMachinesAll.Connection = this.sqlConnection1;
			// 
			// sqlcmdSelectMachinesBoth
			// 
			this.sqlcmdSelectMachinesBoth.CommandText = @"SELECT DISTINCT Machines.MachineID AS MachineID, Machines.MachineName AS MachineName FROM CompCatMach INNER JOIN Machines ON CompCatMach.MachineID = Machines.MachineID WHERE (CompCatMach.CategoryID = @catid) AND (CompCatMach.ComponentID = @compid) ORDER BY Machines.MachineName";
			this.sqlcmdSelectMachinesBoth.Connection = this.sqlConnection1;
			this.sqlcmdSelectMachinesBoth.Parameters.Add(new System.Data.SqlClient.SqlParameter("@catid", System.Data.SqlDbType.Int, 4, "CategoryID"));
			this.sqlcmdSelectMachinesBoth.Parameters.Add(new System.Data.SqlClient.SqlParameter("@compid", System.Data.SqlDbType.Int, 4, "ComponentID"));
			// 
			// sqlcmdSelectMachinesCat
			// 
			this.sqlcmdSelectMachinesCat.CommandText = "SELECT DISTINCT Machines.MachineID AS MachineID, Machines.MachineName AS MachineN" +
				"ame FROM CompCatMach INNER JOIN Machines ON CompCatMach.MachineID = Machines.Mac" +
				"hineID WHERE (CompCatMach.CategoryID = @catid) ORDER BY Machines.MachineName";
			this.sqlcmdSelectMachinesCat.Connection = this.sqlConnection1;
			this.sqlcmdSelectMachinesCat.Parameters.Add(new System.Data.SqlClient.SqlParameter("@catid", System.Data.SqlDbType.Int, 4, "CategoryID"));
			// 
			// sqlcmdSelectMachinesComp
			// 
			this.sqlcmdSelectMachinesComp.CommandText = "SELECT DISTINCT Machines.MachineID AS MachineID, Machines.MachineName AS MachineN" +
				"ame FROM CompCatMach INNER JOIN Machines ON CompCatMach.MachineID = Machines.Mac" +
				"hineID WHERE (CompCatMach.ComponentID = @compid) ORDER BY Machines.MachineName";
			this.sqlcmdSelectMachinesComp.Connection = this.sqlConnection1;
			this.sqlcmdSelectMachinesComp.Parameters.Add(new System.Data.SqlClient.SqlParameter("@compid", System.Data.SqlDbType.Int, 4, "ComponentID"));
			this.CategoryList1.SelectedIndexChanged += new System.EventHandler(this.CategoryList1_SelectedIndexChanged);
			this.ComponentList1.SelectedIndexChanged += new System.EventHandler(this.ComponentList1_SelectedIndexChanged);
			this.MachineList1.SelectedIndexChanged += new System.EventHandler(this.MachineList1_SelectedIndexChanged);
			this.reloadCountersBtn.Click += new System.EventHandler(this.reloadCountersBtn_Click);
			this.FilterResultsLnk.Click += new System.EventHandler(this.FilterResultsLnk_Click);
			this.ExistingCountersList.SelectedIndexChanged += new System.EventHandler(this.ExistingCountersList_SelectedIndexChanged);
			this.AddNewBtn.Click += new System.EventHandler(this.AddNewBtn_Click);
			this.DeleteBtn.Click += new System.EventHandler(this.DeleteBtn_Click);
			this.RefreshBtn.Click += new System.EventHandler(this.RefreshBtn_Click);
			this.CounterTypeList.SelectedIndexChanged += new System.EventHandler(this.CounterTypeList_SelectedIndexChanged);
			this.AddMachineBtn.Click += new System.EventHandler(this.AddMachineBtn_Click);
			this.RemoveMachineBtn.Click += new System.EventHandler(this.RemoveMachineBtn_Click);
			this.PerfObjectList.SelectedIndexChanged += new System.EventHandler(this.PerfObjectList_SelectedIndexChanged);
			this.InstanceList.SelectedIndexChanged += new System.EventHandler(this.InstanceList_SelectedIndexChanged);
			this.AddCounterBtn.Click += new System.EventHandler(this.AddCounterBtn_Click);
			this.RemoveCounterBtn.Click += new System.EventHandler(this.RemoveCounterBtn_Click);
			this.SaveBtn.Click += new System.EventHandler(this.SaveBtn_Click);
			this.SaveCloseBtn.Click += new System.EventHandler(this.SaveCloseBtn_Click);
			this.CancelBtn.Click += new System.EventHandler(this.CancelBtn_Click);
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion
        
        private void Page_Load(object sender, System.EventArgs e)
        {
            // First time loaded
            if (!IsPostBack)
            {
                // Refresh all lists
                Refresh_Page();
            }
        }

        #region Database Refreshers
        private void RefreshCategoryList()
        {
            BindList(CategoryList1, sqlcmdSelectCategoriesAll, "CategoryName", "CategoryID");
        }

        private void RefreshComponentList()
        {
			if (CategoryList1.SelectedIndex < 0)
                BindList(ComponentList1, sqlcmdSelectComponentsAll, "ComponentName", "ComponentID");
            else
            {
                sqlcmdSelectComponents.Parameters["@catid"].Value = CategoryList1.SelectedValue;
                BindList(ComponentList1, sqlcmdSelectComponents, "ComponentName", "ComponentID");
            }
        }

        private void RefreshMachineList()
        {
            // no categories selected?
			   if (CategoryList1.SelectedIndex < 0)
            {
				if (ComponentList1.SelectedIndex < 0)
                {
                    BindList(MachineList1, sqlcmdSelectMachinesAll, "MachineName", "MachineID");
                }
                // All categories, 1 component
                else
                {
                    sqlcmdSelectMachinesComp.Parameters["@compid"].Value = ComponentList1.SelectedValue;
                    BindList(MachineList1, sqlcmdSelectMachinesComp, "MachineName", "MachineID");
                }                                                                                                         
            }
            else
            {
				if (ComponentList1.SelectedIndex < 0)
                {
                    sqlcmdSelectMachinesCat.Parameters["@catid"].Value = CategoryList1.SelectedValue;
                    BindList(MachineList1, sqlcmdSelectMachinesCat, "MachineName", "MachineID");
                }
                // 1 category, 1 component
                else
                {
                    sqlcmdSelectMachinesBoth.Parameters["@compid"].Value = ComponentList1.SelectedValue;
                    sqlcmdSelectMachinesBoth.Parameters["@catid"].Value = CategoryList1.SelectedValue;
                    BindList(MachineList1, sqlcmdSelectMachinesBoth, "MachineName", "MachineID");
                }                                                                                                         
            }
            MachineList1.Items.Insert(0, new ListItem("(All normal)"));
            MachineList1.Items.Insert(1, new ListItem("(All aggregate)"));
        }
//
//        private void RefreshPerfObjectList()
//        {
//            PerfObjectList1.Items.Clear();
//            PerfObjectList1.Items.Add(new ListItem("(Not implemented yet)", "-1"));
//        }

		private void RefreshExistingCountersList(bool clickDeleteButton)
		{
			DetailsCounterID.Text = "";
			DetailsMachines.Text = "";
			DetailsCategory.Text = "";
			DetailsComponent.Text = "";

			if(clickDeleteButton)	//Delete button was clicked
			{
				ExistingCountersList.Items.Clear();
				GetExistingCounters(true);
			}
			else
			{
				ExistingCountersList.Items.Clear();
				FilterResultsLabel.Text = "0 counters saved";
				FilterResultsLnk.Text = "";

				// Show all results if at least one (1) filter box is selected
				if (CategoryList1.SelectedIndex > 0 || ComponentList1.SelectedIndex > 0 || MachineList1.SelectedIndex > 0)
					GetExistingCounters(true);
				else
					GetExistingCounters(false);
			}
		}

        #endregion


        protected bool IsAggregateSelected()
        {
            return MachineList1.SelectedIndex >= 0 && MachineList1.SelectedItem.Text == "(All aggregate)";
        }

        private void GetExistingCounters(bool bGetData)
        {
            // Get actual counter info
            if (bGetData)
            {
                ArrayList list;
                if (IsAggregateSelected())
                {
                    list = p_GetAggCounterInfo(int.Parse(CategoryList1.SelectedValue), int.Parse(ComponentList1.SelectedValue));
                }
                else
                {
                    string machinename = null;
                    if (MachineList1.SelectedIndex >= 2)
                        machinename = MachineList1.SelectedItem.Text;
                    list = p_GetRealCounterInfo(int.Parse(CategoryList1.SelectedValue), int.Parse(ComponentList1.SelectedValue), machinename);
                }
                
                foreach (object o in list)
                {
					CounterInfoBase info = (CounterInfoBase)o;						
                    string name = info.ToString();
                    ExistingCountersList.Items.Add(new ListItem(name, String.Format("{0}", info.CounterID)));
                }
                FilterResultsLabel.Text = String.Format("{0} counters saved", ExistingCountersList.Items.Count);
                FilterResultsLnk.Text = "";
                Session["ExistingCounters"] = list;
            }
            // Only get row count for what would have been returned
            else
            {
                int rowcount = 0;
                if (IsAggregateSelected())
                {
                    rowcount = p_GetAggCounterInfo_Count(int.Parse(CategoryList1.SelectedValue), int.Parse(ComponentList1.SelectedValue));
                }
                else
                {
                    string machinename = null;
                    if (MachineList1.SelectedIndex >= 2)
                        machinename = MachineList1.SelectedItem.Text;
                    rowcount = p_GetRealCounterInfo_Count(int.Parse(CategoryList1.SelectedValue), int.Parse(ComponentList1.SelectedValue), machinename);
                }
                FilterResultsLabel.Text = String.Format("{0} counters saved", rowcount);
                FilterResultsLnk.Text = "Click to view them all";
            }
        }


        private void SetEditCounterType(int type)
        {
            if (type == (int)AggType.Normal)
            {
                CounterNameLabel.Visible = false;
                CounterNameText.Visible = false;
                CounterTypeList.SelectedIndex = type;
            }
            else if (type == (int)AggType.Sum || type == (int)AggType.Average)
            {
                CounterNameLabel.Visible = true;
                CounterNameText.Visible = true;
                CounterTypeList.SelectedIndex = type;
            }
        }

        /// <summary>
        /// Show details of counter in the Details panel
        /// </summary>
        /// <param name="info">Counter to show details of. If null, clear the details panel.</param>
        private void ShowDetails(CounterInfoBase info)
        {
            if (info == null)
            {
                DetailsCounterID.Text = "";
                DetailsMachines.Text = "";
                DetailsCategory.Text = "";
                DetailsComponent.Text = "";
            }
            else
            {
                DetailsCounterID.Text = String.Format("{0}: {1}", info.CounterID, info.ToString());

                // If this is an aggregate counter, make DB request for more info
                if (info.GetType().Name == "AggCounterInfo")
                {
                    AggCounterInfo aggInfo = (AggCounterInfo)info;
					aggInfo.MachineNames.Clear();
                    p_GetAggCounterDetails(info.CounterID, ref aggInfo);
                    DetailsMachines.Text = aggInfo.ToStringMachines();
                }
                else
                {
                    RealCounterInfo realInfo = (RealCounterInfo)info;
                    DetailsMachines.Text = realInfo.MachineName;
                }

				// convert numeric value to text value before showing in the UI
				string cat = "", comp = "";
				object	temp;
				if((Application["CategoryListHash"] != null) &&
					(Application["ComponentListHash"] != null))
				{
					if((temp=(((Hashtable)Application["CategoryListHash"])[info.CatID])) != null)
						cat = (string)temp;
					if((temp =(((Hashtable)Application["ComponentListHash"])[info.CompID])) != null)
						comp = (string)temp;
				}
                DetailsCategory.Text = cat;
                DetailsComponent.Text = comp;
            }
        }

        /// <summary>
        /// Toggle display of the EditPanel and corresponding state of FilterPanel and DetailsPanel
        /// </summary>
        /// <param name="showedit">True: Show edit panel, False: Hide edit panel</param>
        private void ShowEditPanel(bool showedit)
        {
            if (showedit)
            {
                FilterPanel.Visible = false;
                //SearchFilterLabel.Visible = false;
                DetailsPanel.Visible = false;
                EditPanel.Visible = true;

                // Clear out all controls in Edit panel
                CategoryLabel.Text = "";
                ComponentLabel.Text = "";
                CounterNameText.Text = "";
                CounterNameText.ForeColor = Color.Black;
                SetEditCounterType(0);  // set to Normal counter
                AllMachinesList.Items.Clear();
                SelectedMachinesList.Items.Clear();
                EditStatusLabel.Text = "";
                PerfObjectList.Items.Clear();
                InstanceList.Items.Clear();
                CounterList.Items.Clear();
                CountersToAddList.Items.Clear();
                EditStatusLabel2.Text = "";

                // Clear the stored list of counters to add
                Session.Remove("CountersToAdd");
             
            }
            else
            {
                FilterPanel.Visible = true;
                //SearchFilterLabel.Visible = true;
                DetailsPanel.Visible = true;
                EditPanel.Visible = false;
            }
			
        }

        /// <summary>
        /// Initialize the EditCounter panel for a brand new counter
        /// </summary>
        private void ShowEditPanel_New()
        {
            // Initialize Category and Component fields based on filter settings
            CategoryLabel.Text = CategoryList1.SelectedItem.Text;
            ComponentLabel.Text = ComponentList1.SelectedItem.Text;
            Session["CategoryID"] = CategoryList1.SelectedValue;
            Session["ComponentID"] = ComponentList1.SelectedValue;

            // If filtering on (All normal) or (All aggregate), then add all machines to selected list
            bool bCopyAll = (MachineList1.SelectedIndex == 0) || (MachineList1.SelectedIndex == 1);

            // Set counter type to an arbitrary aggregate type if (All aggregates) is selected
            if (MachineList1.SelectedIndex == 1)
            {
                SetEditCounterType((int)AggType.Average);
            }

            // Copy over list of machines from filter box. Skip first two, since they are 
            // (All normal) and (All aggregate).
            for (int i = 2; i < MachineList1.Items.Count; i++)
            {
                // If selected, add to Selected box
                if (MachineList1.Items[i].Selected || bCopyAll)
                {
                    SelectedMachinesList.Items.Add(MachineList1.Items[i]);
                }
                    // Otherwise add to All Machines list
                else
                {
                    AllMachinesList.Items.Add(MachineList1.Items[i]);
                }
            }

            // Fill listbox with categories common to all machines
			GetCategories(true);	// only use cache if "All Normal" is selected.
        }

        /// <summary>
        /// Initialize the panel for editing an existing counter
        /// </summary>
        private void ShowEditPanel_Edit()
        {
            // TODO
        }

        /// <summary>
        /// Get common categories from selected machines and update UI
        /// </summary>
        private void GetCategories(bool useCache)
        {
            PerfObjectList.Items.Clear();
            EditStatusLabel.Text = "";
            CounterNameText.ForeColor = Color.Black;

            // Get list of common categories from all machines
            try 
            {
				if(useCache)
				{
					// cache the categoryList if "(All normal)" is selected in Machines
					// since it is a very time consuming operation 
					string cat = CategoryList1.SelectedItem.Text;
					if (MachineList1.SelectedIndex == 0 && Application[cat] == null)
					{
						GetCategories(CategoryList1.SelectedItem.Text, ComponentList1.SelectedItem.Text,ListToArrayList(SelectedMachinesList), ref PerfObjectList);
						Application.Add(cat,PerfObjectList.Items);
					}
					else if (Application[cat] != null)
					{
						ListItemCollection	lic= (ListItemCollection)Application[cat];
						IEnumerator			ie = lic.GetEnumerator();
						ListItem			item;
						while(ie.MoveNext())
						{
							item = (ListItem)ie.Current;
							PerfObjectList.Items.Add(item);
						}
					}
					else
						GetCategories(CategoryList1.SelectedItem.Text, ComponentList1.SelectedItem.Text,ListToArrayList(SelectedMachinesList), ref PerfObjectList);
				}
				else
						GetCategories(CategoryList1.SelectedItem.Text, ComponentList1.SelectedItem.Text,ListToArrayList(SelectedMachinesList), ref PerfObjectList);
            }
            catch (System.Exception ex)
            {
                // Restore panel
                EditStatusLabel.Text = String.Format("Error getting categories: {0}", ex.ToString());
                return;
            }
            InstanceList.Items.Clear();
            CounterList.Items.Clear();
        }



        #region Edit Panel Buttons
        
        /// <summary>
        /// Store the currently created counter to a listbox and the Session variable, but
        /// don't write to the database.  This function has input parameters mainly for the 
        /// situation where multi-select is enabled for the CounterName and InstanceName listboxes.
        /// </summary>
        /// <param name="machines">List of selected machines. Used to specify multiple normal counters at once
        /// or the machines for a single aggregate counter.</param>
        /// <param name="counterName">The name of the counter.</param>
        /// <param name="instanceName">The name of the instance.</param>
        private void StoreCounter(ArrayList machines, string counterName, string displayName)
        {
            Hashtable hash = (Hashtable)Session["CountersToAdd"];
            if (hash == null)
            {
                Session.Add("CountersToAdd", new Hashtable(100));
                hash = (Hashtable)Session["CountersToAdd"];
            }

            // Is this a normal counter or an aggregate?
            if (CounterTypeList.SelectedIndex == (int)AggType.Normal)
            {
                foreach (object o in machines)
                {
                    string machineName = (string)o;

                    // Create counter info object
                    RealCounterInfo info = new RealCounterInfo(
                        machineName, 
                        PerfObjectList.SelectedItem.Text,
                        counterName,
                        COUNTER_TYPE,
                        0,
                        null,
                        displayName,
                        int.Parse((string)Session["CategoryID"]),
                        int.Parse((string)Session["ComponentID"]),
                        -1);
                            
                    // And add it to CountersToAdd listbox and session hashtable, if it doesn't
                    // already exist.
                    string name = info.ToString();
                    if (!hash.ContainsKey(name))
                    {
                        hash.Add(name, info);
                        CountersToAddList.Items.Add(name);
                    }
                }
            }
                // Otherwise this is an aggregate counter
            else
            {
                // Force user to create a name for this aggregate counter
                if (CounterNameText.Text == "")
                {
                    CounterNameLabel.ForeColor = Color.Red;
                    EditStatusLabel.Text = "Please name this aggregate counter!";
                    return;
                }
                // Create counter info object
                AggCounterInfo info = new AggCounterInfo(
                    machines, 
                    PerfObjectList.SelectedItem.Text,
                    counterName,
                    COUNTER_TYPE,
                    0,
                    displayName,
                    displayName,
                    CounterNameText.Text,
                    CounterTypeList.SelectedIndex,
                    int.Parse((string)Session["CategoryID"]),
                    int.Parse((string)Session["ComponentID"]),
                    -1);

                // And add it to CountersToAdd listbox and session hashtable, if it doesn't
                // already exist.
                string name = info.ToString();
                if (!hash.ContainsKey(name))
                {
                    hash.Add(name, info);
                    CountersToAddList.Items.Add(name);
                }
            }
        }

        /// <summary>
        /// Write stored but unsaved counters to the database
        /// </summary>
        private void SaveStoredCounters()
        {
            Hashtable hash = (Hashtable)Session["CountersToAdd"];
            if ((hash == null) || (hash.Count == 0))
            {
                CountersToAddList.Items.Clear();
				EditStatusLabel2.ForeColor = Color.Red;
				EditStatusLabel2.Font.Bold = true;
                EditStatusLabel2.Text = "add counters first!";
                return;
            }

            // save them here
            int totalwritten = 0;
            foreach (object val in hash.Values)
            {
                CounterInfoBase info = (CounterInfoBase)val;
                totalwritten += AddCounter(info);
            }
			EditStatusLabel2.ForeColor = Color.Black;
			EditStatusLabel2.Font.Bold = false;
            EditStatusLabel2.Text = String.Format("{0} record(s) saved, {1} actually created.", hash.Count, totalwritten);
            CountersToAddList.Items.Clear();
            hash.Clear();
        }


        private void AddCounterBtn_Click(object sender, System.EventArgs e)
        {
			if(CounterList.SelectedIndex == -1)
			{
				EditStatusLabel2.ForeColor = Color.Red;
				EditStatusLabel2.Font.Bold = true;
				EditStatusLabel2.Text = "Please select counters first!";
				return;
			}
			EditStatusLabel.Text = "";
			EditStatusLabel2.Text = "";

			// Iterate through selected counters
			foreach (ListItem counter in CounterList.Items)
			{
				if (!counter.Selected)
					continue;
 	
				// If items exist in InstanceList, loop through them
				if (InstanceList.Items.Count > 0)
				{
					// Iterate through instances
					foreach (ListItem instance in InstanceList.Items)
					{
						if (!instance.Selected)
							continue;
						StoreCounter(ListToArrayList(SelectedMachinesList), counter.Text, instance.Text);
					}
				}
				else
				{
					// No instances available
					StoreCounter(ListToArrayList(SelectedMachinesList), counter.Text, "");
				}
			}
        }

        private void RemoveCounterBtn_Click(object sender, System.EventArgs e)
        {
            Hashtable hash = (Hashtable)Session["CountersToAdd"];
            if (hash == null)
            {
                // hmm... this should never happen here unless the session got reset somehow in the middle
                Session.Add("CounterListHash", new Hashtable(500));
                hash = (Hashtable)Session["CountersToAdd"];
            }

            for (int i = CountersToAddList.Items.Count - 1; i >= 0; i--)
            {
                ListItem item = CountersToAddList.Items[i];
                if (item.Selected)
                {
                    hash.Remove(item.Text);
                    CountersToAddList.Items.Remove(item);
                }
            }
        }

        private void SaveBtn_Click(object sender, System.EventArgs e)
        {
            SaveStoredCounters();
        }

        private void SaveCloseBtn_Click(object sender, System.EventArgs e)
        {
            SaveStoredCounters();
            ShowEditPanel(false);
			RefreshExistingCountersList(false);
			
        }

        private void CancelBtn_Click(object sender, System.EventArgs e)
        {
            ShowEditPanel(false);
			RefreshExistingCountersList(false);
        }
        #endregion


        private void AddMachineBtn_Click(object sender, System.EventArgs e)
        {
            MoveItems(AllMachinesList, SelectedMachinesList);
            GetCategories(false);
        }

        private void RemoveMachineBtn_Click(object sender, System.EventArgs e)
        {
            MoveItems(SelectedMachinesList, AllMachinesList);   
            GetCategories(false);
        }

        private void PerfObjectList_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            ArrayList machines = ListToArrayList(SelectedMachinesList);
			string	exceptionMsg = "";
			GetInstances(CategoryList1.SelectedItem.Text,ComponentList1.SelectedItem.Text,machines, PerfObjectList.SelectedItem.Text, ref InstanceList, out exceptionMsg);
			EditStatusLabel.Text = exceptionMsg;
            GetCounters(machines, InstanceList, PerfObjectList.SelectedItem.Text, ref CounterList);
        }

        private void InstanceList_SelectedIndexChanged(object sender, System.EventArgs e)
        {
        
        }

        private void CounterTypeList_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            SetEditCounterType(CounterTypeList.SelectedIndex);
        }

//        private void RefreshCountersBtn_Click(object sender, System.EventArgs e)
//        {
//            /*foreach(ListItem item in SelectedMachinesList.Items)
//            {
//                // Make HealthXRL request here
//                //serverComm.MakeRequest(labelService.Text, item.Text);
//            }
//            // Output status here
//            //labelRefreshCounters.Text = serverComm.responseString;
//	    */
//        }

        
        private void CategoryList1_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            EditLabel3.Text = "(reload counters on selected machines)";
			EditLabel3.ForeColor = Color.Black;
			sqlConnection1.Open();
            RefreshComponentList();
            RefreshMachineList();
            //RefreshPerfObjectList();
            sqlConnection1.Close();
            RefreshExistingCountersList(false);
        }

        private void ComponentList1_SelectedIndexChanged(object sender, System.EventArgs e)
        {
			EditLabel3.Text = "(reload counters on selected machines)";
			EditLabel3.ForeColor = Color.Black;
            sqlConnection1.Open();
            RefreshMachineList();
            //RefreshPerfObjectList();
            sqlConnection1.Close();
            RefreshExistingCountersList(false);
        }
    
        private void MachineList1_SelectedIndexChanged(object sender, System.EventArgs e)
        {
			EditLabel3.Text = "(reload counters on selected machines)";
			EditLabel3.ForeColor = Color.Black;
            //RefreshPerfObjectList();
            RefreshExistingCountersList(false);
        }

        private void ExistingCountersList_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            // Update details
            ArrayList list = (ArrayList)Session["ExistingCounters"];
            if (list != null)
            {
                // Make sure selected index jives with the length of the ArrayList in Session var
                if (ExistingCountersList.SelectedIndex >= 0 && ExistingCountersList.SelectedIndex < list.Count)
                {
                    CounterInfoBase info = (CounterInfoBase)list[ExistingCountersList.SelectedIndex];
                    ShowDetails(info);
                }
            }
        }

        private void FilterResultsLnk_Click(object sender, System.EventArgs e)
        {
            // force show all counters returned
            GetExistingCounters(true);
        }

        private void AddNewBtn_Click(object sender, System.EventArgs e)
        {
            ShowEditPanel(true);
            ShowEditPanel_New();
        }

        private void DuplicateBtn_Click(object sender, System.EventArgs e)
        {
            ShowEditPanel(true);
            ShowEditPanel_Edit();
        }

        private void EditBtn_Click(object sender, System.EventArgs e)
        {
            ShowEditPanel(true);
            ShowEditPanel_Edit();
        }

        private void DeleteBtn_Click(object sender, System.EventArgs e)
        {
			// Update details
			ArrayList list = (ArrayList)Session["ExistingCounters"];
			if (list != null)
			{
				foreach (ListItem counter in ExistingCountersList.Items)
				{
					if (!counter.Selected)
						continue;
					else
					{
						p_DeleteCounterInfo(int.Parse(counter.Value), int.Parse(CategoryList1.SelectedValue), int.Parse(ComponentList1.SelectedValue));
					}
				}
			}
			sqlConnection1.Open();
			RefreshExistingCountersList(true);
			sqlConnection1.Close();
			ShowDetails(null);
			ShowEditPanel(false);
        }

		private void RefreshBtn_Click(object sender, System.EventArgs e)
		{
			sqlConnection1.Open();
			RefreshExistingCountersList(false);
			sqlConnection1.Close();
			ShowDetails(null);
			ShowEditPanel(false);
		}

		private void Refresh_Page ()
		{
			sqlConnection1.Open();
			RefreshCategoryList();
			RefreshComponentList();
			RefreshMachineList();
			//RefreshPerfObjectList();
			RefreshExistingCountersList(false);
			sqlConnection1.Close();
			ShowDetails(null);
			ShowEditPanel(false);
		}

		private void reloadCountersBtn_Click(object sender, System.EventArgs e)
		{
			//added counter reload code here
			string machine = MachineList1.SelectedItem.Text;
			string component = ComponentList1.SelectedItem.Text;
			ArrayList	machineList = new ArrayList();
			string		failedMachineList = "";
			if(machine.IndexOf(@"(All normal)") != -1)	// all machine is selected
			{
				// get all machines text name for the selected category
				sqlConnection1.Open();
				sqlcmdSelectMachinesBoth.Parameters["@compid"].Value = ComponentList1.SelectedValue;
				sqlcmdSelectMachinesBoth.Parameters["@catid"].Value = CategoryList1.SelectedValue;
				SqlDataReader dReader = sqlcmdSelectMachinesBoth.ExecuteReader();
				while(dReader.Read())
				{
					machineList.Add(dReader.GetString(1));
				}
				dReader.Close();
				dReader = null;
				sqlConnection1.Close();

				foreach(string m in machineList)
				{
					if(serverComm.MakeRequest(component, m) == false)
					{
						failedMachineList += m+" ";
					}
				}
				if(failedMachineList.Length != 0)
				{
					EditLabel3.ForeColor = Color.Red;
					EditLabel3.Text = "Counter reload failed for "+component+":" + failedMachineList +
						";manully send service requests to pick up counter changes";
				}

			}
			else		// single machine is selected
			{
				if(serverComm.MakeRequest(component, machine) == false)
				{
					EditLabel3.ForeColor = Color.Red;
					EditLabel3.Text = "Counter reload failed for "+component+":" + machine +
										";manully restart service to pick up counter changes";
				}
			}
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XeOfferLoader\XeOfferLoader_Database.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using xonline.common.sql.webstore;
using xonline.common.service;
using xonline.common.mgmt;
using Microsoft.Webstore.WstClient;

namespace Microsoft.XBox.Live.Test.OfferLoader
{

	public class Database
	{
		// Offer policies
		//
		public enum OfferPolicies
		{
			PerUserRights = 0x001,
			PerMachineRights = 0x002,
			OnlyPurchaseOnce = 0x100,
			RequiresVoucher = 0x200,
		}

		// Offering types
		//
		public enum OfferingTypes
		{
			Subscription = 0x001,
			Content = 0x002,
			Renewal = 0x004,
			PointsBundle = 0x008,
			GamertagChange = 0x010,
		}

		// Payment Types
		//
		public enum PaymentTypes
		{
			CreditCard = 0x001,
			TokenVoucher = 0x002,
			Points = 0x004,
		}


		public Database()
		{
		}


		~Database()
		{
		}


		/// <summary>
		/// Inserts a title into the uodb database
		/// </summary>
		public void InsertTitle(uint titleID)
		{
			using(WSClient ws = new WSClient("uodb", CmdType.WRITEONLY_COMMANDTYPE))
			{
				// Data is partitioned by user puid
				ws.PartitionType   = WstPartitionType.Logical;
				ws.Partition       = 0; // ANY_PARTITION

				ws.StoredProc = "dbo.p_svc_insert_titles";

				ws.AddParameter(ParamType.RETVAL, "@ret", 0);
				ws.AddParameter("@i_title_id", titleID);
				ws.AddParameter("@i_initial_version", (int) 0);

				ws.ExecuteNonQuery();

				uint hr = (uint)ws.GetIntParameter("@ret");
				if (hr != 0)
					throw new Exception("error calling " + ws.StoredProc + ": 0x" + hr.ToString("x"));
			}
		}

		
		/// <summary>
		/// Insert a rating for a title into the database
		/// </summary>
		public void InsertTitleRating(uint titleId, byte ratingSystemId, byte ratingId)
		{
			using(WSClient ws = new WSClient("uodb", CmdType.WRITEONLY_COMMANDTYPE))
			{
				// Data is partitioned by user puid
				ws.PartitionType   = WstPartitionType.Logical;
				ws.Partition       = 0; // ANY_PARTITION

				ws.StoredProc = "dbo.p_svc_insert_title_rank";

				ws.AddParameter(ParamType.RETVAL, "@ret", 0);
				ws.AddParameter("@i_title_id", titleId);
				ws.AddParameter("@i_rating_system_id", (int) ratingSystemId);
				ws.AddParameter("@i_rating_rank", (int) ratingId);

				ws.ExecuteNonQuery();

				uint hr = (uint)ws.GetIntParameter("@ret");
				if (hr != 0)
					throw new Exception("error calling " + ws.StoredProc + ": 0x" + hr.ToString("x"));
			}
		}

		
		/// <summary>
		/// Insert a rating for a title into the database
		/// </summary>
		public void InsertTitleCultureDetails(uint titleId, uint culture, string name, string shortDescription,
			string sellText, string publisher, string developer, string genre, byte [] image)
		{
			using(WSClient ws = new WSClient("UODB", CmdType.WRITEONLY_COMMANDTYPE))
			{
				// Data is partitioned by user puid
				ws.PartitionType   = WstPartitionType.Logical;
				ws.Partition       = 0; // ANY_PARTITION
    
				ws.StoredProc = "dbo.p_svc_insert_title_culture_details";
                
				ws.AddParameter(ParamType.RETVAL, "@ret", 0);
				ws.AddParameter("@i_title_id", titleId);
				ws.AddParameter("@i_culture_id", culture);
				ws.AddParameter("@vc_name", name);
				ws.AddParameter("@vc_short_description", shortDescription);
				ws.AddParameter("@vc_sell_text", sellText);
				ws.AddParameter("@vc_publisher", publisher);
				ws.AddParameter("@vc_developer", developer);
				ws.AddParameter("@vc_genre", genre);
				ws.AddParameter("@img_image", image);
                
				ws.ExecuteNonQuery();
                
				uint hr = (uint)ws.GetIntParameter("@ret");
				if (hr != 0)
					throw new Exception("error calling " + ws.StoredProc + ": 0x" + hr.ToString("x"));
			}
		}


		public void InsertOffer(uint titleID, ulong offerID, int packageSize, int installSize, int bitFilter,
			int offerType, string friendlyName)
		{
			byte [] symKey = new byte[16];
			byte [] publicKey = new byte[284];

			using(WSClient ws = new WSClient("uodb", CmdType.WRITEONLY_COMMANDTYPE))
			{
				// Data is partitioned by user puid
				ws.PartitionType   = WstPartitionType.Logical;
				ws.Partition       = 0; // ANY_PARTITION

				ws.StoredProc = "dbo.p_svc_insert_offers";

				ws.AddParameter(ParamType.RETVAL, "@ret", 0);
				ws.AddParameter("@i_title_id", titleID);
				ws.AddParameter("@bi_offer_id", offerID);
				ws.AddParameter("@i_ESRB_id", (int) 0); // legacy
				ws.AddParameter("@b_cancelable", 0); // not applicable to content offers
				ws.AddParameter("@i_package_size", packageSize);
				ws.AddParameter("@i_install_size", installSize);
				ws.AddParameter("@vb_sym_key", symKey);
				ws.AddParameter("@i_bitfilter", bitFilter);
				ws.AddParameter("@vc_billing_svc_component_id", "00000000-0000-0000-0000-000000000000");
				ws.AddParameter("@i_offer_type_id", offerType);
				ws.AddParameter("@i_offer_frequency_id", 0); // legacy
				ws.AddParameter("@dt_start_date", new DateTime(2001, 11, 15)); // legacy
				ws.AddParameter("@dt_end_date", new DateTime(3000, 12, 31)); // legacy
				ws.AddParameter("@vc_friendly_name", friendlyName);
				ws.AddParameter("@vb_public_key", publicKey);
				ws.AddParameter("@i_policy_flags", (uint)OfferPolicies.PerMachineRights);

				ws.ExecuteNonQuery();

				uint hr = (uint)ws.GetIntParameter("@ret");
				if (hr != 0)
					throw new Exception("error calling " + ws.StoredProc + ": 0x" + hr.ToString("x"));
			}
		}


		public void InsertOfferCultureDetails(ulong offerID, int culture, string name, string shortDescription,
			string sellText, byte [] image)
		{
			using(WSClient ws = new WSClient("uodb", CmdType.WRITEONLY_COMMANDTYPE))
			{
				// Data is partitioned by user puid
				ws.PartitionType   = WstPartitionType.Logical;
				ws.Partition       = 0; // ANY_PARTITION

				ws.StoredProc = "dbo.p_svc_insert_offer_culture_details";

				ws.AddParameter(ParamType.RETVAL, "@ret", 0);
				ws.AddParameter("@bi_offer_id", offerID);
				ws.AddParameter("@i_culture_id", culture);
				ws.AddParameter("@vc_name", name);
				ws.AddParameter("@vc_short_description", shortDescription);
				ws.AddParameter("@vc_sell_text", sellText);
				ws.AddParameter("@img_image", image);

				ws.ExecuteNonQuery();

				uint hr = (uint)ws.GetIntParameter("@ret");
				if (hr != 0)
					throw new Exception("error calling " + ws.StoredProc + ": 0x" + hr.ToString("x"));
			}
		}


		public void InsertOfferRegion(ulong offerID, byte countryID, int tierRequired, int paymentType, DateTime startDate,
			DateTime endDate, string boid, int priceWhole, int priceFractional, uint specificOfferDetails)
		{
			using(WSClient ws = new WSClient("uodb", CmdType.WRITEONLY_COMMANDTYPE))
			{
				// Data is partitioned by user puid
				ws.PartitionType   = WstPartitionType.Logical;
				ws.Partition       = 0; // ANY_PARTITION

				ws.StoredProc = "dbo.p_svc_insert_offer_regions_xenon";

				ws.AddParameter(ParamType.RETVAL, "@ret", 0);
				ws.AddParameter("@bi_offer_id", offerID);
				ws.AddParameter("@ti_country_id", countryID);
				ws.AddParameter("@i_tier_required", tierRequired);
				ws.AddParameter("@i_payment_type_id", paymentType);
				ws.AddParameter("@dt_start_date", startDate);
				ws.AddParameter("@dt_end_date", endDate);
				ws.AddParameter("@vc_billing_offer_id", boid);
				ws.AddParameter("@i_price_whole", priceWhole);
				ws.AddParameter("@i_price_fractional", priceFractional);
				ws.AddParameter("@si_specific_offer_details", specificOfferDetails);

				ws.ExecuteNonQuery();

				uint hr = (uint)ws.GetIntParameter("@ret");
				if (hr != 0)
					throw new Exception("error calling " + ws.StoredProc + ": 0x" + hr.ToString("x"));
			}
		}
		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XBLPerf\XBLPerfLogTool\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;
using System.Data;
using System.Data.SqlClient;

namespace XBLPerfLogTool 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// These hashTable will be used to convert numeric value to text value
		/// when showing counterDetails in the UI
		/// </summary>
		
		public Hashtable		categoryListHash = new Hashtable(), componentListHash = new Hashtable();

		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{
			string			ConnectionString = "user id=PerfLogTool;password=PerfLogTool;data source=localhost;" +
												"persist security info=False;initial catalog=PerfDB";
			SqlConnection	sqlConn = new SqlConnection(ConnectionString);

			SqlCommand		sqlcmdGetAllComponents = new SqlCommand("p_getAllComponent",sqlConn);
			SqlCommand		sqlcmdGetAllCategories = new SqlCommand("p_getAllCategory",sqlConn);

			sqlcmdGetAllComponents.CommandType = CommandType.StoredProcedure;
			sqlcmdGetAllCategories.CommandType = CommandType.StoredProcedure;

			sqlConn.Open();
			SqlDataReader dReader = sqlcmdGetAllComponents.ExecuteReader();
			const	int COMPID = 0, COMPNAME = 1;
			while(dReader.Read())
			{
				componentListHash.Add(dReader.GetInt32(COMPID),dReader.GetString(COMPNAME));
			}
			dReader.Close();
			dReader = null;

			dReader = sqlcmdGetAllCategories.ExecuteReader();
			const	int CATID = 0, CATNAME = 1;
			while(dReader.Read())
			{
				categoryListHash.Add(dReader.GetInt32(CATID),dReader.GetString(CATNAME));
			}
			dReader.Close();
			dReader = null;

			sqlConn.Close();

			Application.Add("CategoryListHash", categoryListHash);
			Application.Add("ComponentListHash", componentListHash);
		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.components = new System.ComponentModel.Container();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XeOfferLoader\XeOfferLoader_Config.cs ===
using System;

namespace Microsoft.XBox.Live.Test.OfferLoader
{
	/// <summary>
	/// Configuration information for the offer loader.
	/// </summary>
	public class Config
	{
		/// <summary>
		/// Stores the uodb server names.
		/// </summary>
		public static string[] UodbServers;

		/// <summary>
		/// Returns an array of connection strings. One element for each server name
		/// stored in UodbServers.
		/// </summary>
		public static string[] UodbConnectionString
		{
			get 
			{
				// TODO: We can cache this information so we don't
				//       have to do it each time.
				string[] conn = new string[UodbServers.Length];
				for (int i=0; i<UodbServers.Length; i++)
				{
					conn[i] = ConnectionString(UodbServers[i]);
				}
				return conn;
			}
		}

		/// <summary>
		/// Converts a servername into a uodb connection string for use with SqlClient.
		/// This assumes you want to use integrated security.
		/// </summary>
		/// <param name="server">The uodb server name for which to retrieve a connection string.</param>
		/// <returns>Returns a connection string for the server name provided.</returns>
		public static string ConnectionString(string server)
		{
			return "server=" + server + ";Initial Catalog=uodb;Integrated Security=SSPI;";
		}


		/// <summary>
		/// Set this variable to true if the entire process of adding offers/titles needs to be
		/// wrapped in a transaction.
		/// </summary>

		public enum XmlFileType
		{
			Title,
			Offer,
			Subscription
		}

		public static XmlFileType FileType = XmlFileType.Title;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XeOfferLoader\XeOfferLoader_Program.cs ===
using System;
using System.IO;


namespace Microsoft.XBox.Live.Test.OfferLoader
{
	/// <summary>
	/// Main application entry point.
	/// </summary>
	public class Program
	{
		private static XmlFiles m_files = null;

		public static int Main(string[] args)
		{
			int returnValue = 1;
			try
			{
				returnValue = RunApp(args);
			}
			catch (Exception e)
			{
				Console.WriteLine(e.ToString());
			}

			return returnValue;
		}

		public static int RunApp(string[] args)
		{
			if (args.Length == 0) 
			{
				Usage();
				return 1;
			}
			
			m_files = new XmlFiles();

			foreach (string parameter in args)
			{
				switch (parameter.ToLower())
				{
					case "/visual": System.Windows.Forms.Application.Run(new MainForm());
						return 0;
					case "/title": Config.FileType = Config.XmlFileType.Title;
						break;
					case "/offer": Config.FileType = Config.XmlFileType.Offer;
						break;
					case "/sub": Config.FileType = Config.XmlFileType.Subscription;
						throw new ApplicationException("The /sub file type is not yet implemented.");
					case "/?": 
						Usage();
						return 0;
					case "-?":
						Usage();
						return 0;
					default: GetFileList(parameter);
						break;
				}
			}


			// this config needs to be setup elsewhere
			Config.UodbServers = new string[1];
			Config.UodbServers[0] = "xesql1";

			foreach (XmlFile file in m_files)
			{
				Console.WriteLine(String.Format("Processing {0} ...", file.FileName));
				
				XmlImporter importer = new XmlImporter();

				if (Config.FileType == Config.XmlFileType.Title)
				{
					int numTitles = importer.ImportTitleFromXml(file.FileName);
					Console.WriteLine(numTitles.ToString() + " title(s) loaded.");
				} 
				else if (Config.FileType == Config.XmlFileType.Offer)
				{
					int numOffers = importer.ImportOfferFromXml(file.FileName);
					Console.WriteLine(numOffers.ToString() + " offer(s) loaded.");
				} 
				else
				{
					throw new ApplicationException("How did you get here?");
				}
				
			}


			return 0;
		}


		private static void Usage()
		{
			//WSClient ws = new WSClient("asddas");
			Console.WriteLine("usage: OfferLoader xmlfile(s) [/title | /offer | /sub]");
			Console.WriteLine("       /title : load the xml files as titles. (default)");
			Console.WriteLine("       /offer : load the xml files as offers.");
			Console.WriteLine("       /sub   : load the xml files as subscriptions. (not yet implemented)");
		}


		private static void GetFileList(string wildcard)
		{
			if (wildcard == null) return;

			if (IsWildCard(wildcard))
			{
				// get the list of files here
				if (wildcard.IndexOf('\\') <= -1) wildcard = ".\\" + wildcard;
				string directory = wildcard.Substring(0, wildcard.LastIndexOf('\\')+1);
				string searchPattern = wildcard.Substring(wildcard.LastIndexOf('\\')+1);

				string[] files = Directory.GetFiles(directory, searchPattern);
				foreach (string file in files) m_files.Add(Path.GetFullPath(file));
			}
			else
			{
				// single file
				if (!File.Exists(wildcard)) 
					throw new ApplicationException("The specified file '" + wildcard + "' does not exist.");

				m_files.Add(Path.GetFullPath(wildcard));
			}
		}

		private static bool IsWildCard(string wildcard)
		{
			if (wildcard == null) return false;
			
			return (wildcard.IndexOf('*') > -1 || wildcard.IndexOf('?') > -1);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XeOfferLoader\XeOfferLoader_XmlImporter.cs ===
using System;
using System.IO;
using System.Xml.Serialization;

namespace Microsoft.XBox.Live.Test.OfferLoader
{
	public class XmlImporter
	{
		public int ImportTitleFromXml(string filename)
		{
			XmlSerializer deserializer = new XmlSerializer(typeof(Titles));
			
			StreamReader sr = File.OpenText(filename);

			Titles titles = (Titles)deserializer.Deserialize(sr);
			
			return LoadTitles(Path.GetDirectoryName(Path.GetFullPath(filename)), titles);
		}


		public int ImportOfferFromXml(string filename)
		{
			XmlSerializer deserializer = new XmlSerializer(typeof(ContentOffers));
			
			StreamReader sr = File.OpenText(filename);

			ContentOffers offers = (ContentOffers)deserializer.Deserialize(sr);
			
			return LoadOffers(Path.GetDirectoryName(Path.GetFullPath(filename)), offers);
		}


		private int LoadTitles(string xmlFileLocation, Titles titles)
		{
			Database db = new Database();

			int numTitles = 0;

			try
			{
				for (int i=0; i<titles.Title.Length; i++)
				{
					TitlesTitle tt = titles.Title[i];
					System.Console.WriteLine(tt.titleID.ToString());

					// insert the title information
					db.InsertTitle(tt.titleID);

					for (int j=0; j<tt.cultureDetails.Length; j++)
					{
						TitlesTitleCultureDetails cd = tt.cultureDetails[j];
					
						// load the image data if it exists
						byte[] image = GetImageDataFromFile(xmlFileLocation, cd.imageFilePath);

						// insert the title culture information
						db.InsertTitleCultureDetails(tt.titleID, cd.culture,cd.name, cd.shortDescription, cd.sellText, cd.publisher, cd.developer, cd.genre, image);

						// insert the title rating
						foreach (uint rating in tt.rating)
						{
							db.InsertTitleRating(tt.titleID, (byte)(rating >> 8), (byte)(rating & 0x00ff));
						}
					}

					numTitles++;
				}

			}
			catch (Exception)
			{
				throw;
			}

			return numTitles;
		}


		private int LoadOffers(string xmlFileLocation, ContentOffers offers)
		{
			Database db = new Database();

			int numOffers = 0;

			try
			{
				for (int i=0; i<offers.ContentOffer.Length; i++)
				{
					ContentOffersContentOffer co = offers.ContentOffer[i];

					// insert the offer information
					db.InsertOffer(co.titleID, co.offerID, int.Parse(co.packageSize), int.Parse(co.installSize), (int)co.bitFilter, int.Parse(co.offerType), co.friendlyName);

					for (int j=0; j<co.cultureDetails.Length; j++)
					{
						ContentOffersContentOfferCultureDetails cd = co.cultureDetails[j];

						// load the image data if it exists
						byte[] image = GetImageDataFromFile(xmlFileLocation, cd.imageFilePath);

						// insert the culture details
						db.InsertOfferCultureDetails(co.offerID, (int)cd.culture, cd.name, cd.shortDescription, cd.sellText, image);
					}

					for (int j=0; j<co.region.Length; j++)
					{
						ContentOffersContentOfferRegion r = co.region[j];

						// insert the offer regions
						db.InsertOfferRegion(co.offerID, r.countryID, (int)r.tierRequired, (int)r.paymentType, r.startDate, r.endDate, r.boid, int.Parse(r.priceWhole), int.Parse(r.priceFractional), (byte)r.specificOfferDetails);
					}
				
					numOffers++;
				}

			} 
			catch (Exception)
			{
				throw;
			}

			return numOffers;
		}


		private byte[] GetImageDataFromFile(string xmlFileFolder, string filename)
		{
			byte[] image = null;
			if (filename != null && filename.Trim() != "")
			{
				string filepath = "";

				if (xmlFileFolder == null || xmlFileFolder == "") xmlFileFolder = ".\\";
				if (xmlFileFolder.Substring(xmlFileFolder.Length-1, 1) != "\\") xmlFileFolder += "\\";

				if (File.Exists(filename)) 
					filepath = filename;
				else if (File.Exists(Path.GetDirectoryName(xmlFileFolder) + "\\" + filename))
					filepath = xmlFileFolder + filename;
				else
					throw new ApplicationException("Could not find image file '" + filename + "'");
 
				FileStream fs = File.Open(filepath, FileMode.Open, FileAccess.Read);
				long filesize = (new FileInfo(filepath)).Length;
				image = new byte[filesize];
				fs.Read(image, 0, (int)filesize);
			}
			return image;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XeOfferLoader\XeOfferLoader_MainForm.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace Microsoft.XBox.Live.Test.OfferLoader
{
	/// <summary>
	/// Summary description for MainForm.
	/// </summary>
	public class MainForm : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Panel panel1;
		private System.Windows.Forms.Panel panel2;
		private System.Windows.Forms.Splitter splitter1;
		private System.Windows.Forms.TreeView treeviewMain;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		private Titles m_titles;
		private System.Windows.Forms.ContextMenu menuTreeView;
		private System.Windows.Forms.MenuItem menuAddTitle;
		private System.Windows.Forms.MenuItem menuAddOffer;
		private System.Windows.Forms.MenuItem menuItem3;
		private System.Windows.Forms.MenuItem menuRemove;
		private System.Windows.Forms.MenuItem menuItem1;
		private System.Windows.Forms.MenuItem menuReload;
		private System.Windows.Forms.Panel panelTitle;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.Panel panelOffer;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.TextBox textboxTitleTitleId;
		private System.Windows.Forms.Label label6;
		private System.Windows.Forms.Label label7;
		private System.Windows.Forms.Label label8;
		private System.Windows.Forms.Label label9;
		private System.Windows.Forms.TextBox textBox5;
		private System.Windows.Forms.Label label10;
		private System.Windows.Forms.Label label11;
		private System.Windows.Forms.TextBox textBox7;
		private System.Windows.Forms.Label label12;
		private System.Windows.Forms.ListView listviewTitleRatings;
		private System.Windows.Forms.ListView listviewTitleCultures;
		private System.Windows.Forms.Label labelTitleCulture;
		private System.Windows.Forms.Label labelTitleRatings;
		private System.Windows.Forms.Button buttonTitleSaveChanges;
		private System.Windows.Forms.Button buttonTitleRatingEdit;
		private System.Windows.Forms.Button buttonTitleRatingAdd;
		private System.Windows.Forms.Button buttonTitleRatingRemove;
		private System.Windows.Forms.Button buttonTitleCultureAdd;
		private System.Windows.Forms.Button buttonTitleCultureRemove;
		private System.Windows.Forms.Button buttonTitleCultureEdit;
		private System.Windows.Forms.TextBox textboxOfferInstallSize;
		private System.Windows.Forms.TextBox textboxOfferPackageSize;
		private System.Windows.Forms.TextBox textboxOfferOfferId;
		private System.Windows.Forms.TextBox textboxOfferTitleId;
		private System.Windows.Forms.ComboBox comboboxOfferType;
		private System.Windows.Forms.Button buttonOfferCultureEdit;
		private System.Windows.Forms.Button buttonOfferCultureAdd;
		private System.Windows.Forms.ListView listviewOfferCulture;
		private System.Windows.Forms.Label labelOfferCulture;
		private System.Windows.Forms.Button buttonOfferCultureRemove;
		private System.Windows.Forms.Button buttonOfferSaveChanges;
		private System.Windows.Forms.Label labelOfferRegion;
		private System.Windows.Forms.Button buttonOfferRegionEdit;
		private System.Windows.Forms.Button buttonOfferRegionAdd;
		private System.Windows.Forms.ListView listviewOfferRegions;
		private System.Windows.Forms.Button buttonOfferRegionRemove;
		private System.Windows.Forms.ColumnHeader columnheaderOfferCultureCultureId;
		private System.Windows.Forms.ColumnHeader columnheaderOfferCultureName;
		private System.Windows.Forms.ColumnHeader columnheaderOfferCultureShortDescription;
		private System.Windows.Forms.ColumnHeader columnheaderOfferCultureSellText;
		private System.Windows.Forms.ColumnHeader columnheaderOfferCultureImageFilePath;
		private System.Windows.Forms.ColumnHeader columnheaderOfferRegionCountryId;
		private System.Windows.Forms.ColumnHeader columnheaderOfferRegionTier;
		private System.Windows.Forms.ColumnHeader columnheaderOfferRegionPaymentType;
		private System.Windows.Forms.ColumnHeader columnheaderOfferRegionStartDate;
		private System.Windows.Forms.ColumnHeader columnheaderOfferRegionEndDate;
		private System.Windows.Forms.ColumnHeader columnheaderOfferRegionBoid;
		private System.Windows.Forms.ColumnHeader columnheaderOfferRegionPriceWhole;
		private System.Windows.Forms.ColumnHeader columnheaderOfferRegionPriceFractional;
		private System.Windows.Forms.ColumnHeader columnheaderOfferRegionDetails;
		private System.Windows.Forms.ColumnHeader columnheaderTitleRatingsRatingValue;
		private System.Windows.Forms.ColumnHeader columnheaderTitleRatingsRatingSystem;
		private System.Windows.Forms.ColumnHeader columnheaderTitleRatingsRating;
		private System.Windows.Forms.ColumnHeader columnheaderTitleCultureCultureId;
		private System.Windows.Forms.ColumnHeader columnheaderTitleCultureName;
		private System.Windows.Forms.ColumnHeader columnheaderTitleCultureShortDescription;
		private System.Windows.Forms.ColumnHeader columnheaderTitleCultureSellText;
		private System.Windows.Forms.ColumnHeader columnheaderTitleCulturePublisher;
		private System.Windows.Forms.ColumnHeader columnheaderTitleCultureDeveloper;
		private System.Windows.Forms.ColumnHeader columnheaderTitleCultureGenre;
		private System.Windows.Forms.ColumnHeader columnheaderTitleCultureImageFilePath;
		private ContentOffers m_offers;

		
		private enum NodeTypes
		{
			InvalidNodeType,
			OfferRoot,
			OfferNode,
			TitleRoot,
			TitleNode,
		}

		public MainForm()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.panel1 = new System.Windows.Forms.Panel();
			this.treeviewMain = new System.Windows.Forms.TreeView();
			this.panel2 = new System.Windows.Forms.Panel();
			this.panelOffer = new System.Windows.Forms.Panel();
			this.textBox7 = new System.Windows.Forms.TextBox();
			this.label12 = new System.Windows.Forms.Label();
			this.label11 = new System.Windows.Forms.Label();
			this.textBox5 = new System.Windows.Forms.TextBox();
			this.label10 = new System.Windows.Forms.Label();
			this.textboxOfferInstallSize = new System.Windows.Forms.TextBox();
			this.label9 = new System.Windows.Forms.Label();
			this.textboxOfferPackageSize = new System.Windows.Forms.TextBox();
			this.label8 = new System.Windows.Forms.Label();
			this.textboxOfferOfferId = new System.Windows.Forms.TextBox();
			this.label7 = new System.Windows.Forms.Label();
			this.textboxOfferTitleId = new System.Windows.Forms.TextBox();
			this.label6 = new System.Windows.Forms.Label();
			this.label2 = new System.Windows.Forms.Label();
			this.panelTitle = new System.Windows.Forms.Panel();
			this.buttonTitleSaveChanges = new System.Windows.Forms.Button();
			this.buttonTitleRatingEdit = new System.Windows.Forms.Button();
			this.buttonTitleRatingAdd = new System.Windows.Forms.Button();
			this.buttonTitleRatingRemove = new System.Windows.Forms.Button();
			this.buttonTitleCultureEdit = new System.Windows.Forms.Button();
			this.buttonTitleCultureAdd = new System.Windows.Forms.Button();
			this.listviewTitleRatings = new System.Windows.Forms.ListView();
			this.labelTitleRatings = new System.Windows.Forms.Label();
			this.listviewTitleCultures = new System.Windows.Forms.ListView();
			this.labelTitleCulture = new System.Windows.Forms.Label();
			this.textboxTitleTitleId = new System.Windows.Forms.TextBox();
			this.label3 = new System.Windows.Forms.Label();
			this.label1 = new System.Windows.Forms.Label();
			this.buttonTitleCultureRemove = new System.Windows.Forms.Button();
			this.splitter1 = new System.Windows.Forms.Splitter();
			this.menuTreeView = new System.Windows.Forms.ContextMenu();
			this.menuAddTitle = new System.Windows.Forms.MenuItem();
			this.menuAddOffer = new System.Windows.Forms.MenuItem();
			this.menuItem3 = new System.Windows.Forms.MenuItem();
			this.menuRemove = new System.Windows.Forms.MenuItem();
			this.menuItem1 = new System.Windows.Forms.MenuItem();
			this.menuReload = new System.Windows.Forms.MenuItem();
			this.comboboxOfferType = new System.Windows.Forms.ComboBox();
			this.buttonOfferCultureEdit = new System.Windows.Forms.Button();
			this.buttonOfferCultureAdd = new System.Windows.Forms.Button();
			this.listviewOfferCulture = new System.Windows.Forms.ListView();
			this.labelOfferCulture = new System.Windows.Forms.Label();
			this.buttonOfferCultureRemove = new System.Windows.Forms.Button();
			this.buttonOfferSaveChanges = new System.Windows.Forms.Button();
			this.buttonOfferRegionEdit = new System.Windows.Forms.Button();
			this.buttonOfferRegionAdd = new System.Windows.Forms.Button();
			this.listviewOfferRegions = new System.Windows.Forms.ListView();
			this.labelOfferRegion = new System.Windows.Forms.Label();
			this.buttonOfferRegionRemove = new System.Windows.Forms.Button();
			this.columnheaderOfferCultureCultureId = new System.Windows.Forms.ColumnHeader();
			this.columnheaderOfferCultureName = new System.Windows.Forms.ColumnHeader();
			this.columnheaderOfferCultureShortDescription = new System.Windows.Forms.ColumnHeader();
			this.columnheaderOfferCultureSellText = new System.Windows.Forms.ColumnHeader();
			this.columnheaderOfferCultureImageFilePath = new System.Windows.Forms.ColumnHeader();
			this.columnheaderOfferRegionCountryId = new System.Windows.Forms.ColumnHeader();
			this.columnheaderOfferRegionTier = new System.Windows.Forms.ColumnHeader();
			this.columnheaderOfferRegionPaymentType = new System.Windows.Forms.ColumnHeader();
			this.columnheaderOfferRegionStartDate = new System.Windows.Forms.ColumnHeader();
			this.columnheaderOfferRegionEndDate = new System.Windows.Forms.ColumnHeader();
			this.columnheaderOfferRegionBoid = new System.Windows.Forms.ColumnHeader();
			this.columnheaderOfferRegionPriceWhole = new System.Windows.Forms.ColumnHeader();
			this.columnheaderOfferRegionPriceFractional = new System.Windows.Forms.ColumnHeader();
			this.columnheaderOfferRegionDetails = new System.Windows.Forms.ColumnHeader();
			this.columnheaderTitleRatingsRatingValue = new System.Windows.Forms.ColumnHeader();
			this.columnheaderTitleRatingsRatingSystem = new System.Windows.Forms.ColumnHeader();
			this.columnheaderTitleRatingsRating = new System.Windows.Forms.ColumnHeader();
			this.columnheaderTitleCultureCultureId = new System.Windows.Forms.ColumnHeader();
			this.columnheaderTitleCultureName = new System.Windows.Forms.ColumnHeader();
			this.columnheaderTitleCultureShortDescription = new System.Windows.Forms.ColumnHeader();
			this.columnheaderTitleCultureSellText = new System.Windows.Forms.ColumnHeader();
			this.columnheaderTitleCulturePublisher = new System.Windows.Forms.ColumnHeader();
			this.columnheaderTitleCultureDeveloper = new System.Windows.Forms.ColumnHeader();
			this.columnheaderTitleCultureGenre = new System.Windows.Forms.ColumnHeader();
			this.columnheaderTitleCultureImageFilePath = new System.Windows.Forms.ColumnHeader();
			this.panel1.SuspendLayout();
			this.panel2.SuspendLayout();
			this.panelOffer.SuspendLayout();
			this.panelTitle.SuspendLayout();
			this.SuspendLayout();
			// 
			// panel1
			// 
			this.panel1.Controls.Add(this.treeviewMain);
			this.panel1.Dock = System.Windows.Forms.DockStyle.Left;
			this.panel1.Location = new System.Drawing.Point(0, 0);
			this.panel1.Name = "panel1";
			this.panel1.Size = new System.Drawing.Size(235, 641);
			this.panel1.TabIndex = 0;
			// 
			// treeviewMain
			// 
			this.treeviewMain.Dock = System.Windows.Forms.DockStyle.Fill;
			this.treeviewMain.ImageIndex = -1;
			this.treeviewMain.Location = new System.Drawing.Point(0, 0);
			this.treeviewMain.Name = "treeviewMain";
			this.treeviewMain.SelectedImageIndex = -1;
			this.treeviewMain.Size = new System.Drawing.Size(235, 641);
			this.treeviewMain.TabIndex = 0;
			this.treeviewMain.MouseDown += new System.Windows.Forms.MouseEventHandler(this.treeviewMain_MouseDown);
			this.treeviewMain.AfterSelect += new System.Windows.Forms.TreeViewEventHandler(this.treeviewMain_AfterSelect);
			this.treeviewMain.BeforeExpand += new System.Windows.Forms.TreeViewCancelEventHandler(this.treeviewMain_BeforeExpand);
			// 
			// panel2
			// 
			this.panel2.Controls.Add(this.panelOffer);
			this.panel2.Controls.Add(this.panelTitle);
			this.panel2.Dock = System.Windows.Forms.DockStyle.Fill;
			this.panel2.Location = new System.Drawing.Point(235, 0);
			this.panel2.Name = "panel2";
			this.panel2.Size = new System.Drawing.Size(480, 641);
			this.panel2.TabIndex = 1;
			// 
			// panelOffer
			// 
			this.panelOffer.Controls.Add(this.buttonOfferRegionEdit);
			this.panelOffer.Controls.Add(this.buttonOfferRegionAdd);
			this.panelOffer.Controls.Add(this.listviewOfferRegions);
			this.panelOffer.Controls.Add(this.labelOfferRegion);
			this.panelOffer.Controls.Add(this.buttonOfferRegionRemove);
			this.panelOffer.Controls.Add(this.buttonOfferSaveChanges);
			this.panelOffer.Controls.Add(this.buttonOfferCultureEdit);
			this.panelOffer.Controls.Add(this.buttonOfferCultureAdd);
			this.panelOffer.Controls.Add(this.listviewOfferCulture);
			this.panelOffer.Controls.Add(this.labelOfferCulture);
			this.panelOffer.Controls.Add(this.buttonOfferCultureRemove);
			this.panelOffer.Controls.Add(this.comboboxOfferType);
			this.panelOffer.Controls.Add(this.textBox7);
			this.panelOffer.Controls.Add(this.label12);
			this.panelOffer.Controls.Add(this.label11);
			this.panelOffer.Controls.Add(this.textBox5);
			this.panelOffer.Controls.Add(this.label10);
			this.panelOffer.Controls.Add(this.textboxOfferInstallSize);
			this.panelOffer.Controls.Add(this.label9);
			this.panelOffer.Controls.Add(this.textboxOfferPackageSize);
			this.panelOffer.Controls.Add(this.label8);
			this.panelOffer.Controls.Add(this.textboxOfferOfferId);
			this.panelOffer.Controls.Add(this.label7);
			this.panelOffer.Controls.Add(this.textboxOfferTitleId);
			this.panelOffer.Controls.Add(this.label6);
			this.panelOffer.Controls.Add(this.label2);
			this.panelOffer.Location = new System.Drawing.Point(21, 524);
			this.panelOffer.Name = "panelOffer";
			this.panelOffer.Size = new System.Drawing.Size(445, 103);
			this.panelOffer.TabIndex = 4;
			this.panelOffer.Resize += new System.EventHandler(this.panelOffer_Resize);
			// 
			// textBox7
			// 
			this.textBox7.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.textBox7.Location = new System.Drawing.Point(102, 195);
			this.textBox7.Name = "textBox7";
			this.textBox7.Size = new System.Drawing.Size(220, 21);
			this.textBox7.TabIndex = 16;
			this.textBox7.Text = "";
			// 
			// label12
			// 
			this.label12.AutoSize = true;
			this.label12.Location = new System.Drawing.Point(12, 198);
			this.label12.Name = "label12";
			this.label12.Size = new System.Drawing.Size(80, 17);
			this.label12.TabIndex = 15;
			this.label12.Text = "Friendly Name:";
			// 
			// label11
			// 
			this.label11.AutoSize = true;
			this.label11.Location = new System.Drawing.Point(12, 170);
			this.label11.Name = "label11";
			this.label11.Size = new System.Drawing.Size(61, 17);
			this.label11.TabIndex = 13;
			this.label11.Text = "Offer Type:";
			// 
			// textBox5
			// 
			this.textBox5.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.textBox5.Location = new System.Drawing.Point(102, 139);
			this.textBox5.Name = "textBox5";
			this.textBox5.Size = new System.Drawing.Size(114, 21);
			this.textBox5.TabIndex = 12;
			this.textBox5.Text = "";
			// 
			// label10
			// 
			this.label10.AutoSize = true;
			this.label10.Location = new System.Drawing.Point(12, 142);
			this.label10.Name = "label10";
			this.label10.Size = new System.Drawing.Size(46, 17);
			this.label10.TabIndex = 11;
			this.label10.Text = "BitFilter:";
			// 
			// textboxOfferInstallSize
			// 
			this.textboxOfferInstallSize.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.textboxOfferInstallSize.Location = new System.Drawing.Point(102, 111);
			this.textboxOfferInstallSize.Name = "textboxOfferInstallSize";
			this.textboxOfferInstallSize.Size = new System.Drawing.Size(114, 21);
			this.textboxOfferInstallSize.TabIndex = 10;
			this.textboxOfferInstallSize.Text = "";
			// 
			// label9
			// 
			this.label9.AutoSize = true;
			this.label9.Location = new System.Drawing.Point(12, 114);
			this.label9.Name = "label9";
			this.label9.Size = new System.Drawing.Size(62, 17);
			this.label9.TabIndex = 9;
			this.label9.Text = "Install Size:";
			// 
			// textboxOfferPackageSize
			// 
			this.textboxOfferPackageSize.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.textboxOfferPackageSize.Location = new System.Drawing.Point(102, 83);
			this.textboxOfferPackageSize.Name = "textboxOfferPackageSize";
			this.textboxOfferPackageSize.Size = new System.Drawing.Size(114, 21);
			this.textboxOfferPackageSize.TabIndex = 8;
			this.textboxOfferPackageSize.Text = "";
			// 
			// label8
			// 
			this.label8.AutoSize = true;
			this.label8.Location = new System.Drawing.Point(12, 86);
			this.label8.Name = "label8";
			this.label8.Size = new System.Drawing.Size(73, 17);
			this.label8.TabIndex = 7;
			this.label8.Text = "Package Size:";
			// 
			// textboxOfferOfferId
			// 
			this.textboxOfferOfferId.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.textboxOfferOfferId.Location = new System.Drawing.Point(102, 55);
			this.textboxOfferOfferId.Name = "textboxOfferOfferId";
			this.textboxOfferOfferId.Size = new System.Drawing.Size(114, 21);
			this.textboxOfferOfferId.TabIndex = 6;
			this.textboxOfferOfferId.Text = "";
			// 
			// label7
			// 
			this.label7.AutoSize = true;
			this.label7.Location = new System.Drawing.Point(12, 58);
			this.label7.Name = "label7";
			this.label7.Size = new System.Drawing.Size(49, 17);
			this.label7.TabIndex = 5;
			this.label7.Text = "Offer ID:";
			// 
			// textboxOfferTitleId
			// 
			this.textboxOfferTitleId.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.textboxOfferTitleId.Location = new System.Drawing.Point(102, 27);
			this.textboxOfferTitleId.Name = "textboxOfferTitleId";
			this.textboxOfferTitleId.Size = new System.Drawing.Size(114, 21);
			this.textboxOfferTitleId.TabIndex = 4;
			this.textboxOfferTitleId.Text = "";
			// 
			// label6
			// 
			this.label6.AutoSize = true;
			this.label6.Location = new System.Drawing.Point(12, 30);
			this.label6.Name = "label6";
			this.label6.Size = new System.Drawing.Size(45, 17);
			this.label6.TabIndex = 3;
			this.label6.Text = "Title ID:";
			// 
			// label2
			// 
			this.label2.BackColor = System.Drawing.SystemColors.ControlDark;
			this.label2.Dock = System.Windows.Forms.DockStyle.Top;
			this.label2.Font = new System.Drawing.Font("Tahoma", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label2.ForeColor = System.Drawing.SystemColors.HighlightText;
			this.label2.Location = new System.Drawing.Point(0, 0);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(445, 17);
			this.label2.TabIndex = 0;
			this.label2.Text = "Offer";
			this.label2.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
			// 
			// panelTitle
			// 
			this.panelTitle.Controls.Add(this.buttonTitleSaveChanges);
			this.panelTitle.Controls.Add(this.buttonTitleRatingEdit);
			this.panelTitle.Controls.Add(this.buttonTitleRatingAdd);
			this.panelTitle.Controls.Add(this.buttonTitleRatingRemove);
			this.panelTitle.Controls.Add(this.buttonTitleCultureEdit);
			this.panelTitle.Controls.Add(this.buttonTitleCultureAdd);
			this.panelTitle.Controls.Add(this.listviewTitleRatings);
			this.panelTitle.Controls.Add(this.labelTitleRatings);
			this.panelTitle.Controls.Add(this.listviewTitleCultures);
			this.panelTitle.Controls.Add(this.labelTitleCulture);
			this.panelTitle.Controls.Add(this.textboxTitleTitleId);
			this.panelTitle.Controls.Add(this.label3);
			this.panelTitle.Controls.Add(this.label1);
			this.panelTitle.Controls.Add(this.buttonTitleCultureRemove);
			this.panelTitle.Location = new System.Drawing.Point(18, 16);
			this.panelTitle.Name = "panelTitle";
			this.panelTitle.Size = new System.Drawing.Size(445, 436);
			this.panelTitle.TabIndex = 1;
			this.panelTitle.Resize += new System.EventHandler(this.panelTitle_Resize);
			// 
			// buttonTitleSaveChanges
			// 
			this.buttonTitleSaveChanges.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
			this.buttonTitleSaveChanges.Location = new System.Drawing.Point(332, 407);
			this.buttonTitleSaveChanges.Name = "buttonTitleSaveChanges";
			this.buttonTitleSaveChanges.Size = new System.Drawing.Size(105, 23);
			this.buttonTitleSaveChanges.TabIndex = 12;
			this.buttonTitleSaveChanges.Text = "Save Changes";
			// 
			// buttonTitleRatingEdit
			// 
			this.buttonTitleRatingEdit.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.buttonTitleRatingEdit.Location = new System.Drawing.Point(367, 241);
			this.buttonTitleRatingEdit.Name = "buttonTitleRatingEdit";
			this.buttonTitleRatingEdit.Size = new System.Drawing.Size(70, 22);
			this.buttonTitleRatingEdit.TabIndex = 11;
			this.buttonTitleRatingEdit.Text = "Edit...";
			// 
			// buttonTitleRatingAdd
			// 
			this.buttonTitleRatingAdd.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.buttonTitleRatingAdd.Location = new System.Drawing.Point(367, 208);
			this.buttonTitleRatingAdd.Name = "buttonTitleRatingAdd";
			this.buttonTitleRatingAdd.Size = new System.Drawing.Size(70, 22);
			this.buttonTitleRatingAdd.TabIndex = 9;
			this.buttonTitleRatingAdd.Text = "Add...";
			// 
			// buttonTitleRatingRemove
			// 
			this.buttonTitleRatingRemove.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.buttonTitleRatingRemove.Location = new System.Drawing.Point(367, 274);
			this.buttonTitleRatingRemove.Name = "buttonTitleRatingRemove";
			this.buttonTitleRatingRemove.Size = new System.Drawing.Size(70, 22);
			this.buttonTitleRatingRemove.TabIndex = 10;
			this.buttonTitleRatingRemove.Text = "Remove";
			// 
			// buttonTitleCultureEdit
			// 
			this.buttonTitleCultureEdit.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.buttonTitleCultureEdit.Location = new System.Drawing.Point(367, 112);
			this.buttonTitleCultureEdit.Name = "buttonTitleCultureEdit";
			this.buttonTitleCultureEdit.Size = new System.Drawing.Size(70, 22);
			this.buttonTitleCultureEdit.TabIndex = 8;
			this.buttonTitleCultureEdit.Text = "Edit...";
			// 
			// buttonTitleCultureAdd
			// 
			this.buttonTitleCultureAdd.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.buttonTitleCultureAdd.Location = new System.Drawing.Point(367, 79);
			this.buttonTitleCultureAdd.Name = "buttonTitleCultureAdd";
			this.buttonTitleCultureAdd.Size = new System.Drawing.Size(70, 22);
			this.buttonTitleCultureAdd.TabIndex = 7;
			this.buttonTitleCultureAdd.Text = "Add...";
			// 
			// listviewTitleRatings
			// 
			this.listviewTitleRatings.Anchor = System.Windows.Forms.AnchorStyles.Left;
			this.listviewTitleRatings.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.listviewTitleRatings.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
																								   this.columnheaderTitleRatingsRatingValue,
																								   this.columnheaderTitleRatingsRatingSystem,
																								   this.columnheaderTitleRatingsRating});
			this.listviewTitleRatings.FullRowSelect = true;
			this.listviewTitleRatings.GridLines = true;
			this.listviewTitleRatings.Location = new System.Drawing.Point(12, 289);
			this.listviewTitleRatings.Name = "listviewTitleRatings";
			this.listviewTitleRatings.Size = new System.Drawing.Size(341, 91);
			this.listviewTitleRatings.TabIndex = 6;
			this.listviewTitleRatings.View = System.Windows.Forms.View.Details;
			// 
			// labelTitleRatings
			// 
			this.labelTitleRatings.AutoSize = true;
			this.labelTitleRatings.Location = new System.Drawing.Point(11, 188);
			this.labelTitleRatings.Name = "labelTitleRatings";
			this.labelTitleRatings.Size = new System.Drawing.Size(45, 17);
			this.labelTitleRatings.TabIndex = 5;
			this.labelTitleRatings.Text = "Ratings:";
			// 
			// listviewTitleCultures
			// 
			this.listviewTitleCultures.Anchor = System.Windows.Forms.AnchorStyles.Left;
			this.listviewTitleCultures.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.listviewTitleCultures.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
																									this.columnheaderTitleCultureCultureId,
																									this.columnheaderTitleCultureName,
																									this.columnheaderTitleCultureShortDescription,
																									this.columnheaderTitleCultureSellText,
																									this.columnheaderTitleCulturePublisher,
																									this.columnheaderTitleCultureDeveloper,
																									this.columnheaderTitleCultureGenre,
																									this.columnheaderTitleCultureImageFilePath});
			this.listviewTitleCultures.FullRowSelect = true;
			this.listviewTitleCultures.GridLines = true;
			this.listviewTitleCultures.Location = new System.Drawing.Point(12, 159);
			this.listviewTitleCultures.Name = "listviewTitleCultures";
			this.listviewTitleCultures.Size = new System.Drawing.Size(344, 91);
			this.listviewTitleCultures.TabIndex = 4;
			this.listviewTitleCultures.View = System.Windows.Forms.View.Details;
			// 
			// labelTitleCulture
			// 
			this.labelTitleCulture.AutoSize = true;
			this.labelTitleCulture.Location = new System.Drawing.Point(11, 58);
			this.labelTitleCulture.Name = "labelTitleCulture";
			this.labelTitleCulture.Size = new System.Drawing.Size(81, 17);
			this.labelTitleCulture.TabIndex = 3;
			this.labelTitleCulture.Text = "Culture Details:";
			// 
			// textboxTitleTitleId
			// 
			this.textboxTitleTitleId.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.textboxTitleTitleId.Location = new System.Drawing.Point(63, 23);
			this.textboxTitleTitleId.Name = "textboxTitleTitleId";
			this.textboxTitleTitleId.Size = new System.Drawing.Size(114, 21);
			this.textboxTitleTitleId.TabIndex = 2;
			this.textboxTitleTitleId.Text = "";
			// 
			// label3
			// 
			this.label3.AutoSize = true;
			this.label3.Location = new System.Drawing.Point(11, 26);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(45, 17);
			this.label3.TabIndex = 1;
			this.label3.Text = "Title ID:";
			// 
			// label1
			// 
			this.label1.BackColor = System.Drawing.SystemColors.ControlDark;
			this.label1.Dock = System.Windows.Forms.DockStyle.Top;
			this.label1.Font = new System.Drawing.Font("Tahoma", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label1.ForeColor = System.Drawing.SystemColors.HighlightText;
			this.label1.Location = new System.Drawing.Point(0, 0);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(445, 17);
			this.label1.TabIndex = 0;
			this.label1.Text = "Title";
			this.label1.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
			// 
			// buttonTitleCultureRemove
			// 
			this.buttonTitleCultureRemove.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.buttonTitleCultureRemove.Location = new System.Drawing.Point(367, 145);
			this.buttonTitleCultureRemove.Name = "buttonTitleCultureRemove";
			this.buttonTitleCultureRemove.Size = new System.Drawing.Size(70, 22);
			this.buttonTitleCultureRemove.TabIndex = 8;
			this.buttonTitleCultureRemove.Text = "Remove";
			// 
			// splitter1
			// 
			this.splitter1.BackColor = System.Drawing.SystemColors.ControlDark;
			this.splitter1.Location = new System.Drawing.Point(235, 0);
			this.splitter1.Name = "splitter1";
			this.splitter1.Size = new System.Drawing.Size(5, 641);
			this.splitter1.TabIndex = 2;
			this.splitter1.TabStop = false;
			// 
			// menuTreeView
			// 
			this.menuTreeView.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																						 this.menuAddTitle,
																						 this.menuAddOffer,
																						 this.menuItem3,
																						 this.menuRemove,
																						 this.menuItem1,
																						 this.menuReload});
			// 
			// menuAddTitle
			// 
			this.menuAddTitle.Index = 0;
			this.menuAddTitle.Text = "Add Title";
			// 
			// menuAddOffer
			// 
			this.menuAddOffer.Index = 1;
			this.menuAddOffer.Text = "Add Offer";
			// 
			// menuItem3
			// 
			this.menuItem3.Index = 2;
			this.menuItem3.Text = "-";
			// 
			// menuRemove
			// 
			this.menuRemove.Index = 3;
			this.menuRemove.Text = "Remove";
			// 
			// menuItem1
			// 
			this.menuItem1.Index = 4;
			this.menuItem1.Text = "-";
			// 
			// menuReload
			// 
			this.menuReload.Index = 5;
			this.menuReload.Text = "Reload from UODB";
			// 
			// comboboxOfferType
			// 
			this.comboboxOfferType.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
			this.comboboxOfferType.Location = new System.Drawing.Point(102, 167);
			this.comboboxOfferType.Name = "comboboxOfferType";
			this.comboboxOfferType.Size = new System.Drawing.Size(132, 21);
			this.comboboxOfferType.TabIndex = 17;
			// 
			// buttonOfferCultureEdit
			// 
			this.buttonOfferCultureEdit.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.buttonOfferCultureEdit.Location = new System.Drawing.Point(369, 288);
			this.buttonOfferCultureEdit.Name = "buttonOfferCultureEdit";
			this.buttonOfferCultureEdit.Size = new System.Drawing.Size(70, 22);
			this.buttonOfferCultureEdit.TabIndex = 22;
			this.buttonOfferCultureEdit.Text = "Edit...";
			// 
			// buttonOfferCultureAdd
			// 
			this.buttonOfferCultureAdd.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.buttonOfferCultureAdd.Location = new System.Drawing.Point(369, 255);
			this.buttonOfferCultureAdd.Name = "buttonOfferCultureAdd";
			this.buttonOfferCultureAdd.Size = new System.Drawing.Size(70, 22);
			this.buttonOfferCultureAdd.TabIndex = 20;
			this.buttonOfferCultureAdd.Text = "Add...";
			// 
			// listviewOfferCulture
			// 
			this.listviewOfferCulture.Anchor = System.Windows.Forms.AnchorStyles.Left;
			this.listviewOfferCulture.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.listviewOfferCulture.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
																								   this.columnheaderOfferCultureCultureId,
																								   this.columnheaderOfferCultureName,
																								   this.columnheaderOfferCultureShortDescription,
																								   this.columnheaderOfferCultureSellText,
																								   this.columnheaderOfferCultureImageFilePath});
			this.listviewOfferCulture.FullRowSelect = true;
			this.listviewOfferCulture.GridLines = true;
			this.listviewOfferCulture.Location = new System.Drawing.Point(9, 27);
			this.listviewOfferCulture.Name = "listviewOfferCulture";
			this.listviewOfferCulture.Size = new System.Drawing.Size(344, 91);
			this.listviewOfferCulture.TabIndex = 19;
			this.listviewOfferCulture.View = System.Windows.Forms.View.Details;
			// 
			// labelOfferCulture
			// 
			this.labelOfferCulture.AutoSize = true;
			this.labelOfferCulture.Location = new System.Drawing.Point(13, 225);
			this.labelOfferCulture.Name = "labelOfferCulture";
			this.labelOfferCulture.Size = new System.Drawing.Size(81, 17);
			this.labelOfferCulture.TabIndex = 18;
			this.labelOfferCulture.Text = "Culture Details:";
			// 
			// buttonOfferCultureRemove
			// 
			this.buttonOfferCultureRemove.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.buttonOfferCultureRemove.Location = new System.Drawing.Point(369, 321);
			this.buttonOfferCultureRemove.Name = "buttonOfferCultureRemove";
			this.buttonOfferCultureRemove.Size = new System.Drawing.Size(70, 22);
			this.buttonOfferCultureRemove.TabIndex = 21;
			this.buttonOfferCultureRemove.Text = "Remove";
			// 
			// buttonOfferSaveChanges
			// 
			this.buttonOfferSaveChanges.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
			this.buttonOfferSaveChanges.Location = new System.Drawing.Point(334, 74);
			this.buttonOfferSaveChanges.Name = "buttonOfferSaveChanges";
			this.buttonOfferSaveChanges.Size = new System.Drawing.Size(105, 23);
			this.buttonOfferSaveChanges.TabIndex = 23;
			this.buttonOfferSaveChanges.Text = "Save Changes";
			// 
			// buttonOfferRegionEdit
			// 
			this.buttonOfferRegionEdit.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.buttonOfferRegionEdit.Location = new System.Drawing.Point(369, 408);
			this.buttonOfferRegionEdit.Name = "buttonOfferRegionEdit";
			this.buttonOfferRegionEdit.Size = new System.Drawing.Size(70, 22);
			this.buttonOfferRegionEdit.TabIndex = 28;
			this.buttonOfferRegionEdit.Text = "Edit...";
			// 
			// buttonOfferRegionAdd
			// 
			this.buttonOfferRegionAdd.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.buttonOfferRegionAdd.Location = new System.Drawing.Point(369, 375);
			this.buttonOfferRegionAdd.Name = "buttonOfferRegionAdd";
			this.buttonOfferRegionAdd.Size = new System.Drawing.Size(70, 22);
			this.buttonOfferRegionAdd.TabIndex = 26;
			this.buttonOfferRegionAdd.Text = "Add...";
			// 
			// listviewOfferRegions
			// 
			this.listviewOfferRegions.Anchor = System.Windows.Forms.AnchorStyles.Left;
			this.listviewOfferRegions.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.listviewOfferRegions.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
																								   this.columnheaderOfferRegionCountryId,
																								   this.columnheaderOfferRegionTier,
																								   this.columnheaderOfferRegionPaymentType,
																								   this.columnheaderOfferRegionStartDate,
																								   this.columnheaderOfferRegionEndDate,
																								   this.columnheaderOfferRegionBoid,
																								   this.columnheaderOfferRegionPriceWhole,
																								   this.columnheaderOfferRegionPriceFractional,
																								   this.columnheaderOfferRegionDetails});
			this.listviewOfferRegions.FullRowSelect = true;
			this.listviewOfferRegions.GridLines = true;
			this.listviewOfferRegions.Location = new System.Drawing.Point(9, 147);
			this.listviewOfferRegions.Name = "listviewOfferRegions";
			this.listviewOfferRegions.Size = new System.Drawing.Size(344, 91);
			this.listviewOfferRegions.TabIndex = 25;
			this.listviewOfferRegions.View = System.Windows.Forms.View.Details;
			// 
			// labelOfferRegion
			// 
			this.labelOfferRegion.AutoSize = true;
			this.labelOfferRegion.Location = new System.Drawing.Point(13, 354);
			this.labelOfferRegion.Name = "labelOfferRegion";
			this.labelOfferRegion.Size = new System.Drawing.Size(80, 17);
			this.labelOfferRegion.TabIndex = 24;
			this.labelOfferRegion.Text = "Region Details:";
			// 
			// buttonOfferRegionRemove
			// 
			this.buttonOfferRegionRemove.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.buttonOfferRegionRemove.Location = new System.Drawing.Point(369, 441);
			this.buttonOfferRegionRemove.Name = "buttonOfferRegionRemove";
			this.buttonOfferRegionRemove.Size = new System.Drawing.Size(70, 22);
			this.buttonOfferRegionRemove.TabIndex = 27;
			this.buttonOfferRegionRemove.Text = "Remove";
			// 
			// columnheaderOfferCultureCultureId
			// 
			this.columnheaderOfferCultureCultureId.Text = "Culture Id";
			this.columnheaderOfferCultureCultureId.Width = 100;
			// 
			// columnheaderOfferCultureName
			// 
			this.columnheaderOfferCultureName.Text = "Name";
			this.columnheaderOfferCultureName.Width = 100;
			// 
			// columnheaderOfferCultureShortDescription
			// 
			this.columnheaderOfferCultureShortDescription.Text = "Short Description";
			this.columnheaderOfferCultureShortDescription.Width = 200;
			// 
			// columnheaderOfferCultureSellText
			// 
			this.columnheaderOfferCultureSellText.Text = "Sell Text";
			this.columnheaderOfferCultureSellText.Width = 200;
			// 
			// columnheaderOfferCultureImageFilePath
			// 
			this.columnheaderOfferCultureImageFilePath.Text = "Image Path";
			this.columnheaderOfferCultureImageFilePath.Width = 150;
			// 
			// columnheaderOfferRegionCountryId
			// 
			this.columnheaderOfferRegionCountryId.Text = "Country Id";
			this.columnheaderOfferRegionCountryId.Width = 80;
			// 
			// columnheaderOfferRegionTier
			// 
			this.columnheaderOfferRegionTier.Text = "Tier";
			// 
			// columnheaderOfferRegionPaymentType
			// 
			this.columnheaderOfferRegionPaymentType.Text = "Payment Type";
			this.columnheaderOfferRegionPaymentType.Width = 100;
			// 
			// columnheaderOfferRegionStartDate
			// 
			this.columnheaderOfferRegionStartDate.Text = "Start Date";
			this.columnheaderOfferRegionStartDate.Width = 100;
			// 
			// columnheaderOfferRegionEndDate
			// 
			this.columnheaderOfferRegionEndDate.Text = "End Date";
			this.columnheaderOfferRegionEndDate.Width = 100;
			// 
			// columnheaderOfferRegionBoid
			// 
			this.columnheaderOfferRegionBoid.Text = "Boid";
			this.columnheaderOfferRegionBoid.Width = 100;
			// 
			// columnheaderOfferRegionPriceWhole
			// 
			this.columnheaderOfferRegionPriceWhole.Text = "Whole Price";
			this.columnheaderOfferRegionPriceWhole.Width = 100;
			// 
			// columnheaderOfferRegionPriceFractional
			// 
			this.columnheaderOfferRegionPriceFractional.Text = "Fractional Price";
			this.columnheaderOfferRegionPriceFractional.Width = 100;
			// 
			// columnheaderOfferRegionDetails
			// 
			this.columnheaderOfferRegionDetails.Text = "Offer Details";
			this.columnheaderOfferRegionDetails.Width = 100;
			// 
			// columnheaderTitleRatingsRatingValue
			// 
			this.columnheaderTitleRatingsRatingValue.Text = "Rating Value";
			this.columnheaderTitleRatingsRatingValue.Width = 100;
			// 
			// columnheaderTitleRatingsRatingSystem
			// 
			this.columnheaderTitleRatingsRatingSystem.Text = "Rating System";
			this.columnheaderTitleRatingsRatingSystem.Width = 100;
			// 
			// columnheaderTitleRatingsRating
			// 
			this.columnheaderTitleRatingsRating.Text = "Rating";
			this.columnheaderTitleRatingsRating.Width = 100;
			// 
			// columnheaderTitleCultureCultureId
			// 
			this.columnheaderTitleCultureCultureId.Text = "Culture Id";
			this.columnheaderTitleCultureCultureId.Width = 100;
			// 
			// columnheaderTitleCultureName
			// 
			this.columnheaderTitleCultureName.Text = "Name";
			this.columnheaderTitleCultureName.Width = 100;
			// 
			// columnheaderTitleCultureShortDescription
			// 
			this.columnheaderTitleCultureShortDescription.Text = "Description";
			this.columnheaderTitleCultureShortDescription.Width = 150;
			// 
			// columnheaderTitleCultureSellText
			// 
			this.columnheaderTitleCultureSellText.Text = "Sell Text";
			this.columnheaderTitleCultureSellText.Width = 150;
			// 
			// columnheaderTitleCulturePublisher
			// 
			this.columnheaderTitleCulturePublisher.Text = "Publisher";
			this.columnheaderTitleCulturePublisher.Width = 100;
			// 
			// columnheaderTitleCultureDeveloper
			// 
			this.columnheaderTitleCultureDeveloper.Text = "Developer";
			this.columnheaderTitleCultureDeveloper.Width = 100;
			// 
			// columnheaderTitleCultureGenre
			// 
			this.columnheaderTitleCultureGenre.Text = "Genre";
			this.columnheaderTitleCultureGenre.Width = 100;
			// 
			// columnheaderTitleCultureImageFilePath
			// 
			this.columnheaderTitleCultureImageFilePath.Text = "Image File Path";
			this.columnheaderTitleCultureImageFilePath.Width = 150;
			// 
			// MainForm
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 14);
			this.ClientSize = new System.Drawing.Size(715, 641);
			this.Controls.Add(this.splitter1);
			this.Controls.Add(this.panel2);
			this.Controls.Add(this.panel1);
			this.Font = new System.Drawing.Font("Tahoma", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.MinimumSize = new System.Drawing.Size(723, 478);
			this.Name = "MainForm";
			this.Text = "Content Loader";
			this.Load += new System.EventHandler(this.MainForm_Load);
			this.panel1.ResumeLayout(false);
			this.panel2.ResumeLayout(false);
			this.panelOffer.ResumeLayout(false);
			this.panelTitle.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		private void MainForm_Load(object sender, System.EventArgs e)
		{
			m_titles = new Titles();
			m_offers = new ContentOffers();

			panelOffer.Visible = false; panelOffer.Dock = DockStyle.Fill;
			panelTitle.Visible = false; panelTitle.Dock = DockStyle.Fill;

			// todo: potentially load the xml file here

			TreeNode tn = null;
			TreeNode ln = null;
			
			tn = treeviewMain.Nodes.Add("Titles");
			tn.Tag = "titles";
			ln = tn.Nodes.Add("loading...");
			ln.Tag = "loading";
			
			tn = treeviewMain.Nodes.Add("Offers");
			tn.Tag = "offer";
			ln = tn.Nodes.Add("loading...");
			ln.Tag = "loading";
		}

		private void treeviewMain_BeforeExpand(object sender, System.Windows.Forms.TreeViewCancelEventArgs e)
		{
			if ((e.Action & TreeViewAction.Expand) != 0)
			{
				TreeNode tn = (TreeNode)e.Node;
				if (tn.Nodes.Count == 1 && CompareTagWithText(tn.Nodes[0], "loading"))
				{
					if (CompareTagWithText(tn, "titles")) 
					{
						LoadTitles(tn);
					}
					else if (CompareTagWithText(tn, "offer"))
					{
						LoadContent(tn);
					}
					tn.Nodes[0].Remove();
				}
			}
		}

		private bool CompareTagWithText(TreeNode node, string text)
		{
			return (node.Tag != null && node.Tag.ToString() == text);
		}

		private MainForm.NodeTypes NodeType(TreeNode node)
		{
			NodeTypes nt = NodeTypes.InvalidNodeType;

			if (node != null && node.Tag != null)
			{
				if (node.Tag.ToString() == "titles") return NodeTypes.TitleRoot;
				if (node.Tag.ToString() == "offer") return NodeTypes.OfferRoot;
				if (node.Parent != null)
				{
					if (node.Parent.Tag.ToString() == "titles") return NodeTypes.TitleNode;
					if (node.Parent.Tag.ToString() == "offer") return NodeTypes.OfferNode;
				}
			}

			return nt;
		}

		private void LoadTitles(TreeNode titleRoot)
		{
			if (m_titles != null && m_titles.Title != null)
			{
				for (int i=0; i<m_titles.Title.Length; i++)
				{
					TitlesTitle tt = m_titles.Title[i];
					TreeNode tn = titleRoot.Nodes.Add(tt.titleID.ToString());
					tn.Tag = tn.Text;	// save this just in case the text on the node changes
				}
			}
		}

		private void LoadContent(TreeNode contentRoot)
		{
			if (m_offers != null & m_offers.ContentOffer != null)
			{
				for (int i=0; i<m_offers.ContentOffer.Length; i++)
				{
					ContentOffersContentOffer co = m_offers.ContentOffer[i];
					TreeNode tn = contentRoot.Nodes.Add(co.titleID + "~" + co.offerID);
					tn.Tag = tn.Text;	// save this in case the text on the node changes
				}
			}
		}

		private void treeviewMain_AfterSelect(object sender, System.Windows.Forms.TreeViewEventArgs e)
		{
			panelOffer.Visible = false;
			panelTitle.Visible = false;
			NodeTypes nt = NodeType(e.Node);
			if (nt == NodeTypes.OfferNode)
			{
				string offerId = e.Node.ToString();
				offerId = offerId.Substring(offerId.IndexOf("~")+1);
				ShowOffer(ulong.Parse(offerId));
			}
			if (nt == NodeTypes.TitleNode) 
			{
				ShowTitle(uint.Parse(e.Node.Tag.ToString()));
			}
			if (nt == NodeTypes.OfferRoot) ShowOffer(0);
			if (nt == NodeTypes.TitleRoot) ShowTitle(0);

		}


		private void treeviewMain_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
		{
			treeviewMain.SelectedNode = null;
			treeviewMain.SelectedNode = treeviewMain.GetNodeAt(e.X, e.Y);
			
			if (e.Button == MouseButtons.Right)
			{
				menuTreeView.Show(treeviewMain, new Point(e.X, e.Y));
			}
		}

		private void ShowOffer(ulong offerId)
		{
			panelOffer.Visible = true;

			if (offerId == 0) ClearOfferForm();
		}

		private void ClearOfferForm()
		{
		
		}

		private void ShowTitle(uint titleId)
		{
			panelTitle.Visible = true;

			if (titleId == 0) ClearTitleForm();


		}

		private void ClearTitleForm()
		{
			
		}

		private void panelTitle_Resize(object sender, System.EventArgs e)
		{
			listviewTitleCultures.Top = labelTitleCulture.Bottom + 5;
			listviewTitleCultures.Height = ((buttonTitleSaveChanges.Top - listviewTitleCultures.Top) / 2) - 20;
			listviewTitleCultures.Width = buttonTitleCultureAdd.Left - 5 - listviewTitleCultures.Left;

			labelTitleRatings.Top = listviewTitleCultures.Bottom + 5;
			
			listviewTitleRatings.Top = labelTitleRatings.Bottom + 5;
			listviewTitleRatings.Height = listviewTitleCultures.Height;
			listviewTitleRatings.Width = buttonTitleRatingAdd.Left - 5 - listviewTitleRatings.Left;

			buttonTitleCultureAdd.Top = listviewTitleCultures.Top;
			buttonTitleCultureEdit.Top = buttonTitleCultureAdd.Bottom + 5;
			buttonTitleCultureRemove.Top = buttonTitleCultureEdit.Bottom + 5;

			buttonTitleRatingAdd.Top = listviewTitleRatings.Top;
			buttonTitleRatingEdit.Top = buttonTitleRatingAdd.Bottom + 5;
			buttonTitleRatingRemove.Top = buttonTitleRatingEdit.Bottom + 5;
		}

		private void panelOffer_Resize(object sender, System.EventArgs e)
		{
			listviewOfferCulture.Top = labelOfferCulture.Bottom + 5;
			listviewOfferCulture.Height = ((buttonOfferSaveChanges.Top - listviewOfferCulture.Top) / 2) - 20;
			listviewOfferCulture.Width = buttonOfferCultureAdd.Left - 5 - listviewOfferCulture.Left;

			buttonOfferCultureAdd.Top = listviewOfferCulture.Top;
			buttonOfferCultureEdit.Top = buttonOfferCultureAdd.Bottom + 5;
			buttonOfferCultureRemove.Top = buttonOfferCultureEdit.Bottom + 5;


			labelOfferRegion.Top = listviewOfferCulture.Bottom + 5;

			listviewOfferRegions.Left = listviewOfferCulture.Left;
			listviewOfferRegions.Width = listviewOfferCulture.Width;
			listviewOfferRegions.Top = labelOfferRegion.Bottom + 5;
			listviewOfferRegions.Height = listviewOfferCulture.Height;

			buttonOfferRegionAdd.Left = buttonOfferCultureAdd.Left;
			buttonOfferRegionAdd.Top = listviewOfferRegions.Top;
			buttonOfferRegionEdit.Left = buttonOfferRegionAdd.Left;
			buttonOfferRegionEdit.Top = buttonOfferRegionAdd.Bottom + 5;
			buttonOfferRegionRemove.Left = buttonOfferRegionEdit.Left;
			buttonOfferRegionRemove.Top = buttonOfferRegionEdit.Bottom + 5;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XeOfferLoader\XeOfferLoader_XmlFiles.cs ===
using System;
using System.Collections;

namespace Microsoft.XBox.Live.Test.OfferLoader
{

	public class XmlFiles : IEnumerable
	{
		private ArrayList m_files;

		public XmlFiles()
		{
			m_files = new ArrayList();	
		}

		public int Add(string xmlFileName)
		{
			return m_files.Add(new XmlFile(xmlFileName));
		}

		public int Add(XmlFile xmlFile)
		{
			return m_files.Add(xmlFile);
		}
	
		public int Count
		{
			get { return m_files.Count; }
		}

		public void Clear()
		{
			m_files.Clear();
		}

		public IEnumerator GetEnumerator()
		{
			return new XmlFilesEnumerator(m_files);
		}

		private class XmlFilesEnumerator : IEnumerator
		{
			int m_index = -1;
			ArrayList m_files = null;

			public XmlFilesEnumerator(ArrayList files)
			{
				m_index = -1;
				m_files = files;
			}

			public void Reset()
			{
				m_index = -1;
			}

			public object Current
			{
				get
				{
					return m_files[m_index];
				}
			}

			public bool MoveNext()
			{
				if (m_index < m_files.Count - 1)
				{
					m_index++;
					return true;
				}
				else
				{
					return false;
				}
			}

		}
	}

	public class XmlFile
	{
		private string m_filename;

		public XmlFile()
		{
		}

		public XmlFile(string fileName)
		{
			m_filename = fileName;
		}

		public string FileName
		{
			get { return m_filename; } set { m_filename = value; }
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XeOfferLoader\XeOfferLoader_ContentOffer.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.2032
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by xsd, Version=1.1.4322.2032.
// 
using System.Xml.Serialization;


/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
[System.Xml.Serialization.XmlRootAttribute(Namespace="http://www.xboxlive.com/xlast", IsNullable=false)]
public class ContentOffers {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("ContentOffer")]
    public ContentOffersContentOffer[] ContentOffer;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
public class ContentOffersContentOffer {
    
    /// <remarks/>
    public System.UInt32 titleID;
    
    /// <remarks/>
    public System.UInt64 offerID;
    
    /// <remarks/>
    public string packageSize;
    
    /// <remarks/>
    public string installSize;
    
    /// <remarks/>
    public System.UInt32 bitFilter;
    
    /// <remarks/>
    public string offerType;
    
    /// <remarks/>
    public string friendlyName;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("cultureDetails")]
    public ContentOffersContentOfferCultureDetails[] cultureDetails;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("region")]
    public ContentOffersContentOfferRegion[] region;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
public class ContentOffersContentOfferCultureDetails {
    
    /// <remarks/>
    public System.UInt32 culture;
    
    /// <remarks/>
    public string name;
    
    /// <remarks/>
    public string shortDescription;
    
    /// <remarks/>
    public string sellText;
    
    /// <remarks/>
    public string imageFilePath;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
public class ContentOffersContentOfferRegion {
    
    /// <remarks/>
    public System.Byte countryID;
    
    /// <remarks/>
    public System.UInt32 tierRequired;
    
    /// <remarks/>
    public System.UInt32 paymentType;
    
    /// <remarks/>
    public System.DateTime startDate;
    
    /// <remarks/>
    public System.DateTime endDate;
    
    /// <remarks/>
    public string boid;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="nonNegativeInteger")]
    public string priceWhole;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="nonNegativeInteger")]
    public string priceFractional;
    
    /// <remarks/>
    public System.UInt32 specificOfferDetails;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XeOfferLoader\xsd\contentoffer.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.2032
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by xsd, Version=1.1.4322.2032.
// 
using System.Xml.Serialization;


/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
[System.Xml.Serialization.XmlRootAttribute(Namespace="http://www.xboxlive.com/xlast", IsNullable=false)]
public class ContentOffers {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("ContentOffer")]
    public ContentOffersContentOffer[] ContentOffer;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
public class ContentOffersContentOffer {
    
    /// <remarks/>
    public System.UInt32 titleID;
    
    /// <remarks/>
    public System.UInt64 offerID;
    
    /// <remarks/>
    public string packageSize;
    
    /// <remarks/>
    public string installSize;
    
    /// <remarks/>
    public System.UInt32 bitFilter;
    
    /// <remarks/>
    public string offerType;
    
    /// <remarks/>
    public string friendlyName;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("cultureDetails")]
    public ContentOffersContentOfferCultureDetails[] cultureDetails;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("region")]
    public ContentOffersContentOfferRegion[] region;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
public class ContentOffersContentOfferCultureDetails {
    
    /// <remarks/>
    public System.UInt32 culture;
    
    /// <remarks/>
    public string name;
    
    /// <remarks/>
    public string shortDescription;
    
    /// <remarks/>
    public string sellText;
    
    /// <remarks/>
    public string imageFilePath;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
public class ContentOffersContentOfferRegion {
    
    /// <remarks/>
    public System.Byte countryID;
    
    /// <remarks/>
    public System.UInt32 tierRequired;
    
    /// <remarks/>
    public System.UInt32 paymentType;
    
    /// <remarks/>
    public System.DateTime startDate;
    
    /// <remarks/>
    public System.DateTime endDate;
    
    /// <remarks/>
    public string boid;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="nonNegativeInteger")]
    public string priceWhole;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="nonNegativeInteger")]
    public string priceFractional;
    
    /// <remarks/>
    public System.UInt32 specificOfferDetails;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XeOfferLoader\XeOfferLoader_Title.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.2032
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by xsd, Version=1.1.4322.2032.
// 
using System.Xml.Serialization;


/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
[System.Xml.Serialization.XmlRootAttribute(Namespace="http://www.xboxlive.com/xlast", IsNullable=false)]
public class Titles {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("Title")]
    public TitlesTitle[] Title;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
public class TitlesTitle {
    
    /// <remarks/>
    public System.UInt32 titleID;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("cultureDetails")]
    public TitlesTitleCultureDetails[] cultureDetails;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("rating")]
    public System.UInt16[] rating;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
public class TitlesTitleCultureDetails {
    
    /// <remarks/>
    public System.UInt32 culture;
    
    /// <remarks/>
    public string name;
    
    /// <remarks/>
    public string shortDescription;
    
    /// <remarks/>
    public string sellText;
    
    /// <remarks/>
    public string publisher;
    
    /// <remarks/>
    public string developer;
    
    /// <remarks/>
    public string genre;
    
    /// <remarks/>
    public string imageFilePath;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XeOfferLoader\xsd\title.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.2032
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by xsd, Version=1.1.4322.2032.
// 
using System.Xml.Serialization;


/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
[System.Xml.Serialization.XmlRootAttribute(Namespace="http://www.xboxlive.com/xlast", IsNullable=false)]
public class Titles {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("Title")]
    public TitlesTitle[] Title;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
public class TitlesTitle {
    
    /// <remarks/>
    public System.UInt32 titleID;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("cultureDetails")]
    public TitlesTitleCultureDetails[] cultureDetails;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("rating")]
    public System.UInt16[] rating;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
public class TitlesTitleCultureDetails {
    
    /// <remarks/>
    public System.UInt32 culture;
    
    /// <remarks/>
    public string name;
    
    /// <remarks/>
    public string shortDescription;
    
    /// <remarks/>
    public string sellText;
    
    /// <remarks/>
    public string publisher;
    
    /// <remarks/>
    public string developer;
    
    /// <remarks/>
    public string genre;
    
    /// <remarks/>
    public string imageFilePath;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\Common\Globals.cs ===
using System;
using System.Diagnostics;
using System.Text;
using System.Xml;

namespace XlastAuto
{
    public static class Globals
    {
        public const string DefaultBlastPath = @"C:\Program Files (x86)\Microsoft Xbox 360 SDK\bin\win32\blast.exe";
        private static string _blastPath = DefaultBlastPath;
        public static string BlastPath
        {
            get { return _blastPath; }
            set { _blastPath = value; }
        }

        public const string DefaultSpacDebugPath = @"spac.exe";
        private static string _spacDebugPath = DefaultSpacDebugPath;
        public static string SpacDebugPath
        {
            get { return _spacDebugPath; }
            set { _spacDebugPath = value; }
        }

        public const string DefaultSpacRetailPath = @"spac.exe";
        private static string _spacRetailPath = DefaultSpacRetailPath;
        public static string SpacRetailPath
        {
            get { return _spacRetailPath; }
            set { _spacRetailPath = value; }
        }

        public const string DefaultXlastDataFixupsPath = @"XlastDataFixups.exe";
        private static string _xlastDataFixupsPath = DefaultXlastDataFixupsPath;
        public static string XlastDataFixupsPath
        {
            get { return _xlastDataFixupsPath; }
            set { _xlastDataFixupsPath = value; }
        }

        public const string DefaultPositiveBvtsDataPath = @"SuitesData\XlastAuto\BVTs\Positive";
        private static string _suitesDataPath = DefaultPositiveBvtsDataPath;
        public static string PositiveBvtsDataPath
        {
            get { return _suitesDataPath; }
            set { _suitesDataPath = value; }
        }

        public const string DefaultLiveTitlePath = @"C:\esp\Webroot\XblTools\LiveTitle.exe";
        private static string _liveTitlePath = DefaultLiveTitlePath;
        public static string LiveTitlePath
        {
            get { return _liveTitlePath; }
            set { _liveTitlePath = value; }
        }

        public static string GetXMLValue(XmlDocument doc, string path, string defaultValue)
        {
            XmlNode node = doc.SelectSingleNode(path);
            if (node != null)
            {
                if (node.Attributes["value"] != null)
                    return node.Attributes["value"].Value;
                else
                    return defaultValue;
            }
            else
            {
                return defaultValue;
            }
        }

        public static string GetAttributeValue(XmlNode xmlNode, string attribName, string defaultValue)
        {
            string attribValue = defaultValue;
            XmlAttribute xmlAttrib = xmlNode.Attributes[attribName];
            if (xmlAttrib != null)
            {
                attribValue = xmlAttrib.Value;
            }
            return attribValue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\Drivers\TestNodeFromXml.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;

using ServerTestFramework;

namespace XlastAuto.Drivers
{
    public class TestNodeFromXml : TestNode
    {
        protected List<string> casesFromXmlPaths = new List<string>();

        public static TestNodeFromXml Create(XmlNode testGroupXml)
        {
            //[TestGroup, Owner("mifish"), TestFrequency("Regression"), EnvRequirement("Manual"), Description("XLAST BVTs")]
            TestNodeFromXml testNode = new TestNodeFromXml();
            testNode.Name = Globals.GetAttributeValue(testGroupXml, "name", null);
            testNode.TaggingData.AddTagValue("Owner", Globals.GetAttributeValue(testGroupXml, "testOwner", null));
            testNode.Desc = Globals.GetAttributeValue(testGroupXml, "description", null);

            foreach (XmlNode child in testGroupXml.ChildNodes)
            {
                if (child.Name.ToLowerInvariant() == "testgroup")
                {
                    // Create a TestNode (aka TestGroup)
                    testNode.AddChild(TestNodeFromXml.Create(child), true, false);
                }
                else if (child.Name.ToLowerInvariant() == "casesfromxml")
                {
                    // Create compound case from path to XLASTs
                    testNode.casesFromXmlPaths.Add(Globals.GetAttributeValue(child, "path", null));
                }
            }
            return testNode;
        }

        protected TestNodeFromXml()
        {
        }

        protected override void EditInstances(ref List<CompoundCaseAttribute> instances)
        {
            foreach (string path in casesFromXmlPaths)
            {
                // Run XlastDataFixups before building the test case list
                XlastHelper.XlastDataFixup(path);

                // Turn each XLAST into a distinct positive test case
                List<FileInfo> xlastFileInfos = XlastHelper.GetXlastFileInfoList(path);
                xlastFileInfos.Sort(XlastHelper.CompareFileInfosByName);
                foreach (FileInfo xlastFileInfo in xlastFileInfos)
                {
                    int idx = xlastFileInfo.Name.LastIndexOf(".xlast");
                    string cleanName = xlastFileInfo.Name.Substring(0, idx);
                    instances.Add(new CompoundCaseAttribute("P_" + cleanName, xlastFileInfo));
                }
            }
        }

        public List<IExecutor> GetExecutors()
        {
            List<IExecutor> executors = new List<IExecutor>();
            executors.Add(new BlastExecutor());
            executors.Add(new LiveTitleExecutor());
            return executors;
        }

        public override void Run()
        {
            // Build the test case from the XLAST
            FileInfo xlastFileInfo = (FileInfo)MyValues[0];
            Global.RO.Info("Running " + Name + " using " + xlastFileInfo.FullName);

            // Create the validators and test executor
            List<IExecutor> executors = GetExecutors();

            bool passed = true;
            foreach (IExecutor executor in executors)
            {
                ExecutionResults results = executor.Execute(xlastFileInfo.FullName);

                // Create and run the validators
                IValidator outputValidator = executor.GetOutputValidator();
                passed &= outputValidator.ExpectNoErrors(results);
                if (!passed)
                {
                    break;
                }
            }

            //Additional validators go here

            if (!passed)
            {
                throw new UnexpectedTestResultException("Did not pass validation.");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\Common\Blast.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.IO;

using ServerTestFramework.Utilities;

namespace XlastAuto
{
    public class Blast
    {
        private bool useSpac = false;

        private ProcessWrapper _blastProcess;
        public string StdOut
        {
            get { return _blastProcess.Output; }
        }
        public string StdErr
        {
            get { return _blastProcess.Error; }
        }

        private ProcessWrapper _unCompileProcess;

        public int ErrorCode = 0;

        public Blast() : this(false)
        {
        }

        public Blast(bool useSpac)
        {
            Globals.BlastPath = Globals.GetXMLValue(ServerTestFramework.Global.Config,
                "/stf/config/tests/option[@name='BlastPath']", Globals.DefaultBlastPath);

            Globals.SpacRetailPath = Globals.GetXMLValue(ServerTestFramework.Global.Config,
                "/stf/config/tests/option[@name='SpacRetailPath']", Globals.DefaultSpacRetailPath);

            this.useSpac = useSpac;

            if (useSpac)
            {
                _blastProcess = new ProcessWrapper("Spac", Globals.SpacRetailPath);
                _blastProcess.Verbose = true;
            }
            else
            {
                _blastProcess = new ProcessWrapper("Blast", Globals.BlastPath);
                _blastProcess.Verbose = true;
            }

            Globals.SpacDebugPath = Globals.GetXMLValue(ServerTestFramework.Global.Config,
                "/stf/config/tests/option[@name='SpacDebugPath']", Globals.DefaultSpacDebugPath);

            _unCompileProcess = new ProcessWrapper("Spac", Globals.SpacDebugPath);
            _unCompileProcess.Verbose = true;
        }

        /// <summary>
        /// Exposes the Execution Timeout value for the underlying Process wrapper.
        /// </summary>
        public int ExecutionTimeout
        {
            get { return _blastProcess.ExecutionTimeout; }
            set { _blastProcess.ExecutionTimeout = value; }
        }

        public bool Execute(string filePath)
        {
            bool succeeded = true;

            string cwd = System.IO.Path.GetDirectoryName(filePath);
            _blastProcess.WorkingDirectory = cwd;
            string fileName = System.IO.Path.GetFileName(filePath);

            try
            {
                if (useSpac)
                {
                    ErrorCode = _blastProcess.Run(fileName);
                }
                else
                {
                    ErrorCode = _blastProcess.Run(fileName + @" /build");
                }

                Console.WriteLine(_blastProcess.ProcessName + " returned " + ErrorCode.ToString());

                if (ErrorCode != 0)
                {
                    succeeded = false;
                }

            }
            catch (Exception ex)
            {
                Console.WriteLine(_blastProcess.ProcessName + " failed with exception:\r\n" + ex.ToString());
                throw;
            }
            finally
            {
                Console.WriteLine(_blastProcess.Output);
            }

            if (useSpac)
            {
                // Un-compile the spa file, if one has been produced
                FileInfo fi = new FileInfo(filePath);
                string spaFileName = fileName.Substring(0, fileName.Length - fi.Extension.Length) + ".spa";

                if (System.IO.File.Exists(cwd + "\\" + spaFileName))
                {
                    _unCompileProcess.WorkingDirectory = cwd;

                    try
                    {
                        _unCompileProcess.Run("-u " + spaFileName);
                    }
                    catch (Exception ex)
                    {
                        succeeded = false;
                        Console.WriteLine("Spac failed with exception:\r\n" + ex.ToString());
                    }

                    // Output the SPA dump to .spa.dump file
                    StreamWriter wr = new StreamWriter(cwd + "\\" + spaFileName + ".dump");
                    wr.Write(_unCompileProcess.Output);
                    wr.Close();
                }
            }

            return succeeded;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\Drivers\XlastAutoSuite.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;

using ServerTestFramework;

namespace XlastAuto.Drivers
{
    public class XlastAutoSuite : TestSuite
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\Drivers\SPACFunctional.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Diagnostics;

using ServerTestFramework;

using ServerTestFramework.Utilities;

namespace XlastAuto.Drivers
{
    [TestGroup, Owner("viks"), TestFrequency("Regression"), EnvRequirement("Manual"), Description("SPAC Functional tests")]
    class SPACFunctional
    {       
        public static void XlastDataFixup(string basePath)
        {
            String exeName = "XlastDataFixups.exe";

            // Make sure XlastDataFixups is available for execution
            Process xdf = new Process();
            xdf.StartInfo.CreateNoWindow = true;
            xdf.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
            xdf.StartInfo.FileName = exeName;

            try
            {
                xdf.Start();
                xdf.WaitForExit();
            }
            catch (FileNotFoundException)
            {
                Global.RO.Warn("Could not find XlastDataFixups.exe. Make sure it's in the path. Tests might not PASS without running this on XLAST directory");
                return;
            }

            DirectoryInfo baseDir = new DirectoryInfo(basePath);
            
            foreach (DirectoryInfo subDir in baseDir.GetDirectories())
            {
                // Do a fixup only if the XLAST is in the immediate sub-directory
                // and not already in some "spacer" directory
                foreach (FileInfo xlastFile in subDir.GetFiles("*.xlast"))
                {
                    // Skip Files that don't need to be fixed
                    if (xlastFile.FullName.Contains("DontFix"))
                    {
                        continue;
                    }

                    ProcessWrapper fixupProc = new ProcessWrapper("XlastDataFixup", exeName);

                    bool failed = false;
                    try
                    {
                        int ec = fixupProc.Run(xlastFile.FullName);
                        if (ec != 0)
                        {
                            failed = true;
                        }
                    }
                    catch (Exception)
                    {
                        failed = true;
                    }

                    if (failed)
                    {
                        Global.RO.Warn("Could not fixup XLAST data for " + xlastFile.FullName);
                    }
                }
            }
        }

        public static List<FileInfo> GetXlastFileInfoList(string basePath)
        {
            DirectoryInfo baseDir = new DirectoryInfo(basePath);
            FileInfo[] xlasts = baseDir.GetFiles("*.xlast", SearchOption.AllDirectories);

            List<FileInfo> xlastFileInfos = new List<FileInfo>();
            xlastFileInfos.AddRange(xlasts);
            return xlastFileInfos;
        }

        private static int CompareFileInfosByName(FileInfo x, FileInfo y)
        {
            if (x == null)
            {
                // If x is null...
                if (y == null)
                {
                    // ...and y is null, they're equal. 
                    return 0;
                }
                else
                {
                    // ...and y is not null, y is greater.
                    return -1;
                }
            }
            else
            {
                // If x is not null...
                if (y == null)
                {
                    // ...and y is null, x is greater.
                    return 1;
                }
                else
                {
                    // ...and y is not null, compare the file names
                    return x.Name.CompareTo(y.Name);
                }
            }
        }


        public class SpacPositiveFunctionalBase : TestNode
        {
            protected String _suitesDataPath = null;

            protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
            {
                // Run XlastDataFixups before building the test case list
                XlastDataFixup(_suitesDataPath);

                List<FileInfo> xlastFileInfos = GetXlastFileInfoList(_suitesDataPath);
                xlastFileInfos.Sort(CompareFileInfosByName);
                foreach (FileInfo xlastFileInfo in xlastFileInfos)
                {
                    int idx = xlastFileInfo.Name.LastIndexOf(".xlast");
                    string cleanName = xlastFileInfo.Name.Substring(0, idx);
                    instances.Add(new CompoundCaseAttribute("P_" + cleanName, xlastFileInfo));
                }
            }

            public IExecutor GetExecutor()
            {
                BlastExecutor executor = new BlastExecutor();
                executor.UseSpac = true;
                return executor;
            }

            public override void Run()
            {
                // Build the test case from the XLAST
                FileInfo xlastFileInfo = (FileInfo)MyValues[0];
                Global.RO.Info("Running " + Name + " using " + xlastFileInfo.FullName);

                // Create the validators and test executor
                IExecutor executor = GetExecutor();
                ExecutionResults results = executor.Execute(xlastFileInfo.FullName);

                // Create and run the validators
                IValidator outputValidator = executor.GetOutputValidator();

                bool passed = false;

                // Check the output and compare with expected results file
                String xlastName = xlastFileInfo.Name.Substring(0, xlastFileInfo.Name.Length - xlastFileInfo.Extension.Length);
                FileInfo[] expectedOutputFileInfos = xlastFileInfo.Directory.GetFiles(xlastName + "-expected*");

                if (expectedOutputFileInfos.Length == 0)
                {
                    Global.RO.Error("No expected output files to check against");
                    passed = false;
                }
                else
                {
                    String[] expectedOutputFiles = new String[expectedOutputFileInfos.Length];

                    int i = 0;
                    foreach (FileInfo fi in expectedOutputFileInfos)
                    {
                        expectedOutputFiles[i++] = fi.FullName;
                    }

                    passed = outputValidator.ExpectNoErrors(results, expectedOutputFiles);
                }

                //Additional validators go here


                if (!passed)
                {
                    throw new UnexpectedTestResultException("Did not pass validation.");
                }
            }
        }

        [TestCase]
        class Regression : SpacPositiveFunctionalBase
        {
            public Regression()
            {
                _suitesDataPath = @"SuitesData\XlastAuto\SPACFunctional\Regression";
            }
        }

        [TestCase]
        class AvatarItems_Positive : SpacPositiveFunctionalBase
        {
            public AvatarItems_Positive()
            {
                _suitesDataPath = @"SuitesData\XlastAuto\SPACFunctional\AvatarItems\Positive";
            }
        }

        [TestCase]
        public class AvatarItems_Negative : TestNode
        {
            protected String _suitesDataPath = @"SuitesData\XlastAuto\SPACFunctional\AvatarItems\Negative";

            protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
            {
                // Run XlastDataFixups before building the test case list
                XlastDataFixup(_suitesDataPath);

                List<FileInfo> xlastFileInfos = GetXlastFileInfoList(_suitesDataPath);
                xlastFileInfos.Sort(CompareFileInfosByName);
                foreach (FileInfo xlastFileInfo in xlastFileInfos)
                {
                    int idx = xlastFileInfo.Name.LastIndexOf(".xlast");
                    string cleanName = xlastFileInfo.Name.Substring(0, idx);
                    instances.Add(new CompoundCaseAttribute("N_" + cleanName, xlastFileInfo));
                }
            }

            public IExecutor GetExecutor()
            {
                BlastExecutor executor = new BlastExecutor();
                executor.UseSpac = true;
                return executor;
            }

            public override void Run()
            {
                // Build the test case from the XLAST
                FileInfo xlastFileInfo = (FileInfo)MyValues[0];
                Global.RO.Info("Running " + Name + " using " + xlastFileInfo.FullName);

                // Create the validators and test executor
                IExecutor executor = GetExecutor();
                ExecutionResults results = executor.Execute(xlastFileInfo.FullName);

                // Create and run the validators
                IValidator outputValidator = executor.GetOutputValidator();

                bool passed = true;

                // Check the output and compare with expected results file
                String xlastName = xlastFileInfo.Name.Substring(0, xlastFileInfo.Name.Length - xlastFileInfo.Extension.Length);
                FileInfo[] errorFileInfo = xlastFileInfo.Directory.GetFiles(xlastName + ".err");

                if (errorFileInfo.Length == 0)
                {
                    Global.RO.Error("No expected error file '" + xlastName + ".err' to check against");
                    passed = false;
                }
                else
                {
                    int errorCode = 0;
                    String expectedError = String.Empty;


                    try
                    {
                        using (StreamReader reader = new StreamReader(errorFileInfo[0].FullName))
                        {
                            errorCode = Int32.Parse(reader.ReadLine().Trim());
                            expectedError = reader.ReadLine();
                        }
                    }
                    catch (Exception)
                    {
                        Global.RO.Error("Invalid error file '" + xlastName + ".err'"); 
                        passed = false;
                    }

                    if (passed)
                    {
                        passed = outputValidator.ExpectError(results, errorCode, expectedError);
                    }
                }

                // Additional validators go here


                if (!passed)
                {
                    throw new UnexpectedTestResultException("Did not pass validation.");
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\Drivers\TestSuiteFromXml.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;

using ServerTestFramework;

[assembly: RootNode(typeof(XlastAuto.Drivers.TestSuiteFromXml))]

namespace XlastAuto.Drivers
{
    public class TestSuiteFromXml : TestNode
    {
        public TestSuiteFromXml()
        {
            XmlDocument doc = ServerTestFramework.Global.Config;
            XmlNode node = doc.SelectSingleNode("/stf/config/xlastauto/dynamictests");
            if (node == null)
            {
                throw new Exception("Could not read XlastAuto.xml data from STF config object.  Verify XlastAuto.xml exists in the same folder as XlastAuto.dll");
            }

            // Dispatch each child for some TLC
            foreach (XmlNode child in node.ChildNodes)
            {
                AddChild(TestNodeFromXml.Create(child), true, false);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\Common\XlastHelper.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace XlastAuto
{
    public static class XlastHelper
    {
        public static List<FileInfo> GetXlastFileInfoList(string basePath)
        {
            DirectoryInfo baseDir = new DirectoryInfo(basePath);
            FileInfo[] xlasts = baseDir.GetFiles("*.xlast", SearchOption.AllDirectories);

            List<FileInfo> xlastFileInfos = new List<FileInfo>();
            xlastFileInfos.AddRange(xlasts);
            return xlastFileInfos;
        }

        public static int CompareFileInfosByName(FileInfo x, FileInfo y)
        {
            if (x == null)      // x is null...
            {
                if (y == null)
                {
                    return 0;   // ...and y is null, so they're equal. 
                }
                else
                {
                    return -1;  // ...and y is not null, so y is greater.
                }
            }
            else                // x is not null...
            {
                if (y == null)
                {
                    return 1;   // ...and y is null, so x is greater.
                }
                else
                {
                    return x.Name.CompareTo(y.Name);    // ...and y is not null, so compare the file names
                }
            }
        }
        
        public static XmlDocument LoadXLastFile(string filePath)
        {
            XmlDocument doc = new XmlDocument();
            doc.Load(filePath);
            return doc;
        }

        public static void XlastDataFixup(string basePath)
        {
            // Make sure XlastDataFixups is available for execution
            Process xdf = new Process();
            xdf.StartInfo.CreateNoWindow = true;
            xdf.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
            xdf.StartInfo.FileName = Globals.XlastDataFixupsPath;

            try
            {
                xdf.Start();
                xdf.WaitForExit();
            }
            catch (FileNotFoundException)
            {
                Global.RO.Warn("Could not find XlastDataFixups.exe. Make sure it's in the path. Tests might not PASS without running this on XLAST directory");
                return;
            }

            DirectoryInfo baseDir = new DirectoryInfo(basePath);

            foreach (DirectoryInfo subDir in baseDir.GetDirectories())
            {
                // Do a fixup only if the XLAST is in the immediate sub-directory
                // and not already in some "spacer" directory
                foreach (FileInfo xlastFile in subDir.GetFiles("*.xlast"))
                {
                    ProcessWrapper fixupProc = new ProcessWrapper("XlastDataFixup", Globals.XlastDataFixupsPath);

                    bool failed = false;
                    try
                    {
                        int ec = fixupProc.Run(xlastFile.FullName);
                        if (ec != 0)
                        {
                            failed = true;
                        }
                    }
                    catch (Exception)
                    {
                        failed = true;
                    }

                    if (failed)
                    {
                        Global.RO.Warn("Could not fixup XLAST data for " + xlastFile.FullName);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\Drivers\XlastFeeder.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;

namespace XlastAuto.Drivers
{
    public class XlastLoader
    {
        public List<string> LoadDataFileList(string filePath)
        {
            StreamReader streamReader = File.OpenText(filePath);
            string input;
            List<string> files = new List<string>();
            while ((input = streamReader.ReadLine()) != null)
            {
                files.Add(input);
            }
            return files;
        }

        public void Run()
        {
            List<string> files = LoadDataFileList("XlastFeederData.txt");

            BlastExecutor executor = new BlastExecutor();
            foreach (string filePath in files)
            {
                if (filePath == String.Empty)
                {
                    continue;
                }
                //executor.Execute(filePath);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xlastauto_none_12.4.56.0_none_552866c873889d12
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xlastauto_no-public-key_12.4.56.0_x-ww_b4cbaaa0
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xlastauto
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xlastauto_no-public-key_12.4.56.0_x-ww_b4cbaaa0
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xlastauto_no-public-key_12.4.56.0_x-ww_b4cbaaa0.manifest
XP_MANIFEST_PATH=manifests\msil_xlastauto_no-public-key_12.4.56.0_x-ww_b4cbaaa0.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xlastauto_no-public-key_12.4.56.0_x-ww_b4cbaaa0.cat
XP_CATALOG_PATH=manifests\msil_xlastauto_no-public-key_12.4.56.0_x-ww_b4cbaaa0.cat
XP_PAYLOAD_PATH=msil_xlastauto_no-public-key_12.4.56.0_x-ww_b4cbaaa0
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xlastauto,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\Executors\IExecutor.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;

namespace XlastAuto
{
    public enum Executors
    {
        Blast = 0
    }

    public class ExecutionResults
    {
        public Executors ExecutorType;
        public int ErrorCode;
        public string StdOut;
        public string StdErr;
    }

    public interface IExecutor
    {
        IValidator GetOutputValidator();
        ExecutionResults Execute(string filePath);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xlastauto_none_12.4.56.0_none_552866c873889d12
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xlastauto_no-public-key_12.4.56.0_x-ww_b4cbaaa0
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xlastauto
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xlastauto_no-public-key_12.4.56.0_x-ww_b4cbaaa0
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xlastauto_no-public-key_12.4.56.0_x-ww_b4cbaaa0.manifest
XP_MANIFEST_PATH=manifests\msil_xlastauto_no-public-key_12.4.56.0_x-ww_b4cbaaa0.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xlastauto_no-public-key_12.4.56.0_x-ww_b4cbaaa0.cat
XP_CATALOG_PATH=manifests\msil_xlastauto_no-public-key_12.4.56.0_x-ww_b4cbaaa0.cat
XP_PAYLOAD_PATH=msil_xlastauto_no-public-key_12.4.56.0_x-ww_b4cbaaa0
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xlastauto,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\Executors\BlastExecutor.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Xml;

namespace XlastAuto
{
    public class BlastExecutor : IExecutor
    {
        public bool UseSpac = false;

        public IValidator GetOutputValidator()
        {
            return new BlastOutputValidator();
        }

        public ExecutionResults Execute(string filePath)
        {
            Blast blast = new Blast(UseSpac);            
            blast.Execute(filePath);

            ExecutionResults results = new ExecutionResults();
            results.ExecutorType = Executors.Blast;
            results.ErrorCode = blast.ErrorCode;
            results.StdOut = blast.StdOut;
            results.StdErr = blast.StdErr;
            return results;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("XlastAuto")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("XlastAuto")]
[assembly: AssemblyCopyright("Copyright  Microsoft 2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("0a73251b-fd2d-42d8-9349-c8f24a1805e5")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\Executors\LiveTitleExecutor.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using LiveTitle = ServerTestFramework.STFTools.LiveTitle;

namespace XlastAuto
{
    public class LiveTitleExecutor : IExecutor
    {
        public IValidator GetOutputValidator()
        {
            return new BlastOutputValidator();
        }

        public ExecutionResults Execute(string filePath)
        {
            Globals.LiveTitlePath = Globals.GetXMLValue(ServerTestFramework.Global.Config, 
                "/stf/config/tests/option[@name='LiveTitlePath']", Globals.DefaultLiveTitlePath);

            LiveTitle liveTitle = new LiveTitle();

            //liveTitle.WorkingDirectory = System.IO.Directory.GetCurrentDirectory();
            liveTitle.LiveTitlePath = Globals.LiveTitlePath;
            liveTitle.XlastPath = filePath;
            //liveTitle.LTCPath = "";
            //liveTitle.LeaderboardServer = "";
            //liveTitle.MatchServers = "";

            uint titleId = Convert.ToUInt32(System.IO.Path.GetFileNameWithoutExtension(filePath), 16);
            liveTitle.DeployXbox360Title(titleId);

            ExecutionResults results = new ExecutionResults();
            results.ExecutorType = Executors.Blast;
            //results.ErrorCode = liveTitle.ErrorCode;
            results.StdOut = liveTitle.Output;
            //results.StdErr = liveTitle.StdErr;
            return results;

/*
            liveTitle.Execute(filePath);

            ExecutionResults results = new ExecutionResults();
            results.ExecutorType = Executors.Blast;
            results.ErrorCode = liveTitle.ErrorCode;
            results.StdOut = liveTitle.StdOut;
            results.StdErr = liveTitle.StdErr;
            return results;
 */
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\SuitesData\SPACFunctional\AvatarItems\Positive\Arcade\Arcade-3-Sub-expected.spa.h ===
////////////////////////////////////////////////////////////////////
//
// Arcade-3-Sub.spa.h
//
// Auto-generated on {*}
// XLAST project version {*}
// SPA Compiler version {*}
//
////////////////////////////////////////////////////////////////////

#ifndef __UNO_RUSH__SPA_H__
#define __UNO_RUSH__SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_UNO_RUSH_                           0x5841089A

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//

#define CONTEXT_PLACE                               0
#define CONTEXT_GAME_STRUCTURE                      1
#define CONTEXT_GAME_BUTTON                         2
#define CONTEXT_CALL_UNO                            3
#define CONTEXT_DRAW_TYPE                           4
#define CONTEXT_GAME_SCORE                          5
#define CONTEXT_GAME_SPEED                          6
#define CONTEXT_INITIAL_HANDSIZE                    7
#define CONTEXT_PROGRESSIVE_PENALTIES               8
#define CONTEXT_SPECIALS                            10
#define CONTEXT_WILD_PARTOF_RUN                     11
#define CONTEXT_SCORING_TYPE                        12
#define CONTEXT_CAMERA_ALLOWED                      13
#define CONTEXT_NETWORKSTATE                        14

//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for CONTEXT_PLACE

#define CONTEXT_PLACE_PLACE_FIRST                   0
#define CONTEXT_PLACE_PLACE_SECOND                  1
#define CONTEXT_PLACE_PLACE_THIRD                   2
#define CONTEXT_PLACE_PLACE_NONE                    3

// Values for CONTEXT_GAME_STRUCTURE

#define CONTEXT_GAME_STRUCTURE_STANDARD_UNO         0
#define CONTEXT_GAME_STRUCTURE_PARTNER_UNO          1
#define CONTEXT_GAME_STRUCTURE_ELIMINATION_UNO      2

// Values for CONTEXT_GAME_BUTTON

#define CONTEXT_GAME_BUTTON_BUTTON_A                0
#define CONTEXT_GAME_BUTTON_BUTTON_B                1

// Values for CONTEXT_CALL_UNO

#define CONTEXT_CALL_UNO_OFF                        0
#define CONTEXT_CALL_UNO_ON                         1

// Values for CONTEXT_DRAW_TYPE

#define CONTEXT_DRAW_TYPE_DRAW_AND_PLAY             0
#define CONTEXT_DRAW_TYPE_DRAW_ONLY                 1
#define CONTEXT_DRAW_TYPE_DRAW_UNTIL_PLAY           2

// Values for CONTEXT_GAME_SCORE

#define CONTEXT_GAME_SCORE_100                      0
#define CONTEXT_GAME_SCORE_250                      1
#define CONTEXT_GAME_SCORE_350                      2
#define CONTEXT_GAME_SCORE_500                      3
#define CONTEXT_GAME_SCORE_750                      4
#define CONTEXT_GAME_SCORE_1000                     5
#define CONTEXT_GAME_SCORE_2000                     6
#define CONTEXT_GAME_SCORE_5000                     7
#define CONTEXT_GAME_SCORE_0                        8

// Values for CONTEXT_GAME_SPEED

#define CONTEXT_GAME_SPEED_SLOWEST                  0
#define CONTEXT_GAME_SPEED_SLOWER                   1
#define CONTEXT_GAME_SPEED_SLOW                     2
#define CONTEXT_GAME_SPEED_NORMAL                   3
#define CONTEXT_GAME_SPEED_FAST                     4
#define CONTEXT_GAME_SPEED_SUPERFAST                5

// Values for CONTEXT_INITIAL_HANDSIZE

#define CONTEXT_INITIAL_HANDSIZE_4                  0
#define CONTEXT_INITIAL_HANDSIZE_7                  1
#define CONTEXT_INITIAL_HANDSIZE_10                 2
#define CONTEXT_INITIAL_HANDSIZE_13                 3
#define CONTEXT_INITIAL_HANDSIZE_16                 4
#define CONTEXT_INITIAL_HANDSIZE_20                 5

// Values for CONTEXT_PROGRESSIVE_PENALTIES

#define CONTEXT_PROGRESSIVE_PENALTIES_OFF           0
#define CONTEXT_PROGRESSIVE_PENALTIES_ON            1

// Values for CONTEXT_SPECIALS

#define CONTEXT_SPECIALS_ON                         0
#define CONTEXT_SPECIALS_OFF                        1

// Values for CONTEXT_WILD_PARTOF_RUN

#define CONTEXT_WILD_PARTOF_RUN_OFF                 0
#define CONTEXT_WILD_PARTOF_RUN_ON                  1

// Values for CONTEXT_SCORING_TYPE

#define CONTEXT_SCORING_TYPE_TRADITIONAL            0
#define CONTEXT_SCORING_TYPE_RUNNING                1
#define CONTEXT_SCORING_TYPE_NO_SCORE               2

// Values for CONTEXT_CAMERA_ALLOWED

#define CONTEXT_CAMERA_ALLOWED_OFF                  0
#define CONTEXT_CAMERA_ALLOWED_ON                   1

// Values for CONTEXT_NETWORKSTATE

#define CONTEXT_NETWORKSTATE_LOBBY                  0
#define CONTEXT_NETWORKSTATE_GAMEPLAY               1

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_GAME_LOBBY_LIVE            0
#define CONTEXT_PRESENCE_GAME_MULTI_LIVE            1
#define CONTEXT_PRESENCE_GAME_MULTI_LOCAL           2
#define CONTEXT_PRESENCE_GAME_SINGLE                3
#define CONTEXT_PRESENCE_GAME_TRIAL                 4
#define CONTEXT_PRESENCE_PRESENCE_MATCHMAKING       5
#define CONTEXT_PRESENCE_PRESENCE_MENU              6
#define CONTEXT_PRESENCE_PRESENCE_NOTACTIVE         7

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_DEFAULT                   0

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_NAT                                0x10000001
#define PROPERTY_VERSION                            0x10000002
#define PROPERTY_WINS                               0x10000004
#define PROPERTY_LOSSES                             0x10000005
#define PROPERTY_SEAT_MAP                           0x1000000C
#define PROPERTY_SYNC_ID                            0x1000000D
#define PROPERTY_PEER_SYNC_ID                       0x1000000E
#define PROPERTY_LONGEST_RUN                        0x10000018
#define PROPERTY_CARDS_SCRAMBLE                     0x10000019
#define PROPERTY_CARDS_DRAW_TWO                     0x1000001A
#define PROPERTY_CARDS_REVERSE                      0x1000001B
#define PROPERTY_CARDS_SKIP                         0x1000001C
#define PROPERTY_CARDS_WILD                         0x1000001D
#define PROPERTY_CARDS_DRAW_FOUR                    0x1000001E
#define PROPERTY_SIX_CARD_RUN                       0x1000001F
#define PROPERTY_STANDARD_GAMES                     0x10000020
#define PROPERTY_PARTNER_GAMES                      0x10000021
#define PROPERTY_ELIMINATION_GAMES                  0x10000022
#define PROPERTY_CARDS_PLAYED                       0x10000023
#define PROPERTY_CARDS_DRAWN                        0x10000024
#define PROPERTY_POINTS                             0x10000026
#define PROPERTY_SCORE                              0x20000003
#define PROPERTY_RATING                             0x20000025
#define PROPERTY_SESSION_WINS                       0x20000027

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//

#define ACHIEVEMENT_PROFESSOR                       1
#define ACHIEVEMENT_UNO_BLASTER                     2
#define ACHIEVEMENT_SCRAMBLER                       3
#define ACHIEVEMENT_LAST_STANDING                   4
#define ACHIEVEMENT_SKIP_TO_PARTNER                 5
#define ACHIEVEMENT_FAST_BLAST                      6
#define ACHIEVEMENT_VARIETY                         7
#define ACHIEVEMENT_SOCIALIZE_R                     8
#define ACHIEVEMENT_UNO_BLAST_MASTER                9
#define ACHIEVEMENT_BIG_SCORER                      10
#define ACHIEVEMENT_RUNNER                          11
#define ACHIEVEMENT_RAINBOW_BLAST                   12

//
// AvatarAssetAward ids
//

#define AVATARASSETAWARD_SHIRT_POLO_SHOES_TRAINERS       1
#define AVATARASSETAWARD_HAT_HEADWRAP                    2
#define AVATARASSETAWARD_EARING_SMALL_HOOPS              3

//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_DEFAULT             0xFFFF0000

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_DEFAULT           0xFFFE0000

// Title defined leaderboards

#define STATS_VIEW_LEADERBOARD_OVERALL              1
#define STATS_VIEW_LEADERBOARD_OFFLINE              2
#define STATS_VIEW_LEADERBOARD_PLAYERMATCH          3
#define STATS_VIEW_LEADERBOARD_RANKED               4
#define STATS_VIEW_LEADERBOARD_RANKED_WEEKLY        5

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for LEADERBOARD_OVERALL

#define STATS_COLUMN_LEADERBOARD_OVERALL_WINS       1
#define STATS_COLUMN_LEADERBOARD_OVERALL_LOSSES     2
#define STATS_COLUMN_LEADERBOARD_OVERALL_LONGEST_RUN 3
#define STATS_COLUMN_LEADERBOARD_OVERALL_SCRAMBLE_CARDS 5
#define STATS_COLUMN_LEADERBOARD_OVERALL_DRAW_TWO_CARDS 6
#define STATS_COLUMN_LEADERBOARD_OVERALL_REVERSE_CARDS 7
#define STATS_COLUMN_LEADERBOARD_OVERALL_SKIP_CARDS 8
#define STATS_COLUMN_LEADERBOARD_OVERALL_WILD_CARDS 9
#define STATS_COLUMN_LEADERBOARD_OVERALL_DRAW_FOUR_CARDS 10
#define STATS_COLUMN_LEADERBOARD_OVERALL_SIX_CARDS_RUN 11
#define STATS_COLUMN_LEADERBOARD_OVERALL_STANDARD_GAMES 12
#define STATS_COLUMN_LEADERBOARD_OVERALL_PARTNER_GAMES 13
#define STATS_COLUMN_LEADERBOARD_OVERALL_ELIMINATION_GAMES 14
#define STATS_COLUMN_LEADERBOARD_OVERALL_CARDS_PLAYED 15
#define STATS_COLUMN_LEADERBOARD_OVERALL_CARDS_DRAWN 16
#define STATS_COLUMN_LEADERBOARD_OVERALL_POINTS     4

// Column ids for LEADERBOARD_OFFLINE

#define STATS_COLUMN_LEADERBOARD_OFFLINE_WINS       1
#define STATS_COLUMN_LEADERBOARD_OFFLINE_LOSSES     2
#define STATS_COLUMN_LEADERBOARD_OFFLINE_LONGEST_RUN 3
#define STATS_COLUMN_LEADERBOARD_OFFLINE_SCRAMBLE_CARDS 5
#define STATS_COLUMN_LEADERBOARD_OFFLINE_DRAW_TWO_CARDS 6
#define STATS_COLUMN_LEADERBOARD_OFFLINE_REVERSE_CARDS 7
#define STATS_COLUMN_LEADERBOARD_OFFLINE_SKIP_CARDS 8
#define STATS_COLUMN_LEADERBOARD_OFFLINE_WILD_CARDS 9
#define STATS_COLUMN_LEADERBOARD_OFFLINE_DRAW_FOUR_CARDS 10
#define STATS_COLUMN_LEADERBOARD_OFFLINE_SIX_CARD_RUN 11
#define STATS_COLUMN_LEADERBOARD_OFFLINE_STANDARD_GAMES 12
#define STATS_COLUMN_LEADERBOARD_OFFLINE_PARTNER_GAMES 13
#define STATS_COLUMN_LEADERBOARD_OFFLINE_ELIMINATION_GAMES 14
#define STATS_COLUMN_LEADERBOARD_OFFLINE_CARDS_PLAYED 15
#define STATS_COLUMN_LEADERBOARD_OFFLINE_CARDS_DRAWN 16
#define STATS_COLUMN_LEADERBOARD_OFFLINE_POINTS     4

// Column ids for LEADERBOARD_PLAYERMATCH

#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_WINS   1
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_LOSSES 2
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_LONGEST_RUN 3
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_SCRAMBLE_CARDS 5
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_DRAW_TWO_CARDS 6
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_REVERSE_CARDS 7
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_SKIP_CARDS 8
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_WILD_CARDS 9
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_DRAW_FOUR_CARDS 10
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_SIX_CARDS_RUN 11
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_STANDARD_GAMES 12
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_PARTNER_GAMES 13
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_ELIMINATION_GAMES 14
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_CARDS_PLAYED 15
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_CARDS_DRAWN 16
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_POINTS 4

// Column ids for LEADERBOARD_RANKED

#define STATS_COLUMN_LEADERBOARD_RANKED_WINS        1
#define STATS_COLUMN_LEADERBOARD_RANKED_LOSSES      2
#define STATS_COLUMN_LEADERBOARD_RANKED_LONGEST_RUN 3
#define STATS_COLUMN_LEADERBOARD_RANKED_SCRAMBLE_CARDS 5
#define STATS_COLUMN_LEADERBOARD_RANKED_DRAW_TWO_CARDS 6
#define STATS_COLUMN_LEADERBOARD_RANKED_REVERSE_CARDS 7
#define STATS_COLUMN_LEADERBOARD_RANKED_SKIP_CARDS  8
#define STATS_COLUMN_LEADERBOARD_RANKED_WILD_CARDS  9
#define STATS_COLUMN_LEADERBOARD_RANKED_DRAW_FOUR_CARDS 10
#define STATS_COLUMN_LEADERBOARD_RANKED_SIX_CARDS_RUN 11
#define STATS_COLUMN_LEADERBOARD_RANKED_STANDARD_GAMES 12
#define STATS_COLUMN_LEADERBOARD_RANKED_PARTNER_GAMES 13
#define STATS_COLUMN_LEADERBOARD_RANKED_ELIMINATION_GAMES 14
#define STATS_COLUMN_LEADERBOARD_RANKED_CARDS_PLAYED 15
#define STATS_COLUMN_LEADERBOARD_RANKED_CARDS_DRAWN 16
#define STATS_COLUMN_LEADERBOARD_RANKED_POINTS      4

// Column ids for LEADERBOARD_RANKED_WEEKLY

#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_WINS 1
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_LOSSES 2
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_LONGEST_RUN 3
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_SCRAMBLE_CARDS 5
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_DRAW_TWO_CARDS 6
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_REVERSE_CARDS 7
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_SKIP_CARDS 8
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_WILD_CARDS 9
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_DRAW_FOUR_CARDS 10
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_SIX_CARDS_RUN 11
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_STANDARD_GAMES 12
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_PARTNER_GAMES 13
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_ELIMINATION_GAMES 14
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_CARDS_PLAYED 15
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_CARDS_DRAWN 16
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_POINTS 4

//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//

#define SESSION_MATCH_QUERY_DEFAULTQUERY            0

//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//



#ifdef __cplusplus
}
#endif

#endif // __UNO_RUSH__SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\SuitesData\SPACFunctional\AvatarItems\Positive\Arcade\Arcade-4-Sub-expected.spa.h ===
////////////////////////////////////////////////////////////////////
//
// Arcade-4-Sub.spa.h
//
// Auto-generated on {*}
// XLAST project version {*}
// SPA Compiler version {*}
//
////////////////////////////////////////////////////////////////////

#ifndef __UNO_RUSH__SPA_H__
#define __UNO_RUSH__SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_UNO_RUSH_                           0x5841089A

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//

#define CONTEXT_PLACE                               0
#define CONTEXT_GAME_STRUCTURE                      1
#define CONTEXT_GAME_BUTTON                         2
#define CONTEXT_CALL_UNO                            3
#define CONTEXT_DRAW_TYPE                           4
#define CONTEXT_GAME_SCORE                          5
#define CONTEXT_GAME_SPEED                          6
#define CONTEXT_INITIAL_HANDSIZE                    7
#define CONTEXT_PROGRESSIVE_PENALTIES               8
#define CONTEXT_SPECIALS                            10
#define CONTEXT_WILD_PARTOF_RUN                     11
#define CONTEXT_SCORING_TYPE                        12
#define CONTEXT_CAMERA_ALLOWED                      13
#define CONTEXT_NETWORKSTATE                        14

//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for CONTEXT_PLACE

#define CONTEXT_PLACE_PLACE_FIRST                   0
#define CONTEXT_PLACE_PLACE_SECOND                  1
#define CONTEXT_PLACE_PLACE_THIRD                   2
#define CONTEXT_PLACE_PLACE_NONE                    3

// Values for CONTEXT_GAME_STRUCTURE

#define CONTEXT_GAME_STRUCTURE_STANDARD_UNO         0
#define CONTEXT_GAME_STRUCTURE_PARTNER_UNO          1
#define CONTEXT_GAME_STRUCTURE_ELIMINATION_UNO      2

// Values for CONTEXT_GAME_BUTTON

#define CONTEXT_GAME_BUTTON_BUTTON_A                0
#define CONTEXT_GAME_BUTTON_BUTTON_B                1

// Values for CONTEXT_CALL_UNO

#define CONTEXT_CALL_UNO_OFF                        0
#define CONTEXT_CALL_UNO_ON                         1

// Values for CONTEXT_DRAW_TYPE

#define CONTEXT_DRAW_TYPE_DRAW_AND_PLAY             0
#define CONTEXT_DRAW_TYPE_DRAW_ONLY                 1
#define CONTEXT_DRAW_TYPE_DRAW_UNTIL_PLAY           2

// Values for CONTEXT_GAME_SCORE

#define CONTEXT_GAME_SCORE_100                      0
#define CONTEXT_GAME_SCORE_250                      1
#define CONTEXT_GAME_SCORE_350                      2
#define CONTEXT_GAME_SCORE_500                      3
#define CONTEXT_GAME_SCORE_750                      4
#define CONTEXT_GAME_SCORE_1000                     5
#define CONTEXT_GAME_SCORE_2000                     6
#define CONTEXT_GAME_SCORE_5000                     7
#define CONTEXT_GAME_SCORE_0                        8

// Values for CONTEXT_GAME_SPEED

#define CONTEXT_GAME_SPEED_SLOWEST                  0
#define CONTEXT_GAME_SPEED_SLOWER                   1
#define CONTEXT_GAME_SPEED_SLOW                     2
#define CONTEXT_GAME_SPEED_NORMAL                   3
#define CONTEXT_GAME_SPEED_FAST                     4
#define CONTEXT_GAME_SPEED_SUPERFAST                5

// Values for CONTEXT_INITIAL_HANDSIZE

#define CONTEXT_INITIAL_HANDSIZE_4                  0
#define CONTEXT_INITIAL_HANDSIZE_7                  1
#define CONTEXT_INITIAL_HANDSIZE_10                 2
#define CONTEXT_INITIAL_HANDSIZE_13                 3
#define CONTEXT_INITIAL_HANDSIZE_16                 4
#define CONTEXT_INITIAL_HANDSIZE_20                 5

// Values for CONTEXT_PROGRESSIVE_PENALTIES

#define CONTEXT_PROGRESSIVE_PENALTIES_OFF           0
#define CONTEXT_PROGRESSIVE_PENALTIES_ON            1

// Values for CONTEXT_SPECIALS

#define CONTEXT_SPECIALS_ON                         0
#define CONTEXT_SPECIALS_OFF                        1

// Values for CONTEXT_WILD_PARTOF_RUN

#define CONTEXT_WILD_PARTOF_RUN_OFF                 0
#define CONTEXT_WILD_PARTOF_RUN_ON                  1

// Values for CONTEXT_SCORING_TYPE

#define CONTEXT_SCORING_TYPE_TRADITIONAL            0
#define CONTEXT_SCORING_TYPE_RUNNING                1
#define CONTEXT_SCORING_TYPE_NO_SCORE               2

// Values for CONTEXT_CAMERA_ALLOWED

#define CONTEXT_CAMERA_ALLOWED_OFF                  0
#define CONTEXT_CAMERA_ALLOWED_ON                   1

// Values for CONTEXT_NETWORKSTATE

#define CONTEXT_NETWORKSTATE_LOBBY                  0
#define CONTEXT_NETWORKSTATE_GAMEPLAY               1

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_GAME_LOBBY_LIVE            0
#define CONTEXT_PRESENCE_GAME_MULTI_LIVE            1
#define CONTEXT_PRESENCE_GAME_MULTI_LOCAL           2
#define CONTEXT_PRESENCE_GAME_SINGLE                3
#define CONTEXT_PRESENCE_GAME_TRIAL                 4
#define CONTEXT_PRESENCE_PRESENCE_MATCHMAKING       5
#define CONTEXT_PRESENCE_PRESENCE_MENU              6
#define CONTEXT_PRESENCE_PRESENCE_NOTACTIVE         7

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_DEFAULT                   0

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_NAT                                0x10000001
#define PROPERTY_VERSION                            0x10000002
#define PROPERTY_WINS                               0x10000004
#define PROPERTY_LOSSES                             0x10000005
#define PROPERTY_SEAT_MAP                           0x1000000C
#define PROPERTY_SYNC_ID                            0x1000000D
#define PROPERTY_PEER_SYNC_ID                       0x1000000E
#define PROPERTY_LONGEST_RUN                        0x10000018
#define PROPERTY_CARDS_SCRAMBLE                     0x10000019
#define PROPERTY_CARDS_DRAW_TWO                     0x1000001A
#define PROPERTY_CARDS_REVERSE                      0x1000001B
#define PROPERTY_CARDS_SKIP                         0x1000001C
#define PROPERTY_CARDS_WILD                         0x1000001D
#define PROPERTY_CARDS_DRAW_FOUR                    0x1000001E
#define PROPERTY_SIX_CARD_RUN                       0x1000001F
#define PROPERTY_STANDARD_GAMES                     0x10000020
#define PROPERTY_PARTNER_GAMES                      0x10000021
#define PROPERTY_ELIMINATION_GAMES                  0x10000022
#define PROPERTY_CARDS_PLAYED                       0x10000023
#define PROPERTY_CARDS_DRAWN                        0x10000024
#define PROPERTY_POINTS                             0x10000026
#define PROPERTY_SCORE                              0x20000003
#define PROPERTY_RATING                             0x20000025
#define PROPERTY_SESSION_WINS                       0x20000027

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//

#define ACHIEVEMENT_PROFESSOR                       1
#define ACHIEVEMENT_UNO_BLASTER                     2
#define ACHIEVEMENT_SCRAMBLER                       3
#define ACHIEVEMENT_LAST_STANDING                   4
#define ACHIEVEMENT_SKIP_TO_PARTNER                 5
#define ACHIEVEMENT_FAST_BLAST                      6
#define ACHIEVEMENT_VARIETY                         7
#define ACHIEVEMENT_SOCIALIZE_R                     8
#define ACHIEVEMENT_UNO_BLAST_MASTER                9
#define ACHIEVEMENT_BIG_SCORER                      10
#define ACHIEVEMENT_RUNNER                          11
#define ACHIEVEMENT_RAINBOW_BLAST                   12

//
// AvatarAssetAward ids
//

#define AVATARASSETAWARD_SHIRT_HOODIE_COAT               1
#define AVATARASSETAWARD_SHIRT_SPORTS_TEE_SHORT_SLEEVE_SHIRT 2
#define AVATARASSETAWARD_SHIRT_NONE                      3
#define AVATARASSETAWARD_SHOES_SANDALS_PUMPS             4
#define AVATARASSETAWARD_SHOES_COSTUME_SHORT_BOOTS       5
#define AVATARASSETAWARD_CARRYABLE                       6
#define AVATARASSETAWARD_EARING_DANGLERS_SMALL_HOOPS     7

//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_DEFAULT             0xFFFF0000

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_DEFAULT           0xFFFE0000

// Title defined leaderboards

#define STATS_VIEW_LEADERBOARD_OVERALL              1
#define STATS_VIEW_LEADERBOARD_OFFLINE              2
#define STATS_VIEW_LEADERBOARD_PLAYERMATCH          3
#define STATS_VIEW_LEADERBOARD_RANKED               4
#define STATS_VIEW_LEADERBOARD_RANKED_WEEKLY        5

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for LEADERBOARD_OVERALL

#define STATS_COLUMN_LEADERBOARD_OVERALL_WINS       1
#define STATS_COLUMN_LEADERBOARD_OVERALL_LOSSES     2
#define STATS_COLUMN_LEADERBOARD_OVERALL_LONGEST_RUN 3
#define STATS_COLUMN_LEADERBOARD_OVERALL_SCRAMBLE_CARDS 5
#define STATS_COLUMN_LEADERBOARD_OVERALL_DRAW_TWO_CARDS 6
#define STATS_COLUMN_LEADERBOARD_OVERALL_REVERSE_CARDS 7
#define STATS_COLUMN_LEADERBOARD_OVERALL_SKIP_CARDS 8
#define STATS_COLUMN_LEADERBOARD_OVERALL_WILD_CARDS 9
#define STATS_COLUMN_LEADERBOARD_OVERALL_DRAW_FOUR_CARDS 10
#define STATS_COLUMN_LEADERBOARD_OVERALL_SIX_CARDS_RUN 11
#define STATS_COLUMN_LEADERBOARD_OVERALL_STANDARD_GAMES 12
#define STATS_COLUMN_LEADERBOARD_OVERALL_PARTNER_GAMES 13
#define STATS_COLUMN_LEADERBOARD_OVERALL_ELIMINATION_GAMES 14
#define STATS_COLUMN_LEADERBOARD_OVERALL_CARDS_PLAYED 15
#define STATS_COLUMN_LEADERBOARD_OVERALL_CARDS_DRAWN 16
#define STATS_COLUMN_LEADERBOARD_OVERALL_POINTS     4

// Column ids for LEADERBOARD_OFFLINE

#define STATS_COLUMN_LEADERBOARD_OFFLINE_WINS       1
#define STATS_COLUMN_LEADERBOARD_OFFLINE_LOSSES     2
#define STATS_COLUMN_LEADERBOARD_OFFLINE_LONGEST_RUN 3
#define STATS_COLUMN_LEADERBOARD_OFFLINE_SCRAMBLE_CARDS 5
#define STATS_COLUMN_LEADERBOARD_OFFLINE_DRAW_TWO_CARDS 6
#define STATS_COLUMN_LEADERBOARD_OFFLINE_REVERSE_CARDS 7
#define STATS_COLUMN_LEADERBOARD_OFFLINE_SKIP_CARDS 8
#define STATS_COLUMN_LEADERBOARD_OFFLINE_WILD_CARDS 9
#define STATS_COLUMN_LEADERBOARD_OFFLINE_DRAW_FOUR_CARDS 10
#define STATS_COLUMN_LEADERBOARD_OFFLINE_SIX_CARD_RUN 11
#define STATS_COLUMN_LEADERBOARD_OFFLINE_STANDARD_GAMES 12
#define STATS_COLUMN_LEADERBOARD_OFFLINE_PARTNER_GAMES 13
#define STATS_COLUMN_LEADERBOARD_OFFLINE_ELIMINATION_GAMES 14
#define STATS_COLUMN_LEADERBOARD_OFFLINE_CARDS_PLAYED 15
#define STATS_COLUMN_LEADERBOARD_OFFLINE_CARDS_DRAWN 16
#define STATS_COLUMN_LEADERBOARD_OFFLINE_POINTS     4

// Column ids for LEADERBOARD_PLAYERMATCH

#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_WINS   1
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_LOSSES 2
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_LONGEST_RUN 3
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_SCRAMBLE_CARDS 5
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_DRAW_TWO_CARDS 6
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_REVERSE_CARDS 7
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_SKIP_CARDS 8
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_WILD_CARDS 9
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_DRAW_FOUR_CARDS 10
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_SIX_CARDS_RUN 11
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_STANDARD_GAMES 12
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_PARTNER_GAMES 13
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_ELIMINATION_GAMES 14
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_CARDS_PLAYED 15
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_CARDS_DRAWN 16
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_POINTS 4

// Column ids for LEADERBOARD_RANKED

#define STATS_COLUMN_LEADERBOARD_RANKED_WINS        1
#define STATS_COLUMN_LEADERBOARD_RANKED_LOSSES      2
#define STATS_COLUMN_LEADERBOARD_RANKED_LONGEST_RUN 3
#define STATS_COLUMN_LEADERBOARD_RANKED_SCRAMBLE_CARDS 5
#define STATS_COLUMN_LEADERBOARD_RANKED_DRAW_TWO_CARDS 6
#define STATS_COLUMN_LEADERBOARD_RANKED_REVERSE_CARDS 7
#define STATS_COLUMN_LEADERBOARD_RANKED_SKIP_CARDS  8
#define STATS_COLUMN_LEADERBOARD_RANKED_WILD_CARDS  9
#define STATS_COLUMN_LEADERBOARD_RANKED_DRAW_FOUR_CARDS 10
#define STATS_COLUMN_LEADERBOARD_RANKED_SIX_CARDS_RUN 11
#define STATS_COLUMN_LEADERBOARD_RANKED_STANDARD_GAMES 12
#define STATS_COLUMN_LEADERBOARD_RANKED_PARTNER_GAMES 13
#define STATS_COLUMN_LEADERBOARD_RANKED_ELIMINATION_GAMES 14
#define STATS_COLUMN_LEADERBOARD_RANKED_CARDS_PLAYED 15
#define STATS_COLUMN_LEADERBOARD_RANKED_CARDS_DRAWN 16
#define STATS_COLUMN_LEADERBOARD_RANKED_POINTS      4

// Column ids for LEADERBOARD_RANKED_WEEKLY

#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_WINS 1
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_LOSSES 2
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_LONGEST_RUN 3
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_SCRAMBLE_CARDS 5
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_DRAW_TWO_CARDS 6
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_REVERSE_CARDS 7
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_SKIP_CARDS 8
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_WILD_CARDS 9
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_DRAW_FOUR_CARDS 10
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_SIX_CARDS_RUN 11
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_STANDARD_GAMES 12
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_PARTNER_GAMES 13
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_ELIMINATION_GAMES 14
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_CARDS_PLAYED 15
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_CARDS_DRAWN 16
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_POINTS 4

//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//

#define SESSION_MATCH_QUERY_DEFAULTQUERY            0

//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//



#ifdef __cplusplus
}
#endif

#endif // __UNO_RUSH__SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\SuitesData\SPACFunctional\AvatarItems\Positive\Arcade\NeutralNeutral1-expected.h ===
////////////////////////////////////////////////////////////////////
//
// NeutralNeutral1.spa.h
//
// Auto-generated on {*}
// XLAST project version {*}
// SPA Compiler version {*}
//
////////////////////////////////////////////////////////////////////

#ifndef __UNO_RUSH__SPA_H__
#define __UNO_RUSH__SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_UNO_RUSH_                           0x5841089A

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//

#define CONTEXT_PLACE                               0
#define CONTEXT_GAME_STRUCTURE                      1
#define CONTEXT_GAME_BUTTON                         2
#define CONTEXT_CALL_UNO                            3
#define CONTEXT_DRAW_TYPE                           4
#define CONTEXT_GAME_SCORE                          5
#define CONTEXT_GAME_SPEED                          6
#define CONTEXT_INITIAL_HANDSIZE                    7
#define CONTEXT_PROGRESSIVE_PENALTIES               8
#define CONTEXT_SPECIALS                            10
#define CONTEXT_WILD_PARTOF_RUN                     11
#define CONTEXT_SCORING_TYPE                        12
#define CONTEXT_CAMERA_ALLOWED                      13
#define CONTEXT_NETWORKSTATE                        14

//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for CONTEXT_PLACE

#define CONTEXT_PLACE_PLACE_FIRST                   0
#define CONTEXT_PLACE_PLACE_SECOND                  1
#define CONTEXT_PLACE_PLACE_THIRD                   2
#define CONTEXT_PLACE_PLACE_NONE                    3

// Values for CONTEXT_GAME_STRUCTURE

#define CONTEXT_GAME_STRUCTURE_STANDARD_UNO         0
#define CONTEXT_GAME_STRUCTURE_PARTNER_UNO          1
#define CONTEXT_GAME_STRUCTURE_ELIMINATION_UNO      2

// Values for CONTEXT_GAME_BUTTON

#define CONTEXT_GAME_BUTTON_BUTTON_A                0
#define CONTEXT_GAME_BUTTON_BUTTON_B                1

// Values for CONTEXT_CALL_UNO

#define CONTEXT_CALL_UNO_OFF                        0
#define CONTEXT_CALL_UNO_ON                         1

// Values for CONTEXT_DRAW_TYPE

#define CONTEXT_DRAW_TYPE_DRAW_AND_PLAY             0
#define CONTEXT_DRAW_TYPE_DRAW_ONLY                 1
#define CONTEXT_DRAW_TYPE_DRAW_UNTIL_PLAY           2

// Values for CONTEXT_GAME_SCORE

#define CONTEXT_GAME_SCORE_100                      0
#define CONTEXT_GAME_SCORE_250                      1
#define CONTEXT_GAME_SCORE_350                      2
#define CONTEXT_GAME_SCORE_500                      3
#define CONTEXT_GAME_SCORE_750                      4
#define CONTEXT_GAME_SCORE_1000                     5
#define CONTEXT_GAME_SCORE_2000                     6
#define CONTEXT_GAME_SCORE_5000                     7
#define CONTEXT_GAME_SCORE_0                        8

// Values for CONTEXT_GAME_SPEED

#define CONTEXT_GAME_SPEED_SLOWEST                  0
#define CONTEXT_GAME_SPEED_SLOWER                   1
#define CONTEXT_GAME_SPEED_SLOW                     2
#define CONTEXT_GAME_SPEED_NORMAL                   3
#define CONTEXT_GAME_SPEED_FAST                     4
#define CONTEXT_GAME_SPEED_SUPERFAST                5

// Values for CONTEXT_INITIAL_HANDSIZE

#define CONTEXT_INITIAL_HANDSIZE_4                  0
#define CONTEXT_INITIAL_HANDSIZE_7                  1
#define CONTEXT_INITIAL_HANDSIZE_10                 2
#define CONTEXT_INITIAL_HANDSIZE_13                 3
#define CONTEXT_INITIAL_HANDSIZE_16                 4
#define CONTEXT_INITIAL_HANDSIZE_20                 5

// Values for CONTEXT_PROGRESSIVE_PENALTIES

#define CONTEXT_PROGRESSIVE_PENALTIES_OFF           0
#define CONTEXT_PROGRESSIVE_PENALTIES_ON            1

// Values for CONTEXT_SPECIALS

#define CONTEXT_SPECIALS_ON                         0
#define CONTEXT_SPECIALS_OFF                        1

// Values for CONTEXT_WILD_PARTOF_RUN

#define CONTEXT_WILD_PARTOF_RUN_OFF                 0
#define CONTEXT_WILD_PARTOF_RUN_ON                  1

// Values for CONTEXT_SCORING_TYPE

#define CONTEXT_SCORING_TYPE_TRADITIONAL            0
#define CONTEXT_SCORING_TYPE_RUNNING                1
#define CONTEXT_SCORING_TYPE_NO_SCORE               2

// Values for CONTEXT_CAMERA_ALLOWED

#define CONTEXT_CAMERA_ALLOWED_OFF                  0
#define CONTEXT_CAMERA_ALLOWED_ON                   1

// Values for CONTEXT_NETWORKSTATE

#define CONTEXT_NETWORKSTATE_LOBBY                  0
#define CONTEXT_NETWORKSTATE_GAMEPLAY               1

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_GAME_LOBBY_LIVE            0
#define CONTEXT_PRESENCE_GAME_MULTI_LIVE            1
#define CONTEXT_PRESENCE_GAME_MULTI_LOCAL           2
#define CONTEXT_PRESENCE_GAME_SINGLE                3
#define CONTEXT_PRESENCE_GAME_TRIAL                 4
#define CONTEXT_PRESENCE_PRESENCE_MATCHMAKING       5
#define CONTEXT_PRESENCE_PRESENCE_MENU              6
#define CONTEXT_PRESENCE_PRESENCE_NOTACTIVE         7

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_DEFAULT                   0

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_NAT                                0x10000001
#define PROPERTY_VERSION                            0x10000002
#define PROPERTY_WINS                               0x10000004
#define PROPERTY_LOSSES                             0x10000005
#define PROPERTY_SEAT_MAP                           0x1000000C
#define PROPERTY_SYNC_ID                            0x1000000D
#define PROPERTY_PEER_SYNC_ID                       0x1000000E
#define PROPERTY_LONGEST_RUN                        0x10000018
#define PROPERTY_CARDS_SCRAMBLE                     0x10000019
#define PROPERTY_CARDS_DRAW_TWO                     0x1000001A
#define PROPERTY_CARDS_REVERSE                      0x1000001B
#define PROPERTY_CARDS_SKIP                         0x1000001C
#define PROPERTY_CARDS_WILD                         0x1000001D
#define PROPERTY_CARDS_DRAW_FOUR                    0x1000001E
#define PROPERTY_SIX_CARD_RUN                       0x1000001F
#define PROPERTY_STANDARD_GAMES                     0x10000020
#define PROPERTY_PARTNER_GAMES                      0x10000021
#define PROPERTY_ELIMINATION_GAMES                  0x10000022
#define PROPERTY_CARDS_PLAYED                       0x10000023
#define PROPERTY_CARDS_DRAWN                        0x10000024
#define PROPERTY_POINTS                             0x10000026
#define PROPERTY_SCORE                              0x20000003
#define PROPERTY_RATING                             0x20000025
#define PROPERTY_SESSION_WINS                       0x20000027

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//

#define ACHIEVEMENT_PROFESSOR                       1
#define ACHIEVEMENT_UNO_BLASTER                     2
#define ACHIEVEMENT_SCRAMBLER                       3
#define ACHIEVEMENT_LAST_STANDING                   4
#define ACHIEVEMENT_SKIP_TO_PARTNER                 5
#define ACHIEVEMENT_FAST_BLAST                      6
#define ACHIEVEMENT_VARIETY                         7
#define ACHIEVEMENT_SOCIALIZE_R                     8
#define ACHIEVEMENT_UNO_BLAST_MASTER                9
#define ACHIEVEMENT_BIG_SCORER                      10
#define ACHIEVEMENT_RUNNER                          11
#define ACHIEVEMENT_RAINBOW_BLAST                   12

//
// AvatarAssetAward ids
//

#define AVATARASSETAWARD_NEUTRALNEUTRAL                  7

//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_DEFAULT             0xFFFF0000

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_DEFAULT           0xFFFE0000

// Title defined leaderboards

#define STATS_VIEW_LEADERBOARD_OVERALL              1
#define STATS_VIEW_LEADERBOARD_OFFLINE              2
#define STATS_VIEW_LEADERBOARD_PLAYERMATCH          3
#define STATS_VIEW_LEADERBOARD_RANKED               4
#define STATS_VIEW_LEADERBOARD_RANKED_WEEKLY        5

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for LEADERBOARD_OVERALL

#define STATS_COLUMN_LEADERBOARD_OVERALL_WINS       1
#define STATS_COLUMN_LEADERBOARD_OVERALL_LOSSES     2
#define STATS_COLUMN_LEADERBOARD_OVERALL_LONGEST_RUN 3
#define STATS_COLUMN_LEADERBOARD_OVERALL_SCRAMBLE_CARDS 5
#define STATS_COLUMN_LEADERBOARD_OVERALL_DRAW_TWO_CARDS 6
#define STATS_COLUMN_LEADERBOARD_OVERALL_REVERSE_CARDS 7
#define STATS_COLUMN_LEADERBOARD_OVERALL_SKIP_CARDS 8
#define STATS_COLUMN_LEADERBOARD_OVERALL_WILD_CARDS 9
#define STATS_COLUMN_LEADERBOARD_OVERALL_DRAW_FOUR_CARDS 10
#define STATS_COLUMN_LEADERBOARD_OVERALL_SIX_CARDS_RUN 11
#define STATS_COLUMN_LEADERBOARD_OVERALL_STANDARD_GAMES 12
#define STATS_COLUMN_LEADERBOARD_OVERALL_PARTNER_GAMES 13
#define STATS_COLUMN_LEADERBOARD_OVERALL_ELIMINATION_GAMES 14
#define STATS_COLUMN_LEADERBOARD_OVERALL_CARDS_PLAYED 15
#define STATS_COLUMN_LEADERBOARD_OVERALL_CARDS_DRAWN 16
#define STATS_COLUMN_LEADERBOARD_OVERALL_POINTS     4

// Column ids for LEADERBOARD_OFFLINE

#define STATS_COLUMN_LEADERBOARD_OFFLINE_WINS       1
#define STATS_COLUMN_LEADERBOARD_OFFLINE_LOSSES     2
#define STATS_COLUMN_LEADERBOARD_OFFLINE_LONGEST_RUN 3
#define STATS_COLUMN_LEADERBOARD_OFFLINE_SCRAMBLE_CARDS 5
#define STATS_COLUMN_LEADERBOARD_OFFLINE_DRAW_TWO_CARDS 6
#define STATS_COLUMN_LEADERBOARD_OFFLINE_REVERSE_CARDS 7
#define STATS_COLUMN_LEADERBOARD_OFFLINE_SKIP_CARDS 8
#define STATS_COLUMN_LEADERBOARD_OFFLINE_WILD_CARDS 9
#define STATS_COLUMN_LEADERBOARD_OFFLINE_DRAW_FOUR_CARDS 10
#define STATS_COLUMN_LEADERBOARD_OFFLINE_SIX_CARD_RUN 11
#define STATS_COLUMN_LEADERBOARD_OFFLINE_STANDARD_GAMES 12
#define STATS_COLUMN_LEADERBOARD_OFFLINE_PARTNER_GAMES 13
#define STATS_COLUMN_LEADERBOARD_OFFLINE_ELIMINATION_GAMES 14
#define STATS_COLUMN_LEADERBOARD_OFFLINE_CARDS_PLAYED 15
#define STATS_COLUMN_LEADERBOARD_OFFLINE_CARDS_DRAWN 16
#define STATS_COLUMN_LEADERBOARD_OFFLINE_POINTS     4

// Column ids for LEADERBOARD_PLAYERMATCH

#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_WINS   1
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_LOSSES 2
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_LONGEST_RUN 3
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_SCRAMBLE_CARDS 5
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_DRAW_TWO_CARDS 6
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_REVERSE_CARDS 7
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_SKIP_CARDS 8
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_WILD_CARDS 9
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_DRAW_FOUR_CARDS 10
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_SIX_CARDS_RUN 11
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_STANDARD_GAMES 12
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_PARTNER_GAMES 13
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_ELIMINATION_GAMES 14
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_CARDS_PLAYED 15
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_CARDS_DRAWN 16
#define STATS_COLUMN_LEADERBOARD_PLAYERMATCH_POINTS 4

// Column ids for LEADERBOARD_RANKED

#define STATS_COLUMN_LEADERBOARD_RANKED_WINS        1
#define STATS_COLUMN_LEADERBOARD_RANKED_LOSSES      2
#define STATS_COLUMN_LEADERBOARD_RANKED_LONGEST_RUN 3
#define STATS_COLUMN_LEADERBOARD_RANKED_SCRAMBLE_CARDS 5
#define STATS_COLUMN_LEADERBOARD_RANKED_DRAW_TWO_CARDS 6
#define STATS_COLUMN_LEADERBOARD_RANKED_REVERSE_CARDS 7
#define STATS_COLUMN_LEADERBOARD_RANKED_SKIP_CARDS  8
#define STATS_COLUMN_LEADERBOARD_RANKED_WILD_CARDS  9
#define STATS_COLUMN_LEADERBOARD_RANKED_DRAW_FOUR_CARDS 10
#define STATS_COLUMN_LEADERBOARD_RANKED_SIX_CARDS_RUN 11
#define STATS_COLUMN_LEADERBOARD_RANKED_STANDARD_GAMES 12
#define STATS_COLUMN_LEADERBOARD_RANKED_PARTNER_GAMES 13
#define STATS_COLUMN_LEADERBOARD_RANKED_ELIMINATION_GAMES 14
#define STATS_COLUMN_LEADERBOARD_RANKED_CARDS_PLAYED 15
#define STATS_COLUMN_LEADERBOARD_RANKED_CARDS_DRAWN 16
#define STATS_COLUMN_LEADERBOARD_RANKED_POINTS      4

// Column ids for LEADERBOARD_RANKED_WEEKLY

#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_WINS 1
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_LOSSES 2
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_LONGEST_RUN 3
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_SCRAMBLE_CARDS 5
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_DRAW_TWO_CARDS 6
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_REVERSE_CARDS 7
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_SKIP_CARDS 8
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_WILD_CARDS 9
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_DRAW_FOUR_CARDS 10
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_SIX_CARDS_RUN 11
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_STANDARD_GAMES 12
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_PARTNER_GAMES 13
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_ELIMINATION_GAMES 14
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_CARDS_PLAYED 15
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_CARDS_DRAWN 16
#define STATS_COLUMN_LEADERBOARD_RANKED_WEEKLY_POINTS 4

//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//

#define SESSION_MATCH_QUERY_DEFAULTQUERY            0

//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//



#ifdef __cplusplus
}
#endif

#endif // __UNO_RUSH__SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\SuitesData\SPACFunctional\AvatarItems\Positive\FullGame\FullGame-All-expected.spa.h ===
////////////////////////////////////////////////////////////////////
//
// FullGame-All.spa.h
//
// Auto-generated on {*}
// XLAST project version {*}
// SPA Compiler version {*}
//
////////////////////////////////////////////////////////////////////

#ifndef __GUITAR_HERO_WORLD_TOUR_SPA_H__
#define __GUITAR_HERO_WORLD_TOUR_SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_GUITAR_HERO_WORLD_TOUR              0x4156081A

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//

#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY          0
#define CONTEXT_SEARCH_GH3_SONG_COUNT               1
#define CONTEXT_SEARCH_GH3_VENUE                    2
#define CONTEXT_SEARCH_GH3_GAME_MODE                3
#define CONTEXT_GH4_SONGS                           78
#define CONTEXT_SEARCH_GH4_HOSTING_STATE            79
#define CONTEXT_SEARCH_GH4_INSTRUMENTS              80

//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for CONTEXT_SEARCH_GH3_SONG_DIFFICULTY

#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_EASY 0
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_MEDIUM 1
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_HARD 2
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_EXPERT 3
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_BEGINNER 4

// Values for CONTEXT_SEARCH_GH3_SONG_COUNT

#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_1 0
#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_3 1
#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_5 2
#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_7 3

// Values for CONTEXT_SEARCH_GH3_VENUE

#define CONTEXT_SEARCH_GH3_VENUE_SEARCH_CON_VENUE_TEMP 0

// Values for CONTEXT_SEARCH_GH3_GAME_MODE

#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_FACEOFF_GUITAR 0
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_PRO_FACEOFF_GUITAR 1
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_BATTLE_GUITAR 2
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_2V2_PRO_FACEOFF_GUITAR 3
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_PRO_FACEOFF_DRUMS 4
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_BATTLE_DRUMS 5
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_BAND_FACEOFF 6
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_BAND_COOP 7
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_GUITAR_COOP 8
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_BAND_CAREER 9
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_FACEOFF_BASS 10
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_PRO_FACEOFF_BASS 11
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_EXTRA_1   12
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_EXTRA_2   13
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_EXTRA_3   14

// Values for CONTEXT_GH4_SONGS

#define CONTEXT_GH4_SONGS_SONG_ABOUTAGIRL           0
#define CONTEXT_GH4_SONGS_SONG_AGGRO                1
#define CONTEXT_GH4_SONGS_SONG_AMERICANWOMAN        2
#define CONTEXT_GH4_SONGS_SONG_ANTISOCIAL           3
#define CONTEXT_GH4_SONGS_SONG_AREYOUGONNAGOMYWAY   4
#define CONTEXT_GH4_SONGS_SONG_ASSASSIN             5
#define CONTEXT_GH4_SONGS_SONG_BANDONTHERUN         6
#define CONTEXT_GH4_SONGS_SONG_BEATIT               7
#define CONTEXT_GH4_SONGS_SONG_BEAUTIFULDISASTER    8
#define CONTEXT_GH4_SONGS_SONG_BOSS_TED             9
#define CONTEXT_GH4_SONGS_SONG_BOSS_WYLDE           10
#define CONTEXT_GH4_SONGS_SONG_BYOB                 11
#define CONTEXT_GH4_SONGS_SONG_CRAZYTRAIN           12
#define CONTEXT_GH4_SONGS_SONG_DAMMIT               13
#define CONTEXT_GH4_SONGS_SONG_DEMOLITIONMAN        14
#define CONTEXT_GH4_SONGS_SONG_ESCUELADECALOR       15
#define CONTEXT_GH4_SONGS_SONG_EVERLONG             16
#define CONTEXT_GH4_SONGS_SONG_EYEOFTHETIGER        17
#define CONTEXT_GH4_SONGS_SONG_FEELTHEPAIN          18
#define CONTEXT_GH4_SONGS_SONG_FLOATON              19
#define CONTEXT_GH4_SONGS_SONG_FREAKONALEASH        20
#define CONTEXT_GH4_SONGS_SONG_GOYOUROWNWAY         21
#define CONTEXT_GH4_SONGS_SONG_GOODGOD              22
#define CONTEXT_GH4_SONGS_SONG_HAILTOTHEFREAKS      23
#define CONTEXT_GH4_SONGS_SONG_HEARTBREAKER         24
#define CONTEXT_GH4_SONGS_SONG_HEYMANNICESHOT       25
#define CONTEXT_GH4_SONGS_SONG_HOLLYWOODNIGHTS      26
#define CONTEXT_GH4_SONGS_SONG_HOTFORTEACHER        27
#define CONTEXT_GH4_SONGS_SONG_HOTELCALIFORNIA      28
#define CONTEXT_GH4_SONGS_SONG_KICKOUTHEJAMS        29
#define CONTEXT_GH4_SONGS_SONG_LABAMBA              30
#define CONTEXT_GH4_SONGS_SONG_LAZYEYE              31
#define CONTEXT_GH4_SONGS_SONG_LIVINONAPRAYER       32
#define CONTEXT_GH4_SONGS_SONG_LOVEMETWOTIMES       33
#define CONTEXT_GH4_SONGS_SONG_LOVEREMOVALMACHINE   34
#define CONTEXT_GH4_SONGS_SONG_LOVESPREADS          35
#define CONTEXT_GH4_SONGS_SONG_LVIALVIAQUEZ         36
#define CONTEXT_GH4_SONGS_SONG_MISERYBUSINESS       37
#define CONTEXT_GH4_SONGS_SONG_MONSOON              38
#define CONTEXT_GH4_SONGS_SONG_MOUNTAINSONG         39
#define CONTEXT_GH4_SONGS_SONG_MRCROWLEY            40
#define CONTEXT_GH4_SONGS_SONG_NEVERTOOLATE         41
#define CONTEXT_GH4_SONGS_SONG_NOSLEEPTILLBROOKLYN  42
#define CONTEXT_GH4_SONGS_SONG_NUVOLEELENZUOLA      43
#define CONTEXT_GH4_SONGS_SONG_OBSTACLE1            44
#define CONTEXT_GH4_SONGS_SONG_ONTHEROADAGAIN       45
#define CONTEXT_GH4_SONGS_SONG_ONEARMEDSCISSOR      46
#define CONTEXT_GH4_SONGS_SONG_ONEWAYORANOTHER      47
#define CONTEXT_GH4_SONGS_SONG_OURTRUTH             48
#define CONTEXT_GH4_SONGS_SONG_OVERKILL             49
#define CONTEXT_GH4_SONGS_SONG_PARABOLA             50
#define CONTEXT_GH4_SONGS_SONG_PRETTYVACANT         51
#define CONTEXT_GH4_SONGS_SONG_PRISONEROFSOCIETY    52
#define CONTEXT_GH4_SONGS_SONG_PULLMEUNDER          53
#define CONTEXT_GH4_SONGS_SONG_PURPLEHAZE           54
#define CONTEXT_GH4_SONGS_SONG_RAMBLINMAN           55
#define CONTEXT_GH4_SONGS_SONG_REBELYELL            56
#define CONTEXT_GH4_SONGS_SONG_REEDUCATIONTHROUGHLABOR 57
#define CONTEXT_GH4_SONGS_SONG_ROOFTOPS             58
#define CONTEXT_GH4_SONGS_SONG_SANTERIA             59
#define CONTEXT_GH4_SONGS_SONG_SATCHBOOGIE          60
#define CONTEXT_GH4_SONGS_SONG_SCHISM               61
#define CONTEXT_GH4_SONGS_SONG_SCREAMAIMFIRE        62
#define CONTEXT_GH4_SONGS_SONG_SHIVER               63
#define CONTEXT_GH4_SONGS_SONG_SOMEMIGHTSAY         64
#define CONTEXT_GH4_SONGS_SONG_SOULDOUBT            65
#define CONTEXT_GH4_SONGS_SONG_SPIDERWEBS           66
#define CONTEXT_GH4_SONGS_SONG_STILLBORN            67
#define CONTEXT_GH4_SONGS_SONG_STRANGLEHOLD         68
#define CONTEXT_GH4_SONGS_SONG_SWEETHOMEALABAMA     69
#define CONTEXT_GH4_SONGS_SONG_THEJOKER             70
#define CONTEXT_GH4_SONGS_SONG_THEKILL              71
#define CONTEXT_GH4_SONGS_SONG_THEMIDDLE            72
#define CONTEXT_GH4_SONGS_SONG_THEONEILOVE          73
#define CONTEXT_GH4_SONGS_SONG_TODAY                74
#define CONTEXT_GH4_SONGS_SONG_TOOMUCHTOOYOUNGTOOFAST 75
#define CONTEXT_GH4_SONGS_SONG_TOYBOY               76
#define CONTEXT_GH4_SONGS_SONG_TRAPPEDUNDERICE      77
#define CONTEXT_GH4_SONGS_SONG_UPAROUNDTHEBEND      78
#define CONTEXT_GH4_SONGS_SONG_VICARIOUS            79
#define CONTEXT_GH4_SONGS_SONG_VINTERNOLL2          80
#define CONTEXT_GH4_SONGS_SONG_WEAPONOFCHOICE       81
#define CONTEXT_GH4_SONGS_SONG_WHATIVEDONE          82
#define CONTEXT_GH4_SONGS_SONG_WINDCRIESMARY        83
#define CONTEXT_GH4_SONGS_SONG_YOUREGONNASAYYEAH    84
#define CONTEXT_GH4_SONGS_SONG_DOWNLOAD_SONG        85
#define CONTEXT_GH4_SONGS_SONG_DOITAGAIN            86

// Values for CONTEXT_SEARCH_GH4_HOSTING_STATE

#define CONTEXT_SEARCH_GH4_HOSTING_STATE_SEARCH_CON_HOSTING_READY 0
#define CONTEXT_SEARCH_GH4_HOSTING_STATE_SEARCH_CON_HOSTING_NOT_READY 1

// Values for CONTEXT_SEARCH_GH4_INSTRUMENTS

#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_GUITAR 0
#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_BASS 1
#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_DRUMS 2
#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_MIC 3

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_MENUS                      0
#define CONTEXT_PRESENCE_BAND_CAREER                1
#define CONTEXT_PRESENCE_BAND_LOGO_EDIT_AND_INSTRUMENT_EDIT 2
#define CONTEXT_PRESENCE_CAREER                     3
#define CONTEXT_PRESENCE_GIGBOARD_AND_SETLIST       4
#define CONTEXT_PRESENCE_GUEST_PROFILE              5
#define CONTEXT_PRESENCE_HEAD_TO_HEAD               6
#define CONTEXT_PRESENCE_LEADERBOARDS               7
#define CONTEXT_PRESENCE_MUSIC_STUDIO               8
#define CONTEXT_PRESENCE_ONLINE                     9
#define CONTEXT_PRESENCE_PRACTICE                   10
#define CONTEXT_PRESENCE_QUICKPLAY                  11
#define CONTEXT_PRESENCE_ROCKSTAR_CREATOR           12
#define CONTEXT_PRESENCE_SIGNED_IN_2_3_AND_4        13
#define CONTEXT_PRESENCE_TUTORIAL                   14
#define CONTEXT_PRESENCE_VIDEOS                     15

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_ONLY_GAMEMODE             0
#define CONTEXT_GAME_MODE_BAND_CAREER               1
#define CONTEXT_GAME_MODE_SEARCH_TEST_GIDEON        2
#define CONTEXT_GAME_MODE_SEARCH_TEST_JOE           3
#define CONTEXT_GAME_MODE_SEARCH_TEST_THOMAS        4
#define CONTEXT_GAME_MODE_SEARCH_TEST_MARIO         5
#define CONTEXT_GAME_MODE_SEARCH_TEST_TIM           6
#define CONTEXT_GAME_MODE_COOP                      7
#define CONTEXT_GAME_MODE_COMPETITIVE               8

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_COLUMN_SCORE                       0x10000002
#define PROPERTY_GH3_CASH                           0x10000003
#define PROPERTY_COLUMN_WIN_LOSS                    0x10000004
#define PROPERTY_MM_GUITARS_NEEDED                  0x10000005
#define PROPERTY_MM_DRUMS_NEEDED                    0x10000006
#define PROPERTY_MM_MICROPHONES_NEEDED              0x10000007
#define PROPERTY_COLUMN_SCORE_EASY                  0x10000008
#define PROPERTY_COLUMN_SCORE_MEDIUM                0x10000009
#define PROPERTY_COLUMN_SCORE_HARD                  0x1000000A
#define PROPERTY_COLUMN_SCORE_EXPERT                0x1000000B
#define PROPERTY_MM_SONG_DIFFICULTY                 0x1000000C
#define PROPERTY_COLUMN_SORT                        0x20000001

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//

#define ACHIEVEMENT_LEARNING_THE_ROPES              6
#define ACHIEVEMENT_ONE_TIME_SOLO_ARTIST            7
#define ACHIEVEMENT_STIX                            8
#define ACHIEVEMENT_YODELER                         9
#define ACHIEVEMENT_PICK_AND_AXE                    10
#define ACHIEVEMENT_FEEDING_THE_BEAST               11
#define ACHIEVEMENT_THIS_IS_TOTALLY_LEGAL           12
#define ACHIEVEMENT_A_PAIR_BEATS_A_PAIR             13
#define ACHIEVEMENT_SURVIVAL_OF_THE_FITTEST         14
#define ACHIEVEMENT_MINE_IS_BIGGER_THAN_YOURS       15
#define ACHIEVEMENT_FIRST_OF_MANY                   16
#define ACHIEVEMENT_ONE_MAN_BAND                    17
#define ACHIEVEMENT_SHOULD_WE_STICK_TOGETHER        18
#define ACHIEVEMENT_50_NOTE_POSSE                   19
#define ACHIEVEMENT_EASY_THERE                      20
#define ACHIEVEMENT_SOLO_ARTIST                     21
#define ACHIEVEMENT_BAND_ON_A_MISSION               22
#define ACHIEVEMENT_BLING_BLING                     23
#define ACHIEVEMENT_TOP_OF_THE_CHARTS               25
#define ACHIEVEMENT_MEDIUM_MUSICIAN                 26
#define ACHIEVEMENT_SOLID_GOLD_ROCKSTARS            27
#define ACHIEVEMENT_PLATINUM_ROCKSTARS              28
#define ACHIEVEMENT_HARDCORE                        29
#define ACHIEVEMENT_HALL_OF_FAMER                   30
#define ACHIEVEMENT_JACK_OF_ALL_TRADES              31
#define ACHIEVEMENT_INKED                           32
#define ACHIEVEMENT_CUSTOM_BEATS                    33
#define ACHIEVEMENT_ONE_OF_A_KIND_AXE               34
#define ACHIEVEMENT_STAMP_OF_APPROVAL               35
#define ACHIEVEMENT_ROCK_MAIDEN                     36
#define ACHIEVEMENT_WARRIOR_OF_ROCK                 37
#define ACHIEVEMENT_THE_DARK_PRINCE                 38
#define ACHIEVEMENT_LEADING_LADY                    39
#define ACHIEVEMENT_MOTORCITY_MADMAN                40
#define ACHIEVEMENT_THE_EXPERIENCE                  41
#define ACHIEVEMENT_DONT_BLINK                      42
#define ACHIEVEMENT_PUMPKIN_SMASHER                 43
#define ACHIEVEMENT_WYLDE_MAN                       44
#define ACHIEVEMENT_SHINY_METAL_THINGY              45
#define ACHIEVEMENT_BAD_TO_THE_BONE                 46
#define ACHIEVEMENT_GUITARISTS_COAT_TAILS           47
#define ACHIEVEMENT_VOCALISTS_COAT_TAILS            48
#define ACHIEVEMENT_121_JIGOWATTS                   49
#define ACHIEVEMENT_SUPER_GROUP_UNITE               50
#define ACHIEVEMENT_AXE_MUSEUM                      51
#define ACHIEVEMENT_GET_YOUR_BOOGIE_ON              52
#define ACHIEVEMENT_MUSE_TO_MY_EARS                 53
#define ACHIEVEMENT_MIKE_CHECKA                     54
#define ACHIEVEMENT_YOURE_A_TOOL                    55
#define ACHIEVEMENT_HEAVY_METALL                    56

//
// AvatarAssetAward ids
//

#define AVATARASSETAWARD_SHIRT_NONE_JACKET               1
#define AVATARASSETAWARD_SHIRT_TEE_SHORTSLEEVESHIRT      2
#define AVATARASSETAWARD_SHOES_FORMAL_COSTUME            3
#define AVATARASSETAWARD_SHOES_HIGH_BOOTS_HEELS          4
#define AVATARASSETAWARD_HAT_FEZ                         5

//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_ONLY_GAMEMODE       0xFFFF0000
#define STATS_VIEW_SKILL_RANKED_BAND_CAREER         0xFFFF0001
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_GIDEON  0xFFFF0002
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_JOE     0xFFFF0003
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_THOMAS  0xFFFF0004
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_MARIO   0xFFFF0005
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_TIM     0xFFFF0006
#define STATS_VIEW_SKILL_RANKED_COOP                0xFFFF0007
#define STATS_VIEW_SKILL_RANKED_COMPETITIVE         0xFFFF0008

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_ONLY_GAMEMODE     0xFFFE0000
#define STATS_VIEW_SKILL_STANDARD_BAND_CAREER       0xFFFE0001
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_GIDEON 0xFFFE0002
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_JOE   0xFFFE0003
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_THOMAS 0xFFFE0004
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_MARIO 0xFFFE0005
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_TIM   0xFFFE0006
#define STATS_VIEW_SKILL_STANDARD_COOP              0xFFFE0007
#define STATS_VIEW_SKILL_STANDARD_COMPETITIVE       0xFFFE0008

// Title defined leaderboards

#define STATS_VIEW_MODES                            1
#define STATS_VIEW_SONG                             2
#define STATS_VIEW_DLC243_GUITAR                    1651
#define STATS_VIEW_DLC243_BACKUP                    1652
#define STATS_VIEW_DLC243_DRUMS                     1653
#define STATS_VIEW_DLC243_MIC                       1654
#define STATS_VIEW_DLC243_BAND                      1655
#define STATS_VIEW_DLC244_GUITAR                    1656
#define STATS_VIEW_DLC244_BACKUP                    1657
#define STATS_VIEW_DLC244_DRUMS                     1658
#define STATS_VIEW_DLC244_MIC                       1659
#define STATS_VIEW_DLC244_BAND                      1660
#define STATS_VIEW_DLC245_GUITAR                    1661
#define STATS_VIEW_DLC245_BACKUP                    1662
#define STATS_VIEW_DLC245_DRUMS                     1663
#define STATS_VIEW_DLC245_MIC                       1664
#define STATS_VIEW_DLC245_BAND                      1665
#define STATS_VIEW_DLC246_GUITAR                    1666
#define STATS_VIEW_DLC246_BACKUP                    1667
#define STATS_VIEW_DLC246_DRUMS                     1668
#define STATS_VIEW_DLC246_MIC                       1669
#define STATS_VIEW_DLC246_BAND                      1670
#define STATS_VIEW_DLC247_GUITAR                    1671
#define STATS_VIEW_DLC247_BACKUP                    1672
#define STATS_VIEW_DLC247_DRUMS                     1673
#define STATS_VIEW_DLC247_MIC                       1674
#define STATS_VIEW_DLC247_BAND                      1675
#define STATS_VIEW_DLC248_GUITAR                    1676
#define STATS_VIEW_DLC248_BACKUP                    1677
#define STATS_VIEW_DLC248_DRUMS                     1678
#define STATS_VIEW_DLC248_MIC                       1679
#define STATS_VIEW_DLC248_BAND                      1680
#define STATS_VIEW_DLC249_GUITAR                    1681
#define STATS_VIEW_DLC249_BACKUP                    1682
#define STATS_VIEW_DLC249_DRUMS                     1683
#define STATS_VIEW_DLC249_MIC                       1684
#define STATS_VIEW_DLC249_BAND                      1685
#define STATS_VIEW_DLC250_GUITAR                    1686
#define STATS_VIEW_DLC250_BACKUP                    1687
#define STATS_VIEW_DLC250_DRUMS                     1688
#define STATS_VIEW_DLC250_MIC                       1689
#define STATS_VIEW_DLC250_BAND                      1690
#define STATS_VIEW_DLC251_GUITAR                    1691
#define STATS_VIEW_DLC251_BACKUP                    1692
#define STATS_VIEW_DLC251_DRUMS                     1693
#define STATS_VIEW_DLC251_MIC                       1694
#define STATS_VIEW_DLC251_BAND                      1695
#define STATS_VIEW_DLC252_GUITAR                    1696
#define STATS_VIEW_DLC252_BACKUP                    1697
#define STATS_VIEW_DLC252_DRUMS                     1698
#define STATS_VIEW_DLC252_MIC                       1699
#define STATS_VIEW_DLC252_BAND                      1700
#define STATS_VIEW_DLC253_GUITAR                    1701
#define STATS_VIEW_DLC253_BACKUP                    1702
#define STATS_VIEW_DLC253_DRUMS                     1703
#define STATS_VIEW_DLC253_MIC                       1704
#define STATS_VIEW_DLC253_BAND                      1705
#define STATS_VIEW_DLC254_GUITAR                    1706
#define STATS_VIEW_DLC254_BACKUP                    1707
#define STATS_VIEW_DLC254_DRUMS                     1708
#define STATS_VIEW_DLC254_MIC                       1709
#define STATS_VIEW_DLC254_BAND                      1710
#define STATS_VIEW_DLC255_GUITAR                    1711
#define STATS_VIEW_DLC255_BACKUP                    1712
#define STATS_VIEW_DLC255_DRUMS                     1713
#define STATS_VIEW_DLC255_MIC                       1714
#define STATS_VIEW_DLC255_BAND                      1715
#define STATS_VIEW_DLC256_GUITAR                    1716
#define STATS_VIEW_DLC256_BACKUP                    1717
#define STATS_VIEW_DLC256_DRUMS                     1718
#define STATS_VIEW_DLC256_MIC                       1719
#define STATS_VIEW_DLC256_BAND                      1720

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for MODES

#define STATS_COLUMN_MODES_COLUMN_ACCUMULATED_SCORE 1
#define STATS_COLUMN_MODES_COLUMN_SCORE             2
#define STATS_COLUMN_MODES_COLUMN_TOTAL_WINS        3
#define STATS_COLUMN_MODES_COLUMN_DIFFICULTY_HARD   4

// Column ids for SONG

#define STATS_COLUMN_SONG_COLUMN_SCORE_EASY         1
#define STATS_COLUMN_SONG_COLUMN_SCORE_MEDIUM       2
#define STATS_COLUMN_SONG_COLUMN_SCORE_HARD         3
#define STATS_COLUMN_SONG_COLUMN_SCORE_EXPERT       4

// Column ids for DLC243_GUITAR

#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_BACKUP

#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_DRUMS

#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_MIC

#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_BAND

#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_GUITAR

#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_BACKUP

#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_DRUMS

#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_MIC

#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_BAND

#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_GUITAR

#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_BACKUP

#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_DRUMS

#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_MIC

#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_BAND

#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_GUITAR

#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_BACKUP

#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_DRUMS

#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_MIC

#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_BAND

#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_GUITAR

#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_BACKUP

#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_DRUMS

#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_MIC

#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_BAND

#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_GUITAR

#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_BACKUP

#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_DRUMS

#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_MIC

#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_BAND

#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_GUITAR

#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_BACKUP

#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_DRUMS

#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_MIC

#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_BAND

#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_GUITAR

#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_BACKUP

#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_DRUMS

#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_MIC

#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_BAND

#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_GUITAR

#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_BACKUP

#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_DRUMS

#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_MIC

#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_BAND

#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_GUITAR

#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_BACKUP

#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_DRUMS

#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_MIC

#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_BAND

#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_GUITAR

#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_BACKUP

#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_DRUMS

#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_MIC

#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_BAND

#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_GUITAR

#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_BACKUP

#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_DRUMS

#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_MIC

#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_BAND

#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_GUITAR

#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_BACKUP

#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_DRUMS

#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_MIC

#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_BAND

#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_GUITAR

#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_BACKUP

#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_DRUMS

#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_MIC

#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_BAND

#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_EXPERT 4

//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//

#define SESSION_MATCH_QUERY_GH3_DEFAULT_QUERY       0
#define SESSION_MATCH_QUERY_GH4_ALT_QUERY           1

//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//



#ifdef __cplusplus
}
#endif

#endif // __GUITAR_HERO_WORLD_TOUR_SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\SuitesData\SPACFunctional\AvatarItems\Positive\FullGame\FullGame-Hat2-expected.spa.h ===
////////////////////////////////////////////////////////////////////
//
// FullGame-Hat2.spa.h
//
// Auto-generated on {*}
// XLAST project version {*}
// SPA Compiler version {*}
//
////////////////////////////////////////////////////////////////////

#ifndef __GUITAR_HERO_WORLD_TOUR_SPA_H__
#define __GUITAR_HERO_WORLD_TOUR_SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_GUITAR_HERO_WORLD_TOUR              0x4156081A

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//

#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY          0
#define CONTEXT_SEARCH_GH3_SONG_COUNT               1
#define CONTEXT_SEARCH_GH3_VENUE                    2
#define CONTEXT_SEARCH_GH3_GAME_MODE                3
#define CONTEXT_GH4_SONGS                           78
#define CONTEXT_SEARCH_GH4_HOSTING_STATE            79
#define CONTEXT_SEARCH_GH4_INSTRUMENTS              80

//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for CONTEXT_SEARCH_GH3_SONG_DIFFICULTY

#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_EASY 0
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_MEDIUM 1
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_HARD 2
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_EXPERT 3
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_BEGINNER 4

// Values for CONTEXT_SEARCH_GH3_SONG_COUNT

#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_1 0
#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_3 1
#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_5 2
#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_7 3

// Values for CONTEXT_SEARCH_GH3_VENUE

#define CONTEXT_SEARCH_GH3_VENUE_SEARCH_CON_VENUE_TEMP 0

// Values for CONTEXT_SEARCH_GH3_GAME_MODE

#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_FACEOFF_GUITAR 0
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_PRO_FACEOFF_GUITAR 1
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_BATTLE_GUITAR 2
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_2V2_PRO_FACEOFF_GUITAR 3
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_PRO_FACEOFF_DRUMS 4
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_BATTLE_DRUMS 5
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_BAND_FACEOFF 6
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_BAND_COOP 7
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_GUITAR_COOP 8
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_BAND_CAREER 9
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_FACEOFF_BASS 10
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_PRO_FACEOFF_BASS 11
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_EXTRA_1   12
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_EXTRA_2   13
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_EXTRA_3   14

// Values for CONTEXT_GH4_SONGS

#define CONTEXT_GH4_SONGS_SONG_ABOUTAGIRL           0
#define CONTEXT_GH4_SONGS_SONG_AGGRO                1
#define CONTEXT_GH4_SONGS_SONG_AMERICANWOMAN        2
#define CONTEXT_GH4_SONGS_SONG_ANTISOCIAL           3
#define CONTEXT_GH4_SONGS_SONG_AREYOUGONNAGOMYWAY   4
#define CONTEXT_GH4_SONGS_SONG_ASSASSIN             5
#define CONTEXT_GH4_SONGS_SONG_BANDONTHERUN         6
#define CONTEXT_GH4_SONGS_SONG_BEATIT               7
#define CONTEXT_GH4_SONGS_SONG_BEAUTIFULDISASTER    8
#define CONTEXT_GH4_SONGS_SONG_BOSS_TED             9
#define CONTEXT_GH4_SONGS_SONG_BOSS_WYLDE           10
#define CONTEXT_GH4_SONGS_SONG_BYOB                 11
#define CONTEXT_GH4_SONGS_SONG_CRAZYTRAIN           12
#define CONTEXT_GH4_SONGS_SONG_DAMMIT               13
#define CONTEXT_GH4_SONGS_SONG_DEMOLITIONMAN        14
#define CONTEXT_GH4_SONGS_SONG_ESCUELADECALOR       15
#define CONTEXT_GH4_SONGS_SONG_EVERLONG             16
#define CONTEXT_GH4_SONGS_SONG_EYEOFTHETIGER        17
#define CONTEXT_GH4_SONGS_SONG_FEELTHEPAIN          18
#define CONTEXT_GH4_SONGS_SONG_FLOATON              19
#define CONTEXT_GH4_SONGS_SONG_FREAKONALEASH        20
#define CONTEXT_GH4_SONGS_SONG_GOYOUROWNWAY         21
#define CONTEXT_GH4_SONGS_SONG_GOODGOD              22
#define CONTEXT_GH4_SONGS_SONG_HAILTOTHEFREAKS      23
#define CONTEXT_GH4_SONGS_SONG_HEARTBREAKER         24
#define CONTEXT_GH4_SONGS_SONG_HEYMANNICESHOT       25
#define CONTEXT_GH4_SONGS_SONG_HOLLYWOODNIGHTS      26
#define CONTEXT_GH4_SONGS_SONG_HOTFORTEACHER        27
#define CONTEXT_GH4_SONGS_SONG_HOTELCALIFORNIA      28
#define CONTEXT_GH4_SONGS_SONG_KICKOUTHEJAMS        29
#define CONTEXT_GH4_SONGS_SONG_LABAMBA              30
#define CONTEXT_GH4_SONGS_SONG_LAZYEYE              31
#define CONTEXT_GH4_SONGS_SONG_LIVINONAPRAYER       32
#define CONTEXT_GH4_SONGS_SONG_LOVEMETWOTIMES       33
#define CONTEXT_GH4_SONGS_SONG_LOVEREMOVALMACHINE   34
#define CONTEXT_GH4_SONGS_SONG_LOVESPREADS          35
#define CONTEXT_GH4_SONGS_SONG_LVIALVIAQUEZ         36
#define CONTEXT_GH4_SONGS_SONG_MISERYBUSINESS       37
#define CONTEXT_GH4_SONGS_SONG_MONSOON              38
#define CONTEXT_GH4_SONGS_SONG_MOUNTAINSONG         39
#define CONTEXT_GH4_SONGS_SONG_MRCROWLEY            40
#define CONTEXT_GH4_SONGS_SONG_NEVERTOOLATE         41
#define CONTEXT_GH4_SONGS_SONG_NOSLEEPTILLBROOKLYN  42
#define CONTEXT_GH4_SONGS_SONG_NUVOLEELENZUOLA      43
#define CONTEXT_GH4_SONGS_SONG_OBSTACLE1            44
#define CONTEXT_GH4_SONGS_SONG_ONTHEROADAGAIN       45
#define CONTEXT_GH4_SONGS_SONG_ONEARMEDSCISSOR      46
#define CONTEXT_GH4_SONGS_SONG_ONEWAYORANOTHER      47
#define CONTEXT_GH4_SONGS_SONG_OURTRUTH             48
#define CONTEXT_GH4_SONGS_SONG_OVERKILL             49
#define CONTEXT_GH4_SONGS_SONG_PARABOLA             50
#define CONTEXT_GH4_SONGS_SONG_PRETTYVACANT         51
#define CONTEXT_GH4_SONGS_SONG_PRISONEROFSOCIETY    52
#define CONTEXT_GH4_SONGS_SONG_PULLMEUNDER          53
#define CONTEXT_GH4_SONGS_SONG_PURPLEHAZE           54
#define CONTEXT_GH4_SONGS_SONG_RAMBLINMAN           55
#define CONTEXT_GH4_SONGS_SONG_REBELYELL            56
#define CONTEXT_GH4_SONGS_SONG_REEDUCATIONTHROUGHLABOR 57
#define CONTEXT_GH4_SONGS_SONG_ROOFTOPS             58
#define CONTEXT_GH4_SONGS_SONG_SANTERIA             59
#define CONTEXT_GH4_SONGS_SONG_SATCHBOOGIE          60
#define CONTEXT_GH4_SONGS_SONG_SCHISM               61
#define CONTEXT_GH4_SONGS_SONG_SCREAMAIMFIRE        62
#define CONTEXT_GH4_SONGS_SONG_SHIVER               63
#define CONTEXT_GH4_SONGS_SONG_SOMEMIGHTSAY         64
#define CONTEXT_GH4_SONGS_SONG_SOULDOUBT            65
#define CONTEXT_GH4_SONGS_SONG_SPIDERWEBS           66
#define CONTEXT_GH4_SONGS_SONG_STILLBORN            67
#define CONTEXT_GH4_SONGS_SONG_STRANGLEHOLD         68
#define CONTEXT_GH4_SONGS_SONG_SWEETHOMEALABAMA     69
#define CONTEXT_GH4_SONGS_SONG_THEJOKER             70
#define CONTEXT_GH4_SONGS_SONG_THEKILL              71
#define CONTEXT_GH4_SONGS_SONG_THEMIDDLE            72
#define CONTEXT_GH4_SONGS_SONG_THEONEILOVE          73
#define CONTEXT_GH4_SONGS_SONG_TODAY                74
#define CONTEXT_GH4_SONGS_SONG_TOOMUCHTOOYOUNGTOOFAST 75
#define CONTEXT_GH4_SONGS_SONG_TOYBOY               76
#define CONTEXT_GH4_SONGS_SONG_TRAPPEDUNDERICE      77
#define CONTEXT_GH4_SONGS_SONG_UPAROUNDTHEBEND      78
#define CONTEXT_GH4_SONGS_SONG_VICARIOUS            79
#define CONTEXT_GH4_SONGS_SONG_VINTERNOLL2          80
#define CONTEXT_GH4_SONGS_SONG_WEAPONOFCHOICE       81
#define CONTEXT_GH4_SONGS_SONG_WHATIVEDONE          82
#define CONTEXT_GH4_SONGS_SONG_WINDCRIESMARY        83
#define CONTEXT_GH4_SONGS_SONG_YOUREGONNASAYYEAH    84
#define CONTEXT_GH4_SONGS_SONG_DOWNLOAD_SONG        85
#define CONTEXT_GH4_SONGS_SONG_DOITAGAIN            86

// Values for CONTEXT_SEARCH_GH4_HOSTING_STATE

#define CONTEXT_SEARCH_GH4_HOSTING_STATE_SEARCH_CON_HOSTING_READY 0
#define CONTEXT_SEARCH_GH4_HOSTING_STATE_SEARCH_CON_HOSTING_NOT_READY 1

// Values for CONTEXT_SEARCH_GH4_INSTRUMENTS

#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_GUITAR 0
#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_BASS 1
#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_DRUMS 2
#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_MIC 3

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_MENUS                      0
#define CONTEXT_PRESENCE_BAND_CAREER                1
#define CONTEXT_PRESENCE_BAND_LOGO_EDIT_AND_INSTRUMENT_EDIT 2
#define CONTEXT_PRESENCE_CAREER                     3
#define CONTEXT_PRESENCE_GIGBOARD_AND_SETLIST       4
#define CONTEXT_PRESENCE_GUEST_PROFILE              5
#define CONTEXT_PRESENCE_HEAD_TO_HEAD               6
#define CONTEXT_PRESENCE_LEADERBOARDS               7
#define CONTEXT_PRESENCE_MUSIC_STUDIO               8
#define CONTEXT_PRESENCE_ONLINE                     9
#define CONTEXT_PRESENCE_PRACTICE                   10
#define CONTEXT_PRESENCE_QUICKPLAY                  11
#define CONTEXT_PRESENCE_ROCKSTAR_CREATOR           12
#define CONTEXT_PRESENCE_SIGNED_IN_2_3_AND_4        13
#define CONTEXT_PRESENCE_TUTORIAL                   14
#define CONTEXT_PRESENCE_VIDEOS                     15

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_ONLY_GAMEMODE             0
#define CONTEXT_GAME_MODE_BAND_CAREER               1
#define CONTEXT_GAME_MODE_SEARCH_TEST_GIDEON        2
#define CONTEXT_GAME_MODE_SEARCH_TEST_JOE           3
#define CONTEXT_GAME_MODE_SEARCH_TEST_THOMAS        4
#define CONTEXT_GAME_MODE_SEARCH_TEST_MARIO         5
#define CONTEXT_GAME_MODE_SEARCH_TEST_TIM           6
#define CONTEXT_GAME_MODE_COOP                      7
#define CONTEXT_GAME_MODE_COMPETITIVE               8

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_COLUMN_SCORE                       0x10000002
#define PROPERTY_GH3_CASH                           0x10000003
#define PROPERTY_COLUMN_WIN_LOSS                    0x10000004
#define PROPERTY_MM_GUITARS_NEEDED                  0x10000005
#define PROPERTY_MM_DRUMS_NEEDED                    0x10000006
#define PROPERTY_MM_MICROPHONES_NEEDED              0x10000007
#define PROPERTY_COLUMN_SCORE_EASY                  0x10000008
#define PROPERTY_COLUMN_SCORE_MEDIUM                0x10000009
#define PROPERTY_COLUMN_SCORE_HARD                  0x1000000A
#define PROPERTY_COLUMN_SCORE_EXPERT                0x1000000B
#define PROPERTY_MM_SONG_DIFFICULTY                 0x1000000C
#define PROPERTY_COLUMN_SORT                        0x20000001

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//

#define ACHIEVEMENT_LEARNING_THE_ROPES              6
#define ACHIEVEMENT_ONE_TIME_SOLO_ARTIST            7
#define ACHIEVEMENT_STIX                            8
#define ACHIEVEMENT_YODELER                         9
#define ACHIEVEMENT_PICK_AND_AXE                    10
#define ACHIEVEMENT_FEEDING_THE_BEAST               11
#define ACHIEVEMENT_THIS_IS_TOTALLY_LEGAL           12
#define ACHIEVEMENT_A_PAIR_BEATS_A_PAIR             13
#define ACHIEVEMENT_SURVIVAL_OF_THE_FITTEST         14
#define ACHIEVEMENT_MINE_IS_BIGGER_THAN_YOURS       15
#define ACHIEVEMENT_FIRST_OF_MANY                   16
#define ACHIEVEMENT_ONE_MAN_BAND                    17
#define ACHIEVEMENT_SHOULD_WE_STICK_TOGETHER        18
#define ACHIEVEMENT_50_NOTE_POSSE                   19
#define ACHIEVEMENT_EASY_THERE                      20
#define ACHIEVEMENT_SOLO_ARTIST                     21
#define ACHIEVEMENT_BAND_ON_A_MISSION               22
#define ACHIEVEMENT_BLING_BLING                     23
#define ACHIEVEMENT_TOP_OF_THE_CHARTS               25
#define ACHIEVEMENT_MEDIUM_MUSICIAN                 26
#define ACHIEVEMENT_SOLID_GOLD_ROCKSTARS            27
#define ACHIEVEMENT_PLATINUM_ROCKSTARS              28
#define ACHIEVEMENT_HARDCORE                        29
#define ACHIEVEMENT_HALL_OF_FAMER                   30
#define ACHIEVEMENT_JACK_OF_ALL_TRADES              31
#define ACHIEVEMENT_INKED                           32
#define ACHIEVEMENT_CUSTOM_BEATS                    33
#define ACHIEVEMENT_ONE_OF_A_KIND_AXE               34
#define ACHIEVEMENT_STAMP_OF_APPROVAL               35
#define ACHIEVEMENT_ROCK_MAIDEN                     36
#define ACHIEVEMENT_WARRIOR_OF_ROCK                 37
#define ACHIEVEMENT_THE_DARK_PRINCE                 38
#define ACHIEVEMENT_LEADING_LADY                    39
#define ACHIEVEMENT_MOTORCITY_MADMAN                40
#define ACHIEVEMENT_THE_EXPERIENCE                  41
#define ACHIEVEMENT_DONT_BLINK                      42
#define ACHIEVEMENT_PUMPKIN_SMASHER                 43
#define ACHIEVEMENT_WYLDE_MAN                       44
#define ACHIEVEMENT_SHINY_METAL_THINGY              45
#define ACHIEVEMENT_BAD_TO_THE_BONE                 46
#define ACHIEVEMENT_GUITARISTS_COAT_TAILS           47
#define ACHIEVEMENT_VOCALISTS_COAT_TAILS            48
#define ACHIEVEMENT_121_JIGOWATTS                   49
#define ACHIEVEMENT_SUPER_GROUP_UNITE               50
#define ACHIEVEMENT_AXE_MUSEUM                      51
#define ACHIEVEMENT_GET_YOUR_BOOGIE_ON              52
#define ACHIEVEMENT_MUSE_TO_MY_EARS                 53
#define ACHIEVEMENT_MIKE_CHECKA                     54
#define ACHIEVEMENT_YOURE_A_TOOL                    55
#define ACHIEVEMENT_HEAVY_METALL                    56

//
// AvatarAssetAward ids
//

#define AVATARASSETAWARD_HAT_FEZ                         1
#define AVATARASSETAWARD_HAT_HEAD_WRAP                   2
#define AVATARASSETAWARD_HAT_COSTUME                     3
#define AVATARASSETAWARD_HAT_BEARSKIN                    4
#define AVATARASSETAWARD_HAT_HELMET                      5

//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_ONLY_GAMEMODE       0xFFFF0000
#define STATS_VIEW_SKILL_RANKED_BAND_CAREER         0xFFFF0001
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_GIDEON  0xFFFF0002
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_JOE     0xFFFF0003
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_THOMAS  0xFFFF0004
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_MARIO   0xFFFF0005
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_TIM     0xFFFF0006
#define STATS_VIEW_SKILL_RANKED_COOP                0xFFFF0007
#define STATS_VIEW_SKILL_RANKED_COMPETITIVE         0xFFFF0008

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_ONLY_GAMEMODE     0xFFFE0000
#define STATS_VIEW_SKILL_STANDARD_BAND_CAREER       0xFFFE0001
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_GIDEON 0xFFFE0002
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_JOE   0xFFFE0003
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_THOMAS 0xFFFE0004
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_MARIO 0xFFFE0005
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_TIM   0xFFFE0006
#define STATS_VIEW_SKILL_STANDARD_COOP              0xFFFE0007
#define STATS_VIEW_SKILL_STANDARD_COMPETITIVE       0xFFFE0008

// Title defined leaderboards

#define STATS_VIEW_MODES                            1
#define STATS_VIEW_SONG                             2
#define STATS_VIEW_DLC243_GUITAR                    1651
#define STATS_VIEW_DLC243_BACKUP                    1652
#define STATS_VIEW_DLC243_DRUMS                     1653
#define STATS_VIEW_DLC243_MIC                       1654
#define STATS_VIEW_DLC243_BAND                      1655
#define STATS_VIEW_DLC244_GUITAR                    1656
#define STATS_VIEW_DLC244_BACKUP                    1657
#define STATS_VIEW_DLC244_DRUMS                     1658
#define STATS_VIEW_DLC244_MIC                       1659
#define STATS_VIEW_DLC244_BAND                      1660
#define STATS_VIEW_DLC245_GUITAR                    1661
#define STATS_VIEW_DLC245_BACKUP                    1662
#define STATS_VIEW_DLC245_DRUMS                     1663
#define STATS_VIEW_DLC245_MIC                       1664
#define STATS_VIEW_DLC245_BAND                      1665
#define STATS_VIEW_DLC246_GUITAR                    1666
#define STATS_VIEW_DLC246_BACKUP                    1667
#define STATS_VIEW_DLC246_DRUMS                     1668
#define STATS_VIEW_DLC246_MIC                       1669
#define STATS_VIEW_DLC246_BAND                      1670
#define STATS_VIEW_DLC247_GUITAR                    1671
#define STATS_VIEW_DLC247_BACKUP                    1672
#define STATS_VIEW_DLC247_DRUMS                     1673
#define STATS_VIEW_DLC247_MIC                       1674
#define STATS_VIEW_DLC247_BAND                      1675
#define STATS_VIEW_DLC248_GUITAR                    1676
#define STATS_VIEW_DLC248_BACKUP                    1677
#define STATS_VIEW_DLC248_DRUMS                     1678
#define STATS_VIEW_DLC248_MIC                       1679
#define STATS_VIEW_DLC248_BAND                      1680
#define STATS_VIEW_DLC249_GUITAR                    1681
#define STATS_VIEW_DLC249_BACKUP                    1682
#define STATS_VIEW_DLC249_DRUMS                     1683
#define STATS_VIEW_DLC249_MIC                       1684
#define STATS_VIEW_DLC249_BAND                      1685
#define STATS_VIEW_DLC250_GUITAR                    1686
#define STATS_VIEW_DLC250_BACKUP                    1687
#define STATS_VIEW_DLC250_DRUMS                     1688
#define STATS_VIEW_DLC250_MIC                       1689
#define STATS_VIEW_DLC250_BAND                      1690
#define STATS_VIEW_DLC251_GUITAR                    1691
#define STATS_VIEW_DLC251_BACKUP                    1692
#define STATS_VIEW_DLC251_DRUMS                     1693
#define STATS_VIEW_DLC251_MIC                       1694
#define STATS_VIEW_DLC251_BAND                      1695
#define STATS_VIEW_DLC252_GUITAR                    1696
#define STATS_VIEW_DLC252_BACKUP                    1697
#define STATS_VIEW_DLC252_DRUMS                     1698
#define STATS_VIEW_DLC252_MIC                       1699
#define STATS_VIEW_DLC252_BAND                      1700
#define STATS_VIEW_DLC253_GUITAR                    1701
#define STATS_VIEW_DLC253_BACKUP                    1702
#define STATS_VIEW_DLC253_DRUMS                     1703
#define STATS_VIEW_DLC253_MIC                       1704
#define STATS_VIEW_DLC253_BAND                      1705
#define STATS_VIEW_DLC254_GUITAR                    1706
#define STATS_VIEW_DLC254_BACKUP                    1707
#define STATS_VIEW_DLC254_DRUMS                     1708
#define STATS_VIEW_DLC254_MIC                       1709
#define STATS_VIEW_DLC254_BAND                      1710
#define STATS_VIEW_DLC255_GUITAR                    1711
#define STATS_VIEW_DLC255_BACKUP                    1712
#define STATS_VIEW_DLC255_DRUMS                     1713
#define STATS_VIEW_DLC255_MIC                       1714
#define STATS_VIEW_DLC255_BAND                      1715
#define STATS_VIEW_DLC256_GUITAR                    1716
#define STATS_VIEW_DLC256_BACKUP                    1717
#define STATS_VIEW_DLC256_DRUMS                     1718
#define STATS_VIEW_DLC256_MIC                       1719
#define STATS_VIEW_DLC256_BAND                      1720

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for MODES

#define STATS_COLUMN_MODES_COLUMN_ACCUMULATED_SCORE 1
#define STATS_COLUMN_MODES_COLUMN_SCORE             2
#define STATS_COLUMN_MODES_COLUMN_TOTAL_WINS        3
#define STATS_COLUMN_MODES_COLUMN_DIFFICULTY_HARD   4

// Column ids for SONG

#define STATS_COLUMN_SONG_COLUMN_SCORE_EASY         1
#define STATS_COLUMN_SONG_COLUMN_SCORE_MEDIUM       2
#define STATS_COLUMN_SONG_COLUMN_SCORE_HARD         3
#define STATS_COLUMN_SONG_COLUMN_SCORE_EXPERT       4

// Column ids for DLC243_GUITAR

#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_BACKUP

#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_DRUMS

#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_MIC

#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_BAND

#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_GUITAR

#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_BACKUP

#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_DRUMS

#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_MIC

#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_BAND

#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_GUITAR

#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_BACKUP

#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_DRUMS

#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_MIC

#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_BAND

#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_GUITAR

#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_BACKUP

#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_DRUMS

#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_MIC

#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_BAND

#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_GUITAR

#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_BACKUP

#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_DRUMS

#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_MIC

#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_BAND

#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_GUITAR

#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_BACKUP

#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_DRUMS

#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_MIC

#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_BAND

#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_GUITAR

#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_BACKUP

#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_DRUMS

#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_MIC

#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_BAND

#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_GUITAR

#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_BACKUP

#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_DRUMS

#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_MIC

#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_BAND

#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_GUITAR

#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_BACKUP

#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_DRUMS

#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_MIC

#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_BAND

#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_GUITAR

#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_BACKUP

#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_DRUMS

#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_MIC

#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_BAND

#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_GUITAR

#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_BACKUP

#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_DRUMS

#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_MIC

#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_BAND

#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_GUITAR

#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_BACKUP

#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_DRUMS

#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_MIC

#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_BAND

#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_GUITAR

#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_BACKUP

#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_DRUMS

#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_MIC

#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_BAND

#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_GUITAR

#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_BACKUP

#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_DRUMS

#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_MIC

#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_BAND

#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_EXPERT 4

//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//

#define SESSION_MATCH_QUERY_GH3_DEFAULT_QUERY       0
#define SESSION_MATCH_QUERY_GH4_ALT_QUERY           1

//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//



#ifdef __cplusplus
}
#endif

#endif // __GUITAR_HERO_WORLD_TOUR_SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\SuitesData\SPACFunctional\AvatarItems\Positive\FullGame\FullGame-Shoes-Earing-expected.spa.h ===
////////////////////////////////////////////////////////////////////
//
// FullGame-Shoes-Earing.spa.h
//
// Auto-generated on {*}
// XLAST project version {*}
// SPA Compiler version {*}
//
////////////////////////////////////////////////////////////////////

#ifndef __GUITAR_HERO_WORLD_TOUR_SPA_H__
#define __GUITAR_HERO_WORLD_TOUR_SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_GUITAR_HERO_WORLD_TOUR              0x4156081A

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//

#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY          0
#define CONTEXT_SEARCH_GH3_SONG_COUNT               1
#define CONTEXT_SEARCH_GH3_VENUE                    2
#define CONTEXT_SEARCH_GH3_GAME_MODE                3
#define CONTEXT_GH4_SONGS                           78
#define CONTEXT_SEARCH_GH4_HOSTING_STATE            79
#define CONTEXT_SEARCH_GH4_INSTRUMENTS              80

//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for CONTEXT_SEARCH_GH3_SONG_DIFFICULTY

#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_EASY 0
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_MEDIUM 1
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_HARD 2
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_EXPERT 3
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_BEGINNER 4

// Values for CONTEXT_SEARCH_GH3_SONG_COUNT

#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_1 0
#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_3 1
#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_5 2
#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_7 3

// Values for CONTEXT_SEARCH_GH3_VENUE

#define CONTEXT_SEARCH_GH3_VENUE_SEARCH_CON_VENUE_TEMP 0

// Values for CONTEXT_SEARCH_GH3_GAME_MODE

#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_FACEOFF_GUITAR 0
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_PRO_FACEOFF_GUITAR 1
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_BATTLE_GUITAR 2
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_2V2_PRO_FACEOFF_GUITAR 3
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_PRO_FACEOFF_DRUMS 4
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_BATTLE_DRUMS 5
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_BAND_FACEOFF 6
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_BAND_COOP 7
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_GUITAR_COOP 8
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_BAND_CAREER 9
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_FACEOFF_BASS 10
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_PRO_FACEOFF_BASS 11
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_EXTRA_1   12
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_EXTRA_2   13
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_EXTRA_3   14

// Values for CONTEXT_GH4_SONGS

#define CONTEXT_GH4_SONGS_SONG_ABOUTAGIRL           0
#define CONTEXT_GH4_SONGS_SONG_AGGRO                1
#define CONTEXT_GH4_SONGS_SONG_AMERICANWOMAN        2
#define CONTEXT_GH4_SONGS_SONG_ANTISOCIAL           3
#define CONTEXT_GH4_SONGS_SONG_AREYOUGONNAGOMYWAY   4
#define CONTEXT_GH4_SONGS_SONG_ASSASSIN             5
#define CONTEXT_GH4_SONGS_SONG_BANDONTHERUN         6
#define CONTEXT_GH4_SONGS_SONG_BEATIT               7
#define CONTEXT_GH4_SONGS_SONG_BEAUTIFULDISASTER    8
#define CONTEXT_GH4_SONGS_SONG_BOSS_TED             9
#define CONTEXT_GH4_SONGS_SONG_BOSS_WYLDE           10
#define CONTEXT_GH4_SONGS_SONG_BYOB                 11
#define CONTEXT_GH4_SONGS_SONG_CRAZYTRAIN           12
#define CONTEXT_GH4_SONGS_SONG_DAMMIT               13
#define CONTEXT_GH4_SONGS_SONG_DEMOLITIONMAN        14
#define CONTEXT_GH4_SONGS_SONG_ESCUELADECALOR       15
#define CONTEXT_GH4_SONGS_SONG_EVERLONG             16
#define CONTEXT_GH4_SONGS_SONG_EYEOFTHETIGER        17
#define CONTEXT_GH4_SONGS_SONG_FEELTHEPAIN          18
#define CONTEXT_GH4_SONGS_SONG_FLOATON              19
#define CONTEXT_GH4_SONGS_SONG_FREAKONALEASH        20
#define CONTEXT_GH4_SONGS_SONG_GOYOUROWNWAY         21
#define CONTEXT_GH4_SONGS_SONG_GOODGOD              22
#define CONTEXT_GH4_SONGS_SONG_HAILTOTHEFREAKS      23
#define CONTEXT_GH4_SONGS_SONG_HEARTBREAKER         24
#define CONTEXT_GH4_SONGS_SONG_HEYMANNICESHOT       25
#define CONTEXT_GH4_SONGS_SONG_HOLLYWOODNIGHTS      26
#define CONTEXT_GH4_SONGS_SONG_HOTFORTEACHER        27
#define CONTEXT_GH4_SONGS_SONG_HOTELCALIFORNIA      28
#define CONTEXT_GH4_SONGS_SONG_KICKOUTHEJAMS        29
#define CONTEXT_GH4_SONGS_SONG_LABAMBA              30
#define CONTEXT_GH4_SONGS_SONG_LAZYEYE              31
#define CONTEXT_GH4_SONGS_SONG_LIVINONAPRAYER       32
#define CONTEXT_GH4_SONGS_SONG_LOVEMETWOTIMES       33
#define CONTEXT_GH4_SONGS_SONG_LOVEREMOVALMACHINE   34
#define CONTEXT_GH4_SONGS_SONG_LOVESPREADS          35
#define CONTEXT_GH4_SONGS_SONG_LVIALVIAQUEZ         36
#define CONTEXT_GH4_SONGS_SONG_MISERYBUSINESS       37
#define CONTEXT_GH4_SONGS_SONG_MONSOON              38
#define CONTEXT_GH4_SONGS_SONG_MOUNTAINSONG         39
#define CONTEXT_GH4_SONGS_SONG_MRCROWLEY            40
#define CONTEXT_GH4_SONGS_SONG_NEVERTOOLATE         41
#define CONTEXT_GH4_SONGS_SONG_NOSLEEPTILLBROOKLYN  42
#define CONTEXT_GH4_SONGS_SONG_NUVOLEELENZUOLA      43
#define CONTEXT_GH4_SONGS_SONG_OBSTACLE1            44
#define CONTEXT_GH4_SONGS_SONG_ONTHEROADAGAIN       45
#define CONTEXT_GH4_SONGS_SONG_ONEARMEDSCISSOR      46
#define CONTEXT_GH4_SONGS_SONG_ONEWAYORANOTHER      47
#define CONTEXT_GH4_SONGS_SONG_OURTRUTH             48
#define CONTEXT_GH4_SONGS_SONG_OVERKILL             49
#define CONTEXT_GH4_SONGS_SONG_PARABOLA             50
#define CONTEXT_GH4_SONGS_SONG_PRETTYVACANT         51
#define CONTEXT_GH4_SONGS_SONG_PRISONEROFSOCIETY    52
#define CONTEXT_GH4_SONGS_SONG_PULLMEUNDER          53
#define CONTEXT_GH4_SONGS_SONG_PURPLEHAZE           54
#define CONTEXT_GH4_SONGS_SONG_RAMBLINMAN           55
#define CONTEXT_GH4_SONGS_SONG_REBELYELL            56
#define CONTEXT_GH4_SONGS_SONG_REEDUCATIONTHROUGHLABOR 57
#define CONTEXT_GH4_SONGS_SONG_ROOFTOPS             58
#define CONTEXT_GH4_SONGS_SONG_SANTERIA             59
#define CONTEXT_GH4_SONGS_SONG_SATCHBOOGIE          60
#define CONTEXT_GH4_SONGS_SONG_SCHISM               61
#define CONTEXT_GH4_SONGS_SONG_SCREAMAIMFIRE        62
#define CONTEXT_GH4_SONGS_SONG_SHIVER               63
#define CONTEXT_GH4_SONGS_SONG_SOMEMIGHTSAY         64
#define CONTEXT_GH4_SONGS_SONG_SOULDOUBT            65
#define CONTEXT_GH4_SONGS_SONG_SPIDERWEBS           66
#define CONTEXT_GH4_SONGS_SONG_STILLBORN            67
#define CONTEXT_GH4_SONGS_SONG_STRANGLEHOLD         68
#define CONTEXT_GH4_SONGS_SONG_SWEETHOMEALABAMA     69
#define CONTEXT_GH4_SONGS_SONG_THEJOKER             70
#define CONTEXT_GH4_SONGS_SONG_THEKILL              71
#define CONTEXT_GH4_SONGS_SONG_THEMIDDLE            72
#define CONTEXT_GH4_SONGS_SONG_THEONEILOVE          73
#define CONTEXT_GH4_SONGS_SONG_TODAY                74
#define CONTEXT_GH4_SONGS_SONG_TOOMUCHTOOYOUNGTOOFAST 75
#define CONTEXT_GH4_SONGS_SONG_TOYBOY               76
#define CONTEXT_GH4_SONGS_SONG_TRAPPEDUNDERICE      77
#define CONTEXT_GH4_SONGS_SONG_UPAROUNDTHEBEND      78
#define CONTEXT_GH4_SONGS_SONG_VICARIOUS            79
#define CONTEXT_GH4_SONGS_SONG_VINTERNOLL2          80
#define CONTEXT_GH4_SONGS_SONG_WEAPONOFCHOICE       81
#define CONTEXT_GH4_SONGS_SONG_WHATIVEDONE          82
#define CONTEXT_GH4_SONGS_SONG_WINDCRIESMARY        83
#define CONTEXT_GH4_SONGS_SONG_YOUREGONNASAYYEAH    84
#define CONTEXT_GH4_SONGS_SONG_DOWNLOAD_SONG        85
#define CONTEXT_GH4_SONGS_SONG_DOITAGAIN            86

// Values for CONTEXT_SEARCH_GH4_HOSTING_STATE

#define CONTEXT_SEARCH_GH4_HOSTING_STATE_SEARCH_CON_HOSTING_READY 0
#define CONTEXT_SEARCH_GH4_HOSTING_STATE_SEARCH_CON_HOSTING_NOT_READY 1

// Values for CONTEXT_SEARCH_GH4_INSTRUMENTS

#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_GUITAR 0
#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_BASS 1
#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_DRUMS 2
#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_MIC 3

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_MENUS                      0
#define CONTEXT_PRESENCE_BAND_CAREER                1
#define CONTEXT_PRESENCE_BAND_LOGO_EDIT_AND_INSTRUMENT_EDIT 2
#define CONTEXT_PRESENCE_CAREER                     3
#define CONTEXT_PRESENCE_GIGBOARD_AND_SETLIST       4
#define CONTEXT_PRESENCE_GUEST_PROFILE              5
#define CONTEXT_PRESENCE_HEAD_TO_HEAD               6
#define CONTEXT_PRESENCE_LEADERBOARDS               7
#define CONTEXT_PRESENCE_MUSIC_STUDIO               8
#define CONTEXT_PRESENCE_ONLINE                     9
#define CONTEXT_PRESENCE_PRACTICE                   10
#define CONTEXT_PRESENCE_QUICKPLAY                  11
#define CONTEXT_PRESENCE_ROCKSTAR_CREATOR           12
#define CONTEXT_PRESENCE_SIGNED_IN_2_3_AND_4        13
#define CONTEXT_PRESENCE_TUTORIAL                   14
#define CONTEXT_PRESENCE_VIDEOS                     15

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_ONLY_GAMEMODE             0
#define CONTEXT_GAME_MODE_BAND_CAREER               1
#define CONTEXT_GAME_MODE_SEARCH_TEST_GIDEON        2
#define CONTEXT_GAME_MODE_SEARCH_TEST_JOE           3
#define CONTEXT_GAME_MODE_SEARCH_TEST_THOMAS        4
#define CONTEXT_GAME_MODE_SEARCH_TEST_MARIO         5
#define CONTEXT_GAME_MODE_SEARCH_TEST_TIM           6
#define CONTEXT_GAME_MODE_COOP                      7
#define CONTEXT_GAME_MODE_COMPETITIVE               8

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_COLUMN_SCORE                       0x10000002
#define PROPERTY_GH3_CASH                           0x10000003
#define PROPERTY_COLUMN_WIN_LOSS                    0x10000004
#define PROPERTY_MM_GUITARS_NEEDED                  0x10000005
#define PROPERTY_MM_DRUMS_NEEDED                    0x10000006
#define PROPERTY_MM_MICROPHONES_NEEDED              0x10000007
#define PROPERTY_COLUMN_SCORE_EASY                  0x10000008
#define PROPERTY_COLUMN_SCORE_MEDIUM                0x10000009
#define PROPERTY_COLUMN_SCORE_HARD                  0x1000000A
#define PROPERTY_COLUMN_SCORE_EXPERT                0x1000000B
#define PROPERTY_MM_SONG_DIFFICULTY                 0x1000000C
#define PROPERTY_COLUMN_SORT                        0x20000001

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//

#define ACHIEVEMENT_LEARNING_THE_ROPES              6
#define ACHIEVEMENT_ONE_TIME_SOLO_ARTIST            7
#define ACHIEVEMENT_STIX                            8
#define ACHIEVEMENT_YODELER                         9
#define ACHIEVEMENT_PICK_AND_AXE                    10
#define ACHIEVEMENT_FEEDING_THE_BEAST               11
#define ACHIEVEMENT_THIS_IS_TOTALLY_LEGAL           12
#define ACHIEVEMENT_A_PAIR_BEATS_A_PAIR             13
#define ACHIEVEMENT_SURVIVAL_OF_THE_FITTEST         14
#define ACHIEVEMENT_MINE_IS_BIGGER_THAN_YOURS       15
#define ACHIEVEMENT_FIRST_OF_MANY                   16
#define ACHIEVEMENT_ONE_MAN_BAND                    17
#define ACHIEVEMENT_SHOULD_WE_STICK_TOGETHER        18
#define ACHIEVEMENT_50_NOTE_POSSE                   19
#define ACHIEVEMENT_EASY_THERE                      20
#define ACHIEVEMENT_SOLO_ARTIST                     21
#define ACHIEVEMENT_BAND_ON_A_MISSION               22
#define ACHIEVEMENT_BLING_BLING                     23
#define ACHIEVEMENT_TOP_OF_THE_CHARTS               25
#define ACHIEVEMENT_MEDIUM_MUSICIAN                 26
#define ACHIEVEMENT_SOLID_GOLD_ROCKSTARS            27
#define ACHIEVEMENT_PLATINUM_ROCKSTARS              28
#define ACHIEVEMENT_HARDCORE                        29
#define ACHIEVEMENT_HALL_OF_FAMER                   30
#define ACHIEVEMENT_JACK_OF_ALL_TRADES              31
#define ACHIEVEMENT_INKED                           32
#define ACHIEVEMENT_CUSTOM_BEATS                    33
#define ACHIEVEMENT_ONE_OF_A_KIND_AXE               34
#define ACHIEVEMENT_STAMP_OF_APPROVAL               35
#define ACHIEVEMENT_ROCK_MAIDEN                     36
#define ACHIEVEMENT_WARRIOR_OF_ROCK                 37
#define ACHIEVEMENT_THE_DARK_PRINCE                 38
#define ACHIEVEMENT_LEADING_LADY                    39
#define ACHIEVEMENT_MOTORCITY_MADMAN                40
#define ACHIEVEMENT_THE_EXPERIENCE                  41
#define ACHIEVEMENT_DONT_BLINK                      42
#define ACHIEVEMENT_PUMPKIN_SMASHER                 43
#define ACHIEVEMENT_WYLDE_MAN                       44
#define ACHIEVEMENT_SHINY_METAL_THINGY              45
#define ACHIEVEMENT_BAD_TO_THE_BONE                 46
#define ACHIEVEMENT_GUITARISTS_COAT_TAILS           47
#define ACHIEVEMENT_VOCALISTS_COAT_TAILS            48
#define ACHIEVEMENT_121_JIGOWATTS                   49
#define ACHIEVEMENT_SUPER_GROUP_UNITE               50
#define ACHIEVEMENT_AXE_MUSEUM                      51
#define ACHIEVEMENT_GET_YOUR_BOOGIE_ON              52
#define ACHIEVEMENT_MUSE_TO_MY_EARS                 53
#define ACHIEVEMENT_MIKE_CHECKA                     54
#define ACHIEVEMENT_YOURE_A_TOOL                    55
#define ACHIEVEMENT_HEAVY_METALL                    56

//
// AvatarAssetAward ids
//

#define AVATARASSETAWARD_SHOES_SHORT_BOOTS               1
#define AVATARASSETAWARD_SHOES_HIGH_BOOTS                2
#define AVATARASSETAWARD_SHOES_COSTUME                   3
#define AVATARASSETAWARD_EARING_SINGLE_LARGE_HOOP        4
#define AVATARASSETAWARD_EARING_LARGE_HOOPS              5

//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_ONLY_GAMEMODE       0xFFFF0000
#define STATS_VIEW_SKILL_RANKED_BAND_CAREER         0xFFFF0001
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_GIDEON  0xFFFF0002
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_JOE     0xFFFF0003
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_THOMAS  0xFFFF0004
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_MARIO   0xFFFF0005
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_TIM     0xFFFF0006
#define STATS_VIEW_SKILL_RANKED_COOP                0xFFFF0007
#define STATS_VIEW_SKILL_RANKED_COMPETITIVE         0xFFFF0008

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_ONLY_GAMEMODE     0xFFFE0000
#define STATS_VIEW_SKILL_STANDARD_BAND_CAREER       0xFFFE0001
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_GIDEON 0xFFFE0002
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_JOE   0xFFFE0003
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_THOMAS 0xFFFE0004
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_MARIO 0xFFFE0005
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_TIM   0xFFFE0006
#define STATS_VIEW_SKILL_STANDARD_COOP              0xFFFE0007
#define STATS_VIEW_SKILL_STANDARD_COMPETITIVE       0xFFFE0008

// Title defined leaderboards

#define STATS_VIEW_MODES                            1
#define STATS_VIEW_SONG                             2
#define STATS_VIEW_DLC243_GUITAR                    1651
#define STATS_VIEW_DLC243_BACKUP                    1652
#define STATS_VIEW_DLC243_DRUMS                     1653
#define STATS_VIEW_DLC243_MIC                       1654
#define STATS_VIEW_DLC243_BAND                      1655
#define STATS_VIEW_DLC244_GUITAR                    1656
#define STATS_VIEW_DLC244_BACKUP                    1657
#define STATS_VIEW_DLC244_DRUMS                     1658
#define STATS_VIEW_DLC244_MIC                       1659
#define STATS_VIEW_DLC244_BAND                      1660
#define STATS_VIEW_DLC245_GUITAR                    1661
#define STATS_VIEW_DLC245_BACKUP                    1662
#define STATS_VIEW_DLC245_DRUMS                     1663
#define STATS_VIEW_DLC245_MIC                       1664
#define STATS_VIEW_DLC245_BAND                      1665
#define STATS_VIEW_DLC246_GUITAR                    1666
#define STATS_VIEW_DLC246_BACKUP                    1667
#define STATS_VIEW_DLC246_DRUMS                     1668
#define STATS_VIEW_DLC246_MIC                       1669
#define STATS_VIEW_DLC246_BAND                      1670
#define STATS_VIEW_DLC247_GUITAR                    1671
#define STATS_VIEW_DLC247_BACKUP                    1672
#define STATS_VIEW_DLC247_DRUMS                     1673
#define STATS_VIEW_DLC247_MIC                       1674
#define STATS_VIEW_DLC247_BAND                      1675
#define STATS_VIEW_DLC248_GUITAR                    1676
#define STATS_VIEW_DLC248_BACKUP                    1677
#define STATS_VIEW_DLC248_DRUMS                     1678
#define STATS_VIEW_DLC248_MIC                       1679
#define STATS_VIEW_DLC248_BAND                      1680
#define STATS_VIEW_DLC249_GUITAR                    1681
#define STATS_VIEW_DLC249_BACKUP                    1682
#define STATS_VIEW_DLC249_DRUMS                     1683
#define STATS_VIEW_DLC249_MIC                       1684
#define STATS_VIEW_DLC249_BAND                      1685
#define STATS_VIEW_DLC250_GUITAR                    1686
#define STATS_VIEW_DLC250_BACKUP                    1687
#define STATS_VIEW_DLC250_DRUMS                     1688
#define STATS_VIEW_DLC250_MIC                       1689
#define STATS_VIEW_DLC250_BAND                      1690
#define STATS_VIEW_DLC251_GUITAR                    1691
#define STATS_VIEW_DLC251_BACKUP                    1692
#define STATS_VIEW_DLC251_DRUMS                     1693
#define STATS_VIEW_DLC251_MIC                       1694
#define STATS_VIEW_DLC251_BAND                      1695
#define STATS_VIEW_DLC252_GUITAR                    1696
#define STATS_VIEW_DLC252_BACKUP                    1697
#define STATS_VIEW_DLC252_DRUMS                     1698
#define STATS_VIEW_DLC252_MIC                       1699
#define STATS_VIEW_DLC252_BAND                      1700
#define STATS_VIEW_DLC253_GUITAR                    1701
#define STATS_VIEW_DLC253_BACKUP                    1702
#define STATS_VIEW_DLC253_DRUMS                     1703
#define STATS_VIEW_DLC253_MIC                       1704
#define STATS_VIEW_DLC253_BAND                      1705
#define STATS_VIEW_DLC254_GUITAR                    1706
#define STATS_VIEW_DLC254_BACKUP                    1707
#define STATS_VIEW_DLC254_DRUMS                     1708
#define STATS_VIEW_DLC254_MIC                       1709
#define STATS_VIEW_DLC254_BAND                      1710
#define STATS_VIEW_DLC255_GUITAR                    1711
#define STATS_VIEW_DLC255_BACKUP                    1712
#define STATS_VIEW_DLC255_DRUMS                     1713
#define STATS_VIEW_DLC255_MIC                       1714
#define STATS_VIEW_DLC255_BAND                      1715
#define STATS_VIEW_DLC256_GUITAR                    1716
#define STATS_VIEW_DLC256_BACKUP                    1717
#define STATS_VIEW_DLC256_DRUMS                     1718
#define STATS_VIEW_DLC256_MIC                       1719
#define STATS_VIEW_DLC256_BAND                      1720

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for MODES

#define STATS_COLUMN_MODES_COLUMN_ACCUMULATED_SCORE 1
#define STATS_COLUMN_MODES_COLUMN_SCORE             2
#define STATS_COLUMN_MODES_COLUMN_TOTAL_WINS        3
#define STATS_COLUMN_MODES_COLUMN_DIFFICULTY_HARD   4

// Column ids for SONG

#define STATS_COLUMN_SONG_COLUMN_SCORE_EASY         1
#define STATS_COLUMN_SONG_COLUMN_SCORE_MEDIUM       2
#define STATS_COLUMN_SONG_COLUMN_SCORE_HARD         3
#define STATS_COLUMN_SONG_COLUMN_SCORE_EXPERT       4

// Column ids for DLC243_GUITAR

#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_BACKUP

#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_DRUMS

#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_MIC

#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_BAND

#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_GUITAR

#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_BACKUP

#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_DRUMS

#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_MIC

#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_BAND

#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_GUITAR

#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_BACKUP

#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_DRUMS

#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_MIC

#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_BAND

#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_GUITAR

#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_BACKUP

#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_DRUMS

#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_MIC

#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_BAND

#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_GUITAR

#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_BACKUP

#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_DRUMS

#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_MIC

#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_BAND

#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_GUITAR

#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_BACKUP

#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_DRUMS

#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_MIC

#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_BAND

#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_GUITAR

#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_BACKUP

#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_DRUMS

#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_MIC

#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_BAND

#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_GUITAR

#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_BACKUP

#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_DRUMS

#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_MIC

#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_BAND

#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_GUITAR

#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_BACKUP

#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_DRUMS

#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_MIC

#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_BAND

#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_GUITAR

#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_BACKUP

#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_DRUMS

#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_MIC

#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_BAND

#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_GUITAR

#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_BACKUP

#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_DRUMS

#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_MIC

#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_BAND

#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_GUITAR

#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_BACKUP

#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_DRUMS

#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_MIC

#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_BAND

#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_GUITAR

#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_BACKUP

#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_DRUMS

#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_MIC

#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_BAND

#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_GUITAR

#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_BACKUP

#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_DRUMS

#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_MIC

#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_BAND

#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_EXPERT 4

//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//

#define SESSION_MATCH_QUERY_GH3_DEFAULT_QUERY       0
#define SESSION_MATCH_QUERY_GH4_ALT_QUERY           1

//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//



#ifdef __cplusplus
}
#endif

#endif // __GUITAR_HERO_WORLD_TOUR_SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\SuitesData\SPACFunctional\AvatarItems\Positive\FullGame\FullGameEaring-expected.spa.h ===
////////////////////////////////////////////////////////////////////
//
// FullGameEaring.spa.h
//
// Auto-generated on {*}
// XLAST project version {*}
// SPA Compiler version {*}
//
////////////////////////////////////////////////////////////////////

#ifndef __GUITAR_HERO_WORLD_TOUR_SPA_H__
#define __GUITAR_HERO_WORLD_TOUR_SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_GUITAR_HERO_WORLD_TOUR              0x4156081A

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//

#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY          0
#define CONTEXT_SEARCH_GH3_SONG_COUNT               1
#define CONTEXT_SEARCH_GH3_VENUE                    2
#define CONTEXT_SEARCH_GH3_GAME_MODE                3
#define CONTEXT_GH4_SONGS                           78
#define CONTEXT_SEARCH_GH4_HOSTING_STATE            79
#define CONTEXT_SEARCH_GH4_INSTRUMENTS              80

//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for CONTEXT_SEARCH_GH3_SONG_DIFFICULTY

#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_EASY 0
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_MEDIUM 1
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_HARD 2
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_EXPERT 3
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_BEGINNER 4

// Values for CONTEXT_SEARCH_GH3_SONG_COUNT

#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_1 0
#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_3 1
#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_5 2
#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_7 3

// Values for CONTEXT_SEARCH_GH3_VENUE

#define CONTEXT_SEARCH_GH3_VENUE_SEARCH_CON_VENUE_TEMP 0

// Values for CONTEXT_SEARCH_GH3_GAME_MODE

#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_FACEOFF_GUITAR 0
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_PRO_FACEOFF_GUITAR 1
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_BATTLE_GUITAR 2
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_2V2_PRO_FACEOFF_GUITAR 3
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_PRO_FACEOFF_DRUMS 4
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_BATTLE_DRUMS 5
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_BAND_FACEOFF 6
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_BAND_COOP 7
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_GUITAR_COOP 8
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_BAND_CAREER 9
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_FACEOFF_BASS 10
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_PRO_FACEOFF_BASS 11
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_EXTRA_1   12
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_EXTRA_2   13
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_EXTRA_3   14

// Values for CONTEXT_GH4_SONGS

#define CONTEXT_GH4_SONGS_SONG_ABOUTAGIRL           0
#define CONTEXT_GH4_SONGS_SONG_AGGRO                1
#define CONTEXT_GH4_SONGS_SONG_AMERICANWOMAN        2
#define CONTEXT_GH4_SONGS_SONG_ANTISOCIAL           3
#define CONTEXT_GH4_SONGS_SONG_AREYOUGONNAGOMYWAY   4
#define CONTEXT_GH4_SONGS_SONG_ASSASSIN             5
#define CONTEXT_GH4_SONGS_SONG_BANDONTHERUN         6
#define CONTEXT_GH4_SONGS_SONG_BEATIT               7
#define CONTEXT_GH4_SONGS_SONG_BEAUTIFULDISASTER    8
#define CONTEXT_GH4_SONGS_SONG_BOSS_TED             9
#define CONTEXT_GH4_SONGS_SONG_BOSS_WYLDE           10
#define CONTEXT_GH4_SONGS_SONG_BYOB                 11
#define CONTEXT_GH4_SONGS_SONG_CRAZYTRAIN           12
#define CONTEXT_GH4_SONGS_SONG_DAMMIT               13
#define CONTEXT_GH4_SONGS_SONG_DEMOLITIONMAN        14
#define CONTEXT_GH4_SONGS_SONG_ESCUELADECALOR       15
#define CONTEXT_GH4_SONGS_SONG_EVERLONG             16
#define CONTEXT_GH4_SONGS_SONG_EYEOFTHETIGER        17
#define CONTEXT_GH4_SONGS_SONG_FEELTHEPAIN          18
#define CONTEXT_GH4_SONGS_SONG_FLOATON              19
#define CONTEXT_GH4_SONGS_SONG_FREAKONALEASH        20
#define CONTEXT_GH4_SONGS_SONG_GOYOUROWNWAY         21
#define CONTEXT_GH4_SONGS_SONG_GOODGOD              22
#define CONTEXT_GH4_SONGS_SONG_HAILTOTHEFREAKS      23
#define CONTEXT_GH4_SONGS_SONG_HEARTBREAKER         24
#define CONTEXT_GH4_SONGS_SONG_HEYMANNICESHOT       25
#define CONTEXT_GH4_SONGS_SONG_HOLLYWOODNIGHTS      26
#define CONTEXT_GH4_SONGS_SONG_HOTFORTEACHER        27
#define CONTEXT_GH4_SONGS_SONG_HOTELCALIFORNIA      28
#define CONTEXT_GH4_SONGS_SONG_KICKOUTHEJAMS        29
#define CONTEXT_GH4_SONGS_SONG_LABAMBA              30
#define CONTEXT_GH4_SONGS_SONG_LAZYEYE              31
#define CONTEXT_GH4_SONGS_SONG_LIVINONAPRAYER       32
#define CONTEXT_GH4_SONGS_SONG_LOVEMETWOTIMES       33
#define CONTEXT_GH4_SONGS_SONG_LOVEREMOVALMACHINE   34
#define CONTEXT_GH4_SONGS_SONG_LOVESPREADS          35
#define CONTEXT_GH4_SONGS_SONG_LVIALVIAQUEZ         36
#define CONTEXT_GH4_SONGS_SONG_MISERYBUSINESS       37
#define CONTEXT_GH4_SONGS_SONG_MONSOON              38
#define CONTEXT_GH4_SONGS_SONG_MOUNTAINSONG         39
#define CONTEXT_GH4_SONGS_SONG_MRCROWLEY            40
#define CONTEXT_GH4_SONGS_SONG_NEVERTOOLATE         41
#define CONTEXT_GH4_SONGS_SONG_NOSLEEPTILLBROOKLYN  42
#define CONTEXT_GH4_SONGS_SONG_NUVOLEELENZUOLA      43
#define CONTEXT_GH4_SONGS_SONG_OBSTACLE1            44
#define CONTEXT_GH4_SONGS_SONG_ONTHEROADAGAIN       45
#define CONTEXT_GH4_SONGS_SONG_ONEARMEDSCISSOR      46
#define CONTEXT_GH4_SONGS_SONG_ONEWAYORANOTHER      47
#define CONTEXT_GH4_SONGS_SONG_OURTRUTH             48
#define CONTEXT_GH4_SONGS_SONG_OVERKILL             49
#define CONTEXT_GH4_SONGS_SONG_PARABOLA             50
#define CONTEXT_GH4_SONGS_SONG_PRETTYVACANT         51
#define CONTEXT_GH4_SONGS_SONG_PRISONEROFSOCIETY    52
#define CONTEXT_GH4_SONGS_SONG_PULLMEUNDER          53
#define CONTEXT_GH4_SONGS_SONG_PURPLEHAZE           54
#define CONTEXT_GH4_SONGS_SONG_RAMBLINMAN           55
#define CONTEXT_GH4_SONGS_SONG_REBELYELL            56
#define CONTEXT_GH4_SONGS_SONG_REEDUCATIONTHROUGHLABOR 57
#define CONTEXT_GH4_SONGS_SONG_ROOFTOPS             58
#define CONTEXT_GH4_SONGS_SONG_SANTERIA             59
#define CONTEXT_GH4_SONGS_SONG_SATCHBOOGIE          60
#define CONTEXT_GH4_SONGS_SONG_SCHISM               61
#define CONTEXT_GH4_SONGS_SONG_SCREAMAIMFIRE        62
#define CONTEXT_GH4_SONGS_SONG_SHIVER               63
#define CONTEXT_GH4_SONGS_SONG_SOMEMIGHTSAY         64
#define CONTEXT_GH4_SONGS_SONG_SOULDOUBT            65
#define CONTEXT_GH4_SONGS_SONG_SPIDERWEBS           66
#define CONTEXT_GH4_SONGS_SONG_STILLBORN            67
#define CONTEXT_GH4_SONGS_SONG_STRANGLEHOLD         68
#define CONTEXT_GH4_SONGS_SONG_SWEETHOMEALABAMA     69
#define CONTEXT_GH4_SONGS_SONG_THEJOKER             70
#define CONTEXT_GH4_SONGS_SONG_THEKILL              71
#define CONTEXT_GH4_SONGS_SONG_THEMIDDLE            72
#define CONTEXT_GH4_SONGS_SONG_THEONEILOVE          73
#define CONTEXT_GH4_SONGS_SONG_TODAY                74
#define CONTEXT_GH4_SONGS_SONG_TOOMUCHTOOYOUNGTOOFAST 75
#define CONTEXT_GH4_SONGS_SONG_TOYBOY               76
#define CONTEXT_GH4_SONGS_SONG_TRAPPEDUNDERICE      77
#define CONTEXT_GH4_SONGS_SONG_UPAROUNDTHEBEND      78
#define CONTEXT_GH4_SONGS_SONG_VICARIOUS            79
#define CONTEXT_GH4_SONGS_SONG_VINTERNOLL2          80
#define CONTEXT_GH4_SONGS_SONG_WEAPONOFCHOICE       81
#define CONTEXT_GH4_SONGS_SONG_WHATIVEDONE          82
#define CONTEXT_GH4_SONGS_SONG_WINDCRIESMARY        83
#define CONTEXT_GH4_SONGS_SONG_YOUREGONNASAYYEAH    84
#define CONTEXT_GH4_SONGS_SONG_DOWNLOAD_SONG        85
#define CONTEXT_GH4_SONGS_SONG_DOITAGAIN            86

// Values for CONTEXT_SEARCH_GH4_HOSTING_STATE

#define CONTEXT_SEARCH_GH4_HOSTING_STATE_SEARCH_CON_HOSTING_READY 0
#define CONTEXT_SEARCH_GH4_HOSTING_STATE_SEARCH_CON_HOSTING_NOT_READY 1

// Values for CONTEXT_SEARCH_GH4_INSTRUMENTS

#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_GUITAR 0
#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_BASS 1
#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_DRUMS 2
#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_MIC 3

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_MENUS                      0
#define CONTEXT_PRESENCE_BAND_CAREER                1
#define CONTEXT_PRESENCE_BAND_LOGO_EDIT_AND_INSTRUMENT_EDIT 2
#define CONTEXT_PRESENCE_CAREER                     3
#define CONTEXT_PRESENCE_GIGBOARD_AND_SETLIST       4
#define CONTEXT_PRESENCE_GUEST_PROFILE              5
#define CONTEXT_PRESENCE_HEAD_TO_HEAD               6
#define CONTEXT_PRESENCE_LEADERBOARDS               7
#define CONTEXT_PRESENCE_MUSIC_STUDIO               8
#define CONTEXT_PRESENCE_ONLINE                     9
#define CONTEXT_PRESENCE_PRACTICE                   10
#define CONTEXT_PRESENCE_QUICKPLAY                  11
#define CONTEXT_PRESENCE_ROCKSTAR_CREATOR           12
#define CONTEXT_PRESENCE_SIGNED_IN_2_3_AND_4        13
#define CONTEXT_PRESENCE_TUTORIAL                   14
#define CONTEXT_PRESENCE_VIDEOS                     15

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_ONLY_GAMEMODE             0
#define CONTEXT_GAME_MODE_BAND_CAREER               1
#define CONTEXT_GAME_MODE_SEARCH_TEST_GIDEON        2
#define CONTEXT_GAME_MODE_SEARCH_TEST_JOE           3
#define CONTEXT_GAME_MODE_SEARCH_TEST_THOMAS        4
#define CONTEXT_GAME_MODE_SEARCH_TEST_MARIO         5
#define CONTEXT_GAME_MODE_SEARCH_TEST_TIM           6
#define CONTEXT_GAME_MODE_COOP                      7
#define CONTEXT_GAME_MODE_COMPETITIVE               8

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_COLUMN_SCORE                       0x10000002
#define PROPERTY_GH3_CASH                           0x10000003
#define PROPERTY_COLUMN_WIN_LOSS                    0x10000004
#define PROPERTY_MM_GUITARS_NEEDED                  0x10000005
#define PROPERTY_MM_DRUMS_NEEDED                    0x10000006
#define PROPERTY_MM_MICROPHONES_NEEDED              0x10000007
#define PROPERTY_COLUMN_SCORE_EASY                  0x10000008
#define PROPERTY_COLUMN_SCORE_MEDIUM                0x10000009
#define PROPERTY_COLUMN_SCORE_HARD                  0x1000000A
#define PROPERTY_COLUMN_SCORE_EXPERT                0x1000000B
#define PROPERTY_MM_SONG_DIFFICULTY                 0x1000000C
#define PROPERTY_COLUMN_SORT                        0x20000001

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//

#define ACHIEVEMENT_LEARNING_THE_ROPES              6
#define ACHIEVEMENT_ONE_TIME_SOLO_ARTIST            7
#define ACHIEVEMENT_STIX                            8
#define ACHIEVEMENT_YODELER                         9
#define ACHIEVEMENT_PICK_AND_AXE                    10
#define ACHIEVEMENT_FEEDING_THE_BEAST               11
#define ACHIEVEMENT_THIS_IS_TOTALLY_LEGAL           12
#define ACHIEVEMENT_A_PAIR_BEATS_A_PAIR             13
#define ACHIEVEMENT_SURVIVAL_OF_THE_FITTEST         14
#define ACHIEVEMENT_MINE_IS_BIGGER_THAN_YOURS       15
#define ACHIEVEMENT_FIRST_OF_MANY                   16
#define ACHIEVEMENT_ONE_MAN_BAND                    17
#define ACHIEVEMENT_SHOULD_WE_STICK_TOGETHER        18
#define ACHIEVEMENT_50_NOTE_POSSE                   19
#define ACHIEVEMENT_EASY_THERE                      20
#define ACHIEVEMENT_SOLO_ARTIST                     21
#define ACHIEVEMENT_BAND_ON_A_MISSION               22
#define ACHIEVEMENT_BLING_BLING                     23
#define ACHIEVEMENT_TOP_OF_THE_CHARTS               25
#define ACHIEVEMENT_MEDIUM_MUSICIAN                 26
#define ACHIEVEMENT_SOLID_GOLD_ROCKSTARS            27
#define ACHIEVEMENT_PLATINUM_ROCKSTARS              28
#define ACHIEVEMENT_HARDCORE                        29
#define ACHIEVEMENT_HALL_OF_FAMER                   30
#define ACHIEVEMENT_JACK_OF_ALL_TRADES              31
#define ACHIEVEMENT_INKED                           32
#define ACHIEVEMENT_CUSTOM_BEATS                    33
#define ACHIEVEMENT_ONE_OF_A_KIND_AXE               34
#define ACHIEVEMENT_STAMP_OF_APPROVAL               35
#define ACHIEVEMENT_ROCK_MAIDEN                     36
#define ACHIEVEMENT_WARRIOR_OF_ROCK                 37
#define ACHIEVEMENT_THE_DARK_PRINCE                 38
#define ACHIEVEMENT_LEADING_LADY                    39
#define ACHIEVEMENT_MOTORCITY_MADMAN                40
#define ACHIEVEMENT_THE_EXPERIENCE                  41
#define ACHIEVEMENT_DONT_BLINK                      42
#define ACHIEVEMENT_PUMPKIN_SMASHER                 43
#define ACHIEVEMENT_WYLDE_MAN                       44
#define ACHIEVEMENT_SHINY_METAL_THINGY              45
#define ACHIEVEMENT_BAD_TO_THE_BONE                 46
#define ACHIEVEMENT_GUITARISTS_COAT_TAILS           47
#define ACHIEVEMENT_VOCALISTS_COAT_TAILS            48
#define ACHIEVEMENT_121_JIGOWATTS                   49
#define ACHIEVEMENT_SUPER_GROUP_UNITE               50
#define ACHIEVEMENT_AXE_MUSEUM                      51
#define ACHIEVEMENT_GET_YOUR_BOOGIE_ON              52
#define ACHIEVEMENT_MUSE_TO_MY_EARS                 53
#define ACHIEVEMENT_MIKE_CHECKA                     54
#define ACHIEVEMENT_YOURE_A_TOOL                    55
#define ACHIEVEMENT_HEAVY_METALL                    56

//
// AvatarAssetAward ids
//

#define AVATARASSETAWARD_EARING_SINGLE_STUD              1
#define AVATARASSETAWARD_EARING_STUDS                    2
#define AVATARASSETAWARD_EARING_SINGLE_DANGLER           3
#define AVATARASSETAWARD_EARING_SINGLE_SMALL_HOOP        4
#define AVATARASSETAWARD_EARING_SMALL_HOOPS              5

//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_ONLY_GAMEMODE       0xFFFF0000
#define STATS_VIEW_SKILL_RANKED_BAND_CAREER         0xFFFF0001
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_GIDEON  0xFFFF0002
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_JOE     0xFFFF0003
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_THOMAS  0xFFFF0004
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_MARIO   0xFFFF0005
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_TIM     0xFFFF0006
#define STATS_VIEW_SKILL_RANKED_COOP                0xFFFF0007
#define STATS_VIEW_SKILL_RANKED_COMPETITIVE         0xFFFF0008

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_ONLY_GAMEMODE     0xFFFE0000
#define STATS_VIEW_SKILL_STANDARD_BAND_CAREER       0xFFFE0001
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_GIDEON 0xFFFE0002
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_JOE   0xFFFE0003
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_THOMAS 0xFFFE0004
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_MARIO 0xFFFE0005
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_TIM   0xFFFE0006
#define STATS_VIEW_SKILL_STANDARD_COOP              0xFFFE0007
#define STATS_VIEW_SKILL_STANDARD_COMPETITIVE       0xFFFE0008

// Title defined leaderboards

#define STATS_VIEW_MODES                            1
#define STATS_VIEW_SONG                             2
#define STATS_VIEW_DLC243_GUITAR                    1651
#define STATS_VIEW_DLC243_BACKUP                    1652
#define STATS_VIEW_DLC243_DRUMS                     1653
#define STATS_VIEW_DLC243_MIC                       1654
#define STATS_VIEW_DLC243_BAND                      1655
#define STATS_VIEW_DLC244_GUITAR                    1656
#define STATS_VIEW_DLC244_BACKUP                    1657
#define STATS_VIEW_DLC244_DRUMS                     1658
#define STATS_VIEW_DLC244_MIC                       1659
#define STATS_VIEW_DLC244_BAND                      1660
#define STATS_VIEW_DLC245_GUITAR                    1661
#define STATS_VIEW_DLC245_BACKUP                    1662
#define STATS_VIEW_DLC245_DRUMS                     1663
#define STATS_VIEW_DLC245_MIC                       1664
#define STATS_VIEW_DLC245_BAND                      1665
#define STATS_VIEW_DLC246_GUITAR                    1666
#define STATS_VIEW_DLC246_BACKUP                    1667
#define STATS_VIEW_DLC246_DRUMS                     1668
#define STATS_VIEW_DLC246_MIC                       1669
#define STATS_VIEW_DLC246_BAND                      1670
#define STATS_VIEW_DLC247_GUITAR                    1671
#define STATS_VIEW_DLC247_BACKUP                    1672
#define STATS_VIEW_DLC247_DRUMS                     1673
#define STATS_VIEW_DLC247_MIC                       1674
#define STATS_VIEW_DLC247_BAND                      1675
#define STATS_VIEW_DLC248_GUITAR                    1676
#define STATS_VIEW_DLC248_BACKUP                    1677
#define STATS_VIEW_DLC248_DRUMS                     1678
#define STATS_VIEW_DLC248_MIC                       1679
#define STATS_VIEW_DLC248_BAND                      1680
#define STATS_VIEW_DLC249_GUITAR                    1681
#define STATS_VIEW_DLC249_BACKUP                    1682
#define STATS_VIEW_DLC249_DRUMS                     1683
#define STATS_VIEW_DLC249_MIC                       1684
#define STATS_VIEW_DLC249_BAND                      1685
#define STATS_VIEW_DLC250_GUITAR                    1686
#define STATS_VIEW_DLC250_BACKUP                    1687
#define STATS_VIEW_DLC250_DRUMS                     1688
#define STATS_VIEW_DLC250_MIC                       1689
#define STATS_VIEW_DLC250_BAND                      1690
#define STATS_VIEW_DLC251_GUITAR                    1691
#define STATS_VIEW_DLC251_BACKUP                    1692
#define STATS_VIEW_DLC251_DRUMS                     1693
#define STATS_VIEW_DLC251_MIC                       1694
#define STATS_VIEW_DLC251_BAND                      1695
#define STATS_VIEW_DLC252_GUITAR                    1696
#define STATS_VIEW_DLC252_BACKUP                    1697
#define STATS_VIEW_DLC252_DRUMS                     1698
#define STATS_VIEW_DLC252_MIC                       1699
#define STATS_VIEW_DLC252_BAND                      1700
#define STATS_VIEW_DLC253_GUITAR                    1701
#define STATS_VIEW_DLC253_BACKUP                    1702
#define STATS_VIEW_DLC253_DRUMS                     1703
#define STATS_VIEW_DLC253_MIC                       1704
#define STATS_VIEW_DLC253_BAND                      1705
#define STATS_VIEW_DLC254_GUITAR                    1706
#define STATS_VIEW_DLC254_BACKUP                    1707
#define STATS_VIEW_DLC254_DRUMS                     1708
#define STATS_VIEW_DLC254_MIC                       1709
#define STATS_VIEW_DLC254_BAND                      1710
#define STATS_VIEW_DLC255_GUITAR                    1711
#define STATS_VIEW_DLC255_BACKUP                    1712
#define STATS_VIEW_DLC255_DRUMS                     1713
#define STATS_VIEW_DLC255_MIC                       1714
#define STATS_VIEW_DLC255_BAND                      1715
#define STATS_VIEW_DLC256_GUITAR                    1716
#define STATS_VIEW_DLC256_BACKUP                    1717
#define STATS_VIEW_DLC256_DRUMS                     1718
#define STATS_VIEW_DLC256_MIC                       1719
#define STATS_VIEW_DLC256_BAND                      1720

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for MODES

#define STATS_COLUMN_MODES_COLUMN_ACCUMULATED_SCORE 1
#define STATS_COLUMN_MODES_COLUMN_SCORE             2
#define STATS_COLUMN_MODES_COLUMN_TOTAL_WINS        3
#define STATS_COLUMN_MODES_COLUMN_DIFFICULTY_HARD   4

// Column ids for SONG

#define STATS_COLUMN_SONG_COLUMN_SCORE_EASY         1
#define STATS_COLUMN_SONG_COLUMN_SCORE_MEDIUM       2
#define STATS_COLUMN_SONG_COLUMN_SCORE_HARD         3
#define STATS_COLUMN_SONG_COLUMN_SCORE_EXPERT       4

// Column ids for DLC243_GUITAR

#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_BACKUP

#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_DRUMS

#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_MIC

#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_BAND

#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_GUITAR

#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_BACKUP

#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_DRUMS

#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_MIC

#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_BAND

#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_GUITAR

#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_BACKUP

#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_DRUMS

#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_MIC

#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_BAND

#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_GUITAR

#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_BACKUP

#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_DRUMS

#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_MIC

#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_BAND

#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_GUITAR

#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_BACKUP

#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_DRUMS

#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_MIC

#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_BAND

#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_GUITAR

#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_BACKUP

#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_DRUMS

#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_MIC

#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_BAND

#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_GUITAR

#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_BACKUP

#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_DRUMS

#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_MIC

#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_BAND

#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_GUITAR

#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_BACKUP

#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_DRUMS

#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_MIC

#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_BAND

#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_GUITAR

#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_BACKUP

#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_DRUMS

#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_MIC

#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_BAND

#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_GUITAR

#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_BACKUP

#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_DRUMS

#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_MIC

#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_BAND

#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_GUITAR

#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_BACKUP

#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_DRUMS

#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_MIC

#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_BAND

#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_GUITAR

#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_BACKUP

#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_DRUMS

#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_MIC

#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_BAND

#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_GUITAR

#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_BACKUP

#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_DRUMS

#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_MIC

#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_BAND

#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_GUITAR

#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_BACKUP

#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_DRUMS

#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_MIC

#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_BAND

#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_EXPERT 4

//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//

#define SESSION_MATCH_QUERY_GH3_DEFAULT_QUERY       0
#define SESSION_MATCH_QUERY_GH4_ALT_QUERY           1

//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//



#ifdef __cplusplus
}
#endif

#endif // __GUITAR_HERO_WORLD_TOUR_SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\SuitesData\SPACFunctional\AvatarItems\Positive\FullGame\FullGame-Hat-expected.spa.h ===
////////////////////////////////////////////////////////////////////
//
// FullGame-Hat.spa.h
//
// Auto-generated on {*}
// XLAST project version {*}
// SPA Compiler version {*}
//
////////////////////////////////////////////////////////////////////

#ifndef __GUITAR_HERO_WORLD_TOUR_SPA_H__
#define __GUITAR_HERO_WORLD_TOUR_SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_GUITAR_HERO_WORLD_TOUR              0x4156081A

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//

#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY          0
#define CONTEXT_SEARCH_GH3_SONG_COUNT               1
#define CONTEXT_SEARCH_GH3_VENUE                    2
#define CONTEXT_SEARCH_GH3_GAME_MODE                3
#define CONTEXT_GH4_SONGS                           78
#define CONTEXT_SEARCH_GH4_HOSTING_STATE            79
#define CONTEXT_SEARCH_GH4_INSTRUMENTS              80

//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for CONTEXT_SEARCH_GH3_SONG_DIFFICULTY

#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_EASY 0
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_MEDIUM 1
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_HARD 2
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_EXPERT 3
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_BEGINNER 4

// Values for CONTEXT_SEARCH_GH3_SONG_COUNT

#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_1 0
#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_3 1
#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_5 2
#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_7 3

// Values for CONTEXT_SEARCH_GH3_VENUE

#define CONTEXT_SEARCH_GH3_VENUE_SEARCH_CON_VENUE_TEMP 0

// Values for CONTEXT_SEARCH_GH3_GAME_MODE

#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_FACEOFF_GUITAR 0
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_PRO_FACEOFF_GUITAR 1
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_BATTLE_GUITAR 2
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_2V2_PRO_FACEOFF_GUITAR 3
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_PRO_FACEOFF_DRUMS 4
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_BATTLE_DRUMS 5
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_BAND_FACEOFF 6
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_BAND_COOP 7
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_GUITAR_COOP 8
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_BAND_CAREER 9
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_FACEOFF_BASS 10
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_PRO_FACEOFF_BASS 11
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_EXTRA_1   12
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_EXTRA_2   13
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_EXTRA_3   14

// Values for CONTEXT_GH4_SONGS

#define CONTEXT_GH4_SONGS_SONG_ABOUTAGIRL           0
#define CONTEXT_GH4_SONGS_SONG_AGGRO                1
#define CONTEXT_GH4_SONGS_SONG_AMERICANWOMAN        2
#define CONTEXT_GH4_SONGS_SONG_ANTISOCIAL           3
#define CONTEXT_GH4_SONGS_SONG_AREYOUGONNAGOMYWAY   4
#define CONTEXT_GH4_SONGS_SONG_ASSASSIN             5
#define CONTEXT_GH4_SONGS_SONG_BANDONTHERUN         6
#define CONTEXT_GH4_SONGS_SONG_BEATIT               7
#define CONTEXT_GH4_SONGS_SONG_BEAUTIFULDISASTER    8
#define CONTEXT_GH4_SONGS_SONG_BOSS_TED             9
#define CONTEXT_GH4_SONGS_SONG_BOSS_WYLDE           10
#define CONTEXT_GH4_SONGS_SONG_BYOB                 11
#define CONTEXT_GH4_SONGS_SONG_CRAZYTRAIN           12
#define CONTEXT_GH4_SONGS_SONG_DAMMIT               13
#define CONTEXT_GH4_SONGS_SONG_DEMOLITIONMAN        14
#define CONTEXT_GH4_SONGS_SONG_ESCUELADECALOR       15
#define CONTEXT_GH4_SONGS_SONG_EVERLONG             16
#define CONTEXT_GH4_SONGS_SONG_EYEOFTHETIGER        17
#define CONTEXT_GH4_SONGS_SONG_FEELTHEPAIN          18
#define CONTEXT_GH4_SONGS_SONG_FLOATON              19
#define CONTEXT_GH4_SONGS_SONG_FREAKONALEASH        20
#define CONTEXT_GH4_SONGS_SONG_GOYOUROWNWAY         21
#define CONTEXT_GH4_SONGS_SONG_GOODGOD              22
#define CONTEXT_GH4_SONGS_SONG_HAILTOTHEFREAKS      23
#define CONTEXT_GH4_SONGS_SONG_HEARTBREAKER         24
#define CONTEXT_GH4_SONGS_SONG_HEYMANNICESHOT       25
#define CONTEXT_GH4_SONGS_SONG_HOLLYWOODNIGHTS      26
#define CONTEXT_GH4_SONGS_SONG_HOTFORTEACHER        27
#define CONTEXT_GH4_SONGS_SONG_HOTELCALIFORNIA      28
#define CONTEXT_GH4_SONGS_SONG_KICKOUTHEJAMS        29
#define CONTEXT_GH4_SONGS_SONG_LABAMBA              30
#define CONTEXT_GH4_SONGS_SONG_LAZYEYE              31
#define CONTEXT_GH4_SONGS_SONG_LIVINONAPRAYER       32
#define CONTEXT_GH4_SONGS_SONG_LOVEMETWOTIMES       33
#define CONTEXT_GH4_SONGS_SONG_LOVEREMOVALMACHINE   34
#define CONTEXT_GH4_SONGS_SONG_LOVESPREADS          35
#define CONTEXT_GH4_SONGS_SONG_LVIALVIAQUEZ         36
#define CONTEXT_GH4_SONGS_SONG_MISERYBUSINESS       37
#define CONTEXT_GH4_SONGS_SONG_MONSOON              38
#define CONTEXT_GH4_SONGS_SONG_MOUNTAINSONG         39
#define CONTEXT_GH4_SONGS_SONG_MRCROWLEY            40
#define CONTEXT_GH4_SONGS_SONG_NEVERTOOLATE         41
#define CONTEXT_GH4_SONGS_SONG_NOSLEEPTILLBROOKLYN  42
#define CONTEXT_GH4_SONGS_SONG_NUVOLEELENZUOLA      43
#define CONTEXT_GH4_SONGS_SONG_OBSTACLE1            44
#define CONTEXT_GH4_SONGS_SONG_ONTHEROADAGAIN       45
#define CONTEXT_GH4_SONGS_SONG_ONEARMEDSCISSOR      46
#define CONTEXT_GH4_SONGS_SONG_ONEWAYORANOTHER      47
#define CONTEXT_GH4_SONGS_SONG_OURTRUTH             48
#define CONTEXT_GH4_SONGS_SONG_OVERKILL             49
#define CONTEXT_GH4_SONGS_SONG_PARABOLA             50
#define CONTEXT_GH4_SONGS_SONG_PRETTYVACANT         51
#define CONTEXT_GH4_SONGS_SONG_PRISONEROFSOCIETY    52
#define CONTEXT_GH4_SONGS_SONG_PULLMEUNDER          53
#define CONTEXT_GH4_SONGS_SONG_PURPLEHAZE           54
#define CONTEXT_GH4_SONGS_SONG_RAMBLINMAN           55
#define CONTEXT_GH4_SONGS_SONG_REBELYELL            56
#define CONTEXT_GH4_SONGS_SONG_REEDUCATIONTHROUGHLABOR 57
#define CONTEXT_GH4_SONGS_SONG_ROOFTOPS             58
#define CONTEXT_GH4_SONGS_SONG_SANTERIA             59
#define CONTEXT_GH4_SONGS_SONG_SATCHBOOGIE          60
#define CONTEXT_GH4_SONGS_SONG_SCHISM               61
#define CONTEXT_GH4_SONGS_SONG_SCREAMAIMFIRE        62
#define CONTEXT_GH4_SONGS_SONG_SHIVER               63
#define CONTEXT_GH4_SONGS_SONG_SOMEMIGHTSAY         64
#define CONTEXT_GH4_SONGS_SONG_SOULDOUBT            65
#define CONTEXT_GH4_SONGS_SONG_SPIDERWEBS           66
#define CONTEXT_GH4_SONGS_SONG_STILLBORN            67
#define CONTEXT_GH4_SONGS_SONG_STRANGLEHOLD         68
#define CONTEXT_GH4_SONGS_SONG_SWEETHOMEALABAMA     69
#define CONTEXT_GH4_SONGS_SONG_THEJOKER             70
#define CONTEXT_GH4_SONGS_SONG_THEKILL              71
#define CONTEXT_GH4_SONGS_SONG_THEMIDDLE            72
#define CONTEXT_GH4_SONGS_SONG_THEONEILOVE          73
#define CONTEXT_GH4_SONGS_SONG_TODAY                74
#define CONTEXT_GH4_SONGS_SONG_TOOMUCHTOOYOUNGTOOFAST 75
#define CONTEXT_GH4_SONGS_SONG_TOYBOY               76
#define CONTEXT_GH4_SONGS_SONG_TRAPPEDUNDERICE      77
#define CONTEXT_GH4_SONGS_SONG_UPAROUNDTHEBEND      78
#define CONTEXT_GH4_SONGS_SONG_VICARIOUS            79
#define CONTEXT_GH4_SONGS_SONG_VINTERNOLL2          80
#define CONTEXT_GH4_SONGS_SONG_WEAPONOFCHOICE       81
#define CONTEXT_GH4_SONGS_SONG_WHATIVEDONE          82
#define CONTEXT_GH4_SONGS_SONG_WINDCRIESMARY        83
#define CONTEXT_GH4_SONGS_SONG_YOUREGONNASAYYEAH    84
#define CONTEXT_GH4_SONGS_SONG_DOWNLOAD_SONG        85
#define CONTEXT_GH4_SONGS_SONG_DOITAGAIN            86

// Values for CONTEXT_SEARCH_GH4_HOSTING_STATE

#define CONTEXT_SEARCH_GH4_HOSTING_STATE_SEARCH_CON_HOSTING_READY 0
#define CONTEXT_SEARCH_GH4_HOSTING_STATE_SEARCH_CON_HOSTING_NOT_READY 1

// Values for CONTEXT_SEARCH_GH4_INSTRUMENTS

#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_GUITAR 0
#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_BASS 1
#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_DRUMS 2
#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_MIC 3

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_MENUS                      0
#define CONTEXT_PRESENCE_BAND_CAREER                1
#define CONTEXT_PRESENCE_BAND_LOGO_EDIT_AND_INSTRUMENT_EDIT 2
#define CONTEXT_PRESENCE_CAREER                     3
#define CONTEXT_PRESENCE_GIGBOARD_AND_SETLIST       4
#define CONTEXT_PRESENCE_GUEST_PROFILE              5
#define CONTEXT_PRESENCE_HEAD_TO_HEAD               6
#define CONTEXT_PRESENCE_LEADERBOARDS               7
#define CONTEXT_PRESENCE_MUSIC_STUDIO               8
#define CONTEXT_PRESENCE_ONLINE                     9
#define CONTEXT_PRESENCE_PRACTICE                   10
#define CONTEXT_PRESENCE_QUICKPLAY                  11
#define CONTEXT_PRESENCE_ROCKSTAR_CREATOR           12
#define CONTEXT_PRESENCE_SIGNED_IN_2_3_AND_4        13
#define CONTEXT_PRESENCE_TUTORIAL                   14
#define CONTEXT_PRESENCE_VIDEOS                     15

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_ONLY_GAMEMODE             0
#define CONTEXT_GAME_MODE_BAND_CAREER               1
#define CONTEXT_GAME_MODE_SEARCH_TEST_GIDEON        2
#define CONTEXT_GAME_MODE_SEARCH_TEST_JOE           3
#define CONTEXT_GAME_MODE_SEARCH_TEST_THOMAS        4
#define CONTEXT_GAME_MODE_SEARCH_TEST_MARIO         5
#define CONTEXT_GAME_MODE_SEARCH_TEST_TIM           6
#define CONTEXT_GAME_MODE_COOP                      7
#define CONTEXT_GAME_MODE_COMPETITIVE               8

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_COLUMN_SCORE                       0x10000002
#define PROPERTY_GH3_CASH                           0x10000003
#define PROPERTY_COLUMN_WIN_LOSS                    0x10000004
#define PROPERTY_MM_GUITARS_NEEDED                  0x10000005
#define PROPERTY_MM_DRUMS_NEEDED                    0x10000006
#define PROPERTY_MM_MICROPHONES_NEEDED              0x10000007
#define PROPERTY_COLUMN_SCORE_EASY                  0x10000008
#define PROPERTY_COLUMN_SCORE_MEDIUM                0x10000009
#define PROPERTY_COLUMN_SCORE_HARD                  0x1000000A
#define PROPERTY_COLUMN_SCORE_EXPERT                0x1000000B
#define PROPERTY_MM_SONG_DIFFICULTY                 0x1000000C
#define PROPERTY_COLUMN_SORT                        0x20000001

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//

#define ACHIEVEMENT_LEARNING_THE_ROPES              6
#define ACHIEVEMENT_ONE_TIME_SOLO_ARTIST            7
#define ACHIEVEMENT_STIX                            8
#define ACHIEVEMENT_YODELER                         9
#define ACHIEVEMENT_PICK_AND_AXE                    10
#define ACHIEVEMENT_FEEDING_THE_BEAST               11
#define ACHIEVEMENT_THIS_IS_TOTALLY_LEGAL           12
#define ACHIEVEMENT_A_PAIR_BEATS_A_PAIR             13
#define ACHIEVEMENT_SURVIVAL_OF_THE_FITTEST         14
#define ACHIEVEMENT_MINE_IS_BIGGER_THAN_YOURS       15
#define ACHIEVEMENT_FIRST_OF_MANY                   16
#define ACHIEVEMENT_ONE_MAN_BAND                    17
#define ACHIEVEMENT_SHOULD_WE_STICK_TOGETHER        18
#define ACHIEVEMENT_50_NOTE_POSSE                   19
#define ACHIEVEMENT_EASY_THERE                      20
#define ACHIEVEMENT_SOLO_ARTIST                     21
#define ACHIEVEMENT_BAND_ON_A_MISSION               22
#define ACHIEVEMENT_BLING_BLING                     23
#define ACHIEVEMENT_TOP_OF_THE_CHARTS               25
#define ACHIEVEMENT_MEDIUM_MUSICIAN                 26
#define ACHIEVEMENT_SOLID_GOLD_ROCKSTARS            27
#define ACHIEVEMENT_PLATINUM_ROCKSTARS              28
#define ACHIEVEMENT_HARDCORE                        29
#define ACHIEVEMENT_HALL_OF_FAMER                   30
#define ACHIEVEMENT_JACK_OF_ALL_TRADES              31
#define ACHIEVEMENT_INKED                           32
#define ACHIEVEMENT_CUSTOM_BEATS                    33
#define ACHIEVEMENT_ONE_OF_A_KIND_AXE               34
#define ACHIEVEMENT_STAMP_OF_APPROVAL               35
#define ACHIEVEMENT_ROCK_MAIDEN                     36
#define ACHIEVEMENT_WARRIOR_OF_ROCK                 37
#define ACHIEVEMENT_THE_DARK_PRINCE                 38
#define ACHIEVEMENT_LEADING_LADY                    39
#define ACHIEVEMENT_MOTORCITY_MADMAN                40
#define ACHIEVEMENT_THE_EXPERIENCE                  41
#define ACHIEVEMENT_DONT_BLINK                      42
#define ACHIEVEMENT_PUMPKIN_SMASHER                 43
#define ACHIEVEMENT_WYLDE_MAN                       44
#define ACHIEVEMENT_SHINY_METAL_THINGY              45
#define ACHIEVEMENT_BAD_TO_THE_BONE                 46
#define ACHIEVEMENT_GUITARISTS_COAT_TAILS           47
#define ACHIEVEMENT_VOCALISTS_COAT_TAILS            48
#define ACHIEVEMENT_121_JIGOWATTS                   49
#define ACHIEVEMENT_SUPER_GROUP_UNITE               50
#define ACHIEVEMENT_AXE_MUSEUM                      51
#define ACHIEVEMENT_GET_YOUR_BOOGIE_ON              52
#define ACHIEVEMENT_MUSE_TO_MY_EARS                 53
#define ACHIEVEMENT_MIKE_CHECKA                     54
#define ACHIEVEMENT_YOURE_A_TOOL                    55
#define ACHIEVEMENT_HEAVY_METALL                    56

//
// AvatarAssetAward ids
//

#define AVATARASSETAWARD_HAT_BEANIE                      1
#define AVATARASSETAWARD_HAT_FLAT_CAP                    2
#define AVATARASSETAWARD_HAT_BASEBALL_CAP                3
#define AVATARASSETAWARD_HAT_PEAK_CAP                    4
#define AVATARASSETAWARD_HAT_BRIMMED                     5

//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_ONLY_GAMEMODE       0xFFFF0000
#define STATS_VIEW_SKILL_RANKED_BAND_CAREER         0xFFFF0001
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_GIDEON  0xFFFF0002
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_JOE     0xFFFF0003
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_THOMAS  0xFFFF0004
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_MARIO   0xFFFF0005
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_TIM     0xFFFF0006
#define STATS_VIEW_SKILL_RANKED_COOP                0xFFFF0007
#define STATS_VIEW_SKILL_RANKED_COMPETITIVE         0xFFFF0008

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_ONLY_GAMEMODE     0xFFFE0000
#define STATS_VIEW_SKILL_STANDARD_BAND_CAREER       0xFFFE0001
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_GIDEON 0xFFFE0002
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_JOE   0xFFFE0003
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_THOMAS 0xFFFE0004
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_MARIO 0xFFFE0005
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_TIM   0xFFFE0006
#define STATS_VIEW_SKILL_STANDARD_COOP              0xFFFE0007
#define STATS_VIEW_SKILL_STANDARD_COMPETITIVE       0xFFFE0008

// Title defined leaderboards

#define STATS_VIEW_MODES                            1
#define STATS_VIEW_SONG                             2
#define STATS_VIEW_DLC243_GUITAR                    1651
#define STATS_VIEW_DLC243_BACKUP                    1652
#define STATS_VIEW_DLC243_DRUMS                     1653
#define STATS_VIEW_DLC243_MIC                       1654
#define STATS_VIEW_DLC243_BAND                      1655
#define STATS_VIEW_DLC244_GUITAR                    1656
#define STATS_VIEW_DLC244_BACKUP                    1657
#define STATS_VIEW_DLC244_DRUMS                     1658
#define STATS_VIEW_DLC244_MIC                       1659
#define STATS_VIEW_DLC244_BAND                      1660
#define STATS_VIEW_DLC245_GUITAR                    1661
#define STATS_VIEW_DLC245_BACKUP                    1662
#define STATS_VIEW_DLC245_DRUMS                     1663
#define STATS_VIEW_DLC245_MIC                       1664
#define STATS_VIEW_DLC245_BAND                      1665
#define STATS_VIEW_DLC246_GUITAR                    1666
#define STATS_VIEW_DLC246_BACKUP                    1667
#define STATS_VIEW_DLC246_DRUMS                     1668
#define STATS_VIEW_DLC246_MIC                       1669
#define STATS_VIEW_DLC246_BAND                      1670
#define STATS_VIEW_DLC247_GUITAR                    1671
#define STATS_VIEW_DLC247_BACKUP                    1672
#define STATS_VIEW_DLC247_DRUMS                     1673
#define STATS_VIEW_DLC247_MIC                       1674
#define STATS_VIEW_DLC247_BAND                      1675
#define STATS_VIEW_DLC248_GUITAR                    1676
#define STATS_VIEW_DLC248_BACKUP                    1677
#define STATS_VIEW_DLC248_DRUMS                     1678
#define STATS_VIEW_DLC248_MIC                       1679
#define STATS_VIEW_DLC248_BAND                      1680
#define STATS_VIEW_DLC249_GUITAR                    1681
#define STATS_VIEW_DLC249_BACKUP                    1682
#define STATS_VIEW_DLC249_DRUMS                     1683
#define STATS_VIEW_DLC249_MIC                       1684
#define STATS_VIEW_DLC249_BAND                      1685
#define STATS_VIEW_DLC250_GUITAR                    1686
#define STATS_VIEW_DLC250_BACKUP                    1687
#define STATS_VIEW_DLC250_DRUMS                     1688
#define STATS_VIEW_DLC250_MIC                       1689
#define STATS_VIEW_DLC250_BAND                      1690
#define STATS_VIEW_DLC251_GUITAR                    1691
#define STATS_VIEW_DLC251_BACKUP                    1692
#define STATS_VIEW_DLC251_DRUMS                     1693
#define STATS_VIEW_DLC251_MIC                       1694
#define STATS_VIEW_DLC251_BAND                      1695
#define STATS_VIEW_DLC252_GUITAR                    1696
#define STATS_VIEW_DLC252_BACKUP                    1697
#define STATS_VIEW_DLC252_DRUMS                     1698
#define STATS_VIEW_DLC252_MIC                       1699
#define STATS_VIEW_DLC252_BAND                      1700
#define STATS_VIEW_DLC253_GUITAR                    1701
#define STATS_VIEW_DLC253_BACKUP                    1702
#define STATS_VIEW_DLC253_DRUMS                     1703
#define STATS_VIEW_DLC253_MIC                       1704
#define STATS_VIEW_DLC253_BAND                      1705
#define STATS_VIEW_DLC254_GUITAR                    1706
#define STATS_VIEW_DLC254_BACKUP                    1707
#define STATS_VIEW_DLC254_DRUMS                     1708
#define STATS_VIEW_DLC254_MIC                       1709
#define STATS_VIEW_DLC254_BAND                      1710
#define STATS_VIEW_DLC255_GUITAR                    1711
#define STATS_VIEW_DLC255_BACKUP                    1712
#define STATS_VIEW_DLC255_DRUMS                     1713
#define STATS_VIEW_DLC255_MIC                       1714
#define STATS_VIEW_DLC255_BAND                      1715
#define STATS_VIEW_DLC256_GUITAR                    1716
#define STATS_VIEW_DLC256_BACKUP                    1717
#define STATS_VIEW_DLC256_DRUMS                     1718
#define STATS_VIEW_DLC256_MIC                       1719
#define STATS_VIEW_DLC256_BAND                      1720

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for MODES

#define STATS_COLUMN_MODES_COLUMN_ACCUMULATED_SCORE 1
#define STATS_COLUMN_MODES_COLUMN_SCORE             2
#define STATS_COLUMN_MODES_COLUMN_TOTAL_WINS        3
#define STATS_COLUMN_MODES_COLUMN_DIFFICULTY_HARD   4

// Column ids for SONG

#define STATS_COLUMN_SONG_COLUMN_SCORE_EASY         1
#define STATS_COLUMN_SONG_COLUMN_SCORE_MEDIUM       2
#define STATS_COLUMN_SONG_COLUMN_SCORE_HARD         3
#define STATS_COLUMN_SONG_COLUMN_SCORE_EXPERT       4

// Column ids for DLC243_GUITAR

#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_BACKUP

#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_DRUMS

#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_MIC

#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_BAND

#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_GUITAR

#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_BACKUP

#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_DRUMS

#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_MIC

#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_BAND

#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_GUITAR

#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_BACKUP

#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_DRUMS

#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_MIC

#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_BAND

#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_GUITAR

#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_BACKUP

#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_DRUMS

#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_MIC

#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_BAND

#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_GUITAR

#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_BACKUP

#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_DRUMS

#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_MIC

#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_BAND

#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_GUITAR

#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_BACKUP

#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_DRUMS

#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_MIC

#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_BAND

#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_GUITAR

#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_BACKUP

#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_DRUMS

#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_MIC

#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_BAND

#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_GUITAR

#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_BACKUP

#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_DRUMS

#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_MIC

#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_BAND

#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_GUITAR

#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_BACKUP

#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_DRUMS

#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_MIC

#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_BAND

#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_GUITAR

#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_BACKUP

#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_DRUMS

#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_MIC

#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_BAND

#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_GUITAR

#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_BACKUP

#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_DRUMS

#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_MIC

#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_BAND

#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_GUITAR

#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_BACKUP

#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_DRUMS

#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_MIC

#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_BAND

#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_GUITAR

#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_BACKUP

#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_DRUMS

#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_MIC

#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_BAND

#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_GUITAR

#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_BACKUP

#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_DRUMS

#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_MIC

#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_BAND

#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_EXPERT 4

//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//

#define SESSION_MATCH_QUERY_GH3_DEFAULT_QUERY       0
#define SESSION_MATCH_QUERY_GH4_ALT_QUERY           1

//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//



#ifdef __cplusplus
}
#endif

#endif // __GUITAR_HERO_WORLD_TOUR_SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\SuitesData\SPACFunctional\AvatarItems\Positive\FullGame\FullGameShoes-expected.spa.h ===
////////////////////////////////////////////////////////////////////
//
// FullGameShoes.spa.h
//
// Auto-generated on {*}
// XLAST project version {*}
// SPA Compiler version {*}
//
////////////////////////////////////////////////////////////////////

#ifndef __GUITAR_HERO_WORLD_TOUR_SPA_H__
#define __GUITAR_HERO_WORLD_TOUR_SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_GUITAR_HERO_WORLD_TOUR              0x4156081A

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//

#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY          0
#define CONTEXT_SEARCH_GH3_SONG_COUNT               1
#define CONTEXT_SEARCH_GH3_VENUE                    2
#define CONTEXT_SEARCH_GH3_GAME_MODE                3
#define CONTEXT_GH4_SONGS                           78
#define CONTEXT_SEARCH_GH4_HOSTING_STATE            79
#define CONTEXT_SEARCH_GH4_INSTRUMENTS              80

//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for CONTEXT_SEARCH_GH3_SONG_DIFFICULTY

#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_EASY 0
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_MEDIUM 1
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_HARD 2
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_EXPERT 3
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_BEGINNER 4

// Values for CONTEXT_SEARCH_GH3_SONG_COUNT

#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_1 0
#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_3 1
#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_5 2
#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_7 3

// Values for CONTEXT_SEARCH_GH3_VENUE

#define CONTEXT_SEARCH_GH3_VENUE_SEARCH_CON_VENUE_TEMP 0

// Values for CONTEXT_SEARCH_GH3_GAME_MODE

#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_FACEOFF_GUITAR 0
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_PRO_FACEOFF_GUITAR 1
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_BATTLE_GUITAR 2
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_2V2_PRO_FACEOFF_GUITAR 3
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_PRO_FACEOFF_DRUMS 4
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_BATTLE_DRUMS 5
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_BAND_FACEOFF 6
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_BAND_COOP 7
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_GUITAR_COOP 8
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_BAND_CAREER 9
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_FACEOFF_BASS 10
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_PRO_FACEOFF_BASS 11
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_EXTRA_1   12
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_EXTRA_2   13
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_EXTRA_3   14

// Values for CONTEXT_GH4_SONGS

#define CONTEXT_GH4_SONGS_SONG_ABOUTAGIRL           0
#define CONTEXT_GH4_SONGS_SONG_AGGRO                1
#define CONTEXT_GH4_SONGS_SONG_AMERICANWOMAN        2
#define CONTEXT_GH4_SONGS_SONG_ANTISOCIAL           3
#define CONTEXT_GH4_SONGS_SONG_AREYOUGONNAGOMYWAY   4
#define CONTEXT_GH4_SONGS_SONG_ASSASSIN             5
#define CONTEXT_GH4_SONGS_SONG_BANDONTHERUN         6
#define CONTEXT_GH4_SONGS_SONG_BEATIT               7
#define CONTEXT_GH4_SONGS_SONG_BEAUTIFULDISASTER    8
#define CONTEXT_GH4_SONGS_SONG_BOSS_TED             9
#define CONTEXT_GH4_SONGS_SONG_BOSS_WYLDE           10
#define CONTEXT_GH4_SONGS_SONG_BYOB                 11
#define CONTEXT_GH4_SONGS_SONG_CRAZYTRAIN           12
#define CONTEXT_GH4_SONGS_SONG_DAMMIT               13
#define CONTEXT_GH4_SONGS_SONG_DEMOLITIONMAN        14
#define CONTEXT_GH4_SONGS_SONG_ESCUELADECALOR       15
#define CONTEXT_GH4_SONGS_SONG_EVERLONG             16
#define CONTEXT_GH4_SONGS_SONG_EYEOFTHETIGER        17
#define CONTEXT_GH4_SONGS_SONG_FEELTHEPAIN          18
#define CONTEXT_GH4_SONGS_SONG_FLOATON              19
#define CONTEXT_GH4_SONGS_SONG_FREAKONALEASH        20
#define CONTEXT_GH4_SONGS_SONG_GOYOUROWNWAY         21
#define CONTEXT_GH4_SONGS_SONG_GOODGOD              22
#define CONTEXT_GH4_SONGS_SONG_HAILTOTHEFREAKS      23
#define CONTEXT_GH4_SONGS_SONG_HEARTBREAKER         24
#define CONTEXT_GH4_SONGS_SONG_HEYMANNICESHOT       25
#define CONTEXT_GH4_SONGS_SONG_HOLLYWOODNIGHTS      26
#define CONTEXT_GH4_SONGS_SONG_HOTFORTEACHER        27
#define CONTEXT_GH4_SONGS_SONG_HOTELCALIFORNIA      28
#define CONTEXT_GH4_SONGS_SONG_KICKOUTHEJAMS        29
#define CONTEXT_GH4_SONGS_SONG_LABAMBA              30
#define CONTEXT_GH4_SONGS_SONG_LAZYEYE              31
#define CONTEXT_GH4_SONGS_SONG_LIVINONAPRAYER       32
#define CONTEXT_GH4_SONGS_SONG_LOVEMETWOTIMES       33
#define CONTEXT_GH4_SONGS_SONG_LOVEREMOVALMACHINE   34
#define CONTEXT_GH4_SONGS_SONG_LOVESPREADS          35
#define CONTEXT_GH4_SONGS_SONG_LVIALVIAQUEZ         36
#define CONTEXT_GH4_SONGS_SONG_MISERYBUSINESS       37
#define CONTEXT_GH4_SONGS_SONG_MONSOON              38
#define CONTEXT_GH4_SONGS_SONG_MOUNTAINSONG         39
#define CONTEXT_GH4_SONGS_SONG_MRCROWLEY            40
#define CONTEXT_GH4_SONGS_SONG_NEVERTOOLATE         41
#define CONTEXT_GH4_SONGS_SONG_NOSLEEPTILLBROOKLYN  42
#define CONTEXT_GH4_SONGS_SONG_NUVOLEELENZUOLA      43
#define CONTEXT_GH4_SONGS_SONG_OBSTACLE1            44
#define CONTEXT_GH4_SONGS_SONG_ONTHEROADAGAIN       45
#define CONTEXT_GH4_SONGS_SONG_ONEARMEDSCISSOR      46
#define CONTEXT_GH4_SONGS_SONG_ONEWAYORANOTHER      47
#define CONTEXT_GH4_SONGS_SONG_OURTRUTH             48
#define CONTEXT_GH4_SONGS_SONG_OVERKILL             49
#define CONTEXT_GH4_SONGS_SONG_PARABOLA             50
#define CONTEXT_GH4_SONGS_SONG_PRETTYVACANT         51
#define CONTEXT_GH4_SONGS_SONG_PRISONEROFSOCIETY    52
#define CONTEXT_GH4_SONGS_SONG_PULLMEUNDER          53
#define CONTEXT_GH4_SONGS_SONG_PURPLEHAZE           54
#define CONTEXT_GH4_SONGS_SONG_RAMBLINMAN           55
#define CONTEXT_GH4_SONGS_SONG_REBELYELL            56
#define CONTEXT_GH4_SONGS_SONG_REEDUCATIONTHROUGHLABOR 57
#define CONTEXT_GH4_SONGS_SONG_ROOFTOPS             58
#define CONTEXT_GH4_SONGS_SONG_SANTERIA             59
#define CONTEXT_GH4_SONGS_SONG_SATCHBOOGIE          60
#define CONTEXT_GH4_SONGS_SONG_SCHISM               61
#define CONTEXT_GH4_SONGS_SONG_SCREAMAIMFIRE        62
#define CONTEXT_GH4_SONGS_SONG_SHIVER               63
#define CONTEXT_GH4_SONGS_SONG_SOMEMIGHTSAY         64
#define CONTEXT_GH4_SONGS_SONG_SOULDOUBT            65
#define CONTEXT_GH4_SONGS_SONG_SPIDERWEBS           66
#define CONTEXT_GH4_SONGS_SONG_STILLBORN            67
#define CONTEXT_GH4_SONGS_SONG_STRANGLEHOLD         68
#define CONTEXT_GH4_SONGS_SONG_SWEETHOMEALABAMA     69
#define CONTEXT_GH4_SONGS_SONG_THEJOKER             70
#define CONTEXT_GH4_SONGS_SONG_THEKILL              71
#define CONTEXT_GH4_SONGS_SONG_THEMIDDLE            72
#define CONTEXT_GH4_SONGS_SONG_THEONEILOVE          73
#define CONTEXT_GH4_SONGS_SONG_TODAY                74
#define CONTEXT_GH4_SONGS_SONG_TOOMUCHTOOYOUNGTOOFAST 75
#define CONTEXT_GH4_SONGS_SONG_TOYBOY               76
#define CONTEXT_GH4_SONGS_SONG_TRAPPEDUNDERICE      77
#define CONTEXT_GH4_SONGS_SONG_UPAROUNDTHEBEND      78
#define CONTEXT_GH4_SONGS_SONG_VICARIOUS            79
#define CONTEXT_GH4_SONGS_SONG_VINTERNOLL2          80
#define CONTEXT_GH4_SONGS_SONG_WEAPONOFCHOICE       81
#define CONTEXT_GH4_SONGS_SONG_WHATIVEDONE          82
#define CONTEXT_GH4_SONGS_SONG_WINDCRIESMARY        83
#define CONTEXT_GH4_SONGS_SONG_YOUREGONNASAYYEAH    84
#define CONTEXT_GH4_SONGS_SONG_DOWNLOAD_SONG        85
#define CONTEXT_GH4_SONGS_SONG_DOITAGAIN            86

// Values for CONTEXT_SEARCH_GH4_HOSTING_STATE

#define CONTEXT_SEARCH_GH4_HOSTING_STATE_SEARCH_CON_HOSTING_READY 0
#define CONTEXT_SEARCH_GH4_HOSTING_STATE_SEARCH_CON_HOSTING_NOT_READY 1

// Values for CONTEXT_SEARCH_GH4_INSTRUMENTS

#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_GUITAR 0
#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_BASS 1
#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_DRUMS 2
#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_MIC 3

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_MENUS                      0
#define CONTEXT_PRESENCE_BAND_CAREER                1
#define CONTEXT_PRESENCE_BAND_LOGO_EDIT_AND_INSTRUMENT_EDIT 2
#define CONTEXT_PRESENCE_CAREER                     3
#define CONTEXT_PRESENCE_GIGBOARD_AND_SETLIST       4
#define CONTEXT_PRESENCE_GUEST_PROFILE              5
#define CONTEXT_PRESENCE_HEAD_TO_HEAD               6
#define CONTEXT_PRESENCE_LEADERBOARDS               7
#define CONTEXT_PRESENCE_MUSIC_STUDIO               8
#define CONTEXT_PRESENCE_ONLINE                     9
#define CONTEXT_PRESENCE_PRACTICE                   10
#define CONTEXT_PRESENCE_QUICKPLAY                  11
#define CONTEXT_PRESENCE_ROCKSTAR_CREATOR           12
#define CONTEXT_PRESENCE_SIGNED_IN_2_3_AND_4        13
#define CONTEXT_PRESENCE_TUTORIAL                   14
#define CONTEXT_PRESENCE_VIDEOS                     15

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_ONLY_GAMEMODE             0
#define CONTEXT_GAME_MODE_BAND_CAREER               1
#define CONTEXT_GAME_MODE_SEARCH_TEST_GIDEON        2
#define CONTEXT_GAME_MODE_SEARCH_TEST_JOE           3
#define CONTEXT_GAME_MODE_SEARCH_TEST_THOMAS        4
#define CONTEXT_GAME_MODE_SEARCH_TEST_MARIO         5
#define CONTEXT_GAME_MODE_SEARCH_TEST_TIM           6
#define CONTEXT_GAME_MODE_COOP                      7
#define CONTEXT_GAME_MODE_COMPETITIVE               8

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_COLUMN_SCORE                       0x10000002
#define PROPERTY_GH3_CASH                           0x10000003
#define PROPERTY_COLUMN_WIN_LOSS                    0x10000004
#define PROPERTY_MM_GUITARS_NEEDED                  0x10000005
#define PROPERTY_MM_DRUMS_NEEDED                    0x10000006
#define PROPERTY_MM_MICROPHONES_NEEDED              0x10000007
#define PROPERTY_COLUMN_SCORE_EASY                  0x10000008
#define PROPERTY_COLUMN_SCORE_MEDIUM                0x10000009
#define PROPERTY_COLUMN_SCORE_HARD                  0x1000000A
#define PROPERTY_COLUMN_SCORE_EXPERT                0x1000000B
#define PROPERTY_MM_SONG_DIFFICULTY                 0x1000000C
#define PROPERTY_COLUMN_SORT                        0x20000001

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//

#define ACHIEVEMENT_LEARNING_THE_ROPES              6
#define ACHIEVEMENT_ONE_TIME_SOLO_ARTIST            7
#define ACHIEVEMENT_STIX                            8
#define ACHIEVEMENT_YODELER                         9
#define ACHIEVEMENT_PICK_AND_AXE                    10
#define ACHIEVEMENT_FEEDING_THE_BEAST               11
#define ACHIEVEMENT_THIS_IS_TOTALLY_LEGAL           12
#define ACHIEVEMENT_A_PAIR_BEATS_A_PAIR             13
#define ACHIEVEMENT_SURVIVAL_OF_THE_FITTEST         14
#define ACHIEVEMENT_MINE_IS_BIGGER_THAN_YOURS       15
#define ACHIEVEMENT_FIRST_OF_MANY                   16
#define ACHIEVEMENT_ONE_MAN_BAND                    17
#define ACHIEVEMENT_SHOULD_WE_STICK_TOGETHER        18
#define ACHIEVEMENT_50_NOTE_POSSE                   19
#define ACHIEVEMENT_EASY_THERE                      20
#define ACHIEVEMENT_SOLO_ARTIST                     21
#define ACHIEVEMENT_BAND_ON_A_MISSION               22
#define ACHIEVEMENT_BLING_BLING                     23
#define ACHIEVEMENT_TOP_OF_THE_CHARTS               25
#define ACHIEVEMENT_MEDIUM_MUSICIAN                 26
#define ACHIEVEMENT_SOLID_GOLD_ROCKSTARS            27
#define ACHIEVEMENT_PLATINUM_ROCKSTARS              28
#define ACHIEVEMENT_HARDCORE                        29
#define ACHIEVEMENT_HALL_OF_FAMER                   30
#define ACHIEVEMENT_JACK_OF_ALL_TRADES              31
#define ACHIEVEMENT_INKED                           32
#define ACHIEVEMENT_CUSTOM_BEATS                    33
#define ACHIEVEMENT_ONE_OF_A_KIND_AXE               34
#define ACHIEVEMENT_STAMP_OF_APPROVAL               35
#define ACHIEVEMENT_ROCK_MAIDEN                     36
#define ACHIEVEMENT_WARRIOR_OF_ROCK                 37
#define ACHIEVEMENT_THE_DARK_PRINCE                 38
#define ACHIEVEMENT_LEADING_LADY                    39
#define ACHIEVEMENT_MOTORCITY_MADMAN                40
#define ACHIEVEMENT_THE_EXPERIENCE                  41
#define ACHIEVEMENT_DONT_BLINK                      42
#define ACHIEVEMENT_PUMPKIN_SMASHER                 43
#define ACHIEVEMENT_WYLDE_MAN                       44
#define ACHIEVEMENT_SHINY_METAL_THINGY              45
#define ACHIEVEMENT_BAD_TO_THE_BONE                 46
#define ACHIEVEMENT_GUITARISTS_COAT_TAILS           47
#define ACHIEVEMENT_VOCALISTS_COAT_TAILS            48
#define ACHIEVEMENT_121_JIGOWATTS                   49
#define ACHIEVEMENT_SUPER_GROUP_UNITE               50
#define ACHIEVEMENT_AXE_MUSEUM                      51
#define ACHIEVEMENT_GET_YOUR_BOOGIE_ON              52
#define ACHIEVEMENT_MUSE_TO_MY_EARS                 53
#define ACHIEVEMENT_MIKE_CHECKA                     54
#define ACHIEVEMENT_YOURE_A_TOOL                    55
#define ACHIEVEMENT_HEAVY_METALL                    56

//
// AvatarAssetAward ids
//

#define AVATARASSETAWARD_SHOES_SANDALS                   1
#define AVATARASSETAWARD_SHOES_HEELS                     2
#define AVATARASSETAWARD_SHOES_PUMPS                     3
#define AVATARASSETAWARD_SHOES_FORMAL                    4
#define AVATARASSETAWARD_SHOES_TRAINERS                  5

//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_ONLY_GAMEMODE       0xFFFF0000
#define STATS_VIEW_SKILL_RANKED_BAND_CAREER         0xFFFF0001
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_GIDEON  0xFFFF0002
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_JOE     0xFFFF0003
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_THOMAS  0xFFFF0004
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_MARIO   0xFFFF0005
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_TIM     0xFFFF0006
#define STATS_VIEW_SKILL_RANKED_COOP                0xFFFF0007
#define STATS_VIEW_SKILL_RANKED_COMPETITIVE         0xFFFF0008

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_ONLY_GAMEMODE     0xFFFE0000
#define STATS_VIEW_SKILL_STANDARD_BAND_CAREER       0xFFFE0001
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_GIDEON 0xFFFE0002
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_JOE   0xFFFE0003
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_THOMAS 0xFFFE0004
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_MARIO 0xFFFE0005
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_TIM   0xFFFE0006
#define STATS_VIEW_SKILL_STANDARD_COOP              0xFFFE0007
#define STATS_VIEW_SKILL_STANDARD_COMPETITIVE       0xFFFE0008

// Title defined leaderboards

#define STATS_VIEW_MODES                            1
#define STATS_VIEW_SONG                             2
#define STATS_VIEW_DLC243_GUITAR                    1651
#define STATS_VIEW_DLC243_BACKUP                    1652
#define STATS_VIEW_DLC243_DRUMS                     1653
#define STATS_VIEW_DLC243_MIC                       1654
#define STATS_VIEW_DLC243_BAND                      1655
#define STATS_VIEW_DLC244_GUITAR                    1656
#define STATS_VIEW_DLC244_BACKUP                    1657
#define STATS_VIEW_DLC244_DRUMS                     1658
#define STATS_VIEW_DLC244_MIC                       1659
#define STATS_VIEW_DLC244_BAND                      1660
#define STATS_VIEW_DLC245_GUITAR                    1661
#define STATS_VIEW_DLC245_BACKUP                    1662
#define STATS_VIEW_DLC245_DRUMS                     1663
#define STATS_VIEW_DLC245_MIC                       1664
#define STATS_VIEW_DLC245_BAND                      1665
#define STATS_VIEW_DLC246_GUITAR                    1666
#define STATS_VIEW_DLC246_BACKUP                    1667
#define STATS_VIEW_DLC246_DRUMS                     1668
#define STATS_VIEW_DLC246_MIC                       1669
#define STATS_VIEW_DLC246_BAND                      1670
#define STATS_VIEW_DLC247_GUITAR                    1671
#define STATS_VIEW_DLC247_BACKUP                    1672
#define STATS_VIEW_DLC247_DRUMS                     1673
#define STATS_VIEW_DLC247_MIC                       1674
#define STATS_VIEW_DLC247_BAND                      1675
#define STATS_VIEW_DLC248_GUITAR                    1676
#define STATS_VIEW_DLC248_BACKUP                    1677
#define STATS_VIEW_DLC248_DRUMS                     1678
#define STATS_VIEW_DLC248_MIC                       1679
#define STATS_VIEW_DLC248_BAND                      1680
#define STATS_VIEW_DLC249_GUITAR                    1681
#define STATS_VIEW_DLC249_BACKUP                    1682
#define STATS_VIEW_DLC249_DRUMS                     1683
#define STATS_VIEW_DLC249_MIC                       1684
#define STATS_VIEW_DLC249_BAND                      1685
#define STATS_VIEW_DLC250_GUITAR                    1686
#define STATS_VIEW_DLC250_BACKUP                    1687
#define STATS_VIEW_DLC250_DRUMS                     1688
#define STATS_VIEW_DLC250_MIC                       1689
#define STATS_VIEW_DLC250_BAND                      1690
#define STATS_VIEW_DLC251_GUITAR                    1691
#define STATS_VIEW_DLC251_BACKUP                    1692
#define STATS_VIEW_DLC251_DRUMS                     1693
#define STATS_VIEW_DLC251_MIC                       1694
#define STATS_VIEW_DLC251_BAND                      1695
#define STATS_VIEW_DLC252_GUITAR                    1696
#define STATS_VIEW_DLC252_BACKUP                    1697
#define STATS_VIEW_DLC252_DRUMS                     1698
#define STATS_VIEW_DLC252_MIC                       1699
#define STATS_VIEW_DLC252_BAND                      1700
#define STATS_VIEW_DLC253_GUITAR                    1701
#define STATS_VIEW_DLC253_BACKUP                    1702
#define STATS_VIEW_DLC253_DRUMS                     1703
#define STATS_VIEW_DLC253_MIC                       1704
#define STATS_VIEW_DLC253_BAND                      1705
#define STATS_VIEW_DLC254_GUITAR                    1706
#define STATS_VIEW_DLC254_BACKUP                    1707
#define STATS_VIEW_DLC254_DRUMS                     1708
#define STATS_VIEW_DLC254_MIC                       1709
#define STATS_VIEW_DLC254_BAND                      1710
#define STATS_VIEW_DLC255_GUITAR                    1711
#define STATS_VIEW_DLC255_BACKUP                    1712
#define STATS_VIEW_DLC255_DRUMS                     1713
#define STATS_VIEW_DLC255_MIC                       1714
#define STATS_VIEW_DLC255_BAND                      1715
#define STATS_VIEW_DLC256_GUITAR                    1716
#define STATS_VIEW_DLC256_BACKUP                    1717
#define STATS_VIEW_DLC256_DRUMS                     1718
#define STATS_VIEW_DLC256_MIC                       1719
#define STATS_VIEW_DLC256_BAND                      1720

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for MODES

#define STATS_COLUMN_MODES_COLUMN_ACCUMULATED_SCORE 1
#define STATS_COLUMN_MODES_COLUMN_SCORE             2
#define STATS_COLUMN_MODES_COLUMN_TOTAL_WINS        3
#define STATS_COLUMN_MODES_COLUMN_DIFFICULTY_HARD   4

// Column ids for SONG

#define STATS_COLUMN_SONG_COLUMN_SCORE_EASY         1
#define STATS_COLUMN_SONG_COLUMN_SCORE_MEDIUM       2
#define STATS_COLUMN_SONG_COLUMN_SCORE_HARD         3
#define STATS_COLUMN_SONG_COLUMN_SCORE_EXPERT       4

// Column ids for DLC243_GUITAR

#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_BACKUP

#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_DRUMS

#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_MIC

#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_BAND

#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_GUITAR

#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_BACKUP

#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_DRUMS

#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_MIC

#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_BAND

#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_GUITAR

#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_BACKUP

#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_DRUMS

#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_MIC

#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_BAND

#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_GUITAR

#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_BACKUP

#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_DRUMS

#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_MIC

#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_BAND

#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_GUITAR

#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_BACKUP

#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_DRUMS

#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_MIC

#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_BAND

#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_GUITAR

#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_BACKUP

#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_DRUMS

#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_MIC

#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_BAND

#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_GUITAR

#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_BACKUP

#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_DRUMS

#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_MIC

#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_BAND

#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_GUITAR

#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_BACKUP

#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_DRUMS

#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_MIC

#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_BAND

#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_GUITAR

#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_BACKUP

#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_DRUMS

#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_MIC

#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_BAND

#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_GUITAR

#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_BACKUP

#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_DRUMS

#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_MIC

#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_BAND

#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_GUITAR

#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_BACKUP

#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_DRUMS

#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_MIC

#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_BAND

#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_GUITAR

#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_BACKUP

#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_DRUMS

#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_MIC

#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_BAND

#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_GUITAR

#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_BACKUP

#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_DRUMS

#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_MIC

#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_BAND

#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_GUITAR

#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_BACKUP

#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_DRUMS

#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_MIC

#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_BAND

#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_EXPERT 4

//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//

#define SESSION_MATCH_QUERY_GH3_DEFAULT_QUERY       0
#define SESSION_MATCH_QUERY_GH4_ALT_QUERY           1

//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//



#ifdef __cplusplus
}
#endif

#endif // __GUITAR_HERO_WORLD_TOUR_SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\SuitesData\SPACFunctional\AvatarItems\Positive\FullGame\FullGameShirt-expected.spa.h ===
////////////////////////////////////////////////////////////////////
//
// FullGameShirt.spa.h
//
// Auto-generated on {*}
// XLAST project version {*}
// SPA Compiler version {*}
//
////////////////////////////////////////////////////////////////////

#ifndef __GUITAR_HERO_WORLD_TOUR_SPA_H__
#define __GUITAR_HERO_WORLD_TOUR_SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_GUITAR_HERO_WORLD_TOUR              0x4156081A

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//

#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY          0
#define CONTEXT_SEARCH_GH3_SONG_COUNT               1
#define CONTEXT_SEARCH_GH3_VENUE                    2
#define CONTEXT_SEARCH_GH3_GAME_MODE                3
#define CONTEXT_GH4_SONGS                           78
#define CONTEXT_SEARCH_GH4_HOSTING_STATE            79
#define CONTEXT_SEARCH_GH4_INSTRUMENTS              80

//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for CONTEXT_SEARCH_GH3_SONG_DIFFICULTY

#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_EASY 0
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_MEDIUM 1
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_HARD 2
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_EXPERT 3
#define CONTEXT_SEARCH_GH3_SONG_DIFFICULTY_SEARCH_CON_DIFF_BEGINNER 4

// Values for CONTEXT_SEARCH_GH3_SONG_COUNT

#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_1 0
#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_3 1
#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_5 2
#define CONTEXT_SEARCH_GH3_SONG_COUNT_SEARCH_CON_SONG_COUNT_7 3

// Values for CONTEXT_SEARCH_GH3_VENUE

#define CONTEXT_SEARCH_GH3_VENUE_SEARCH_CON_VENUE_TEMP 0

// Values for CONTEXT_SEARCH_GH3_GAME_MODE

#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_FACEOFF_GUITAR 0
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_PRO_FACEOFF_GUITAR 1
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_BATTLE_GUITAR 2
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_2V2_PRO_FACEOFF_GUITAR 3
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_PRO_FACEOFF_DRUMS 4
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_BATTLE_DRUMS 5
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_BAND_FACEOFF 6
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_BAND_COOP 7
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_GUITAR_COOP 8
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_BAND_CAREER 9
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_FACEOFF_BASS 10
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_1V1_PRO_FACEOFF_BASS 11
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_EXTRA_1   12
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_EXTRA_2   13
#define CONTEXT_SEARCH_GH3_GAME_MODE_MODE_EXTRA_3   14

// Values for CONTEXT_GH4_SONGS

#define CONTEXT_GH4_SONGS_SONG_ABOUTAGIRL           0
#define CONTEXT_GH4_SONGS_SONG_AGGRO                1
#define CONTEXT_GH4_SONGS_SONG_AMERICANWOMAN        2
#define CONTEXT_GH4_SONGS_SONG_ANTISOCIAL           3
#define CONTEXT_GH4_SONGS_SONG_AREYOUGONNAGOMYWAY   4
#define CONTEXT_GH4_SONGS_SONG_ASSASSIN             5
#define CONTEXT_GH4_SONGS_SONG_BANDONTHERUN         6
#define CONTEXT_GH4_SONGS_SONG_BEATIT               7
#define CONTEXT_GH4_SONGS_SONG_BEAUTIFULDISASTER    8
#define CONTEXT_GH4_SONGS_SONG_BOSS_TED             9
#define CONTEXT_GH4_SONGS_SONG_BOSS_WYLDE           10
#define CONTEXT_GH4_SONGS_SONG_BYOB                 11
#define CONTEXT_GH4_SONGS_SONG_CRAZYTRAIN           12
#define CONTEXT_GH4_SONGS_SONG_DAMMIT               13
#define CONTEXT_GH4_SONGS_SONG_DEMOLITIONMAN        14
#define CONTEXT_GH4_SONGS_SONG_ESCUELADECALOR       15
#define CONTEXT_GH4_SONGS_SONG_EVERLONG             16
#define CONTEXT_GH4_SONGS_SONG_EYEOFTHETIGER        17
#define CONTEXT_GH4_SONGS_SONG_FEELTHEPAIN          18
#define CONTEXT_GH4_SONGS_SONG_FLOATON              19
#define CONTEXT_GH4_SONGS_SONG_FREAKONALEASH        20
#define CONTEXT_GH4_SONGS_SONG_GOYOUROWNWAY         21
#define CONTEXT_GH4_SONGS_SONG_GOODGOD              22
#define CONTEXT_GH4_SONGS_SONG_HAILTOTHEFREAKS      23
#define CONTEXT_GH4_SONGS_SONG_HEARTBREAKER         24
#define CONTEXT_GH4_SONGS_SONG_HEYMANNICESHOT       25
#define CONTEXT_GH4_SONGS_SONG_HOLLYWOODNIGHTS      26
#define CONTEXT_GH4_SONGS_SONG_HOTFORTEACHER        27
#define CONTEXT_GH4_SONGS_SONG_HOTELCALIFORNIA      28
#define CONTEXT_GH4_SONGS_SONG_KICKOUTHEJAMS        29
#define CONTEXT_GH4_SONGS_SONG_LABAMBA              30
#define CONTEXT_GH4_SONGS_SONG_LAZYEYE              31
#define CONTEXT_GH4_SONGS_SONG_LIVINONAPRAYER       32
#define CONTEXT_GH4_SONGS_SONG_LOVEMETWOTIMES       33
#define CONTEXT_GH4_SONGS_SONG_LOVEREMOVALMACHINE   34
#define CONTEXT_GH4_SONGS_SONG_LOVESPREADS          35
#define CONTEXT_GH4_SONGS_SONG_LVIALVIAQUEZ         36
#define CONTEXT_GH4_SONGS_SONG_MISERYBUSINESS       37
#define CONTEXT_GH4_SONGS_SONG_MONSOON              38
#define CONTEXT_GH4_SONGS_SONG_MOUNTAINSONG         39
#define CONTEXT_GH4_SONGS_SONG_MRCROWLEY            40
#define CONTEXT_GH4_SONGS_SONG_NEVERTOOLATE         41
#define CONTEXT_GH4_SONGS_SONG_NOSLEEPTILLBROOKLYN  42
#define CONTEXT_GH4_SONGS_SONG_NUVOLEELENZUOLA      43
#define CONTEXT_GH4_SONGS_SONG_OBSTACLE1            44
#define CONTEXT_GH4_SONGS_SONG_ONTHEROADAGAIN       45
#define CONTEXT_GH4_SONGS_SONG_ONEARMEDSCISSOR      46
#define CONTEXT_GH4_SONGS_SONG_ONEWAYORANOTHER      47
#define CONTEXT_GH4_SONGS_SONG_OURTRUTH             48
#define CONTEXT_GH4_SONGS_SONG_OVERKILL             49
#define CONTEXT_GH4_SONGS_SONG_PARABOLA             50
#define CONTEXT_GH4_SONGS_SONG_PRETTYVACANT         51
#define CONTEXT_GH4_SONGS_SONG_PRISONEROFSOCIETY    52
#define CONTEXT_GH4_SONGS_SONG_PULLMEUNDER          53
#define CONTEXT_GH4_SONGS_SONG_PURPLEHAZE           54
#define CONTEXT_GH4_SONGS_SONG_RAMBLINMAN           55
#define CONTEXT_GH4_SONGS_SONG_REBELYELL            56
#define CONTEXT_GH4_SONGS_SONG_REEDUCATIONTHROUGHLABOR 57
#define CONTEXT_GH4_SONGS_SONG_ROOFTOPS             58
#define CONTEXT_GH4_SONGS_SONG_SANTERIA             59
#define CONTEXT_GH4_SONGS_SONG_SATCHBOOGIE          60
#define CONTEXT_GH4_SONGS_SONG_SCHISM               61
#define CONTEXT_GH4_SONGS_SONG_SCREAMAIMFIRE        62
#define CONTEXT_GH4_SONGS_SONG_SHIVER               63
#define CONTEXT_GH4_SONGS_SONG_SOMEMIGHTSAY         64
#define CONTEXT_GH4_SONGS_SONG_SOULDOUBT            65
#define CONTEXT_GH4_SONGS_SONG_SPIDERWEBS           66
#define CONTEXT_GH4_SONGS_SONG_STILLBORN            67
#define CONTEXT_GH4_SONGS_SONG_STRANGLEHOLD         68
#define CONTEXT_GH4_SONGS_SONG_SWEETHOMEALABAMA     69
#define CONTEXT_GH4_SONGS_SONG_THEJOKER             70
#define CONTEXT_GH4_SONGS_SONG_THEKILL              71
#define CONTEXT_GH4_SONGS_SONG_THEMIDDLE            72
#define CONTEXT_GH4_SONGS_SONG_THEONEILOVE          73
#define CONTEXT_GH4_SONGS_SONG_TODAY                74
#define CONTEXT_GH4_SONGS_SONG_TOOMUCHTOOYOUNGTOOFAST 75
#define CONTEXT_GH4_SONGS_SONG_TOYBOY               76
#define CONTEXT_GH4_SONGS_SONG_TRAPPEDUNDERICE      77
#define CONTEXT_GH4_SONGS_SONG_UPAROUNDTHEBEND      78
#define CONTEXT_GH4_SONGS_SONG_VICARIOUS            79
#define CONTEXT_GH4_SONGS_SONG_VINTERNOLL2          80
#define CONTEXT_GH4_SONGS_SONG_WEAPONOFCHOICE       81
#define CONTEXT_GH4_SONGS_SONG_WHATIVEDONE          82
#define CONTEXT_GH4_SONGS_SONG_WINDCRIESMARY        83
#define CONTEXT_GH4_SONGS_SONG_YOUREGONNASAYYEAH    84
#define CONTEXT_GH4_SONGS_SONG_DOWNLOAD_SONG        85
#define CONTEXT_GH4_SONGS_SONG_DOITAGAIN            86

// Values for CONTEXT_SEARCH_GH4_HOSTING_STATE

#define CONTEXT_SEARCH_GH4_HOSTING_STATE_SEARCH_CON_HOSTING_READY 0
#define CONTEXT_SEARCH_GH4_HOSTING_STATE_SEARCH_CON_HOSTING_NOT_READY 1

// Values for CONTEXT_SEARCH_GH4_INSTRUMENTS

#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_GUITAR 0
#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_BASS 1
#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_DRUMS 2
#define CONTEXT_SEARCH_GH4_INSTRUMENTS_SEARCH_GH4_INSTRUMENTS_MIC 3

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_MENUS                      0
#define CONTEXT_PRESENCE_BAND_CAREER                1
#define CONTEXT_PRESENCE_BAND_LOGO_EDIT_AND_INSTRUMENT_EDIT 2
#define CONTEXT_PRESENCE_CAREER                     3
#define CONTEXT_PRESENCE_GIGBOARD_AND_SETLIST       4
#define CONTEXT_PRESENCE_GUEST_PROFILE              5
#define CONTEXT_PRESENCE_HEAD_TO_HEAD               6
#define CONTEXT_PRESENCE_LEADERBOARDS               7
#define CONTEXT_PRESENCE_MUSIC_STUDIO               8
#define CONTEXT_PRESENCE_ONLINE                     9
#define CONTEXT_PRESENCE_PRACTICE                   10
#define CONTEXT_PRESENCE_QUICKPLAY                  11
#define CONTEXT_PRESENCE_ROCKSTAR_CREATOR           12
#define CONTEXT_PRESENCE_SIGNED_IN_2_3_AND_4        13
#define CONTEXT_PRESENCE_TUTORIAL                   14
#define CONTEXT_PRESENCE_VIDEOS                     15

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_ONLY_GAMEMODE             0
#define CONTEXT_GAME_MODE_BAND_CAREER               1
#define CONTEXT_GAME_MODE_SEARCH_TEST_GIDEON        2
#define CONTEXT_GAME_MODE_SEARCH_TEST_JOE           3
#define CONTEXT_GAME_MODE_SEARCH_TEST_THOMAS        4
#define CONTEXT_GAME_MODE_SEARCH_TEST_MARIO         5
#define CONTEXT_GAME_MODE_SEARCH_TEST_TIM           6
#define CONTEXT_GAME_MODE_COOP                      7
#define CONTEXT_GAME_MODE_COMPETITIVE               8

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_COLUMN_SCORE                       0x10000002
#define PROPERTY_GH3_CASH                           0x10000003
#define PROPERTY_COLUMN_WIN_LOSS                    0x10000004
#define PROPERTY_MM_GUITARS_NEEDED                  0x10000005
#define PROPERTY_MM_DRUMS_NEEDED                    0x10000006
#define PROPERTY_MM_MICROPHONES_NEEDED              0x10000007
#define PROPERTY_COLUMN_SCORE_EASY                  0x10000008
#define PROPERTY_COLUMN_SCORE_MEDIUM                0x10000009
#define PROPERTY_COLUMN_SCORE_HARD                  0x1000000A
#define PROPERTY_COLUMN_SCORE_EXPERT                0x1000000B
#define PROPERTY_MM_SONG_DIFFICULTY                 0x1000000C
#define PROPERTY_COLUMN_SORT                        0x20000001

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//

#define ACHIEVEMENT_LEARNING_THE_ROPES              6
#define ACHIEVEMENT_ONE_TIME_SOLO_ARTIST            7
#define ACHIEVEMENT_STIX                            8
#define ACHIEVEMENT_YODELER                         9
#define ACHIEVEMENT_PICK_AND_AXE                    10
#define ACHIEVEMENT_FEEDING_THE_BEAST               11
#define ACHIEVEMENT_THIS_IS_TOTALLY_LEGAL           12
#define ACHIEVEMENT_A_PAIR_BEATS_A_PAIR             13
#define ACHIEVEMENT_SURVIVAL_OF_THE_FITTEST         14
#define ACHIEVEMENT_MINE_IS_BIGGER_THAN_YOURS       15
#define ACHIEVEMENT_FIRST_OF_MANY                   16
#define ACHIEVEMENT_ONE_MAN_BAND                    17
#define ACHIEVEMENT_SHOULD_WE_STICK_TOGETHER        18
#define ACHIEVEMENT_50_NOTE_POSSE                   19
#define ACHIEVEMENT_EASY_THERE                      20
#define ACHIEVEMENT_SOLO_ARTIST                     21
#define ACHIEVEMENT_BAND_ON_A_MISSION               22
#define ACHIEVEMENT_BLING_BLING                     23
#define ACHIEVEMENT_TOP_OF_THE_CHARTS               25
#define ACHIEVEMENT_MEDIUM_MUSICIAN                 26
#define ACHIEVEMENT_SOLID_GOLD_ROCKSTARS            27
#define ACHIEVEMENT_PLATINUM_ROCKSTARS              28
#define ACHIEVEMENT_HARDCORE                        29
#define ACHIEVEMENT_HALL_OF_FAMER                   30
#define ACHIEVEMENT_JACK_OF_ALL_TRADES              31
#define ACHIEVEMENT_INKED                           32
#define ACHIEVEMENT_CUSTOM_BEATS                    33
#define ACHIEVEMENT_ONE_OF_A_KIND_AXE               34
#define ACHIEVEMENT_STAMP_OF_APPROVAL               35
#define ACHIEVEMENT_ROCK_MAIDEN                     36
#define ACHIEVEMENT_WARRIOR_OF_ROCK                 37
#define ACHIEVEMENT_THE_DARK_PRINCE                 38
#define ACHIEVEMENT_LEADING_LADY                    39
#define ACHIEVEMENT_MOTORCITY_MADMAN                40
#define ACHIEVEMENT_THE_EXPERIENCE                  41
#define ACHIEVEMENT_DONT_BLINK                      42
#define ACHIEVEMENT_PUMPKIN_SMASHER                 43
#define ACHIEVEMENT_WYLDE_MAN                       44
#define ACHIEVEMENT_SHINY_METAL_THINGY              45
#define ACHIEVEMENT_BAD_TO_THE_BONE                 46
#define ACHIEVEMENT_GUITARISTS_COAT_TAILS           47
#define ACHIEVEMENT_VOCALISTS_COAT_TAILS            48
#define ACHIEVEMENT_121_JIGOWATTS                   49
#define ACHIEVEMENT_SUPER_GROUP_UNITE               50
#define ACHIEVEMENT_AXE_MUSEUM                      51
#define ACHIEVEMENT_GET_YOUR_BOOGIE_ON              52
#define ACHIEVEMENT_MUSE_TO_MY_EARS                 53
#define ACHIEVEMENT_MIKE_CHECKA                     54
#define ACHIEVEMENT_YOURE_A_TOOL                    55
#define ACHIEVEMENT_HEAVY_METALL                    56

//
// AvatarAssetAward ids
//

#define AVATARASSETAWARD_SHIRT_COAT                      1
#define AVATARASSETAWARD_SHIRT_HOODIE_JACKET             2
#define AVATARASSETAWARD_SHIRT_TEE_POLO                  3
#define AVATARASSETAWARD_SHIRT_VESTS_SPORTS_TEE          4
#define AVATARASSETAWARD_SHIRT_TEE_POLO_2                5

//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_ONLY_GAMEMODE       0xFFFF0000
#define STATS_VIEW_SKILL_RANKED_BAND_CAREER         0xFFFF0001
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_GIDEON  0xFFFF0002
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_JOE     0xFFFF0003
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_THOMAS  0xFFFF0004
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_MARIO   0xFFFF0005
#define STATS_VIEW_SKILL_RANKED_SEARCH_TEST_TIM     0xFFFF0006
#define STATS_VIEW_SKILL_RANKED_COOP                0xFFFF0007
#define STATS_VIEW_SKILL_RANKED_COMPETITIVE         0xFFFF0008

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_ONLY_GAMEMODE     0xFFFE0000
#define STATS_VIEW_SKILL_STANDARD_BAND_CAREER       0xFFFE0001
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_GIDEON 0xFFFE0002
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_JOE   0xFFFE0003
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_THOMAS 0xFFFE0004
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_MARIO 0xFFFE0005
#define STATS_VIEW_SKILL_STANDARD_SEARCH_TEST_TIM   0xFFFE0006
#define STATS_VIEW_SKILL_STANDARD_COOP              0xFFFE0007
#define STATS_VIEW_SKILL_STANDARD_COMPETITIVE       0xFFFE0008

// Title defined leaderboards

#define STATS_VIEW_MODES                            1
#define STATS_VIEW_SONG                             2
#define STATS_VIEW_DLC243_GUITAR                    1651
#define STATS_VIEW_DLC243_BACKUP                    1652
#define STATS_VIEW_DLC243_DRUMS                     1653
#define STATS_VIEW_DLC243_MIC                       1654
#define STATS_VIEW_DLC243_BAND                      1655
#define STATS_VIEW_DLC244_GUITAR                    1656
#define STATS_VIEW_DLC244_BACKUP                    1657
#define STATS_VIEW_DLC244_DRUMS                     1658
#define STATS_VIEW_DLC244_MIC                       1659
#define STATS_VIEW_DLC244_BAND                      1660
#define STATS_VIEW_DLC245_GUITAR                    1661
#define STATS_VIEW_DLC245_BACKUP                    1662
#define STATS_VIEW_DLC245_DRUMS                     1663
#define STATS_VIEW_DLC245_MIC                       1664
#define STATS_VIEW_DLC245_BAND                      1665
#define STATS_VIEW_DLC246_GUITAR                    1666
#define STATS_VIEW_DLC246_BACKUP                    1667
#define STATS_VIEW_DLC246_DRUMS                     1668
#define STATS_VIEW_DLC246_MIC                       1669
#define STATS_VIEW_DLC246_BAND                      1670
#define STATS_VIEW_DLC247_GUITAR                    1671
#define STATS_VIEW_DLC247_BACKUP                    1672
#define STATS_VIEW_DLC247_DRUMS                     1673
#define STATS_VIEW_DLC247_MIC                       1674
#define STATS_VIEW_DLC247_BAND                      1675
#define STATS_VIEW_DLC248_GUITAR                    1676
#define STATS_VIEW_DLC248_BACKUP                    1677
#define STATS_VIEW_DLC248_DRUMS                     1678
#define STATS_VIEW_DLC248_MIC                       1679
#define STATS_VIEW_DLC248_BAND                      1680
#define STATS_VIEW_DLC249_GUITAR                    1681
#define STATS_VIEW_DLC249_BACKUP                    1682
#define STATS_VIEW_DLC249_DRUMS                     1683
#define STATS_VIEW_DLC249_MIC                       1684
#define STATS_VIEW_DLC249_BAND                      1685
#define STATS_VIEW_DLC250_GUITAR                    1686
#define STATS_VIEW_DLC250_BACKUP                    1687
#define STATS_VIEW_DLC250_DRUMS                     1688
#define STATS_VIEW_DLC250_MIC                       1689
#define STATS_VIEW_DLC250_BAND                      1690
#define STATS_VIEW_DLC251_GUITAR                    1691
#define STATS_VIEW_DLC251_BACKUP                    1692
#define STATS_VIEW_DLC251_DRUMS                     1693
#define STATS_VIEW_DLC251_MIC                       1694
#define STATS_VIEW_DLC251_BAND                      1695
#define STATS_VIEW_DLC252_GUITAR                    1696
#define STATS_VIEW_DLC252_BACKUP                    1697
#define STATS_VIEW_DLC252_DRUMS                     1698
#define STATS_VIEW_DLC252_MIC                       1699
#define STATS_VIEW_DLC252_BAND                      1700
#define STATS_VIEW_DLC253_GUITAR                    1701
#define STATS_VIEW_DLC253_BACKUP                    1702
#define STATS_VIEW_DLC253_DRUMS                     1703
#define STATS_VIEW_DLC253_MIC                       1704
#define STATS_VIEW_DLC253_BAND                      1705
#define STATS_VIEW_DLC254_GUITAR                    1706
#define STATS_VIEW_DLC254_BACKUP                    1707
#define STATS_VIEW_DLC254_DRUMS                     1708
#define STATS_VIEW_DLC254_MIC                       1709
#define STATS_VIEW_DLC254_BAND                      1710
#define STATS_VIEW_DLC255_GUITAR                    1711
#define STATS_VIEW_DLC255_BACKUP                    1712
#define STATS_VIEW_DLC255_DRUMS                     1713
#define STATS_VIEW_DLC255_MIC                       1714
#define STATS_VIEW_DLC255_BAND                      1715
#define STATS_VIEW_DLC256_GUITAR                    1716
#define STATS_VIEW_DLC256_BACKUP                    1717
#define STATS_VIEW_DLC256_DRUMS                     1718
#define STATS_VIEW_DLC256_MIC                       1719
#define STATS_VIEW_DLC256_BAND                      1720

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for MODES

#define STATS_COLUMN_MODES_COLUMN_ACCUMULATED_SCORE 1
#define STATS_COLUMN_MODES_COLUMN_SCORE             2
#define STATS_COLUMN_MODES_COLUMN_TOTAL_WINS        3
#define STATS_COLUMN_MODES_COLUMN_DIFFICULTY_HARD   4

// Column ids for SONG

#define STATS_COLUMN_SONG_COLUMN_SCORE_EASY         1
#define STATS_COLUMN_SONG_COLUMN_SCORE_MEDIUM       2
#define STATS_COLUMN_SONG_COLUMN_SCORE_HARD         3
#define STATS_COLUMN_SONG_COLUMN_SCORE_EXPERT       4

// Column ids for DLC243_GUITAR

#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC243_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_BACKUP

#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC243_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_DRUMS

#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC243_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_MIC

#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC243_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC243_BAND

#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC243_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_GUITAR

#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC244_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_BACKUP

#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC244_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_DRUMS

#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC244_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_MIC

#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC244_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC244_BAND

#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC244_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_GUITAR

#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC245_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_BACKUP

#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC245_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_DRUMS

#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC245_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_MIC

#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC245_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC245_BAND

#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC245_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_GUITAR

#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC246_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_BACKUP

#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC246_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_DRUMS

#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC246_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_MIC

#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC246_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC246_BAND

#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC246_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_GUITAR

#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC247_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_BACKUP

#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC247_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_DRUMS

#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC247_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_MIC

#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC247_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC247_BAND

#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC247_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_GUITAR

#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC248_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_BACKUP

#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC248_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_DRUMS

#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC248_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_MIC

#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC248_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC248_BAND

#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC248_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_GUITAR

#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC249_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_BACKUP

#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC249_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_DRUMS

#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC249_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_MIC

#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC249_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC249_BAND

#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC249_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_GUITAR

#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC250_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_BACKUP

#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC250_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_DRUMS

#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC250_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_MIC

#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC250_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC250_BAND

#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC250_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_GUITAR

#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC251_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_BACKUP

#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC251_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_DRUMS

#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC251_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_MIC

#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC251_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC251_BAND

#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC251_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_GUITAR

#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC252_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_BACKUP

#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC252_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_DRUMS

#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC252_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_MIC

#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC252_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC252_BAND

#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC252_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_GUITAR

#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC253_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_BACKUP

#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC253_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_DRUMS

#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC253_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_MIC

#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC253_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC253_BAND

#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC253_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_GUITAR

#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC254_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_BACKUP

#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC254_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_DRUMS

#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC254_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_MIC

#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC254_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC254_BAND

#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC254_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_GUITAR

#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC255_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_BACKUP

#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC255_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_DRUMS

#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC255_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_MIC

#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC255_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC255_BAND

#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC255_BAND_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_GUITAR

#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC256_GUITAR_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_BACKUP

#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC256_BACKUP_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_DRUMS

#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_EASY 1
#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_HARD 3
#define STATS_COLUMN_DLC256_DRUMS_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_MIC

#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_EASY   1
#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_HARD   3
#define STATS_COLUMN_DLC256_MIC_COLUMN_SCORE_EXPERT 4

// Column ids for DLC256_BAND

#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_EASY  1
#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_MEDIUM 2
#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_HARD  3
#define STATS_COLUMN_DLC256_BAND_COLUMN_SCORE_EXPERT 4

//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//

#define SESSION_MATCH_QUERY_GH3_DEFAULT_QUERY       0
#define SESSION_MATCH_QUERY_GH4_ALT_QUERY           1

//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//



#ifdef __cplusplus
}
#endif

#endif // __GUITAR_HERO_WORLD_TOUR_SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\SuitesData\SPACFunctional\Regression\Hexic\Hexic-Korean-92-expected.spa.h ===
////////////////////////////////////////////////////////////////////
//
// Hexic-Korean-92.spa.h
//
// Auto-generated on {*}
// XLAST project version {*}
// SPA Compiler version {*}
//
////////////////////////////////////////////////////////////////////

#ifndef __HEXIC_HD_SPA_H__
#define __HEXIC_HD_SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_HEXIC_HD                            0x584107D1

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//

#define CONTEXT_DIFFICULTY                          3

//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for CONTEXT_DIFFICULTY

#define CONTEXT_DIFFICULTY_EASY_DIFFICULTY          0
#define CONTEXT_DIFFICULTY_MEDIUM_DIFFICULTY        1
#define CONTEXT_DIFFICULTY_HARD_DIFFICULTY          2

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_PRESENCE_MENU              0
#define CONTEXT_PRESENCE_PRESENCE_MARATHON          1
#define CONTEXT_PRESENCE_PRESENCE_TIMED             2
#define CONTEXT_PRESENCE_PRESENCE_SURVIVAL          3

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_CONTEXT_SOLO              0

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_LEVEL                              0x10000004
#define PROPERTY_TIME                               0x10000005
#define PROPERTY_CLUSTERS                           0x10000006
#define PROPERTY_FLOWERS                            0x10000007
#define PROPERTY_PEARLS                             0x10000008
#define PROPERTY_BOMBS                              0x10000009
#define PROPERTY_BONUSES                            0x1000000A
#define PROPERTY_BOMBBONUSCOMBO                     0x1000000B
#define PROPERTY_BONUS3COMBO                        0x1000000C
#define PROPERTY_WINGAME                            0x1000000D
#define PROPERTY_DIFFICULTY                         0x1000000F
#define PROPERTY_SCORE                              0x20000001
#define PROPERTY_DATE                               0x2000000E

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//

#define ACHIEVEMENT_ACHIEVEMENT_BEGINNER            1
#define ACHIEVEMENT_ACHIEVEMENT_BONUSCLUSTER        2
#define ACHIEVEMENT_ACHIEVEMENT_FLOWER              3
#define ACHIEVEMENT_ACHIEVEMENT_BLACKPEARL          4
#define ACHIEVEMENT_ACHIEVEMENT_PEARLCLUSTER        5
#define ACHIEVEMENT_ACHIEVEMENT_VETERAN             6
#define ACHIEVEMENT_ACHIEVEMENT_LIFETIMECOMBOS      7
#define ACHIEVEMENT_ACHIEVEMENT_SURVIVAL            8
#define ACHIEVEMENT_ACHIEVEMENT_TIMEDSCORE          9
#define ACHIEVEMENT_ACHIEVEMENT_MARATHONSCORE       10
#define ACHIEVEMENT_ACHIEVEMENT_LIFETIMESCORE       11
#define ACHIEVEMENT_ACHIEVEMENT_PEARLFLOWER         12

//
// AvatarAssetAward ids
//


//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_CONTEXT_SOLO        0xFFFF0000

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_CONTEXT_SOLO      0xFFFE0000

// Title defined leaderboards

#define STATS_VIEW_MARATHON                         1
#define STATS_VIEW_TIMED                            2
#define STATS_VIEW_SURVIVAL                         3

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for MARATHON

#define STATS_COLUMN_MARATHON_TIME_COLUMN           2
#define STATS_COLUMN_MARATHON_CLUSTERS_COLUMN       3
#define STATS_COLUMN_MARATHON_FLOWERS_COLUMN        4
#define STATS_COLUMN_MARATHON_PEARLS_COLUMN         5
#define STATS_COLUMN_MARATHON_BOMBS_COLUMN          6
#define STATS_COLUMN_MARATHON_BONUSES_COLUMN        7
#define STATS_COLUMN_MARATHON_BOMBBONUSCOMBO_COLUMN 8
#define STATS_COLUMN_MARATHON_BONUS3COMBO_COLUMN    9
#define STATS_COLUMN_MARATHON_LEVEL_COLUMN          1
#define STATS_COLUMN_MARATHON_DATE_COLUMN           12
#define STATS_COLUMN_MARATHON_DIFFICULTY_COLUMN     10
#define STATS_COLUMN_MARATHON_WINGAME_COLUMN        11

// Column ids for TIMED

#define STATS_COLUMN_TIMED_TIME_COLUMN              2
#define STATS_COLUMN_TIMED_CLUSTERS_COLUMN          3
#define STATS_COLUMN_TIMED_FLOWERS_COLUMN           4
#define STATS_COLUMN_TIMED_PEARLS_COLUMN            5
#define STATS_COLUMN_TIMED_BOMBS_COLUMN             6
#define STATS_COLUMN_TIMED_BONUSES_COLUMN           7
#define STATS_COLUMN_TIMED_BOMBBONUSCOMBO_COLUMN    8
#define STATS_COLUMN_TIMED_BONUS3COMBO_COLUMN       9
#define STATS_COLUMN_TIMED_LEVEL_COLUMN             1
#define STATS_COLUMN_TIMED_DATE_COLUMN              12
#define STATS_COLUMN_TIMED_DIFFICULTY_COLUMN        10
#define STATS_COLUMN_TIMED_WINGAME_COLUMN           11

// Column ids for SURVIVAL

#define STATS_COLUMN_SURVIVAL_TIME_COLUMN           2
#define STATS_COLUMN_SURVIVAL_CLUSTERS_COLUMN       3
#define STATS_COLUMN_SURVIVAL_FLOWERS_COLUMN        4
#define STATS_COLUMN_SURVIVAL_PEARLS_COLUMN         5
#define STATS_COLUMN_SURVIVAL_BOMBS_COLUMN          6
#define STATS_COLUMN_SURVIVAL_BONUSES_COLUMN        7
#define STATS_COLUMN_SURVIVAL_BOMBBONUSCOMBO_COLUMN 8
#define STATS_COLUMN_SURVIVAL_BONUS3COMBO_COLUMN    9
#define STATS_COLUMN_SURVIVAL_LEVEL_COLUMN          1
#define STATS_COLUMN_SURVIVAL_DATE_COLUMN           12
#define STATS_COLUMN_SURVIVAL_DIFFICULTY_COLUMN     10
#define STATS_COLUMN_SURVIVAL_WINGAME_COLUMN        11

//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//


//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//

#define GAMER_PICTURE_TILE_ATCHA                    13


#ifdef __cplusplus
}
#endif

#endif // __HEXIC_HD_SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\Validators\IValidator.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace XlastAuto
{
    public enum Expect
    {
        NoError = 0,
        BlastError = 1,
        SpacError = 2
    }

    public interface IValidator
    {
        bool ExpectNoErrors(ExecutionResults results);

        bool ExpectNoErrors(ExecutionResults results, string[] expectedOutputFiles);

        bool ExpectError(ExecutionResults results, int errorCode, string expect);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XLASys\Common\database.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Data.SqlClient;
using System.Text;

namespace XLASys
{
    /// <summary>
    /// Common class for accessing the database and stored procedures
    /// </summary>
    public class XBLDistAutoDB
    {
        protected const string DefaultServerName = "localhost";
        protected const string DefaultDatabaseName = "XBLDistAuto";

        protected string _sqlConnStr = "";
        protected string _serverName;
        protected string _databaseName;

        /// <summary>
        /// Constructor using default servername and database name
        /// </summary>
        public XBLDistAutoDB() : this(DefaultServerName, DefaultDatabaseName)
        {
        }

        /// <summary>
        /// Constructs the sql Connection String and stores it
        /// </summary>
        /// <param name="serverName">server where the database resides</param>
        /// <param name="databaseName">name of the database used</param>
        public XBLDistAutoDB(string serverName, string databaseName)
        {
            _serverName = serverName;
            _databaseName = databaseName;

            SqlConnectionStringBuilder sqlStringBldr = new SqlConnectionStringBuilder();
            sqlStringBldr.DataSource = _serverName;
            sqlStringBldr.InitialCatalog = _databaseName;
            sqlStringBldr.IntegratedSecurity = true;
            _sqlConnStr = sqlStringBldr.ConnectionString;
        }

        public string ServerName
        {
            get { return _serverName; }
            set
            {
                _serverName = value;

                SqlConnectionStringBuilder sqlStringBldr = new SqlConnectionStringBuilder();
                sqlStringBldr.DataSource = _serverName;
                sqlStringBldr.InitialCatalog = _databaseName;
                sqlStringBldr.IntegratedSecurity = true;
                _sqlConnStr = sqlStringBldr.ConnectionString;
            }
        }

        public string DatabaseName
        {
            get { return _databaseName; }
            set
            {
                _databaseName = value;

                SqlConnectionStringBuilder sqlStringBldr = new SqlConnectionStringBuilder();
                sqlStringBldr.DataSource = _serverName;
                sqlStringBldr.InitialCatalog = _databaseName;
                sqlStringBldr.IntegratedSecurity = true;
                _sqlConnStr = sqlStringBldr.ConnectionString;
            }
        }

        /// <summary>
        /// Wrapper for calling p_test_passes_create_test_pass
        /// </summary>
        /// <param name="testrunStart">DateTime the test run was launched.</param>
        /// <param name="username">User that launched this test run</param>
        /// <param name="targetAssemblyVersion">Version of the DLL that contains this test case</param>
        /// <param name="targetAssemblyModified">Modified date of the DLL (used to identify different privates of the same build)</param>
        /// <returns>i_test_pass_id - Unique ID for this test pass</returns>
        public int TestPassCreateTestPass(DateTime testrunStart, string username,
	                    string targetAssemblyVersion, DateTime targetAssemblyModified)
        {
            int testPassId = 0;

            using (SqlConnection sqlConn = new SqlConnection(_sqlConnStr))
            {
                using (SqlCommand sqlCommand = new SqlCommand("dbo.p_test_passes_create_test_pass", sqlConn))
                {
                    sqlCommand.CommandType = System.Data.CommandType.StoredProcedure;
                    sqlCommand.Parameters.Add("@dt_testrun_start", System.Data.SqlDbType.DateTime).Value = testrunStart;
                    sqlCommand.Parameters.Add("@vc_username", System.Data.SqlDbType.NVarChar, 16).Value = username;
                    sqlCommand.Parameters.Add("@vc_target_assembly_version", System.Data.SqlDbType.NVarChar, 16).Value = targetAssemblyVersion;
                    sqlCommand.Parameters.Add("@dt_target_assembly_modified", System.Data.SqlDbType.DateTime).Value = targetAssemblyModified;
                    SqlParameter sqlParam = sqlCommand.Parameters.Add("@i_test_pass_id", System.Data.SqlDbType.Int);
                    sqlParam.Direction = System.Data.ParameterDirection.Output;

                    sqlConn.Open();
                    sqlCommand.ExecuteNonQuery();
                    if (sqlParam.Value == DBNull.Value)
                    {
                        // No rows were modified or the return value was null so the insert may have failed
                        testPassId = -1;
                    }
                    else
                    {
                        testPassId = (int)sqlParam.Value;
                    }
                }
            }

            return testPassId;
        }

        /// <summary>
        /// Wrapper for calling p_test_passes_set_test_pass_state
        /// </summary>
        /// <param name="testPassId">i_test_pass_id - Unique ID for this test pass</param>
        /// <param name="testPassStateId">i_test_pass_state_id from the t_test_pass_states table</param>
        /// <returns>Test Pass State as a string (after being updated in the table).</returns>
        public string TestPassSetTestPassState(int testPassId, int testPassStateId)
        {
            string testPassState = null;

            using (SqlConnection sqlConn = new SqlConnection(_sqlConnStr))
            {
                using (SqlCommand sqlCommand = new SqlCommand("dbo.p_test_passes_set_test_pass_state", sqlConn))
                {
                    sqlCommand.CommandType = System.Data.CommandType.StoredProcedure;
                    sqlCommand.Parameters.Add("@i_test_pass_id", System.Data.SqlDbType.Int).Value = testPassId;
                    sqlCommand.Parameters.Add("@i_test_pass_state_id", System.Data.SqlDbType.Int).Value = testPassStateId;
                    SqlParameter sqlParam = sqlCommand.Parameters.Add("@vc_test_pass_state", System.Data.SqlDbType.NVarChar, 20);
                    sqlParam.Direction = System.Data.ParameterDirection.Output;

                    sqlConn.Open();
                    sqlCommand.ExecuteNonQuery();
                    if (sqlParam.Value != DBNull.Value)
                    {
                        testPassState = (string)sqlParam.Value;
                    }
                }
            }

            return testPassState;
        }

        /// <summary>
        /// Gets the test pass information for the provided Test Pass Id
        /// </summary>
        /// <param name="testPassId">Unique ID for a test pass</param>
        /// <returns>class TestPassView 
        ///     (wrapper for the v_results_test_passes view)</returns>
        public TestPassView TestPassesGetTestPass(int testPassId)
        {
            TestPassView testPass = null;

            using (SqlConnection sqlConn = new SqlConnection(_sqlConnStr))
            {
                using (SqlCommand sqlCommand = new SqlCommand("dbo.p_test_passes_get_test_pass", sqlConn))
                {
                    sqlCommand.CommandType = System.Data.CommandType.StoredProcedure;
                    sqlCommand.Parameters.Add("@i_test_pass_id", System.Data.SqlDbType.Int).Value = testPassId;

                    sqlConn.Open();
                    using(SqlDataReader sqlResults = sqlCommand.ExecuteReader())
                    {
                        if (sqlResults.FieldCount != 6)
                        {
                            // invalid field count
                            // TODO: Log to even log
                            throw new InvalidDataException(string.Format(
                                "Incorrect number of columns returned by p_test_passes_get_test_pass. Expected 6, Received {0}",
                                sqlResults.FieldCount));
                        }
                        else if (sqlResults.HasRows == true)
                        {
                            sqlResults.Read();
                            testPass = new TestPassView();
                            testPass.TestPassId = sqlResults.GetInt32(0);
                            testPass.Username = sqlResults.GetString(1);
                            testPass.TestrunStart = sqlResults.GetDateTime(2);
                            testPass.TargetAssemblyVersion = sqlResults.GetString(3);
                            testPass.TestPassState = sqlResults.GetString(4);
                            testPass.TestPassStateId = sqlResults.GetInt32(5);
                        }
                    }
                }
            }

            return testPass;
        }

        /// <summary>
        /// Wrapper for calling p_results_set_test_result
        /// </summary>
        /// <param name="testCaseId">Link to the Test Case in the Test Cases Table</param>
        /// <param name="testPassId">Link to the Test Pass in the Test Passes Table</param>
        /// <param name="testClient">Client machine this test result came from.</param>
        /// <param name="runTime">The number of milliseconds the case takes to run.</param>
        /// <param name="testResultValueId">Result of the test case. (t_test_result_values)</param>
        /// <param name="log">Log of the test case (can be null)</param>
        /// <returns>i_test_result_id - Unique ID for this test result</returns>
        public int TestResultCreateTestResult(int testCaseId, int testPassId, string testClient,
	                                            int runTime,	int testResultValueId,	string log)
        {
            int testResultId = 0;

            using (SqlConnection sqlConn = new SqlConnection(_sqlConnStr))
            {
                using (SqlCommand sqlCommand = new SqlCommand("dbo.p_results_set_test_result", sqlConn))
                {
                    sqlCommand.CommandType = System.Data.CommandType.StoredProcedure;
                    sqlCommand.Parameters.Add("@i_test_case_id", System.Data.SqlDbType.Int).Value = testCaseId;
                    sqlCommand.Parameters.Add("@i_test_pass_id", System.Data.SqlDbType.Int).Value = testPassId;
                    sqlCommand.Parameters.Add("@vc_test_client", System.Data.SqlDbType.NVarChar, 50).Value = testClient;
                    sqlCommand.Parameters.Add("@i_run_time", System.Data.SqlDbType.Int).Value = runTime;
                    sqlCommand.Parameters.Add("@i_test_result_value_id", System.Data.SqlDbType.Int).Value = testResultValueId;
                    if ((log != null) && (log != "")) // Log is optional. if its empty or null just don't pass it
                    {
                        sqlCommand.Parameters.Add("@vc_log", System.Data.SqlDbType.NVarChar, 4000).Value = log;
                    }
                    SqlParameter sqlParam = sqlCommand.Parameters.Add("@i_test_result_id", System.Data.SqlDbType.Int);
                    sqlParam.Direction = System.Data.ParameterDirection.Output;

                    sqlConn.Open();
                    sqlCommand.ExecuteNonQuery(); // The return value is always -1
                    if (sqlParam.Value == DBNull.Value)
                    {
                        // No rows were modified or the return value was null so the insert may have failed
                        testResultId = -1;
                    }
                    else
                    {
                        testResultId = (int)sqlParam.Value;
                    }
                }
            }

            return testResultId;
        }

        /// <summary>
        /// Gets the test results for the provided Test Pass Id
        /// </summary>
        /// <param name="testPassId">Unique ID for a test pass</param>
        /// <returns>Array of class TestCaseResultView 
        ///     (wrapper for the v_results_test_case_results view)</returns>
        public TestCaseResultView[] TestResultGetTestPassResults(int testPassId)
        {
            TestCaseResultView[] testPassResults = null;

            using (SqlConnection sqlConn = new SqlConnection(_sqlConnStr))
            {
                using (SqlCommand sqlCommand = new SqlCommand("dbo.p_results_get_test_pass_results", sqlConn))
                {
                    sqlCommand.CommandType = System.Data.CommandType.StoredProcedure;
                    sqlCommand.Parameters.Add("@i_test_pass_id", System.Data.SqlDbType.Int).Value = testPassId;

                    sqlConn.Open();
                    using (SqlDataReader sqlResults = sqlCommand.ExecuteReader())
                    {
                        if (sqlResults.FieldCount != 15)
                        {
                            // No rows returned or invalid field count
                            // TODO: change this to write to the event log
                            throw new InvalidDataException(string.Format(
                                "Incorrect number of columns returned by p_results_get_test_pass_results. Expected 15, Received {0}",
                                sqlResults.FieldCount));
                        }
                        else if (sqlResults.HasRows == true)
                        {
                            List<TestCaseResultView> tempTestPassResults = new List<TestCaseResultView>();
                            TestCaseResultView tempTestPassResult;
                            while (sqlResults.Read())
                            {
                                tempTestPassResult = new TestCaseResultView();

                                tempTestPassResult.TestCaseName = sqlResults.GetString(0);
                                tempTestPassResult.Username = sqlResults.GetString(1);
                                tempTestPassResult.TestrunStart = sqlResults.GetDateTime(2);
                                tempTestPassResult.TestType = sqlResults.GetString(3);
                                tempTestPassResult.TargetComponent = sqlResults.GetString(4);
                                tempTestPassResult.TargetAssemblyVersion = sqlResults.GetString(5);
                                tempTestPassResult.TestClient = sqlResults.GetString(6);
                                tempTestPassResult.RunTime = sqlResults.GetInt64(7);
                                tempTestPassResult.TestResult = sqlResults.GetString(8);
                                if (sqlResults[9] != DBNull.Value) // Log can be null
                                {
                                    tempTestPassResult.Log = sqlResults.GetString(9);
                                }
                                tempTestPassResult.TestPassId = sqlResults.GetInt32(10);
                                tempTestPassResult.TestCaseId = sqlResults.GetInt32(11);
                                tempTestPassResult.TestResultId = sqlResults.GetInt32(12);
                                tempTestPassResult.TestTypeId = sqlResults.GetInt32(13);
                                tempTestPassResult.TestResultValueId = sqlResults.GetInt32(14);

                                tempTestPassResults.Add(tempTestPassResult);
                            } // end while
                            testPassResults = tempTestPassResults.ToArray();
                        } // end if else
                    } // end using data reader
                } // end using command
            } // end using connection

            return testPassResults;
        }

        /// <summary>
        /// Gets the test results for the provided Test Pass Id
        /// </summary>
        /// <param name="testResultId">Unique ID for a test case result</param>
        /// <returns>class TestCaseResultView 
        ///     (wrapper for the v_results_test_case_results view)</returns>
        public TestCaseResultView TestResultGetTestPassResult(int testResultId)
        {
            TestCaseResultView testCaseResult = null;

            using (SqlConnection sqlConn = new SqlConnection(_sqlConnStr))
            {
                using (SqlCommand sqlCommand = new SqlCommand("dbo.p_results_get_test_case_result", sqlConn))
                {
                    sqlCommand.CommandType = System.Data.CommandType.StoredProcedure;
                    sqlCommand.Parameters.Add("@i_test_result_id", System.Data.SqlDbType.Int).Value = testResultId;

                    sqlConn.Open();
                    using (SqlDataReader sqlResults = sqlCommand.ExecuteReader())
                    {
                        if (sqlResults.FieldCount != 15)
                        {
                            // No rows returned or invalid field count
                            // TODO: change this to write to the event log
                            throw new InvalidDataException(string.Format(
                                "Incorrect number of columns returned by p_results_get_test_pass_results. Expected 15, Received {0}",
                                sqlResults.FieldCount));
                        }
                        else if (sqlResults.HasRows == true)
                        {
                            TestCaseResultView tempTestCaseResult = new TestCaseResultView();

                            sqlResults.Read();
                            tempTestCaseResult.TestCaseName = sqlResults.GetString(0);
                            tempTestCaseResult.Username = sqlResults.GetString(1);
                            tempTestCaseResult.TestrunStart = sqlResults.GetDateTime(2);
                            tempTestCaseResult.TestType = sqlResults.GetString(3);
                            tempTestCaseResult.TargetComponent = sqlResults.GetString(4);
                            tempTestCaseResult.TargetAssemblyVersion = sqlResults.GetString(5);
                            tempTestCaseResult.TestClient = sqlResults.GetString(6);
                            tempTestCaseResult.RunTime = sqlResults.GetInt64(7);
                            tempTestCaseResult.TestResult = sqlResults.GetString(8);
                            if (sqlResults[9] != DBNull.Value) // Log can be null
                            {
                                tempTestCaseResult.Log = sqlResults.GetString(9);
                            }
                            tempTestCaseResult.TestPassId = sqlResults.GetInt32(10);
                            tempTestCaseResult.TestCaseId = sqlResults.GetInt32(11);
                            tempTestCaseResult.TestResultId = sqlResults.GetInt32(12);
                            tempTestCaseResult.TestTypeId = sqlResults.GetInt32(13);
                            tempTestCaseResult.TestResultValueId = sqlResults.GetInt32(14);

                            testCaseResult = tempTestCaseResult;
                        } // end if else
                    } // end using data reader
                } // end using command
            } // end using connection

            return testCaseResult;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XLASys\Common\EventLogger.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using System.Threading;

namespace XLASys
{
    public enum EventCategoryId : short
    {
        General = 0
    }
    public enum EventId : int
    {
        // TODO: Add our own custom error codes
        ProductStudioDiagnostic = 7,
        WorkflowStart = 777,
        WorkflowFailed = 23,
        ProductStudioException = 888,
        WorkflowBug = 666,
        TransferFailed = 876,
        NetPropDiagnostic = 8,
    }

    public class GlobalEventLogger
    {
        private static System.Diagnostics.EventLog applicationLog;

        static GlobalEventLogger()
        {
            String source = "XLASys - XBL Test Automation System";
            if (!EventLog.SourceExists(source))
            {
                EventLog.CreateEventSource(source, "Application");

                while (!EventLog.SourceExists(source))
                    Thread.Sleep(1000);
            }

            applicationLog = new EventLog("Application");
            applicationLog.Source = source;
        }

        public void WriteInformation(EventId eventId, String format, params Object[] args)
        {
            WriteInformation(EventCategoryId.General, eventId, format, args);
        }
        public void WriteInformation(EventCategoryId categoryId, EventId eventId, String format, params Object[] args)
        {
            WriteLog(categoryId, eventId, EventLogEntryType.Information, format, args);
        }

        public void WriteWarning(EventId eventId, String format, params Object[] args)
        {
            WriteWarning(EventCategoryId.General, eventId, format, args);
        }
        public void WriteWarning(EventCategoryId categoryId, EventId eventId, String format, params Object[] args)
        {
            WriteLog(categoryId, eventId, EventLogEntryType.Warning, format, args);
        }

        public void WriteError(EventId eventId, String format, params Object[] args)
        {
            WriteError(EventCategoryId.General, eventId, format, args);
        }
        public void WriteError(EventCategoryId categoryId, EventId eventId, String format, params Object[] args)
        {
            WriteLog(categoryId, eventId, EventLogEntryType.Error, format, args);
        }

        public static void WriteLog(EventCategoryId categoryId, EventId eventId, EventLogEntryType type, String format, params Object[] args)
        {
            String message = String.Format(format, args);

            if (message.Length > 32000)
                message = message.Remove(32000);

            applicationLog.WriteEntry(message, type, (int)eventId, (short)categoryId);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XLASys\Common\TestPassView.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace XLASys
{
    /// <summary>
    /// Class Wrapper for the v_results_test_passes view
    /// 
    /// Returned by:
    /// p_test_passes_get_test_pass
    /// p_test_passes_get_test_passes
    /// </summary>
    public class TestPassView
    {
        protected int _test_pass_id;
        protected string _username;
        protected DateTime _testrun_start;
        protected string _target_assembly_version;
        protected string _test_pass_state;
        protected int _test_pass_state_id;

        public TestPassView()
        {
            _test_pass_id = 0;
            _username = "";
            _testrun_start = DateTime.Now;
            _target_assembly_version = "";
            _test_pass_state = "";
            _test_pass_state_id = 0;
        }

        public TestPassView(int test_pass_id,
                            string username,
                            DateTime testrun_start,
                            string target_assembly_version,
                            string test_pass_state,
                            int test_pass_state_id)
        {
            _test_pass_id = test_pass_id;
            _username = username;
            _testrun_start = testrun_start;
            _target_assembly_version = target_assembly_version;
            _test_pass_state = test_pass_state;
            _test_pass_state_id = test_pass_state_id;
        }

        public int TestPassId
        {
            get { return _test_pass_id; }
            set { _test_pass_id = value; }
        }

        public string Username
        {
            get { return _username; }
            set { _username = value; }
        }

        public DateTime TestrunStart
        {
            get { return _testrun_start; }
            set { _testrun_start = value; }
        }

        public string TargetAssemblyVersion
        {
            get { return _target_assembly_version; }
            set { _target_assembly_version = value; }
        }

        public string TestPassState
        {
            get { return _test_pass_state; }
            set { _test_pass_state = value; }
        }

        public int TestPassStateId
        {
            get { return _test_pass_state_id; }
            set { _test_pass_state_id = value; }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XlastAuto\Validators\BlastOutputValidator.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;

using ServerTestFramework;

namespace XlastAuto
{
    class BlastOutputValidator : IValidator
    {
        private const string ErrorMsg = ": error :";
        //private const string WarningMsg = ": warning :";

        public bool ExpectNoErrors(ExecutionResults results, String [] expectedOutputFiles)
        {
            bool succeeded = true;
            string output = results.StdOut;


            // Check that the return code is ok
            if (results.ErrorCode != 0)
            {
                succeeded = false;
                Global.RO.Error("Unexpected Error Code : " + results.ErrorCode);
            }

            // Check that there is no error in output
            if (output.Contains(ErrorMsg))
            {
                succeeded = false;
                Global.RO.Error("Error message detected in output");
            }

            if (expectedOutputFiles != null)
            {
                // Verify that the output files match the expected output files
                foreach (String expectedOutputFile in expectedOutputFiles)
                {
                    String actualOutputFile = expectedOutputFile.Replace("-expected", "");
                    FileInfo fi = new FileInfo(expectedOutputFile);

                    if (!fi.Exists)
                    {
                        Global.RO.Error(expectedOutputFile + " not found. Failing the test case. Copy actual output to " + expectedOutputFile);
                        succeeded = false;
                        continue;
                    }

                    // Check the outpt file with the same filename as the expected output file name
                    FileInfo afi = new FileInfo(actualOutputFile);

                    if (!afi.Exists)
                    {
                        Global.RO.Info(afi.FullName + " not found. Failing the test case");
                        succeeded = false;
                        continue;
                    }

                    // Expected and actual outputfile exist. Compare them
                    StreamReader expected = new StreamReader(fi.FullName);
                    StreamReader actual = new StreamReader(afi.FullName);

                    int line = 1;
                    while ((!expected.EndOfStream) && (!actual.EndOfStream))
                    {
                        String expLine = expected.ReadLine();
                        String actualLine = actual.ReadLine();
                                                
                        if (expLine != actualLine)
                        {
                            bool match = false;

                            // Try to fallback to regexp comparison
                            if (expLine.Contains("{*}"))
                            {
                                String regStr = expLine.Replace("{*}", ".*");

                                // Replace problematic characters with escaped version
                                regStr = regStr.Replace("(", "\\(");
                                regStr = regStr.Replace(")", "\\)");                                
                                regStr = regStr.Replace("{", "\\{");
                                regStr = regStr.Replace("}", "\\}");

                                regStr = regStr.Replace("[", "\\[");
                                regStr = regStr.Replace("]", "\\]");

                                // Compare lines using regular expressions
                                Regex pattern = new Regex(regStr);

                                if (pattern.IsMatch(actualLine))
                                {
                                    match = true;
                                }
                                else
                                {
                                    match = false;
                                }
                            }

                            if (!match)
                            {
                                Global.RO.Error("Expected output file '" + fi.FullName + "' and actual output file '" + afi.FullName + "' differ at line : " + line);
                                succeeded = false;
                                break;
                            }
                        }

                        line++;
                    }

                    if (succeeded)
                    {
                        if (!expected.EndOfStream)
                        {
                            Global.RO.Error("Expected output file '" + fi.FullName + "' is longer than Actual output file '" + afi.FullName + "'");
                        }

                        if (!actual.EndOfStream)
                        {
                            Global.RO.Error("Actual output file '" + afi.FullName + "' is longer than Expected output file '" + fi.FullName + "'");
                        }
                    }

                    expected.Close();
                    actual.Close();
                }
            }

            return succeeded;
        }

        public bool ExpectNoErrors(ExecutionResults results)
        {
            return ExpectNoErrors(results, null);
        }

        public bool ExpectError(ExecutionResults results, int errorCode, string expect)
        {
            bool succeeded = false;
            string output = results.StdOut;

            if ((output.Contains(expect)) && (errorCode == results.ErrorCode))
            {
                succeeded = true;
            }
            else
            {
                if (errorCode != results.ErrorCode)
                {
                    Global.RO.Error("Expected errorCode " + errorCode + " but got " + results.ErrorCode);
                }
                else
                {
                    Global.RO.Error("Could not find expected error message : '" + expect + "'"); 
                }
            }

            return succeeded;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XLASys\Common\TestCaseResult.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace XLASys
{
    /// <summary>
    /// Class Wrapper for the v_results_test_case_results view
    /// 
    /// Returned by:
    /// p_results_get_test_pass_results
    /// p_results_get_test_case_results
    /// p_results_get_test_case_result
    /// </summary>
    public class TestCaseResultView
    {
        protected string _vc_test_case_name;
        protected string _vc_username;
        protected DateTime _dt_testrun_start;
        protected string _vc_test_type;
        protected string _vc_target_component;
        protected string _vc_target_assembly_version;
        protected string _vc_test_client;
        protected long _bi_run_time; 
        protected string _vc_test_result;
        protected string _vc_log;
        protected int _i_test_pass_id;
        protected int _i_test_case_id;
        protected int _i_test_result_id;
        protected int _i_test_type_id;
        protected int _i_test_result_value_id;

        public TestCaseResultView()
        {
            _vc_test_case_name = "";
            _vc_username = "";
            _dt_testrun_start = DateTime.Now;
            _vc_test_type = "";
            _vc_target_component = "";
            _vc_target_assembly_version = "";
            _vc_test_client = "";
            _bi_run_time = 0;
            _vc_test_result = "";
            _vc_log = "";
            _i_test_pass_id = 0;
            _i_test_case_id = 0;
            _i_test_result_id = 0;
            _i_test_type_id = 0;
            _i_test_result_value_id = 0;
        }

        public TestCaseResultView(string vc_test_case_name,
                            string vc_username,
                            DateTime dt_testrun_start,
                            string vc_test_type,
                            string vc_target_component,
                            string vc_target_assembly_version,
                            string vc_test_client,
                            long bi_run_time, 
                            string vc_test_result,
                            string vc_log,
                            int i_test_pass_id,
                            int i_test_case_id,
                            int i_test_result_id,
                            int i_test_type_id,
                            int i_test_result_value_id)
        {
            _vc_test_case_name = vc_test_case_name;
            _vc_username = vc_username;
            _dt_testrun_start = dt_testrun_start;
            _vc_test_type = vc_test_type;
            _vc_target_component = vc_target_component;
            _vc_target_assembly_version = vc_target_assembly_version;
            _vc_test_client = vc_test_client;
            _bi_run_time = bi_run_time;
            _vc_test_result = vc_test_result;
            _vc_log = vc_log;
            _i_test_pass_id = i_test_pass_id;
            _i_test_case_id = i_test_case_id;
            _i_test_result_id = i_test_result_id;
            _i_test_type_id = i_test_type_id;
            _i_test_result_value_id = i_test_result_value_id;
        }

        public string TestCaseName
        {
            get { return _vc_test_case_name; }
            set { _vc_test_case_name = value; }
        }

        public string Username
        {
            get { return _vc_username; }
            set { _vc_username = value; }
        }
        
        public DateTime TestrunStart
        {
            get { return _dt_testrun_start; }
            set { _dt_testrun_start = value; }
        }
        
        public string TestType
        {
            get { return _vc_test_type; }
            set { _vc_test_type = value; }
        }
        
        public string TargetComponent
        {
            get { return _vc_target_component; }
            set { _vc_target_component = value; }
        }
        
        public string TargetAssemblyVersion
        {
            get { return _vc_target_assembly_version; }
            set { _vc_target_assembly_version = value; }
        }
        
        public string TestClient
        {
            get { return _vc_test_client; }
            set { _vc_test_client = value; }
        }
        
        public long RunTime
        {
            get { return _bi_run_time; }
            set { _bi_run_time = value; }
        }
        
        public string TestResult
        {
            get { return _vc_test_result; }
            set { _vc_test_result = value; }
        }
        
        public string Log
        {
            get { return _vc_log; }
            set { _vc_log = value; }
        }
        
        public int TestPassId
        {
            get { return _i_test_pass_id; }
            set { _i_test_pass_id = value; }
        }
        
        public int TestCaseId
        {
            get { return _i_test_case_id; }
            set { _i_test_case_id = value; }
        }
        
        public int TestResultId
        {
            get { return _i_test_result_id; }
            set { _i_test_result_id = value; }
        }
        
        public int TestTypeId
        {
            get { return _i_test_type_id; }
            set { _i_test_type_id = value; }
        }
        
        public int TestResultValueId
        {
            get { return _i_test_result_value_id; }
            set { _i_test_result_value_id = value; }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XLASys\Controller\ControllerForm.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;
using System.IO;

using livetest.core;

namespace XLASys
{
    public partial class ControllerForm : Form, IMessageHandler
    {
        private Report _report = new Report("Controller");
        private FileManager _fileManager = new FileManager(@"c:\temp\");

        public ControllerForm()
        {
            // Subscribe to FileManager events...
            _fileManager.Update += new Notify(_fileManager_Update);

            string path = @"c:\temp\SPACTest.dll";
            //string path = @"C:\src\xonline\private\test\StfTests\XLASys\Controller\bin\Debug\temp";
             using (StreamWriter sw = File.CreateText(path)) {}
             string path2 = @"C:\src\xonline\private\test\StfTests\SPAC\objd\i386\SPACTest.dll";

            // Ensure that the target does not exist.
            File.Delete(path);

            // Copy the file.
            File.Copy(path2, path);

            
            // Set up a report target
            Report.Root.AddReportDestination(new DebugOutputReportDestination());

            // Register this class as a message handler for the common channel
            _report.Debug("Registering as a message handler on channel '{0}'", XLASysCommon.COMMON_CHANNEL_NAME);
            Bus.Default.RegisterChannel(XLASysCommon.COMMON_CHANNEL_NAME, this);

            InitializeComponent();
        }

        /// <summary>
        /// Recieve updates from the File Manager as it monitors the files.
        /// </summary>
        /// <param name="sender">Sender</param>
        /// <param name="e">Message</param>
        void _fileManager_Update(object sender, FileManagerEventArgs e)
        {
            // Create a item and add it just like we recieved a message from a client to keep updates together in the list...
            ListViewItem msgItem = new ListViewItem();
            msgItem.Text = DateTime.Now.ToString();
            msgItem.SubItems.Add("FileManager");
            msgItem.SubItems.Add("");
            msgItem.SubItems.Add("");
            msgItem.SubItems.Add(e.Action);
            msgItem.SubItems.Add(e.Message);
            DisplayMessage(msgItem);
           
        }

        private delegate void DisplayMessageDelegate(ListViewItem msgItem);
        private void DisplayMessage(ListViewItem msgItem)
        {
            if (listView1 == null) return;
            if (listView1.InvokeRequired == true)
            {
                // We're being called from another thread - use a delegate
                DisplayMessageDelegate displayMessage = new DisplayMessageDelegate(DisplayMessage);
                Invoke(displayMessage, new object[] { msgItem });
            }
            else
            {
                // We're being called from the UI thread - do the work
                listView1.Items.Add(msgItem);
            }
        }

        #region IMessageHandler Members

        public void HandleMessage(livetest.core.Message msg)
        {
            // Since this is on a different thread, we need to call a delegate to display the message in the UI
            _report.Debug("Message Received: {0}", msg.Name);
            if (BusManager.KeepAlive != msg.Name)
            {
                ListViewItem msgItem = new ListViewItem();

                msgItem.Text = DateTime.Now.ToString();
                msgItem.SubItems.Add(msg.Name);
                msgItem.SubItems.Add(msg.Src);
                msgItem.SubItems.Add(msg.Dst == BusManager.AnyChannel ? "Broadcast" : msg.Dst);
                if (msg.Payload != null)
                {
                    msgItem.SubItems.Add(msg.Payload.GetType().Name);
                    msgItem.SubItems.Add(msg.Payload.ToString());
                }
                else
                {
                    msgItem.SubItems.Add("None");
                    msgItem.SubItems.Add("None");
                }
                DisplayMessage(msgItem);

                if (XLASysCommon.MESSAGE_CONNECT == msg.Name)
                {

                }
            }
        }

        #endregion

        private void ControllerForm_FormClosed(object sender, FormClosedEventArgs e)
        {
            BusManager.Instance.Shutdown();
            Application.Exit();
        }

        private void ControllerForm_Load(object sender, EventArgs e)
        {

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XLASys\Controller\database.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Data.SqlClient;
using System.Text;

namespace XLASys
{
    public class XBLDistAutoDB
    {
        private const string DefaultServerName = "TrevormXblob";
        private const string DefaultDatabaseName = "XBLDistAuto";

        private string _sqlConnStr = "";

        public XBLDistAutoDB() : this(DefaultServerName, DefaultDatabaseName)
        {
        }

        public XBLDistAutoDB(string serverName, string databaseName)
        {
            SqlConnectionStringBuilder sqlStringBldr = new SqlConnectionStringBuilder();
            sqlStringBldr.DataSource = serverName;
            sqlStringBldr.InitialCatalog = databaseName;
            sqlStringBldr.IntegratedSecurity = true;
            _sqlConnStr = sqlStringBldr.ConnectionString;
        }

        public int FileLog(string fileName, DateTime fileVersion)
        {
            int testAsmId = 0;

            using (SqlConnection sqlConn = new SqlConnection(_sqlConnStr))
            {
                SqlCommand sqlCommand = new SqlCommand("dbo.p_test_assemblies_set_asm", sqlConn);
                sqlCommand.CommandType = System.Data.CommandType.StoredProcedure;

                sqlCommand.Parameters.Add("@vc_test_assembly_name", System.Data.SqlDbType.NVarChar).Value = fileName;
                sqlCommand.Parameters.Add("@dt_test_assembly_version", System.Data.SqlDbType.DateTime).Value = fileVersion;
                SqlParameter sqlParam = sqlCommand.Parameters.Add("@i_test_assembly_id", System.Data.SqlDbType.Int);
                sqlParam.Direction = System.Data.ParameterDirection.Output;

                sqlConn.Open();
                if ((sqlCommand.ExecuteNonQuery() != 1) || (sqlParam.Value == DBNull.Value))
                {
                    // No rows were modified or the insert have failed
                    testAsmId = -1;
                }
                else
                {
                    testAsmId = (int)sqlParam.Value;
                }
                sqlConn.Close();
            }
            
            return testAsmId;
        }

        //Wrapper for calling p_testcases_set_test_case
        public int CreateTestCases(string testCaseName, string testGroupName,
	                    int asmId, string targetComponent, int testType, Int64 runtimeAvg)
        {
            int testCaseId = 0;

            using (SqlConnection sqlConn = new SqlConnection(_sqlConnStr))
            {
                SqlCommand sqlCommand = new SqlCommand("dbo.p_testcases_set_test_case", sqlConn);
                sqlCommand.CommandType = System.Data.CommandType.StoredProcedure;

                sqlCommand.Parameters.Add("@vc_test_case_name", System.Data.SqlDbType.NVarChar).Value = testCaseName;
                sqlCommand.Parameters.Add("@vc_test_group_name", System.Data.SqlDbType.NVarChar).Value = testGroupName;
                sqlCommand.Parameters.Add("@i_test_assembly_id", System.Data.SqlDbType.Int,16).Value = asmId;
                sqlCommand.Parameters.Add("@vc_target_component", System.Data.SqlDbType.NVarChar).Value = targetComponent;
                sqlCommand.Parameters.Add("@i_test_type_id", System.Data.SqlDbType.Int,16).Value = testType;
                sqlCommand.Parameters.Add("@i_run_time_average", System.Data.SqlDbType.Int,32).Value = runtimeAvg;
                SqlParameter sqlParam = sqlCommand.Parameters.Add("@i_test_case_id", System.Data.SqlDbType.Int);
                sqlParam.Direction = System.Data.ParameterDirection.Output;

                sqlConn.Open();
                if ((sqlCommand.ExecuteNonQuery() != 1) || (sqlParam.Value == DBNull.Value))
                {
                    // No rows were modified or the insert have failed
                    testCaseId = -1;
                }
                else
                {
                    testCaseId = (int)sqlParam.Value;
                }
                sqlConn.Close();
            }
            
            return testCaseId;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XLASys\Controller\AttrExcepts.cs ===
using System;
using System.Net;

namespace XLASys
{
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple=false, Inherited=false)]
    public class DescriptionAttribute : Attribute
    {
        protected string desc;
        public string Desc
        {
            get {return desc;}
        }

        public DescriptionAttribute(string desc)
        {
            this.desc = desc;
        }
    }

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, Inherited=true)]
    public class TestCaseAttribute : Attribute
    {
        public TestCaseAttribute()
        {
        }
        public TestCaseAttribute(bool catchExceptions)
        {
            CatchExceptions = catchExceptions;
        }
        public TestCaseAttribute(int bugID)
        {
            BugID = bugID;
        }
        public TestCaseAttribute(bool catchExceptions, int bugID)
        {
            CatchExceptions = catchExceptions;
            BugID = bugID;
        }
        public TestCaseAttribute(System.Type expectedException)
        {
            if(!expectedException.IsSubclassOf(typeof(System.Exception)))
            {
                //Msg(expectedException.ToString() + " is not a subclass of System.Exception.");
                ExpectedException = null;
            }
            else
                ExpectedException = expectedException;

            CatchExceptions = true;
        }
        public TestCaseAttribute(System.Type expectedException, int bugID)
        {
            if(!expectedException.IsSubclassOf(typeof(System.Exception)))
            {
                //Global.RO.Error(expectedException.ToString() + " is not a subclass of System.Exception.");
                ExpectedException = null;
            }
            else
                ExpectedException = expectedException;

            CatchExceptions = true;
            BugID = bugID;
        }
        public bool CatchExceptions = true;
        public int BugID = 0;
        public System.Type ExpectedException = null;
    }

    /// <summary>
    /// allow an alias for Attribute "[TestCase]" to be "[Test]", like NUnit
    /// </summary> 
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, Inherited=true)]
    public class TestAttribute : TestCaseAttribute
    {
    }

    /// <summary>
    /// marks a function as a setup method.  These methods are executed
    /// just before a set of tests are run.
    /// </summary> 
    [AttributeUsage(AttributeTargets.Method)]
    public class TestGroupSetupAttribute : Attribute
    {
    }

    /// <summary>
    /// marks a function as an tear-down method.  These methods are executed
    /// just after a set of tests are run.
    /// </summary> 
    [AttributeUsage(AttributeTargets.Method)]
    public class TestGroupTearDownAttribute : Attribute
    {
    }

    [AttributeUsage(AttributeTargets.Class, Inherited=true)]
    public class TestGroupAttribute : Attribute
    {
    }

    /// <summary>
    /// allow an alias for Attribute "[TestGroup]" to be "[TestFixture]", like NUnit
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited=true)]
    public class TestFixtureAttribute : TestGroupAttribute
    {
    }

    [AttributeUsage(AttributeTargets.Class, Inherited=true)]
    public class StressTestAttribute : Attribute
    {
        public float Priority = 0;
        public bool CatchExceptions = true;
        public bool Counters = false;

        public StressTestAttribute()
        {
        }

        public StressTestAttribute(float priority)
        {
            this.Priority = priority;
        }

        public StressTestAttribute(float priority, bool usePerfCounters)
        {
            this.Priority = priority;
            this.Counters = usePerfCounters;
        }

        public StressTestAttribute(bool usePerfCounters)
        {
            this.Counters = usePerfCounters;
        }
    }

    /// <summary>
    /// This feature should be used to temporarily not run a TestCase or TestGroup. 
    /// This is a better mechanism than commenting out the testCase/testGroup,
    /// since the tests will be compiled with the rest of the code and there is an 
    /// indication at run time that a test is not being run. This insures that tests will not be forgotten.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, Inherited=true)]
    public class IgnoreAttribute : Attribute
    {
        public IgnoreAttribute()
        {
        }

        public IgnoreAttribute(string desc)
        {
        }
    }
    /// <summary>
    /// This attribute can be applied to TestGroup or TestCase
    /// it stands for "Developer Verfication Test"
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited=true)]
    public class DVTAttribute : Attribute
    {
        public DVTAttribute()
        {
        }
    }

    /// <summary>
    /// On a test case, tests with the same AsyncGroup value can run at the same time.  On a group this sets the default AsyncGroup value for all tests in that group.
    /// Test groups with the same AsyncSet value can be run at the same time. (AsyncSet has no meaning for a test case)
    /// A value of 0 means don't run async.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, Inherited=true, AllowMultiple=false)]
    public class AsyncGroupAttribute: Attribute
    {
        //parallel groups        
        protected uint asyncSet;
        public uint AsyncSet { get {return asyncSet;} }

        //parallel test cases within a group
        protected uint asyncGroup;
        public uint AsyncGroup { get {return asyncGroup;} }

        //
        public AsyncGroupAttribute(uint group)
        {
            asyncGroup=group;
        }
        public AsyncGroupAttribute(uint group, uint set)
        {
            asyncGroup=group;
            asyncSet=set;
        }
    };

    /// <summary>
    /// Attribute for a test group for how many threads within the group are allowed to run at the same time.
    /// Default is 8.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited=true, AllowMultiple=false)]
    public class AsyncThreadCountAttribute: Attribute
    {
        protected uint threadCount;
        public uint ThreadCount { get {return threadCount;} }

        public AsyncThreadCountAttribute(uint tcount)
        {
            threadCount=tcount;
        }
    };

    /// <summary>
    /// Attribute for a test group.  Controls the delay (in ms) between thread creations for tests within the group.  This can be useful for preventing a ton of tests from slamming the network system at the exact same moment.
    /// Default is 25ms.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited=true, AllowMultiple=false)]
    public class AsyncThreadDelayAttribute: Attribute
    {
        protected uint threadDelay;
        public uint ThreadDelay { get {return threadDelay;} }

        public AsyncThreadDelayAttribute(uint tdelay)
        {
            threadDelay=tdelay;
        }
    };

    /// <summary>
    /// Attribute for groups and cases.  This specifies that the test case or group should be excluded from the automatic daily functional run.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, Inherited=true, AllowMultiple=false)]
    public class DoNotRunDailyAttribute: Attribute
    {
    };


    public class UnexpectedTestResultException : Exception
    {
        //public XRLPayload xrl = null;
        public UnexpectedTestResultException() : base() { }
        public UnexpectedTestResultException(string message) : base(message) { }
        public UnexpectedTestResultException(string message, Exception inner) : base(message, inner) { }
    }

    public class HarnessException : Exception
    {
        public HarnessException() : base() { }
        public HarnessException(string message) : base(message) { }
        public HarnessException(string message, Exception inner) : base(message, inner) { }
    }

    /// <summary>
    /// Custom Excption class to convey excpetions at the test suite load and run states.
    /// </summary>
    public class TestSuiteException : Exception
    {
        public TestSuiteException( string message) : base(message) {}
        public TestSuiteException( string message, Exception inner) : base(message, inner) {}
    }

    /// <summary>
    /// Custom Exception class to carry and identify failures with an HResult
    /// </summary>
    public class HResultException : Exception
    {
        public override string Message
        {
            get
            {
                return base.Message + ": " /*+ Global.XErrToString(HR)*/;
            }
        }
        public uint HR;
        public HResultException(uint hr) : base() { HR = hr; }
        public HResultException(uint hr, string message) : base(message) { HR = hr; }
        public HResultException(uint hr, string message, Exception inner) : base(message, inner) { HR = hr; }
    }

    /// <summary>
    /// Custom Exception class to carry and identify failures with an X-Err
    /// </summary>
    public class XErrException : Exception
    {
        public uint XErr;
        public XErrException(uint xErr) : base() { XErr = xErr; }
        public XErrException(uint xErr, string message) : base(message) { XErr = xErr; }
        public XErrException(uint xErr, string message, Exception inner) : base(message, inner) { XErr = xErr; }
    }

    /// <summary>
    /// Custom Exception class to carry and identify failures with an Http Status code
    /// </summary>
    public class HttpStatusCodeException : Exception
    {
        public HttpStatusCode StatusCode;
        public HttpStatusCodeException(HttpStatusCode code) : base() { StatusCode = code; }
        public HttpStatusCodeException(HttpStatusCode code, string message) : base(message) { StatusCode = code; }
        public HttpStatusCodeException(HttpStatusCode code, string message, Exception inner) : base(message, inner) { StatusCode = code; }
    }

    /// <summary>
    /// Custom Exception class to identify time out failures
    /// </summary>
    public class TimeOutException : Exception
    {
        public ushort WaitSec; 
        public TimeOutException( ushort waitSec ) : base() { WaitSec = waitSec; }
        public TimeOutException( ushort waitSec, string message) : base(message) { WaitSec = waitSec; }
        public TimeOutException( ushort waitSec, string message, Exception inner) : base(message, inner) { WaitSec = waitSec; }
    }


    /// <summary>
    /// Custom Excption class to carry and identify failures matching a named value.
    /// </summary>
    public class ExpectedValueCheckException : Exception
    {
        public string Name;
        public ExpectedValueCheckException(string name) : base("Value Mismatch! " + name) { Name = name; }
        public ExpectedValueCheckException(string name, string message) : base("Value Mismatch! " + name + ": " + message) { Name = name; }
        public ExpectedValueCheckException(string name, string message, Exception inner) : base("Value Mismatch! " + name + ": " + message, inner) { Name = name; }
    }

    /// <summary>
    /// Generic exception wrapper, allows parameters in the message string. Think of it as
    /// an Exception++.
    /// </summary>
    public class StfException : Exception
    {
        public StfException(string message)
            : base(message)
        {
            /*if (Global.RO != null)
                Global.RO.Error(message);*/
        }
        public StfException(string format, params object[] args)
            : base(String.Format(format, args))
        {
            /*if (Global.RO != null)
                Global.RO.Error(format, args);*/
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XLASys\Controller\ControllerForm.Designer.cs ===
namespace XLASys
{
    partial class ControllerForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.panel1 = new System.Windows.Forms.Panel();
            this.textBox1 = new System.Windows.Forms.TextBox();
            this.groupBox1 = new System.Windows.Forms.GroupBox();
            this.listView1 = new System.Windows.Forms.ListView();
            this.TimestampCol = new System.Windows.Forms.ColumnHeader();
            this.MessageCol = new System.Windows.Forms.ColumnHeader();
            this.SrcAddressCol = new System.Windows.Forms.ColumnHeader();
            this.DstAddressCol = new System.Windows.Forms.ColumnHeader();
            this.PayloadTypeCol = new System.Windows.Forms.ColumnHeader();
            this.PayloadCol = new System.Windows.Forms.ColumnHeader();
            this.panel1.SuspendLayout();
            this.groupBox1.SuspendLayout();
            this.SuspendLayout();
            // 
            // panel1
            // 
            this.panel1.Controls.Add(this.textBox1);
            this.panel1.Dock = System.Windows.Forms.DockStyle.Top;
            this.panel1.Location = new System.Drawing.Point(0, 0);
            this.panel1.Name = "panel1";
            this.panel1.Size = new System.Drawing.Size(808, 110);
            this.panel1.TabIndex = 0;
            // 
            // textBox1
            // 
            this.textBox1.Location = new System.Drawing.Point(12, 12);
            this.textBox1.Multiline = true;
            this.textBox1.Name = "textBox1";
            this.textBox1.Size = new System.Drawing.Size(784, 86);
            this.textBox1.TabIndex = 0;
            // 
            // groupBox1
            // 
            this.groupBox1.Controls.Add(this.listView1);
            this.groupBox1.Dock = System.Windows.Forms.DockStyle.Bottom;
            this.groupBox1.Location = new System.Drawing.Point(0, 117);
            this.groupBox1.Name = "groupBox1";
            this.groupBox1.Size = new System.Drawing.Size(808, 435);
            this.groupBox1.TabIndex = 0;
            this.groupBox1.TabStop = false;
            this.groupBox1.Text = "Received Messages";
            // 
            // listView1
            // 
            this.listView1.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
            this.TimestampCol,
            this.MessageCol,
            this.SrcAddressCol,
            this.DstAddressCol,
            this.PayloadTypeCol,
            this.PayloadCol});
            this.listView1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.listView1.Location = new System.Drawing.Point(3, 16);
            this.listView1.Name = "listView1";
            this.listView1.Size = new System.Drawing.Size(802, 416);
            this.listView1.TabIndex = 0;
            this.listView1.UseCompatibleStateImageBehavior = false;
            this.listView1.View = System.Windows.Forms.View.Details;
            // 
            // TimestampCol
            // 
            this.TimestampCol.Text = "Timestamp";
            this.TimestampCol.Width = 88;
            // 
            // MessageCol
            // 
            this.MessageCol.Text = "Message";
            this.MessageCol.Width = 83;
            // 
            // SrcAddressCol
            // 
            this.SrcAddressCol.Text = "Src Address";
            this.SrcAddressCol.Width = 88;
            // 
            // DstAddressCol
            // 
            this.DstAddressCol.Text = "Dst Address";
            this.DstAddressCol.Width = 81;
            // 
            // PayloadTypeCol
            // 
            this.PayloadTypeCol.Text = "Payload Type";
            this.PayloadTypeCol.Width = 83;
            // 
            // PayloadCol
            // 
            this.PayloadCol.Text = "Payload";
            this.PayloadCol.Width = 361;
            // 
            // ControllerForm
            // 
            this.ClientSize = new System.Drawing.Size(292, 266);
            this.Name = "ControllerForm";
            this.panel1.ResumeLayout(false);
            this.panel1.PerformLayout();
            this.groupBox1.ResumeLayout(false);
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.Panel panel1;
        private System.Windows.Forms.GroupBox groupBox1;
        private System.Windows.Forms.ListView listView1;
        private System.Windows.Forms.ColumnHeader TimestampCol;
        private System.Windows.Forms.ColumnHeader MessageCol;
        private System.Windows.Forms.ColumnHeader SrcAddressCol;
        private System.Windows.Forms.ColumnHeader DstAddressCol;
        private System.Windows.Forms.ColumnHeader PayloadTypeCol;
        private System.Windows.Forms.ColumnHeader PayloadCol;
        private System.Windows.Forms.TextBox textBox1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XLASys\Controller\TestBase.cs ===
using System;
using System.Net;
//using ServerTestFramework.LiveService.UserAccount;
//using ServerTestFramework.Utilities;

namespace XLASys
{
    //                       MinimumTestBase
    //                       /             
    //                TestBase             
    //                /      
    // TestBaseFunction      
    //                       
    //

    public enum TEST_RESULTS 
    {
        NOT_EXECUTED, 
        PASSED, 
        FAILED, 
        IN_PROGRESS,
        COMPOSITE
    };

    /// <summary>
    /// This must be multi-thread safe.
    /// </summary>
    public class MinimumTestBase
    {
        // All of these may potentially be accessed by multiple threads. They should
        // be considered read-only after initializing them.
        public string           Name;
        public string           Desc                = "";
        public TestBaseGroup    Parent;
        public bool             Enabled             = true;
        public bool             CatchExceptions     = true;
        public bool             Ignore              = false;    
        public bool             IsDvt               = false;
        public int              BugId               = 0;
        public uint             AsyncGroup          = 0;
        public bool             IsExcludedFromDailyRun = false; //is this case excluded from the daily functional run
        public System.Type      ExpectedException   = null;

        // This will be used if TestResult = PASSED | FAILED for stress tests. It has to go
        // here because StressTestBase and MinimumStressTestBase need it.
        // You may set it once per derived class type. Then consider it read-only.
        public int CasesExecuted = 1;

        public string FullName
        {
            get
            {
                if (Parent == null)
                    return Name;
                return Parent.Name+"."+Name;
            }
        }
        
        public MinimumTestBase()
        {
            Name = GetType().Name;
        }

        public MinimumTestBase(string name)
        {
            Name = name;
        }

        abstract public TEST_RESULTS Run();    

    }

    public class TestBaseFunction : TestBase
    {
        public delegate void TestCaseDelegate();

        public static void NoOp()
        {
        }

        public TestBaseFunction(TestCaseDelegate testCase, string name)
        {
            m_testCase = testCase;
            Name = name;
        }
                                                         
        protected override void Execute()
        {
            m_testCase();

            ResultCode = TEST_RESULTS.PASSED;
        }

        protected TestCaseDelegate m_testCase;
    }

    
    /// <summary>
    /// This is not multi-thread safe.
    /// </summary>
    abstract public class    TestBase : MinimumTestBase
    {
        public UacsCommon       UACS;
        public long             Started;
        public TEST_RESULTS     ResultCode          = TEST_RESULTS.NOT_EXECUTED;
        public float            TotalExecutionTime  = 0;


        public TestBase()
        {
            Name = GetType().Name;
            UACS=new UacsCommon(this);
        }
        public TestBase(string name)
        {
            Name = name;
            UACS=new UacsCommon(this);
        }

        abstract protected void Execute();    
        
        public float Elapsed
        {
            get
            {
                long ElapsedTicks=DateTime.Now.Ticks-Started;
                return ElapsedTicks*0.0000001f;
            }
        }

        public override void Run()
        {
            Started = DateTime.Now.Ticks;
            ResultCode = TEST_RESULTS.FAILED;

            try
            {
                Execute();
            }
            finally 
            {
                TotalExecutionTime = Elapsed;
            }

            return ResultCode;
        }

        static protected void Check(bool f)
        {
            if (!f)
                throw new UnexpectedTestResultException();
        }

        static protected void Check(bool f, string msg)
        {
            if (!f)
                throw new UnexpectedTestResultException(msg);
        }

        public void Info(string Msg)
        {
            ConsoleX.ClearLine();
            ConsoleX.WriteLine("Info :"+ Msg);
        }

        static public  void LogWarning(string Msg)
        {
            ConsoleX.WriteLine("Warn :"+ Msg);
            
        }
    }

    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XLASys\Controller\TestCaseManager.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Reflection;
using System.Security;
using System.Security.Policy;
using System.Security.Permissions;


namespace XLASys
{
    class TestCaseManager
    {
        public bool ExtractTestCases(string asmPath, int assemblyID)
        {
            TestSuite testSuiteFromAsm = new TestSuite();
            if (File.Exists(asmPath))
            {
                string dllName = Path.GetFileName(asmPath);
                XLASysAppDomain xlaSysAD = new XLASysAppDomain();

                xlaSysAD.CreateAD(assemblyID, asmPath);

            }
            return true;
        }

    }
   


    class XLASysAppDomain
    {

        public void CreateAD(int asmID, string asmPath)
        {
            //Create evidence for the new appdomain.
            Evidence adevidence = AppDomain.CurrentDomain.Evidence;

            AppDomainSetup domaininfo = new AppDomainSetup();
            domaininfo.ApplicationName = "XLASysTCM";
            domaininfo.PrivateBinPath = "temp";
            domaininfo.DisallowApplicationBaseProbing = false;
            PolicyLevel polLevel = PolicyLevel.CreateAppDomainLevel();

            PermissionSet permSet = new PermissionSet(PermissionState.Unrestricted);
            // Add permission to execute code to the permission set.
            permSet.AddPermission(new SecurityPermission(SecurityPermissionFlag.Execution));
            // Give the policy level's root code group a new policy statement based
            // on the new permission set.
            polLevel.RootCodeGroup.PolicyStatement = new PolicyStatement(permSet);

            // Create the new application domain.
            AppDomain xlad1 = AppDomain.CreateDomain("XLASysDomain", adevidence, domaininfo);
            xlad1.SetAppDomainPolicy(polLevel);

            xlad1.SetData("AsmID", asmID);
            xlad1.SetData("AsmName", Path.GetFileName(asmPath));
            xlad1.DoCallBack(new CrossAppDomainDelegate(AppDomainCallBack));
            
            AppDomain.Unload(xlad1);
        }


        static public void AppDomainCallBack()
        {
            Assembly asm;
            XLASysAppDomain thisAD = new XLASysAppDomain();

            List<TestCaseInfo> testListArray;

            string asmNameAD = (string)AppDomain.CurrentDomain.GetData("AsmName");

            int lastIndx = asmNameAD.LastIndexOf('.');
            string asmName = asmNameAD.Remove(lastIndx);

            string fullname = Assembly.Load(asmName).FullName;
            asm = Assembly.Load(fullname);

            int asmID = (int)AppDomain.CurrentDomain.GetData("AsmID");

            testListArray = TestSuite.GetTestcasesFromAssembly(asm, asmID);
            if (testListArray != null)
            {
                for (int i = 0; i < testListArray.Count; ++i)
                {
                    thisAD.WritetoDB(testListArray[i]);
                }
            }  
        }
        
        void WritetoDB(TestCaseInfo testCase)
        {
            string GPName = testCase.GroupName;
            string TCName = testCase.TestCaseName;

            XBLDistAutoDB disAutoDB = new XBLDistAutoDB();
            disAutoDB.CreateTestCases(TCName, GPName, 1, "testDLL", 6, 0);

        }
    }
  }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XLASys\Controller\TestBaseGroup.cs ===
using System;
using System.Collections;
using System.Reflection;
//using ServerTestFramework.Utilities;

namespace XLASys
{
    public abstract class TestBaseGroup : CollectionBase, IEnumerable
    {
        protected string name;
        protected bool _isXenonClient = false;
        protected uint asyncThreadCount=8; //max number of threads that can run within this group
        protected uint asyncThreadDelay=25; //delay between thread creations in this group
        protected uint defaultAsyncGroup=0; //default asyncGroup value for tests within this group
        protected uint asyncSet=0; //which asyncSet this group belongs to (for running different groups in parallel)
        protected bool isExcludedFromDailyRun=false; //is this group excluded from the daily functional run

        public int RunGroupIndex=-1; //index of the group used when running the test
        public Exception SetupException=null;

        public delegate void TestGroupSetupDelegate();
        public ArrayList TestGroupSetupMethods = new ArrayList();
        
        public delegate void TestGroupTearDownDelegate();
        public ArrayList TestGroupTearDownMethods = new ArrayList();

        // The name of this test group
        public string Name 
        {
            get {return name;}
            set {name = value;}
        }

        public uint AsyncThreadCount
        {
            get {return asyncThreadCount;} 
            set {asyncThreadCount=value;}
        }

        public uint AsyncThreadDelay
        {
            get {return asyncThreadDelay;} 
            set {asyncThreadDelay=value;}
        }

        public uint DefaultAsyncGroup
        {
            get {return defaultAsyncGroup;} 
            set {defaultAsyncGroup=value;}
        }

        public uint AsyncSet
        {
            get {return asyncSet;} 
            set {asyncSet=value;}
        }

        public bool IsExcludedFromDailyRun
        {
            get {return isExcludedFromDailyRun;}
            set {isExcludedFromDailyRun=value;}
        }

        public bool Ignore = false;
        public bool IsDvt = false;


        /// <summary>
        /// Flag to indicate if this is a Xenon client or not. It us up to each test to implement
        /// any functionality around this; it is here only for information. A recommended way to use
        /// this is to add a Setup function to your test base group, using our [TestGroupSetup] 
        /// attribute, then do something in this function with the Xenon flag. This Setup function
        /// will be executed before any other tests in the group. Here is a sample:
        /// 
        ///     public class XkdcTestBaseGroup : TestBaseGroup
        ///     {
        ///         [TestGroupSetup]
        ///         public void Setup()
        ///         {
        ///             XmacsTestBase.kcl.IsXenonClient = IsXenonClient;
        ///         }
        ///         
        ///         [TestGroupTearDown]
        ///         public void TearDown()
        ///         {
        ///             XmacsTestBase.kcl.IsXenonClient = false;
        ///         }
        ///     }
        ///     
        /// </summary>
        public bool IsXenonClient
        {
            get { return _isXenonClient; }
            set { _isXenonClient = value; }
        }

        /// <summary>
        /// Construct a new TestBaseGroup using the type's name and an Xbox client
        /// </summary>
        public TestBaseGroup() : this(null, false)
        {
        }

        /// <summary>
        /// Construct a new TestBaseGroup with a custom name and an Xbox client
        /// </summary>
        /// <param name="groupName"></param>
        public TestBaseGroup(string groupName) : this(groupName, false)
        {
        }

        /// <summary>
        /// Construct a new TestBaseGroup with the type's name an the possibility of Xenon client
        /// </summary>
        /// <param name="isXenonClient"></param>
        public TestBaseGroup(bool isXenonClient) : this(null, isXenonClient)
        {
        }
        
        /// <summary>
        /// Construct a new TestBaseGroup with a custom name and the possiblity of Xenon client
        /// </summary>
        /// <param name="groupName"></param>
        /// <param name="isXenonClient"></param>
        public TestBaseGroup(string groupName, bool isXenonClient)
        {
            try
            {
                if (groupName == null)
                {
                    groupName = GetType().Name;
                }
                Name = groupName;
                IsXenonClient = isXenonClient;

                {
                    //check for [Dvt] and [Ignore] attributes (on group)
                    IsDvt = null != (DVTAttribute)Attribute.GetCustomAttribute(GetType(), typeof(DVTAttribute));
                    Ignore = null != (IgnoreAttribute)Attribute.GetCustomAttribute(GetType(), typeof(IgnoreAttribute));

                    //check for [AsyncThreadCount] (on group class)
                    AsyncThreadCountAttribute tcA=(AsyncThreadCountAttribute)Attribute.GetCustomAttribute(GetType(), typeof(AsyncThreadCountAttribute));
                    if (tcA!=null)
                    {
                        uint atc=tcA.ThreadCount;
                        if (atc<1)
                        {
                            //Global.RO.Warn("A group's AsyncThreadCount cannot be less than 1. (class name: "+GetType().Name+")");
                            atc=1;
                        }
                        AsyncThreadCount=atc;
                    }

                    //check for [AsyncThreadDelay] (on group class)
                    AsyncThreadDelayAttribute tdA=(AsyncThreadDelayAttribute)Attribute.GetCustomAttribute(GetType(), typeof(AsyncThreadDelayAttribute));
                    if (tdA!=null)
                    {
                        AsyncThreadDelay=tdA.ThreadDelay;
                    }

                    //check for [AsyncGroup] (on group class)
                    AsyncGroupAttribute asyncGroupA=(AsyncGroupAttribute)Attribute.GetCustomAttribute(GetType(), typeof(AsyncGroupAttribute));
                    if (asyncGroupA!=null)
                    {
                        DefaultAsyncGroup=asyncGroupA.AsyncGroup;
                        AsyncSet=asyncGroupA.AsyncSet;
                    }

                    //check for [DoNotRunDaily] (on group class)
                    IsExcludedFromDailyRun = null != (DoNotRunDailyAttribute)Attribute.GetCustomAttribute(GetType(), typeof(DoNotRunDailyAttribute));
                }

                // look for inner classes declared within the TestBaseGroup, turning them into test cases as appropriate
                foreach (Type inner in GetType().GetNestedTypes(BindingFlags.NonPublic | BindingFlags.Public))
                {
                    TestCaseAttribute testCaseAttr = (TestCaseAttribute)Attribute.GetCustomAttribute(inner, typeof(TestCaseAttribute));

                    if (testCaseAttr != null)
                    {
                        ConstructorInfo testDefaultConstructor = inner.GetConstructor(Type.EmptyTypes);
                        if (testDefaultConstructor == null)
                        {
                            //Global.RO.Warn("Test case does not have a default constructor, so it will be ignored: " + inner.FullName);
                            continue;
                        }

                        TestBase instance = testDefaultConstructor.Invoke(null) as TestBase;
                        if (instance==null)
                        {
                            Global.RO.Warn("Test case is not derived from TestBase, so it will be ignored: "+inner.FullName);
                            continue;
                        }

                        instance.BugId = testCaseAttr.BugID;

                        //[Description] (on test case)
                        DescriptionAttribute da = (DescriptionAttribute)Attribute.GetCustomAttribute(inner, typeof(DescriptionAttribute));
                        instance.Desc = da == null ? null : da.Desc;

                        //[Ignore] (on test case)
                        IgnoreAttribute ia = (IgnoreAttribute)Attribute.GetCustomAttribute(inner, typeof(IgnoreAttribute));
                        instance.Ignore = (ia != null);
                        
                        //[Dvt] (on test case)
                        DVTAttribute dvt = (DVTAttribute)Attribute.GetCustomAttribute(inner, typeof(DVTAttribute));
                        instance.IsDvt = IsDvt || (dvt != null);

                        //[AsyncGroup] (on test case)
                        AsyncGroupAttribute asyncGroupA=(AsyncGroupAttribute)Attribute.GetCustomAttribute(inner, typeof(AsyncGroupAttribute));
                        if (asyncGroupA!=null)
                        {
                            instance.AsyncGroup=asyncGroupA.AsyncGroup;
                        }
                        else //default to group value
                        {
                            instance.AsyncGroup=DefaultAsyncGroup;
                        }

                        //[DoNotRunDaily] (on test case)
                        instance.IsExcludedFromDailyRun = null!=(DoNotRunDailyAttribute)Attribute.GetCustomAttribute(inner, typeof(DoNotRunDailyAttribute));
                        instance.IsExcludedFromDailyRun = instance.IsExcludedFromDailyRun || IsExcludedFromDailyRun; //inherit from group

                        //
                        instance.CatchExceptions = testCaseAttr.CatchExceptions;
                        instance.ExpectedException = testCaseAttr.ExpectedException;

                        Add(instance,instance.AsyncGroup);
                    }
                }

                // look for public functions within the TestBaseGroup, 
                Type testCaseDelegateType = Type.GetType("ServerTestFramework.TestBaseFunction+TestCaseDelegate");
                Type testGroupSetupDelegateType = typeof(TestGroupSetupDelegate);
                Type testGroupTearDownDelegateType = typeof(TestGroupTearDownDelegate);

                foreach (MethodInfo methodInfo in GetType().GetMethods())
                {
                    Attribute attr;

                    // check for [TestCase]
                    attr = Attribute.GetCustomAttribute(methodInfo, typeof(TestCaseAttribute));
                    if (attr != null)
                    {
                        TestBaseFunction.TestCaseDelegate testCaseDelegate = 
                            (TestBaseFunction.TestCaseDelegate) Delegate.CreateDelegate(testCaseDelegateType, this, methodInfo.Name);

                        TestBase instance = new TestBaseFunction(testCaseDelegate, methodInfo.Name);

                        instance.BugId = ((TestCaseAttribute)attr).BugID;

                        //[Description] (on test case)
                        DescriptionAttribute da = (DescriptionAttribute)Attribute.GetCustomAttribute(methodInfo, typeof(DescriptionAttribute));
                        instance.Desc = da == null ? null : da.Desc;

                        //[Ignore] (on test case)
                        IgnoreAttribute ia = (IgnoreAttribute)Attribute.GetCustomAttribute(methodInfo, typeof(IgnoreAttribute));
                        instance.Ignore = (ia != null);

                        //[Dvt] (on test case)
                        DVTAttribute dvt = (DVTAttribute)Attribute.GetCustomAttribute(methodInfo, typeof(DVTAttribute));
                        instance.IsDvt = IsDvt || (dvt != null);

                        //[AsyncGroup] (on test case)
                        AsyncGroupAttribute asyncGroupA=(AsyncGroupAttribute)Attribute.GetCustomAttribute(methodInfo, typeof(AsyncGroupAttribute));
                        if (asyncGroupA!=null)
                        {
                            instance.AsyncGroup=asyncGroupA.AsyncGroup;
                        }
                        else //default to group value
                        {
                            instance.AsyncGroup=DefaultAsyncGroup;
                        }

                        //[DoNotRunDaily] (on test case)
                        instance.IsExcludedFromDailyRun = null!=(DoNotRunDailyAttribute)Attribute.GetCustomAttribute(methodInfo, typeof(DoNotRunDailyAttribute));
                        instance.IsExcludedFromDailyRun = instance.IsExcludedFromDailyRun || IsExcludedFromDailyRun; //inherit from group

                        //
                        instance.CatchExceptions = ((TestCaseAttribute)attr).CatchExceptions;
                        instance.ExpectedException = ((TestCaseAttribute)attr).ExpectedException;

                        Add(instance,instance.AsyncGroup);
                    }

                    // check for [TestGroupSetup]
                    attr = Attribute.GetCustomAttribute(methodInfo, typeof(TestGroupSetupAttribute));
                    if (attr != null)
                    {
                        TestGroupSetupMethods.Add(Delegate.CreateDelegate(testGroupSetupDelegateType, this, methodInfo.Name));
                    }

                    // check for [TestGroupTearDown]
                    attr = Attribute.GetCustomAttribute(methodInfo, typeof(TestGroupTearDownAttribute));
                    if (attr != null)
                    {
                        TestGroupTearDownMethods.Add(Delegate.CreateDelegate(testGroupTearDownDelegateType, this, methodInfo.Name));
                    }                
                }
            }
            catch(Exception e)
            {
                //Global.RO.Error("An exception was thrown attempting to create TestBaseGroup!");
                //Global.RO.Error(e.ToString());
                throw;
            }
            
        }

        public virtual void Initialize()
        {
            foreach (TestGroupSetupDelegate SetupDelegate in TestGroupSetupMethods)
            {
                Global.RO.Debug("   Setup ({0}.{1})", Name, SetupDelegate.Method.Name);
                try
                {
                    SetupDelegate();
                }
                catch(Exception ex)
                {
                    Global.RO.Error("   Setup ({0}.{1}) Failed: {2}", Name, SetupDelegate.Method.Name, ex.ToString());
                    SetupException = ex;
                }
            }

        }

        public virtual void Cleanup()
        {
            foreach (TestGroupTearDownDelegate TearDownDelegate in TestGroupTearDownMethods)
            {
                Global.RO.Debug("   TearDown ({0}.{1})", Name, TearDownDelegate.Method.Name);
                try
                {
                    TearDownDelegate();
                }
                catch(Exception ex)
                {
                    Global.RO.Error("   TearDown ({0}.{1}) Failed: {2}", Name, TearDownDelegate.Method.Name, ex.ToString());
                }
            }

        }

        /// <summary>
        /// Adds a test to the group.  The group's default AsyncGroup value will be used.
        /// </summary>
        virtual public void Add(TestBase t)
        {
            t.Parent = this;
            t.AsyncGroup = DefaultAsyncGroup;
            List.Add(t);
        }
        /// <summary>
        /// Adds a test to the group, with a specific AsyncGroup value.
        /// </summary>
        virtual public void Add(TestBase t, uint asyncGroup)
        {
            t.Parent = this;
            t.AsyncGroup = asyncGroup;
            List.Add(t);
        }

        public TestBase this[int index]
        {
            get
            {
                return (TestBase)List[index];
            }
            set
            {
                List[index] = value;
            }
        }

        public bool AnyEnabledTests()
        {
            foreach (TestBase test in List)
            {
                if (test.Enabled)
                {
                    return true;
                }
            }
            return false;
        }

        // Copies special attributes (async settings, etc) from another group to this one
        public void CopyAttributesFrom(TestBaseGroup other)
        {
            //copy group settings
            asyncThreadCount = other.asyncThreadCount;
            asyncThreadDelay = other.asyncThreadDelay;
            defaultAsyncGroup = other.defaultAsyncGroup;
            asyncSet = other.asyncSet;

            //copy test settings
            foreach (TestBase me in this)
            {
                foreach (TestBase you in other)
                {
                    if (me.Name == you.Name)
                    {
                        me.AsyncGroup = you.AsyncGroup;
                        
                        break;
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XLASys\Controller\XLASysController.cs ===
using System;
using System.Collections.Generic;
using System.Windows.Forms;

using livetest.core;

namespace XLASys
{
    static class XLASysController
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new ControllerForm());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XLASys\Controller\FileManager.cs ===
/*
 * This class is responsible for monitoring the folders and updating the database with tests and the proper versions of the files.
 * Files to be watch include DLL (Test files and Framework), XML (config files), MSI (the XBLTools setup) and any supporting files 
 * for the tests themselves.
 *
 */

using System;
using System.Collections.Generic;
using System.Text;
using System.IO;

namespace XLASys
{
    public delegate void Notify(object sender, FileManagerEventArgs e);
    public enum FileTypeCode { DLL_TYPE=1, PDB_TYPE, XML_TYPE, MSI_TYPE, TXT_TYPE, EXE_TYPE };

    class FileManager
    {
        private System.IO.FileSystemWatcher _watcher;
        public event Notify Update;
        private Queue<FileQueueItem> _fileQueue;
        private TestCaseManager tstCaseMgr = new TestCaseManager();
        public string localDest =  @"C:\src\xonline\private\test\StfTests\XLASys\Controller\bin\Debug\temp\\";

        public FileManager(string path)
        {
            _fileQueue = new Queue<FileQueueItem>();
            _watcher = new FileSystemWatcher(path);
            _watcher.IncludeSubdirectories = true;
            _watcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName;
            // Monitor events... Renamed has a different sig so if we decide to watch that, need a new handler...
            // Created Files also throw changed events, so not going to throw a separate event for that right now.
            //_watcher.Created += new FileSystemEventHandler(WatchHandler);
            _watcher.Changed += new FileSystemEventHandler(WatchHandler);
            _watcher.Deleted += new FileSystemEventHandler(WatchHandler);
            _watcher.EnableRaisingEvents = true;
        }

        /// <summary>
        /// Called when a new file or folder is created.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void WatchHandler(object sender, FileSystemEventArgs e)
        {
            FileQueueItem item;
            XBLDistAutoDB dbAccess = new XBLDistAutoDB();
            string fileName;

            item.ChangeType = e.ChangeType;
            item.FullPath = e.FullPath;
            fileName = e.Name;
            int lastIndx = fileName.LastIndexOf('.');
            item.Name = fileName.Remove(lastIndx);

            //Msg("Inside WatchHandler!!!!!!!!!!", String.Format("Fullpath: {0} File: {1}", e.FullPath, e.Name));
            if (!_fileQueue.Contains(item))
            {
                    switch (e.ChangeType)
                    {
                        case WatcherChangeTypes.Changed:
                            if (File.Exists(e.FullPath) && (File.GetAttributes(e.FullPath) & FileAttributes.Directory) != FileAttributes.Directory)
                            {
                                Msg("Changed", String.Format("Fullpath: {0} File: {1}", e.FullPath, e.Name));
                                _fileQueue.Enqueue(item);
                                while (_fileQueue.Count > 0)
                                {
                                   item = _fileQueue.Dequeue();
                                   FileTypeCode fileType = GetFileType(item.FullPath);
                                   switch (fileType)
                                   {
                                       case FileTypeCode.DLL_TYPE: string dest = localDest + fileName;
                                                                   if (File.Exists(dest))
                                                                       File.Delete(dest);
                                                                   File.Copy(item.FullPath, dest);
                                                                   int asmID = dbAccess.FileLog(item.Name, File.GetLastWriteTime(item.FullPath));
                                                                   bool Result = tstCaseMgr.ExtractTestCases(item.FullPath, asmID);
                                                                   break;
                                   }
                                }
                                
                            }
                            break;
                        case WatcherChangeTypes.Created:
                            Msg("Created", String.Format("Fullpath: {0} File: {1}", e.FullPath, e.Name));
                            break;
                        case WatcherChangeTypes.Deleted:
                            Msg("Deleted", String.Format("Fullpath: {0} File: {1}", e.FullPath, e.Name));
                            _fileQueue.Enqueue(item);
                            break;
                    }
            }
        }

        protected virtual void OnUpdate(FileManagerEventArgs e)
        {
            if (this.Update != null)
            {
                this.Update(this, e);
            }
        }
        private void Msg(string changeType, string msg)
        {
            OnUpdate(new FileManagerEventArgs(changeType,msg));
        }

        public FileTypeCode GetFileType(string fullPath)
        {
            switch (System.IO.Path.GetExtension(fullPath)){
                case ".dll": return FileTypeCode.DLL_TYPE;
                case ".pdb": return FileTypeCode.PDB_TYPE;
                case ".txt": return FileTypeCode.TXT_TYPE;
                case ".exe": return FileTypeCode.EXE_TYPE; 
                default    : return 0;     
            }

        }
    }

    public struct FileQueueItem
    {
        public WatcherChangeTypes ChangeType;
        public string FullPath;
        public string Name;
    }

    public class FileManagerEventArgs : EventArgs
    {
        public string Message;
        public string Action;

        public FileManagerEventArgs(string Msg)
        {
            Message = Msg;
        }
        public FileManagerEventArgs(string ActionType,string Msg)
        {
            Action = ActionType;
            Message = Msg;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XLASys\Controller\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("XLDASController")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MSIT")]
[assembly: AssemblyProduct("XLDASController")]
[assembly: AssemblyCopyright("Copyright  MSIT 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("ea18c655-7311-4764-bdc6-52355f812f07")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XLASys\Controller\TestSuite.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Reflection;


namespace XLASys
{
    public enum TEST_RESULTS
    {
        NOT_EXECUTED,
        PASSED,
        FAILED,
        IN_PROGRESS,
        COMPOSITE
    };
    public enum testType : uint { DVT, FUNCTIONAL, STRESS };

    class TestSuite
    {
        protected Assembly _assembly;

        public TestSuite()
        {
            _assembly = GetType().Assembly;
        }

        public TestSuite(Assembly asm)
        {
            _assembly = asm;
        }
        
        public Assembly HostAssembly
        {
            get { return (_assembly == null ? GetType().Assembly : _assembly); }
            set { _assembly = value; }
        }


        public string Name
        {
            get { return HostAssembly.GetName().Name; }
        }

        //Gets TestCase information from the assembly
        //path - Full path followed by assembly
        //static public List<TestCaseInfo> GetTestsFromAssemblyPath(string path)
        static public List<TestCaseInfo> GetTestcasesFromAssembly(Assembly asm, int asmID)
        {
            /*           Assembly asm = null;
                    try
                    {
                        asm = Assembly.LoadFile(path);
                    }
                    catch (BadImageFormatException)
                    {
                        return null;
                    }*/
            List<TestCaseInfo> TClist = new List<TestCaseInfo>();
            Type[] eTypes = asm.GetExportedTypes();
            string asmName = asm.FullName;
            
            // Search for types marked with [TestGroup]
            foreach (Type t in eTypes)
            { 
                if (!t.IsClass)
                    continue;
                object[] testgroupAttrs = t.GetCustomAttributes(typeof(ServerTestFramework.TestGroupAttribute), true);
                if ( (testgroupAttrs != null) && (testgroupAttrs.Length > 0) )
                {
                    foreach (Type inner in t.GetNestedTypes(BindingFlags.Public))
                    {
                        // Search for types marked with [TestCase]
                        object[] testCaseAttrs = inner.GetCustomAttributes(typeof(ServerTestFramework.TestCaseAttribute), true);
                        if ( (testgroupAttrs != null) && (testCaseAttrs.Length != 0) )
                        {
                            TestCaseInfo tCaseInfo = new TestCaseInfo();
                            if (tCaseInfo == null) { return null; }
                            tCaseInfo.GroupName = t.Name;
                            tCaseInfo.TestCaseName = inner.Name;
                            tCaseInfo._active = true;
                            tCaseInfo.AssemblyID = asmID;
                            TClist.Add(tCaseInfo);
                        }
                    }
                 }
             }
             return TClist;
           }


      /*  public TestCaseInfo GetTestcasesFromSuite(TestSuite tstSuite)
        {
            ArrayList testArray = new ArrayList();
            TestCaseInfo tCaseInfo = new TestCaseInfo();

            // Search for types marked with [TestCase]
            foreach (Type inner in GetType().GetNestedTypes(BindingFlags.NonPublic | BindingFlags.Public))
            {
                TestCaseAttribute testCaseAttr = (TestCaseAttribute)Attribute.GetCustomAttribute(inner, typeof(TestCaseAttribute));
                if (testCaseAttr != null)
                {
                    tCaseInfo.TestCaseID = 1;
                    //tCaseInfo.FullName = new TestSuite();
                    break;
                }

            }
            return tCaseInfo;

        }*/
    }

    class TestCaseInfo
    {
        public static uint _testID = 0;
        public string TestCaseName;
        public string GroupName;
        public int _asmID;
        public string _testDesc = "";
        public bool _active;
        public bool _IsDvt;
        public DateTime _dateModified;
        public string _asmVer;
        public TimeSpan _avgDuration;
        public uint _testType;
    
       /* public string TestCaseName
        {
            get
            {
                return TestCaseName;
            }
            set
            {
                if (value != null) { TestCaseName = _testName; }
            }
        }

        public string GroupName
        {
            get
            {
                return GroupName;
            }
            set
            {
                if (value != null) { GroupName = _groupName; }
            }

        }*/

        public int AssemblyID
        {
            get
            {
                return AssemblyID;
            }
            set
            {
                if (value > 0) { AssemblyID = _asmID; }
            }

        }

        public uint TestCaseID
        {
            get
            {
                return TestCaseID;
            }
            set
            {
                if (value > 0) { TestCaseID = _testID; }
            }

        }

        public DateTime DateModified
        {
            get
            {
                return DateModified;
            }
            set
            {
                DateModified = _dateModified;
            }

        }

    }




}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XLASys\ResultAgg\ResultUI\Program.cs ===
using System;
using System.Collections.Generic;
using System.Windows.Forms;

namespace XLASys
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new ResultAggUI());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XLASys\Controller\Properties\Settings.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace XLASys.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "8.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XLASys\Controller\Properties\Resources.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace XLASys.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("XLASys.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XLASys\ResultAgg\ResultUI\ResultAggUI.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;

namespace XLASys
{
    public partial class ResultAggUI : Form
    {
        protected ResultAgg _resultAgg;
        protected XBLDistAutoDB _database;
        protected int _testPassId;

        public ResultAggUI()
        {
            InitializeComponent();
            _resultAgg = new ResultAgg(serverName.Text, databaseName.Text);
            _database = new XBLDistAutoDB(serverName.Text, databaseName.Text);
            _testPassId = 1;
        }

        private void resultAggCreate_Click(object sender, EventArgs e)
        {
            _resultAgg = new ResultAgg(serverName.Text, databaseName.Text);
            _database = new XBLDistAutoDB(serverName.Text, databaseName.Text);
        }

        private void sendResultsButton_Click(object sender, EventArgs e)
        {
            try
            {
                _resultAgg.SendResults(_testPassId);
                MessageBox.Show("Mail Sent");
            }
            catch (Exception excep)
            {
                MessageBox.Show("Mail Failed:\n" + excep.ToString());
            }
        }

        private void testPassId_TextChanged(object sender, EventArgs e)
        {
            Int32Converter intConverter = new Int32Converter();
            int oldValue = _testPassId;
            try
            {
                int tempTestPassId = (int)intConverter.ConvertFromString(tsTestPassId.Text);
                _testPassId = tempTestPassId;
            }
            catch (System.Exception)
            {
                _testPassId = oldValue;
                tsTestPassId.Text = oldValue.ToString();
            }
        }

        private void tpCreateButton_Click(object sender, EventArgs e)
        {
            int tempTestPassId = 0;
            try
            {
                DateTime runStart = DateTime.Parse(tsRunStartBox.Text);
                string username = tsUserNameBox.Text;
                string assemblyVer = tsAssemblyVerBox.Text;
                DateTime assemblyMod = DateTime.Parse(tsAssemblyModBox.Text);

                tempTestPassId = _resultAgg.CreateTestPass(username, runStart, assemblyVer, assemblyMod);

                tsTestPassId.Text = tempTestPassId.ToString();
                trPassIdBox.Text = tempTestPassId.ToString();
                tsTestPassId.Text = tempTestPassId.ToString();
                MessageBox.Show("New Test Pass Created: " + tempTestPassId.ToString());
            }
            catch (Exception excep)
            {
                MessageBox.Show(excep.ToString());
            }
        }

        private void trCreateButton_Click(object sender, EventArgs e)
        {
            int tempTestResultId = 0;
            try
            {
                int tempTestCaseId = Int32.Parse(trCaseIdBox.Text);
                int tempTestPassId = Int32.Parse(trPassIdBox.Text);
                string tempTestClient = trTestClientBox.Text;
                string tempLog = trLogBox.Text;
                int tempTestRunTime = Int32.Parse(trRunTimeBox.Text);
                int tempTestResultValueId = trCasePassedCheckBox.Checked ? 1 : 0;

                tempTestResultId = _resultAgg.LogResult(
                            tempTestCaseId, tempTestPassId,
                            tempTestClient, tempTestRunTime,
                            tempTestResultValueId, tempLog);

                trResultIdBox.Text = tempTestResultId.ToString();
                MessageBox.Show("New Test Result Created: " + tempTestResultId.ToString());
            }
            catch (Exception excep)
            {
                MessageBox.Show(excep.ToString());
            }
        }

        private void setTestPassStateButton_Click(object sender, EventArgs e)
        {
            int tempTestPassId = Int32.Parse(tsTestPassId.Text);
            int tempTestPassStateId = tsStateComboBox.SelectedIndex;
            string tempTestPassState;

            try
            {
                tempTestPassState = _resultAgg.SetTestPassState(tempTestPassId, tempTestPassStateId);
                tsStateComboBox.SelectedItem = tempTestPassState;
            }
            catch (Exception excep)
            {
                MessageBox.Show(excep.ToString());
            }
        }

        private void getTestPassStateButton_Click(object sender, EventArgs e)
        {
            int tempTestPassId = Int32.Parse(tsTestPassId.Text);
            TestPassView testPassView;

            try
            {
                testPassView = _database.TestPassesGetTestPass(tempTestPassId);

                tsUserNameBox.Text = testPassView.Username;
                tsRunStartBox.Text = testPassView.TestrunStart.ToString();
                tsAssemblyVerBox.Text = testPassView.TargetAssemblyVersion;
                tsTestPassId.Text = testPassView.TestPassId.ToString();
                tsStateComboBox.SelectedIndex = testPassView.TestPassStateId;
            }
            catch (Exception excep)
            {
                MessageBox.Show(excep.ToString());
            }
        }

        private void trGetResultButton_Click(object sender, EventArgs e)
        {
            int tempTestResultId = 0;
            TestCaseResultView testResultView;

            try
            {
                tempTestResultId = Int32.Parse(trResultIdBox.Text);

                testResultView = _database.TestResultGetTestPassResult(tempTestResultId);

                trCaseIdBox.Text = testResultView.TestCaseId.ToString();
                trPassIdBox.Text = testResultView.TestPassId.ToString();
                trTestClientBox.Text = testResultView.TestClient;
                trLogBox.Text = testResultView.Log;
                trRunTimeBox.Text = testResultView.RunTime.ToString();
                trCasePassedCheckBox.Checked = (testResultView.TestResultValueId == 1);
            }
            catch (Exception excep)
            {
                MessageBox.Show(excep.ToString());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XLASys\Sql\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

SQLTARGET:
    -md %_NT386TREE%\xdb\XBLDistAutodb
    for /f %i in ('dir /b *.sql') do type %i | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/" > %_NT386TREE%\xdb\XBLDistAutodb\%i
    for /f %i in ('dir /b *.xml') do type %i | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/" > %_NT386TREE%\xdb\XBLDistAutodb\%i
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XLASys\ResultAgg\ResultAgg.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Net.Mail;
using System.Globalization;

namespace XLASys
{
    /// <summary>
    /// Interface API Class for the Xbox Live Distributed Automation System
    /// </summary>
    public class ResultAgg
    {
        protected XBLDistAutoDB _xblDB;

        protected const string DefaultSmtpServer = "smtphost.redmond.corp.microsoft.com";
        protected const string DefaultEmailSubject = "Test Pass Results from ";
        protected const string DefaultEmailSender = "trevorm@microsoft.com";
        protected const string DefaultEmailRecipient = "@microsoft.com";

        /// <summary>
        /// Constructor with default server name and database name
        /// </summary>
        public ResultAgg()
        {
            _xblDB = new XBLDistAutoDB();
        }

        public ResultAgg(string serverName, string databaseName)
        {
            _xblDB = new XBLDistAutoDB(serverName, databaseName);
        }

        /// <summary>
        /// Creates a test pass record in test passes table, Defaults to state Not Run
        /// </summary>
        /// <param name="emailName">email alias that created this test pass</param>
        /// <param name="testRunStart">Start time for the test pass</param>
        /// <param name="assemblyVersion">Version of the target assembly</param>
        /// <param name="assemblyModified">Modified date of the target assembly (used to distinguish privates)</param>
        /// <returns>unique ID of the test pass i_test_pass_id</returns>
        public int CreateTestPass(string emailName, DateTime testRunStart, string assemblyVersion, DateTime assemblyModified)
        {
            return _xblDB.TestPassCreateTestPass(testRunStart, emailName, assemblyVersion, assemblyModified);
        }

        public string SetTestPassState(int testPassId, int testPassStateId)
        {
            return _xblDB.TestPassSetTestPassState(testPassId, testPassStateId);
        }

        /// <summary>
        /// Creates a test result record in test results table
        /// </summary>
        /// <param name="testCaseId">Test Case ID from the t_test_cases table</param>
        /// <param name="testPassId">Test Pass ID from the t_test_passes table</param>
        /// <param name="testClientName">Test client this was run on</param>
        /// <param name="runTime">execution time in ms</param>
        /// <param name="testResult">Test Result ID from the t_test_result_values table</param>
        /// <param name="testResultLog">Log result of the test case (optional)</param>
        /// <returns>unique ID of the test case i_test_case_result_id</returns>
        public int LogResult(int testCaseId, int testPassId, string testClientName, int runTime, int testResult, string testResultLog)
        {
            return _xblDB.TestResultCreateTestResult(testCaseId, testPassId, testClientName, runTime, testResult, testResultLog);
        }

        /// <summary>
        /// Emails out the test results for the provided test pass
        /// </summary>
        /// <param name="testPassId">unique ID of the test pass i_test_pass_id</param>
        public void SendResults(int testPassId)
        {
            TestCaseResultView[] testResults = _xblDB.TestResultGetTestPassResults(testPassId);

            if (testResults == null)
            {
                // No results returned
                TestPassView testPass = _xblDB.TestPassesGetTestPass(testPassId);

                // If this returns null we have no idea where to send the email
                if (testPass != null)
                {

                    SmtpClient smtpClient = new SmtpClient(DefaultSmtpServer);
                    MailMessage mailMessage = new MailMessage(DefaultEmailSender, testPass.Username + DefaultEmailRecipient);
                    mailMessage.Subject = DefaultEmailSubject + testPass.TestrunStart.ToString("g", DateTimeFormatInfo.InvariantInfo);

                    // Construct the alternate body as HTML.
                    string body = String.Format("http://{0}/results/testpassbyid?id={1}" + Environment.NewLine, _xblDB.ServerName, testPassId);
                    body += "No results for this test pass" + Environment.NewLine;

                    body += "Test Pass Status: " + testPass.TestPassState + Environment.NewLine;

                    mailMessage.Body = body;

                    smtpClient.UseDefaultCredentials = true;
                    smtpClient.Send(mailMessage);
                }
            }
            else
            {
                string htmlResultLink = String.Format("http://{0}/results/testpassbyid?id={1}", _xblDB.ServerName, testPassId);
                SmtpClient smtpClient = new SmtpClient(DefaultSmtpServer);
                MailMessage mailMessage = new MailMessage(DefaultEmailSender, testResults[0].Username + DefaultEmailRecipient);
                mailMessage.Subject = DefaultEmailSubject + testResults[0].TestrunStart.ToString("g", DateTimeFormatInfo.InvariantInfo);
                mailMessage.Body = htmlResultLink;

                // Construct the alternate body as HTML.
                string body = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">";
                body += "<HTML><HEAD><META http-equiv=Content-Type content=\"text/html; charset=iso-8859-1\">";
                body += "</HEAD><BODY><DIV><FONT face=Arial color=#ff0000 size=2>";

                body += String.Format("<A HREF=\"{0}\">{0}</A>", htmlResultLink);
                body += "<BR><H3>Results:</H3>";// +Environment.NewLine;

                body += "<BR><TABLE BORDER=1>";// +Environment.NewLine;

                // Header row
                body += "<TR>";
                body += String.Format("<TD>{0}</TD>", "TestCaseId");
                body += String.Format("<TD>{0}</TD>", "TestCaseName");
                body += String.Format("<TD>{0}</TD>", "TestType");
                body += String.Format("<TD>{0}</TD>", "TestResult");
                body += String.Format("<TD>{0}</TD>", "RunTime");
                body += String.Format("<TD>{0}</TD>", "TargetAssemblyVersion");
                body += String.Format("<TD>{0}</TD>", "TestClient");
                body += "</TR>";// +Environment.NewLine;

                // Add a row for each result
                for (int iRow = 0; iRow < testResults.Length; iRow++)
                {
                    body += "<TR>";
                    body += String.Format("<TD>{0}</TD>", testResults[iRow].TestCaseId);
                    body += String.Format("<TD>{0}</TD>", testResults[iRow].TestCaseName);
                    body += String.Format("<TD>{0}</TD>", testResults[iRow].TestType);
                    body += String.Format("<TD>{0}</TD>", testResults[iRow].TestResult);
                    body += String.Format("<TD>{0}</TD>", testResults[iRow].RunTime);
                    body += String.Format("<TD>{0}</TD>", testResults[iRow].TargetAssemblyVersion);
                    body += String.Format("<TD>{0}</TD>", testResults[iRow].TestClient);
                    body += "</TR>";// +Environment.NewLine;
                }
                body += "</TABLE>";// +Environment.NewLine;
                
                body += "</FONT></DIV></BODY></HTML>";

                // Add the alternate body to the message.
                //AlternateView alternate = new AlternateView(body, System.Net.Mime.MediaTypeNames.Text.Html);
                //mailMessage.AlternateViews.Add(alternate);
                mailMessage.Body = body;
                mailMessage.IsBodyHtml = true;

                smtpClient.UseDefaultCredentials = true;
                smtpClient.Send(mailMessage);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XStatsTCR\TestConsole\TestCall.cs ===
using System;

namespace TestLib
{
	/// <summary>
	/// Summary description for TestCall.
	/// </summary>
	public class TestCall
	{
		public TestCall()
		{
			
		}

		public virtual string ID 
		{
			get
			{
				throw new System.Exception("Not implemented");
			}
		}

		public virtual string Description
		{
			get
			{
				return "";
			}
		}

		public virtual void Invoke()
		{
			throw new System.Exception("Not implemented");
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XStatsTCR\TestConsole\Class1.cs ===
using System;
using XStatsTCR;

namespace TestLib
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class Application
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			TestCall[] operations = 
				{
					new TestCertReset(),
					new TestCertVerify()
				};

			Console.Write("XStatsTCR console test wrapper");
			while (true) 
			{
				string command;
				bool do_continue = false;

				Console.Write("\n:");
				command = Console.ReadLine().ToLower();

				if ("exit" == command)
					break;
				else if (("help" == command) || ("?" == command))
				{
					Console.WriteLine("XStatsTCR console test wrapper");
					Console.WriteLine("commands:");
					Console.WriteLine(" exit -- Terminates the application");
					Console.WriteLine(" help -- Displays this help screen");

					foreach (TestCall tc in operations) 
						Console.WriteLine(" {0} -- {1}", tc.ID, tc.Description);

					continue;
				}

				foreach (TestCall tc in operations) 
				{
					if (tc.ID == command) 
					{
						tc.Invoke();
						do_continue = true;
						break;
					}
				}

				if (true == do_continue) 
				{
					do_continue = false;
					continue;
				}

				Console.Write("Unknown command '{0}'", command);
			}

			Console.WriteLine("bye");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XLASys\ResultAgg\ResultUI\ResultAggUI.Designer.cs ===
using System;

namespace XLASys
{
    partial class ResultAggUI
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.Windows.Forms.Button resultAggCreate;
            this.serverName = new System.Windows.Forms.TextBox();
            this.databaseName = new System.Windows.Forms.TextBox();
            this.serverNameLabel = new System.Windows.Forms.Label();
            this.databaseNameLabel = new System.Windows.Forms.Label();
            this.sendResultsButton = new System.Windows.Forms.Button();
            this.tsTestPassId = new System.Windows.Forms.TextBox();
            this.testPassIdLabel = new System.Windows.Forms.Label();
            this.testPassGroupBox = new System.Windows.Forms.GroupBox();
            this.tpModifiedLabel = new System.Windows.Forms.Label();
            this.tpCreateButton = new System.Windows.Forms.Button();
            this.tsAssemblyModBox = new System.Windows.Forms.TextBox();
            this.groupBox1 = new System.Windows.Forms.GroupBox();
            this.label10 = new System.Windows.Forms.Label();
            this.trResultIdBox = new System.Windows.Forms.TextBox();
            this.trGetResultButton = new System.Windows.Forms.Button();
            this.trCasePassedCheckBox = new System.Windows.Forms.CheckBox();
            this.label5 = new System.Windows.Forms.Label();
            this.trRunTimeBox = new System.Windows.Forms.TextBox();
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.label3 = new System.Windows.Forms.Label();
            this.label4 = new System.Windows.Forms.Label();
            this.trCreateButton = new System.Windows.Forms.Button();
            this.trLogBox = new System.Windows.Forms.TextBox();
            this.trPassIdBox = new System.Windows.Forms.TextBox();
            this.trTestClientBox = new System.Windows.Forms.TextBox();
            this.trCaseIdBox = new System.Windows.Forms.TextBox();
            this.groupBox2 = new System.Windows.Forms.GroupBox();
            this.tsStateComboBox = new System.Windows.Forms.ComboBox();
            this.getTestPassStateButton = new System.Windows.Forms.Button();
            this.setTestPassStateButton = new System.Windows.Forms.Button();
            this.label6 = new System.Windows.Forms.Label();
            this.label7 = new System.Windows.Forms.Label();
            this.label8 = new System.Windows.Forms.Label();
            this.label9 = new System.Windows.Forms.Label();
            this.tsAssemblyVerBox = new System.Windows.Forms.TextBox();
            this.tsRunStartBox = new System.Windows.Forms.TextBox();
            this.tsUserNameBox = new System.Windows.Forms.TextBox();
            resultAggCreate = new System.Windows.Forms.Button();
            this.groupBox1.SuspendLayout();
            this.groupBox2.SuspendLayout();
            this.SuspendLayout();
            // 
            // resultAggCreate
            // 
            resultAggCreate.Location = new System.Drawing.Point(12, 12);
            resultAggCreate.Name = "resultAggCreate";
            resultAggCreate.Size = new System.Drawing.Size(85, 23);
            resultAggCreate.TabIndex = 0;
            resultAggCreate.Text = "Connect";
            resultAggCreate.UseVisualStyleBackColor = true;
            resultAggCreate.Click += new System.EventHandler(this.resultAggCreate_Click);
            // 
            // serverName
            // 
            this.serverName.Location = new System.Drawing.Point(149, 14);
            this.serverName.Name = "serverName";
            this.serverName.Size = new System.Drawing.Size(133, 20);
            this.serverName.TabIndex = 1;
            this.serverName.Text = "trevormxdev";
            // 
            // databaseName
            // 
            this.databaseName.Location = new System.Drawing.Point(348, 15);
            this.databaseName.Name = "databaseName";
            this.databaseName.Size = new System.Drawing.Size(146, 20);
            this.databaseName.TabIndex = 2;
            this.databaseName.Text = "XBLDistAuto";
            // 
            // serverNameLabel
            // 
            this.serverNameLabel.AutoSize = true;
            this.serverNameLabel.Location = new System.Drawing.Point(104, 18);
            this.serverNameLabel.Name = "serverNameLabel";
            this.serverNameLabel.Size = new System.Drawing.Size(41, 13);
            this.serverNameLabel.TabIndex = 3;
            this.serverNameLabel.Text = "Server:";
            // 
            // databaseNameLabel
            // 
            this.databaseNameLabel.AutoSize = true;
            this.databaseNameLabel.Location = new System.Drawing.Point(288, 18);
            this.databaseNameLabel.Name = "databaseNameLabel";
            this.databaseNameLabel.Size = new System.Drawing.Size(56, 13);
            this.databaseNameLabel.TabIndex = 4;
            this.databaseNameLabel.Text = "Database:";
            // 
            // sendResultsButton
            // 
            this.sendResultsButton.Location = new System.Drawing.Point(107, 95);
            this.sendResultsButton.Name = "sendResultsButton";
            this.sendResultsButton.Size = new System.Drawing.Size(85, 23);
            this.sendResultsButton.TabIndex = 5;
            this.sendResultsButton.Text = "Send Results";
            this.sendResultsButton.UseVisualStyleBackColor = true;
            this.sendResultsButton.Click += new System.EventHandler(this.sendResultsButton_Click);
            // 
            // tsTestPassId
            // 
            this.tsTestPassId.Location = new System.Drawing.Point(267, 98);
            this.tsTestPassId.Name = "tsTestPassId";
            this.tsTestPassId.Size = new System.Drawing.Size(51, 20);
            this.tsTestPassId.TabIndex = 6;
            this.tsTestPassId.Text = "1";
            this.tsTestPassId.TextChanged += new System.EventHandler(this.testPassId_TextChanged);
            // 
            // testPassIdLabel
            // 
            this.testPassIdLabel.AutoSize = true;
            this.testPassIdLabel.Location = new System.Drawing.Point(220, 101);
            this.testPassIdLabel.Name = "testPassIdLabel";
            this.testPassIdLabel.Size = new System.Drawing.Size(45, 13);
            this.testPassIdLabel.TabIndex = 7;
            this.testPassIdLabel.Text = "Pass Id:";
            // 
            // testPassGroupBox
            // 
            this.testPassGroupBox.Location = new System.Drawing.Point(12, 51);
            this.testPassGroupBox.Name = "testPassGroupBox";
            this.testPassGroupBox.Size = new System.Drawing.Size(482, 97);
            this.testPassGroupBox.TabIndex = 8;
            this.testPassGroupBox.TabStop = false;
            this.testPassGroupBox.Text = "Create Test Case";
            // 
            // tpModifiedLabel
            // 
            this.tpModifiedLabel.AutoSize = true;
            this.tpModifiedLabel.Location = new System.Drawing.Point(270, 63);
            this.tpModifiedLabel.Name = "tpModifiedLabel";
            this.tpModifiedLabel.Size = new System.Drawing.Size(50, 13);
            this.tpModifiedLabel.TabIndex = 9;
            this.tpModifiedLabel.Text = "Modified:";
            // 
            // tpCreateButton
            // 
            this.tpCreateButton.Location = new System.Drawing.Point(6, 20);
            this.tpCreateButton.Name = "tpCreateButton";
            this.tpCreateButton.Size = new System.Drawing.Size(83, 23);
            this.tpCreateButton.TabIndex = 5;
            this.tpCreateButton.Text = "Create";
            this.tpCreateButton.UseVisualStyleBackColor = true;
            this.tpCreateButton.Click += new System.EventHandler(this.tpCreateButton_Click);
            // 
            // tsAssemblyModBox
            // 
            this.tsAssemblyModBox.Location = new System.Drawing.Point(331, 60);
            this.tsAssemblyModBox.Name = "tsAssemblyModBox";
            this.tsAssemblyModBox.Size = new System.Drawing.Size(138, 20);
            this.tsAssemblyModBox.TabIndex = 3;
            this.tsAssemblyModBox.Text = "4/13/2007 12:00:00 AM";
            // 
            // groupBox1
            // 
            this.groupBox1.Controls.Add(this.label10);
            this.groupBox1.Controls.Add(this.trResultIdBox);
            this.groupBox1.Controls.Add(this.trGetResultButton);
            this.groupBox1.Controls.Add(this.trCasePassedCheckBox);
            this.groupBox1.Controls.Add(this.label5);
            this.groupBox1.Controls.Add(this.trRunTimeBox);
            this.groupBox1.Controls.Add(this.label1);
            this.groupBox1.Controls.Add(this.label2);
            this.groupBox1.Controls.Add(this.label3);
            this.groupBox1.Controls.Add(this.label4);
            this.groupBox1.Controls.Add(this.trCreateButton);
            this.groupBox1.Controls.Add(this.trLogBox);
            this.groupBox1.Controls.Add(this.trPassIdBox);
            this.groupBox1.Controls.Add(this.trTestClientBox);
            this.groupBox1.Controls.Add(this.trCaseIdBox);
            this.groupBox1.Location = new System.Drawing.Point(12, 317);
            this.groupBox1.Name = "groupBox1";
            this.groupBox1.Size = new System.Drawing.Size(482, 134);
            this.groupBox1.TabIndex = 10;
            this.groupBox1.TabStop = false;
            this.groupBox1.Text = "Create Test Result";
            // 
            // label10
            // 
            this.label10.AutoSize = true;
            this.label10.Location = new System.Drawing.Point(17, 100);
            this.label10.Name = "label10";
            this.label10.Size = new System.Drawing.Size(54, 13);
            this.label10.TabIndex = 15;
            this.label10.Text = "Result ID:";
            // 
            // trResultIdBox
            // 
            this.trResultIdBox.Location = new System.Drawing.Point(74, 97);
            this.trResultIdBox.Name = "trResultIdBox";
            this.trResultIdBox.Size = new System.Drawing.Size(100, 20);
            this.trResultIdBox.TabIndex = 14;
            this.trResultIdBox.Text = "1";
            // 
            // trGetResultButton
            // 
            this.trGetResultButton.Location = new System.Drawing.Point(6, 57);
            this.trGetResultButton.Name = "trGetResultButton";
            this.trGetResultButton.Size = new System.Drawing.Size(83, 23);
            this.trGetResultButton.TabIndex = 13;
            this.trGetResultButton.Text = "Get";
            this.trGetResultButton.UseVisualStyleBackColor = true;
            this.trGetResultButton.Click += new System.EventHandler(this.trGetResultButton_Click);
            // 
            // trCasePassedCheckBox
            // 
            this.trCasePassedCheckBox.AutoSize = true;
            this.trCasePassedCheckBox.Location = new System.Drawing.Point(382, 99);
            this.trCasePassedCheckBox.Name = "trCasePassedCheckBox";
            this.trCasePassedCheckBox.Size = new System.Drawing.Size(88, 17);
            this.trCasePassedCheckBox.TabIndex = 12;
            this.trCasePassedCheckBox.Text = "Case Passed";
            this.trCasePassedCheckBox.UseVisualStyleBackColor = true;
            // 
            // label5
            // 
            this.label5.AutoSize = true;
            this.label5.Location = new System.Drawing.Point(189, 100);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(56, 13);
            this.label5.TabIndex = 11;
            this.label5.Text = "Run Time:";
            // 
            // trRunTimeBox
            // 
            this.trRunTimeBox.Location = new System.Drawing.Point(251, 97);
            this.trRunTimeBox.Name = "trRunTimeBox";
            this.trRunTimeBox.Size = new System.Drawing.Size(100, 20);
            this.trRunTimeBox.TabIndex = 10;
            this.trRunTimeBox.Text = "360";
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(277, 62);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(28, 13);
            this.label1.TabIndex = 9;
            this.label1.Text = "Log:";
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(99, 62);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(47, 13);
            this.label2.TabIndex = 8;
            this.label2.Text = "Pass ID:";
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(277, 24);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(60, 13);
            this.label3.TabIndex = 7;
            this.label3.Text = "Test Client:";
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(99, 24);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(48, 13);
            this.label4.TabIndex = 6;
            this.label4.Text = "Case ID:";
            // 
            // trCreateButton
            // 
            this.trCreateButton.Location = new System.Drawing.Point(6, 19);
            this.trCreateButton.Name = "trCreateButton";
            this.trCreateButton.Size = new System.Drawing.Size(83, 23);
            this.trCreateButton.TabIndex = 5;
            this.trCreateButton.Text = "Create";
            this.trCreateButton.UseVisualStyleBackColor = true;
            this.trCreateButton.Click += new System.EventHandler(this.trCreateButton_Click);
            // 
            // trLogBox
            // 
            this.trLogBox.Location = new System.Drawing.Point(338, 59);
            this.trLogBox.Name = "trLogBox";
            this.trLogBox.Size = new System.Drawing.Size(138, 20);
            this.trLogBox.TabIndex = 3;
            // 
            // trPassIdBox
            // 
            this.trPassIdBox.Location = new System.Drawing.Point(151, 59);
            this.trPassIdBox.Name = "trPassIdBox";
            this.trPassIdBox.Size = new System.Drawing.Size(100, 20);
            this.trPassIdBox.TabIndex = 2;
            this.trPassIdBox.Text = "1";
            // 
            // trTestClientBox
            // 
            this.trTestClientBox.Location = new System.Drawing.Point(338, 21);
            this.trTestClientBox.Name = "trTestClientBox";
            this.trTestClientBox.Size = new System.Drawing.Size(138, 20);
            this.trTestClientBox.TabIndex = 1;
            this.trTestClientBox.Text = "xeclisxxx037";
            // 
            // trCaseIdBox
            // 
            this.trCaseIdBox.Location = new System.Drawing.Point(151, 21);
            this.trCaseIdBox.Name = "trCaseIdBox";
            this.trCaseIdBox.Size = new System.Drawing.Size(100, 20);
            this.trCaseIdBox.TabIndex = 0;
            this.trCaseIdBox.Text = "1";
            // 
            // groupBox2
            // 
            this.groupBox2.Controls.Add(this.tpModifiedLabel);
            this.groupBox2.Controls.Add(this.tsStateComboBox);
            this.groupBox2.Controls.Add(this.getTestPassStateButton);
            this.groupBox2.Controls.Add(this.tpCreateButton);
            this.groupBox2.Controls.Add(this.setTestPassStateButton);
            this.groupBox2.Controls.Add(this.label6);
            this.groupBox2.Controls.Add(this.tsAssemblyModBox);
            this.groupBox2.Controls.Add(this.testPassIdLabel);
            this.groupBox2.Controls.Add(this.label7);
            this.groupBox2.Controls.Add(this.tsTestPassId);
            this.groupBox2.Controls.Add(this.label8);
            this.groupBox2.Controls.Add(this.sendResultsButton);
            this.groupBox2.Controls.Add(this.label9);
            this.groupBox2.Controls.Add(this.tsAssemblyVerBox);
            this.groupBox2.Controls.Add(this.tsRunStartBox);
            this.groupBox2.Controls.Add(this.tsUserNameBox);
            this.groupBox2.Location = new System.Drawing.Point(12, 164);
            this.groupBox2.Name = "groupBox2";
            this.groupBox2.Size = new System.Drawing.Size(482, 137);
            this.groupBox2.TabIndex = 11;
            this.groupBox2.TabStop = false;
            this.groupBox2.Text = "Test Pass State";
            // 
            // tsStateComboBox
            // 
            this.tsStateComboBox.FormattingEnabled = true;
            this.tsStateComboBox.Items.AddRange(new object[] {
            "Not Run",
            "In Progress",
            "Completed",
            "Cancelled"});
            this.tsStateComboBox.Location = new System.Drawing.Point(375, 97);
            this.tsStateComboBox.Name = "tsStateComboBox";
            this.tsStateComboBox.Size = new System.Drawing.Size(94, 21);
            this.tsStateComboBox.TabIndex = 20;
            // 
            // getTestPassStateButton
            // 
            this.getTestPassStateButton.Location = new System.Drawing.Point(6, 94);
            this.getTestPassStateButton.Name = "getTestPassStateButton";
            this.getTestPassStateButton.Size = new System.Drawing.Size(83, 23);
            this.getTestPassStateButton.TabIndex = 19;
            this.getTestPassStateButton.Text = "Get";
            this.getTestPassStateButton.UseVisualStyleBackColor = true;
            this.getTestPassStateButton.Click += new System.EventHandler(this.getTestPassStateButton_Click);
            // 
            // setTestPassStateButton
            // 
            this.setTestPassStateButton.Location = new System.Drawing.Point(6, 58);
            this.setTestPassStateButton.Name = "setTestPassStateButton";
            this.setTestPassStateButton.Size = new System.Drawing.Size(83, 23);
            this.setTestPassStateButton.TabIndex = 18;
            this.setTestPassStateButton.Text = "Set";
            this.setTestPassStateButton.UseVisualStyleBackColor = true;
            this.setTestPassStateButton.Click += new System.EventHandler(this.setTestPassStateButton_Click);
            // 
            // label6
            // 
            this.label6.AutoSize = true;
            this.label6.Location = new System.Drawing.Point(333, 100);
            this.label6.Name = "label6";
            this.label6.Size = new System.Drawing.Size(35, 13);
            this.label6.TabIndex = 17;
            this.label6.Text = "State:";
            // 
            // label7
            // 
            this.label7.AutoSize = true;
            this.label7.Location = new System.Drawing.Point(104, 63);
            this.label7.Name = "label7";
            this.label7.Size = new System.Drawing.Size(26, 13);
            this.label7.TabIndex = 16;
            this.label7.Text = "Ver:";
            // 
            // label8
            // 
            this.label8.AutoSize = true;
            this.label8.Location = new System.Drawing.Point(271, 25);
            this.label8.Name = "label8";
            this.label8.Size = new System.Drawing.Size(55, 13);
            this.label8.TabIndex = 15;
            this.label8.Text = "Run Start:";
            // 
            // label9
            // 
            this.label9.AutoSize = true;
            this.label9.Location = new System.Drawing.Point(104, 25);
            this.label9.Name = "label9";
            this.label9.Size = new System.Drawing.Size(32, 13);
            this.label9.TabIndex = 14;
            this.label9.Text = "User:";
            // 
            // tsAssemblyVerBox
            // 
            this.tsAssemblyVerBox.Location = new System.Drawing.Point(145, 60);
            this.tsAssemblyVerBox.Name = "tsAssemblyVerBox";
            this.tsAssemblyVerBox.Size = new System.Drawing.Size(100, 20);
            this.tsAssemblyVerBox.TabIndex = 12;
            this.tsAssemblyVerBox.Text = "5.0.66.1";
            // 
            // tsRunStartBox
            // 
            this.tsRunStartBox.Location = new System.Drawing.Point(332, 22);
            this.tsRunStartBox.Name = "tsRunStartBox";
            this.tsRunStartBox.Size = new System.Drawing.Size(138, 20);
            this.tsRunStartBox.TabIndex = 11;
            this.tsRunStartBox.Text = "4/13/2007 2:49:30 PM";
            // 
            // tsUserNameBox
            // 
            this.tsUserNameBox.Location = new System.Drawing.Point(145, 22);
            this.tsUserNameBox.Name = "tsUserNameBox";
            this.tsUserNameBox.Size = new System.Drawing.Size(100, 20);
            this.tsUserNameBox.TabIndex = 10;
            this.tsUserNameBox.Text = "trevorm";
            // 
            // ResultAggUI
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(511, 468);
            this.Controls.Add(this.groupBox2);
            this.Controls.Add(this.groupBox1);
            this.Controls.Add(this.testPassGroupBox);
            this.Controls.Add(this.databaseNameLabel);
            this.Controls.Add(this.serverNameLabel);
            this.Controls.Add(this.databaseName);
            this.Controls.Add(this.serverName);
            this.Controls.Add(resultAggCreate);
            this.Name = "ResultAggUI";
            this.Text = "ResultAgg UI";
            this.groupBox1.ResumeLayout(false);
            this.groupBox1.PerformLayout();
            this.groupBox2.ResumeLayout(false);
            this.groupBox2.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.TextBox serverName;
        private System.Windows.Forms.TextBox databaseName;
        private System.Windows.Forms.Label serverNameLabel;
        private System.Windows.Forms.Label databaseNameLabel;
        private System.Windows.Forms.Button sendResultsButton;
        private System.Windows.Forms.TextBox tsTestPassId;
        private System.Windows.Forms.Label testPassIdLabel;
        private System.Windows.Forms.GroupBox testPassGroupBox;
        private System.Windows.Forms.TextBox tsAssemblyModBox;
        private System.Windows.Forms.Button tpCreateButton;
        private System.Windows.Forms.Label tpModifiedLabel;
        private System.Windows.Forms.GroupBox groupBox1;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.Button trCreateButton;
        private System.Windows.Forms.TextBox trLogBox;
        private System.Windows.Forms.TextBox trPassIdBox;
        private System.Windows.Forms.TextBox trTestClientBox;
        private System.Windows.Forms.TextBox trCaseIdBox;
        private System.Windows.Forms.Label label5;
        private System.Windows.Forms.TextBox trRunTimeBox;
        private System.Windows.Forms.CheckBox trCasePassedCheckBox;
        private System.Windows.Forms.GroupBox groupBox2;
        private System.Windows.Forms.Button getTestPassStateButton;
        private System.Windows.Forms.Button setTestPassStateButton;
        private System.Windows.Forms.Label label6;
        private System.Windows.Forms.Label label7;
        private System.Windows.Forms.Label label8;
        private System.Windows.Forms.Label label9;
        private System.Windows.Forms.TextBox tsAssemblyVerBox;
        private System.Windows.Forms.TextBox tsRunStartBox;
        private System.Windows.Forms.TextBox tsUserNameBox;
        private System.Windows.Forms.ComboBox tsStateComboBox;
        private System.Windows.Forms.Button trGetResultButton;
        private System.Windows.Forms.Label label10;
        private System.Windows.Forms.TextBox trResultIdBox;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XStatsTCR\TestConsole\TestCertReset.cs ===
using System;
using System.IO;
using System.Globalization;
using XStatsTCR;

namespace TestLib
{
	/// <summary>
	/// Summary description for TestCertReset.
	/// </summary>
	public class TestCertReset : TestCall
	{
		XRLStatsCertReset certreset = new XRLStatsCertReset();

		public TestCertReset()
		{
		
		}

		public override string ID
		{
			get
			{
				return "certreset";
			}
		}

		public override string Description
		{
			get
			{
				return "Reset title certification.";
			}
		}

		public override void Invoke() 
		{
			string	sPUID;
			ulong	ulPUID;

			while (true) 
			{
				Console.Write("Enter PUID as hex (0 to exit): ");
				sPUID = Console.ReadLine();

				try 
				{
					ulPUID = System.UInt64.Parse(sPUID,NumberStyles.AllowHexSpecifier);
				}
				catch (System.Exception e) 
				{
					Console.WriteLine("Invalid entry '{0}'", sPUID);
					Console.WriteLine(" -- {0}", e.Message);
					continue;
				}

				if (0 == ulPUID) 
					break;

				certreset._ulPuid = ulPUID;
				Console.WriteLine("PUID: {0,16:x}", ulPUID);

				try 
				{	
					Console.WriteLine("Posting request...");
					certreset.PostRequest();

					Console.WriteLine( certreset.GetDumpString() );
				}
				catch (System.Exception e)
				{
					Console.WriteLine("certreset failed");
					Console.WriteLine(" -- {0}\n at {1}", e.Message, e.Source);
				}

				break;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XStatsTCR\TestConsole\TestCertVerify.cs ===
using System;
using System.IO;
using System.Globalization;
using XStatsTCR;

namespace TestLib
{
	/// <summary>
	/// Summary description for TestCertVerify.
	/// </summary>
	public class TestCertVerify : TestCall
	{
		XRLStatsCertVerify certverify = new XRLStatsCertVerify();

		public TestCertVerify()
		{
			
		}

		public override string ID
		{
			get
			{
				return "certverify";
			}
		}

		public override string Description
		{
			get
			{
				return "Verify title certification.";
			}
		}

		public override void Invoke() 
		{
			string	sPUID;
			ulong	ulPUID;

			while (true) 
			{
				Console.Write("Enter PUID as hex (0 to exit): ");
				sPUID = Console.ReadLine();

				try 
				{
					ulPUID = System.UInt64.Parse(sPUID,NumberStyles.AllowHexSpecifier);
				}
				catch (System.Exception e) 
				{
					Console.WriteLine("Invalid entry '{0}'", sPUID);
					Console.WriteLine(" -- {0}", e.Message);
					continue;
				}

				if (0 == ulPUID) 
					break;

				certverify._ulPuid = ulPUID;
				Console.WriteLine("PUID: {0,16:x}", ulPUID);

				try 
				{
					byte[] results;

					Console.WriteLine("Posting request...");
					results = certverify.PostRequest();
					
					Console.WriteLine( certverify.GetDumpString() );

					Console.WriteLine("Fetching results...");

					if (results == null) 
					{
						
						Console.WriteLine("[ERROR] Results were null");
					}
					else
					{
						object response;

						response = certverify.GetObjectFromResponse(results);
						
						Console.WriteLine("Response");
						Console.WriteLine(response.ToString());
					}
				}
				catch (System.Exception e)
				{
					Console.WriteLine("certverify operation failed");
					Console.WriteLine(" -- {0}\n at {1}", e.Message, e.Source);
				}

				break;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XStatsTCR\WebApp\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace StatsTCR 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.components = new System.ComponentModel.Container();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XStatsTCR\WebApp\WebForm1.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.IO;

namespace StatsTCR
{
	/// <summary>
	/// Summary description for WebForm1.
	/// </summary>
	public class WebForm1 : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Button btncertverify;
		protected System.Web.UI.WebControls.Button btncertreset;
		protected System.Web.UI.WebControls.TextBox TextGamerTag;
		protected System.Web.UI.WebControls.Label tResults;
		protected XStatsTCR webservice = new XStatsTCR();
	
		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.btncertreset.Click += new System.EventHandler(this.btncertreset_Click);
			this.btncertverify.Click += new System.EventHandler(this.btncertverify_Click);
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

		private void btncertreset_Click(object sender, System.EventArgs e)
		{
			byte[] webID = new byte[8];
			ulong PUID;

			try 
			{
				PUID = UInt64.Parse(TextGamerTag.Text);
				
				//This web ID write step should be replaced with the Passport WebID
				MemoryStream ms = new MemoryStream(webID);
				BinaryWriter bw = new BinaryWriter(ms);

				bw.Write(PUID);
				bw.Close();
				ms.Close();
			}
			catch (System.Exception ex)
			{
				tResults.Text = 
					"<P><B>Error reading PUID</B></P>\r\n" +
					"<P><B>Exception String</B></P>\r\n" +
					"<FONT color=red><P><B>" + ex.ToString() + "</B></P></FONT>\r\n";

				return;
			}

			try
			{
				webservice.CertReset(webID, PUID);
				tResults.Text =
					"<FONT color=green><P><B>CertReset request successful</B></P></FONT>\r\n";
			}
			catch (System.Exception ex)
			{
				tResults.Text =
					"<P><B>CertReset raised an exception</B></P>\n" +
					"<FONT color=red><P><B>" + ex.ToString() + "</B></P></FONT>\r\n";
			}
		}

		private void btncertverify_Click(object sender, System.EventArgs e)
		{
			byte[] webID = new byte[8];
			ulong PUID;
			RepCertVerify result;

			try 
			{
				PUID = UInt64.Parse(TextGamerTag.Text);
			
				//This web ID write step should be replaced with the Passport WebID
				MemoryStream ms = new MemoryStream(webID);
				BinaryWriter bw = new BinaryWriter(ms);

				bw.Write(PUID);
				bw.Close();
				ms.Close();
			}
			catch (System.Exception ex)
			{
				tResults.Text = 
					"<P><B>Error reading PUID</B></P>\r\n" +
					"<P><B>Exception String</B></P>\r\n" +
					"<FONT color=red><P><B>" + ex.ToString() + "</B></P></FONT>\r\n";

				return;
			}

			try
			{
				result = webservice.CertVerify(webID, PUID);
				tResults.Text =
					"<FONT color=green><P><B>CertVerify request successful</B></P></FONT>\r\n" +
					"<P><B>Response</B></P>\r\n";
				if ( null == result ) 
				{
					tResults.Text += "<P><FONT color=red><B>Results are null</B></FONT></P>\r\n";
				}
				else
				{
					tResults.Text += "<TABLE width=700px BORDER=1 ALIGN=center><TR>" +
						"<TH width=100px>Level</TH><TH width=600px>Message</TH></TR>\r\n";
					for (int c=0; c<result._usEntryCount; c++) 
					{
						tResults.Text += 
							"<TR><TD><P>" + result._entries[c]._bLevel + "</P></TD>\r\n" + 
							"<TD><P>" + result._entries[c]._description + "</P></TD></TR>";
					}
					tResults.Text += "</TABLE>\r\n";
				}
			}
			catch (System.Exception)
			{
				tResults.Text =
					"<P><B>Certverify raised an exception</B></P>\n" +
					"<FONT color=red><P><B>" + e.ToString() + "</B></P></FONT>\r\n";
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XStatsTCR\WebService\CommonCode.cs ===
using System;
using System.IO;
using System.Text;

namespace XStatsTCR
{
	public class ReqCertReset
	{
		public ulong    _ulPuid     = 0;
        
		public void ReadFrom(BinaryReader br)
		{
			_ulPuid = br.ReadUInt64();
		}
        
		public void WriteTo(BinaryWriter bw)
		{
			bw.Write(_ulPuid);
		}
        
		public override string ToString()
		{
			return 
				"\n_ulPuid: 0x"+_ulPuid.ToString("x");
		}
	}
    
	public class ReqCertVerify
	{
		public ulong    _ulPuid     = 0;
        
		public void ReadFrom(BinaryReader br)
		{
			_ulPuid = br.ReadUInt64();
		}
        
		public void WriteTo(BinaryWriter bw)
		{
			bw.Write(_ulPuid);
		}
        
		public override string ToString()
		{
			return 
				"\n_ulPuid: 0x"+_ulPuid.ToString("x");
		}
	}
    
	public class RepCertVerify
	{
		public ushort               _usEntryCount = 0;
		public MsgCertVerifyEntry[] _entries = null;
        
		public void ReadFrom(BinaryReader br)
		{
			_usEntryCount = br.ReadUInt16();
			_entries = new MsgCertVerifyEntry[_usEntryCount];
			for(int i=0; i < _entries.Length; i++)
			{
				_entries[i] = new MsgCertVerifyEntry();
				_entries[i].ReadFrom(br);
			}
		}
        
		public void WriteTo(BinaryWriter bw)
		{
			_usEntryCount = (ushort) _entries.Length;
			bw.Write(_usEntryCount);
			for(int i=0; i < _entries.Length; i++)
			{
				_entries[i].WriteTo(bw);
			}
		}
        
		public override string ToString()
		{
			StringBuilder str = new StringBuilder(
				"\n_usEntryCount:"+_usEntryCount+
				"\n_entries:");
                
			for(int i=0; i < _entries.Length; i++)
			{
				str.Append((_entries[i] != null ? _entries[i].ToString() : "(null)"));
			}
            
			return str.ToString();
		}
	}

	public class MsgCertVerifyEntry
	{
		public byte     _bLevel;
		public ushort   _usSizeDescription = 0;
		public string   _description;
        
		public void ReadFrom(BinaryReader br)
		{
			_bLevel = br.ReadByte();
			_usSizeDescription  = br.ReadUInt16();
			_description = Encoding.UTF8.GetString(br.ReadBytes((int)_usSizeDescription));
		}
        
		public void WriteTo(BinaryWriter bw)
		{
			byte[] binDescription = Encoding.UTF8.GetBytes(_description);
			_usSizeDescription = (ushort) binDescription.Length;
            
			bw.Write(_bLevel);
			bw.Write(_usSizeDescription);
			bw.Write(binDescription);
		}
	}
		
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XStatsTCR\WebService\VerifyResponse.cs ===
using System;
using System.IO;
using System.Text;

namespace XStatsTCR
{

	public class CertVerifyMessageEntry
	{
		protected byte     level;
		protected ushort   sizedescription = 0;
		protected string   description;

		public byte Level
		{
			get
			{
				return this.level;
			}
			set
			{ 
				this.level = value;
			}
		}

		public ushort SizeDescription
		{
			get
			{
				return this.sizedescription;
			}
			set
			{
				this.sizedescription = value;
			}
		}

		public string Description
		{
			get
			{
				return this.description;
			}
			set 
			{
				this.description = value;
			}
		}

		public void Unserialize(BinaryReader reader) 
		{
			Level = reader.ReadByte();
			SizeDescription = reader.ReadUInt16();
			Description = Encoding.UTF8.GetString(reader.ReadBytes(SizeDescription));
		}

		public void Serialize(BinaryWriter writer) 
		{
			byte[] Raw = Encoding.UTF8.GetBytes(Description);
			SizeDescription = (ushort)Raw.Length;

			writer.Write(Level);
			writer.Write(SizeDescription);
			writer.Write(Raw);
		}

		public override string ToString() 
		{
			StringBuilder sb = new StringBuilder(
				"Level: " + Level.ToString() + "\n" +
				"Length: " + Description.Length.ToString() + "\n" +
				"Description: " + Description
				);

			return sb.ToString();
		}
	}

	public class StatsCertVerifyResponse
	{
		protected ushort					messagecount = 0;
		protected CertVerifyMessageEntry[]	messages = null;

		public ushort MessageCount
		{
			get 
			{
				return this.messagecount;
			}
			set
			{
				this.messagecount = value;
			}
		}

		public CertVerifyMessageEntry[] Messages
		{
			get
			{
				return this.messages;
			}
		}

		public void Unserialize(BinaryReader reader) 
		{
			MessageCount = reader.ReadUInt16();
			messages = new CertVerifyMessageEntry[MessageCount];

			for (uint c=0; c<MessageCount; c++) 
			{
				messages[c] = new CertVerifyMessageEntry();
				messages[c].Unserialize(reader);
			}
		}

		public void Serialize(BinaryWriter writer) 
		{
			MessageCount = (ushort)Messages.Length;

			writer.Write(MessageCount);

			for (uint c=0; c<MessageCount; c++) 
			{
				messages[c].Serialize(writer);
			}

		}

		public override string ToString() 
		{
			StringBuilder sb = new StringBuilder(
				"MessageCount: " + MessageCount.ToString() + "\n" +
				"Messages:" + "\n"
				);

			for (uint c=0; c<MessageCount; c++) 
			{
				if (null != messages[c])
					sb.Append(messages[c].ToString());
				else
					sb.Append("(null)");
			}

			return sb.ToString();
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XStatsTCR\WebService\XRLStatsCertReset.cs ===
using System;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;

namespace XStatsTCR
{
	/// <summary>
	/// Requests a certification reset.
	/// Returns:
	///		Nothing
	/// </summary>
	public class XRLStatsCertReset : XRLRequest
	{
		[XRLPayloadFld(IsUPuid=true)]
		public ulong _ulPuid = 0;

		public override string RequestName
		{
			get
			{
				return "certreset";
			}
		}

		protected override string GetServiceName()
		{
			return "/xstats/xstatscertreset.ashx";
		}

		public override string ToString()
		{
			return 
				"_ulPuid: " + _ulPuid.ToString("x");
		}

		public XRLStatsCertReset()
		{
		}

		public override object GetObjectFromResponse(byte[] response) 
		{
			return null;
		}

		protected override void UpdateSlot(ref CSGInfo slot)
		{
			slot.userPuid0 = _ulPuid;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XStatsTCR\WebService\XRLRequest.cs ===
using System;
using System.Text;
using System.Collections;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Stats;
using ServerTestFramework.LiveService.Stats.Util;
using ServerTestFramework.LiveService.FakeSG;

namespace XStatsTCR
{
	/// <summary>
	/// Summary description for XRLRequest.
	/// </summary>
	public class XRLRequest : XRLPayload
	{
		public XRLRequest()
		{
			this.ServiceId = XOService.Statistics;

			ManualPopulateSlot();

			/*
			 * Since we are not using certificates
			 * 
			InitializerInfo ii = new InitializerInfo();
			ii.UseUodb = false;
			ii.UseFakeSG = false;
			ii.UseSharedFakeSG = false;
			ii.Certificates = false;
			XmlDocument config = new XmlDataDocument();
			config.Load("stf.xml");
				
			ServerTestFramework.Global.Initialize(config);

			XmlNode servers = config.SelectSingleNode("/stf/servers");
			if (servers != null)
			{
				ServerTestFramework.Global.Env.Add(servers);
			}
			else
			{
				throw new Exception("Section <stf><servers> not found in any specified xml config files.  Verify " + ServerTestFramework.Global.DefaultConfigFile + " is available or specify an alternative on the command line.");
			}

			// bypass StfRunner version checking
			InitializerInfo.SkipInit();
			InitializerInfo.InitializeGlobalResources(ii, config);
			*/
		}

		public virtual string RequestName
		{
			get
			{
				return "";
			}
		}

		#region Derived class functions to implement
	
		protected override string GetServiceName()
		{
			throw new Exception("Not implemented");
		}

		public virtual object GetObjectFromResponse(byte[] response) 
		{
			throw new Exception("Not implemented");
		}
		
		#endregion

		#region XRL Posting code

		public byte[] PostRequest() 
		{
			IPEndPoint		ipep	= new IPEndPoint( IPAddress.Parse("10.10.7.207") , 8080);
			MemoryStream	ms		= new MemoryStream(512);
			bool			result	= false;

			WriteStream( ms );

			UpdateSlot(ref Slot);

			MemoryStream	header = new MemoryStream(GenerateHttpHeader(ipep, ms));
			Console.WriteLine( (new StreamReader(header)).ReadToEnd() );

			result = InternalExecute(ipep, ms);

			ms.Close();

			if ( result ) 
			{
				if( (xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)) )
				{
					return xAct.ResponseContents;
				}
			}

			return null;
		}

		public override void ManualPopulateSlot()
		{
			PopulateSlot(ref Slot);

			Slot.titleId	= 0;
			Slot.userPuid0	= 0;
			Slot.userPuid1	= 0;
			Slot.userPuid2	= 0;
			Slot.userPuid3	= 0;

			ManualSlotSetup=true;
		}

		protected virtual void UpdateSlot(ref CSGInfo slot) 
		{
		}

		#endregion

		#region XRLPayload requirement overrides

		protected override void ReadResponse(MemoryStream responsestream) 
		{
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XStatsTCR\WebService\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace XStatsTCR 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.components = new System.ComponentModel.Container();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XStatsTCR\WebService\XStatsTCR.asmx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Web;
using System.Web.Services;
using System.IO;

namespace XStatsTCR
{
	/// <summary>
	/// Summary description for XStatsTCR.
	/// </summary>
	public class XStatsTCR : System.Web.Services.WebService
	{
		public XStatsTCR()
		{
			//CODEGEN: This call is required by the ASP.NET Web Services Designer
			InitializeComponent();
		}

		#region Component Designer generated code
		
		//Required by the Web Services Designer 
		private IContainer components = null;
				
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if(disposing && components != null)
			{
				components.Dispose();
			}
			base.Dispose(disposing);		
		}
		
		#endregion

		private bool CompareWebIDToPUID(byte[] WebID, ulong Puid) 
		{
			MemoryStream ms = new MemoryStream(WebID);
			BinaryReader br = new BinaryReader(ms);

			ulong PUID;

			if (8 != ms.Length)
				return false;

			PUID = br.ReadUInt64();

			return PUID == Puid;
		}

		[WebMethod]
		public void CertReset(byte[] WebID, ulong Puid) 
		{
			int x = 1, y = 2;

			if (x != y )
				return;

			if (false == CompareWebIDToPUID(WebID, Puid)) 
			{
                throw new System.Exception("Access denied, WebID does not match");
			}

			try
			{
				XRLStatsCertReset reset = new XRLStatsCertReset();
				reset._ulPuid = Puid;

				reset.PostRequest();
			}
			catch (System.Exception e)
			{
				throw new System.Exception("Title certification reset failed", e);
			}
		}

		[WebMethod]
		public RepCertVerify CertVerify(byte[] WebID, ulong Puid) 
		{
			int x = 1, y = 2;

			if (x != y ) 
			{
				RepCertVerify rcv = new RepCertVerify();

				rcv._entries = new MsgCertVerifyEntry[1];
				rcv._usEntryCount = 1;

				rcv._entries[0] = new MsgCertVerifyEntry();
				rcv._entries[0]._bLevel = 1;
				rcv._entries[0]._description = "Test Description";
				rcv._entries[0]._usSizeDescription = (ushort)rcv._entries[0]._description.Length;
				return rcv;
			}

			if (false == CompareWebIDToPUID(WebID, Puid)) 
			{
				throw new System.Exception("Access denied, WebID does not match");
			}

			try 
			{
				byte[] response;

				XRLStatsCertVerify verify = new XRLStatsCertVerify();
				verify._ulPuid = Puid;

				response = verify.PostRequest();
				
				return (RepCertVerify)verify.GetObjectFromResponse(response);
			}
			catch (System.Exception e)
			{
				throw new System.Exception("Title cert verify filed", e);
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\AasManager\src\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XStatsTCR\WebService\XRLStatsCertVerify.cs ===
using System;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;

namespace XStatsTCR
{
	/// <summary>
	/// Summary description for XRLReqCertVerify.
	/// </summary>
	public class XRLStatsCertVerify : XRLRequest
	{
		[XRLPayloadFld(IsUPuid=true)]
		public ulong _ulPuid = 0;

		public override string RequestName
		{
			get
			{
				return "certverify";
			}
		}

		protected override string GetServiceName()
		{
			return "/xstats/xstatscertverify.ashx";
		}

		public override string ToString()
		{
			return 
				"_ulPuid: " + _ulPuid.ToString("x");
		}

		public XRLStatsCertVerify()
		{
		}

		public override object GetObjectFromResponse(byte[] response) 
		{
			MemoryStream ms = new MemoryStream(response);
			System.IO.BinaryReader br = new BinaryReader(ms);

			RepCertVerify rep = new RepCertVerify();

			rep.ReadFrom(br);

			br.Close();
			ms.Close();

			return rep;
		}

		protected override void UpdateSlot(ref CSGInfo slot)
		{
			slot.userPuid0 = _ulPuid;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\XStatsTCR\WebApp\XStatsTCR.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.1.4322.573.
// 
namespace StatsTCR {
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="XStatsTCRSoap", Namespace="http://tempuri.org/")]
    public class XStatsTCR : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public XStatsTCR() {
            this.Url = "http://127.0.0.1/XSTatsTCR/XStatsTCR.asmx";
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/CertReset", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void CertReset([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] WebID, System.UInt64 Puid) {
            this.Invoke("CertReset", new object[] {
                        WebID,
                        Puid});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCertReset(System.Byte[] WebID, System.UInt64 Puid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CertReset", new object[] {
                        WebID,
                        Puid}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCertReset(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/CertVerify", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public RepCertVerify CertVerify([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] WebID, System.UInt64 Puid) {
            object[] results = this.Invoke("CertVerify", new object[] {
                        WebID,
                        Puid});
            return ((RepCertVerify)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCertVerify(System.Byte[] WebID, System.UInt64 Puid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CertVerify", new object[] {
                        WebID,
                        Puid}, callback, asyncState);
        }
        
        /// <remarks/>
        public RepCertVerify EndCertVerify(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((RepCertVerify)(results[0]));
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://tempuri.org/")]
    public class RepCertVerify {
        
        /// <remarks/>
        public System.UInt16 _usEntryCount;
        
        /// <remarks/>
        public MsgCertVerifyEntry[] _entries;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://tempuri.org/")]
    public class MsgCertVerifyEntry {
        
        /// <remarks/>
        public System.Byte _bLevel;
        
        /// <remarks/>
        public System.UInt16 _usSizeDescription;
        
        /// <remarks/>
        public string _description;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\AasManager\src\AasManager.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;

using System.Xml;
using System.ComponentModel;

namespace xonline.tools.aasmanager.src 
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class AasManager
	{
		enum Environment 
		{
			TestNet =1,
			PartnerNet =2
		}
		
		int UserCount = 0;
		int Option =0; 
		int env =0;   // env 1 = test net and Evn 2 = partnernet.
		string  Prefix =null;
		BaseUserInfo  userinfo;
		string filename;

		public AasManager()
		{
			userinfo= new BaseUserInfo();
		}

		
		public  XmlDocument LoadXmlConfig(string fileName)
		{
			XmlDocument config = new XmlDocument();
			config.Load(fileName);

			try
			{
				//Global.Env.Add(config.SelectSingleNode("//stf/servers"));
			}
			catch (Exception)
			{
				System.Console.WriteLine("Section <stf><servers> not found in any specified xml config files.  Verify stf.xml is available or specify an alternative on the command line.");
				
			}


			return config;
		}

		/*  create users option=1
		 * Replace users for title option =2
		 */

		public void Help()
		{
			System.Console.WriteLine(" AasManager.exe <options> ");
			System.Console.WriteLine(" Options include: ");
			System.Console.WriteLine(" -env	Specifies which environment the tool is running in, use test for testnet and partner for partnernet ");
			System.Console.WriteLine(" -(f)ile	This  options  creates users based on the input xml file ");
			System.Console.WriteLine(" -(c)reate	This  options  creates users ");
			System.Console.WriteLine(" -(n)umber	Number of users to create");
			System.Console.WriteLine(" -(p)refix	Prefix of the gamer tag");
			System.Console.WriteLine(" Eg: AasManager.exe -c -n 100 -p \"testuser\" -env test");
			System.Console.WriteLine(" Eg: AasManager.exe -f c:\\temp\\user1.xml -env test");
		}


		public bool LoadFromXML()
		{
			bool retval = true;
			XmlDocument config = new XmlDocument();
			try
			{
				config.Load(filename);
			}
			catch(Exception e)
			{
				
				System.Console.WriteLine("Unable to open file"+filename);
				Help();
				
				throw e;
			}

			try
			{
				XmlNodeList UserConfig = config.DocumentElement["UserConfig"].ChildNodes;
				for(int j=0 ; j< UserConfig.Count;j++)
				{
					string Prefix = UserConfig[j].Attributes["Prefix"].Value;

					if(Prefix==null || Prefix.Length<1 || Prefix.Length>11)
					{
						System.Console.WriteLine("Invalid Prefix : Prefix length should be greater then 1 and less then 11 characters");
						return false;
					}

					string sUserCount = UserConfig[j].Attributes["NO"].Value;
					XmlNodeList RecoveryInfo = UserConfig[j].ChildNodes;
					for(int i=0 ; i< RecoveryInfo.Count;i++)
					{
						
						if(RecoveryInfo[i].Name=="FirstName")
							userinfo.firstName=RecoveryInfo[i].InnerText;
						if(RecoveryInfo[i].Name=="LastName")
							userinfo.lastName=RecoveryInfo[i].InnerText;
						if(RecoveryInfo[i].Name=="street1")
							userinfo.street1=RecoveryInfo[i].InnerText;
						if(RecoveryInfo[i].Name=="city")
							userinfo.city=RecoveryInfo[i].InnerText;
						if(RecoveryInfo[i].Name=="state")
							userinfo.state=RecoveryInfo[i].InnerText;
						if(RecoveryInfo[i].Name=="postalCode")
							userinfo.postalCode=RecoveryInfo[i].InnerText;
						if(RecoveryInfo[i].Name=="phoneAreaCode")
							userinfo.phonePrefix=RecoveryInfo[i].InnerText;
						if(RecoveryInfo[i].Name=="phoneNumber")
							userinfo.phoneNumber=RecoveryInfo[i].InnerText;
						if(RecoveryInfo[i].Name=="cardType")
							userinfo.cardType=RecoveryInfo[i].InnerText;
						if(RecoveryInfo[i].Name=="cardNumber")
							userinfo.cardNumber=RecoveryInfo[i].InnerText;
						
					}
					UserCount=	(int)TypeDescriptor.GetConverter(UserCount).ConvertFromString(sUserCount);

					if( UserCount<1 ||UserCount>10000)
					{
						System.Console.WriteLine("Invalid User Count : Usercount should be greater then 1 and less then 10,000");
						return  false;
					}

					BulkAccountCreator temp= new BulkAccountCreator(Prefix,UserCount);
					temp.CreatAccounts(userinfo);

				}
			}
			catch( Exception e)
			{
				System.Console.WriteLine(e);
				throw e;
			}
			return retval;	

		}

		public bool Parse(string[] commandLine)
		{
			bool retval= true;
			
			
			try
			{
				for (int i = 0; i < commandLine.Length; i++)
				{
					if (commandLine[i].StartsWith("-") || commandLine[i].StartsWith("/"))
					{
						string command = commandLine[i].Substring(1);

						if(command.ToLower() =="env")
                        {
							string temp= commandLine[++i];
							if(temp.ToLower()=="test")
								env=(int)Environment.TestNet;
							else if (temp.ToLower()=="partner")
								env=(int)Environment.PartnerNet;
						}
						
						if(command.ToLower() =="c")
							Option=1;
						if(command.ToLower() =="r")
							Option=2;
						if(command.ToLower() =="f")
						{	
							filename = commandLine[++i];
							Option=3;
						}
						if(command.ToLower() =="n")
						{
							string temp =commandLine[++i];
							if(temp !=null && temp.Length>0)
								UserCount = (int)TypeDescriptor.GetConverter(UserCount).ConvertFromString(temp);
							if( UserCount<1 ||UserCount>10000)
							{
								System.Console.WriteLine("Invalid User Count : Usercount should be greater then 1 and less then 10,000");
								retval= false;
							}
							
							
						}
						if(command.ToLower() =="p")
						{
							Prefix= commandLine[++i];
							if(Prefix==null || Prefix.Length<1 || Prefix.Length>11)
							{
								System.Console.WriteLine("Invalid Prefix : Prefix length should be greater then 1 and less then 11 characters");
								retval= false;
							}
						}
					}
				}

				if(Option ==0 || !retval  )
				{
					Help();
					retval= false;
				}
			}
			catch(Exception exp)
			{
				Help();
				retval= false;
				System.Console.WriteLine(exp);
			}

			return retval;
		}
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			bool validState = true;
			//
			// TODO: Add code to start application here
			//
			AasManager  manager= new AasManager();
			if(manager.Parse(args))
			{				
				if(manager.env== (int)Environment.TestNet)
                {
                    manager.LoadXmlConfig("stf.xml");
                    CoreGlobal.Initialize("stf.xml");
                }
				else if(manager.env == (int)Environment.PartnerNet)
                {
                    manager.LoadXmlConfig("stf_partnernet.xml");
					CoreGlobal.Initialize("stf_partnernet.xml");
                }
				else if (manager.env<0 ||manager.env>(int)Environment.PartnerNet)
					manager.Help();


				if(manager.Option==1)
				{	
					if( manager.UserCount<1 ||manager.UserCount>10000)
					{
						System.Console.WriteLine("Invalid User Count : Usercount should be greater then 1 and less then 10,000");
						validState= false;
					}
					if(manager.Prefix==null || manager.Prefix.Length<1 || manager.Prefix.Length>11)
					{
						System.Console.WriteLine("Invalid Prefix : Prefix length should be greater then 1 and less then 11 characters");
						validState= false;
					}

					if(validState)
					{
						BulkAccountCreator temp= new BulkAccountCreator(manager.Prefix,manager.UserCount);
						temp.CreatAccounts(manager.userinfo);
					}
					
				}
				if(manager.Option==3)
				{
					try
					{
						manager.LoadFromXML();
							
					}
					catch (Exception e)
					{
						System.Console.WriteLine(e);
					}

				}


				CoreGlobal.Uninitialize();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\AasManager\src\BulkAccountCreator.cs ===
using System;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using System.IO;


namespace xonline.tools.aasmanager.src 
{
	public class BaseUserInfo
	{
		public string firstName = "Foo";
		public string lastName = "Bar";
		public string city = "Redmond";
		public string state="WA";
		public string phonePrefix="425";
		public string phoneNumber="555-1212";
		public string postalCode= "98052";
		public string street1 = "1 Microsoft Way";
		public string street2 ="";
		public string cardType ="Visa";
		public string cardNumber ="4111111111111111";

	};
	/// <summary>
	/// Summary description for BulkAccountCreator.
	/// </summary>
	public class BulkAccountCreator
	{
		string m_Prefix;
		int m_NoOfUsersToCreate; 		

		public BulkAccountCreator(string Prefix,int Count)
		{
			m_Prefix =Prefix;
			m_NoOfUsersToCreate =Count;			
		}


		/*
		 * Default Account recovery information
		 *  Name Foo Bar
		 * Address 1 Microsoft Way
		 * Redmond, wa 98052
		 * USA
		 * CC Visa - 4111 1111 1111 1111
		 * Tel#	425 555 1212
		 * */
		public static ulong CreateUser(string GamerTag ,StreamWriter logfile,BaseUserInfo baseinfo)
		{
			ulong puid;
			Owner ownr=new Owner(GamerTag);
			ownr.firstName = baseinfo.firstName;
			ownr.lastName = baseinfo.lastName;
			ownr.city = baseinfo.city;
			ownr.state=baseinfo.state;
			ownr.phonePrefix=baseinfo.phonePrefix;
			ownr.phoneNumber=baseinfo.phonePrefix;
			ownr.postalCode= baseinfo.postalCode;
			ownr.street1 = baseinfo.street1;
			ownr.street2 ="";
			ownr.cardNumber= baseinfo.cardNumber;
			ownr.cardHolder = baseinfo.firstName+" "+baseinfo.lastName;
			
			
			puid=ownr.Create();
			if (puid==0)
			{
				// get the puid from UODB and Add to list.
				puid=UodbWS.DoesUserExist(GamerTag);
			}
			logfile.WriteLine(GamerTag +" , "+puid);
			return puid;
		}


		public void CreatAccounts(BaseUserInfo UserInfo)
		{
			StreamWriter sw =null;
			System.Console.WriteLine("Creating Users");
			try
			{
				string filename = m_Prefix+"Users.txt";
				sw = new StreamWriter(filename);
					
				sw.WriteLine("Account recovery information");
				sw.WriteLine("Name: "+ UserInfo.firstName+" "+UserInfo.lastName);
				sw.WriteLine("Address:"+UserInfo.street1+" , "+UserInfo.city+" "+ UserInfo.state+" "+UserInfo.postalCode+" , USA");
				sw.WriteLine("CC: Visa -" +UserInfo.cardNumber);
				sw.WriteLine("Telephone#:"+	UserInfo.phonePrefix+" "+UserInfo.phoneNumber);
				sw.WriteLine("");

				sw.WriteLine("** User information ****");
				
				for(int i=0;i<m_NoOfUsersToCreate;i++)
				{
					int j= i+1;
					string gamertag = m_Prefix+j.ToString();
					CreateUser(gamertag,sw,UserInfo);
					
					System.Console.Write("\rCreated "+ (i+1)+" Users");
					
				}
			}
			catch(Exception exp)
			{
				System.Console.Write("\nError occured while Creating Users");
				System.Console.Write(exp);
			}
			finally
			{				
				if(sw!=null)
					sw.Close();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\AasManager\src\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_aasmanager_none_12.4.56.0_none_6f89f6d225e86bff
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_aasmanager_no-public-key_12.4.56.0_x-ww_a40c591d
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=aasmanager
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_aasmanager_no-public-key_12.4.56.0_x-ww_a40c591d
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_aasmanager_no-public-key_12.4.56.0_x-ww_a40c591d.manifest
XP_MANIFEST_PATH=manifests\msil_aasmanager_no-public-key_12.4.56.0_x-ww_a40c591d.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_aasmanager_no-public-key_12.4.56.0_x-ww_a40c591d.cat
XP_CATALOG_PATH=manifests\msil_aasmanager_no-public-key_12.4.56.0_x-ww_a40c591d.cat
XP_PAYLOAD_PATH=msil_aasmanager_no-public-key_12.4.56.0_x-ww_a40c591d
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=aasmanager,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\AasManager\src\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\AasManager\src\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_aasmanager_none_12.4.56.0_none_6f89f6d225e86bff
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_aasmanager_no-public-key_12.4.56.0_x-ww_a40c591d
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=aasmanager
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_aasmanager_no-public-key_12.4.56.0_x-ww_a40c591d
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_aasmanager_no-public-key_12.4.56.0_x-ww_a40c591d.manifest
XP_MANIFEST_PATH=manifests\msil_aasmanager_no-public-key_12.4.56.0_x-ww_a40c591d.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_aasmanager_no-public-key_12.4.56.0_x-ww_a40c591d.cat
XP_CATALOG_PATH=manifests\msil_aasmanager_no-public-key_12.4.56.0_x-ww_a40c591d.cat
XP_PAYLOAD_PATH=msil_aasmanager_no-public-key_12.4.56.0_x-ww_a40c591d
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=aasmanager,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\AasManager\src\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\adt\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

PublishADT:
    -md %_NT386TREE%\tools\ADT
    -md %_NT386TREE%\tools\ADT\ADT
    -xcopy $(INETROOT)\public\ext\tools\x86\Adtscript.ps1 $(_NT386TREE)\Tools\ADT
    -xcopy $(INETROOT)\public\ext\tools\x86\_PartnerADT.cmd $(_NT386TREE)\Tools\ADT
    -rename $(_NT386TREE)\Tools\ADT\_PartnerADT.cmd ADT.cmd 
    -robocopy $(INETROOT)\public\ext\tools\x86\ADT $(_NT386TREE)\Tools\ADT\ADT /E /R:0 /NP /NJH /NJS /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\adt\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_adt_none_12.4.56.0_none_b4d1374f193f9929
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_adt_no-public-key_12.4.56.0_x-ww_a888d207
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=adt
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_adt_no-public-key_12.4.56.0_x-ww_a888d207
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_adt_no-public-key_12.4.56.0_x-ww_a888d207.manifest
XP_MANIFEST_PATH=manifests\x86_adt_no-public-key_12.4.56.0_x-ww_a888d207.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_adt_no-public-key_12.4.56.0_x-ww_a888d207.cat
XP_CATALOG_PATH=manifests\x86_adt_no-public-key_12.4.56.0_x-ww_a888d207.cat
XP_PAYLOAD_PATH=x86_adt_no-public-key_12.4.56.0_x-ww_a888d207
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=adt,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\adt\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_adt_none_12.4.56.0_none_b4d1374f193f9929
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_adt_no-public-key_12.4.56.0_x-ww_a888d207
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=adt
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_adt_no-public-key_12.4.56.0_x-ww_a888d207
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_adt_no-public-key_12.4.56.0_x-ww_a888d207.manifest
XP_MANIFEST_PATH=manifests\x86_adt_no-public-key_12.4.56.0_x-ww_a888d207.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_adt_no-public-key_12.4.56.0_x-ww_a888d207.cat
XP_CATALOG_PATH=manifests\x86_adt_no-public-key_12.4.56.0_x-ww_a888d207.cat
XP_PAYLOAD_PATH=x86_adt_no-public-key_12.4.56.0_x-ww_a888d207
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=adt,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\APDispatcher\FileGrouping.cs ===
using System;
using System.Collections;
using System.IO;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;

using xonline.common.offerutil;
using xonline.common.xlastutil;

namespace xonline.tools.APDispatcher
{
    #region User-defined exception classes

    public class InvalidOfferFileException : ApplicationException
    {
        public InvalidOfferFileException(String offerFile, Exception innerException)
            : base("Invalid offer file " + offerFile, innerException)
        {

        }
    }
    /// <summary>
    /// This exception is thrown when a list of files contains both XLAST and CAB files.
    /// </summary>
    public class MultipleContentTypesInOfferException : ApplicationException
    {
        public MultipleContentTypesInOfferException() {}
        public MultipleContentTypesInOfferException(string message) : base(message) {}
        public MultipleContentTypesInOfferException(string message, Exception inner) : base(message, inner) {}
    }

    public class MissingContentOfferException : ApplicationException
    {
        public MissingContentOfferException() {}
        public MissingContentOfferException(string message) : base(message) {}
        public MissingContentOfferException(string message, Exception inner) : base(message, inner) {}
    }

    #endregion

    public enum WorkType : uint
    {
        None = 0,
        XLAST = 1,
        Content = 2,
        ContentAndOffer = 3,
        ContentAnd2Offers = 4,
        OfferOnly = 5
    }

    /// <summary>
    /// Contains a list of files and the associated work type for a submission job.
    /// </summary>
    public class FileGroup
    {
        private WorkType _workType;
        private ArrayList _files;

        public FileGroup(WorkType workType)
        {
            _workType = workType;
            _files = new ArrayList();
        }

        public ArrayList Files
        {
            get { return _files; }
        }

        public WorkType WorkType
        {
            get { return _workType; }
        }
    }

	/// <summary>
	/// Summary description for FileGrouping.
	/// </summary>
    public class FileGrouping
    {
        private static Regex rgPropResults = new Regex(@"propresults_(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{3})\.txt", RegexOptions.IgnoreCase);

        /// <summary>
        /// Return true if the file list contains at least one XLAST files
        /// </summary>
        /// <param name="files"></param>
        /// <returns></returns>
        private static bool HasXlast(ArrayList files)
        {
            foreach(string file in files)
            {
                if(Path.GetExtension(file).ToLower() == ".xlast")
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Return true if the file list contains at least one CAB files
        /// </summary>
        /// <param name="files"></param>
        /// <returns></returns>
        private static bool HasCab(ArrayList files)
        {
            foreach(string file in files)
            {
                if(Path.GetExtension(file).ToLower() == ".cab")
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Return true if the file list contains at least one OFFER files
        /// </summary>
        /// <param name="files"></param>
        /// <returns></returns>
        private static bool HasOffer(ArrayList files)
        {
            foreach(string file in files)
            {
                if(Path.GetExtension(file).ToLower() == ".offer")
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Parses a datetime out of a propresults file name.
        /// </summary>
        /// <param name="file"></param>
        /// <returns></returns>
        public static DateTime GetPropResultsTime(string file)
        {
            DateTime dt = DateTime.MinValue;
            Match m = rgPropResults.Match(file);
            if(m.Success)
            {
                try
                {
                    dt = new DateTime(
                        Int32.Parse(file.Substring(m.Groups[1].Index, m.Groups[1].Length)),
                        Int32.Parse(file.Substring(m.Groups[2].Index, m.Groups[2].Length)),
                        Int32.Parse(file.Substring(m.Groups[3].Index, m.Groups[3].Length)),
                        Int32.Parse(file.Substring(m.Groups[4].Index, m.Groups[4].Length)),
                        Int32.Parse(file.Substring(m.Groups[5].Index, m.Groups[5].Length)),
                        Int32.Parse(file.Substring(m.Groups[6].Index, m.Groups[6].Length)),
                        Int32.Parse(file.Substring(m.Groups[7].Index, m.Groups[7].Length)));
                }
                catch(Exception)
                {
                    //  If the name doesn't parse out to valid datetime, just
                    //  ignore the file and continue.
                }
            }

            return dt;
        }

        /// <summary>
        /// Return the most recent prop results file in the list of files.  Removes all other
        /// prop results files found from the list.
        /// </summary>
        /// <param name="files"></param>
        /// <returns>Array of strings.  Returns an array of length 0 if no offers found.</returns>
        private static string GetLatestPropResults(ArrayList files)
        {
            string latestPropResultsFile = null;
            DateTime dtMostRecent = DateTime.MinValue;
            
            foreach(string file in files)
            {
                DateTime dtCur = GetPropResultsTime(file);
                if(dtCur == DateTime.MinValue)
                    continue;

                if(dtCur > dtMostRecent)
                {
                    latestPropResultsFile = file;
                    dtMostRecent = dtCur;
                }
            }

            return latestPropResultsFile;
        }

        /// <summary>
        /// Return an array containing only .offer files.
        /// </summary>
        /// <param name="files"></param>
        /// <returns>Array of strings.  Returns an array of length 0 if no offers found.</returns>
        private static ArrayList GetOffers(ArrayList files)
        {
            ArrayList offers = new ArrayList();

            foreach(string file in files)
            {
                if(Path.GetExtension(file).ToLower() == ".offer")
                    offers.Add(file);
            }

            return offers;
        }

        /// <summary>
        /// Return an array containing only .xlast files.
        /// </summary>
        /// <param name="files"></param>
        /// <returns>Array of strings.  Returns an array of length 0 if no offers found.</returns>
        private static ArrayList GetXlasts(ArrayList files)
        {
            ArrayList xlasts = new ArrayList();

            foreach(string file in files)
            {
                if(Path.GetExtension(file).ToLower() == ".xlast")
                    xlasts.Add(file);
            }

            return xlasts;
        }

        /// <summary>
        /// Return an array containing only .offer files.
        /// </summary>
        /// <param name="files"></param>
        /// <returns>Array of strings.  Returns an array of length 0 if no offers found.</returns>
        private static ArrayList GetCABs(ArrayList files)
        {
            ArrayList cabs = new ArrayList();

            foreach(string file in files)
            {
                if(Path.GetExtension(file).ToLower() == ".cab")
                    cabs.Add(file);
            }

            return cabs;
        }

        /// <summary>
        /// Return the content type from an offer.  Throws an exception if multiple
        /// content types found.
        /// </summary>
        /// <param name="lo"></param>
        /// <returns></returns>
        private static ContentOfferType GetContentTypeFromOffer(LiveOffer lo)
        {
            if(lo == null)
                throw new ArgumentException("Null offer passed into GetOfferTypeFromOffer", "lo");

            if(lo.contentOfferCollection == null || lo.contentOfferCollection.Count == 0)
                throw new MissingContentOfferException();

            ContentOfferType type = lo.contentOfferCollection[0].contentOfferType;

            foreach(ContentOffer co in lo.contentOfferCollection)
            {
                if(type != co.contentOfferType)
                    throw new MultipleContentTypesInOfferException();
            }

            return type;
        }

        /// <summary>
        /// Given the name of an offer file, parse the offer file
        /// and retrieve the name of the associated cab file.
        /// </summary>
        /// <param name="offerFile"></param>
        /// <returns></returns>
        private static string GetCabFromOffer(LiveOffer lo)
        {
            if(lo == null)
                throw new ArgumentException("Null offer passed into GetCabFromOffer", "lo");

            ContentOffer co = lo.contentOfferCollection[0];
            return co.contentCAB;
        }

        /// <summary>
        /// For trailers and videos only.  Find the offer in the files collection
        /// that 'matches' the offer passed in.  In this case, matching means
        /// they point to the same CAB, but have different offer ids.
        /// </summary>
        /// <param name="lo"></param>
        /// <param name="files"></param>
        /// <returns></returns>
        private static string GetMatchingOffer(LiveOffer lo, ArrayList files)
        {
            if( lo == null ||
                lo.contentOfferCollection == null || 
                lo.contentOfferCollection.Count == 0 ||
                files == null ||
                files.Count == 0 )
                return null;

            ContentOffer co = lo.contentOfferCollection[0];

            foreach(string file in files)
            {
                if(Path.GetExtension(file).ToLower() != ".offer")
                    continue;

                LiveOffer loCur = OfferUtil.LoadOffer(file);
                if(loCur == null || loCur.contentOfferCollection == null || loCur.contentOfferCollection.Count == 0)
                    continue;

                ContentOffer coCur = loCur.contentOfferCollection[0];
                if( coCur.contentCAB == co.contentCAB &&
                    coCur.offerBasicInfo.offerID != co.offerBasicInfo.offerID )
                {
                    return file;
                }
            }

            return null;
        }

        /// <summary>
        /// Given the name of an offer file, parse the offer file
        /// and retrieve all PNGs referenced in the file.  Images
        /// are referenced in two places:  TitleCultureDetails and
        /// OfferCultureDetails.
        /// </summary>
        /// <param name="offerFile"></param>
        /// <returns></returns>
        private static ArrayList GetPngsFromOffer(LiveOffer lo)
        {
            if(lo == null)
                throw new ArgumentException("Null offer passed into GetPngsFromOffer", "lo");

            ArrayList images = new ArrayList();

            if(lo != null)
            {
                if(lo.titleCollection != null)
                {
                    foreach(Title t in lo.titleCollection)
                    {
                        if(t.titleCultureDetailsCollection != null)
                        {
                            foreach(TitleCultureDetails details in t.titleCultureDetailsCollection)
                            {
                                if(!images.Contains(details.imageFilePath))
                                    images.Add(details.imageFilePath);
                            }
                        }
                    }
                }

                if(lo.contentOfferCollection != null)
                {
                    foreach(ContentOffer co in lo.contentOfferCollection)
                    {
                        if(co.offerBasicInfo == null)
                            continue;

                        if(co.offerBasicInfo.offerCultureDetailsCollection != null)
                        {
                            foreach(OfferCultureDetails details in co.offerBasicInfo.offerCultureDetailsCollection)
                            {
                                if(!images.Contains(details.imageFilePath))
                                    images.Add(details.imageFilePath);
                            }
                        }
                    }
                }
            }

            return images;
        }

        /// <summary>
        /// Given the name of an XLAST file, parse the xlast file and
        /// retrieve all PNGs and BINs referenced in the file.
        /// </summary>
        /// <param name="xlastFile"></param>
        /// <returns></returns>
        private static ArrayList GetFilesToPropFromXlast(string xlastFile)
        {
            TextReader xlastReader = new StreamReader(xlastFile);
            string xlastXml = xlastReader.ReadToEnd();
            xlastReader.Close();

            ArrayList fileList = new ArrayList();

            XboxLiveSubmissionProject xlastProj = XlastUtil.GetXlastFromXml(xlastXml);

            // add all Images from the Images info
            Images images = xlastProj.GameConfigProject.Images;
            if ((images != null) && (images.Image != null))
            {
                foreach (Image i in images.Image)
                {
                    string fileName = Path.GetFileName(i.Path);
                    if (fileName.Length == 0)
                        continue;

                    fileList.Add(fileName);
                }
            }

            AvatarItems avatarItems = xlastProj.GameConfigProject.AvatarItems;
            if ((avatarItems != null) && (avatarItems.AvatarItem != null))
            {
                // add the bin, acp and png files from the AvatarItems info
                foreach (XboxLiveSubmissionProjectGameConfigProjectAvatarItemsAvatarItem avatarItem in avatarItems.AvatarItem)
                {
                    // adding bin, acp and 128x128 png for avatar item 1
                    if (avatarItem.guid1 != Guid.Empty)
                    {
                        fileList.Add(avatarItem.guid1.ToString("D") + ".bin");
                        fileList.Add(avatarItem.guid1.ToString("D") + ".acp");
                        fileList.Add(avatarItem.guid1.ToString("D") + ".png");
                    }

                    // adding bin, acp and 128x128 png for avatar item 2
                    if (avatarItem.guid2 != Guid.Empty)
                    {
                        fileList.Add(avatarItem.guid2.ToString("D") + ".bin");
                        fileList.Add(avatarItem.guid2.ToString("D") + ".acp");
                        fileList.Add(avatarItem.guid2.ToString("D") + ".png");
                    }
                }
            }

            return fileList;
        }

        /// <summary>
        /// Group a collection of files into individual submission jobs.
        /// </summary>
        /// <param name="files">List of files to be grouped.  Each item in this
        /// array should be a full path to a file.</param>
        public static ArrayList GroupFiles(ArrayList files, PropResultsWriter writer)
        {
            IEnumerator fileEnum;
            WorkType workType = WorkType.None;

            if(files == null || files.Count == 0)
                throw new ArgumentException("Empty file list passed into FileGrouping.GroupFiles.", "files");
            if(writer == null)
                throw new ArgumentException("PropResultsWriter parameter cannot be null.", "writer");

            //  Convert all files in list to lower case.

            for(int curFileIndex = 0; curFileIndex < files.Count; ++curFileIndex)
                files[curFileIndex] = ((string)files[curFileIndex]).ToLower();

            ArrayList groups = new ArrayList();

            //  Error case - group cannot contain both XLAST and CAB files.

            if(HasXlast(files) && HasCab(files))
            {
                ArrayList badFiles = new ArrayList();
                badFiles.AddRange(GetCABs(files));
                badFiles.AddRange(GetXlasts(files));

                writer.AddResult(
                    badFiles,
                    "Game configuration and Content cannot be submitted at the same time.",
                    PropResult.PropResultType.INVALIDGROUPING);
            }

            //  Find any prop results file.  If found, remove any previously successfully
            //  propped files from the list.
            
            string propResultsFile = GetLatestPropResults(files);
            if(propResultsFile != null)
            {
                PropResultsReader reader;

                try
                {
                    reader = new PropResultsReader(propResultsFile);
                }
                catch(Exception e)
                {
                    //  Error loading the prop results file may mask other issues, or cause jobs to
                    //  be propped unintentionally if we overlook the failure.  Re-cast the exception and throw.
                    throw new ApplicationException(string.Format("The most recent prop results file {0} could not be loaded.  Failing this bug.", propResultsFile), e);
                }

                if(reader.Results.Count != 0)
                {
                    foreach(PropResult r in reader.Results)
                    {
                        if( r.Result == PropResult.PropResultType.SUCCESS ||
                            r.Result == PropResult.PropResultType.SKIPPED )
                        {
                            // 1. Remove all non-PNG files in this result from the current list of files
                            fileEnum = files.GetEnumerator();
                            while(fileEnum.MoveNext())
                            {
                                string file = (string)fileEnum.Current;

                                if( Path.GetExtension(file).ToLower() != ".png" &&
                                    r.Files.Contains(Path.GetFileName(file).ToLower()))
                                {
                                    files.Remove(file);
                                    fileEnum = files.GetEnumerator();
                                    fileEnum.Reset();
                                }
                            }

                            // 2. Add a 'SKIPPED' result to the current prop results
                            writer.AddResult(r.Files, null, PropResult.PropResultType.SKIPPED);
                        }
                    }
                }
            }

            //  Process all offer files

            ArrayList offerFiles = GetOffers(files);
            fileEnum = offerFiles.GetEnumerator();
            while(fileEnum.MoveNext())
            {
                try
                {
                    ArrayList groupedFiles = new ArrayList();

                    string offerFile =(string)fileEnum.Current;
                    groupedFiles.Add(offerFile);
                    offerFiles.Remove(offerFile);
                    files.Remove(offerFile);

                    LiveOffer lo = null;
                    try
                    {
                        lo = OfferUtil.LoadOffer(offerFile);
                    }
                    catch (InvalidOperationException ex)
                    {
                        if( ex.InnerException is XmlSchemaValidationException)
                            throw new InvalidOfferFileException(offerFile, ex);
                    }
                    string matchingOffer = null;

                    //  If this is a trailer or video offer, we need to find the matching
                    //  offer file.  If not found, error out.

                    ContentOfferType offerType;
                    try
                    {
                        offerType = GetContentTypeFromOffer(lo);
                    }
                    catch(MissingContentOfferException)
                    {
                        writer.AddResult(
                            groupedFiles,
                            string.Format("Offer file {0} does not contain a content offer.", offerFile),
                            PropResult.PropResultType.INVALIDGROUPING);
                        continue;
                    }
                    catch(MultipleContentTypesInOfferException)
                    {
                        writer.AddResult(
                            groupedFiles,
                            string.Format("Offer file {0} contains multiple content types.", offerFile),
                            PropResult.PropResultType.INVALIDGROUPING);
                        continue;
                    }

                    if( offerType == ContentOfferType.GameTrailer ||
                        offerType == ContentOfferType.Video)
                    {
                        matchingOffer = GetMatchingOffer(lo, files);
                        if(matchingOffer != null)
                        {
                            offerFiles.Remove(matchingOffer);
                            files.Remove(matchingOffer);
                            groupedFiles.Add(matchingOffer);
                        }
                    }

                    string cabFile = GetCabFromOffer(lo);
                    if (cabFile != null)
                    {
                        if (Path.GetExtension(cabFile).ToLower() != ".cab")
                        {
                            writer.AddResult(
                                groupedFiles,
                                string.Format("The contentCAB element in offer file {0} contains a file whose extension is not .cab: {1}", offerFile, cabFile),
                                PropResult.PropResultType.INVALIDGROUPING);
                            continue;
                        }

                        cabFile = Path.Combine(Path.GetDirectoryName(offerFile), cabFile).ToLower();

                        //  Make sure the CAB file exists in the file list, and make
                        //  sure that it physically exists on the disk in the same 
                        //  directory as the offer file

                        if (!files.Contains(cabFile) || !File.Exists(cabFile))
                        {
                            writer.AddResult(
                                groupedFiles,
                                string.Format("Offer file {0} references CAB file {1} which was not found.", offerFile, cabFile),
                                PropResult.PropResultType.INVALIDGROUPING);
                            continue;
                        }

                        groupedFiles.Add(cabFile);
                        files.Remove(cabFile);
                        workType = (matchingOffer == null ? WorkType.ContentAndOffer : WorkType.ContentAnd2Offers);
                    }
                    else if (matchingOffer != null)
                    {
                        writer.AddResult(
                            groupedFiles,
                            string.Format("Two matching offer files ({0} and {1}) w/o CAB is not a valid grouping.", offerFile, matchingOffer),
                            PropResult.PropResultType.INVALIDGROUPING);
                        continue;
                    }
                    else
                    {
                        workType = WorkType.OfferOnly;
                    }

                    //  Make sure all PNG files exists in the file list, and make
                    //  sure that they physically exists on the disk in the same 
                    //  directory as the offer file

                    ArrayList pngFilesTemp = GetPngsFromOffer(lo);

                    bool offerGroupingFailed = false;
                    foreach(string pngFile in pngFilesTemp)
                    {
                        string pngFileFullPath = Path.Combine(Path.GetDirectoryName(offerFile), pngFile).ToLower();
                        if(!files.Contains(pngFileFullPath) || !File.Exists(pngFileFullPath))
                        {
                            writer.AddResult(
                                groupedFiles,
                                string.Format("Offer file {0} references PNG file {1} which was not found.", offerFile, pngFileFullPath),
                                PropResult.PropResultType.INVALIDGROUPING);
                            offerGroupingFailed = true;
                            break;
                        }

                        groupedFiles.Add(pngFileFullPath);
                    }

                    if(!offerGroupingFailed)
                    {
                        //  Construct the new group and add it to the groups collection

                        FileGroup group = new FileGroup(workType);
                        group.Files.AddRange(groupedFiles);

                        groups.Add(group);
                    }
                }
                finally
                {
                    fileEnum = offerFiles.GetEnumerator();
                }
            }

            //  Everything that's left over should be standalone CAB files or old prop results files.  Each
            //  CAB gets it's own group with no other files.

            foreach(string cabFile in GetCABs(files))
            {
                files.Remove(cabFile);

                FileGroup group = new FileGroup(WorkType.Content);
                group.Files.Add(cabFile);

                groups.Add(group);
            }

            //  Process XLAST files

            ArrayList xlastFiles = GetXlasts(files);
            if(xlastFiles.Count > 1)
            {
                writer.AddResult(
                    xlastFiles,
                    "Multiple XLAST files found in bug.",
                    PropResult.PropResultType.INVALIDGROUPING);

                foreach(string file in xlastFiles)
                {
                    files.Remove(file);
                }
            }
            else if(xlastFiles.Count != 0)
            {
                ArrayList groupedFiles = new ArrayList();

                string xlastFile = (string)(xlastFiles[0]);

                files.Remove(xlastFile);
                groupedFiles.Add(xlastFile);

                ArrayList filesTemp = GetFilesToPropFromXlast(xlastFile);

                bool xlastGroupingFailed = false;
                foreach(string fileTemp in filesTemp)
                {
                    string fileTempFullPath = Path.Combine(Path.GetDirectoryName(xlastFile), fileTemp).ToLower();
                    if (!files.Contains(fileTempFullPath) || !File.Exists(fileTempFullPath))
                    {
                        writer.AddResult(
                            groupedFiles,
                            string.Format("Xlast file {0} references file {1} which was not found.", xlastFile, fileTempFullPath),
                            PropResult.PropResultType.INVALIDGROUPING);
                        xlastGroupingFailed = true;
                        break;
                    }

                    groupedFiles.Add(fileTempFullPath);
                }

                if(!xlastGroupingFailed)
                {
                    //  Make sure all pngs are in file list

                    FileGroup group = new FileGroup(WorkType.XLAST);
                    group.Files.AddRange(groupedFiles);

                    groups.Add(group);
                }
            }

            //  Remove any PNG, BIN, ACP and PropResults files now.

            fileEnum = files.GetEnumerator();
            while(fileEnum.MoveNext())
            {
                string file = (string)fileEnum.Current;
                string fileExtension = Path.GetExtension(file).ToLower();
                if ((fileExtension == ".png") || (fileExtension == ".bin") || (fileExtension == ".acp"))
                {
                    files.Remove(file);
                    fileEnum = files.GetEnumerator();
                    continue;
                }

                Match m = rgPropResults.Match(file);
                if(m.Success)
                {
                    files.Remove(file);
                    fileEnum = files.GetEnumerator();
                    continue;
                }
            }

            //  At this point if there's anything left in files it's an error
            if(files.Count != 0)
            {
                writer.AddResult(files, null, PropResult.PropResultType.INVALIDGROUPING);
                groups = null;
            }

            return groups;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\AdWalk\Program.cs ===
using System;
using System.DirectoryServices;
using System.IO;
using System.Text;

namespace AdWalkProgram
{
    class ActiveDirectoryWalker
    {
        void WriteEntry(string cn, int currentLevel, string attrs, int indent, string additionalInfo)
        {
            try
            {
                // Skip objects in the Hidden Address Book
                if (cn.Contains("OU=HABObjects"))
                        return;

                DirectoryEntry entry = new DirectoryEntry("LDAP://" + cn);

#if NOTDEFINED

                // This debugging code is useful for dumping all properties of
                // an object in order to find the right one to dump.
                if (null == entry.Properties[attrs].Value)
                {
                    PropertyCollection properties = entry.Properties;

                    foreach (PropertyValueCollection propertyValues in properties)
                    {
                        Console.WriteLine(propertyValues.PropertyName);

                        foreach (object v in propertyValues)
                            Console.WriteLine("\t{0}", v);
                    }
                }

#endif // NOTDEFINED

				if (typeof(System.Byte[]) == entry.Properties[attrs].Value.GetType())
				{
					using (FileStream fs = new FileStream(String.Format("{0}.jpg", entry.Properties["mailNickname"].Value), FileMode.CreateNew))
					{
						System.Byte[] t = entry.Properties[attrs].Value as System.Byte[];
//						Console.WriteLine("{0}", (System.BitConverter.ToString(t)));
						fs.Write(t, 0, t.Length);
					}
				}
				else
				{
					Console.WriteLine("{2}{0}\t{1}", entry.Properties[attrs].Value, additionalInfo, "".PadRight(currentLevel * indent, ' '));
				}
            }
            catch (Exception e)
            {
                if (OutputDebug)
                {
                    Console.WriteLine("Unhandled exception in WriteEntry for cn \"{0}\":", cn);
                    Console.WriteLine(e.ToString());
                }
            }
        }   // WriteEntry


        void WriteEntries(string cn, int currentLevel, int maxLevel, string linkAttr, string attrs, int indent, string additionalInfo)
        {
            try
            {
                if (currentLevel <= maxLevel)
                {
                    WriteEntry(cn, currentLevel, attrs, indent, additionalInfo);

                    // Skip objects in the Hidden Address Book
                    if (cn.Contains("OU=HABObjects"))
                        return;

                    DirectoryEntry entry = new DirectoryEntry("LDAP://" + cn);

                    PropertyValueCollection pvc = entry.Properties[linkAttr];

                    foreach (string v in pvc)
                    {
                        WriteEntries(v, currentLevel + 1, maxLevel, linkAttr, attrs, indent, additionalInfo);
                    }
                }
            }
            catch (Exception e)
            {
                if (OutputDebug)
                {
                    Console.WriteLine("Unhandled exception in WriteEntries for cn \"{0}\":", cn);
                    Console.WriteLine(e.ToString());
                }
            }
        }   // WriteEntries


        internal void ExecuteCommand()
        {
            if (true == NeedHelp)
                ShowUsage();
            else
                WriteEntries(cn, 0 /* currentLevel */, maxLevels, linkAttr, attrs, indent, additionalInfo);
        }   // ExecuteCommand


        internal void ParseCommandLine(string[] args)
        {
            try
            {
                // Walk over the given args
                for (int i = 0; i < args.Length; i++)
                {
                    String arg = args[i].ToString();

                    // Is this is an internal parameter?
                    if (arg.Length > 0 && ('-' == arg[0] || '/' == arg[0]))
                    {
                        // Remove the dash or slash
                        arg = arg.Remove(0, 1);

                        switch (arg.ToLower())
                        {
                            case "additionalinfo":
                                i++;    // Move to the next arg

                                // Make sure there's another arg to get
                                if (args.Length <= i)
                                    throw new ApplicationException("Additional info to write was not specified.");

                                additionalInfo = args[i].ToString();

                                break;

                            case "attrs":
                                i++;    // Move to the next arg

                                // TODO: Should be array

                                // Make sure there's another arg to get
                                if (args.Length <= i)
                                    throw new ApplicationException("Attribute to write were not specified.");

                                attrs = args[i].ToString();

                                break;

                            case "cn":
                                i++;    // Move to the next arg

                                // Make sure there's another arg to get
                                if (args.Length <= i)
                                    throw new ApplicationException("Root entry name not specified.");

                                cn = args[i].ToString();

                                break;

                            case "help":
                            case "?":
                                NeedHelp = true;
                                break;

                            case "indent":
                                i++;    // Move to the next arg

                                // Make sure there's another arg to get
                                if (args.Length <= i)
                                    throw new ApplicationException("Number of spaces to indent was not specified.");

                                indent = Int32.Parse(args[i].ToString());

                                break;

                            case "linkattr":
                                i++;    // Move to the next arg

                                // Make sure there's another arg to get
                                if (args.Length <= i)
                                    throw new ApplicationException("Attribute to link entries not specified.");

                                linkAttr = args[i].ToString();

                                break;

                            case "maxlevels":
                                i++;    // Move to the next arg

                                // Make sure there's another arg to get
                                if (args.Length <= i)
                                    throw new ApplicationException("Max levels not specified.");

                                maxLevels = Int32.Parse(args[i].ToString());

                                break;

                            case "outputdebug":
                                OutputDebug = true;
                                break;

                            default:
                                throw new ApplicationException(String.Format("Unrecognized argument (\"{0}\").", args[i]));
                        }
                    }
                    else
                    {
                        throw new ApplicationException(String.Format("Unrecognized argument (\"{0}\").", arg));
                    }
                }
            }
            catch (ApplicationException)
            {
                // The exception info will be dumped by the caller's catch
                // block, but we want to display the usage info since we
                // failed to parse the command line.
                ShowUsage();

                throw;
            }
        }   // ParseCommandLine


        private void ShowUsage()
        {
            Console.WriteLine("{0} <options>", ProgramName);
            Console.WriteLine("  where options are:");
            Console.WriteLine("  -cn <RootObject> (Required)");
            Console.WriteLine("  -linkAttr <AttributeToFollow> (Required)");
            Console.WriteLine("  -attrs <AttributesToWrite> (Required, Separated by commas) (Currently only 1 attribute is allowed, not a list)");
            Console.WriteLine("  -additionalInfo <StringToAppendToEachLineWritten>");
            Console.WriteLine("  -indent <NumberOfSpacesToIndentEachChild> (Default={0})", DefaultSpacesToIndent);
            Console.WriteLine("  -maxLevels <NumberOfChildLevelsToFollow> (Default={0})", DefaultMaxLevels);
            Console.WriteLine("  -outputDebug (Default={0})", DefaultOutputDebug);
            Console.WriteLine("Examples:");
            Console.WriteLine("  {0} -cn \"CN=Vince Curley,OU=UserAccounts,DC=redmond,DC=corp,DC=microsoft,DC=com\" -maxLevels 99 -linkAttr directReports -attrs mailNickname -additionalInfo \"dev CGTriad\" -indent 2", ProgramName);
            Console.WriteLine("  {0} -cn \"CN=Xenon OS,OU=UserAccounts,DC=redmond,DC=corp,DC=microsoft,DC=com\" -maxLevels 99 -linkAttr member -attrs mailNickname -indent 2", ProgramName);
            Console.WriteLine("Use dsquery from the Windows Resource Kit to see what attributes are available.");
            Console.WriteLine("  For example, to see the attributes on a user:");
            Console.WriteLine("  dsquery user -samid vincec");
            Console.WriteLine("  dsquery * \"CN=Vince Curley,OU=UserAccounts,DC=redmond,DC=corp,DC=microsoft,DC=com\" -attr * -scope base");
        }   // ShowUsage


        private static void WriteError(string str)
        {
            // This text cannot be localized or the build tools won't know
            // how to recognize warnings and errors.  White-space is also
            // important.
            Console.WriteLine(String.Format(
                "{0} : error : {1}",
                ProgramName,
                str));
        }   // WriteError


        /// <summary>
        /// Write the exception message and the messages for any inner exceptions to the console.
        /// </summary>
        /// <param name="ex">The exception whose info to write</param>
        private static void WriteExceptionInfoToConsole(Exception ex)
        {
            while (null != ex)
            {
                WriteError(ex.Message);
                ex = ex.InnerException;
            }
        }   // WriteExceptionInfoToConsole


        internal bool NeedHelp { get; set; }
        internal bool OutputDebug { get; set; }


        //
        // Constant
        //

        private const int DefaultMaxLevels = 99;
        private const int DefaultSpacesToIndent = 2;
        private const string ProgramName = "ADWalk";
        private const bool DefaultOutputDebug = true;

        //
        // Data members
        //

        private string      cn;
        private int         maxLevels;
        private string      linkAttr;
        private string      attrs;   // TODO: Should be array
        private string      additionalInfo;
        private int         indent;


        static void Main(string[] args)
        {
//            ArrayList   args = new ArrayList(argStrings);
            ActiveDirectoryWalker adWalk = new ActiveDirectoryWalker();

            try
            {
                adWalk.NeedHelp = false;
                adWalk.OutputDebug = DefaultOutputDebug;

                adWalk.ParseCommandLine(args);

                if (0 == args.Length)
                {
                    // Show usage
                    adWalk.ShowUsage();

//                    Environment.ExitCode = (int)AdWalkExitCode.BadUsage;
                }
                else
                {
                    adWalk.ExecuteCommand();

//                    Environment.ExitCode = (int)adWalk.ExitCode;
                }
            }
            catch (Exception ex)
            {
                WriteExceptionInfoToConsole(ex);

                if (true == adWalk.OutputDebug)
                {
#if DEBUG
                    Console.WriteLine();
                    Console.WriteLine("Debug spew (not displayed to the public, but handy for bug reports):");
                    Console.WriteLine(ex.ToString());
#endif  // DEBUG
                }

//                Environment.ExitCode = (int)AdWalkExitCode.FatalError;
            }


#if NOTDEFINED

            // TESTING
            cn = "CN=Tian Lim,OU=UserAccounts,DC=redmond,DC=corp,DC=microsoft,DC=com";
            maxLevels = 1;
            linkAttr = "directReports";
            attrs = "mailNickname";   // TODO: Should be array
            additionalInfo = "dev\tAllTriads";
            indent = 2;

            WriteEntries(cn, 0 /* currentLevel */, maxLevels, linkAttr, attrs, indent, additionalInfo);

            // TESTING
            cn = "CN=Vince Curley,OU=UserAccounts,DC=redmond,DC=corp,DC=microsoft,DC=com";
            maxLevels = 99;
            linkAttr = "directReports";
            attrs = "mailNickname";   // TODO: Should be array
            additionalInfo = "dev\tCGTriad";
            indent = 2;

            WriteEntries(cn, 0 /* currentLevel */, maxLevels, linkAttr, attrs, indent, additionalInfo);

            Console.WriteLine();

            // TESTING
            cn = "CN=Xbox Live Dev FTE,OU=Distribution Lists,DC=redmond,DC=corp,DC=microsoft,DC=com";
            maxLevels = 99;
            linkAttr = "memberOf";
            attrs = "mailNickname";   // TODO: Should be array
            additionalInfo = "";
            indent = 2;

//            WriteEntries(cn, 0 /* currentLevel */, maxLevels, linkAttr, attrs, indent, additionalInfo);

            Console.WriteLine();

            // TESTING
            cn = "CN=Xbox Live Dev FTE,OU=Distribution Lists,DC=redmond,DC=corp,DC=microsoft,DC=com";
            maxLevels = 99;
            linkAttr = "member";
            attrs = "mailNickname";   // TODO: Should be array
            additionalInfo = "";
            indent = 2;

            WriteEntries(cn, 0 /* currentLevel */, maxLevels, linkAttr, attrs, indent, additionalInfo);

#endif // NOTDEFINED

            return;
        }   // main
    }   // class ActiveDirectoryWalker
}   // namespace AdWalkProgram
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\APDispatcher\FileUploader.cs ===
using System;
using System.Diagnostics;
using System.IO;
using System.Text;

namespace xonline.tools.APDispatcher
{
    /// <summary>
    /// Uploads a directory of files using the scp2.exe secure shell client.
    /// This class assumes that scp2.exe is in the path, and will fail out if not found.
    /// Command line reference:
    /// 
    ///     scp2 -p -r -Q -k [keydir] [src] LiveTransferUser@[ip]:[rdst]
    /// 
    ///     -u      Remove source files after copying
    ///     -p      Preserver file timestamps
    ///     -r      Recurse subdirectories
    ///     -Q      Hide progress indicator
    ///     -k      [keydir] Is the directory containing hostkeys and userkeys
    ///     [src]   Local file to upload
    ///     [ip]    IP address of server
    ///     [rdst]  Destination folder name
    ///     
    /// </summary>
    public class FileUploader
    {
        private const string SCP2     = "scp2.exe";
        private const string SCP2ARGS = "-u -p -r -Q -k {0} {1} LiveTransferUser@{2}:{3}";

        private string _keyDir          = @"c:\ssh2";
        private string _uploadServer    = null;

        #region Properties

        public string KeyDirectory
        {
            get { return _keyDir; }
            set { _keyDir = value; }
        }

        public string UploadServer
        {
            get { return _uploadServer; }
            set { _uploadServer = value; }
        }

        #endregion

        public FileUploader(string uploadServer)
        {
            _uploadServer = uploadServer;
        }

        public FileUploader(string uploadServer, string keyDir) : this(uploadServer)
        {
            _keyDir = keyDir;
        }

        public int UploadFiles(string srcDir, string destDir, ref string output)
        {
            string [] uploadParams = new string [] { _keyDir, srcDir, _uploadServer, destDir };
            string args = string.Format(SCP2ARGS, uploadParams);

            return RunCommandLine(SCP2, args, ref output);
        }
    
        private static int RunCommandLine(string file, string args, ref string output)
        {
            Process p = new Process();
            p.StartInfo.FileName = file;
            p.StartInfo.Arguments = args;
            p.StartInfo.CreateNoWindow = true;
            p.StartInfo.UseShellExecute = false;
            p.StartInfo.RedirectStandardOutput = true;
            p.StartInfo.RedirectStandardError = true;
            p.Start();

            output = p.StandardOutput.ReadToEnd();
            output += p.StandardError.ReadToEnd();

            p.WaitForExit();

            return p.ExitCode;           
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\APDispatcher\AutoPropBug.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Security.Principal;
using System.Text;
using System.Threading;
using System.Net.Mail;
using System.Xml;
using ProductStudio;

namespace xonline.tools.APDispatcher
{
    /* ========================================================================
     * CLASS: AutopropBug
     * ========================================================================
     * Class to consolidate the handling of a product studio bug, including the
     * process of updating the PS information and communicating with the
     * webservice
     *
    */
    class AutopropBug
    {
        DatastoreItem       bug;
        public XDSData      xdsData;

        string              stagingDir;

        ArrayList           uploadGroups;

        PropResultsWriter   propResultsWriter;

        const int           POLLING_INTERVAL = 1000;
        const int           MAX_POLL_TIME = -1;

        /* AutopropBug (constructor)
         * ------------------------------------
         * Actually quite a lot of work is done here in order to simplify the
         * caller's logic.
         
         * 1) The PS DatastoreItem is referenced for any later actions 
         * 2) The comment history is parsed to extract XDS provided info
         * 3) The attached files are analyzed and a list of their extensions saved
         *
         * Parameters:  
         *
         *
        */
        public AutopropBug(DatastoreItem item)
        {
            bug                 = item;
            propResultsWriter   = new PropResultsWriter();


            bug.Edit(PsItemEditActionEnum.psDatastoreItemEditActionReadOnly, null, PsApplyRulesMask.psApplyRulesAll);

            //---------------------------------------------------------
            // Initialize an XDSData object with the original 
            // description text to have it parsed and available for 
            // our validation logic, etc
            //
            xdsData = new XDSData(bug);


            //---------------------------------------------------------
            // Create a directory for this bug under the working 
            // directory
            //
            stagingDir = System.IO.Directory.GetCurrentDirectory() + "\\" + BugID.ToString();

            if (System.IO.Directory.Exists(stagingDir))
                System.IO.Directory.Delete(stagingDir, true);

            System.IO.Directory.CreateDirectory(stagingDir);

            bug.Reset(true);
        }

        ~AutopropBug()
        {
            FreeResources();
        }



        public int BugID
        {
            get { return (bug == null) ? 0 : (int) bug.Fields["ID"].Value; }
        }

        public String Title
        {
            get { return (bug == null) ? "<null>" : (string) bug.Fields["Title"].Value; }
        }
        



        public bool AutoProp(ToolsMgmt service, string uploadServer)
        {
            string apState  = "Failed";
            string apStatus = "";
            string apDesc   = "An unknown failure path was encountered";

            try
            {
                bool anyFailed = false;

                foreach(FileGroup group in uploadGroups)
                {
                    StringBuilder groupOutput = new StringBuilder();
                    PropResult.PropResultType propResult = PropResult.PropResultType.PROPFAILED;

                    try
                    {
                        groupOutput.Append("-------------------------------------------------------------------------------\r\n");
                        groupOutput.Append("WorkType: ");
                        switch(group.WorkType)
                        {
                            case WorkType.XLAST:
                                groupOutput.Append("XLAST+PNGs\r\n");
                                break;
                            case WorkType.Content:
                                groupOutput.Append("CAB\r\n");
                                break;
                            case WorkType.ContentAndOffer:
                                groupOutput.Append("CAB+Offer\r\n");
                                break;
                            case WorkType.ContentAnd2Offers:
                                groupOutput.Append("CAB+2 Offers\r\n");
                                break;
                            case WorkType.OfferOnly:
                                groupOutput.Append("Offer+PNGs\r\n");
                                break;
                        }
                        groupOutput.Append("Files:\r\n");
                        foreach(string file in group.Files)
                        {
                            groupOutput.Append("\t" + file + "\r\n");
                        }
                        groupOutput.Append("-------------------------------------------------------------------------------\r\n");

                        BeginWorkResult res = CallBeginWork(service, group.WorkType);
    
                        if(!OkToContinue())
                        {
                            groupOutput.Append("  > This bug has been terminated by manual action in Product Studio.\r\n");
                            return false;
                        }

                        groupOutput.Append("  > Created workitem: " + res.workId + "\r\n");
                    
                        //
                        //  Verify that there is enough space to upload all the files
                        //

                        ulong totalUploadSize = 0;
                        foreach(string file in group.Files)
                        {
                            FileInfo fi = new FileInfo(file);

                            totalUploadSize += (ulong)fi.Length;
                        }

                        if(totalUploadSize > res.spaceAvailable)
                        {
                            groupOutput.Append("  > Not enough space on server to upload files.\r\n");
                            return false;
                        }

                        //
                        //  Begin uploading files.  We want to make just a single call to scp2.exe
                        //  to upload an entire directory, so we just copy the files for this
                        //  job (not the entire bug) into a separate upload staging directory, and 
                        //  then push that directory up.
                        //

                        UpdateBug("Uploading", "WorkID: " + res.workId, null);
                
                        string uploadBaseDir = BugID.ToString() + "_" + res.workId.ToString();
                        string uploadStagingDir = Path.Combine(stagingDir, uploadBaseDir);
                        string dstRelativeDir = @"autoprop\" + uploadBaseDir;

                        if(!System.IO.Directory.Exists(uploadStagingDir))
                            System.IO.Directory.CreateDirectory(uploadStagingDir);

                        foreach(string fspec in group.Files)
                        {
                            groupOutput.Append("  > Copying file:   " + fspec + "\r\n");
                        
                            System.IO.File.Copy(fspec, Path.Combine(uploadStagingDir, Path.GetFileName(fspec)), true);
                        }
    
                        string output = "";

                        groupOutput.Append("  > Uploading all files.\r\n");

                        FileUploader uploader = new FileUploader(uploadServer);
                        if(uploader.UploadFiles(uploadStagingDir, "autoprop", ref output) != 0)
                        {
                            groupOutput.Append("  > Upload FAILED.  Output follows:\r\n" + output + "\r\n");
                            return false;
                        }
 
                        //
                        //  We're done uploading.  Check the bug to make sure it's still ok to continue.
                        //  If it is, tell wctoolsmgmt to beging processing files.
                        //

                        if(!OkToContinue())
                        {
                            groupOutput.Append("  > This bug has been terminated by manual action in Product Studio.\r\n");
                            return false;
                        }

                        UpdateBug("Processing", null, null);

                        groupOutput.Append("  > Calling WorkFilesReady.\r\n");
                        CallWorkFilesReady(service, res.workId, dstRelativeDir);

                        //
                        //  Now we need to poll wctoolsmgmt for job completion status.
                        //  Include a timeout so we don't loop here indefinitely.
                        //

                        DateTime dtStart = DateTime.Now;

                        groupOutput.Append("  > Polling for results.");
                        Thread.Sleep(POLLING_INTERVAL);
                        groupOutput.Append(".");

                        GetWorkStatusResult wsRes = CallGetWorkStatus(service, res.workId);

                        //  [darrenan]  The commented expression below was generating a CS0429 warning, 
                        //  which the build was promoting to an error.  Since MAX_POLL_TIME is currently
                        //  set to -1, this is an acceptable change for Fall S01.  MAX_POLL_TIME
                        //  should really be coming from an app config file anyway, not hard coded.

                        while(!wsRes.workComplete /*&& (MAX_POLL_TIME == -1 ? true : MAX_POLL_TIME > (int)(((TimeSpan)(DateTime.Now - dtStart)).TotalMilliseconds))*/ )
                        {
                            Thread.Sleep(POLLING_INTERVAL);
                            groupOutput.Append(".");
                            wsRes = CallGetWorkStatus(service, res.workId);                        
                        }

                        if (wsRes.returnCode != 0)
                        {
                            groupOutput.Append("Autoprop failed!!!!  ***** ERROR: " + wsRes.returnCode + " *****\r\n" + wsRes.consoleOutput + "\r\n");
                            anyFailed = true;
                        }
                        else
                        {
                            groupOutput.Append("Autoprop completed successfully.\r\n" + wsRes.consoleOutput + "\r\n");
                            propResult = PropResult.PropResultType.SUCCESS;
                        }
                    }
                    catch(WebSvcException e)
                    {
                        groupOutput.Append("ERROR: WebService exception detected\r\n" + e.Message + "\r\n");
                        apState  = "Failed";
                        apStatus = "";
                        apDesc   = "Unexpected WebService exception encountered.";
                        throw;
                    }
                    catch(Exception e)
                    {
                        groupOutput.Append("ERROR: Unknown exception detected\r\n" + e.Message + "\r\n");
                        apState  = "Failed";
                        apStatus = "";
                        apDesc   = "Unexpected exception encountered.";
                        throw;
                    }
                    finally
                    {
                        propResultsWriter.AddResult(group.Files, groupOutput.ToString(), propResult);
                    }
                }

                //  Now update the state of the bug based on all the results that occurred.

                if(anyFailed)
                {
                    apState  = "Failed";
                    apStatus = "";
                    apDesc   = "One or more jobs failed.";
                }
                else
                {
                    apState  = "Completed";
                    apStatus = "Resolved";
                    apDesc   = "All jobs completed successfully.";
                }
            }
            catch(Exception)
            {
                // Swallow the exception here.  All the output has already
                // gone into propResultsWriter which will get saved and 
                // added to the bug in the finally block below.
            }
            finally
            {
                //  Save all prop results to text file, and add the file to the bug.
                //  The bug gets saved in the finally block below.

                AddResultsToBug();
                UpdateBug(apState, string.Format("{0}  See attached results file {1} for detailed information.", apDesc, Path.GetFileName(propResultsWriter.Filename)), apStatus);
            }

            return true;
        }

        public void AddResultsToBug()
        {
            string resultsFile = propResultsWriter.Save(stagingDir);
            AddFileToBug(resultsFile);
        }

        private void AddFileToBug(string file)
        {
            bug.Edit(PsItemEditActionEnum.psDatastoreItemEditActionEdit, null, PsApplyRulesMask.psApplyRulesAll);
            bug.Files.Add(file, false);
            bug.Save(true);
        }

        public void UpdateBug(string state, string desc, string resolve)
        {
            try
            {
                if (resolve == "Resolved")
                    bug.Edit(PsItemEditActionEnum.psBugEditActionResolve, null, PsApplyRulesMask.psApplyRulesMakeTrue);
                else if (resolve == "Closed")
                    bug.Edit(PsItemEditActionEnum.psBugEditActionClose, null, PsApplyRulesMask.psApplyRulesAll);
                else
                    bug.Edit(PsItemEditActionEnum.psDatastoreItemEditActionEdit, null, PsApplyRulesMask.psApplyRulesAll);

                if (state != null)
                    bug.Fields["Autoprop State"].Value = state;

                if (desc != null)
                    bug.Fields["Description"].Value = desc;
    
                if (resolve == "Resolved")
                {
                    bug.Fields["Fix Build"].Value     = "00.00.00.0000";
                    bug.Fields["Resolution"].Value    = "Fixed";
                    bug.Fields["Resolved By"].Value   = "xladmins";              // $REVIEW (michion): need another user to resolve by?
                }
    
                if (resolve == "Closed")
                {
                    bug.Fields["Fix Build"].Value     = "00.00.00.0000";
                    bug.Fields["Resolution"].Value    = "Fixed";
                    bug.Fields["Resolved By"].Value   = "xladmins";              // $REVIEW (michion): need another user to resolve by?
                }
    
                bug.Save(true);
            }
            catch (Exception e)
            {
                EventLog myLog = new EventLog();
                myLog.Log      = "Application";
                myLog.Source   = "APDispatcher";
    
                myLog.WriteEntry("ProductStudio exception: " + e.Message, EventLogEntryType.Error, 4);
            }
                    
            return;
        }
    
    
        public bool OkToContinue()
        {
            bug.Edit(PsItemEditActionEnum.psDatastoreItemEditActionReadOnly, null, PsApplyRulesMask.psApplyRulesAll);
            bug.Refresh();

            bool okToContinue = ((string)(bug.Fields["Autoprop State"].Value) != "Ignored");

            bug.Reset(true);

            return okToContinue;
        }

        BeginWorkResult CallBeginWork(ToolsMgmt service, WorkType workType)
        {
            try
            {
                BeginWorkInfo req = new BeginWorkInfo();
        
                req.workType = (uint)workType;
                req.titleId  = xdsData.TitleID;
        
                BeginWorkResult res = service.BeginWork( req );
        
                return res;
            }
            catch (Exception e)
            {
                throw new WebSvcException("CallBeginWork exception: " + e.Message);
            }
        }
    

        void CallWorkFilesReady(ToolsMgmt service, ulong workId, string relativePath)
        {
            try
            {
                WorkFilesReadyInfo req = new WorkFilesReadyInfo();

                req.workId = workId;
                req.relativePath = relativePath; // TODO

                WorkFilesReadyResult res = service.WorkFilesReady(req);
            }
            catch (Exception e)
            {
                throw new WebSvcException("CallWorkFilesReady exception: " + e.Message);
            }
        }

        GetWorkStatusResult CallGetWorkStatus(ToolsMgmt service, ulong workId)
        {
            try
            {
                GetWorkStatusInfo req = new GetWorkStatusInfo();

                req.workId = workId;

                GetWorkStatusResult res = service.GetWorkStatus(req);

                return res;
            }
            catch (Exception e)
            {
                throw new WebSvcException("CallWorkFilesReady exception: " + e.Message);
            }
        }

        public void RemoveReadonlyAttribute(string fileName)
        {
            System.IO.FileAttributes attributes = System.IO.File.GetAttributes(fileName);
            attributes &= ~System.IO.FileAttributes.ReadOnly;
            System.IO.File.SetAttributes(fileName, attributes);
        }
        
        public void ExtractFiles()
        {
            bug.Edit(PsItemEditActionEnum.psDatastoreItemEditActionReadOnly, null, PsApplyRulesMask.psApplyRulesAll);

            //---------------------------------------------------------
            // If this bug contains no files attached or folder links
            // then we're done.  Return an empty list and this bug
            // will be skipped.
            uploadGroups = new ArrayList();
            if(bug.Files.Count == 0)
                return;


            //---------------------------------------------------------
            // At this stage, we should already be commited to 
            // performing an autoprop on this bug so we need to 
            // extract the files from the bug and save them locally 
            // prior to uploading them to the toolsmgmt widget
            //
            foreach (ProductStudio.File fItem in bug.Files)
            {
                //  Does this item reference a single file, or a folder containing files?
                string itemFileName = fItem.FileName;

                if(Path.GetExtension(itemFileName) != null && Path.GetExtension(itemFileName).Length != 0)
                {
                    string file = Path.Combine(stagingDir, itemFileName);

                    uploadGroups.Add(file);
                    fItem.SaveToFile(file, true);
                    RemoveReadonlyAttribute(file);
                }
                else
                {
                    string [] files = System.IO.Directory.GetFiles(itemFileName, "*");
                    if(files.Length == 0)
                    {
                        Console.WriteLine(string.Format("WARNING:  Folder \"{0}\" referenced in bug {1} does not contain any files.", itemFileName, bug.ID.ToString()));
                        continue;
                    }

                    foreach(string file in files)
                    {
                        string fullFilePath = Path.Combine(stagingDir, Path.GetFileName(file));
                        uploadGroups.Add(fullFilePath);
                        System.IO.File.Copy(file, fullFilePath, true);
                        RemoveReadonlyAttribute(fullFilePath);
                    }
                }
            }

            bug.Reset(true);
            
            //----------------------------------------------------------
            //  We have extracted all files from the bug, now we are
            //  ready to group the files into submission jobs.
            //
            ArrayList fileList = new ArrayList();

            foreach(string file in System.IO.Directory.GetFiles(stagingDir, "*"))
            {
                fileList.Add(Path.Combine(stagingDir, file));
            }

            propResultsWriter = new PropResultsWriter();

            try
            {
                uploadGroups = null;
                uploadGroups = FileGrouping.GroupFiles(fileList, propResultsWriter);
            }
            catch(Exception e)
            {
                if (e is InvalidOfferFileException)
                {
                    String message = e.Message + ". " + e.InnerException.Message + " " + e.InnerException.InnerException.Message;
                    UpdateBug(null, message, null);
                }
                Console.WriteLine("ERROR:  " + e.Message);
            }
        }



        
        /* CanAutoprop
         * ------------------------------------
         * Method to determine if a bug meets the criteria necessary for 
         * autoprop
         *
        */
        public bool CanAutoprop()
        {
            //
            //  If any file groups failed, put a message in the bug and return false
            //

            bool hasInvalidGroups = false;
            foreach(PropResult result in propResultsWriter.Results)
            {
                if(result.Result == PropResult.PropResultType.INVALIDGROUPING)
                {
                    hasInvalidGroups = true;
                    break;
                }
            }
            
            if(hasInvalidGroups)
            {
                AddResultsToBug();
                UpdateBug("Failed", string.Format("One or more invalid file groups were found in this bug.  Please correct these and resubmit.\r\nDetails:\r\n{0}", propResultsWriter.FormatSummaryLines()), "");
                return false;
            }

            //
            //  If there are no attached files, or no groups that need processing, return false
            //

            if(uploadGroups == null || uploadGroups.Count == 0)
            {
                if(propResultsWriter.Results.Count == 0)
                {
                    UpdateBug("Ignored", "No files are attached or linked to this bug.  This bug is being ignored.", "");
                }
                else
                {
                    AddResultsToBug();
                    UpdateBug(
                        "Completed", 
                        string.Format("All attached files were propped successfully in a previous run.  If you wish to prop new versions of these files you must create a new autoprop bug.\r\nSee attached results file {0} for detailed information.", Path.GetFileName(propResultsWriter.Filename)) , 
                        "Resolved");
                }

                return false;
            }

            //
            //  If we can't determine the title id return false
            //

            if(xdsData.TitleID.Length == 0)
            {
                UpdateBug("Ignored", "Could not find title id in description or Title ID field.  This bug is being ignored.", "");
                return false;
            }

            return true;
        }



        public void FreeResources()
        {
            if (System.IO.Directory.Exists(stagingDir))
                System.IO.Directory.Delete(stagingDir, true);
        }



        public bool SendStatusEmail(string smtpHost)
        {
            if (xdsData.Contact.Length > 0)
            {
                try
                {
                    //
                    //  Get current user name sans domain
                    //

                    string userName = WindowsIdentity.GetCurrent().Name;
                    if(userName.IndexOf('@') != -1)
                    {
                        string [] a = userName.Split('@');
                        userName = a[0];
                    }
                    else if(userName.IndexOf('\\') != -1)
                    {
                        string [] a = userName.Split('\\');
                            userName = a[1];
                    }

                    //
                    //  Create new mail message
                    //

                    MailMessage msg = new MailMessage(new MailAddress(userName + "@microsoft.com"), new MailAddress(xdsData.Contact));
    
                    bool anyFailed = false;
                    foreach(PropResult pr in propResultsWriter.Results)
                    {
                        if(pr.Result != PropResult.PropResultType.SUCCESS)
                        {
                            anyFailed = true;
                            break;
                        }
                    }

                    msg.Subject = String.Format("Submission for title {0}: {1}", xdsData.TitleID, !anyFailed ? "Succeeded" : "*** Failed ***");

                    StringBuilder body = new StringBuilder();
                    body.Append("An automated submission was performed for title " + xdsData.TitleID + " under work item " + BugID + " [" + Title + "].\r\n");

                    if (anyFailed)
                    {
                        body.Append("\r\nThe automated process detected one or more errors associated with this submission which must be corrected in order for the submission to be properly processed.\r\n");
                        body.Append("\r\nPlease refer to the work item number " + BugID + " in any inquiries related to this submission.\r\n");
                    }
    
                    msg.Body = body.ToString();

                    SmtpClient mailClient = new SmtpClient();
                    mailClient.Host = smtpHost;
                    mailClient.UseDefaultCredentials = true;
                    mailClient.Send(msg);
    
                    return true;
                }
                catch (Exception e)
                {
                    Console.WriteLine("ERROR: Exception occured while attempting to send status email: " + e.Message);
                    return false;
                }
            }
            else
            {
                return false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\APDispatcher\PropResults.cs ===
using System;
using System.Collections;
using System.IO;
using System.Text;

namespace xonline.tools.APDispatcher
{
    public class PropResult
    {
        public enum PropResultType : byte
        {
            SUCCESS         = 1,
            PROPFAILED      = 2,
            INVALIDGROUPING = 3,
            SKIPPED         = 4
        };

        #region CTOR\DTOR

        public PropResult(ArrayList files, string output, PropResultType result)
        {
            _files = files;
            _output = output;
            _result = result;
        }

        /// <summary>
        /// Parses the summary results line from the prop results file.  Format is:
        /// result:file1[+file2][+file3]...[+fileN]
        /// 
        /// result is one of the static strings defined below.
        /// </summary>
        /// <param name="resultLine"></param>
        public PropResult(string resultLine)
        {
            _files = new ArrayList();

            string [] resultSplit = resultLine.Split(':');

            try
            {
                _result = StringToPropResultType(resultSplit[0]);
            }
            catch(ArgumentException e)
            {
                throw new ApplicationException(string.Format("Invalid prop result type found in summary line \"{0}\".", resultLine), e);
            }

            string [] resultFiles = resultSplit[1].Split('+');
            foreach(string file in resultFiles)
            {
                _files.Add(file);
            }
        }

        #endregion

        #region Properties

        public ArrayList Files
        {
            get { return _files; }
        }

        public string Output
        {
            get { return _output; }
            set { _output = value; }
        }

        public PropResultType Result
        {
            get { return _result; }
        }

        #endregion

        #region Member Variables

        private ArrayList _files;
        private string _output;
        private PropResultType _result;

        #endregion

        public static string PropResultTypeToString(PropResultType t)
        {
            switch(t)
            {
                case PropResultType.SUCCESS:
                    return Success;
                case PropResultType.PROPFAILED:
                    return PropFailed;
                case PropResultType.INVALIDGROUPING:
                    return InvalidGrouping;
                case PropResultType.SKIPPED:
                    return Skipped;
                default:
                    throw new ArgumentException(string.Format("Invalid prop result type {0} passed to PropResultTypeToString.", t.ToString()), "t");
            }
        }

        public static PropResultType StringToPropResultType(string s)
        {
            switch(s)
            {
                case Success:
                    return PropResultType.SUCCESS;
                case PropFailed:
                    return PropResultType.PROPFAILED;
                case InvalidGrouping:
                    return PropResultType.INVALIDGROUPING;
                case Skipped:
                    return PropResultType.SKIPPED;
                default:
                    throw new ArgumentException(string.Format("Invalid prop result string \"{0}\" passed to StringToPropResultType.", s), "s");
            }
        }


        /// <summary>
        /// Static strings for result lines in the prop results file
        /// </summary>
        public const string Success = "Success";
        public const string PropFailed = "Prop Failed";
        public const string InvalidGrouping = "Invalid Grouping";
        public const string Skipped = "Skipped";

        public const string BeginOutput = "====  Begin Detailed Job Output ====";
        public const string EndOutput   = "====  End Detailed Job Output ====";
    }

    
    /// <summary>
    /// Load and parse a prop results text file.  Usage:
    /// 1.  Create new instance, passing in filename of prop results file
    /// 2.  Use prop results from the Results property collection
    /// </summary>
    public class PropResultsReader
    {
        private ArrayList _results;

        public PropResultsReader()
        {
            _results = new ArrayList();
        }

        public PropResultsReader(string filename) : this()
        {
            Load(filename);
        }

        public void Load(string filename)
        {
            if(!File.Exists(filename))
                throw new FileLoadException("File not found.", filename);

            _results.Clear();

            using(TextReader reader = new StreamReader(filename))
            {
                //  Read first line which just contains the date/time stamp
                string curLine = reader.ReadLine();
                // TBD - Parse datetime (and do what with it exactly?  Vet it against filename?

                //  Read summary lines until we encounter a blank line, which signals the end of summary
                curLine = reader.ReadLine();

                //  Valid case, no results in file, just a single time/date line
                if(curLine == null)
                    return;

                while(curLine.Length != 0)
                {
                    PropResult result = new PropResult(curLine);
                    _results.Add(result);

                    curLine = reader.ReadLine();
                }

                //
                //  The next section of the file has all the command line output as follows:
                //
                //  <blank line>
                //  ====  Begin Detailed Job Output ====
                //  <job 1 output>
                //  ====  End Detailed Job Output ====
                //  <blank line>
                //  ====  Begin Detailed Job Output ====
                //  <job 2 output>
                //  ====  End Detailed Job Output ====
                //  .
                //  .
                //  .
                //  <blank line>
                //  ====  Begin Detailed Job Output ====
                //  <job N output>
                //  ====  End Detailed Job Output ====
                //  

                int outputCount = 0;
                while((curLine = reader.ReadLine()) != null)
                {
                    StringBuilder sOutput = new StringBuilder();

                    if(curLine != PropResult.BeginOutput)
                        continue;

                    while((curLine = reader.ReadLine()) != PropResult.EndOutput)
                    {
                        sOutput.Append(curLine);
                        sOutput.Append("\n");
                    }

                    ((PropResult)_results[outputCount]).Output = sOutput.ToString();

                    ++outputCount;
                }
            }
        }
        
        public ArrayList Results
        {
            get { return _results; }
        }
    }

	
    /// <summary>
	/// Write out prop results to text file.  Usage:
	/// 1.  Create instance
	/// 2.  Call AddResult multiple times
	/// 3.  Call Save, passing in the directory to create file in
	/// 
	/// File will be automatically named using datetime stamp.
	/// </summary>
	public class PropResultsWriter
	{
        private ArrayList _results;
        private string _filename = "<no filename, not saved yet>";

        public PropResultsWriter()
        {
            _results = new ArrayList();
        }

        public ArrayList Results
        {
            get { return _results; }
        }

        public string Filename
        {
            get { return _filename; }
        }

        public void AddResult(ArrayList files, string output, PropResult.PropResultType result)
        {
            PropResult r = new PropResult(files, output, result);
            _results.Add(r);
        }

        public string FormatSummaryLines()
        {
            StringBuilder summaryLines = new StringBuilder();

            //  First loop, simple success/failure results
            foreach(PropResult r in _results)
            {
                summaryLines.Append(PropResult.PropResultTypeToString(r.Result));
                summaryLines.Append(":");

                bool bFirst = true;
                foreach(string file in r.Files)
                {
                    if(!bFirst)
                        summaryLines.Append("+");

                    bFirst = false;

                    summaryLines.Append(Path.GetFileName(file));
                }

                summaryLines.Append("\r\n");
            }

            return summaryLines.ToString();
        }

        public string Save(string dir)
        {
            DateTime dt = DateTime.Now;
            FileStream resultsFile;

            //  First make sure we can create a new file

            do
            {
                _filename = Path.Combine(dir, "PropResults_" + dt.ToString("yyyyMMddHHmmssfff") + ".txt");

                try
                {
                    resultsFile = new FileStream(_filename, FileMode.CreateNew, FileAccess.ReadWrite, FileShare.Read);
                    resultsFile.Close();
                }
                catch(IOException) 
                {
                    // This occurs if the file already exists, try a new filename
                    // Access denied and out of disk space conditions cause different exceptions
                    // which will get thrown up to the creator.
                    dt.AddMilliseconds(1);
                }
            }
            while(!File.Exists(_filename));

            //  Now open the file for writing and get busy!

            using(TextWriter writer = new StreamWriter(_filename))
            {
                //  First line is the time stamp.
                writer.WriteLine("PropResults file created on {0} at {1}.", dt.ToLongDateString(), dt.ToString("HH:mm:ss.fff"));

                //  Write out summaries for each processed group
                writer.Write(FormatSummaryLines());

                //  Second loop, detailed output of each prop
                foreach(PropResult r in _results)
                {
                    //  Blank line before each job output
                    writer.WriteLine(string.Empty);

                    //  Delimited job output
                    writer.WriteLine(PropResult.BeginOutput);
                    writer.WriteLine(r.Output);
                    writer.WriteLine(PropResult.EndOutput);
                }
            }

            return _filename;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\APDispatcher\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\APDispatcher\autoprop.cs ===
using System;
using System.Text;
using System.Xml;
using System.IO;
using System.Diagnostics;
using System.Security.Cryptography.X509Certificates;
using xonline.common.tools.console;


namespace xonline.tools.APDispatcher
{

	class AutopropDispatcherClass
	{
        static string  smtpHost     = "smtphost.redmond.corp.microsoft.com";
        static string  server       = null;
        static string  uploadServer = null;
        static string  psDatabase   = null;
        static string  certificate  = null;
        static string  treePath     = null;
        static int     maxBugs      = 50;		

        private static void Help()
        {
            Console.WriteLine("Usage: APDispatcher.exe /server:<server> /uploadserver:<server> /psdatabase:<dbname> /pspath:<path> /certificate:<fname> /maxbugs:<#>");
            Console.WriteLine("       <server> is either a WebSG server or a WebCache server");
            Console.WriteLine("       <uploadserver> is the name or address of the secure file upload server.");
            Console.WriteLine("       <psdatabase> is the name of a ProductStudio database <EG xboxonline>");
            Console.WriteLine("       <pspath> is the path in ProductStudio to look for bugs <EG partnernet>");
            Console.WriteLine("       <certificate> is the name of a .CER client certificate used to authenticate to a WebSG");
            Console.WriteLine("       <maxbugs> is the maximum number of ProductStudio bugs that will be processed");
        }

        [STAThread]
		static int Main(string[] rawArgs)
		{
			try
			{
                Console.WriteLine("\n\nAutoprop Dispatcher"); 
                Console.WriteLine("===================\n"); 


                NamedArgParser args;

                string [] tags = {
                                     "server",
                                     "psdatabase",
                                     "pspath",
                                     "certificate",
                                     "maxbugs",
                                     "uploadserver",
                                     "?"
                                 };

                args = new NamedArgParser(tags);

                if (!args.Parse(rawArgs))
                {
                    Help();
                    return -1;
                }

                if (args["?"] != null)
                {
                    Help();
                    return -1;
                }

                if (args["server"] == null)
                {
                    Console.WriteLine("Unable to proceed -- missing required /server: specification");
                    Help();
                    return -1;
                }
                else
                {
                    server = args["server"];
                }

                if (args["uploadserver"] == null)
                {
                    Console.WriteLine("Unable to proceed -- missing required /uploadserver: specification");
                    Help();
                    return -1;
                }
                else
                {
                    uploadServer = args["uploadserver"];
                }

                if (args["psdatabase"] == null)
                {
                    Console.WriteLine("Unable to proceed -- missing required /psdatabase: specification");
                    Help();
                    return -1;
                }
                else
                {
                    psDatabase = args["psdatabase"];
                }

                if (args["pspath"] == null)
                {
                    Console.WriteLine("Unable to proceed -- missing required /pspath: specification");
                    Help();
                    return -1;
                }
                else
                {
                    treePath = args["pspath"];
                }

                if (args["certificate"] != null)
                {
                    certificate = args["certificate"];
                }
                else
                {
                    Console.WriteLine("WARNING: Assuming direct connection to webcache server since no certificate was specified");
                }

                if (args["pspath"] != null)
                {
                    treePath = args["pspath"];
                }

                if (args["maxbugs"] != null)
                {
                    maxBugs = (int) Convert.ToInt32(args["maxbugs"]);
                }





                //-------------------------------------------------------------
                // Setup our connection to the WebSG/Widget
                // 
                ToolsMgmt service;
                  
                if (certificate != null)
                {
                    service = new ToolsMgmt("https://" + server + "/wcToolsMgmt/ToolsMgmt.asmx");
                    X509Certificate x509 = X509Certificate.CreateFromCertFile(certificate);
                    service.ClientCertificates.Add(x509); 

                    Console.WriteLine("Authenticating with certificate: [" + x509.Subject + "]"); 
                }
                else
                {
                    // $REVIEW (michion): Debug only?
                    service = new ToolsMgmt("http://" + server + ":12000/wcToolsMgmt/ToolsMgmt.asmx");
                }

                //-------------------------------------------------------------

                PSAccess  psAccess = new PSAccess(psDatabase);

                AutopropBug x = psAccess.GetWork(treePath);

                if (x == null)
                {
                    Console.WriteLine("No work found");
                    return 0;
                }


                while (x != null && maxBugs > 0)
                {
                    try
                    {
                        maxBugs--;

                        x.ExtractFiles();

                        if (x.CanAutoprop())
                        {
                            x.AutoProp(service, uploadServer);
                            x.SendStatusEmail(smtpHost);
                        }
                    }
                    catch(Exception e)
                    {
                        x.UpdateBug("Failed", string.Format("The following unexpected exception occured while processing this bug: {0}", e.Message), "");
                    }
                    finally
                    {
                        x.FreeResources();
                    }

                    x = psAccess.GetWork(treePath);
                }
                
			}
			catch (Exception e)
			{
				Console.WriteLine("Error: {0}", e.Message);
                return -1;
			}

            return 0;
        }
    }

    
    /* ========================================================================
     * CLASS: WebSvcException
     * ========================================================================
     *
    */
    public class WebSvcException : Exception
    {
        public WebSvcException(string message) : base(message)
        {
            Console.WriteLine("WebService exception: " + message);
            LogEvent(message);
        }

        private void LogEvent(string message)
        {
            EventLog myLog = new EventLog();
            myLog.Log      = "Application";
            myLog.Source   = "APDispatcher";

            myLog.WriteEntry(message, EventLogEntryType.Error, 5);
        
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\AdWalk\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("AdWalk")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("AdWalk")]
[assembly: AssemblyCopyright("Copyright  Microsoft 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("93b447ab-05ed-4103-b443-a05a1c0d5893")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\APDispatcher\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ArgoAcctMgr\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\APDispatcher\XDSData.cs ===
using System;
using System.Globalization;
using ProductStudio;

namespace xonline.tools.APDispatcher
{
    /* ========================================================================
     * CLASS: XDSData
     * ========================================================================
     * Simple class to encapsulate the interpretation of XDS supplied
     * data that are saved to Product Studio in a bug's Description
     * text
     *
    */
    class XDSData
    {
        #region Data Members

        private string  _titleID = "";
        private string  _contact = "";
        private string  _xmid= "";
        
        #endregion

        #region CTOR/DTOR

        public XDSData(DatastoreItem bug)
        {
            //---------------------------------------------------------
            // The first history item (which ironically is the last
            // element in the History collection) is the one which the
            // XDS system will place a variety of interesting info
            // (such as title ID, contact info) into the Description.
            // If there has only been one edit on the bug, then it will
            // not be in the History collection, however, but in the
            // DatastoreItem we retrieve initially
            //
            // Since this is a text field, we have to parse it in order
            // to extract the data 
            //
            Field initialDescriptionField;

            if (bug.History.Count < 1)
            {
                initialDescriptionField = bug.Fields["Description"];
            }
            else
            {
                initialDescriptionField = bug.History[bug.History.Count-1].Fields["Description"];
            }

            if(initialDescriptionField != null && initialDescriptionField.Value != null)
            {
                string initialDescription = initialDescriptionField.Value.ToString();
                char [] delimiters = {'\n'}; 

                string [] fields = initialDescription.Split(delimiters);

                foreach(string line in fields)
                {
                    if (line.StartsWith("Title ID:"))
                    {
                        string[] titleIdParts = line.Split(':');
                        if (titleIdParts.Length != 2)
                            continue;

                        _titleID = titleIdParts[1].Trim();
                        if (_titleID.StartsWith("0x"))
                        {
                            _titleID = _titleID.Remove(0, 2);
                        }

                        if (_titleID.Length == 0)
                            continue;
                    }

                    if (line.StartsWith("Contact:"))
                    {
                        string[] contactParts = line.Split(':');
                        _contact = contactParts[1].Trim();
                        continue;
                    }

                    if (line.StartsWith("XMID:"))
                    {
                        string[] xmidParts = line.Split(':');
                        _xmid = xmidParts[1].Trim();
                        continue;
                    }
                }
            }


            if(_titleID == "" && bug.Fields["Title ID"].Value != null && ((string)bug.Fields["Title ID"].Value).Length >= 8)
            {
                string tempTitleId = ((string)(bug.Fields["Title ID"].Value)).Substring(0, 8);

                try
                {
                    uint.Parse(tempTitleId, NumberStyles.HexNumber);

                    _titleID = tempTitleId;
                }
                catch(FormatException)
                {
                    // Swallow this exception.  The title id field could not be parsed
                    // so it is invalid and should not be assigned to _titleID.
                }
            }
        }

        #endregion

        #region Properties

        public string Contact
        {
            get { return _contact; }
        }

        public string TitleID
        {
            get { return _titleID; }
        }

        public string XMID
        {
            get { return _xmid; }
        }    

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\APDispatcher\PSAccess.cs ===
using System;
using ProductStudio;

namespace xonline.tools.APDispatcher
{

    /* ========================================================================
     * CLASS: PSAccess
     * ========================================================================
     * Class to handle Product Studio details relating to running queries to
     * find dispatcher work
     *
    */
    class PSAccess
    {
        string               	        databaseName = null;
        ProductStudio.Directory	        psDirectory  = null;
        ProductStudio.Product		    psProduct    = null;
        ProductStudio.Datastore	        psDatastore  = null;


        public PSAccess(string dbName)
        {
            databaseName = dbName;
        }


        ProductStudio.Directory PSDirectory
        {
            get
            {
                if (psDirectory == null)
                {
                    psDirectory = new ProductStudio.DirectoryClass();
                    psDirectory.Connect("", "", "");
                }

                return psDirectory;
            }
        }

        

        ProductStudio.Product PSProduct
        {
            get
            {
                if (psProduct == null)
                {
                    psProduct = PSDirectory.GetProductByName(databaseName);
                }

                return psProduct;
            }
        }

        
        ProductStudio.Datastore PSDatastore
        {
            get
            {
                if (psDatastore == null)
                {
                    psDatastore = PSProduct.Connect("", "", "");
                }

                return psDatastore;
            }
        }

        


        public int TreeIDFromPath(string path)
        {
            string[]    pathLevelNames;
            char[]      separator = {'\\'};
            Node        currentNode = PSDatastore.RootNode;
        
            pathLevelNames = path.Split(separator);
        
            if(path.Trim().Length >= 1 && path.Trim() != "\\")
            {
                for (int pathCount=0; pathCount<pathLevelNames.Length; pathCount++)
                {
                    currentNode = currentNode.Nodes[pathLevelNames[pathCount]];
                }
            }
        
            return currentNode.ID;
        }



        
        /* GetWork
             * ------------------------------------
             * Method to execute the PS query used to identify the bugs that need 
             * to be examined by the autoprop system.  Note that this does NOT
             * necessarily mean that the bugs returned will be subjected to
             * autoprop.  There are various types of bugs that will be 'ignored'
             * by the autoprop system and deferred to xladmin handling (either 
             * because of the level of tool support or other reasons)
             * 
            */
        public AutopropBug GetWork(string treePath)
        {
            AutopropBug retBug = null;

            int treeID = TreeIDFromPath(treePath);
            
            int			                    fieldCount      = 0;
            string		                    psQueryXml      = "";
            ProductStudio.Query		        psQuery         = null;
            ProductStudio.DatastoreItemList	psDataList      = null;
            ProductStudio.FieldDefinitions	psFields        = null;
            string[]                        fieldsArray     = {"Title"};
            string[]                        sortFieldsArray = {"ID"};
    
            //
            // Query in Xml Format which retrieves all 
            // unassigned bugs 
            //
            psQueryXml = "<Query>" + 
                "<Group GroupOperator='and'>" +
                "<Expression Column='Assigned To'    Operator='equals'><String>xladmins</String></Expression>" +
                "<Expression Column='Status'         Operator='equals'><String>Active</String></Expression>" +
                "<Expression Column='Autoprop State' Operator='equals'><String>Ready</String></Expression>" +
                "<Expression Column='TreeID'         Operator='equals'><Number>" + treeID.ToString() + "</Number></Expression>" +
                "</Group>" +
                "</Query>";
    
            //
            // Set up the query.
            //
            psQuery = new ProductStudio.QueryClass();
            psQuery.CountOnly         = false;
            psQuery.SelectionCriteria = psQueryXml;
    
            //
            // Bind the query and Datastore to our 
            // DatastoreItemList.
            //
            psDataList = new ProductStudio.DatastoreItemListClass();
            psDataList.Query     = psQuery;
            psDataList.Datastore = PSDatastore;
    
                                                                            

            //-------------------------------------------------------------
            // Configure the query with the fields to return and sort by
            // processing
            //
            psFields = PSDatastore.FieldDefinitions;

            psQuery.QueryFields.Clear();
            for (fieldCount = 0; fieldCount < fieldsArray.Length; fieldCount ++)
            {
                psQuery.QueryFields.Add(psFields[fieldsArray[fieldCount]]);	
            }
            
            psQuery.QuerySortFields.Clear();
            for (fieldCount = 0; fieldCount < sortFieldsArray.Length; fieldCount ++)
            {
                psQuery.QuerySortFields.Add(psFields[sortFieldsArray[fieldCount]], PsSortTypeEnum.psSortTypeAscending);	
            }
            

            //-------------------------------------------------------------
            // All set: Run the query and get the first matching bug for
            // processing
            //
            psDataList.Execute();

            foreach (DatastoreItem psItem in psDataList.DatastoreItems)
            {
                retBug = new AutopropBug(psItem);
                break;
            }

            return retBug;
        }
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ArgoAcctMgr\MaskConsole.cs ===
using System;

namespace xonline.tools.argoacctmgr
{
    public class MaskConsole
    {
        // Methods
        private static string GetPasswordChars(string s, char c)
        {
            string passwordChars = "";
            for (int i = 0; i < s.Length; i++)
            {
                passwordChars = passwordChars + c;
            }
            return passwordChars;
        }

        public static string ReadMaskLine()
        {
            ConsoleKey ck;
            string password = "";
            string s = "~!@#$%&*()_+`1234567890-=";
            s = (s + @"QWERTYUIOP{}|qwertyuiop[]\") + "ASDFGHJKL:\"asdfghjkl;'" + "ZXCVBNM<>?zxcvbnm,./ ";
            do
            {
                ConsoleKeyInfo cki = Console.ReadKey(true);
                char c = cki.KeyChar;
                ck = cki.Key;
                int p = 0;
                if (((ck == ConsoleKey.Backspace) && !string.IsNullOrEmpty(password)) && (password.Length > 0))
                {
                    password = password.Substring(0, p - 1);
                }
                else if (s.IndexOf(c) >= 0)
                {
                    password = password + c;
                }
                else
                {
                    Console.Beep();
                    return password;
                }
            }
            while (ck != ConsoleKey.Enter);
            return password;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\APDispatcher\ToolsMgmt.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.2300
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.1.4322.2300.
// 
namespace xonline.tools.APDispatcher {
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="ToolsMgmtSoap", Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public class ToolsMgmt : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public ToolsMgmt(string url) 
        {
            this.Url = url;
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/GetActionTable", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetActionTable() {
            object[] results = this.Invoke("GetActionTable", new object[0]);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetActionTable(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetActionTable", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetActionTable(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/BeginWork", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public BeginWorkResult BeginWork(BeginWorkInfo bwi) {
            object[] results = this.Invoke("BeginWork", new object[] {
                        bwi});
            return ((BeginWorkResult)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBeginWork(BeginWorkInfo bwi, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BeginWork", new object[] {
                        bwi}, callback, asyncState);
        }
        
        /// <remarks/>
        public BeginWorkResult EndBeginWork(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((BeginWorkResult)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/WorkFilesReady", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public WorkFilesReadyResult WorkFilesReady(WorkFilesReadyInfo wfri) {
            object[] results = this.Invoke("WorkFilesReady", new object[] {
                        wfri});
            return ((WorkFilesReadyResult)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginWorkFilesReady(WorkFilesReadyInfo wfri, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("WorkFilesReady", new object[] {
                        wfri}, callback, asyncState);
        }
        
        /// <remarks/>
        public WorkFilesReadyResult EndWorkFilesReady(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((WorkFilesReadyResult)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/GetWorkStatus", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GetWorkStatusResult GetWorkStatus(GetWorkStatusInfo gwsi) {
            object[] results = this.Invoke("GetWorkStatus", new object[] {
                        gwsi});
            return ((GetWorkStatusResult)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetWorkStatus(GetWorkStatusInfo gwsi, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetWorkStatus", new object[] {
                        gwsi}, callback, asyncState);
        }
        
        /// <remarks/>
        public GetWorkStatusResult EndGetWorkStatus(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GetWorkStatusResult)(results[0]));
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public class BeginWorkInfo {
        
        /// <remarks/>
        public System.UInt32 workType;
        
        /// <remarks/>
        public string titleId;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public class GetWorkStatusResult {
        
        /// <remarks/>
        public bool workComplete;
        
        /// <remarks/>
        public int returnCode;
        
        /// <remarks/>
        public string consoleOutput;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public class GetWorkStatusInfo {
        
        /// <remarks/>
        public System.UInt64 workId;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public class WorkFilesReadyResult {
        
        /// <remarks/>
        public bool success;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public class WorkFilesReadyInfo {
        
        /// <remarks/>
        public System.UInt64 workId;
        
        /// <remarks/>
        public string relativePath;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public class BeginWorkResult {
        
        /// <remarks/>
        public System.UInt64 workId;
        
        /// <remarks/>
        public System.UInt64 spaceAvailable;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\authdump\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ArgoAcctMgr\ArgoAcctMgr.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Globalization;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Net.Security;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Policy;
using System.Text;
using System.Text.RegularExpressions;
using System.Web;
using System.Xml;

using xonline.common.service;
using xonline.common.tools.console;
using xonline.common.utilities2;

using Microsoft.Passport.Test.Ppcrl;

namespace xonline.tools.argoacctmgr
{
    /// <summary>
    /// Summary description for ArgoAcctMgr.
    /// </summary>
    class ArgoAcctMgr
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        ///

        static string retailerId = "ZUNE";

        static bool   verbose = false;
        static bool   useXblob = false;
        static string xblobHostname = "NPDB";

        static NamedArgParser args;

        static string webSvcUrl = "websvc.argo.xboxlive.com";
        static string certName = "argo.crux.rdw.001";
        static string rpsSiteId = "63264"; // Int-rps.xboxlive.com
        static string rpsSiteName = "Int-rps.xboxlive.com";
        static string cruxRpsSiteName = "Int-rps.xboxlive.com";
        static int    aaPort = 443;
        static string aaHost = "131.107.28.202";
        static string passportEnv = "int";
        static string behaviorHeader = null;

        static uint   serviceTitleId = 0xfffe0777;
        static int    serviceType    = 2;
        static string serviceClientName = "Dorado";
        static bool   isZune = true;

        static string token5x5Regex =
            "([a-zA-Z0-9]{5}-[a-zA-Z0-9]{5}-[a-zA-Z0-9]{5}-[a-zA-Z0-9]{5}-[a-zA-Z0-9]{5}|[a-zA-Z0-9]{25})";

        static WebProxy proxy = null;

        static XlsEnv xlsEnv = null;

        public static string PassportEnv
        {
            get { return passportEnv; }
        }

        public static string UacsSvcUrl
        {
            get
            {
                string protocol = useXblob ? "http" : "https";
                return protocol + "://" + aaHost + ":" + aaPort + "/xuacs/useraccount.asmx";
            }
        }

        public static string XbosSvcUrl
        {
            get
            {
                string protocol = useXblob ? "http" : "https";
                return protocol + "://" + aaHost + ":" + aaPort + "/xbos/billing.asmx";
            }
        }

        [STAThread]
        static int Main(string[] rawArgs)
        {
            //
            // TODO: Add code to start application here
            //
            string [] options = {
                "new",
                "sub",
                "subscription",
                "nosub",
                "nosubscription",
                "points",
                "nopoints",
                "testnet",
                "testz",
                "testnetz",
                "prod",
                "prodnet",
                "proxy",
                "certname",
                "websghost",
                "url",
                "rpssiteid",
                "cruxrpssitename",
                "rpssitename",
                "aagateway",
                "aahost",
                "aaport",
                "xblob",
                "argo",
                "argonet",
                "status",
                "signin",
                "getuserauth",
                "balance",
                "getpi",
                "addcc",
                "buypoints",
                "buysub",
                "behavior",
                "subcancel",
                "subenum",
                "test",
                "testconnection",
                "user",
                "pass",
                "password",
                "retailer",
                "verbose",
                "verify",
                "verifytoken",
                "xbox",
                "zune",
                "help",
                "?"
            };

            string user = null;
            string password = "secret";

            AuthState authState = null;

            bool addPoints = true;
            bool addSubscription = true;

            args = new NamedArgParser(options);

            if (!args.Parse(rawArgs))
            {
                Console.Error.WriteLine("Invalid argument: " + args.InvalidArgText);
                Usage();
                return -1;
            }

            if ( args["help"] != null || args["?"] != null )
            {
                Usage();
                return 0;
            }

            if ( args["verbose"] != null )
            {
                verbose = true;
            }

            if ( args["retailer"] != null )
            {
                retailerId = args["retailer"];
            }

            if ( args["aahost"] != null )
            {
                aaHost = args["aahost"];
            }

            if ( args["aaport"] != null )
            {
                aaPort = Int32.Parse( args["aaport"] );
            }

            if ( args["nopoints"] != null )
            {
                addPoints = false;
            }

            if ( args["nosubscription"] != null || args["nosub"] != null )
            {
                addSubscription = false;
            }

            if ( args["argo"] != null || args["argonet"] != null )
            {
                xlsEnv = new XlsEnv(XlsEnvEnum.ArgoNet);

                useXblob = false;
                aaPort = 443; // default HTTPS port
                rpsSiteName = "Int-rps.xboxlive.com";
                cruxRpsSiteName = "Int-rps.xboxlive.com";
                aaHost = "131.107.28.202";
            }

            if ( args["testnet"] != null )
            {
                xlsEnv = new XlsEnv(XlsEnvEnum.TestNet);

                useXblob = false;
                webSvcUrl = "10.198.102.113";
                certName = "test.crux.rdw.001";
                rpsSiteId = "64146"; // xuacs.test.xboxlive.com
                rpsSiteName = "kdc.test.xboxlive.com";
                cruxRpsSiteName = "xuacs.test.xboxlive.com";

                // TestNet uses SSL on port 14100
                aaPort = 14100;
                aaHost = "10.198.102.118";
            }

            if ( args["testz"] != null || args["testnetz"] != null )
            {
                useXblob = false;
                webSvcUrl = "10.198.102.46";
                certName = "testz.crux.rdw.001";
                rpsSiteId = "64146"; // xuacs.test.xboxlive.com
                rpsSiteName = "kdc.test.xboxlive.com";
                cruxRpsSiteName = "xuacs.test.xboxlive.com";

                // From CorpNet, TestNetZ uses SSL on port 443
                aaPort = 443;
                aaHost = "10.198.102.47";
            }

            if ( args["prod"] != null || args["prodnet"] != null )
            {
                xlsEnv = new XlsEnv(XlsEnvEnum.Prod);

                useXblob = false;
                aaPort = 443; // default HTTPS port
                rpsSiteName = "kdc.xboxlive.com";
                cruxRpsSiteName = "xuacs.xboxlive.com";
                aaHost = "activeauth.xboxlive.com";
                passportEnv = "production";

                // no default password for Production accounts
                password = null;
            }

            if ( args["xblob"] != null )
            {
                xlsEnv = new XlsEnv(XlsEnvEnum.Xblob);
                xlsEnv.AuthSgHost = args["xblob"];

                useXblob = true;

                rpsSiteId = "64146"; // xuacs.test.xboxlive.com
                rpsSiteName = "kdc.test.xboxlive.com";
                cruxRpsSiteName = "kdc.test.xboxlive.com";

                if ( args["xblob"] != string.Empty )
                {
                    xblobHostname = args["xblob"];
                }
                else
                {
                    xblobHostname = "localhost";
                }

                aaPort = 13100;
                aaHost = xblobHostname;
            }

            if ( args["xbox"] != null )
            {
                serviceTitleId = 0xfffe07d1;
                serviceType = 1;
                serviceClientName = "Panorama";
                isZune = false;
            }

            if ( args["zune"] != null )
            {
                serviceTitleId = 0xfffe0777;
                serviceType = 2;
                serviceClientName = "Dorado";
                isZune = true;
            }

            if ( !string.IsNullOrEmpty(args["certname"]) )
            {
                certName = args["certname"];
            }

            if ( !string.IsNullOrEmpty(args["url"]) )
            {
                webSvcUrl = args["url"];
            }

            if ( !string.IsNullOrEmpty(args["websghost"]) )
            {
                webSvcUrl = args["websghost"];
            }

            if ( !string.IsNullOrEmpty(args["rpssiteid"]) )
            {
                rpsSiteId = args["rpssiteid"];
            }

            if ( !string.IsNullOrEmpty(args["rpssitename"]) )
            {
                rpsSiteName = args["rpssitename"];
            }

            if ( !string.IsNullOrEmpty(args["cruxrpssitename"]) )
            {
                cruxRpsSiteName = args["cruxrpssitename"];
            }

            if ( !string.IsNullOrEmpty(args["proxy"]) )
            {
                proxy = new WebProxy(args["proxy"], true);
            }

            if ( !string.IsNullOrEmpty(args["behavior"]) )
            {
                behaviorHeader = args["behavior"];
            }

            try
            {

                if ( args["test"] != null || args["testconnection"] != null )
                {
                    WCMusic mw = GetWCMusic();
                    string result = mw.TestConnection("ArgoAcctMgr");
                    Console.WriteLine("ArgoAcctMgr: TestConnection succeeded.");
                    return 0;
                }

                if ( args["user"] != null )
                {
                    user = args["user"];

                    if ( user == string.Empty )
                    {
                        Console.Error.WriteLine("ArgoAcctMgr: missing userid in -user:<usertag>");
                        Usage();
                        return -1;
                    }

                    if ( args["password"] != null || args["pass"] != null )
                    {
                        if ( args["password"] != null )
                        {
                            password = args["password"];
                        }
                        else if ( args["pass"] != null )
                        {
                            password = args["pass"];
                        }

                        if ( string.IsNullOrEmpty(password) )
                        {
                            Console.Write("Password: ");

                            password = MaskConsole.ReadMaskLine();

                            Console.WriteLine();
                        }
                    }

                    if ( xlsEnv == null )
                    {
                        throw new Exception("no environment specified!");
                    }

                    authState = xlsEnv.GetAuthState(user, password, isZune);
                }

                string argsNew = args["new"];
                if ( argsNew != null )
                {
                    if ( argsNew == string.Empty )
                    {
                        CreateNewAccount(addPoints, addSubscription);
                        return 0;
                    }

                    int bulkCount = 0;
                    try
                    {
                        bulkCount = Int32.Parse(argsNew);

                        CreateBulkAccounts(addPoints, addSubscription, bulkCount);
                    }
                    catch (Exception e)
                    {
                        if ( e is FormatException || e is OverflowException )
                        {
                            Console.Error.WriteLine("ArgoAcctMgr: -bulk:<count> requires a valid integer count.");
                            Usage();
                            return -1;
                        }
                    }
                }

                if ( args["status"] != null )
                {
                    if ( user == null || user == string.Empty )
                    {
                        Console.Error.WriteLine("ArgoAcctMgr: -status requires -user:<userid>");
                        Usage();
                        return -1;
                    }

                    GetAccountStatus(user, password);
                    return 0;
                }

                if ( args["signin"] != null )
                {
                    if ( user == null || user == string.Empty )
                    {
                        Console.Error.WriteLine("ArgoAcctMgr: -signin requires -user:<userid>");
                        Usage();
                        return -1;
                    }

                    DoZuneSignIn(user, password);

                    return 0;
                }

                if ( args["getuserauth"] != null )
                {
                    if ( string.IsNullOrEmpty(user) )
                    {
                        Console.Error.WriteLine("ArgoAcctMgr: -getuserauth requires -user:<userid>");
                        Usage();
                        return -1;
                    }

                    DoGetUserAuth(user, password);

                    return 0;
                }

                if ( args["balance"] != null )
                {
                    DoGetPointsBalance(authState);

                    return 0;
                }

                if ( args["getpi"] != null )
                {
                    DoGetPaymentInstruments(authState);

                    return 0;
                }

                if ( args["addcc"] != null )
                {
                    DoAddCreditCard(authState);

                    return 0;
                }

                if ( args["buypoints"] != null )
                {
                    string buyPointsArg = args["buypoints"];

                    if ( user == null || user == string.Empty )
                    {
                        Console.Error.WriteLine("ArgoAcctMgr: -buypoints requires -user:<userid>");
                        Usage();
                        return -1;
                    }

                    ulong offerId = 18446189718253076483;

                    if ( !string.IsNullOrEmpty(buyPointsArg) )
                    {
                        offerId = SafeConvert.ToUInt64(buyPointsArg, 18446189718253076483);
                    }

                    DoPurchasePointsBundle(authState, offerId);

                    return 0;
                }

                if ( args["buysub"] != null )
                {
                    string buySubArg = args["buysub"];
                    string billingToken = "";

                    if ( user == null || user == string.Empty )
                    {
                        Console.Error.WriteLine("ArgoAcctMgr: -buysub requires -user:<userid>");
                        Usage();
                        return -1;
                    }

                    ulong offerId = 18446189333720334337;

                    if ( !string.IsNullOrEmpty(buySubArg) )
                    {
                        if ( Regex.IsMatch(buySubArg, token5x5Regex) )
                        {
                            int storeId = 1;

                            billingToken = buySubArg;

                            string tokenXml = AuthSgWebMethods.VerifyToken(authState, billingToken, storeId);

                            offerId = GetOfferIdFromVerifyTokenResults(tokenXml);
                        }
                        else
                        {
                            offerId = SafeConvert.ToUInt64(buySubArg, 18446189718253076483);
                        }
                    }

                    DoPurchaseSubscription(authState, offerId, billingToken);

                    return 0;
                }

                if ( args["verify"] != null || args["verifytoken"] != null )
                {
                    string billingToken = string.IsNullOrEmpty(args["verify"]) ? args["verifytoken"] : args["verify"];

                    int storeId = 1;

                    DoVerifyToken(authState, billingToken, storeId);

                    return 0;
                }
                if ( args["subenum"] != null )
                {
                    if ( user == null || user == string.Empty )
                    {
                        Console.Error.WriteLine("ArgoAcctMgr: -subenum requires -user:<userid>");
                        Usage();
                        return -1;
                    }

                    string enumArgs = args["subenum"].ToLower();

                    bool queryForNew = false;
                    bool queryForRenewals = false;
                    bool queryForCurrent = false;
                    bool queryForCancelled = false;
                    bool queryForSuspended = false;

                    foreach (string enumType in enumArgs.Split(new char[]{'|',','}))
                    {
                        switch ( enumType )
                        {
                        case "new":
                            queryForNew = true;
                            break;
                        case "renew":
                        case "renewal":
                        case "renewals":
                            queryForRenewals = true;
                            break;
                        case "curr":
                        case "current":
                            queryForCurrent = true;
                            break;
                        case "cancel":
                        case "cancelled":
                            queryForCancelled = true;
                            break;
                        case "suspend":
                        case "suspended":
                            queryForSuspended = true;
                            break;
                        }
                    }

                    DoSubscriptionEnumerate(authState, serviceTitleId, queryForNew, queryForRenewals, queryForCurrent, queryForCancelled, queryForSuspended);

                    return 0;
                }

                if ( args["subcancel"] != null )
                {
                    string subCancelArg = args["subcancel"];

                    if ( user == null || user == string.Empty )
                    {
                        Console.Error.WriteLine("ArgoAcctMgr: -subcancel requires -user:<userid>");
                        Usage();
                        return -1;
                    }

                    bool undoDelayedCancel = false;
                    if ( args["subcancel"] == "undo" )
                    {
                        undoDelayedCancel = true;
                    }

                    // find current subscription
                    string subEnumXml = AuthSgWebMethods.SubscriptionEnumerate(authState, 5, 1, serviceTitleId, false, false, true, false, false);

                    ulong offerId = GetOfferIdFromSubscriptionEnumResults(subEnumXml);

                    if ( offerId == 0 )
                    {
                        Console.Error.WriteLine("ArgoAcctMgr: -subcancel: no offer id provided nor was an active subscription found");
                        return -1;
                    }

                    DoCancelSubscription(authState, offerId, undoDelayedCancel);

                    return 0;
                }

            }
            catch (System.Runtime.InteropServices.COMException ce)
            {
                if ( (uint) ce.ErrorCode == 0x80040154 )
                {
                    Console.Error.WriteLine("ArgoAcctMgr: failed to instantiate CAPICOM.  Have you run: regsvr32 capicom.dll");
                    Console.Error.WriteLine("");
                    Console.Error.WriteLine("COMException: " + ce);
                    return -1;
                }

                throw;
            }
            catch (System.Security.SecurityException se)
            {
                Console.Error.WriteLine("ArgoAcctMgr: security exception:  Try executing a local copy of ArgoAcctMgr rather than executing from a share.");
                Console.Error.WriteLine("");
                Console.Error.WriteLine("SecurityException: " + se);
                return -1;
            }
            catch (XRLException xe)
            {
                if ( xe.HResult == HResult.XONLINE_E_RPS_CERT_NOT_FOUND )
                {
                    Console.Error.WriteLine("ArgoAcctMgr: failed to find argo.crux.rdw.001 certificate.  Have you imported it yet?");
                    Console.Error.WriteLine("");
                    Console.Error.WriteLine("Exception: " + xe);
                    return -1;
                }
                throw;
            }
            catch (IDCRLException ie)
            {
                Console.Error.WriteLine("ArgoAcctMgr: caught IDCRL exception: ErrorCode: 0x" + ie.ErrorCode.ToString("x"));
                Console.Error.WriteLine("Exception:\r\n" + ie.ToString());
                return -1;
            }
            catch (WebException we)
            {
                if ( we.Response != null && we.Response.Headers != null )
                {
                    string xerr = we.Response.Headers["X-Err"];
                    if ( !string.IsNullOrEmpty(xerr) )
                    {
                        Console.Error.WriteLine("ArgoAcctMgr: X-Err: 0x" + xerr + "\r\n");
                    }
                }
                Console.Error.WriteLine("ArgoAcctMgr: web exception:\r\n\r\n" + we.ToString());
                return -1;
            }
            catch (Exception e)
            {
                Console.Error.WriteLine("ArgoAcctMgr: unhandled exception:\r\n\r\n" + e.ToString());
                return -1;
            }
            return 0;
        }

        static void DoZuneSignIn(string user, string password)
        {
            if ( verbose )
            {
                Console.WriteLine("");
                Console.WriteLine("RpsSiteName: " + rpsSiteName);
                Console.WriteLine("SignInUrl: " + UacsSvcUrl + "/SignIn");
            }

            string ticket = IdcrlUtil.GetRpsTicket(user, password, rpsSiteName, "hbi");

            if ( verbose )
            {
                Console.WriteLine("IdcrlTicket: " + ticket);
            }

            string xmlText = GetSignInResults(ticket);

            Console.WriteLine("");
            Console.WriteLine("UserAccount.SignIn xml:");
            Console.WriteLine("-----------------------------------------------------");
            Console.WriteLine(xmlText);
        }

        static void DoGetUserAuth(string user, string password)
        {
            if ( verbose )
            {
                Console.WriteLine("");
                Console.WriteLine("RpsSiteName: " + rpsSiteName);
                Console.WriteLine("GetUserAuthUrl: " + UacsSvcUrl + "/GetUserAuthorization");
            }

            string ticket = IdcrlUtil.GetRpsTicket(user, password, rpsSiteName, "hbi");

            if ( verbose )
            {
                Console.WriteLine("IdcrlTicket: " + ticket);
            }

            string getUserAuthParams = string.Format("serviceType={0}&titleId={1}",
                serviceType,
                serviceTitleId);

            string clientTypeHeader = serviceClientName;

            string xmlText = MakePostRequest(UacsSvcUrl + "/GetUserAuthorization", ticket, null, getUserAuthParams, clientTypeHeader, null);

            Console.WriteLine("");
            Console.WriteLine("UserAccount.GetUserAuthorization xml:");
            Console.WriteLine("-----------------------------------------------------");
            Console.WriteLine(xmlText);
        }

        static void DoGetPointsBalance(AuthState authState)
        {
            string xml = AuthSgWebMethods.GetPointsBalance(authState);

            Console.WriteLine("");
            Console.WriteLine("UserAccount.GetPointsBalance xml:");
            Console.WriteLine("-----------------------------------------------------");
            Console.WriteLine(xml);
        }

        static void DoGetPaymentInstruments(AuthState authState)
        {
            if ( verbose )
            {
                Console.WriteLine("");
                Console.WriteLine("RpsSiteName: " + rpsSiteName);
                Console.WriteLine("SignInUrl: " + UacsSvcUrl + "/SignIn");
                Console.WriteLine("GetPointsBalanceUrl: " + UacsSvcUrl + "/GetPointsBalance");
            }

            string xml = AuthSgWebMethods.GetPaymentInstruments(authState);

            Console.WriteLine("");
            Console.WriteLine("UserAccount.GetPaymentInstruments xml:");
            Console.WriteLine("-----------------------------------------------------");
            Console.WriteLine(xml);
        }

        static void DoAddCreditCard(AuthState authState)
        {
            string expirationYear = (DateTime.UtcNow.Year + 3).ToString("d");

            string xml = AuthSgWebMethods.AddCreditCard(
                authState,
                "123 Elm St.",      // street1
                "",                 // street2
                "Eek",              // city
                "",                 // district
                "AK",               // state
                "99578",            // postal code
                "111",              // phone prefix
                "555-1212",         // phone number
                "",                 // extension
                0,                  // card type of Visa
                "John Smith",       // account holder name
                "4111111111111111", // account number
                "111",              // card verification number
                "11",               // expiration month
                expirationYear      // expiration year
                );

            Console.WriteLine("");
            Console.WriteLine("UserAccount.AddCreditCard xml:");
            Console.WriteLine("-----------------------------------------------------");
            Console.WriteLine(xml);
        }

        static void DoPurchasePointsBundle(AuthState authState, ulong offerId)
        {
            string piId = GetFirstPaymentInstrumentId(authState);

            int paymentType = 1; // credit card

            string xml = AuthSgWebMethods.PurchaseBillingOffer(authState, offerId, paymentType, piId, string.Empty);
        }

        static void DoPurchaseSubscription(AuthState authState, ulong offerId, string billingToken)
        {
            if ( string.IsNullOrEmpty(billingToken) )
            {
                string piId = GetFirstPaymentInstrumentId(authState);

                DoPurchaseBillingOfferPI(authState, offerId, piId);
            }
            else
            {
                int paymentType = 2; // token
                
                string xml = AuthSgWebMethods.PurchaseBillingOffer(authState, offerId, paymentType, string.Empty, billingToken);
            }
        }

        static void DoCancelSubscription(AuthState authState, ulong offerId, bool undoDelayedCancel)
        {
            string xml = AuthSgWebMethods.CancelSubscription(authState, offerId, undoDelayedCancel);
        }

        static string GetFirstPaymentInstrumentId(AuthState authState)
        {
            string getPiXml = AuthSgWebMethods.GetPaymentInstruments(authState);

            // find the first payment instrument id in the returned XML
            string piId = GetPaymentInstrumentIdFromGetPaymentInstrumentResults(getPiXml);

            if ( string.IsNullOrEmpty(piId) )
            {
                string errMsg = "No payment instrument found for user: 0x" + authState.UserPuid.ToString("x") + ".  Unable to purchase points!";
                Console.Error.WriteLine(errMsg);
                throw new Exception(errMsg);
            }

            return piId;
        }

        static void DoPurchaseBillingOfferPI(AuthState authState, ulong offerId, string piId)
        {
            int paymentType = 1; // credit card

            string xml = AuthSgWebMethods.PurchaseBillingOffer(authState, offerId, paymentType, piId, string.Empty);
        }

        static void DoSubscriptionEnumerate(AuthState authState, uint titleId, bool queryForNew, bool queryForRenewals, bool queryForCurrent, bool queryForCancelled, bool queryForSuspended)
        {
            if ( verbose )
            {
                Console.WriteLine("");
                Console.WriteLine("RpsSiteName: " + rpsSiteName);
                Console.WriteLine("SignInUrl: " + UacsSvcUrl + "/SignIn");
                Console.WriteLine("SubscriptionEnumerateUrl: " + XbosSvcUrl + "/SubscriptionEnumerate");
            }

            uint offerType = 5; // NEW | RENEWAL

            uint paymentType = 1; // CreditCard

            string xml = AuthSgWebMethods.SubscriptionEnumerate(authState, offerType, paymentType, titleId, queryForNew, queryForRenewals, queryForCurrent, queryForCancelled, queryForSuspended);

            Console.WriteLine("");
            Console.WriteLine("Billing.SubscriptionEnumerate xml:");
            Console.WriteLine("-----------------------------------------------------");
            Console.WriteLine(xml);
        }

        static void DoVerifyToken(AuthState authState, string billingToken, int storeId)
        {
            if ( verbose )
            {
                Console.WriteLine("");
                Console.WriteLine("RpsSiteName: " + rpsSiteName);
                Console.WriteLine("SignInUrl: " + UacsSvcUrl + "/SignIn");
                Console.WriteLine("VerifyToken: " + XbosSvcUrl + "/VerifyToken");
            }

            string xml = AuthSgWebMethods.VerifyToken(authState, billingToken, storeId);

            Console.WriteLine("");
            Console.WriteLine("Billing.VerifyToken xml:");
            Console.WriteLine("-----------------------------------------------------");
            Console.WriteLine(xml);
        }

        static WCMusic GetWCMusic()
        {
            WCMusic mw = null;

            if ( useXblob )
            {
                // Get server related information.
                IPHostEntry xblobServer = Dns.GetHostEntry(xblobHostname);
                IPAddress xblobAddr = null;

                // find the IPv4 address of the XBLOB
                foreach (IPAddress ipAddr in xblobServer.AddressList)
                {
                    if ( ipAddr.AddressFamily == AddressFamily.InterNetwork )
                    {
                        xblobAddr = ipAddr;
                        break;
                    }
                }

                if ( xblobAddr == null )
                {
                    throw new Exception("No IPv4 address found!");
                }

                IPEndPoint ep = new IPEndPoint(xblobAddr, 12000);

                mw = new WCMusic(ep);
            }
            else
            {
                X509Certificate cert = LookupCertificate(certName);
                if ( cert == null )
                {
                    throw new Exception("ArgoAcctMgr: certificate: " + certName + ": not found in either computer account or current user certificate stores!");
                }

                mw = new WCMusic(webSvcUrl, cert);
            }

            return mw;
        }

        static X509Certificate LookupCertificate(string certSubject)
        {
            X509Certificate cert = null;

            // First, try finding the certificate in the computer account's certificate
            // store.  If it doesn't exist there, then try the current user's certificate
            // store instead.
            try
            {
                cert = CertUtil.GetLocalMachineCertificate(certSubject);
            }
            catch (Exception)
            {
                cert = null;
            }

            if ( cert == null )
            {
                try
                {
                    cert = CertUtil.GetCurrentUserCertificate(certSubject);
                }
                catch (Exception)
                {
                    cert = null;
                }
            }

            return cert;
        }

        static AuthenticateAccountResult GetAuthenticationResults(string user, string password)
        {
            // get an RPS ticket from the passport name and password
            //string ticket = GetRpsTicket(user, password);
            string ticket = IdcrlUtil.GetRpsTicket(user, password, cruxRpsSiteName, "mbi");

            // call AuthenticateAccount
            WCMusic mw = GetWCMusic();
            AuthenticateAccountResult aaResult = mw.AuthenticateAccount(retailerId, ticket);

            return aaResult;
        }

        static void CreateNewAccount(bool addPoints, bool addSubscription)
        {
            // call AuthenticateAccount
            WCMusic mw = GetWCMusic();
            TestCreateAccountResult tcaResult = mw.TestCreateAccount(addPoints, addSubscription);

            // get an RPS ticket for the newly-created account
            //string ticket = GetRpsTicket(tcaResult.passportMemberNameField, tcaResult.passportPasswordField);
            string ticket = IdcrlUtil.GetRpsTicket(tcaResult.passportMemberNameField, tcaResult.passportPasswordField, rpsSiteName, "mbi");

#if false
            // make sure the account actually authenticates
            AuthenticateAccountResult aaResult = mw.AuthenticateAccount(retailerId, ticket);

            if ( addPoints && aaResult.balanceField <= 0 )
            {
                throw new Exception("ArgoAcctMgr: attempted to create account with points but no points returned!");
            }

            if ( addSubscription && aaResult.subscriptionField == null )
            {
                throw new Exception("ArgoAcctMgr: attempted to create account with a subscription but no subscription returned!");
            }
#endif

            Console.WriteLine("");
            Console.WriteLine("account created: " + tcaResult.passportMemberNameField);
            Console.WriteLine("-----------------------------------------------------");
#if false
            PrintAccountStatus(aaResult);
#else
            string xmlText = GetSignInResults(ticket);
            PrintAccountStatus(xmlText);
#endif
        }

        static void CreateBulkAccounts(bool addPoints, bool addSubscription, int bulkCount)
        {
            // call AuthenticateAccount
            WCMusic mw = GetWCMusic();

            int failures = 0;

            Console.WriteLine("");
            Console.WriteLine("accounts to create: " + bulkCount + ", subscription: " + addSubscription.ToString().ToLower() + ", points: " + ( addPoints == false ? "0" : "12000") );
            Console.WriteLine("----------------------------------------------------------");

            for (int i=1; i <= bulkCount; i++)
            {
                try
                {
                    TestCreateAccountResult tcaResult = mw.TestCreateAccount(addPoints, addSubscription);
                    // get an RPS ticket for the newly-created account
                    //string ticket = GetRpsTicket(tcaResult.passportMemberNameField, tcaResult.passportPasswordField);
                    string ticket = IdcrlUtil.GetRpsTicket(tcaResult.passportMemberNameField, tcaResult.passportPasswordField, cruxRpsSiteName, "mbi");

                    // make sure the account actually authenticates
#if false
                    AuthenticateAccountResult aaResult = mw.AuthenticateAccount(retailerId, ticket);
                    if ( addPoints && aaResult.balanceField <= 0 )
                    {
                        throw new Exception("ArgoAcctMgr: attempted to create account with points but no points returned!");
                    }

                    if ( addSubscription && aaResult.subscriptionField == null )
                    {
                        throw new Exception("ArgoAcctMgr: attempted to create account with a subscription but no subscription returned!");
                    }
#else
                    string xmlText = GetSignInResults(ticket);

                    if ( addPoints && xmlText.IndexOf("<PointsBalance>0</PointsBalance>") != -1 )
                    {
                        throw new Exception("ArgoAcctMgr: attempted to create account with points but no points returned!");
                    }

                    if ( addSubscription && xmlText.IndexOf("<SubscriptionInfo>") == -1 )
                    {
                        throw new Exception("ArgoAcctMgr: attempted to create account with a subscription but no subscription returned!");
                    }
#endif

                    Console.WriteLine(i.ToString("d3") + ":     " + tcaResult.passportMemberNameField);
                }
                catch (Exception)
                {
                    failures++;
                    if ( failures >= 5 )
                    {
                        Console.Error.WriteLine("ArgoAcctMgr: encountered at least 5 failures attempting to bulk create " + bulkCount + " accounts.  Aborting...");
                        throw;
                    }

                    i--;
                    continue;
                }
            }
        }

        static void GetAccountStatus(string user, string password)
        {
            Console.WriteLine("");
            Console.WriteLine("account status: " + user);
            Console.WriteLine("-----------------------------------------------------");
            AuthenticateAccountResult aaResult = GetAuthenticationResults(user, password);
            PrintAccountStatus(aaResult);
        }

        static void PrintAccountStatus(AuthenticateAccountResult aaResult)
        {
            Console.WriteLine("  balance: " + aaResult.balanceField);

            string subscriptionStatus = "none";
            if ( aaResult.subscriptionField != null )
            {
                SubscriptionSku sku = aaResult.subscriptionField.subscriptionSkuField;
                subscriptionStatus = sku.paymentTypeField + " " + sku.paymentCycleField + " ($" + sku.paymentCyclePriceField + ", XOID: 0x" + sku.skuField + ", MNet SKU: " + sku.fulfillmentSkuField + ")";
            }
            Console.WriteLine("  subscription: " + subscriptionStatus);
            Console.WriteLine("  customerId: " + aaResult.customerIdField);
            Console.WriteLine("  accountStatus: " + aaResult.accountStatusField);

            UserPrivileges up = new UserPrivileges(aaResult.userPrivilegesField);
            string userPrivileges =
                "PURCHASE_CONTENT=" + up[XOn.XPRIVILEGE_PURCHASE_CONTENT].ToString().ToLower() + ", " +
                "EXPLICIT_CONTENT=" + up[XOn.XPRIVILEGE_MUSIC_EXPLICIT_CONTENT].ToString().ToLower();
            Console.WriteLine("  userPrivileges:" + userPrivileges);

#if false
            Console.WriteLine("  grantedPrivileges:");
            for (int i=XOn.XPRIVILEGE_MIN; i <= XOn.XPRIVILEGE_MAX; i++)
            {
                if ( up[i] )
                {
                    Console.WriteLine("    " + i);
                }
            }

            Console.WriteLine("  missingPrivileges:");
            for (int i=XOn.XPRIVILEGE_MIN; i <= XOn.XPRIVILEGE_MAX; i++)
            {
                if ( !up[i] )
                {
                    Console.WriteLine("    " + i);
                }
            }
#endif
        }

        static void PrintAccountStatus(string signInXml)
        {
            XmlDocument xml = new XmlDocument();
            xml.LoadXml(signInXml);

            XmlNamespaceManager nsm = new XmlNamespaceManager(xml.NameTable);
            nsm.AddNamespace("xsd", "http://www.w3.org/2001/XMLSchema");
            nsm.AddNamespace("def", "urn:schemas-xbox-com:user-account-data");
            nsm.AddNamespace("xsi","http://www.w3.org/2001/XMLSchema-instance");

            XmlNode node;

            node = xml.SelectSingleNode("/def:SignInResults/def:AccountInfo/def:PointsBalance", nsm);
            if ( node != null )
            {
                uint balance = UInt32.Parse(node.InnerText);
                Console.WriteLine("  balance: " + balance.ToString());
            }
            else
            {
                Console.Error.WriteLine("Unable to parse PointsBalance from SignInResults XML!");
            }

            string subscriptionStatus = "none";
            if ( signInXml.IndexOf("<SubscriptionInfo>") >= 0 )
            {
                node = xml.SelectSingleNode("/def:SignInResults/def:SubscriptionInfo/def:XboxOfferId", nsm);
                if ( node != null )
                {
                    ulong xoid = UInt64.Parse(node.InnerText);
                    subscriptionStatus = "XOID: 0x" + xoid.ToString("x");

                    node = xml.SelectSingleNode("/def:SignInResults/def:SubscriptionInfo/def:MusicNetSku", nsm);
                    if ( node != null )
                    {
                        string musicNetSku = node.InnerText;
                        subscriptionStatus += ", MNet SKU: " + musicNetSku;
                    }
                }
            }
            Console.WriteLine("  subscription: " + subscriptionStatus);

            node = xml.SelectSingleNode("/def:SignInResults/def:AccountInfo/def:XboxPuid", nsm);
            if ( node != null )
            {
                ulong customerId = UInt64.Parse(node.InnerText);
                Console.WriteLine("  customerId: " + customerId.ToString("x"));
            }
            else
            {
                Console.Error.WriteLine("Unable to parse XboxPuid from SignInResults XML!");
            }

            //Console.WriteLine("  accountStatus: " + aaResult.accountStatusField);

#if false
            UserPrivileges up = new UserPrivileges(aaResult.userPrivilegesField);
            string userPrivileges =
                "PURCHASE_CONTENT=" + up[XOn.XPRIVILEGE_PURCHASE_CONTENT].ToString().ToLower() + ", " +
                "EXPLICIT_CONTENT=" + up[XOn.XPRIVILEGE_MUSIC_EXPLICIT_CONTENT].ToString().ToLower();
            Console.WriteLine("  userPrivileges:" + userPrivileges);
#endif

#if false
            Console.WriteLine("  grantedPrivileges:");
            for (int i=XOn.XPRIVILEGE_MIN; i <= XOn.XPRIVILEGE_MAX; i++)
            {
                if ( up[i] )
                {
                    Console.WriteLine("    " + i);
                }
            }

            Console.WriteLine("  missingPrivileges:");
            for (int i=XOn.XPRIVILEGE_MIN; i <= XOn.XPRIVILEGE_MAX; i++)
            {
                if ( !up[i] )
                {
                    Console.WriteLine("    " + i);
                }
            }
#endif
        }

        public static string GetRpsTicket(string membername, string password)
        {
            string passportLoginUrl = "https://login.passport-int.com/ppsecure/clientpost.srf?id=" + rpsSiteId + "&wp=mbi";

            string content =
                "<LoginRequest>" +
                    "<ClientInfo name=\"\" version=\"1.35\"/>" +
                    "<User>" +
                        "<SignInName>" + HttpUtility.HtmlEncode(membername) + "</SignInName>" +
                        "<Password>" + HttpUtility.HtmlEncode(password) + "</Password>" +
                        "<SavePassword>false</SavePassword>" +
                    "</User>" +
                "</LoginRequest>";

            HttpWebRequest req = WebRequest.Create(passportLoginUrl) as HttpWebRequest;
            req.Method = "POST";
            req.KeepAlive = false;
            req.ContentType = "text/xml";
            req.ContentLength = content.Length;

            StreamWriter sw = new StreamWriter(req.GetRequestStream());
            sw.Write(content);
            sw.Close();

            try
            {
                HttpWebResponse resp = (HttpWebResponse) req.GetResponse();
                StreamReader sr = new StreamReader(resp.GetResponseStream());

                // read xml results
                string xml = sr.ReadToEnd();

                int start = xml.IndexOf("t=", 0);
                int end = xml.IndexOf("&amp;", start);

                string ticket = xml.Substring(start, end - start);
                return ticket;
            }
            catch (Exception e)
            {
                Console.Error.WriteLine("Exception: " + e);
                throw;
            }
        }

        static string GetSignInResults(string user, string password, string rpsSiteName)
        {
            string ticket = IdcrlUtil.GetRpsTicket(user, password, rpsSiteName, "mbi");
            string xmlText = MakePostRequest(UacsSvcUrl + "/SignIn", ticket, null, "");
            return xmlText;
        }

        static string GetSignInResults(string ticket)
        {
            string xmlText = MakePostRequest(UacsSvcUrl + "/SignIn", ticket, null, "");
            return xmlText;
        }

        static ulong GetXuidFromSignInResults(string xmlText)
        {
            XmlDocument xml = new XmlDocument();
            xml.LoadXml(xmlText);

            XmlNamespaceManager nsm = new XmlNamespaceManager(xml.NameTable);
            nsm.AddNamespace("xsd", "http://www.w3.org/2001/XMLSchema");
            nsm.AddNamespace("def", "urn:schemas-xbox-com:user-account-data");
            nsm.AddNamespace("xsi","http://www.w3.org/2001/XMLSchema-instance");

            XmlNode node = xml.SelectSingleNode("/def:SignInResults/def:AccountInfo/def:XboxPuid", nsm);
            return (node == null) ? 0 : UInt64.Parse(node.InnerText);
        }

        static ulong GetOfferIdFromSubscriptionEnumResults(string xmlText)
        {
            XmlDocument xml = new XmlDocument();
            xml.LoadXml(xmlText);

            XmlNamespaceManager nsm = new XmlNamespaceManager(xml.NameTable);
            nsm.AddNamespace("xsd", "http://www.w3.org/2001/XMLSchema");
            nsm.AddNamespace("def", "urn:schemas-xbox-com:billing-data");
            nsm.AddNamespace("xsi","http://www.w3.org/2001/XMLSchema-instance");

            //<SubscriptionEnumerateResults xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="urn:schemas-xbox-com:billing-data">
            //  <SubscriptionInfos>
            //    <SubscriptionInfo>
            //      <OfferId>18446189720133173274</OfferId>

            XmlNode node = xml.SelectSingleNode("/def:SubscriptionEnumerateResults/def:SubscriptionInfos/def:SubscriptionInfo/def:OfferId", nsm);

            return (node == null) ? 0 : UInt64.Parse(node.InnerText);
        }

        static ulong GetOfferIdFromVerifyTokenResults(string xmlText)
        {
            XmlDocument xml = new XmlDocument();
            xml.LoadXml(xmlText);

            XmlNamespaceManager nsm = new XmlNamespaceManager(xml.NameTable);
            nsm.AddNamespace("xsd", "http://www.w3.org/2001/XMLSchema");
            nsm.AddNamespace("def", "urn:schemas-xbox-com:billing-data");
            nsm.AddNamespace("xsi","http://www.w3.org/2001/XMLSchema-instance");

            XmlNode node = xml.SelectSingleNode("/def:VerifyTokenResults/def:xboxOfferInfo/def:offerId", nsm);
            return (node == null) ? 0 : UInt64.Parse(node.InnerText);
        }

        static string GetPaymentInstrumentIdFromGetPaymentInstrumentResults(string xmlText)
        {
            XmlDocument xml = new XmlDocument();
            xml.LoadXml(xmlText);

            XmlNamespaceManager nsm = new XmlNamespaceManager(xml.NameTable);
            nsm.AddNamespace("xsd", "http://www.w3.org/2001/XMLSchema");
            nsm.AddNamespace("def", "urn:schemas-xbox-com:user-account-data");
            nsm.AddNamespace("xsi","http://www.w3.org/2001/XMLSchema-instance");

            XmlNode node = xml.SelectSingleNode("/def:GetPaymentInstrumentResults/def:PaymentInstrumentInfos/def:PaymentInstrumentInfo/def:PaymentInstrumentId", nsm);
            return (node == null) ? "" : node.InnerText;
        }

        internal static string MakePostRequest(string url, string rpsTicket, string clientVersion, string content)
        {
            return MakePostRequest(url, rpsTicket, clientVersion, content, null, null);
        }

        internal static string MakePostRequest(string url, string rpsTicket, string clientVersion, string content, string clientTypeHeader, string xpltHeader)
        {
            //xonline.common.config.IVirtualInterfaceInfo vii = xonline.common.config.Config.GetVirtualInterface(xonline.common.config.VirtualInterface.crux, Config.MainSiteId);

            //string cruxUrl = "http://" + vii.IPAddressString + ":" + vii.Port + "/crux/crux.asmx";
            //Console.WriteLine("CruxSignIn url: " + cruxSvcUrl);

            // if https, provide a cert validation callback to handle expected policy errors
            if ( url.StartsWith("https:") )
            {
                ServicePointManager.ServerCertificateValidationCallback =
                    new RemoteCertificateValidationCallback(MyCertValidationCb);
            }

            if ( verbose )
            {
                Console.WriteLine("Url: " + url);
            }

            // Post
            HttpWebRequest httpReq = (HttpWebRequest) WebRequest.Create( url );
            httpReq.Method = "POST";
            httpReq.ContentType = "application/x-www-form-urlencoded"; //"text/xml";
            httpReq.ContentLength = (content == null) ? 0 : content.Length;
            if ( rpsTicket != null )
            {
                httpReq.Headers.Add("Authorization", "WLID1.0 " + rpsTicket);
            }
            if ( clientVersion != null )
            {
                httpReq.Headers.Add("X-Client-Version", clientVersion);
            }
            if ( clientTypeHeader != null )
            {
                httpReq.Headers.Add("X-ClientType", clientTypeHeader);
            }
            if ( xpltHeader != null )
            {
                httpReq.Headers.Add("XPLT", xpltHeader);
            }
            if ( !string.IsNullOrEmpty(behaviorHeader) )
            {
                httpReq.Headers.Add("BEHAVIOR_INJECTIONS", behaviorHeader);
            }

            if ( proxy != null )
            {
                httpReq.Proxy = proxy;
            }

            if ( !string.IsNullOrEmpty(content) )
            {
                httpReq.ContentLength = content.Length;

                StreamWriter sw = new StreamWriter(httpReq.GetRequestStream(), System.Text.Encoding.ASCII);
                sw.Write(content);
                sw.Close();
            }

            HttpWebResponse httpRep = (HttpWebResponse) httpReq.GetResponse();
            StreamReader sr = new StreamReader(httpRep.GetResponseStream());
            string xml = sr.ReadToEnd();
            return xml;
        }

        public static bool MyCertValidationCb(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
        {
            // production has a valid SSL cert and if so, no errors will occur
            if ( sslPolicyErrors == SslPolicyErrors.None )
            {
                return true;
            }

            if ( (sslPolicyErrors & SslPolicyErrors.RemoteCertificateChainErrors) == SslPolicyErrors.RemoteCertificateChainErrors )
            {
                return false;
            }
            else if ( (sslPolicyErrors & SslPolicyErrors.RemoteCertificateNameMismatch) == SslPolicyErrors.RemoteCertificateNameMismatch )
            {
#if false
                Zone z;
                z = Zone.CreateFromUrl(((HttpWebRequest)sender).RequestUri.ToString());

                if (z.SecurityZone == System.Security.SecurityZone.Intranet
                    || z.SecurityZone == System.Security.SecurityZone.MyComputer)
                {
                    return true;
                }

                return false;
#else
                return true;
#endif
            }

            return false;
        }

        static void Usage()
        {
            Console.WriteLine("Usage: ");
            Console.WriteLine("");
            Console.WriteLine("    ArgoAcctMgr -new[:<count>] [-nopoints|-points] [-nosubscription|-subscription] (default: -points -subscription)");
            Console.WriteLine("");
            Console.WriteLine("    ArgoAcctMgr -status -user:<userid> [-password:<password>] (default: -password:secret)");
            Console.WriteLine("");
            Console.WriteLine("    ArgoAcctMgr -testconnection");
            Console.WriteLine("");
            Console.WriteLine("");
            Console.WriteLine("    Troubleshooting options:");
            Console.WriteLine("");
            Console.WriteLine("    ArgoAcctMgr -signin -user:<userid> [-password:<password>] (default: -password:secret)");
            Console.WriteLine("    ArgoAcctMgr -balance -user:<userid> [-password:<password>] (default: -password:secret)");
            Console.WriteLine("");
            Console.WriteLine("    Advanced options:");
            Console.WriteLine("");
            Console.WriteLine("    -aaHost:<hostname-or-ip-address>     - ActiveAuth IP address");
            Console.WriteLine("    -aaPort:<hostname-or-ip-address>     - ActiveAuth port (defaults to 443)");
            Console.WriteLine("    -rpssitename:<aa-rps-sitename>       - RPS sitename used by ActiveAuth");
            Console.WriteLine("    -cruxrpssitename:<crux-rps-sitename> - RPS sitename used by WCMusic Crux APIs");
            Console.WriteLine("    -websghost:<hostname-or-ipaddress>   - WebSG IP address");
            Console.WriteLine("    -certname:<subject-name>             - WebSG partner certificate subject name");
            Console.WriteLine("");
        }

    } //ArgoAcctMgr


    class IdcrlUtil
    {
        static IdcrlUtil()
        {
            Guid appGuid = new Guid("28880461-ed9b-4911-b691-474503c690e7");
            const int PPCRL_VERSION = 1;

            ManagedIDCRL.Initialize_Options[] initOps = new ManagedIDCRL.Initialize_Options[1];
            initOps[0].optionType = ManagedIDCRL.IDCRL_OPTION_ID.IDCRL_OPTION_ENVIRONMENT;
            initOps[0].proxyUserInfo = ArgoAcctMgr.PassportEnv;

            _msidcrl = new ManagedIDCRL();
            _msidcrl.InitializeEx(ref appGuid, PPCRL_VERSION, (uint)ManagedIDCRL.UpdateFlag.DEFAULT_UPDATE_POLICY, initOps);
        }

        public static string GetRpsTicket(string user, string password, string partner, string policy)
        {
            //ManagedIDCRL.LogonState logonState;
            ManagedIDCRL.AuthState authState;
            int identity;

            _msidcrl.CreateIdentityHandle(user, (uint)ManagedIDCRL.IdentityFlag.IDENTITY_SHARE_ALL, out identity);
            _msidcrl.SetCredential(identity, ManagedIDCRL.PPCRL_CREDTYPE_PASSWORD, password);
            _msidcrl.LogonIdentity(identity, null, (uint)ManagedIDCRL.LogonFlag.LOGONIDENTITY_DEFAULT);
            _msidcrl.AuthIdentityToService(identity, partner, policy, (uint)ManagedIDCRL.ServiceTokenFlags.SERVICE_TOKEN_REQUEST_TYPE_NONE, out authState);

            return authState.Token;
        }

        private static ManagedIDCRL _msidcrl = null;
    }

    class UserPrivileges
    {
        byte[] privileges;

        public UserPrivileges(byte[] privileges)
        {
            this.privileges = privileges;
        }

        public bool this[int index]
        {
            get
            {
                byte b = privileges[index/8];
                int mask = (byte) 1 << (index % 8);
                return ( mask & b ) == mask;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ArgoAcctMgr\WCMusic.cs ===
using System;
using System.IO;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using System.Xml;

namespace xonline.tools.argoacctmgr
{
    public class WCMusic : Music
    {
        //protected RequestInfo requestInfo = null;
        public string AlternateMusicNetUrl = null;
        public string AlternateBillingUrl = null;
        public string InjectedScsError = null;
        public string AlternateDmpUrl = null;

        public WCMusic(IPEndPoint endpoint)
        {
            Url = "http://" + endpoint.ToString() + "/Music/Music.asmx";
            //requestInfo = new RequestInfo();
        }

        public WCMusic(IPEndPoint endpoint, X509Certificate certificate)
        {
            Url = "https://" + endpoint.ToString() + "/Music/Music.asmx";
            this.ClientCertificates.Add(certificate);
        }

        public WCMusic(string domain, X509Certificate certificate)
        {
            Url = "https://" + domain + "/Music/Music.asmx";
            this.ClientCertificates.Add(certificate);
        }

        override protected WebRequest GetWebRequest(Uri url)
        {
            WebRequest wr = base.GetWebRequest(new Uri(Url));

#if false
            if (requestInfo != null)
            {
                wr.Headers.Add("Subject-Name", requestInfo.SubjectName);
                wr.Headers.Add("Client-IP-Port", requestInfo.ClientIPPort);
                wr.Headers.Add("RequestId", requestInfo.RequestId);
            }
#endif

            if (AlternateMusicNetUrl != null)
                wr.Headers.Add("AlternateMusicNetUrl", AlternateMusicNetUrl);
            if (AlternateBillingUrl != null)
                wr.Headers.Add("AlternateBillingUrl", AlternateBillingUrl);
            if (InjectedScsError != null)
                wr.Headers.Add("InjectedScsError", InjectedScsError);
            if (AlternateDmpUrl != null)
                wr.Headers.Add("AlternateDmpUrl", AlternateDmpUrl);

            return wr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ArgoAcctMgr\WebServiceMethods.cs ===
using System;
using System.Web;
using System.Xml;

using Microsoft.Passport.Test.Ppcrl;

namespace xonline.tools.argoacctmgr
{
    class IdcrlUtil2
    {
        public IdcrlUtil2(string passportEnv)
        {
            Guid appGuid = new Guid("28880461-ed9b-4911-b691-474503c690e7");
            const int PPCRL_VERSION = 1;

            ManagedIDCRL.Initialize_Options[] initOps = new ManagedIDCRL.Initialize_Options[1];
            initOps[0].optionType = ManagedIDCRL.IDCRL_OPTION_ID.IDCRL_OPTION_ENVIRONMENT;
            initOps[0].proxyUserInfo = passportEnv;

            _msidcrl = new ManagedIDCRL();
            _msidcrl.InitializeEx(ref appGuid, PPCRL_VERSION, (uint)ManagedIDCRL.UpdateFlag.DEFAULT_UPDATE_POLICY, initOps);
        }

        public string GetRpsTicket(string user, string password, string partner, string policy)
        {
            //ManagedIDCRL.LogonState logonState;
            ManagedIDCRL.AuthState authState;
            int identity;

            _msidcrl.CreateIdentityHandle(user, (uint)ManagedIDCRL.IdentityFlag.IDENTITY_SHARE_ALL, out identity);
            _msidcrl.SetCredential(identity, ManagedIDCRL.PPCRL_CREDTYPE_PASSWORD, password);
            _msidcrl.LogonIdentity(identity, null, (uint)ManagedIDCRL.LogonFlag.LOGONIDENTITY_DEFAULT);
            _msidcrl.AuthIdentityToService(identity, partner, policy, (uint)ManagedIDCRL.ServiceTokenFlags.SERVICE_TOKEN_REQUEST_TYPE_NONE, out authState);

            return authState.Token;
        }

        private ManagedIDCRL _msidcrl = null;
    }

        public enum XlsEnvEnum
        {
            ArgoNet,
            BvtNet,
            CertNet,
            Prod,
            StressNet,
            StressNet2,
            TestNet,
            TestNetZ,
            Xblob,
        }

    public class XlsEnv
    {
        public XlsEnv() : this(XlsEnvEnum.ArgoNet)
        {
        }

        public XlsEnv(XlsEnvEnum xenv)
        {
            _xlsEnvEnum = xenv;
            _authSgPort = 443;
            _passportEnv = "int";

            switch (xenv)
            {
            case XlsEnvEnum.Prod:
                _authSgHost = "activeauth.xboxlive.com";
                _authSgRpsSiteName = "kdc.xboxlive.com";
                _passportEnv = "production";
                break;
            case XlsEnvEnum.Xblob:
                _authSgPort = 13100;
                _authSgProtocol = "http";
                _authSgRpsSiteName = "kdc.test.xboxlive.com";
                break;
            case XlsEnvEnum.TestNet:
                _authSgHost = "10.198.102.47";
                _authSgRpsSiteName = "kdc.test.xboxlive.com";
                break;
            case XlsEnvEnum.ArgoNet:
                _authSgHost = "131.107.28.202";
                _authSgRpsSiteName = "Int-rps.xboxlive.com";
                break;
            default:
                _authSgHost = "131.107.28.202";
                _authSgRpsSiteName = "Int-rps.xboxlive.com";
                break;
            }
        }

        public string AuthSgHost
        {
            get { return _authSgHost; }
            set { _authSgHost = value; }
        }

        public int AuthSgPort
        {
            get { return _authSgPort; }
            set { _authSgPort = value; }
        }

        public string AuthSgProtocol
        {
            get { return _authSgProtocol; }
            set { _authSgProtocol = value; }
        }

        public string AuthSgRpsSiteName
        {
            get { return _authSgRpsSiteName; }
            set { _authSgRpsSiteName = value; }
        }

        public string PassportEnv
        {
            get { return _passportEnv; }
            set { _passportEnv = value; }
        }

        public XlsEnvEnum XlsEnvEnum
        {
            get { return _xlsEnvEnum; }
        }

        public string UacsSvcUrl
        {
            get
            {
                return string.Format("{0}://{1}:{2}/xuacs/useraccount.asmx", AuthSgProtocol, AuthSgHost, AuthSgPort);
            }
        }

        public string XbosSvcUrl
        {
            get
            {
                return string.Format("{0}://{1}:{2}/xbos/billing.asmx", AuthSgProtocol, AuthSgHost, AuthSgPort);
            }
        }

        public AuthState GetAuthState(string user, string password, bool isZune)
        {
            return GetAuthState(user, password, "hbi", isZune);
        }

        public AuthState GetAuthState(string user, string password, string policy, bool isZune)
        {
            IdcrlUtil2 idcrlUtil = new IdcrlUtil2(PassportEnv);
            string rpsTicket = idcrlUtil.GetRpsTicket(user, password, AuthSgRpsSiteName, policy);
            //string signInResults = ArgoAcctMgr.MakePostRequest(UacsSvcUrl + "/SignIn", rpsTicket, null, "");
            string authParams = "serviceType=1&titleId=4294838225"; // 0xFFFE07D1
            string clientType = "Panorama";

            if ( isZune )
            {
                authParams = "serviceType=2&titleId=4294838135"; // 0xFFFE0777
                clientType = "Dorado";
            }

            string signInResults = ArgoAcctMgr.MakePostRequest(UacsSvcUrl + "/GetUserAuthorization", rpsTicket, null, authParams, clientType, null);

            XmlDocument signInXml = new XmlDocument();
            signInXml.LoadXml(signInResults);

            ulong xuid = AuthState.GetXuidFromGetUserAuthorizationInfo(signInXml);

            return new AuthState(this, rpsTicket, signInXml, xuid);
        }

        //private string _rpsSiteName;
        private string      _authSgHost;
        private int         _authSgPort = 443;
        private string      _authSgProtocol = "https";
        private string      _authSgRpsSiteName;
        private string      _passportEnv = "int";
        private XlsEnvEnum  _xlsEnvEnum;
    }

    public class AuthState
    {
        public AuthState(XlsEnv xlsEnv, string rpsTicket, XmlDocument signInXml, ulong userPuid)
        {
            _xlsEnv = xlsEnv;
            _rpsTicket = rpsTicket;
            _signInResults = signInXml;
            _userPuid = userPuid;
        }

        public string RpsTicket
        {
            get { return _rpsTicket; }
        }

        public ulong UserPuid
        {
            get
            {
                return ( _userPuid.HasValue ? _userPuid.Value : 0 );
            }
        }

        public string SignInResults
        {
            get
            {
                string signInXml = _signInResults == null ? "" : _signInResults.OuterXml;

                return string.IsNullOrEmpty(signInXml) ? "" : signInXml;
            }
        }

        public XlsEnv XlsEnv
        {
            get { return _xlsEnv; }
        }

        internal static ulong GetXuidFromSignInResults(XmlDocument signInXml)
        {
            XmlNamespaceManager nsm = new XmlNamespaceManager(signInXml.NameTable);
            nsm.AddNamespace("xsd", "http://www.w3.org/2001/XMLSchema");
            nsm.AddNamespace("def", "urn:schemas-xbox-com:user-account-data");
            nsm.AddNamespace("xsi","http://www.w3.org/2001/XMLSchema-instance");

            XmlNode node = signInXml.SelectSingleNode("/def:SignInResults/def:AccountInfo/def:XboxPuid", nsm);

            ulong xuid = 0;
            try
            {
                if ( node != null )
                {
                    xuid = UInt64.Parse(node.InnerText);
                }
            }
            catch (Exception)
            {
            }

            return xuid;
        }

        internal static ulong GetXuidFromGetUserAuthorizationInfo(XmlDocument signInXml)
        {
            XmlNamespaceManager nsm = new XmlNamespaceManager(signInXml.NameTable);
            nsm.AddNamespace("xsd", "http://www.w3.org/2001/XMLSchema");
            nsm.AddNamespace("def", "urn:schemas-xbox-com:user-account-data");
            nsm.AddNamespace("xsi","http://www.w3.org/2001/XMLSchema-instance");

            XmlNode node = signInXml.SelectSingleNode("/def:GetUserAuthorizationInfo/def:AccountInfo/def:XboxPuid", nsm);

            ulong xuid = 0;
            try
            {
                if ( node != null )
                {
                    xuid = UInt64.Parse(node.InnerText);
                }
            }
            catch (Exception)
            {
            }

            return xuid;
        }

        internal XlsEnv _xlsEnv;
        internal string _rpsTicket;
        internal XmlDocument _signInResults;
        internal ulong? _userPuid;
    }

    public class AuthSgWebMethods
    {
        public static string GetPointsBalance(AuthState authState)
        {
            string url = authState.XlsEnv.UacsSvcUrl + "/GetPointsBalance";

            string paramsString = string.Format("userPuid={0}&machinePuid=0", authState.UserPuid.ToString("d"));

            string xmlResponse = ArgoAcctMgr.MakePostRequest(url, authState.RpsTicket, null, paramsString);

            return xmlResponse;
        }

        public static string GetPaymentInstruments(AuthState authState)
        {
            string url = authState.XlsEnv.UacsSvcUrl + "/GetPaymentInstruments";

            string paramsString = string.Format("userPuid={0}&machinePuid=0", authState.UserPuid.ToString("d"));

            string xmlResponse = ArgoAcctMgr.MakePostRequest(url, authState.RpsTicket, null, paramsString);

            return xmlResponse;
        }

        public static string AddCreditCard(
            AuthState authState,
            string addressStreet1,
            string addressStreet2,
            string addressCity,
            string addressDistrict,
            string addressState,
            string addressPostalCode,
            string phonePrefix,
            string phoneNumber,
            string phoneExtension,
            byte cardType,
            string accountHolderName,
            string accountNumber,
            string cardVerificationNumber,
            string expirationMonth,
            string expirationYear
            )
        {
            string url = authState.XlsEnv.UacsSvcUrl + "/AddCreditCard";

            string expirationDate = expirationMonth + "/" + expirationYear;

            const string addCcParamsFormat =
                "userPuid={0}&" +
                "machinePuid=0&" +
                "addressStreet1={1}&" +
                "addressStreet2={2}&" +
                "addressCity={3}&" +
                "addressDistrict={4}&" +
                "addressState={5}&" +
                "addressPostalCode={6}&" +
                "phonePrefix={7}&" +
                "phoneNumber={8}&" +
                "phoneExtension={9}&" +
                "cardType={10}&" +
                "accountHolderName={11}&" +
                "accountNumber={12}&" +
                "cardVerificationNumber={13}&" +
                "expirationDate={14}";

            string addCcParams = string.Format(
                addCcParamsFormat,
                authState.UserPuid.ToString("d"),
                HttpUtility.UrlEncode(addressStreet1),
                HttpUtility.UrlEncode(addressStreet2),
                HttpUtility.UrlEncode(addressCity),
                HttpUtility.UrlEncode(addressDistrict),
                HttpUtility.UrlEncode(addressState),
                HttpUtility.UrlEncode(addressPostalCode),
                HttpUtility.UrlEncode(phonePrefix),
                HttpUtility.UrlEncode(phoneNumber),
                HttpUtility.UrlEncode(phoneExtension),
                cardType.ToString("d"),
                HttpUtility.UrlEncode(accountHolderName),
                HttpUtility.UrlEncode(accountNumber),
                HttpUtility.UrlEncode(cardVerificationNumber),
                HttpUtility.UrlEncode(expirationDate)
                );

            string xmlResponse = ArgoAcctMgr.MakePostRequest(url, authState.RpsTicket, null, addCcParams);

            return xmlResponse;
        }

        public static string PurchaseBillingOffer(AuthState authState, ulong offerId, int paymentType, string paymentInstrumentId, string billingToken)
        {
            string url = authState.XlsEnv.XbosSvcUrl + "/PurchaseBillingOffer";

            string purchaseBillingOfferFormat =
                "userPuid={0}&" +
                "machinePuid=0&" +
                "offerId={1}&" +
                "paymentType={2}&" +
                "paymentInstrumentId={3}&" + HttpUtility.UrlEncode(paymentInstrumentId) + "&" +
                "billingToken={4}";

            string purchaseParams = null;

            if ( paymentType == 1 )
            {
                purchaseParams = string.Format(
                    purchaseBillingOfferFormat,
                    authState.UserPuid.ToString("d"),
                    offerId.ToString("d"),
                    paymentType.ToString("d"),
                    HttpUtility.UrlEncode(paymentInstrumentId),
                    string.Empty);
            }
            else if ( paymentType == 2 )
            {
                purchaseParams = string.Format(
                    purchaseBillingOfferFormat,
                    authState.UserPuid.ToString("d"),
                    offerId.ToString("d"),
                    paymentType.ToString("d"),
                    string.Empty,
                    HttpUtility.UrlEncode(billingToken));
            }
            else
            {
                throw new ArgumentException("paymentType");
            }

            string xmlResponse = ArgoAcctMgr.MakePostRequest(url, authState.RpsTicket, null, purchaseParams);

            return xmlResponse;
        }

        public static string SubscriptionEnumerate(AuthState authState, uint offerType, uint paymentType, uint titleId, bool queryForNew, bool queryForRenewals, bool queryForCurrent, bool queryForCancelled, bool queryForSuspended)
        {
            string url = authState.XlsEnv.XbosSvcUrl + "/SubscriptionEnumerate";

            string subEnumParamsFormat =
                "userPuid={0}&" +
                "machinePuid=0&" +
                "offerType={1}&" +
                "paymentType={2}&" +
                "titleId={3}&" +
                "queryForNew={4}&" +
                "queryForRenewals={5}&" +
                "queryForCurrent={6}&" +
                "queryForCancelled={7}&" +
                "queryForSuspended={8}";

            string subEnumParams = string.Format(
                subEnumParamsFormat,
                authState.UserPuid.ToString("d"),
                offerType.ToString("d"),
                paymentType.ToString("d"),
                titleId.ToString("d"),
                queryForNew.ToString(),
                queryForRenewals.ToString(),
                queryForCurrent.ToString(),
                queryForCancelled.ToString(),
                queryForSuspended.ToString()
                );

            string xmlResponse = ArgoAcctMgr.MakePostRequest(url, authState.RpsTicket, null, subEnumParams);

            return xmlResponse;
        }

        public static string VerifyToken(AuthState authState, string billingToken, int storeId)
        {
            string url = authState.XlsEnv.XbosSvcUrl + "/VerifyToken";

            string verifyTokenParamsFormat =
                "userPuid={0}&" +
                "machinePuid=0&" +
                "billingToken={1}&" +
                "storeId={2}";

            string verifyTokenParams = string.Format(
                verifyTokenParamsFormat,
                authState.UserPuid.ToString("d"),
                billingToken,
                storeId.ToString("d")
                );

            string xmlResponse = ArgoAcctMgr.MakePostRequest(url, authState.RpsTicket, null, verifyTokenParams);

            return xmlResponse;
        }

        public static string CancelSubscription(AuthState authState, ulong offerId, bool undoDelayedCancel)
        {
            string url = authState.XlsEnv.XbosSvcUrl + "/CancelSubscription";

            string cancelSubParamsFormat =
                "userPuid={0}&" +
                "machinePuid=0&" +
                "offerId={1}&" +
                "undoDelayedCancel={2}";

            string cancelSubParams = string.Format(
                cancelSubParamsFormat,
                authState.UserPuid.ToString("d"),
                offerId.ToString("d"),
                undoDelayedCancel.ToString()
                );

            string xmlResponse = ArgoAcctMgr.MakePostRequest(url, authState.RpsTicket, null, cancelSubParams);

            return xmlResponse;
        }
    }
 }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\AzureRunner\app\AzureRunnerApp.cs ===
using System;
using System.IO;
using System.Net;
using xonline.common.console;

namespace xonline.tools.AzureRunner
{
    class AzureRunnerApp
    {
        static int Main(string[] args)
        {
            return CommandHandlerBase.ProcessCommand(args);
        }

        public static void DumpWebException(WebException we)
        {
            HttpWebResponse response = (HttpWebResponse)we.Response;
            StreamReader reader = new StreamReader(response.GetResponseStream());
            string responseBody = reader.ReadToEnd();
            Console.WriteLine("Response Body:");
            Console.WriteLine(responseBody);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\AzureBlob\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("AzureBlob")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("ReadAzureBlobFromStorage")]
[assembly: AssemblyCopyright("Copyright  Microsoft 2011")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("7834c7fe-73c9-45cc-acc7-b35c26cfdcbd")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\AzureBlob\Program.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net;
using System.Text;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;
using System.Configuration;


namespace AzureBlob
{
    class Program
    {
        private static readonly string azureStorageConnectionString = ConfigurationSettings.AppSettings["AzureStorageConnectionString"];

        static void Main(string[] args)
        {
            if (args.Length < 2 || (args[0] != "list" && args.Length < 3))
            {
                Console.WriteLine("This exe requires you to pass three parameters: read|write|list container [name]\n\tcontainer: the name of the Azure storage container\n\tname: blobname for a 'read' or filename for a 'write'\n\n\tNOTE: read assumes blob is GZipped, write assumes writing a GZipped blob");
                return;
            }

            string operation = args[0];
            string containerName = args[1];
            string fileOrBlobName = null;

            if (args.Length == 3)
            {
                fileOrBlobName = args[2];
            }

            WebRequest.DefaultWebProxy = new WebProxy("http://netproxy:80", true);

            CloudStorageAccount account = CloudStorageAccount.Parse(azureStorageConnectionString);
            var client = account.CreateCloudBlobClient();

            var container = client.GetContainerReference(containerName);

            switch (operation.ToUpper())
            {
                case "READ":
                    read(container, fileOrBlobName);
                    break;

                case "WRITE":
                    write(container, fileOrBlobName);
                    break;

                case "LIST":
                    list(container);
                    break;

                case "DELETE":
                    delete(container, fileOrBlobName);
                    break;

                case "WRITELOCAL":
                    writelocal(fileOrBlobName);
                    break;

                case "READLOCAL":
                    readlocal(fileOrBlobName);
                    break;

                default:
                    Console.WriteLine(String.Format("The first argument '{0}' is invalid. Please rerun the tool passing either 'read' or 'write'.", operation));
                    break;
            }

        }

        private static void read(CloudBlobContainer container, string blobName)
        {
            var blob = container.GetBlobReference(blobName);

            using (BlobStream blobStream = blob.OpenRead())
            {
                using (GZipStream gz = new GZipStream(blobStream, CompressionMode.Decompress))
                {
                    gz.CopyTo(Console.OpenStandardOutput());
                }
            }
        }

        private static void write(CloudBlobContainer container, string file)
        {
            if (!File.Exists(file))
            {
                Console.WriteLine("The file {0} was not found.");
                return;
            }

            container.CreateIfNotExist();

            using (FileStream fs = new FileStream(file, FileMode.Open))
            {

                string blobName = String.Format("{0}.gz", Path.GetFileNameWithoutExtension(file));

                var blob = container.GetBlobReference(blobName);

                using (BlobStream blobStream = blob.OpenWrite())
                {
                    using (GZipStream gz = new GZipStream(blobStream, CompressionMode.Compress))
                    {

                        fs.CopyTo(gz);
                    }
                }
            }
            Console.WriteLine("The blob has been succesfully written.");
        }

        private static void list(CloudBlobContainer container)
        {
            //List blobs and directories in this container hierarchically (which is the default listing).
            foreach (var blobItem in container.ListBlobs())
            {
                Console.WriteLine(blobItem.Uri);
            }
            Console.WriteLine();
        }

        private static void delete(CloudBlobContainer container, string blobName)
        {
            var blob = container.GetBlobReference(blobName);
            blob.DeleteIfExists();
            Console.WriteLine("The blob has been succesfully deleted.");
        }

        private static void writelocal(string file)
        {
            if (!File.Exists(file))
            {
                Console.WriteLine("The file {0} was not found.");
                return;
            }

            using (FileStream fs = new FileStream(file, FileMode.Open))
            {

                string fileName = String.Format("{0}.gz", Path.GetFileNameWithoutExtension(file));

                using (FileStream fsw = new FileStream(fileName, FileMode.CreateNew))
                {
                    using (GZipStream gz = new GZipStream(fsw, CompressionMode.Compress))
                    {

                        fs.CopyTo(gz);
                    }
                }
            }
            Console.WriteLine("The file has been succesfully written.");
        }

        private static void readlocal(string file)
        {
            if (!File.Exists(file))
            {
                Console.WriteLine("The file {0} was not found.");
                return;
            }

            using (FileStream fs = new FileStream(file, FileMode.Open))
            {
                using (GZipStream gz = new GZipStream(fs, CompressionMode.Decompress))
                {
                    gz.CopyTo(Console.OpenStandardOutput());
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ArgoAcctMgr\Reference.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

//
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
//
namespace xonline.tools.argoacctmgr {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;


    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="MusicSoap", Namespace="http://websvc.xboxlive.com/Music/")]
    public partial class Music : System.Web.Services.Protocols.SoapHttpClientProtocol {

        private System.Threading.SendOrPostCallback TestCreateAccountOperationCompleted;

        private System.Threading.SendOrPostCallback TestConnectionOperationCompleted;

        private System.Threading.SendOrPostCallback TestOrderSubscriptionOperationCompleted;

        private System.Threading.SendOrPostCallback CancelSubscriptionOperationCompleted;

        private System.Threading.SendOrPostCallback ResumeAccountOperationCompleted;

        private System.Threading.SendOrPostCallback SuspendAccountOperationCompleted;

        private System.Threading.SendOrPostCallback GetAccountStatusOperationCompleted;

        private System.Threading.SendOrPostCallback RestoreSubscriptionOperationCompleted;

        private System.Threading.SendOrPostCallback OrderSubscriptionOperationCompleted;

        private System.Threading.SendOrPostCallback GetSubscriptionProductsOperationCompleted;

        private System.Threading.SendOrPostCallback GetAccountSummaryOperationCompleted;

        private System.Threading.SendOrPostCallback AuthenticateAccountOperationCompleted;

        private System.Threading.SendOrPostCallback GetBillingInfoOperationCompleted;

        private System.Threading.SendOrPostCallback GetAccountBalanceOperationCompleted;

        private System.Threading.SendOrPostCallback OrderItemsOperationCompleted;

        private System.Threading.SendOrPostCallback GetOrderByExternalOrderIdOperationCompleted;

        /// <remarks/>
        public Music() {
            this.Url = "http://garyt4:12000/music/music.asmx";
        }

        /// <remarks/>
        public event TestCreateAccountCompletedEventHandler TestCreateAccountCompleted;

        /// <remarks/>
        public event TestConnectionCompletedEventHandler TestConnectionCompleted;

        /// <remarks/>
        public event TestOrderSubscriptionCompletedEventHandler TestOrderSubscriptionCompleted;

        /// <remarks/>
        public event CancelSubscriptionCompletedEventHandler CancelSubscriptionCompleted;

        /// <remarks/>
        public event ResumeAccountCompletedEventHandler ResumeAccountCompleted;

        /// <remarks/>
        public event SuspendAccountCompletedEventHandler SuspendAccountCompleted;

        /// <remarks/>
        public event GetAccountStatusCompletedEventHandler GetAccountStatusCompleted;

        /// <remarks/>
        public event RestoreSubscriptionCompletedEventHandler RestoreSubscriptionCompleted;

        /// <remarks/>
        public event OrderSubscriptionCompletedEventHandler OrderSubscriptionCompleted;

        /// <remarks/>
        public event GetSubscriptionProductsCompletedEventHandler GetSubscriptionProductsCompleted;

        /// <remarks/>
        public event GetAccountSummaryCompletedEventHandler GetAccountSummaryCompleted;

        /// <remarks/>
        public event AuthenticateAccountCompletedEventHandler AuthenticateAccountCompleted;

        /// <remarks/>
        public event GetBillingInfoCompletedEventHandler GetBillingInfoCompleted;

        /// <remarks/>
        public event GetAccountBalanceCompletedEventHandler GetAccountBalanceCompleted;

        /// <remarks/>
        public event OrderItemsCompletedEventHandler OrderItemsCompleted;

        /// <remarks/>
        public event GetOrderByExternalOrderIdCompletedEventHandler GetOrderByExternalOrderIdCompleted;

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Music/TestCreateAccount", RequestNamespace="http://websvc.xboxlive.com/Music/", ResponseNamespace="http://websvc.xboxlive.com/Music/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public TestCreateAccountResult TestCreateAccount(bool addPoints, bool addSubscription) {
            object[] results = this.Invoke("TestCreateAccount", new object[] {
                        addPoints,
                        addSubscription});
            return ((TestCreateAccountResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginTestCreateAccount(bool addPoints, bool addSubscription, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TestCreateAccount", new object[] {
                        addPoints,
                        addSubscription}, callback, asyncState);
        }

        /// <remarks/>
        public TestCreateAccountResult EndTestCreateAccount(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((TestCreateAccountResult)(results[0]));
        }

        /// <remarks/>
        public void TestCreateAccountAsync(bool addPoints, bool addSubscription) {
            this.TestCreateAccountAsync(addPoints, addSubscription, null);
        }

        /// <remarks/>
        public void TestCreateAccountAsync(bool addPoints, bool addSubscription, object userState) {
            if ((this.TestCreateAccountOperationCompleted == null)) {
                this.TestCreateAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTestCreateAccountOperationCompleted);
            }
            this.InvokeAsync("TestCreateAccount", new object[] {
                        addPoints,
                        addSubscription}, this.TestCreateAccountOperationCompleted, userState);
        }

        private void OnTestCreateAccountOperationCompleted(object arg) {
            if ((this.TestCreateAccountCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TestCreateAccountCompleted(this, new TestCreateAccountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Music/TestConnection", RequestNamespace="http://websvc.xboxlive.com/Music/", ResponseNamespace="http://websvc.xboxlive.com/Music/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string TestConnection(string message) {
            object[] results = this.Invoke("TestConnection", new object[] {
                        message});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginTestConnection(string message, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TestConnection", new object[] {
                        message}, callback, asyncState);
        }

        /// <remarks/>
        public string EndTestConnection(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        public void TestConnectionAsync(string message) {
            this.TestConnectionAsync(message, null);
        }

        /// <remarks/>
        public void TestConnectionAsync(string message, object userState) {
            if ((this.TestConnectionOperationCompleted == null)) {
                this.TestConnectionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTestConnectionOperationCompleted);
            }
            this.InvokeAsync("TestConnection", new object[] {
                        message}, this.TestConnectionOperationCompleted, userState);
        }

        private void OnTestConnectionOperationCompleted(object arg) {
            if ((this.TestConnectionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TestConnectionCompleted(this, new TestConnectionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Music/TestOrderSubscription", RequestNamespace="http://websvc.xboxlive.com/Music/", ResponseNamespace="http://websvc.xboxlive.com/Music/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public TestOrderSubscriptionResult TestOrderSubscription(string retailerId, string customerId, string subscriptionSku) {
            object[] results = this.Invoke("TestOrderSubscription", new object[] {
                        retailerId,
                        customerId,
                        subscriptionSku});
            return ((TestOrderSubscriptionResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginTestOrderSubscription(string retailerId, string customerId, string subscriptionSku, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TestOrderSubscription", new object[] {
                        retailerId,
                        customerId,
                        subscriptionSku}, callback, asyncState);
        }

        /// <remarks/>
        public TestOrderSubscriptionResult EndTestOrderSubscription(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((TestOrderSubscriptionResult)(results[0]));
        }

        /// <remarks/>
        public void TestOrderSubscriptionAsync(string retailerId, string customerId, string subscriptionSku) {
            this.TestOrderSubscriptionAsync(retailerId, customerId, subscriptionSku, null);
        }

        /// <remarks/>
        public void TestOrderSubscriptionAsync(string retailerId, string customerId, string subscriptionSku, object userState) {
            if ((this.TestOrderSubscriptionOperationCompleted == null)) {
                this.TestOrderSubscriptionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTestOrderSubscriptionOperationCompleted);
            }
            this.InvokeAsync("TestOrderSubscription", new object[] {
                        retailerId,
                        customerId,
                        subscriptionSku}, this.TestOrderSubscriptionOperationCompleted, userState);
        }

        private void OnTestOrderSubscriptionOperationCompleted(object arg) {
            if ((this.TestOrderSubscriptionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TestOrderSubscriptionCompleted(this, new TestOrderSubscriptionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Music/CancelSubscription", RequestNamespace="http://websvc.xboxlive.com/Music/", ResponseNamespace="http://websvc.xboxlive.com/Music/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public SubscriptionResult CancelSubscription(string retailerId, string customerId, string subscriptionSku) {
            object[] results = this.Invoke("CancelSubscription", new object[] {
                        retailerId,
                        customerId,
                        subscriptionSku});
            return ((SubscriptionResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginCancelSubscription(string retailerId, string customerId, string subscriptionSku, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CancelSubscription", new object[] {
                        retailerId,
                        customerId,
                        subscriptionSku}, callback, asyncState);
        }

        /// <remarks/>
        public SubscriptionResult EndCancelSubscription(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((SubscriptionResult)(results[0]));
        }

        /// <remarks/>
        public void CancelSubscriptionAsync(string retailerId, string customerId, string subscriptionSku) {
            this.CancelSubscriptionAsync(retailerId, customerId, subscriptionSku, null);
        }

        /// <remarks/>
        public void CancelSubscriptionAsync(string retailerId, string customerId, string subscriptionSku, object userState) {
            if ((this.CancelSubscriptionOperationCompleted == null)) {
                this.CancelSubscriptionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCancelSubscriptionOperationCompleted);
            }
            this.InvokeAsync("CancelSubscription", new object[] {
                        retailerId,
                        customerId,
                        subscriptionSku}, this.CancelSubscriptionOperationCompleted, userState);
        }

        private void OnCancelSubscriptionOperationCompleted(object arg) {
            if ((this.CancelSubscriptionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CancelSubscriptionCompleted(this, new CancelSubscriptionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Music/ResumeAccount", RequestNamespace="http://websvc.xboxlive.com/Music/", ResponseNamespace="http://websvc.xboxlive.com/Music/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public SubscriptionResult ResumeAccount(string retailerId, string customerId) {
            object[] results = this.Invoke("ResumeAccount", new object[] {
                        retailerId,
                        customerId});
            return ((SubscriptionResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginResumeAccount(string retailerId, string customerId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ResumeAccount", new object[] {
                        retailerId,
                        customerId}, callback, asyncState);
        }

        /// <remarks/>
        public SubscriptionResult EndResumeAccount(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((SubscriptionResult)(results[0]));
        }

        /// <remarks/>
        public void ResumeAccountAsync(string retailerId, string customerId) {
            this.ResumeAccountAsync(retailerId, customerId, null);
        }

        /// <remarks/>
        public void ResumeAccountAsync(string retailerId, string customerId, object userState) {
            if ((this.ResumeAccountOperationCompleted == null)) {
                this.ResumeAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnResumeAccountOperationCompleted);
            }
            this.InvokeAsync("ResumeAccount", new object[] {
                        retailerId,
                        customerId}, this.ResumeAccountOperationCompleted, userState);
        }

        private void OnResumeAccountOperationCompleted(object arg) {
            if ((this.ResumeAccountCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ResumeAccountCompleted(this, new ResumeAccountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Music/SuspendAccount", RequestNamespace="http://websvc.xboxlive.com/Music/", ResponseNamespace="http://websvc.xboxlive.com/Music/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public SubscriptionResult SuspendAccount(string retailerId, string customerId) {
            object[] results = this.Invoke("SuspendAccount", new object[] {
                        retailerId,
                        customerId});
            return ((SubscriptionResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginSuspendAccount(string retailerId, string customerId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SuspendAccount", new object[] {
                        retailerId,
                        customerId}, callback, asyncState);
        }

        /// <remarks/>
        public SubscriptionResult EndSuspendAccount(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((SubscriptionResult)(results[0]));
        }

        /// <remarks/>
        public void SuspendAccountAsync(string retailerId, string customerId) {
            this.SuspendAccountAsync(retailerId, customerId, null);
        }

        /// <remarks/>
        public void SuspendAccountAsync(string retailerId, string customerId, object userState) {
            if ((this.SuspendAccountOperationCompleted == null)) {
                this.SuspendAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSuspendAccountOperationCompleted);
            }
            this.InvokeAsync("SuspendAccount", new object[] {
                        retailerId,
                        customerId}, this.SuspendAccountOperationCompleted, userState);
        }

        private void OnSuspendAccountOperationCompleted(object arg) {
            if ((this.SuspendAccountCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SuspendAccountCompleted(this, new SuspendAccountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Music/GetAccountStatus", RequestNamespace="http://websvc.xboxlive.com/Music/", ResponseNamespace="http://websvc.xboxlive.com/Music/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public SubscriptionResult GetAccountStatus(string retailerId, string customerId) {
            object[] results = this.Invoke("GetAccountStatus", new object[] {
                        retailerId,
                        customerId});
            return ((SubscriptionResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetAccountStatus(string retailerId, string customerId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountStatus", new object[] {
                        retailerId,
                        customerId}, callback, asyncState);
        }

        /// <remarks/>
        public SubscriptionResult EndGetAccountStatus(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((SubscriptionResult)(results[0]));
        }

        /// <remarks/>
        public void GetAccountStatusAsync(string retailerId, string customerId) {
            this.GetAccountStatusAsync(retailerId, customerId, null);
        }

        /// <remarks/>
        public void GetAccountStatusAsync(string retailerId, string customerId, object userState) {
            if ((this.GetAccountStatusOperationCompleted == null)) {
                this.GetAccountStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAccountStatusOperationCompleted);
            }
            this.InvokeAsync("GetAccountStatus", new object[] {
                        retailerId,
                        customerId}, this.GetAccountStatusOperationCompleted, userState);
        }

        private void OnGetAccountStatusOperationCompleted(object arg) {
            if ((this.GetAccountStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAccountStatusCompleted(this, new GetAccountStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Music/RestoreSubscription", RequestNamespace="http://websvc.xboxlive.com/Music/", ResponseNamespace="http://websvc.xboxlive.com/Music/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public SubscriptionResult RestoreSubscription(string retailerId, string customerId, string subscriptionSku) {
            object[] results = this.Invoke("RestoreSubscription", new object[] {
                        retailerId,
                        customerId,
                        subscriptionSku});
            return ((SubscriptionResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginRestoreSubscription(string retailerId, string customerId, string subscriptionSku, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RestoreSubscription", new object[] {
                        retailerId,
                        customerId,
                        subscriptionSku}, callback, asyncState);
        }

        /// <remarks/>
        public SubscriptionResult EndRestoreSubscription(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((SubscriptionResult)(results[0]));
        }

        /// <remarks/>
        public void RestoreSubscriptionAsync(string retailerId, string customerId, string subscriptionSku) {
            this.RestoreSubscriptionAsync(retailerId, customerId, subscriptionSku, null);
        }

        /// <remarks/>
        public void RestoreSubscriptionAsync(string retailerId, string customerId, string subscriptionSku, object userState) {
            if ((this.RestoreSubscriptionOperationCompleted == null)) {
                this.RestoreSubscriptionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRestoreSubscriptionOperationCompleted);
            }
            this.InvokeAsync("RestoreSubscription", new object[] {
                        retailerId,
                        customerId,
                        subscriptionSku}, this.RestoreSubscriptionOperationCompleted, userState);
        }

        private void OnRestoreSubscriptionOperationCompleted(object arg) {
            if ((this.RestoreSubscriptionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RestoreSubscriptionCompleted(this, new RestoreSubscriptionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Music/OrderSubscription", RequestNamespace="http://websvc.xboxlive.com/Music/", ResponseNamespace="http://websvc.xboxlive.com/Music/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public SubscriptionResult OrderSubscription(string retailerId, string customerId, string subscriptionSku, string ipAddress) {
            object[] results = this.Invoke("OrderSubscription", new object[] {
                        retailerId,
                        customerId,
                        subscriptionSku,
                        ipAddress});
            return ((SubscriptionResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginOrderSubscription(string retailerId, string customerId, string subscriptionSku, string ipAddress, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("OrderSubscription", new object[] {
                        retailerId,
                        customerId,
                        subscriptionSku,
                        ipAddress}, callback, asyncState);
        }

        /// <remarks/>
        public SubscriptionResult EndOrderSubscription(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((SubscriptionResult)(results[0]));
        }

        /// <remarks/>
        public void OrderSubscriptionAsync(string retailerId, string customerId, string subscriptionSku, string ipAddress) {
            this.OrderSubscriptionAsync(retailerId, customerId, subscriptionSku, ipAddress, null);
        }

        /// <remarks/>
        public void OrderSubscriptionAsync(string retailerId, string customerId, string subscriptionSku, string ipAddress, object userState) {
            if ((this.OrderSubscriptionOperationCompleted == null)) {
                this.OrderSubscriptionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnOrderSubscriptionOperationCompleted);
            }
            this.InvokeAsync("OrderSubscription", new object[] {
                        retailerId,
                        customerId,
                        subscriptionSku,
                        ipAddress}, this.OrderSubscriptionOperationCompleted, userState);
        }

        private void OnOrderSubscriptionOperationCompleted(object arg) {
            if ((this.OrderSubscriptionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.OrderSubscriptionCompleted(this, new OrderSubscriptionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Music/GetSubscriptionProducts", RequestNamespace="http://websvc.xboxlive.com/Music/", ResponseNamespace="http://websvc.xboxlive.com/Music/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GetSubscriptionProductsResult GetSubscriptionProducts(string retailerId) {
            object[] results = this.Invoke("GetSubscriptionProducts", new object[] {
                        retailerId});
            return ((GetSubscriptionProductsResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetSubscriptionProducts(string retailerId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSubscriptionProducts", new object[] {
                        retailerId}, callback, asyncState);
        }

        /// <remarks/>
        public GetSubscriptionProductsResult EndGetSubscriptionProducts(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GetSubscriptionProductsResult)(results[0]));
        }

        /// <remarks/>
        public void GetSubscriptionProductsAsync(string retailerId) {
            this.GetSubscriptionProductsAsync(retailerId, null);
        }

        /// <remarks/>
        public void GetSubscriptionProductsAsync(string retailerId, object userState) {
            if ((this.GetSubscriptionProductsOperationCompleted == null)) {
                this.GetSubscriptionProductsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetSubscriptionProductsOperationCompleted);
            }
            this.InvokeAsync("GetSubscriptionProducts", new object[] {
                        retailerId}, this.GetSubscriptionProductsOperationCompleted, userState);
        }

        private void OnGetSubscriptionProductsOperationCompleted(object arg) {
            if ((this.GetSubscriptionProductsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetSubscriptionProductsCompleted(this, new GetSubscriptionProductsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Music/GetAccountSummary", RequestNamespace="http://websvc.xboxlive.com/Music/", ResponseNamespace="http://websvc.xboxlive.com/Music/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public AccountSummaryResult GetAccountSummary(string retailerId, string customerId) {
            object[] results = this.Invoke("GetAccountSummary", new object[] {
                        retailerId,
                        customerId});
            return ((AccountSummaryResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetAccountSummary(string retailerId, string customerId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountSummary", new object[] {
                        retailerId,
                        customerId}, callback, asyncState);
        }

        /// <remarks/>
        public AccountSummaryResult EndGetAccountSummary(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((AccountSummaryResult)(results[0]));
        }

        /// <remarks/>
        public void GetAccountSummaryAsync(string retailerId, string customerId) {
            this.GetAccountSummaryAsync(retailerId, customerId, null);
        }

        /// <remarks/>
        public void GetAccountSummaryAsync(string retailerId, string customerId, object userState) {
            if ((this.GetAccountSummaryOperationCompleted == null)) {
                this.GetAccountSummaryOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAccountSummaryOperationCompleted);
            }
            this.InvokeAsync("GetAccountSummary", new object[] {
                        retailerId,
                        customerId}, this.GetAccountSummaryOperationCompleted, userState);
        }

        private void OnGetAccountSummaryOperationCompleted(object arg) {
            if ((this.GetAccountSummaryCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAccountSummaryCompleted(this, new GetAccountSummaryCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Music/AuthenticateAccount", RequestNamespace="http://websvc.xboxlive.com/Music/", ResponseNamespace="http://websvc.xboxlive.com/Music/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public AuthenticateAccountResult AuthenticateAccount(string retailerId, string passportTicket) {
            object[] results = this.Invoke("AuthenticateAccount", new object[] {
                        retailerId,
                        passportTicket});
            return ((AuthenticateAccountResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginAuthenticateAccount(string retailerId, string passportTicket, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AuthenticateAccount", new object[] {
                        retailerId,
                        passportTicket}, callback, asyncState);
        }

        /// <remarks/>
        public AuthenticateAccountResult EndAuthenticateAccount(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((AuthenticateAccountResult)(results[0]));
        }

        /// <remarks/>
        public void AuthenticateAccountAsync(string retailerId, string passportTicket) {
            this.AuthenticateAccountAsync(retailerId, passportTicket, null);
        }

        /// <remarks/>
        public void AuthenticateAccountAsync(string retailerId, string passportTicket, object userState) {
            if ((this.AuthenticateAccountOperationCompleted == null)) {
                this.AuthenticateAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAuthenticateAccountOperationCompleted);
            }
            this.InvokeAsync("AuthenticateAccount", new object[] {
                        retailerId,
                        passportTicket}, this.AuthenticateAccountOperationCompleted, userState);
        }

        private void OnAuthenticateAccountOperationCompleted(object arg) {
            if ((this.AuthenticateAccountCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AuthenticateAccountCompleted(this, new AuthenticateAccountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Music/GetBillingInfo", RequestNamespace="http://websvc.xboxlive.com/Music/", ResponseNamespace="http://websvc.xboxlive.com/Music/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public BillingInfoResult GetBillingInfo(string retailerId, string customerId) {
            object[] results = this.Invoke("GetBillingInfo", new object[] {
                        retailerId,
                        customerId});
            return ((BillingInfoResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetBillingInfo(string retailerId, string customerId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetBillingInfo", new object[] {
                        retailerId,
                        customerId}, callback, asyncState);
        }

        /// <remarks/>
        public BillingInfoResult EndGetBillingInfo(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((BillingInfoResult)(results[0]));
        }

        /// <remarks/>
        public void GetBillingInfoAsync(string retailerId, string customerId) {
            this.GetBillingInfoAsync(retailerId, customerId, null);
        }

        /// <remarks/>
        public void GetBillingInfoAsync(string retailerId, string customerId, object userState) {
            if ((this.GetBillingInfoOperationCompleted == null)) {
                this.GetBillingInfoOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetBillingInfoOperationCompleted);
            }
            this.InvokeAsync("GetBillingInfo", new object[] {
                        retailerId,
                        customerId}, this.GetBillingInfoOperationCompleted, userState);
        }

        private void OnGetBillingInfoOperationCompleted(object arg) {
            if ((this.GetBillingInfoCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetBillingInfoCompleted(this, new GetBillingInfoCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Music/GetAccountBalance", RequestNamespace="http://websvc.xboxlive.com/Music/", ResponseNamespace="http://websvc.xboxlive.com/Music/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public AccountBalanceResult GetAccountBalance(string retailerId, string customerId) {
            object[] results = this.Invoke("GetAccountBalance", new object[] {
                        retailerId,
                        customerId});
            return ((AccountBalanceResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetAccountBalance(string retailerId, string customerId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountBalance", new object[] {
                        retailerId,
                        customerId}, callback, asyncState);
        }

        /// <remarks/>
        public AccountBalanceResult EndGetAccountBalance(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((AccountBalanceResult)(results[0]));
        }

        /// <remarks/>
        public void GetAccountBalanceAsync(string retailerId, string customerId) {
            this.GetAccountBalanceAsync(retailerId, customerId, null);
        }

        /// <remarks/>
        public void GetAccountBalanceAsync(string retailerId, string customerId, object userState) {
            if ((this.GetAccountBalanceOperationCompleted == null)) {
                this.GetAccountBalanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAccountBalanceOperationCompleted);
            }
            this.InvokeAsync("GetAccountBalance", new object[] {
                        retailerId,
                        customerId}, this.GetAccountBalanceOperationCompleted, userState);
        }

        private void OnGetAccountBalanceOperationCompleted(object arg) {
            if ((this.GetAccountBalanceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAccountBalanceCompleted(this, new GetAccountBalanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Music/OrderItems", RequestNamespace="http://websvc.xboxlive.com/Music/", ResponseNamespace="http://websvc.xboxlive.com/Music/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public OrderItemsResult OrderItems(string retailerId, string customerId, string externalOrderId, bool repurchaseOverride, Item[] items, string ipAddress) {
            object[] results = this.Invoke("OrderItems", new object[] {
                        retailerId,
                        customerId,
                        externalOrderId,
                        repurchaseOverride,
                        items,
                        ipAddress});
            return ((OrderItemsResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginOrderItems(string retailerId, string customerId, string externalOrderId, bool repurchaseOverride, Item[] items, string ipAddress, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("OrderItems", new object[] {
                        retailerId,
                        customerId,
                        externalOrderId,
                        repurchaseOverride,
                        items,
                        ipAddress}, callback, asyncState);
        }

        /// <remarks/>
        public OrderItemsResult EndOrderItems(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((OrderItemsResult)(results[0]));
        }

        /// <remarks/>
        public void OrderItemsAsync(string retailerId, string customerId, string externalOrderId, bool repurchaseOverride, Item[] items, string ipAddress) {
            this.OrderItemsAsync(retailerId, customerId, externalOrderId, repurchaseOverride, items, ipAddress, null);
        }

        /// <remarks/>
        public void OrderItemsAsync(string retailerId, string customerId, string externalOrderId, bool repurchaseOverride, Item[] items, string ipAddress, object userState) {
            if ((this.OrderItemsOperationCompleted == null)) {
                this.OrderItemsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnOrderItemsOperationCompleted);
            }
            this.InvokeAsync("OrderItems", new object[] {
                        retailerId,
                        customerId,
                        externalOrderId,
                        repurchaseOverride,
                        items,
                        ipAddress}, this.OrderItemsOperationCompleted, userState);
        }

        private void OnOrderItemsOperationCompleted(object arg) {
            if ((this.OrderItemsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.OrderItemsCompleted(this, new OrderItemsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Music/GetOrderByExternalOrderId", RequestNamespace="http://websvc.xboxlive.com/Music/", ResponseNamespace="http://websvc.xboxlive.com/Music/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GetOrderResult GetOrderByExternalOrderId(string retailerId, string customerId, string[] externalOrderId) {
            object[] results = this.Invoke("GetOrderByExternalOrderId", new object[] {
                        retailerId,
                        customerId,
                        externalOrderId});
            return ((GetOrderResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetOrderByExternalOrderId(string retailerId, string customerId, string[] externalOrderId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetOrderByExternalOrderId", new object[] {
                        retailerId,
                        customerId,
                        externalOrderId}, callback, asyncState);
        }

        /// <remarks/>
        public GetOrderResult EndGetOrderByExternalOrderId(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GetOrderResult)(results[0]));
        }

        /// <remarks/>
        public void GetOrderByExternalOrderIdAsync(string retailerId, string customerId, string[] externalOrderId) {
            this.GetOrderByExternalOrderIdAsync(retailerId, customerId, externalOrderId, null);
        }

        /// <remarks/>
        public void GetOrderByExternalOrderIdAsync(string retailerId, string customerId, string[] externalOrderId, object userState) {
            if ((this.GetOrderByExternalOrderIdOperationCompleted == null)) {
                this.GetOrderByExternalOrderIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetOrderByExternalOrderIdOperationCompleted);
            }
            this.InvokeAsync("GetOrderByExternalOrderId", new object[] {
                        retailerId,
                        customerId,
                        externalOrderId}, this.GetOrderByExternalOrderIdOperationCompleted, userState);
        }

        private void OnGetOrderByExternalOrderIdOperationCompleted(object arg) {
            if ((this.GetOrderByExternalOrderIdCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetOrderByExternalOrderIdCompleted(this, new GetOrderByExternalOrderIdCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Music/")]
    public partial class TestCreateAccountResult {

        private string gamertagFieldField;

        private ulong xboxLivePuidFieldField;

        private ulong passportPuidFieldField;

        private string passportMemberNameFieldField;

        private string passportPasswordFieldField;

        private int pointsBalanceFieldField;

        /// <remarks/>
        public string gamertagField {
            get {
                return this.gamertagFieldField;
            }
            set {
                this.gamertagFieldField = value;
            }
        }

        /// <remarks/>
        public ulong xboxLivePuidField {
            get {
                return this.xboxLivePuidFieldField;
            }
            set {
                this.xboxLivePuidFieldField = value;
            }
        }

        /// <remarks/>
        public ulong passportPuidField {
            get {
                return this.passportPuidFieldField;
            }
            set {
                this.passportPuidFieldField = value;
            }
        }

        /// <remarks/>
        public string passportMemberNameField {
            get {
                return this.passportMemberNameFieldField;
            }
            set {
                this.passportMemberNameFieldField = value;
            }
        }

        /// <remarks/>
        public string passportPasswordField {
            get {
                return this.passportPasswordFieldField;
            }
            set {
                this.passportPasswordFieldField = value;
            }
        }

        /// <remarks/>
        public int pointsBalanceField {
            get {
                return this.pointsBalanceFieldField;
            }
            set {
                this.pointsBalanceFieldField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Music/")]
    public partial class OrderStatus {

        private string externalOrderIdField;

        private OrderStatusEnum orderStatusField;

        /// <remarks/>
        public string externalOrderId {
            get {
                return this.externalOrderIdField;
            }
            set {
                this.externalOrderIdField = value;
            }
        }

        /// <remarks/>
        public OrderStatusEnum orderStatus {
            get {
                return this.orderStatusField;
            }
            set {
                this.orderStatusField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Music/")]
    public enum OrderStatusEnum {

        /// <remarks/>
        ExternalOrderIdNotFound,

        /// <remarks/>
        TransactionPending,

        /// <remarks/>
        TransactionSuccessful,

        /// <remarks/>
        TransactionFailed,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Music/")]
    public partial class GetOrderResult {

        private OrderStatus[] externalOrderIdStatusField;

        /// <remarks/>
        public OrderStatus[] externalOrderIdStatus {
            get {
                return this.externalOrderIdStatusField;
            }
            set {
                this.externalOrderIdStatusField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Music/")]
    public partial class OrderItemsResult {

        private string externalOrderIdField;

        private int accountBalanceFieldField;

        /// <remarks/>
        public string externalOrderId {
            get {
                return this.externalOrderIdField;
            }
            set {
                this.externalOrderIdField = value;
            }
        }

        /// <remarks/>
        public int accountBalanceField {
            get {
                return this.accountBalanceFieldField;
            }
            set {
                this.accountBalanceFieldField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Music/")]
    public partial class Item {

        private ComponentType virtualSkuFieldField;

        private string componentIdFieldField;

        private string artistNameFieldField;

        private string titleFieldField;

        private int retailPriceInPointsField;

        private decimal retailPriceInCurrencyField;

        private decimal wholesalePriceInCurrencyField;

        /// <remarks/>
        public ComponentType virtualSkuField {
            get {
                return this.virtualSkuFieldField;
            }
            set {
                this.virtualSkuFieldField = value;
            }
        }

        /// <remarks/>
        public string componentIdField {
            get {
                return this.componentIdFieldField;
            }
            set {
                this.componentIdFieldField = value;
            }
        }

        /// <remarks/>
        public string artistNameField {
            get {
                return this.artistNameFieldField;
            }
            set {
                this.artistNameFieldField = value;
            }
        }

        /// <remarks/>
        public string titleField {
            get {
                return this.titleFieldField;
            }
            set {
                this.titleFieldField = value;
            }
        }

        /// <remarks/>
        public int retailPriceInPoints {
            get {
                return this.retailPriceInPointsField;
            }
            set {
                this.retailPriceInPointsField = value;
            }
        }

        /// <remarks/>
        public decimal retailPriceInCurrency {
            get {
                return this.retailPriceInCurrencyField;
            }
            set {
                this.retailPriceInCurrencyField = value;
            }
        }

        /// <remarks/>
        public decimal wholesalePriceInCurrency {
            get {
                return this.wholesalePriceInCurrencyField;
            }
            set {
                this.wholesalePriceInCurrencyField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Music/")]
    public enum ComponentType {

        /// <remarks/>
        Album,

        /// <remarks/>
        Single,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Music/")]
    public partial class AccountBalanceResult {

        private int balanceField;

        /// <remarks/>
        public int balance {
            get {
                return this.balanceField;
            }
            set {
                this.balanceField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Music/")]
    public partial class BillingInfoResult {

        private bool hasPaymentInstrumentField;

        /// <remarks/>
        public bool hasPaymentInstrument {
            get {
                return this.hasPaymentInstrumentField;
            }
            set {
                this.hasPaymentInstrumentField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Music/")]
    public partial class AuthenticateAccountResult {

        private string customerIdFieldField;

        private int balanceFieldField;

        private AccountStatus accountStatusFieldField;

        private Subscription subscriptionFieldField;

        private byte[] userPrivilegesFieldField;

        private byte[] clientDataFieldField;

        /// <remarks/>
        public string customerIdField {
            get {
                return this.customerIdFieldField;
            }
            set {
                this.customerIdFieldField = value;
            }
        }

        /// <remarks/>
        public int balanceField {
            get {
                return this.balanceFieldField;
            }
            set {
                this.balanceFieldField = value;
            }
        }

        /// <remarks/>
        public AccountStatus accountStatusField {
            get {
                return this.accountStatusFieldField;
            }
            set {
                this.accountStatusFieldField = value;
            }
        }

        /// <remarks/>
        public Subscription subscriptionField {
            get {
                return this.subscriptionFieldField;
            }
            set {
                this.subscriptionFieldField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] userPrivilegesField {
            get {
                return this.userPrivilegesFieldField;
            }
            set {
                this.userPrivilegesFieldField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] clientDataField {
            get {
                return this.clientDataFieldField;
            }
            set {
                this.clientDataFieldField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Music/")]
    public enum AccountStatus {

        /// <remarks/>
        Active,

        /// <remarks/>
        SuspendedByPartner,

        /// <remarks/>
        SuspendedForBillingFailure,

        /// <remarks/>
        SuspendedManually,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Music/")]
    public partial class Subscription {

        private SubscriptionSku subscriptionSkuFieldField;

        private System.DateTime orderedDateFieldField;

        private System.DateTime startDateFieldField;

        private decimal payCyclePriceFieldField;

        private System.DateTime nextPayCycleDateFieldField;

        private System.Nullable<System.DateTime> cancelRequestDateFieldField;

        private System.Nullable<System.DateTime> endDateFieldField;

        /// <remarks/>
        public SubscriptionSku subscriptionSkuField {
            get {
                return this.subscriptionSkuFieldField;
            }
            set {
                this.subscriptionSkuFieldField = value;
            }
        }

        /// <remarks/>
        public System.DateTime orderedDateField {
            get {
                return this.orderedDateFieldField;
            }
            set {
                this.orderedDateFieldField = value;
            }
        }

        /// <remarks/>
        public System.DateTime startDateField {
            get {
                return this.startDateFieldField;
            }
            set {
                this.startDateFieldField = value;
            }
        }

        /// <remarks/>
        public decimal payCyclePriceField {
            get {
                return this.payCyclePriceFieldField;
            }
            set {
                this.payCyclePriceFieldField = value;
            }
        }

        /// <remarks/>
        public System.DateTime nextPayCycleDateField {
            get {
                return this.nextPayCycleDateFieldField;
            }
            set {
                this.nextPayCycleDateFieldField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> cancelRequestDateField {
            get {
                return this.cancelRequestDateFieldField;
            }
            set {
                this.cancelRequestDateFieldField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> endDateField {
            get {
                return this.endDateFieldField;
            }
            set {
                this.endDateFieldField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Music/")]
    public partial class SubscriptionSku {

        private string skuFieldField;

        private System.DateTime availableStartDateFieldField;

        private System.DateTime availableEndDateFieldField;

        private bool consumerAvailableFieldField;

        private int fulfillmentSkuFieldField;

        private string productIdFieldField;

        private PaymentType paymentTypeFieldField;

        private System.Nullable<int> trialDurationDaysFieldField;

        private bool trialDurationDaysFieldFieldSpecified;

        private bool trialDurationDaysFieldSpecified1Field;

        private System.Nullable<PaymentCycle> paymentCycleFieldField;

        private System.Nullable<decimal> paymentCyclePriceFieldField;

        /// <remarks/>
        public string skuField {
            get {
                return this.skuFieldField;
            }
            set {
                this.skuFieldField = value;
            }
        }

        /// <remarks/>
        public System.DateTime availableStartDateField {
            get {
                return this.availableStartDateFieldField;
            }
            set {
                this.availableStartDateFieldField = value;
            }
        }

        /// <remarks/>
        public System.DateTime availableEndDateField {
            get {
                return this.availableEndDateFieldField;
            }
            set {
                this.availableEndDateFieldField = value;
            }
        }

        /// <remarks/>
        public bool consumerAvailableField {
            get {
                return this.consumerAvailableFieldField;
            }
            set {
                this.consumerAvailableFieldField = value;
            }
        }

        /// <remarks/>
        public int fulfillmentSkuField {
            get {
                return this.fulfillmentSkuFieldField;
            }
            set {
                this.fulfillmentSkuFieldField = value;
            }
        }

        /// <remarks/>
        public string productIdField {
            get {
                return this.productIdFieldField;
            }
            set {
                this.productIdFieldField = value;
            }
        }

        /// <remarks/>
        public PaymentType paymentTypeField {
            get {
                return this.paymentTypeFieldField;
            }
            set {
                this.paymentTypeFieldField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> trialDurationDaysField {
            get {
                return this.trialDurationDaysFieldField;
            }
            set {
                this.trialDurationDaysFieldField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool trialDurationDaysFieldSpecified {
            get {
                return this.trialDurationDaysFieldFieldSpecified;
            }
            set {
                this.trialDurationDaysFieldFieldSpecified = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("trialDurationDaysFieldSpecified")]
        public bool trialDurationDaysFieldSpecified1 {
            get {
                return this.trialDurationDaysFieldSpecified1Field;
            }
            set {
                this.trialDurationDaysFieldSpecified1Field = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<PaymentCycle> paymentCycleField {
            get {
                return this.paymentCycleFieldField;
            }
            set {
                this.paymentCycleFieldField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<decimal> paymentCyclePriceField {
            get {
                return this.paymentCyclePriceFieldField;
            }
            set {
                this.paymentCyclePriceFieldField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Music/")]
    public enum PaymentType {

        /// <remarks/>
        Free,

        /// <remarks/>
        Paid,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Music/")]
    public enum PaymentCycle {

        /// <remarks/>
        Monthly,

        /// <remarks/>
        Annual,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Music/")]
    public partial class AccountSummaryResult {

        private string retailerIdFieldField;

        private string customerIdFieldField;

        private string firstNameFieldField;

        private string lastNameFieldField;

        private string emailFieldField;

        private bool hasPaymentInstrumentField;

        /// <remarks/>
        public string retailerIdField {
            get {
                return this.retailerIdFieldField;
            }
            set {
                this.retailerIdFieldField = value;
            }
        }

        /// <remarks/>
        public string customerIdField {
            get {
                return this.customerIdFieldField;
            }
            set {
                this.customerIdFieldField = value;
            }
        }

        /// <remarks/>
        public string firstNameField {
            get {
                return this.firstNameFieldField;
            }
            set {
                this.firstNameFieldField = value;
            }
        }

        /// <remarks/>
        public string lastNameField {
            get {
                return this.lastNameFieldField;
            }
            set {
                this.lastNameFieldField = value;
            }
        }

        /// <remarks/>
        public string emailField {
            get {
                return this.emailFieldField;
            }
            set {
                this.emailFieldField = value;
            }
        }

        /// <remarks/>
        public bool hasPaymentInstrument {
            get {
                return this.hasPaymentInstrumentField;
            }
            set {
                this.hasPaymentInstrumentField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Music/")]
    public partial class Product {

        private string productIdFieldField;

        private string productNameFieldField;

        private int productTierFieldField;

        private string subscriptionRightsFieldField;

        private SubscriptionSku[] subscriptionSkusFieldField;

        /// <remarks/>
        public string productIdField {
            get {
                return this.productIdFieldField;
            }
            set {
                this.productIdFieldField = value;
            }
        }

        /// <remarks/>
        public string productNameField {
            get {
                return this.productNameFieldField;
            }
            set {
                this.productNameFieldField = value;
            }
        }

        /// <remarks/>
        public int productTierField {
            get {
                return this.productTierFieldField;
            }
            set {
                this.productTierFieldField = value;
            }
        }

        /// <remarks/>
        public string subscriptionRightsField {
            get {
                return this.subscriptionRightsFieldField;
            }
            set {
                this.subscriptionRightsFieldField = value;
            }
        }

        /// <remarks/>
        public SubscriptionSku[] subscriptionSkusField {
            get {
                return this.subscriptionSkusFieldField;
            }
            set {
                this.subscriptionSkusFieldField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Music/")]
    public partial class GetSubscriptionProductsResult {

        private Product[] productsFieldField;

        /// <remarks/>
        public Product[] productsField {
            get {
                return this.productsFieldField;
            }
            set {
                this.productsFieldField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Music/")]
    public partial class SubscriptionHistory {

        private Subscription currentSubscriptionFieldField;

        private Subscription queuedSubscriptionFieldField;

        private Subscription[] expiredSubscriptionsFieldField;

        /// <remarks/>
        public Subscription currentSubscriptionField {
            get {
                return this.currentSubscriptionFieldField;
            }
            set {
                this.currentSubscriptionFieldField = value;
            }
        }

        /// <remarks/>
        public Subscription queuedSubscriptionField {
            get {
                return this.queuedSubscriptionFieldField;
            }
            set {
                this.queuedSubscriptionFieldField = value;
            }
        }

        /// <remarks/>
        public Subscription[] expiredSubscriptionsField {
            get {
                return this.expiredSubscriptionsFieldField;
            }
            set {
                this.expiredSubscriptionsFieldField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Music/")]
    public partial class SubscriptionResult {

        private AccountStatus accountStatusFieldField;

        private SubscriptionHistory subscriptionHistoryFieldField;

        /// <remarks/>
        public AccountStatus accountStatusField {
            get {
                return this.accountStatusFieldField;
            }
            set {
                this.accountStatusFieldField = value;
            }
        }

        /// <remarks/>
        public SubscriptionHistory subscriptionHistoryField {
            get {
                return this.subscriptionHistoryFieldField;
            }
            set {
                this.subscriptionHistoryFieldField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Music/")]
    public partial class TestOrderSubscriptionResult {

        private bool isAllowedFieldField;

        private System.DateTime startDateFieldField;

        private decimal totalChargeFieldField;

        private decimal creditChargeFieldField;

        private decimal debitChargeFieldField;

        private System.DateTime nextBillingDateFieldField;

        private System.Nullable<decimal> paymentCyclePriceFieldField;

        /// <remarks/>
        public bool isAllowedField {
            get {
                return this.isAllowedFieldField;
            }
            set {
                this.isAllowedFieldField = value;
            }
        }

        /// <remarks/>
        public System.DateTime startDateField {
            get {
                return this.startDateFieldField;
            }
            set {
                this.startDateFieldField = value;
            }
        }

        /// <remarks/>
        public decimal totalChargeField {
            get {
                return this.totalChargeFieldField;
            }
            set {
                this.totalChargeFieldField = value;
            }
        }

        /// <remarks/>
        public decimal creditChargeField {
            get {
                return this.creditChargeFieldField;
            }
            set {
                this.creditChargeFieldField = value;
            }
        }

        /// <remarks/>
        public decimal debitChargeField {
            get {
                return this.debitChargeFieldField;
            }
            set {
                this.debitChargeFieldField = value;
            }
        }

        /// <remarks/>
        public System.DateTime nextBillingDateField {
            get {
                return this.nextBillingDateFieldField;
            }
            set {
                this.nextBillingDateFieldField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<decimal> paymentCyclePriceField {
            get {
                return this.paymentCyclePriceFieldField;
            }
            set {
                this.paymentCyclePriceFieldField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void TestCreateAccountCompletedEventHandler(object sender, TestCreateAccountCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TestCreateAccountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {

        private object[] results;

        internal TestCreateAccountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
                base(exception, cancelled, userState) {
            this.results = results;
        }

        /// <remarks/>
        public TestCreateAccountResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((TestCreateAccountResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void TestConnectionCompletedEventHandler(object sender, TestConnectionCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TestConnectionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {

        private object[] results;

        internal TestConnectionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
                base(exception, cancelled, userState) {
            this.results = results;
        }

        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void TestOrderSubscriptionCompletedEventHandler(object sender, TestOrderSubscriptionCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TestOrderSubscriptionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {

        private object[] results;

        internal TestOrderSubscriptionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
                base(exception, cancelled, userState) {
            this.results = results;
        }

        /// <remarks/>
        public TestOrderSubscriptionResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((TestOrderSubscriptionResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CancelSubscriptionCompletedEventHandler(object sender, CancelSubscriptionCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CancelSubscriptionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {

        private object[] results;

        internal CancelSubscriptionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
                base(exception, cancelled, userState) {
            this.results = results;
        }

        /// <remarks/>
        public SubscriptionResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((SubscriptionResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ResumeAccountCompletedEventHandler(object sender, ResumeAccountCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ResumeAccountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {

        private object[] results;

        internal ResumeAccountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
                base(exception, cancelled, userState) {
            this.results = results;
        }

        /// <remarks/>
        public SubscriptionResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((SubscriptionResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SuspendAccountCompletedEventHandler(object sender, SuspendAccountCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SuspendAccountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {

        private object[] results;

        internal SuspendAccountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
                base(exception, cancelled, userState) {
            this.results = results;
        }

        /// <remarks/>
        public SubscriptionResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((SubscriptionResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAccountStatusCompletedEventHandler(object sender, GetAccountStatusCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAccountStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {

        private object[] results;

        internal GetAccountStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
                base(exception, cancelled, userState) {
            this.results = results;
        }

        /// <remarks/>
        public SubscriptionResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((SubscriptionResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RestoreSubscriptionCompletedEventHandler(object sender, RestoreSubscriptionCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class RestoreSubscriptionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {

        private object[] results;

        internal RestoreSubscriptionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
                base(exception, cancelled, userState) {
            this.results = results;
        }

        /// <remarks/>
        public SubscriptionResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((SubscriptionResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void OrderSubscriptionCompletedEventHandler(object sender, OrderSubscriptionCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class OrderSubscriptionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {

        private object[] results;

        internal OrderSubscriptionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
                base(exception, cancelled, userState) {
            this.results = results;
        }

        /// <remarks/>
        public SubscriptionResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((SubscriptionResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetSubscriptionProductsCompletedEventHandler(object sender, GetSubscriptionProductsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetSubscriptionProductsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {

        private object[] results;

        internal GetSubscriptionProductsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
                base(exception, cancelled, userState) {
            this.results = results;
        }

        /// <remarks/>
        public GetSubscriptionProductsResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GetSubscriptionProductsResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAccountSummaryCompletedEventHandler(object sender, GetAccountSummaryCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAccountSummaryCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {

        private object[] results;

        internal GetAccountSummaryCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
                base(exception, cancelled, userState) {
            this.results = results;
        }

        /// <remarks/>
        public AccountSummaryResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((AccountSummaryResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AuthenticateAccountCompletedEventHandler(object sender, AuthenticateAccountCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AuthenticateAccountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {

        private object[] results;

        internal AuthenticateAccountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
                base(exception, cancelled, userState) {
            this.results = results;
        }

        /// <remarks/>
        public AuthenticateAccountResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((AuthenticateAccountResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetBillingInfoCompletedEventHandler(object sender, GetBillingInfoCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetBillingInfoCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {

        private object[] results;

        internal GetBillingInfoCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
                base(exception, cancelled, userState) {
            this.results = results;
        }

        /// <remarks/>
        public BillingInfoResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((BillingInfoResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAccountBalanceCompletedEventHandler(object sender, GetAccountBalanceCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAccountBalanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {

        private object[] results;

        internal GetAccountBalanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
                base(exception, cancelled, userState) {
            this.results = results;
        }

        /// <remarks/>
        public AccountBalanceResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((AccountBalanceResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void OrderItemsCompletedEventHandler(object sender, OrderItemsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class OrderItemsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {

        private object[] results;

        internal OrderItemsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
                base(exception, cancelled, userState) {
            this.results = results;
        }

        /// <remarks/>
        public OrderItemsResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((OrderItemsResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetOrderByExternalOrderIdCompletedEventHandler(object sender, GetOrderByExternalOrderIdCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetOrderByExternalOrderIdCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {

        private object[] results;

        internal GetOrderByExternalOrderIdCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
                base(exception, cancelled, userState) {
            this.results = results;
        }

        /// <remarks/>
        public GetOrderResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GetOrderResult)(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\AzureRunner\app\DeleteDeploymentCommandHandler.cs ===
using System;
using System.Collections.Generic;
using xonline.common.console;

namespace xonline.tools.AzureRunner
{
    [Command("DeleteDeployment", "Delete an Azure deployment from the cloud.")]
    class DeleteDeploymentCommandHandler : CommandHandlerBase
	{
        public override int Execute(Dictionary<string,string> parameters)
        {
            throw new NotImplementedException();
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\AzureRunner\app\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\authdump\authdump.cs ===
using System;
using System.Web;
using System.IO;
using System.Net;
using System.Text;
using System.Net.Sockets;
using System.Collections.Specialized;
using System.Threading;
using System.Diagnostics;
using System.Collections;
using System.Reflection;
using System.Security.Cryptography;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;


namespace xonline.tools.authdump
{
    public class dmpttkt
    {

        public static void Main(string[] args)
        {
            bool bundledAuth = false;
            
            if (args.Length == 2 && args[0].ToLower() == "/b")
            {
                bundledAuth = true;
            }
            else if (args.Length != 1)
            {
                Console.WriteLine("usage: authdump [/b] <base-64 authdata>");
                return;
            }
            
            if (bundledAuth)
            {
                BundledAuthData authData = new BundledAuthData(args[1]);
                Console.WriteLine("BundledAuthData:");
                Console.WriteLine("  titleId: " + authData.titleID.ToString("x"));
                for (int i = 0; i < authData.users.Length; i++)
                {
                    Console.WriteLine("  userId: " + authData.users[i].qwUserID.ToString("x"));
                }    
                
                return;
                    
            }    
                

            SGInfo info = new SGInfo(args[0]);
            Console.WriteLine(info.ToString());

        }
    }

    public class CallSource
    {
        public const string CALL_SOURCE_INFO = "CallSourceInfo";
    }


    public struct XUIDAndTrust : IComparable
    {
        private const uint XONLINE_USER_GUEST_MASK      = 0x00000003;
        private const uint XONLINE_USER_VOICE_NOT_ALLOWED    = 0x00010000;
        private const uint XONLINE_USER_PURCHASE_NOT_ALLOWED = 0x00020000;
        private const uint XONLINE_USER_COUNTRY_MASK    = 0x0000FF00;

        public ulong    qwUserID;
        public uint     dwUserFlags;
        public float    userTrust;

        public XUIDAndTrust(ulong userID, uint userFlags, float paramUserTrust)
        {
            qwUserID = userID;
            dwUserFlags = userFlags;
            userTrust = paramUserTrust;
        }

        public int CompareTo(object obj)
        {
            return qwUserID.CompareTo(((XUIDAndTrust) obj).qwUserID);
        }

        public uint GuestNumber()
        {
            return dwUserFlags & XONLINE_USER_GUEST_MASK;
        }

        public bool IsGuest()
        {
            return (GuestNumber() != 0);
        }

        public byte UserCountry()
        {
            return (byte)((dwUserFlags & XONLINE_USER_COUNTRY_MASK) >> 8);
        }

        public bool CanPurchase()
        {
            return ((dwUserFlags & (XONLINE_USER_GUEST_MASK | XONLINE_USER_PURCHASE_NOT_ALLOWED)) == 0);
        }

    }

    public class BundledAuthData
    {
        public const string HTTP_HEADER_BUNDLED_AUTH_DATA = "BundledAuthData";
        public const ushort HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION = 1;

        public BundledAuthData(uint paramTitleID, XUIDAndTrust[] paramUsers)
        {
            titleID = paramTitleID;
            users = paramUsers;
        }

        public BundledAuthData(string base64EncodedString)
        {
            BinaryReader reader = new BinaryReader(new MemoryStream(Convert.FromBase64String(base64EncodedString)));
            ushort wBundledAuthDataVersion;

            wBundledAuthDataVersion = reader.ReadUInt16();
            if(wBundledAuthDataVersion != HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION)
            {
                throw new ExceptionWithEventId(XEvent.Id.TOOLS_HACK_0, "BundledAuthData: Auth data version ("
                    + wBundledAuthDataVersion + ") is incorrect!");
            }
            users = new XUIDAndTrust[reader.ReadUInt16()];
            titleID = reader.ReadUInt32();
            for (int i=0; i<users.Length; ++i)
            {
                users[i] = new XUIDAndTrust(reader.ReadUInt64(), reader.ReadUInt32(), reader.ReadSingle());
            }
        }

        public string GetBase64EncodedString()
        {
            MemoryStream memStream = new MemoryStream(users.Length * 16 + 8);

            BinaryWriter writer = new BinaryWriter(memStream);

            writer.Write(HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION);
            writer.Write((ushort)users.Length);
            writer.Write(titleID);
            for (int i=0; i<users.Length; ++i)
            {
                writer.Write(users[i].qwUserID);
                writer.Write(users[i].dwUserFlags);
                writer.Write(users[i].userTrust);
            }

            return Convert.ToBase64String(memStream.ToArray());
        }

        public readonly uint     titleID;
        public XUIDAndTrust[]   users;

        public void VerifyTitleId(uint titleId)
        {
            if (AuthToggle.Off)
                return;

            if( titleId != titleID )
            {
                throw new ExceptionWithEventId( XEvent.Id.TOOLS_HACK_1, "BundleAuthData.Verify: Title ID *" + titleId.ToString("X") + "* (Bundle says " + titleID.ToString("X") + ") cannot be verfied.");
            }
        }


    }

    public class HTTPAuthData : SGInfo
    {
        public const string HTTP_HEADER_AUTH_DATA = "HTTPAuthData";
        public const ushort HTTP_HEADER_AUTH_DATA_VERSION = 3;

        //use this ONLY if you are using XRL common code and won't have SGInfo available (like for tools)
        public HTTPAuthData( ) : this( 0, 0, 0, 0, 0, 0, 0 )
        {

    }

        public HTTPAuthData(ushort port, uint ip, ulong requestId, ulong userID, uint titleID, uint serviceId1, uint serviceId2) : base(port, ip, requestId)
        {
            wAuthDataSize    = 0;
            wMajorVersion    = 0;
            wMinorVersion    = 0;
            wBuildNumber     = 0;
            wQFENumber       = 0;
            dwTitleID        = titleID;
            dwTitleVersion   = 0;
            dwTitleRegion    = 0;
            dwConsoleRegion  = 0;
            dwMediaID        = 0;
            wLanguageID      = 0;
            dwAuthDataFlags  = 0;

            qwXboxID         = 0;

            // users (XUIDAndTrust)
            xUsers = new XUIDAndTrust[XONLINE_MAX_LOGON_USERS];
            xUsers[0] = new XUIDAndTrust(userID, 0, 0.0F);
            for( int i = 1; i < XONLINE_MAX_LOGON_USERS; i++ )
            {
                xUsers[i] = new XUIDAndTrust(0, 0, 0.0F);
            }

            // privileges
            wNumPrivileges = 0;
            dwPrivileges = new uint[XONLINE_NUM_PRIVILEGE_DWORDS];

            if ( serviceId1 > 0 && serviceId1 < XONLINE_MAX_PRIVILEGE_ID )
            {
                dwPrivileges[0] |= ((uint)1) << (byte)serviceId1;
                wNumPrivileges++;
            }
            if ( serviceId2 > 0 && serviceId2 < XONLINE_MAX_PRIVILEGE_ID )
            {
                dwPrivileges[0] |= ((uint)1) << (byte)serviceId2;
                wNumPrivileges++;
            }

            // services
            wNumDwordServices = 0;
            dwServiceIds = new uint[XONLINE_MAX_DWORD_SERVICEIDS];

            if ( serviceId1 > XONLINE_MAX_PRIVILEGE_ID )
            {
                dwServiceIds[wNumDwordServices++] = serviceId1;
            }

            if ( serviceId2 > XONLINE_MAX_PRIVILEGE_ID )
            {
                dwServiceIds[wNumDwordServices++] = serviceId2;
            }

            dwAltTitleID = new uint[XONLINE_MAX_ALTERNATE_TITLE_ID];
            for( int i = 0; i < XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
            {
                dwAltTitleID[i] = 0;
            }

            key = new byte[XONLINE_KEY_LENGTH];
        }

        public HTTPAuthData(ushort port, uint ip, ulong requestId, ulong xboxID, XUIDAndTrust[] users, uint titleID, uint serviceId1, uint serviceId2) : base(port, ip, requestId)
        {
            wAuthDataSize    = 0;
            wMajorVersion    = 0;
            wMinorVersion    = 0;
            wBuildNumber     = 0;
            wQFENumber       = 0;
            dwTitleID        = titleID;
            dwTitleVersion   = 0;
            dwTitleRegion    = 0;
            dwConsoleRegion  = 0;
            dwMediaID        = 0;
            wLanguageID      = 0;
            dwAuthDataFlags  = 0;

            wNumPrivileges   = 0;
            dwPrivileges = new uint[XONLINE_NUM_PRIVILEGE_DWORDS];

            qwXboxID         = xboxID;

            // users (XUIDAndTrust)
            xUsers = new XUIDAndTrust[XONLINE_MAX_LOGON_USERS];
            for( int i = 0; i < XONLINE_MAX_LOGON_USERS; i++ )
            {
                if (i < users.Length)
                {
                    xUsers[i] = users[i];
                }
                else
                {
                    xUsers[i] = new XUIDAndTrust(0, 0, 0.0F);
                }
            }

            // privileges and services
            if ( serviceId1 > 0 && serviceId1 < XONLINE_MAX_PRIVILEGE_ID )
            {
                dwPrivileges[0] |= ((uint)1) << (byte)serviceId1;
                wNumPrivileges++;
            }
            if ( serviceId2 > 0 && serviceId2 < XONLINE_MAX_PRIVILEGE_ID )
            {
                dwPrivileges[0] |= ((uint)1) << (byte)serviceId2;
                wNumPrivileges++;
            }

            wNumDwordServices = 0;
            dwServiceIds = new uint[XONLINE_MAX_DWORD_SERVICEIDS];

            if ( serviceId1 > XONLINE_MAX_PRIVILEGE_ID )
            {
                dwServiceIds[wNumDwordServices++] = serviceId1;
            }

            if ( serviceId2 > XONLINE_MAX_PRIVILEGE_ID )
            {
                dwServiceIds[wNumDwordServices++] = serviceId2;
            }

            dwAltTitleID = new uint[XONLINE_MAX_ALTERNATE_TITLE_ID];
            for( int i = 0; i < XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
            {
                dwAltTitleID[i] = 0;
            }

            key = new byte[XONLINE_KEY_LENGTH];
        }

        public string GetBase64EncodedString()
        {
            return ConstructBase64String();
        }
    }


    //
    //  AuthToggle: Wraps the guts of turning on/off SG auth checking by config file.
    //
    public class AuthToggle
    {
        private static bool mGotSetting = false;

        // static toggle saying whether to ignore auth data from SG
        // default to TRUE
        //
        private static bool mVerifyAuthData = true;

        // static constructor to get config settings for XBOS.
        private static void GetAuthToggle()
        {
            string r = Config.GetSetting(Setting.sginfo_verifyAuth);
            if(r != null)
            {
                r = r.ToUpper();
                if( r == "FALSE" || r == "NO" || r == "OFF" )
                {
                  Xom.NtEvent( XEvent.Id.TOOLS_CONFIG_0,
                        "SG AUTH DATA VERIFICATION HAS BEEN TURNED OFF. This should NEVER happen in production." );

                    mVerifyAuthData = false;
                }
            }
            mGotSetting = true;
        }

        public static bool On
        {
            get
            {
                if(mGotSetting == false)
                {
                    GetAuthToggle();
                }
                return (mVerifyAuthData == true);
            }
        }

        public static bool Off
        {
            get
            {
                if(mGotSetting == false)
                {
                    GetAuthToggle();
                }
                return (mVerifyAuthData == false);
            }
        }

    }

    public class SGInfo
    {

        // the following structures are defined in xonline.x for the XSGInfo stuff.
        // they are mirrored here.
        //
        private struct sgMessageHeader
        {
            public ushort _wType;
            public ushort _cbEnt;
        }
        const int sizeMessageHeader = 4;

        private struct sgMessageSpiRequest
        {
            public uint   _dwReqNum;    // request number from requester
            public uint   _ipaZ;        // this is an IN_ADDR with just the "long" part exposed
            public ushort _ipportZ;     // IP port of client on DMZ
        }
        const int sizeMessageSpiRequest = 10;

        private struct sgMessageSpiResponse
        {
            public uint   _dwReqNum;
            public uint   _ipaZ;
            public ushort _ipportZ;
            public byte   _fNotFound;
        }
        const int sizeMessageSpiResponse = 11;

        protected const int XONLINE_MAX_LOGON_USERS        = 4;
        protected const int XONLINE_MAX_ALTERNATE_TITLE_ID = 4;
        protected const int XONLINE_MAX_NUMBER_SERVICE_PER_TICKET = 12;
        protected const int XONLINE_MAX_DWORD_SERVICEIDS   = 4;
        protected const int XONLINE_MAX_PRIVILEGE_ID       = 256;
        protected const int XONLINE_NUM_PRIVILEGE_DWORDS   = 8;
        protected const int XONLINE_KEY_LENGTH = 16;
        protected const int XONLINE_SG_MESSAGE_PORT       = 0xFFFF;
        protected const int XONLINE_SG_REQ_RETRIES        = 4;        // Number of retries. Each retry doubles prevous timeout.
        protected const int XONLINE_SG_REQ_TIMEOUT        = 200000;   // 200 milliseconds timeout for first request, doubled every subsequent request
                                                                      // Net result is 4 requests with timeouts of 200, 400, 800, and 1600 milliseconds
        protected const ushort XONLINE_AUTHDATA_VERSION   = 0x02 ;
        protected const ushort XONLINE_XENON_AUTHDATA_VERSION   = 0x03 ;
        protected const ushort SGMSG_TYPE_SPIDATA_REQ     = 0x4710;  // CSgMsgSpiReq2
        protected const ushort SGMSG_TYPE_SPIDATA_REP     = 0x4711;  // CSgMsgSpiRep2

        protected const ushort SGMSG_TYPE_SPIDATA         = 0x4782;  // CSgMsgSpiData2 in the payload
        protected const ushort SGMSG_TYPE_AUTHDATA        = 0x4783;  // CAuthData2 in the payload

        //  the following fields are in the SG Info structure. (XKERB_AD_XENON)
        //

        protected ushort    wAuthDataVersion;
        protected ushort    wAuthDataSize;        // Size of this struct in bytes

        // XBOX_LIBRARY_VERSION     clientVersion;
        protected ushort    wMajorVersion;
        protected ushort    wMinorVersion;
        protected ushort    wBuildNumber;
        protected ushort    wQFENumber;
        //

        protected uint      dwTitleID;
        protected uint      dwTitleVersion;
        protected uint      dwTitleRegion;
        protected uint      dwConsoleRegion;
        protected uint      dwMediaID;
        protected ushort    wLanguageID;

        // authdata flags
        public const uint XONLINE_AUTHDATA_FLAGS_ISXENON_MASK = 0x01;
        protected uint      dwAuthDataFlags;

        protected ushort    wNumPrivileges;
        protected uint[]    dwPrivileges;

        protected ulong     qwXboxID;

        //List of alternate title IDs
        //DWORD dwAltTitleID[XONLINE_MAX_ALTERNATE_TITLE_ID]
        protected uint[]    dwAltTitleID;

        // Key used for signing data within a session
        protected byte[]    key;

        // The high 16 bits of dwUserFlags should come from the UODB User Table.
        protected XUIDAndTrust[]   xUsers;

        protected uint     dwNumServices;
        protected ushort   wNumDwordServices;

        //DWORD dwServiceID[XONLINE_MAX_NUMBER_SERVICE_PER_TICKET];
        protected uint[]   dwServiceIds;
        //

        // the rest of the spidata structure (CSgMsgSpiData)

        protected ushort  _ipportI;                   // IP port of the client on the Internet
        protected uint    _ipaI;                      // IP address of the client on the Internet
        protected byte[]  _sgaddr;                    // SGADDR of the client
        protected ushort  _wVersionKeyEx;             // KeyEx version of the client
        protected ushort  _wFlagsKeyEx;               // Flags sent in KeyEx initiator
        protected ulong   _liNonce;                   // A random nonce associated with this session
        protected ulong   _liTimeInit;                // FILETIME marking session initiation
        protected uint    _fCs;                       // TRUE if SG is providing connection services

        // size of the spidata structure
        protected const int sizeSpiData = 186;
        protected const int sizeSpiData2 = 54;


        // the following is the STATIC request number.  it is initialized to 0, and
        // should only be used with the Interlocked.Increment protection
        //
        protected static int staticRequestNumber = 0;

        // the instance reqnum, set when a request is first made.
        protected int thisRequestNumber;

        // config settings
        //
        protected static int _maxRetries;
        protected static int _sgTimeout;

        // SG ip
        protected IPAddress _srcIP;

        public static SGInfo Current
        {
            get
            {
                if (AuthToggle.Off)
                    return null;

                SGInfo sg = null;
                if (HttpContext.Current != null)
                {
                    sg = (SGInfo)HttpContext.Current.Items["SGInfo"];
                }

                if (sg == null)
                {
                    sg = new SGInfo();
                    if (HttpContext.Current != null)
                    {
                        HttpContext.Current.Items["SGInfo"] = sg;
                    }
                }

                return sg;
            }
        }

        static SGInfo()
        {
            // load config settings
            _maxRetries = 3;

            _sgTimeout = 20;
        }

        public SGInfo()
        {
        }

        // This is a special constructor for HTTPAuthData construction
        public SGInfo(ushort port, uint ip, ulong requestId)
        {
            CreateSGInfoData(port, ip, requestId);
        }


        /// <summary>
        /// The default constructor will create a new SGInfo with all the current information from
        /// the security gateway.
        /// </summary>

        public SGInfo(string httAuthData)
        {

                    byte[] httpBytes = Convert.FromBase64String(httAuthData);
                    string[] strs = ByteConvert.ToFormattedStrings(httpBytes);
                    foreach (string s in strs)
                    {
                        Console.WriteLine(s);
                    }


                    BinaryReader sgInfo = new BinaryReader(new MemoryStream(httpBytes));

                    ushort version = sgInfo.ReadUInt16();
                    if (version == SGMSG_TYPE_SPIDATA_REP)
                    {
                        // auth data from an SG, treat it like normal sg information
                        sgInfo.BaseStream.Seek(0, SeekOrigin.Begin);

                        VerifyResponse(sgInfo, false);
                        ReadSgInfo(sgInfo, false);
                    }
                    else if (version == HTTPAuthData.HTTP_HEADER_AUTH_DATA_VERSION)
                    {
                        _ipportI         = sgInfo.ReadUInt16();
                        _ipaI            = sgInfo.ReadUInt32();
                        _sgaddr          = null;
                        _wVersionKeyEx   = 0;
                        _wFlagsKeyEx     = 0;
                        _liNonce         = sgInfo.ReadUInt64();
                        _liTimeInit      = (ulong)DateTime.Now.Ticks;
                        _fCs             = 0;

                        ReadSgInfo(sgInfo, true);
                    }
                    else
                    {
                        throw new ExceptionWithEventId(XEvent.Id.TOOLS_HACK_2, "SGInfo: HTTP AuthData has bad version: " + version.ToString() );
                    }
        }


        // This is a special constructor for HTTPAuthData construction
        public void CreateSGInfoData(ushort port, uint ip, ulong requestId)
        {
            wAuthDataVersion = XONLINE_XENON_AUTHDATA_VERSION;
            _ipportI = port;
            _ipaI = ip;
            _liNonce = requestId;

            _sgaddr          = null;
            _wVersionKeyEx   = 0;
            _wFlagsKeyEx     = 0;
            _liTimeInit      = (ulong)DateTime.Now.Ticks;
            _fCs             = 0;

            wNumPrivileges = 0;
            dwPrivileges = new uint[XONLINE_NUM_PRIVILEGE_DWORDS];

            wNumDwordServices = 0;
            dwServiceIds = new uint[XONLINE_MAX_DWORD_SERVICEIDS];

            xUsers = new XUIDAndTrust[XONLINE_MAX_LOGON_USERS];
            for( int i = 0; i < XONLINE_MAX_LOGON_USERS; i++ )
            {
                xUsers[i] = new XUIDAndTrust(0, 0, 0.0F);
            }

            dwAltTitleID = new uint[XONLINE_MAX_ALTERNATE_TITLE_ID];

            key = new byte[XONLINE_KEY_LENGTH];
        }

        public static bool HasSGInfo()
        {
            HttpContext ctx = HttpContext.Current;
            string viface = VirtualInterface.None;
            bool fHasSGInfo = true;

            if (null != ctx.Items[CallSource.CALL_SOURCE_INFO])
            {
                viface = (string)ctx.Items[CallSource.CALL_SOURCE_INFO];

                if (viface != VirtualInterface.None)
                {
                    IVirtualInterfaceInfo viinfo = Config.GetVirtualInterface(viface);
                    if (null != viinfo)
                    {
                        fHasSGInfo = viinfo.NeedSGInfo;
                    }

                }
            }

            return fHasSGInfo;
        }

        private void ReadSgInfo(BinaryReader reader, bool onlyAuthData)
        {
            sgMessageHeader authHdr;
            authHdr._wType = SGMSG_TYPE_AUTHDATA;
            authHdr._cbEnt = 0;

            // if we're getting more than authdata then get ready to read the spy.
            if (!onlyAuthData)
            {
                _ipportI         = reader.ReadUInt16();
                _ipaI            = reader.ReadUInt32();
                _sgaddr          = reader.ReadBytes(20);
                _wVersionKeyEx   = reader.ReadUInt16();
                _wFlagsKeyEx     = reader.ReadUInt16();
                _liNonce         = reader.ReadUInt64();
                _liTimeInit      = reader.ReadUInt64();
                _fCs             = reader.ReadUInt32();

                // read the spi header.
                authHdr._wType   = reader.ReadUInt16();
                authHdr._cbEnt   = reader.ReadUInt16();
            }

            wAuthDataVersion = reader.ReadUInt16();
            if(wAuthDataVersion == XONLINE_XENON_AUTHDATA_VERSION)
            {
                ReadXenonSgInfo(reader, authHdr, onlyAuthData);
            }
            else if (wAuthDataVersion == XONLINE_AUTHDATA_VERSION)
            {
                ReadV2SgInfo(reader, authHdr, onlyAuthData);
            }
            else
            {
                throw new ExceptionWithEventId(XEvent.Id.TOOLS_HACK_3, "SGInfo: Auth data from SG("+_srcIP+") version ("
                    + wAuthDataVersion + ") is incorrect!");
            }

        }

        private void ReadXenonSgInfo(BinaryReader reader, sgMessageHeader authHdr, bool onlyAuthData)
        {

            wAuthDataSize    = reader.ReadUInt16();
            wMajorVersion    = reader.ReadUInt16();
            wMinorVersion    = reader.ReadUInt16();
            wBuildNumber     = reader.ReadUInt16();
            wQFENumber       = reader.ReadUInt16();
            dwTitleID        = reader.ReadUInt32();
            dwTitleVersion   = reader.ReadUInt32();
            dwTitleRegion    = reader.ReadUInt32();
            dwConsoleRegion  = reader.ReadUInt32();
            dwMediaID        = reader.ReadUInt32();
            wLanguageID      = reader.ReadUInt16();
            dwAuthDataFlags  = reader.ReadUInt32();

            wNumPrivileges   = reader.ReadUInt16();

            dwPrivileges = new uint[XONLINE_NUM_PRIVILEGE_DWORDS];
            for( int i = 0; i < XONLINE_NUM_PRIVILEGE_DWORDS; i++ )
            {
                dwPrivileges[i] = reader.ReadUInt32();
            }

            // read Xbox puid
            qwXboxID         = reader.ReadUInt64();

            // read users (XUIDAndTrust)
            xUsers = new XUIDAndTrust[XONLINE_MAX_LOGON_USERS];
            for( int i = 0; i < XONLINE_MAX_LOGON_USERS; i++ )
            {
                xUsers[i] = new XUIDAndTrust(reader.ReadUInt64(), reader.ReadUInt32(), 0.0F);
            }
            Xom.Trace(XomAreaName.sginfotrace, LogLevel.L_NORMAL, string.Format("Users:({0},{1},{2},{3}),
                xUsers[0].qwUserID,xUsers[1].qwUserID,xUsers[2].qwUserID,xUsers[3].qwUserID));

            // read user trust factors.
            for( int i = 0; i < XONLINE_MAX_LOGON_USERS; i++ )
            {
                // set the user trust factor.
                xUsers[i].userTrust = reader.ReadSingle();
            }

            wNumDwordServices = reader.ReadUInt16();

            dwServiceIds = new uint[XONLINE_MAX_DWORD_SERVICEIDS];

            // read DWORD service ids
            for( int i = 0; i < XONLINE_MAX_DWORD_SERVICEIDS; i++ )
            {
                uint serviceID = reader.ReadUInt32();
                if ( serviceID != 0 )
                {
                    dwServiceIds[dwNumServices++] = serviceID;
                }
            }

            dwNumServices = (uint)(wNumPrivileges + wNumDwordServices);

            dwAltTitleID = new uint[XONLINE_MAX_ALTERNATE_TITLE_ID];

            //  read additional auth data information for later auth data structures.
            // read alternate title IDs
            for( int i = 0; i < XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
            {
                dwAltTitleID[i] = reader.ReadUInt32();
            }

            // read ticket key
            key = reader.ReadBytes(XONLINE_KEY_LENGTH);
        }

        private void ReadV2SgInfo(BinaryReader reader, sgMessageHeader authHdr, bool onlyAuthData)
        {

            wAuthDataSize    = reader.ReadUInt16();
            wMajorVersion    = reader.ReadUInt16();
            wMinorVersion    = reader.ReadUInt16();
            wBuildNumber     = reader.ReadUInt16();
            wQFENumber       = reader.ReadUInt16();
            dwTitleID        = reader.ReadUInt32();
            dwTitleVersion   = reader.ReadUInt32();
            dwTitleRegion    = reader.ReadUInt32();
            qwXboxID         = reader.ReadUInt64();

            // read users (XUIDAndTrust)
            xUsers = new XUIDAndTrust[XONLINE_MAX_LOGON_USERS];
            for( int i = 0; i < XONLINE_MAX_LOGON_USERS; i++ )
            {
                xUsers[i] = new XUIDAndTrust(reader.ReadUInt64(), reader.ReadUInt32(), 0.0F);
            }
            Xom.Trace(XomAreaName.sginfotrace, LogLevel.L_NORMAL, string.Format("Users:({0},{1},{2},{3}),
                xUsers[0].qwUserID,xUsers[1].qwUserID,xUsers[2].qwUserID,xUsers[3].qwUserID));

            // read services
            dwNumServices = reader.ReadUInt32();
            dwServiceIds = new uint[XONLINE_MAX_NUMBER_SERVICE_PER_TICKET];
            for( int i = 0; i < XONLINE_MAX_NUMBER_SERVICE_PER_TICKET; i++ )
            {
                dwServiceIds[i]  = reader.ReadUInt32();
            }


            dwAltTitleID = new uint[XONLINE_MAX_ALTERNATE_TITLE_ID];

            //  read additional auth data information for later auth data structures.
            if ( authHdr._wType  == SGMSG_TYPE_AUTHDATA )
            {
                // read user truct factors.
                for( int i = 0; i < XONLINE_MAX_LOGON_USERS; i++ )
                {
                    // set the user trust factor.
                    xUsers[i].userTrust = reader.ReadSingle();
                }

                // read alternate title IDs
                for( int i = 0; i < XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
                {
                    dwAltTitleID[i] = reader.ReadUInt32();
                }

                // read ticket key
                key = reader.ReadBytes(XONLINE_KEY_LENGTH);
            }
            else
            {
                for( int i = 0; i < XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
                {
                    dwAltTitleID[i] = 0;
                }
                key = new byte[XONLINE_KEY_LENGTH];
            }

            // dummy data from v3 privs
            dwPrivileges = new uint[XONLINE_NUM_PRIVILEGE_DWORDS];

        }


        private byte[] BuildRequest(IPAddress ip, ushort port)
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter wr = new BinaryWriter(ms);
            sgMessageHeader header;
            sgMessageSpiRequest req;
            byte[] reqSize;

            // build the data into structs for clean maintenance
            header._wType = SGMSG_TYPE_SPIDATA_REQ;
            header._cbEnt = sizeMessageHeader + sizeMessageSpiRequest;
            thisRequestNumber = Interlocked.Increment(ref staticRequestNumber);
            req._dwReqNum = (uint)thisRequestNumber;

            byte[] addr = ip.GetAddressBytes();
            req._ipaZ     = ((uint)addr[0]) + ((uint)addr[1] << 8) + ((uint)addr[2] << 16) + ((uint)addr[3] << 24);
            req._ipportZ  = port;

            // now stream the structs out into a byte array.
            wr.Write(header._wType);
            wr.Write(header._cbEnt);
            wr.Write(req._dwReqNum);
            wr.Write(req._ipaZ);
            wr.Write(req._ipportZ);

            reqSize = ms.ToArray();
            Debug.Assert (reqSize.Length == header._cbEnt);

            return reqSize;
        }

        bool VerifyResponse(BinaryReader br, bool verifyRequestNum)
        {
            sgMessageHeader header;
            sgMessageSpiResponse reply;

            header._wType = br.ReadUInt16();
            if (header._wType != SGMSG_TYPE_SPIDATA_REP)
            {
                throw new ExceptionWithEventId (XEvent.Id.TOOLS_HACK_4, "SGInfo: Unhandleable response type 0x" + header._wType.ToString("x"));
            }

            header._cbEnt = br.ReadUInt16();
            if (header._cbEnt != (sizeMessageHeader + sizeMessageSpiResponse))
            {
                throw new ExceptionWithEventId (XEvent.Id.TOOLS_HACK_5, "SGInfo: Unexpected SG reply size (" + header._cbEnt + ")."
                    + " Expected size is " + (sizeMessageHeader + sizeMessageSpiResponse));
            }

            reply._dwReqNum = br.ReadUInt32();
            reply._ipaZ = br.ReadUInt32();
            reply._ipportZ = br.ReadUInt16();
            reply._fNotFound = br.ReadByte();

            if (reply._fNotFound != 0)
            {
                IPAddress ipZ = new IPAddress (reply._ipaZ);
                throw new ExceptionWithEventId (XEvent.Id.TOOLS_HACK_6, "SGInfo: SG replies saying auth data NOT FOUND for " +
                    ipZ.ToString() + ":" + reply._ipportZ + " (DMZ)");
            }

            // make sure reqnum is the same as the request we sent.
            if (verifyRequestNum && reply._dwReqNum != (uint)thisRequestNumber)
            {
                return false;
            }

            // next reade the header on the auth data itself (as distinct from the
            // header on the SG reply, which is read above).
            header._wType = br.ReadUInt16();
            if (header._wType != SGMSG_TYPE_SPIDATA)
            {
                throw new ExceptionWithEventId (XEvent.Id.TOOLS_HACK_7, "SGInfo: Unexpected auth payload type 0x" + header._wType.ToString("x")
                    + "... Expected type SGMSG_TYPE_SPIDATA" );
            }

            header._cbEnt = br.ReadUInt16();
            if ( header._cbEnt != sizeSpiData2 )
            {
                throw new ExceptionWithEventId (XEvent.Id.TOOLS_HACK_8, "SGInfo: Unexpected SG auth data size (" + header._cbEnt + ")."
                    + " Expected size is " + sizeSpiData2);
            }

            // if we made it this far, we should be ready to roll.
            return true;
        }


        public override string ToString()
        {
            try
            {
                int i;
                bool b;
                StringBuilder bldr = new StringBuilder();


                bldr.Append("Source:    " + _srcIP + "\r\n");
                bldr.Append("TitleId:   0x" + TitleId.ToString("X") + "\r\n");
                bldr.Append("TitleVer:  0x");
                bldr.Append(dwTitleVersion.ToString("X"));
                bldr.Append("\r\nTitleRgn:   0x");
                bldr.Append(dwTitleRegion.ToString("X"));
                bldr.Append("\r\nConsoleRgn: 0x");
                bldr.Append(dwConsoleRegion.ToString("X"));
                bldr.Append("\r\nMediaID: 0x");
                bldr.Append(dwMediaID.ToString("X"));
                bldr.Append("\r\nLanguageID: ");
                bldr.Append(wLanguageID);
                bldr.Append("\r\nAuthDataFlags: 0x");
                bldr.Append(dwAuthDataFlags.ToString("X"));
                bldr.Append("\r\nXboxLibVer: ");
                bldr.Append(wMajorVersion);
                bldr.Append(".");
                bldr.Append(wMinorVersion);
                bldr.Append(".");
                bldr.Append(wBuildNumber);
                bldr.Append(".");
                bldr.Append(wQFENumber);

                bldr.Append("\r\nMachineId: 0x" + MachineId.ToString("X"));
                bldr.Append("\r\nClientIP:  " + ClientIP.ToString());

                b = false;
                for (i = 0; i < XONLINE_MAX_LOGON_USERS; i++)
                {
                    if (xUsers != null && xUsers[i].qwUserID != 0)
                    {
                        bldr.Append("\r\nU" + i.ToString() + ": 0x" + xUsers[i].qwUserID.ToString("X") + " (" + xUsers[i].dwUserFlags.ToString("X") + "," + xUsers[i].userTrust.ToString() + ")\r\n");
                        b = true;
                    }

                }
                if (b == false)
                {
                    bldr.Append("\r\nno users present.");
                }

                b = false;
                for (i = 0; i < XONLINE_MAX_PRIVILEGE_ID; i++)
                {
                    if ( dwPrivileges != null && IsServicePresent(i) )
                    {
                        bldr.Append("\r\nSVC" + i.ToString() + ": 0x" + i.ToString("X") + "");
                        b = true;
                    }
                }
                for (i = 0; i < XONLINE_MAX_DWORD_SERVICEIDS; i++)
                {
                    if (dwServiceIds != null && dwServiceIds[i] != 0)
                    {
                        bldr.Append("\r\nSVC" + i.ToString() + ": 0x" + dwServiceIds[i].ToString("X") + "");
                        b = true;
                    }
                }
                if (b == false)
                {
                    bldr.Append("\r\nno services present (How did this get through SG?!?!?)");
                }

                b = false;
                for (i = 0; i < XONLINE_MAX_ALTERNATE_TITLE_ID; i++)
                {
                    if (dwAltTitleID != null && dwAltTitleID[i] != 0)
                    {
                        bldr.Append("\r\nAltTitleID" + i.ToString() + ": 0x" + dwAltTitleID[i].ToString("X"));
                        b = true;
                    }
                }
                if (b == false)
                {
                    bldr.Append("\r\nno AltTitleID present");
                }

                return bldr.ToString();
            }
            catch(Exception e)
            {
                return "Error building SGInfo.ToString(): " + e.ToString();
            }
        }


        public string ToXomLogString()
        {
            try
            {
                StringBuilder bldr = new StringBuilder();

                bldr.Append(TitleId.ToString("X8")+"|");
                bldr.Append(dwTitleVersion.ToString("X8")+"|");
                bldr.Append(dwTitleRegion.ToString("X8")+"|");
                bldr.Append(ClientIP.ToString() + "|");
                bldr.Append(MachineId.ToString("X16")+"|");

                for (int i = 0; i < XONLINE_MAX_LOGON_USERS; i++)
                {
                    if (xUsers != null && xUsers[i].qwUserID != 0)
                    {
                        bldr.Append(xUsers[i].qwUserID.ToString("X16") + "|" );
                    }
                    else
                    {
                        bldr.Append("0|");
                    }

                }

                return bldr.ToString();
            }
            catch(Exception e)
            {
                return "Error building SGInfo.ToXomLogString(): " + e.ToString();
            }
        }


        // public accessors and helper methods
        public ushort MajorVersion { get { return wMajorVersion; } }
        public ushort MinorVersion { get { return wMinorVersion; } }
        public ushort BuildNumber { get { return wBuildNumber; } }
        public ushort QFENumber { get { return wQFENumber; } }
        public uint AltTitleId1 { get { return dwAltTitleID[ 0 ]; } }
        public uint AltTitleId2 { get { return dwAltTitleID[ 1 ]; } }
        public uint AltTitleId3 { get { return dwAltTitleID[ 2 ]; } }
        public uint AltTitleId4 { get { return dwAltTitleID[ 3 ]; } }
        public uint TitleRegion { get { return dwTitleRegion; } }
        public ushort ClientPort { get { return _ipportI; } }

        public uint TitleId
        {
            get { return dwTitleID; }
        }

        public uint TitleVersion
        {
            get { return dwTitleVersion; }
        }

        public uint ConsoleRegion
        {
            get { return dwConsoleRegion; }
        }

        public uint MediaID
        {
            get { return dwMediaID; }
        }

        public ushort LanguageID
        {
            get { return wLanguageID; }
        }

        public uint AuthDataFlags
        {
            get { return dwAuthDataFlags; }
        }

        public ulong MachineId
        {
            get { return qwXboxID; }
        }

        public IPAddress ClientIP
        {
            get { return new IPAddress(_ipaI); }
        }

        public ulong TimeSessionStarted
        {
            get { return _liTimeInit; }
        }

        public XUIDAndTrust[] LogonUsers
        {
            get { return xUsers; }
        }

        public ulong Nonce
        {
            get { return _liNonce; }
        }

        public bool IsUserPresent(ulong passportId)
        {
            int i;
            for(i = 0; i < XONLINE_MAX_LOGON_USERS; i++ )
            {
                if(xUsers[i].qwUserID == passportId && !xUsers[i].IsGuest())
                {
                    return true;
                }
            }

            return false;
        }

        public bool CanUserPurchase(ulong passportId)
        {
            int i;
            for(i = 0; i < XONLINE_MAX_LOGON_USERS; i++ )
            {
                if(xUsers[i].qwUserID == passportId)
                {
                    if(xUsers[i].CanPurchase())
                    {
                        return true;
                    }
                }
            }

            // user not found, or can't purchase
            return false;
        }

        public byte GetUserCountry(ulong passportId)
        {
            int i;
            for(i = 0; i < XONLINE_MAX_LOGON_USERS; i++ )
            {
                if(xUsers[i].qwUserID == passportId && !xUsers[i].IsGuest())
                {
                    return (xUsers[i].UserCountry());
                }
            }

            // user not found
            return 0;
        }

        public float GetUserTrust(ulong passportId)
        {
            int i;
            for(i = 0; i < XONLINE_MAX_LOGON_USERS; i++ )
            {
                if(xUsers[i].qwUserID == passportId && !xUsers[i].IsGuest())
                {
                    return (xUsers[i].userTrust);
                }
            }

            // user not found
            return Single.NaN;
        }

        public string GetUserLocale()
        {
            // TODO: Load the locale setting out of the ticket and make it available here
            return "en-US";
        }

        public bool IsServicePresent(XOService serviceId)
        {
            return IsServicePresent((int) serviceId);
        }

        public bool IsServicePresent(int serviceId)
        {
            // base services are represented using the privilege bits
            // dword services are stored in a separate four element array
            if ( serviceId < XONLINE_MAX_PRIVILEGE_ID )
            {
                // find the DWORD containing this bit
                int dwordIndex = serviceId / 32;

                // find the bit offset within the DWORD
                int bitIndex = serviceId - dwordIndex*32;

                // create the mask
                uint mask = ((uint)1) << bitIndex;

                if ( (dwPrivileges[dwordIndex] & mask) == mask )
                {
                    return true;
                }
            }
            else
            {
                for (int i=0; i < dwServiceIds.Length; i++)
                {
                    if ( dwServiceIds[i] == (uint)serviceId )
                    {
                        return true;
                    }
                }
            }

            // service not found
            return false;
        }

        public bool IsXenonTitle()
        {
            bool isXenon =
                (dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISXENON_MASK) == XONLINE_AUTHDATA_FLAGS_ISXENON_MASK;

            return isXenon;
        }

        public bool IsXboxTitle()
        {
            return !IsXenonTitle();
        }

        public byte[] SignWithKey( byte[] data, int offset, int count )
        {
            HMACSHA1 shaM = new HMACSHA1(key);

            shaM.ComputeHash(data, offset, count);

            return shaM.Hash;
        }

        //
        // Set of public functions to perform verification on users, machines, and titles.
        //  All of these functions will throw exceptions if data doesn't match.
        //

        public static void VerifyMachineId(ulong machineId)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            if( sg.MachineId != machineId )
            {
                throw new ExceptionWithEventId( XEvent.Id.TOOLS_HACK_9, "SGInfo.Verify: Machine " + machineId.ToString("X") + " cannot be verfied "
                    + "(SG says " + sg.MachineId.ToString("X") + ")");
            }
        }

        public static void VerifyServiceId(XOService serviceId)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            if( !sg.IsServicePresent(serviceId) )
            {
                throw new ExceptionWithEventId( XEvent.Id.TOOLS_HACK_10, "SGInfo.Verify: Machine " + sg.MachineId.ToString("X") +
                    " is not supposed to have access to this service ("+ (int)serviceId + ")");
            }
        }

        public static void VerifyTitleId(uint titleId)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            if( titleId != sg.TitleId )
            {
                throw new ExceptionWithEventId( XEvent.Id.TOOLS_HACK_11, "SGInfo.Verify: Title ID *" + titleId.ToString("X") + "* (SG says " + sg.TitleId.ToString("X")
                    + ") cannot be verfied [" + "machine " + sg.MachineId.ToString("X") + "]");
            }
        }

        public static void VerifyTitleIdOrAlternate(uint titleId)
        {
            if (AuthToggle.Off)
            {
                return;
            }

            SGInfo sg = SGInfo.Current;

            if( titleId == sg.TitleId )
            {
                return;
            }

            for (int i=0; i < XONLINE_MAX_ALTERNATE_TITLE_ID; i++)
            {
                if (titleId == sg.dwAltTitleID[i])
                {
                    return;
                }
            }

            throw new XRLException(HResult.XONLINE_E_INVALID_TITLE_ID, XEvent.Id.TOOLS_HACK_12, "SGInfo.VerifyTitleIdOrAlternate: Title ID *" + titleId.ToString("X") + "* (SG says " + sg.TitleId.ToString("X")
                + "," + sg.dwAltTitleID[0].ToString("X")
                + "," + sg.dwAltTitleID[1].ToString("X")
                + "," + sg.dwAltTitleID[2].ToString("X")
                + "," + sg.dwAltTitleID[3].ToString("X")
                + ") cannot be verfied [" + "machine " + sg.MachineId.ToString("X") + "]");
        }

        public static void VerifyTitleVersion(uint titleVersion)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            if( titleVersion != sg.TitleVersion )
            {
                throw new ExceptionWithEventId( XEvent.Id.TOOLS_HACK_13, "SGInfo.Verify: Title Version *" + titleVersion.ToString("x") + "* (SG says " + sg.TitleVersion.ToString("x")
                    + ") cannot be verfied [" + "machine " + sg.MachineId + "]");
            }
        }

        public static void VerifyUserId(ulong passportId)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            if( !sg.IsUserPresent(passportId) )
            {
                throw new ExceptionWithEventId( XEvent.Id.TOOLS_HACK_14, "SGInfo.Verify: *User " + passportId.ToString("X") + "* cannot be verified ["
                    + "machine " + sg.MachineId.ToString("X") + "; title " + sg.TitleId.ToString("X") + "]");
            }
        }

        public static void VerifyUserCountryId(ulong passportId, byte countryId)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            if ( countryId != sg.GetUserCountry(passportId) )
            {
                throw new ExceptionWithEventId( XEvent.Id.TOOLS_HACK_15,
                    "SGInfo.Verify: User country (" + passportId.ToString("x") +
                    ";" + countryId + ") cannot be verified [countryId " +
                    sg.GetUserCountry(passportId) + "]");
            }
        }

        public static string ToStr()
        {
            try
            {
                return Current != null ? Current.ToString() : "(sgauth=off)";
            }
            catch(Exception e)
            {
                return "Error from SGInfo.ToString(). Exception:\n"+e.ToString();
            }
        }

        public static byte[] GetAuthData()
        {
            if (AuthToggle.Off)
            {
                return new byte[180];
            }

            SGInfo sg = SGInfo.Current;

            return sg.ConstructAuthData();
        }

        public byte[] ConstructAuthData()
        {
            int i;
            MemoryStream m = new MemoryStream();
            BinaryWriter w = new BinaryWriter(m);
            w.Write(wAuthDataVersion);
            w.Write(wAuthDataSize);
            w.Write(wMajorVersion);
            w.Write(wMinorVersion);
            w.Write(wBuildNumber);
            w.Write(wQFENumber);
            w.Write(dwTitleID);
            w.Write(dwTitleVersion);
            w.Write(dwTitleRegion);
            w.Write(dwConsoleRegion);
            w.Write(dwMediaID);
            w.Write(wLanguageID);
            w.Write(dwAuthDataFlags);

            w.Write(wNumPrivileges);
            Debug.Assert( dwPrivileges.Length == XONLINE_NUM_PRIVILEGE_DWORDS );
            for (i=0; i < dwPrivileges.Length; i++)
            {
                w.Write(dwPrivileges[i]);
            }

            w.Write(qwXboxID);
            for (i=0; i < xUsers.Length; i++)
            {
                w.Write(xUsers[i].qwUserID);
                w.Write(xUsers[i].dwUserFlags);
            }

            for (i=0; i < xUsers.Length; i++)
            {
                w.Write(xUsers[i].userTrust);
            }

            w.Write(wNumDwordServices);

            for (i=0; i < XONLINE_MAX_DWORD_SERVICEIDS; i++)
            {
                w.Write(dwServiceIds[i]);
            }

            for (i=0; i < XONLINE_MAX_ALTERNATE_TITLE_ID; i++)
            {
                w.Write(dwAltTitleID[i]);
            }

            w.Write(key);

            return m.ToArray();
        }

        public static string ToBase64String()
        {
            SGInfo sg;
            if (AuthToggle.Off)
            {
                //return "Auth Data is turned off!";
                sg = new SGInfo(0, 0, 0);
            }
            else
            {
                sg = SGInfo.Current;
            }

            return sg.ConstructBase64String();
        }

        public string ConstructBase64String()
        {
            MemoryStream m = new MemoryStream(200);
            BinaryWriter w = new BinaryWriter(m);
            w.Write(HTTPAuthData.HTTP_HEADER_AUTH_DATA_VERSION);
            w.Write(_ipportI);
            w.Write(_ipaI);
            w.Write(_liNonce);
            w.Write(ConstructAuthData());

            return Convert.ToBase64String(m.ToArray());
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\AzureRunner\app\PreRequisitesCheckCommandHandler.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using System.Xml;
using xonline.common.Azure;
using xonline.common.console;

namespace xonline.tools.AzureRunner
{
    [Command("PreRequisitesCheck", "Verifies storage account, certificate and connectivity to Azure management.")]
    [CommandLineParameter("SubscriptionId", "Subscription Id of the Azure account to be deployed to.", Required = true)]
    [CommandLineParameter("ApiCertificateThumbprint", "Thumbprint that uniquely identifies the certificate in the LocalMachine certificate store that will be used to authenticate to the Azure Management APIs.", Required = true)]
    [CommandLineParameter("ServiceName", "Name of the hosted service that will be hosting the deployment", Required = true)]
    [CommandLineParameter("StorageAccount", "The name of the storage account that the deployment package will be stored in.", Required = true)]
    [CommandLineParameter("DiagnosticsStorageAccount", "The name of the storage account that diagnostics information will be stored in.", Required = true)]
    public class PreRequisitesCheckCommandHandler : CommandHandlerBase
    {
        private Dictionary<string, string> _parameters;

        #region Internal Helper Methods

        /// <summary>
        /// Do as much parameter validation as we can before starting.
        /// Parse the deployment mode.
        /// </summary>
        /// <returns></returns>
        protected bool ValidateParameters()
        {
            if (_parameters == null)
            {
                Console.Write(Help());
                return false;
            }

            return true;
        }

        #endregion

        #region ICommandHandler Methods

        /// <summary>
        /// Handler for the PreRequisitesCheck command.
        /// </summary>
        /// <param name="parameters"></param>
        /// <returns></returns>
        public override int Execute(Dictionary<string, string> parameters)
        {
            _parameters = parameters;
            if(!ValidateParameters())
            {
                return -1;
            }

            X509Certificate clientCertificate = Utilities.FindApiCertificate(_parameters["ApiCertificateThumbprint"]);
            if (clientCertificate == null)
            {
                Console.WriteLine(
                    "Certificate with thumbprint {0} was not found in the LocalMachine certificate store.",
                    _parameters["ApiCertificateThumbprint"]);
                return -4;
            }

            // To validate the subscription id, storage account names and the certificate, we will
            // get the storage account key for the specified storage account.

            Console.WriteLine("Getting storage account key.");

            try
            {
                string storageAccountKey = AzureManagement.GetStorageAccountKey(
                    _parameters["SubscriptionId"],
                    _parameters["StorageAccount"],
                    clientCertificate);
                if (string.IsNullOrEmpty(storageAccountKey))
                {
                    Console.WriteLine("Failed to retrieve storage account key.");
                    return -2;
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Exception thrown when retrieving storage account key:\r\n{0}", e);

                if (e.InnerException.GetType() == typeof(WebException))
                {
                    AzureRunnerApp.DumpWebException((WebException)(e.InnerException));
                }

                return -2;
            }

            Console.WriteLine("Succeeded.");

            Console.WriteLine("Getting diagnostics storage account key.");

            try
            {
                string diagnosticsStorageAccountKey = AzureManagement.GetStorageAccountKey(
                    _parameters["SubscriptionId"],
                    _parameters["DiagnosticsStorageAccount"],
                    clientCertificate);
                if (string.IsNullOrEmpty(diagnosticsStorageAccountKey))
                {
                    Console.WriteLine("Failed to retrieve diagnostics storage account key.");
                    return -2;
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Exception thrown when retrieving diagnostics storage account key:\r\n{0}", e);

                if (e.InnerException.GetType() == typeof(WebException))
                {
                    AzureRunnerApp.DumpWebException((WebException)(e.InnerException));
                }

                return -2;
            }

            Console.WriteLine("Succeeded.");

            // To validate the service name, we will get a list of all
            // hosted services and make sure it is in the list.

            Console.WriteLine("Getting hosted service properties.");

            try
            {
                XmlDocument hostedServiceProperties = AzureManagement.GetHostedServiceProperties(
                    _parameters["SubscriptionId"],
                    _parameters["ServiceName"],
                    clientCertificate);
                if (hostedServiceProperties == null)
                {
                    Console.WriteLine("Failed to retrieve hosted service properties.");
                    return -3;
                }
            }
            catch(Exception e)
            {
                Console.WriteLine("Exception thrown when getting hosted service properties:\r\n{0}", e);

                if (e.InnerException.GetType() == typeof(WebException))
                {
                    AzureRunnerApp.DumpWebException((WebException)(e.InnerException));
                }

                return -3;
            }

            Console.WriteLine("Succeeded.");

            return 0;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\AzureRunner\app\DeployCommandHandler.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Xml;
using xonline.common.Azure;
using xonline.common.console;

namespace xonline.tools.AzureRunner
{
    enum DeployActions
    {
        DeployOnly = 1,
        DeployRun = 2,
        DeployRunWait = 3
    }

    [Command("Deploy", "Deploy an Azure package to the cloud.  Requires a package and configuration file defining the service, and a public certificate to grant access to the service account.")]
    [CommandLineParameter("SubscriptionId", "Subscription Id of the Azure account to be deployed to.", Required = true)]
    [CommandLineParameter("ApiCertificateThumbprint", "Thumbprint that uniquely identifies the certificate in the LocalMachine certificate store that will be used to authenticate to the Azure Management APIs.", Required = true)]
    [CommandLineParameter("ServiceName", "Name of the hosted service that will be hosting the deployment", Required = true)]
    [CommandLineParameter("PackagePath", "Full path to the .cspkg file to be deployed.", Required = true)]
    [CommandLineParameter("Configuration", "Full path to the .cscfg configuration file for the service being deployed.", Required = true)]
    [CommandLineParameter("InstanceCount", "Instances of the service to deploy.", Required = false, DefaultValue = "1")]
    [CommandLineParameter("DeploymentName", "Deployment name.", Required = true)]
    [CommandLineParameter("DeploymentLabel", "Deployment label.", Required = true)]
    [CommandLineParameter("Slot", "Deployment slot.  Must be either 'staging' or 'production'.", Required = false, DefaultValue = "staging")]
    [CommandLineParameter("DeployMode", "Specifies the deployment actions to be performed.  Can be one of DeployOnly|DeployRun|DeployRunWait", Required = true)]
    [CommandLineParameter("StorageAccount", "The name of the storage account that the deployment package will be stored in.", Required = true)]
    [CommandLineParameter("DiagnosticsStorageAccount", "The name of the storage account that diagnostics information will be stored in.", Required = true)]
    [CommandLineParameter("Upgrade", "If the deployment already exists, this parameter must be provided in order to perform an upgrade.", HasValue = false, Required = false)]
    [CommandLineParameter("Settings", "Setting values to customize in the .cscfg file.  The format of this parameter is: SettingName1=Value1[:SettingName2=Value2...]", Required = false)]
    [CommandLineParameter("CertificateThumbprints", "A list of Certificate Name/Thumbprint pairs to be replaced in the Certificates section of the .cscfg file.  The format of this parameter is: CertificateName1=Thumbprint1[:CertificateName2=Thumbprint2...].  All certificates specified must already exist in the .cscfg file, and will NOT be added if they don't exist.", Required = false)]
    class DeployCommandHandler : CommandHandlerBase
    {
        private Dictionary<string, string> _parameters;
        private DeployActions _deployActions;

        #region Internal Helper Methods

        /// <summary>
        /// Do as much parameter validation as we can before starting.
        /// Parse the deployment mode.
        /// </summary>
        /// <returns></returns>
        protected bool ValidateParameters()
        {
            if (_parameters == null)
            {
                Console.Write(Help());
                return false;
            }

            if (!File.Exists(_parameters["PackagePath"]))
            {
                Console.Write(string.Format("Package file {0} does not exist.\r\n\r\n", _parameters["PackagePath"]));
                Console.Write(Help());
                return false;
            }

            try
            {
                _deployActions = (DeployActions) Enum.Parse(typeof (DeployActions), _parameters["DeployMode"]);
            }
            catch(Exception)
            {
                Console.WriteLine(
                    "-DeployMode parameter must be one of the following: Deploy, DeployRun or DeployRunWait\r\n");
                Console.Write(Help());
                return false;
            }

            return true;
        }

        /// <summary>
        /// Replace the connection strings in the configuration file
        /// with new connections strings generated from passed-in
        /// information.
        /// </summary>
        /// <param name="configurationFilePath"></param>
        /// <param name="instanceCount"></param>
        /// <param name="storageAccount"></param>
        /// <param name="storageAccountKey"></param>
        /// <param name="diagnosticsStorageAccountKey"></param>
        /// <param name="settings"></param>
        /// <param name="certificateThumbprints"></param>
        /// <param name="diagnosticsStorageAccount"></param>
        protected bool CustomizeConfigurationFile(
            string configurationFilePath,
            string instanceCount,
            string storageAccount,
            string storageAccountKey,
            string diagnosticsStorageAccount,
            string diagnosticsStorageAccountKey,
            string settings,
            string certificateThumbprints)
        {
            // Try to decode the storage account key, just to make sure
            // it's valid.  If it isn't, it's the caller's responsibility
            // to handle the resultant FormatException.
            Convert.FromBase64String(storageAccountKey);
            Convert.FromBase64String(diagnosticsStorageAccountKey);
            
            // Format the connection strings.
            string storageConnectionString = string.Format("DefaultEndpointsProtocol=https;AccountName={0};AccountKey={1}",
                                                    storageAccount, storageAccountKey);
            string diagnosticsConnectionString =
                string.Format("DefaultEndpointsProtocol=https;AccountName={0};AccountKey={1}",
                              diagnosticsStorageAccount, diagnosticsStorageAccountKey);

            XmlDocument configurationDocument = new XmlDocument();
            configurationDocument.Load(configurationFilePath);
            XmlNamespaceManager nsManager = new XmlNamespaceManager(configurationDocument.NameTable);
            nsManager.AddNamespace("cs", "http://schemas.microsoft.com/ServiceHosting/2008/10/ServiceConfiguration");

            // Set the instance count.

            XmlNode instancesNode =
                configurationDocument.SelectSingleNode("/cs:ServiceConfiguration/cs:Role/cs:Instances", nsManager);

            if(instancesNode == null)
            {
                Console.WriteLine(
                    "Instances element not found in configuration file; unable to customize configuration.");
                return false;
            }

            instancesNode.Attributes["count"].Value = instanceCount;

            // Customize connection strings.

            XmlNode configurationSettingsNode =
                configurationDocument.SelectSingleNode("/cs:ServiceConfiguration/cs:Role/cs:ConfigurationSettings",
                                                       nsManager);

            if (configurationSettingsNode == null)
            {
                Console.WriteLine(
                    "ConfigurationSettings element not found in configuration file; unable to customize configuration.");
                return false;
            }

            XmlNodeList configurationSettingNodes = configurationSettingsNode.SelectNodes("cs:Setting", nsManager);
            if (configurationSettingNodes != null && configurationSettingNodes.Count != 0)
            {
                foreach (XmlNode configurationSettingNode in configurationSettingNodes)
                {
                    if (configurationSettingNode.Attributes["name"].Value == "StorageConnectionString")
                    {
                        configurationSettingNode.Attributes["value"].Value = storageConnectionString;
                    }

                    if (configurationSettingNode.Attributes["name"].Value == "DiagnosticsConnectionString")
                    {
                        configurationSettingNode.Attributes["value"].Value = diagnosticsConnectionString;
                    }
                }
            }

            // Customize other settings using the values passed in.

            if(settings != null)
            {
                if(!CustomizeSettings(configurationSettingsNode, nsManager, settings))
                {
                    return false;
                }
            }

            // Customize certificate thumbprints using the values passed in.

            if(certificateThumbprints != null)
            {
                if(!CustomizeCertificates(
                    configurationDocument,
                    nsManager,
                    certificateThumbprints))
                {
                    return false;
                }
            }

            // Save the configuration file.

            configurationDocument.Save(configurationFilePath);
            
            return true;
        }

        /// <summary>
        /// Customize settings in the configuration file.
        /// </summary>
        /// <param name="configurationSettings"></param>
        /// <param name="namespaceManager"></param>
        /// <param name="settings"></param>
        protected bool CustomizeSettings(
            XmlNode configurationSettings,
            XmlNamespaceManager namespaceManager,
            string settings)
        {
            string[] settingPairs = settings.Split(':');
            foreach(string settingPair in settingPairs)
            {
                //
                //  Don't use .Split here because the value is allowed to contain '='.
                //

                int separator = settingPair.IndexOf('=');
                if(separator == -1)
                {
                    Console.WriteLine("Found invalid setting pair: {0}", settingPair);
                    return false;
                }

                string name = settingPair.Substring(0, separator);
                string value = settingPair.Substring(separator + 1);

                XmlNode settingNode =
                    configurationSettings.SelectSingleNode(
                        string.Format(
                            "/cs:ServiceConfiguration/cs:Role/cs:ConfigurationSettings/cs:Setting[@name=\"{0}\"]",
                            name),
                        namespaceManager);

                if(settingNode == null)
                {
                    Console.WriteLine("Setting {0} not found in configuration file, skipping.", name);
                    return false;
                }

                settingNode.Attributes["value"].Value = value;
            }

            return true;
        }

        /// <summary>
        /// Customize certificate thumbprints in the Certificates section of the configuration file.
        /// </summary>
        /// <param name="configurationDocument"></param>
        /// <param name="namespaceManager"></param>
        /// <param name="certificateThumbprints"></param>
        protected bool CustomizeCertificates(
            XmlDocument configurationDocument,
            XmlNamespaceManager namespaceManager,
            string certificateThumbprints)
        {
            string[] certificatePairs = certificateThumbprints.Split(':');

            foreach (string certificatePair in certificatePairs)
            {
                string[] nameValuePair = certificatePair.Split('=');

                if(nameValuePair.Length != 2)
                {
                    Console.WriteLine("Invalid certificate/thumbprint pair: {0}", certificatePair);
                    return false;
                }

                XmlNode certificateNode =
                    configurationDocument.SelectSingleNode(
                        string.Format("/cs:ServiceConfiguration/cs:Role/cs:Certificates/cs:Certificate[@name=\"{0}\"]",
                                      nameValuePair[0]),
                        namespaceManager);

                if (certificateNode == null)
                {
                    Console.WriteLine("Certificate with name {0} was not found in the configuration file.  Skipping.", nameValuePair[0]);
                    return false;
                }

                certificateNode.Attributes["thumbprint"].Value = nameValuePair[1];
            }

            return true;
        }

        /// <summary>
        /// Upload the package to deploy to blob storage.
        /// </summary>
        protected string UploadPackageToStorage(string storageAccountKey, Stream packageStream)
        {
            AzureStorage azureStorage = new AzureStorage(_parameters["StorageAccount"], storageAccountKey);

            //  Make sure the container exists
            azureStorage.CreateContainer("mydeployments");

            //  Create the package blob name
            DateTime timeStamp = DateTime.Now;
            string packageFilename = Path.GetFileName(_parameters["PackagePath"]);

            string blobName = string.Format("{0}_{1}", timeStamp.ToString("yyyyMMdd_hhmmss"), packageFilename);

            Console.WriteLine("Copying deployment package to blob storage.");

            string packageStorageUri = azureStorage.PutBlob("mydeployments", blobName, packageStream);
            if(string.IsNullOrEmpty(packageStorageUri))
            {
                return null;
            }

            Console.WriteLine(string.Format("Complete.  Blob URI = {0}", packageStorageUri));

            return packageStorageUri;
        }

        /// <summary>
        /// Create the deployment.
        /// </summary>
        /// <param name="clientCertificate"></param>
        /// <param name="packageStorageUri"></param>
        /// <returns></returns>
        protected bool CreateDeployment(X509Certificate clientCertificate, string packageStorageUri)
        {
            Console.WriteLine("Creating deployment...");

            string requestId;
            try
            {
                requestId = AzureManagement.CreateDeployment(
                    _parameters["SubscriptionId"],
                    clientCertificate,
                    _parameters["ServiceName"],
                    _parameters["Slot"] == "staging",
                    _parameters["DeploymentName"] + DateTime.UtcNow.ToString("yyyyMMddHHmmss"),
                    _parameters["DeploymentLabel"],
                    packageStorageUri,
                    _parameters["Configuration"]
                    );

                if(string.IsNullOrEmpty(requestId))
                {
                    return false;
                }

            }
            catch(Exception e)
            {
                Console.WriteLine(string.Format("Deployment creation failed.  Exception:\r\n{0}", e));

                if (e.InnerException.GetType() == typeof(WebException))
                {
                    AzureRunnerApp.DumpWebException((WebException)(e.InnerException));
                }

                return false;
            }

            OperationStatusDetails statusDetails = AzureManagement.PollForOperationCompleteStatus(
                    _parameters["SubscriptionId"],
                    clientCertificate,
                    requestId);
            
            switch(statusDetails.Status)
            {
                case OperationStatus.Succeeded:
                    Console.WriteLine("Deployment creation succeeded.");
                    return true;
                case OperationStatus.Failed:
                    Console.WriteLine("Deployment creation failed.  Failure details:\r\n{0}", statusDetails);
                    return false;
                default:
                    Console.WriteLine(string.Format("Unexpected response: {0}", statusDetails));
                    return false;
            }
        }

        /// <summary>
        /// Upgrade the deployment using a new package.
        /// </summary>
        /// <returns></returns>
        protected bool UpgradeDeployment(X509Certificate clientCertificate, string packageStorageUri)
        {
            Console.WriteLine("Upgrading deployment.");

            string requestId;
            try
            {
                requestId = AzureManagement.UpgradeDeployment(
                    _parameters["SubscriptionId"],
                    clientCertificate,
                    _parameters["ServiceName"],
                    _parameters["Slot"] == "staging",
                    _parameters["DeploymentLabel"],
                    packageStorageUri,
                    _parameters["Configuration"]
                    );
            }
            catch (Exception e)
            {
                Console.WriteLine(string.Format("Deployment upgrade failed.  Exception:\r\n{0}", e));

                if (e.InnerException.GetType() == typeof(WebException))
                {
                    AzureRunnerApp.DumpWebException((WebException)(e.InnerException));
                }

                return false;
            }


            OperationStatusDetails statusDetails = AzureManagement.PollForOperationCompleteStatus(
                    _parameters["SubscriptionId"],
                    clientCertificate,
                    requestId);

            switch (statusDetails.Status)
            {
                case OperationStatus.Succeeded:
                    Console.WriteLine("Deployment upgrade succeeded.");
                    return true;
                case OperationStatus.Failed:
                    Console.WriteLine("Deployment upgrade failed.  Failure details:\r\n{0}", statusDetails);
                    return false;
                default:
                    Console.WriteLine(string.Format("Unexpected response: {0}", statusDetails));
                    return false;
            }
        }

        /// <summary>
        /// Tell the deployment to run.
        /// </summary>
        /// <param name="clientCertificate"></param>
        /// <returns></returns>
        protected bool RunDeployment(X509Certificate clientCertificate)
        {
            Console.WriteLine("Running deployment...");

            string requestId;
            try
            {
                requestId = AzureManagement.RunDeployment(
                    _parameters["SubscriptionId"],
                    clientCertificate,
                    _parameters["ServiceName"],
                    _parameters["Slot"] == "staging");
            }
            catch(Exception e)
            {
                Console.WriteLine(string.Format("Running the deployment failed.  Exception:\r\n{0}", e));

                if (e.InnerException.GetType() == typeof(WebException))
                {
                    AzureRunnerApp.DumpWebException((WebException)(e.InnerException));
                }

                return false;
            }

            if(string.IsNullOrEmpty(requestId))
            {
                Console.WriteLine("Running the deployment failed.");
                return false;
            }

            try
            {
                OperationStatusDetails statusDetails = AzureManagement.PollForOperationCompleteStatus(
                    _parameters["SubscriptionId"],
                    clientCertificate,
                    requestId);

                switch (statusDetails.Status)
                {
                    case OperationStatus.Succeeded:
                        Console.WriteLine("Deployment run succeeded.");
                        return true;
                    case OperationStatus.Failed:
                        Console.WriteLine("Deployment run failed.  Failure details:\r\n{0}", statusDetails);
                        return false;
                    default:
                        Console.WriteLine(string.Format("Unexpected status:\r\n{0}", statusDetails));
                        return false;
                }
            }
            catch(Exception e)
            {
                Console.WriteLine(string.Format("Polling for run completion failed.  Exception:\r\n{0}", e));

                if (e.InnerException.GetType() == typeof(WebException))
                {
                    AzureRunnerApp.DumpWebException((WebException)(e.InnerException));
                }

                return false;
            }
        }

        #endregion

        #region ICommandHandler Members

        public override int Execute(Dictionary<string,string> parameters)
        {
            try
            {
                _parameters = parameters;
                if(!ValidateParameters())
                {
                    return -1;
                }

                bool isStaging = _parameters["Slot"] == "staging";

                X509Certificate clientCertificate = Utilities.FindApiCertificate(_parameters["ApiCertificateThumbprint"]);
                if(clientCertificate == null)
                {
                    Console.WriteLine("Certificate with thumbprint {0} was not found in the LocalMachine certificate store.");
                    return -1;
                }

                // First, we need to check if the deployment already exists.
                DeploymentStatus deploymentStatus = AzureManagement.GetDeploymentStatus(
                    _parameters["SubscriptionId"],
                    clientCertificate,
                    _parameters["ServiceName"],
                    isStaging);

                bool deploymentExists = deploymentStatus != DeploymentStatus.NotExists;

                if(deploymentExists && !_parameters.ContainsKey("Upgrade"))
                {
                    Console.WriteLine("Specified deployment already exists and /Upgrade was not specified.  No operations will be performed.");
                    return 0;
                }

                FileStream packageStream = new FileStream(_parameters["PackagePath"], FileMode.Open, FileAccess.Read);

                // Get the storage account key.

                Console.WriteLine("Getting storage account key.");

                string storageAccountKey = AzureManagement.GetStorageAccountKey(
                    _parameters["SubscriptionId"],
                    _parameters["StorageAccount"],
                    clientCertificate);
                if (string.IsNullOrEmpty(storageAccountKey))
                {
                    Console.WriteLine("Failed to retrieve storage account key.");
                    return -1;
                }

                Console.WriteLine("Succeeded.");

                Console.WriteLine("Getting diagnostics storage account key.");

                string diagnosticsStorageAccountKey = AzureManagement.GetStorageAccountKey(
                    _parameters["SubscriptionId"],
                    _parameters["DiagnosticsStorageAccount"],
                    clientCertificate);
                if (string.IsNullOrEmpty(storageAccountKey))
                {
                    Console.WriteLine("Failed to retrieve diagnostics storage account key.");
                    return -1;
                }

                Console.WriteLine("Succeeded.");

                Console.WriteLine("Customizing Configuration File.");

                if(!CustomizeConfigurationFile(
                    _parameters["Configuration"],
                    _parameters["InstanceCount"],
                    _parameters["StorageAccount"],
                    storageAccountKey,
                    _parameters["DiagnosticsStorageAccount"],
                    diagnosticsStorageAccountKey,
                    _parameters.ContainsKey("Settings") ? _parameters["Settings"] : null,
                    _parameters.ContainsKey("CertificateThumbprints") ? _parameters["CertificateThumbprints"] : null))
                {
                    return -1;
                }

                Console.WriteLine("Done.");

                string packageStorageUri = UploadPackageToStorage(storageAccountKey, packageStream);
                if(string.IsNullOrEmpty(packageStorageUri))
                {
                    return -1;
                }

                if (deploymentExists)
                {
                    if (!UpgradeDeployment(clientCertificate, packageStorageUri))
                    {
                        return -1;
                    }
                }
                else
                {
                    if (!CreateDeployment(clientCertificate, packageStorageUri))
                    {
                        return -1;
                    }
                }

                // Run the service if the client requested it.
                if(_deployActions == DeployActions.DeployRun || _deployActions == DeployActions.DeployRunWait)
                {
                    if(!RunDeployment(clientCertificate))
                    {
                        return -1;
                    }
                }

                // Wait for the service to be running if the client request it.
                if (_deployActions == DeployActions.DeployRunWait)
                {
                    Console.Write("Waiting for all services to enter the ready state.");

                    try
                    {
                        while (AzureManagement.GetDeploymentStatus(
                            _parameters["SubscriptionId"],
                            clientCertificate,
                            _parameters["ServiceName"],
                            _parameters["Slot"] == "staging") != DeploymentStatus.Running)
                        {
                            Thread.Sleep(5000);
                            Console.Write(".");
                        }

                        Console.WriteLine("all services are ready.");
                    }
                    catch(Exception e)
                    {
                        Console.WriteLine(string.Format("Getting deployment status failed.  Exception:\r\n{0}", e));
                        return -1;
                    }
                }

                return 0;
            }
            catch(Exception e)
            {
                Console.WriteLine(string.Format("Unhandled exception:\r\n{0}", e));

                if(e.InnerException != null && e.InnerException.GetType() == typeof(WebException))
                {
                    AzureRunnerApp.DumpWebException((WebException)(e.InnerException));
                }

                return -1;
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\Action.cs ===
using System;
using System.IO;
using System.Xml.Serialization;
using System.Data;
using System.Data.SqlClient;
using System.Text;
using System.Collections;
using System.Collections.Specialized;
using System.Xml;
using System.Text.RegularExpressions;
using Billing.PSO;


namespace xonline.tools.batman
{
    /// <summary>
    /// Summary description for Action.
    /// </summary>
    public class CAction
    {
        public CAction()
        {

        }

        public static void ProcessReport()
        {
            Report oReport;

            //load the report into memory
            XmlSerializer serializer = new XmlSerializer(typeof(Report));

            // A FileStream is needed to read the XML document.
            FileStream fs = new FileStream(CBatman.strPathToLog, FileMode.Open);

            //Deserialize the xml into the object
            oReport = (Report) serializer.Deserialize(fs);

            fs.Close();

            //now we have the report, we should act on it
            foreach (Account account in oReport.DeleteAccount)
            {
                CReport.numDuplicateAccounts++;
                DeleteAccount(account);
            }

            foreach (Subscription subscription in oReport.DeleteSubscription)
            {
                CReport.numDuplicateSubscriptions++;
                DeleteSubscription(subscription);
            }

            foreach (PaymentInfo payinfo in oReport.DeletePaymentInfos)
            {
                CReport.numPaymentInstrumentProblems++;
                DeletePayInfo(payinfo);
            }

            foreach (UpdatePaymentInfo payinfo in oReport.UpdatePaymentInfos)
            {
                CReport.numPaymentInstrumentProblems++;
                UpdatePayInfo(payinfo);
            }

            foreach (LocaleFix fix in oReport.LocaleUpdates)
            {
                CReport.numBadLocales++;
                UpdateLocale(fix);
            }

            foreach (Subscription sub in oReport.PurchaseSubscriptions)
            {
                CReport.numIncompletePurchases++;
                PurchaseBadSubscription(sub);
            }

            foreach (Subscription sub in oReport.UpdateSubscriptions)
            {
                CReport.numIncompletePurchases++;
                UpdateSubscription(sub);
            }

            foreach (Subscription sub in oReport.ProvisionSubscriptions)
            {
                CReport.numUnprovisionedSubscriptions++;
                ProvisionSubscription(sub);
            }

            CReport.PrintReport();
        }

        public static void DeleteAccount(Account account)
        {
            try
            {
                //delete all subscriptions
                DeleteUserSubscriptions(account);

                //delete all payinfos
                //DeleteUserPayInfos(account);
                Output.WriteEntryHappy("Account: " + account.Puid.ToString() +
                    " has had all subscriptions cancelled. They are effectively gone from the system.");
            }
            catch(Exception e)
            {
                Output.WriteLineEntryError("Error cancelling account " + account.AccountID + ": " + e.Message);
            }
        }

        public static void DeleteUserPayInfos(Account account)
        {
            ArrayList rPayInfos = new ArrayList();

            CUser user = new CUser();
            user.account = account.AccountID;
            user.ownerPuid = account.Puid;
            CReport.GetPaymentInfos(user, out rPayInfos);

            foreach(string payinfoid in rPayInfos)
            {
                PaymentInfo payinfo = new PaymentInfo();
                payinfo.AccountID = user.account;
                payinfo.PaymentInfoID = payinfoid;
                payinfo.UserPuid = user.ownerPuid;
                DeletePayInfo(payinfo);
            }
        }

        public static void DeleteUserSubscriptions(Account account)
        {
            ArrayList rSubs = new ArrayList();

            CUser user = new CUser();
            user.account = account.AccountID;
            user.ownerPuid = account.Puid;
            CReport.GetSpsSubscriptions(user, out rSubs);

            foreach(SubscriptionInfoSetSubscriptionInfo sub in rSubs)
            {
                Subscription csub = new Subscription();
                csub.OwnerPuid = user.ownerPuid;
                if (sub.ServiceInstanceSet.Length == 0)
                {
                    /*
                    Output.WriteLineEntryError("Subscritpion " + sub.SubscriptionId + " on user " +
                        user.ownerPuid.ToString() + " has no service instances. Not deleting.");
                    */
                }
                else
                {
                    csub.Instance = sub.ServiceInstanceSet[0].ServiceInstanceId;
                    if (sub.SubscriptionStatusInfo.SubscriptionStatus == "ENABLED")
                        DeleteSubscription(csub);
                }
            }
        }

        public static void DeleteSubscription(Subscription sub)
        {
            PsoEncrypterClass enc = new PsoEncrypterClass();
            string subid = enc.ConvertServiceRefIDToSubID(sub.Instance);

            try
            {
                string comment = "<CommentInfo xmlns=\"urn:schemas-microsoft-com:billing-data\">";
                comment += "<CommentCode>6</CommentCode>";
                comment += "<CommentText>Duplicate Account - Cancelled by Xbox Live Billing Audit Tool</CommentText>";
                comment += "</CommentInfo>";

                int high = (int)(sub.OwnerPuid >> 32);
                int low  = (int)(sub.OwnerPuid & 0xFFFFFFFF);

                //
                //  Convert instance to subid
                //


                string guid = Guid.NewGuid().ToString();

                string error = "", charged = "", status = "", result = "";
                int count = 0;

                CBatman.Throttle();
                CBatman._sps.CancelSubscription(
                        0
                    ,   0 //delegates can be 0
                    ,   high
                    ,   low
                    ,   guid
                    ,   false
                    ,   subid
                    ,   ""
                    ,   comment
                    ,   out error
                    ,   out charged
                    ,   out status
                    ,   out count
                    ,   out result
                    );

                CReport.numBillingDeletes++;
                Output.WriteEntryHappy("Cancelled subscription: " + subid);
            }
            catch(Exception e)
            {
                Output.WriteLineEntryError("Error cancelling subscription " + subid + ": " + e.Message);
            }

        }

        public static void DeletePayInfo(PaymentInfo payinfo)
        {
            try
            {
                int high = (int)(payinfo.UserPuid >> 32);
                int low  = (int)(payinfo.UserPuid & 0xFFFFFFFF);

                string guid = Guid.NewGuid().ToString();

                string error = "";

                /*
                CBatman.Throttle();
                CBatman._sps.CloseBalance(
                        0
                    ,   0
                    ,   guid
                    ,   payinfo.PaymentInfoID
                    ,   ""
                    ,   out error
                    ,   out charged
                    );

                guid = Guid.NewGuid().ToString();

                CBatman.Throttle();
                CBatman._sps.SettleBalance(
                        0
                    ,   0
                    ,   guid
                    ,   payinfo.PaymentInfoID
                    ,   out error
                    ,   out charged
                    );

                guid = Guid.NewGuid().ToString();
                */
                CBatman.Throttle();
                CBatman._sps.RemovePaymentInstrument(
                        0
                    ,   0 //delegate
                    ,   high
                    ,   low //requester
                    ,   payinfo.PaymentInfoID
                    ,   out error
                    );

                CReport.numBillingDeletes++;
                Output.WriteEntryHappy("Deleted payment info " + payinfo.PaymentInfoID + " on user " +
                    payinfo.UserPuid.ToString());
            }
            catch(Exception e)
            {
                Output.WriteLineEntryError("Error deleting payment info " + payinfo.PaymentInfoID + ": " + e.Message);
            }
        }

        public static void UpdatePayInfo(UpdatePaymentInfo payinfo)
        {
            try
            {
                for (int i = 0; i < CBatman._servers.Length; i++)
                {
                    string server = (string)CBatman._servers[i];

                    SqlConnection cxn = new SqlConnection("server="+ server + ";trusted_connection=true;database=uodb");
                    cxn.Open();

                    SqlCommand cmd = new SqlCommand("p_batman_update_user_payinfo", cxn);
                    cmd.CommandType = CommandType.StoredProcedure;
                    SqlParameter sqlRval = cmd.Parameters.Add("@ReturnValue", 0);
                    sqlRval.Direction = ParameterDirection.ReturnValue;

                    SqlParameter sqlUser = cmd.Parameters.Add("@bi_user_puid", payinfo.UserPuid);
                    SqlParameter sqlNewPayinfo = cmd.Parameters.Add("@vc_billing_payinfo_id", payinfo.CorrectPaymentInfoID);

                    SqlDataReader reader = cmd.ExecuteReader();

                    cxn.Close();

                    if ((int)(sqlRval.Value) == 0)
                    {
                        CReport.numUODBUpdates++;
                        Output.WriteEntryHappy("Payment info for user: " + payinfo.UserPuid.ToString() +
                            " has been updated to " + payinfo.CorrectPaymentInfoID);
                        break;
                    }
                }
            }
            catch(Exception e)
            {
                Output.WriteLineEntryError("Error updating payinfo for user " +
                    payinfo.UserPuid.ToString() + ": " + e.Message);
            }

        }

        public static void PurchaseBadSubscription(Subscription sub)
        {
            PsoEncrypterClass enc = new PsoEncrypterClass();
            string subid = enc.ConvertServiceRefIDToSubID(sub.Instance);

            try
            {
                int high = (int)(sub.OwnerPuid >> 32);
                int low  = (int)(sub.OwnerPuid & 0xFFFFFFFF);

                string guid = Guid.NewGuid().ToString();

                string error = "", charged = "", result = "", newid = "", referral = "";
                int count = 0;


                CBatman.Throttle();
                CBatman._sps.PurchaseOffering(
                        1
                    ,   1
                    ,   high
                    ,   low
                    ,   guid
                    ,   false
                    ,   sub.Offerid.ToString()
                    ,   sub.Account
                    ,   subid
                    ,   sub.GUID
                    ,   0 //amount
                    ,   sub.PayInfo
                    ,   "" //sub.AddressID
                    ,   "" //sub.StartDate
                    ,   "" //sub.EndDate
                    ,   referral
                    ,   out error
                    ,   out newid
                    ,   out charged
                    ,   out count
                    ,   out result
                    );

                if (count != 1)
                    throw new Exception("Purchasing subscription for user " + sub.UserPuid + " on Guid " +
                        sub.GUID + " returned != 1 service instance sets.");

                //use some high quality benzotto code
                ServiceInstance serviceSet = new ServiceInstance();
                serviceSet.FromXml(result, "ServiceInstanceSet");

                // this Purchase output param must be set here,
                // parenthetically to the task at hand.
                string serviceInstanceId = serviceSet.ServiceInstanceId;

                int userHigh = (int)(sub.UserPuid >> 32);
                int userLow  = (int)(sub.UserPuid & 0xFFFFFFFF);

                // now set the inputs for provisioning
                serviceSet.PuidHigh = userHigh;
                serviceSet.PuidLow  = userLow;
                serviceSet.PMN      = sub.GamerTag;
                serviceSet.Role     = "User";
                serviceSet.Details  = "&lt;AlreadyProvisioned&gt;1&lt;/AlreadyProvisioned&gt;";
                serviceSet.ServiceInstanceStatus = InstanceStatusEnum.Enabled;
                serviceSet.InstanceFriendlyName = sub.GamerTag;

                // make sure we have enough information
                serviceSet.ValidateFields();

                string errorXml = "";
                try
                {
                    // now we can make an actual provisioning call.
                    CBatman.Throttle();
                    CBatman._sps.ProvisionServices(0x0, 0x0, high, low,
                        serviceSet.ToXml("ServiceInstanceSet"), out errorXml);
                }
                catch (Exception e)
                {
                    // no-op.
                    //
                    // If a larger exception is thrown here, the purchase may never be committed
                    // which would be a terrible thing since someone is paying for it.
                    // Better that we suck up the fact that SPS doesn't think something is
                    // Provisioned and have it be uncancelable via CSR than leave a paying customer
                    // without content rights, etc.
                    Output.WriteLineEntryError("Provision error! Purchase succeeded, Provision not so."
                        + " Data integrity warning; SPS is out of sync with UODB-- SPS must be notified of the "
                        + " following request. \nSERVICEINSTANCESET:\n"
                        + serviceSet.ToXml("ServiceInstanceSet") + "\nERROR OUTPUT:\n"
                        + e.Message );
                }

                /*
                 *   thanks benzotto - we don't need this anymore
                //check result
                string xmlset = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n" + result;

                //Output.WriteLine(xmlset);
                //put xmlset into rSubs
                XmlSerializer serializer = new XmlSerializer(typeof(ServiceInstanceSet));

                byte[] xmlData = new byte[xmlset.Length];
                ASCIIEncoding aEnc = new  ASCIIEncoding();
                aEnc.GetBytes(xmlset, 0, xmlset.Length, xmlData, 0);

                MemoryStream ms = new MemoryStream(xmlData);
                ServiceInstanceSet sii = (ServiceInstanceSet)serializer.Deserialize(ms);

                if (sii.ServiceInstance.Length != 1)
                    throw new Exception("Purchasing subscription for user " + sub.UserPuid + " on Guid " +
                        sub.GUID + " returned != 1 service instance sets.");

                sub.Instance = sii.ServiceInstance[0].ServiceInstanceId; //new instanceid
                //UpdateSubscription(sub);
                IProvisionSubscription(sub, result);
                */

                CReport.numBillingUpdates++;
                Output.WriteEntryHappy("Purchased subscription: " + subid);
            }
            catch(Exception e)
            {
                Output.WriteLineEntryError("Error purchasing subscription " + subid + ": " + e.Message);
            }

        }

        public static void IProvisionSubscription(Subscription sub, string strServiceInstanceSet)
        {
            try
            {
                int high = (int)(sub.UserPuid >> 32);
                int low  = (int)(sub.UserPuid & 0xFFFFFFFF);

                string guid = Guid.NewGuid().ToString();

                string error = "";

                // do same xml processing with user puid and PMN
                // get svc component etc.

                CBatman.Throttle();
                CBatman._sps.ProvisionServices(
                    0
                    ,   0
                    ,   high
                    ,   low
                    ,   strServiceInstanceSet
                    ,   out error
                    );

                CReport.numBillingUpdates++;
                Output.WriteEntryHappy("Provisioned subscription set: \n" + strServiceInstanceSet);
            }
            catch (Exception e)
            {
                Output.WriteLineEntryError("Error provisioning subscription with service instance set: \n" +
                    strServiceInstanceSet + "\n" + e.Message);
            }
        }

        public static void UpdateSubscription(Subscription sub)
        {
            try
            {
                for (int i = 0; i < CBatman._servers.Length; i++)
                {
                    string server = (string)CBatman._servers[i];

                    SqlConnection cxn = new SqlConnection("server="+ server + ";trusted_connection=true;database=uodb");
                    cxn.Open();

                    SqlCommand cmd = new SqlCommand("p_batman_update_subscription", cxn);
                    cmd.CommandType = CommandType.StoredProcedure;
                    SqlParameter sqlRval = cmd.Parameters.Add("@ReturnValue", 0);
                    sqlRval.Direction = ParameterDirection.ReturnValue;
                    SqlParameter sqlInstance = cmd.Parameters.Add("@vc_svc_instance_id", sub.Instance);
                    SqlParameter sqlUser = cmd.Parameters.Add("@bi_primary_puid", sub.UserPuid);
                    SqlParameter sqlOffer = cmd.Parameters.Add("@bi_offer_id", sub.Offerid);

                    SqlDataReader reader = cmd.ExecuteReader();

                    cxn.Close();

                    if ((int)(sqlRval.Value) == 0)
                    {
                        CReport.numUODBUpdates++;
                        Output.WriteEntryHappy("Updated subscription: " + sub.Instance + " to good flags.");
                        break;
                    }
                }
            }
            catch(Exception e)
            {
                Output.WriteLineEntryError("Error updating subscription " + sub.Instance + ": " + e.Message);
            }
        }

        public static void ProvisionSubscription(Subscription sub)
        {
            try
            {
                int high = (int)(sub.OwnerPuid >> 32);
                int low  = (int)(sub.OwnerPuid & 0xFFFFFFFF);
                int userHigh = (int)(sub.UserPuid >> 32);
                int userLow  = (int)(sub.UserPuid & 0xFFFFFFFF);

                string strServiceInstanceSet = "<ServiceInstanceSet xmlns=\"urn:schemas-microsoft-com:billing-data\">\n";
                strServiceInstanceSet += "<ServiceInstance>\n";
                strServiceInstanceSet += "<Role>User</Role>\n";
                strServiceInstanceSet += "<PUIDHigh>" + userHigh.ToString() + "</PUIDHigh>\n";
                strServiceInstanceSet += "<PUIDLow>" + userLow.ToString() + "</PUIDLow>\n";
                strServiceInstanceSet += "<PMN>" + sub.GamerTag + "</PMN>";
                strServiceInstanceSet += "<ServiceComponentId>" + sub.Component + "</ServiceComponentId>\n";
                strServiceInstanceSet += "<Details>&lt;AlreadyProvisioned&gt;1&lt;/AlreadyProvisioned&gt;</Details>";
                strServiceInstanceSet += "</ServiceInstance>\n";
                strServiceInstanceSet += "</ServiceInstanceSet>";



                string guid = Guid.NewGuid().ToString();

                string error = "";

                // do same xml processing with user puid and PMN
                // get svc component etc.

                CBatman.Throttle();
                CBatman._sps.ProvisionServices(
                        0
                    ,   0
                    ,   high
                    ,   low
                    ,   strServiceInstanceSet
                    ,   out error
                    );

                CReport.numBillingUpdates++;
                Output.WriteEntryHappy("Provisioned subscription set: \n" + strServiceInstanceSet);

                /*
                CSubscription csub = new CSubscription();
                csub.account = sub.Account;
                csub.instance = sub.Instance;
                csub.ownerPuid = sub.UserPuid;
                string siixml = CReport.GetSpsSingleSubscription(csub.ownerPuid, sub.Instance);

                Regex first = new Regex("<ServiceInstanceSet>");
                Regex last = new Regex("</ServiceInstanceSet>");

                string []parts = first.Split(siixml);
                if (parts.Length == 2)
                {
                    string []moreparts = last.Split(parts[1]);
                    if (moreparts.Length == 2)
                    {
                        string strServiceInstanceSet = "<ServiceInstanceSet xmlns=\"urn:schemas-microsoft-com:billing-data\">" +
                                                        moreparts[0] +
                                                        "</ServiceInstanceSet>";
                        IProvisionSubscription(sub, strServiceInstanceSet);
                    }
                    else
                    {
                        Output.WriteDebug("No /service instance set in service: " + siixml);
                    }

                }
                else
                {
                    Output.WriteDebug("No service instance set in service: " + siixml);
                }

                */
            }
            catch (Exception e)
            {
                Output.WriteLineEntryError("FAIL: Provision subscription " + sub.Instance + ": " + e.Message);
            }
        }

        public static void UpdateLocale(LocaleFix fix)
        {
            try
            {
                string strSendXml = "<AccountInfo xmlns=\"urn:schemas-microsoft-com:billing-data\">";
                strSendXml += "\n<Locale>" + fix.CorrectLocale + "</Locale>";
                strSendXml += "\n</AccountInfo>";

                int high = (int)(fix.UserPuid >> 32);
                int low  = (int)(fix.UserPuid & 0xFFFFFFFF);

                string error = "", paperwork = "";

                // do same xml processing with user puid and PMN
                // get svc component etc.

                CBatman.Throttle();
                CBatman._sps.UpdateAccountInfo(
                    0
                    ,   0
                    ,   high
                    ,   low
                    ,   fix.AccountID
                    ,   strSendXml
                    ,   out error
                    ,   out paperwork

                    );

                CReport.numBillingUpdates++;
                Output.WriteEntryHappy("Fixed locale: \n" + strSendXml);
            }
            catch(Exception e)
            {
                Output.WriteLineEntryError("Error updating locale for user: " + fix.UserPuid + ".\n" + e.Message);
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\AzureRunner\app\Utilities.cs ===
using System.Security.Cryptography.X509Certificates;

namespace xonline.tools.AzureRunner
{
    class Utilities
    {
        /// <summary>
        /// Find the certificate in the LocalMachine certificate store that has
        /// the specified thumbprint.
        /// </summary>
        /// <param name="thumbprint"></param>
        /// <returns></returns>
        static public X509Certificate FindApiCertificate(string thumbprint)
        {
            X509Store localMachineStore = new X509Store(StoreLocation.LocalMachine);
            localMachineStore.Open(OpenFlags.ReadOnly);

            X509CertificateCollection foundCerts = localMachineStore.Certificates.Find(X509FindType.FindByThumbprint,
                                                                                      thumbprint, false);

            return foundCerts.Count == 0 ? null : foundCerts[0];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\AzureRunner\test\AzureRunnerTest.cs ===
using System;
using System.IO;
using System.Reflection;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.diagnostics;

namespace xonline.tools.azurerunner.test
{
    [TestGroup, Owner("darrenan"), TestFrequency("Daily"), Description("Tests the base functionality of AzureRunner")]
    public class AzureRunnerTest
    {
        private static ProcessWrapper _azureRunnerWrapper;

        [TestGroupSetup]
        public void Setup()
        {
            string suitesDirectory = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);

            // Get the root of the build
            if (suitesDirectory.IndexOf("\\test\\") == -1)
            {
                // This should never happen since we looked up the directory from the 
                // location of the currently running assembly!!?!
                throw new NullReferenceException(string.Format("The Suites directory {0} is not within a valid build directory structure.  No 'test' parent directory exists.", suitesDirectory));
            }

            string buildRoot = suitesDirectory.Substring(0, suitesDirectory.IndexOf("\\test\\"));

            // AzureRunner.exe is binplaced to the deployment tools directory.
            string azureRunnerPath = Path.Combine(buildRoot, "msi\\esp\\tools\\" + AzureRunnerTestSuite.AzureRunnerExe);
            if (!File.Exists(azureRunnerPath))
            {
                throw new FileNotFoundException(string.Format("AzureRunner.exe was not found at {0}.", azureRunnerPath));
            }
            _azureRunnerWrapper = new ProcessWrapper(AzureRunnerTestSuite.AzureRunnerExe, azureRunnerPath);
        }

        [TestCase, Owner("darrenan"), TestCasePriority(0), Description("Positive test case.  No parameters supplied.  Should output all valid commands and help text.")]
        public class P_NoParameters : TestNode
        {
            public override void Run()
            {
                if(_azureRunnerWrapper.Run("") != 0)
                {
                    return TEST_RESULTS.FAILED;
                }

                // Verify that the output is roughly in the correct format.  We don't
                // want to do an exact comparison because the exact command list will
                // be changing over time.
                string[] lines = _azureRunnerWrapper.Output.Split(new [] {'\r', '\n'},
                                                                  StringSplitOptions.RemoveEmptyEntries);

                // First line
                Assert.AreEqual("Commands:", lines[0]);

                // Skip specific commands
                for (int currentLine = 1; lines[currentLine].StartsWith("\t"); ++currentLine ){}

                // Last line
                Assert.AreEqual("For details on a specific command use \"AzureRunnerTest Help <command>\".  Commands are case sensitive.", lines[lines.Length - 1]);

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Owner("darrenan"), TestCasePriority(0), Description("Positive test case.  'Help' parameter supplied.  Should output all valid commands and help text.")]
        public class P_HelpParameter : TestNode
        {
            public override void Run()
            {
                if (_azureRunnerWrapper.Run("Help") != 0)
                {
                    return TEST_RESULTS.FAILED;
                }

                // Verify that the output is roughly in the correct format.  We don't
                // want to do an exact comparison because the exact command list will
                // be changing over time.
                string[] lines = _azureRunnerWrapper.Output.Split(new[] { '\r', '\n' },
                                                                  StringSplitOptions.RemoveEmptyEntries);

                // First line
                Assert.AreEqual("Commands:", lines[0]);

                // Skip specific commands
                for (int currentLine = 1; lines[currentLine].StartsWith("\t"); ++currentLine) { }

                // Last line
                Assert.AreEqual("For details on a specific command use \"AzureRunnerTest Help <command>\".  Commands are case sensitive.", lines[lines.Length - 1]);

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Owner("darrenan"), TestCasePriority(0), Description("Positive test case.  'Help' parameter supplied.  Should output all valid commands and help text.")]
        public class P_UnknownCommand : TestNode
        {
            public override void Run()
            {
                if (_azureRunnerWrapper.Run("BogusCommand") != 0)
                {
                    return TEST_RESULTS.FAILED;
                }

                // Verify that the output is roughly in the correct format.  We don't
                // want to do an exact comparison because the exact command list will
                // be changing over time.
                string[] lines = _azureRunnerWrapper.Output.Split(new[] { '\r', '\n' },
                                                                  StringSplitOptions.RemoveEmptyEntries);

                // First line
                Assert.AreEqual("Unknown command: BogusCommand", lines[0]);
                Assert.AreEqual("Commands:", lines[1]);

                // Skip specific commands
                for (int currentLine = 1; lines[currentLine].StartsWith("\t"); ++currentLine) { }

                // Last line
                Assert.AreEqual("For details on a specific command use \"AzureRunnerTest Help <command>\".  Commands are case sensitive.", lines[lines.Length - 1]);

                return TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\AzureRunner\test\AzureRunnerTestSuite.cs ===
using ServerTestFramework;

[assembly: RootNode(typeof(xonline.tools.azurerunner.test.AzureRunnerTestSuite))]

namespace xonline.tools.azurerunner.test
{
    public class AzureRunnerTestSuite : TestNode
    {
        public const string AzureRunnerExe = "azurerunner.exe";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\Batman.cs ===
using System;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Collections;
using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Globalization;
using xonline.common.service;                                     
using xonline.common.tools.console;

namespace xonline.tools.batman 
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class CBatman
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
        ///
        public static EventLog _eventlog   = null;

        //logging
        public static string strPathToLog = "";

        [STAThread]
        static int Main(string[] rawArgs)
        {
            NamedArgParser args;
            DateTime dtStartDate = DateTime.Now;
            DateTime dtEndDate = DateTime.Now;

            try
            {
                _eventlog = new EventLog();
                _eventlog.Source = "BillingAudit";
            
                //
                //  Validate all command line arguments
                //

                string [] tags = {
                                     "report",
                                     "path",
                                     "startdate",
                                     "enddate",
                                     "throttle",
                                     "output",
                                     "?"
                                 };

                args = new NamedArgParser(tags);

                if (!args.Parse(rawArgs))
                {
                    Help();
                    return 1;
                }

                if (args["?"] != null)
                {
                    Help();
                    return 1;
                }


                if (args["path"] == null)
                {
                    Output.WriteLine("You need to specify a /path");
                    Help();
                    return 1;
                }

                if (args["startdate"] == null || args["enddate"] == null)
                {
                    Output.WriteLine("You need to specify a /startdate and /enddate.");
                    Help();
                    return 1;
                }

                if (args["output"] != null)
                {
                    if (args["output"].ToUpper() == "DEBUG")
                        Output.Level = Output.DEBUG;
                    if (args["output"].ToUpper() == "NORMAL")
                        Output.Level = Output.NORMAL;
                    if (args["output"].ToUpper() == "VERBOSE")
                        Output.Level = Output.VERBOSE;
                    if (args["output"].ToUpper() == "SILENT")
                        Output.Level = Output.SILENT;
                }

                //
                //  The stored procedure that these two date values are passed into excludes the parameters
                //  from the range of users returned, it uses less-than and greater-than when selecting.
                //  To get around this problem we're fudging the parameters here so that it functions 
                //  correctly from the end-user's point of view.
                //  Bug 31824.
                //
                dtStartDate = Convert.ToDateTime(args["startdate"]).AddDays(-1);
                dtEndDate = Convert.ToDateTime(args["enddate"]).AddDays(1);

                //
                // Get throttling value, if any.
                //
                strPathToLog = args["path"];
                if (args["throttle"] != null)
                {
                    if (args["throttle"].IndexOf('S') > 0)
                    {
                        args["throttle"] = args["throttle"].Substring(0,
                            args["throttle"].IndexOf('S'));
                        BillingProvider.BillingCallDelay = 1000 / Int32.Parse(args["throttle"]);
                    }
                    else if (args["throttle"].IndexOf('M') > 0)
                    {
                        args["throttle"] = args["throttle"].Substring(0,
                            args["throttle"].IndexOf('M'));
                        BillingProvider.BillingCallDelay = Convert.ToInt32(1000.0 / 
                            (double)(Double.Parse(args["throttle"]) / 60.0));
                    }
                    else
                        BillingProvider.BillingCallDelay = 0;

                    Output.WriteLine("Number of milliseconds between billing calls = " + BillingProvider.BillingCallDelay.ToString());
                }
            }
            catch(Exception e)
            {
                Output.WriteLine("Problem initializing data: " + e.ToString());
                return 2;
            }

            string outStr;

            // run the simplest test
            try 
            {                
                CReport.TestConnection( "Testing 1, 2, 3..!", out outStr );
            } 
            catch (Exception e) 
            {
                Output.WriteLine( "Error: " + e );
                return 1;
            }

            //
            //  Now generate and display the report.
            //

            CReport.GenerateReport(dtStartDate, dtEndDate);
            
            //
            //  Cleanup
            //

            if (Output.log != null)
                Output.log.Close();

            return 0;
        }

        /// <summary>
        /// Utility function to return the directory that this tool is running from.
        /// </summary>
        /// <returns></returns>
        public static string GetProcessDir()
        {
            return Path.GetDirectoryName(System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName);
        }

        /// <summary>
        /// Command line help.
        /// </summary>
        private static void Help()
        {
            Output.WriteLine("Usage: BillingAudit /path:<path> /startdate:<date> /enddate:<date>");
            Output.WriteLine("Date format: MM-DD-YYYY, eg. 05-17-1980");
            Output.WriteLine("Optional commands: /throttle:<##S | ##M> " +
                "/output:<debug, normal, silent, verbose");
        }        
	}


    /// <summary>
    /// Helper class for doing command line output.
    /// </summary>
    public class Output
    {
        public static int Level = NORMAL;
                                        
        public const int SILENT  = 0;
        public const int NORMAL  = 1;
        public const int VERBOSE = 2;
        public const int DEBUG   = 3;

        public static StreamWriter log = null;

        public static void WriteOut(string s)
        {
            if (log == null)
            {
                
                log = new StreamWriter(Path.Combine(CBatman.GetProcessDir(), "Batman.log"));
                log.WriteLine(Environment.CommandLine);
            }

            string [] lines = s.Split('\n');
            foreach (string line in lines)
                log.WriteLine(line);

            log.Flush();

        }
        public static void WriteLine(string s)
        {
            if(Level >= NORMAL)
            {
                Console.WriteLine(s);
            }
            WriteOut(s);
        }
        
        public static void WriteVerbose(string s)
        {
            if(Level >= VERBOSE)
            {
                Console.WriteLine(s);
            }
            WriteOut(s);
        }
        
        public static void WriteDebug(string s)
        {
            if(Level >= DEBUG)
            {
                Console.WriteLine(s);
            }
            WriteOut(s);
        }

        public static void WriteEntryError(string s)
        {
            if (CBatman._eventlog != null)
            {
                int id;
                unchecked
                {
                    id = (int)XEvent.Id.BATMAN_REQUIRED_FIX & 65535;
                }
                CBatman._eventlog.WriteEntry(s, EventLogEntryType.Error, id);
            }
        }
        
        public static void WriteEntryHappy(string s)
        {
            WriteVerbose(s);
            if (CBatman._eventlog != null)
            {
                int id;
                unchecked
                {
                    id = (int)XEvent.Id.BATMAN_REQUIRED_FIX_1 & 65535;
                }
                CBatman._eventlog.WriteEntry(s, EventLogEntryType.Information, id);
            }
        }                

        public static void WriteLineEntryError(string s)
        {
            WriteLine(s);
            WriteEntryError(s);
        }

        public static void WriteDebugEntryError(string s)
        {
            WriteDebug(s);
            WriteEntryError(s);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\billingprovider.cs ===
//
// BillingProvider.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// SPS 2.5 Wrapper Class
// Xbox Online Service
//
// Author: Ben Zotto (benzotto)
//

using System;
using System.IO;
using System.Web;
using System.Data.SqlClient;
using System.Data;
using System.Net;
using System.Text;
using System.Threading;
using System.Xml;
using System.Globalization;
using System.Diagnostics;
using System.Web.Services.Protocols;
using System.Security.Permissions;
using System.Security.Principal;
using xonline.common.config;
using xonline.common.crypto;
using xonline.common.service;
using Microsoft.Webstore.WstClient;


namespace xonline.tools.batman
{

    /// <summary>
    /// Billing Provider class.  Provides static configuration of server and user,
    /// and also throttling.
    /// </summary>
    public class BillingProvider : bdk
    {
        //
        // Private data members.
        //

        private static string _username;
        private static string _password;
        private static string _wsdlLocation;
        private static DateTime _dtLastCall = DateTime.MinValue;
        private static bool _initialized = false;
        private static int _numBillingCalls = 0;
        private static int _numMSBetweenBillingCalls = 0;

        //
        //  Properties
        //

        public static string Username
        {
            get
            {
                if (!_initialized) Init();
                return _username;
            }

            set { _username = value; }
        }

        public static string Password
        {
            get
            {
                if (!_initialized) Init();
                return _password;
            }
            set { _password = value; }
        }

        public static string WsdlLocation
        {
            get
            {
                if (!_initialized) Init();
                return _wsdlLocation;
            }
            set { _wsdlLocation = value; }
        }

        public static int NumBillingCalls
        {
            get { return _numBillingCalls; }
        }

        public static int BillingCallDelay
        {
            get { return _numMSBetweenBillingCalls; }
            set { _numMSBetweenBillingCalls = value; }
        }

        /// <summary>
        /// Initialization function.
        /// </summary>
        public static void Init()
        {
            GetPartnerInfo();

            Output.WriteDebug("BillingProvider: Username=" + _username);
            Output.WriteDebug("BillingProvider: WSDL=" + _wsdlLocation);

            _initialized = true;
        }

        /// <summary>
        /// Throttling settings are shared across all instances of the class.
        /// Number of calls to billing service is also tracked globally.
        /// </summary>
        public static void Throttle()
        {
            _numBillingCalls++;
            if (_numMSBetweenBillingCalls == 0)
                return; //no throttling

            if (_dtLastCall == DateTime.MinValue)
                _dtLastCall = DateTime.Now;
            else
            {
                //they have previously called this, wait until #seconds
                TimeSpan diff = DateTime.Now - _dtLastCall;
                while (diff.TotalMilliseconds < _numMSBetweenBillingCalls)
                {
                    Thread.Sleep(10);  //yeild the proc while we wait
                    diff = DateTime.Now - _dtLastCall;
                }
            }

            _dtLastCall = DateTime.Now;
        }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="server"></param>
        public BillingProvider() : base()
        {
            // set up the bdk that we inherit from
            this.Url     = WsdlLocation;

            this.Credentials = new NetworkCredential(Username, Password);
            this.Timeout     = 20000;
        }



        /// <summary>
        /// Gets the partner key info from UODB.
        /// </summary>
        private static void GetPartnerInfo()
        {
            WstConnection conn = null;
            WstCommand cmd = null;
            WstDataReader reader = null;

            int masterkeyver;
            byte[] encPassword = null;

            try
            {
                Output.WriteDebug("Opening connection to uodb");
                conn = new WstConnection(ConfigUtil.UodbWebstoreApp);
                conn.Open();

                Output.WriteDebug("Getting service keys...");
                cmd = conn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_xbos_get_raw_sps_info";
                cmd.WstCommandType = WstCommandType.ReadThenWrite;
                cmd.PartitionType = WstPartitionType.Logical;
                cmd.Partition = WstCommand.AnyPartition;

                SqlParameter sqlUsername = cmd.Parameters.Add("@username", SqlDbType.NVarChar, 200);
                SqlParameter sqlPassword = cmd.Parameters.Add("@password", SqlDbType.VarBinary, 256);
                SqlParameter sqlWsdlLocation = cmd.Parameters.Add("@wsdllocation", SqlDbType.NVarChar, 200);
                SqlParameter sqlKeyVer = cmd.Parameters.Add("@i_masterkeyversion", SqlDbType.Int);
                sqlUsername.Direction = ParameterDirection.Output;
                sqlPassword.Direction = ParameterDirection.Output;
                sqlWsdlLocation.Direction = ParameterDirection.Output;
                sqlKeyVer.Direction = ParameterDirection.Output;

                reader = cmd.ExecuteReader();

                Username = (string)sqlUsername.Value;
                encPassword = (byte[])sqlPassword.Value;
                WsdlLocation = (string)sqlWsdlLocation.Value;
                masterkeyver = (int)sqlKeyVer.Value;

                Output.WriteDebug("Username = " + (string)sqlUsername.Value + ", WSDL = " + (string)sqlWsdlLocation.Value + ", Master Key Version = " + (int)sqlKeyVer.Value);

                // check the master key version
                if ( masterkeyver == 0 )
                {
                    UnicodeEncoding UE = new UnicodeEncoding();
                    Password = UE.GetString(encPassword);
                }
                else
                {
                    ASCIIEncoding AE = new ASCIIEncoding();
                    Password = AE.GetString(KEKCryptoMgr.DecryptWithMasterKeyWrp( (uint)masterkeyver, (uint)encPassword.Length, encPassword ));
                }
            }
            finally
            {
                if(reader != null)
                {
                    reader.Close();
                    reader = null;
                }

                if(conn != null)
                {
                    conn.Close();
                    conn = null;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\ConsoleEx.cs ===
// ConsoleEx V1.02 - Tim Sneath <tims@microsoft.com>

// ReadHiddenLine: Ben Zotto (benzotto@xbox.com)

using System;
using System.Runtime.InteropServices;
using System.Text;

namespace xonline.tools.batman 
{
	/// <summary>
	/// This class provides supplemental functionality to that available in the System.Console class. It 
	/// allows a developer to control the cursor location, size and visibility, to manipulate the color
	/// used for writing text on the screen, to read characters individually from the input buffer, to 
	/// manipulate the console window title, to clear the screen and to draw rectangles on the screen. It 
	/// does not replace traditional functions supplied in the System.Console class such as WriteLine() 
	/// and ReadLine(), but is intended to be use in conjunction with calls to that class.
	/// </summary>
	/// <remarks>
	/// This class is largely built using information from the Platform SDK. Documentation on the 
	/// Console APIs within kernel32 can be found at the following location:
	///       http://msdn.microsoft.com/library/en-us/dllproc/base/character_mode_applications.asp
	///
	/// Several of the functions within this class are reworked and expanded versions of those
	/// found in KnowledgeBase articles Q319883 and Q319257.
	/// </remarks>
	public class ConsoleEx
	{	

		#region API and Structure Declarations

		// Standard structures used for interop with kernel32
		[StructLayout(LayoutKind.Sequential)]
			struct COORD
		{
			public short x;
			public short y;
		}

		[StructLayout(LayoutKind.Sequential)]
			struct SMALL_RECT
		{
			public short Left;
			public short Top;
			public short Right;
			public short Bottom;
		}
		
		[StructLayout(LayoutKind.Sequential)]
			struct CONSOLE_SCREEN_BUFFER_INFO
		{
			public COORD dwSize;
			public COORD dwCursorPosition;
			public int wAttributes;
			public SMALL_RECT srWindow;
			public COORD dwMaximumWindowSize;
		}

		[StructLayout(LayoutKind.Sequential)]
			struct CONSOLE_CURSOR_INFO 
		{
			public int dwSize;  
			public bool bVisible;
		} 


		// External function declarations
		[DllImport("kernel32.dll", EntryPoint="GetStdHandle", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int GetStdHandle(int nStdHandle);

		[DllImport("kernel32.dll", EntryPoint="GetConsoleScreenBufferInfo", SetLastError=true, 
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int GetConsoleScreenBufferInfo(int hConsoleOutput,
			ref CONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleTextAttribute", SetLastError=true, 
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int SetConsoleTextAttribute(int hConsoleOutput,
			int wAttributes);

		[DllImport("kernel32.dll", EntryPoint="FillConsoleOutputCharacter", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int FillConsoleOutputCharacter(int hConsoleOutput, 
			byte cCharacter, int nLength, COORD dwWriteCoord, ref int lpNumberOfCharsWritten);

		[DllImport("kernel32.dll", EntryPoint="FillConsoleOutputAttribute", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int FillConsoleOutputAttribute(int hConsoleOutput,
			int wAttribute, int nLength, COORD dwWriteCoord, ref int lpNumberOfAttrsWritten);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleCursorPosition", SetLastError=true, 
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int SetConsoleCursorPosition(int hConsoleOutput, 
			COORD dwCursorPosition);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleTitle", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern bool SetConsoleTitle(string lpConsoleTitle);

		[DllImport("kernel32.dll", EntryPoint="GetConsoleTitle", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int GetConsoleTitle(StringBuilder lpConsoleTitle, 
			int nSize);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleCursorInfo", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int SetConsoleCursorInfo(int hConsoleOutput, 
			ref CONSOLE_CURSOR_INFO lpConsoleCursorInfo);

		[DllImport("kernel32.dll", EntryPoint="GetConsoleCursorInfo", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int GetConsoleCursorInfo(int hConsoleOutput, 
			ref CONSOLE_CURSOR_INFO lpConsoleCursorInfo);
		
		[DllImport("kernel32.dll", EntryPoint="ReadConsole", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern bool ReadConsole(int hConsoleInput,
			StringBuilder buf, int nNumberOfCharsToRead, ref int lpNumberOfCharsRead, int lpReserved);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleMode", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern bool SetConsoleMode(int hConsoleHandle,
			int dwMode);

		[DllImport("kernel32.dll", EntryPoint="GetConsoleMode", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern bool GetConsoleMode(int hConsoleHandle,
			ref int dwMode);

		#endregion


		// Const variables
		private const int  INVALID_HANDLE_VALUE    = -1;
		private const int  STD_INPUT_HANDLE        = -10;
		private const int  STD_OUTPUT_HANDLE       = -11;
		private const byte EMPTY                   = 32;
		private const int  TITLE_LENGTH            = 1024;

		// Internal variables
		private static int hConsoleOutput;	// handle to output buffer
		private static int hConsoleInput;	// handle to input buffer
		private static COORD ConsoleOutputLocation;
		private static CONSOLE_SCREEN_BUFFER_INFO ConsoleInfo;
		private static int OriginalConsolePen;
		private static int CurrentConsolePen;

		
		// Constructors
		static ConsoleEx()
		{
			// Grab input and output buffer handles
			hConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE);
			hConsoleInput = GetStdHandle(STD_INPUT_HANDLE);
			if (hConsoleOutput == INVALID_HANDLE_VALUE || hConsoleInput == INVALID_HANDLE_VALUE)
				throw new ApplicationException("Unable to obtain buffer handle during initialization.");

			// Get information about the console window characteristics.
			ConsoleInfo = new CONSOLE_SCREEN_BUFFER_INFO();
			ConsoleOutputLocation = new COORD();
			GetConsoleScreenBufferInfo(hConsoleOutput, ref ConsoleInfo);
			OriginalConsolePen = ConsoleInfo.wAttributes;

			// Disable wrapping at the end of a line (ENABLE_WRAP_AT_EOL_INPUT); this enables rectangles 
			// to be drawn that fill the screen without the window scrolling.
			SetConsoleMode(hConsoleOutput, 
				(int) OutputModeFlags.ENABLE_PROCESSED_OUTPUT);
		}

		private ConsoleEx() : base()
		{
			throw new NotSupportedException("This object may not be instantiated. Use static methods instead.");
		}


		/// <summary>
		/// Sets or gets the console window title.
		/// </summary>
		public static string Title 
		{
			get
			{
				StringBuilder title = new StringBuilder(TITLE_LENGTH);
				int ret = GetConsoleTitle(title, TITLE_LENGTH);
				return title.ToString(0, ret);
			}
			set 
			{	
				if (value.Length < TITLE_LENGTH)
					SetConsoleTitle(value);
				else
					throw new ArgumentOutOfRangeException(
						"Title", 
						value, 
						"Console window title must be no more than " + TITLE_LENGTH +  " characters.");
			}
		}


		/// <summary>
		/// Gets or sets the visibility of the cursor.
		/// </summary>
		public static bool CursorVisible
		{
			get
			{
				CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
				GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
				return ConsoleCursorInfo.bVisible;
			}
			set
			{
				// Obtain current cursor information, since the CONSOLE_CURSOR_INFO struct
				// also contains information on the shape of the cursor.
				CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
				GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);

				ConsoleCursorInfo.bVisible = value;
				SetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
			}
		}


		/// <summary>
		/// Gets or sets the height of the cursor, as a percentage of the overall character cell.
		/// The value must be a number between 1 and 100, otherwise an ArgumentOutOfRangeException
		/// will be thrown.
		/// </summary>
		public static int CursorHeight
		{
			get
			{
				CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
				GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
				return ConsoleCursorInfo.dwSize;
			}
			set
			{
				if (value >= 1 && value <= 100)
				{
					// Obtain current cursor information, since the CONSOLE_CURSOR_INFO struct
					// also contains information on the visibility of the cursor.
					CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
					GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);

					ConsoleCursorInfo.dwSize = value;
					SetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
				}
				else
					throw new ArgumentOutOfRangeException(
						"CursorHeight", 
						value, 
						"Cursor height must be a percentage of the character cell between 1 and 100.");
			}
		}


		/// <summary>
		/// Sets the console pen color to that specified.
		/// </summary>
		/// <param name="foreground">A foreground color specified from the 
		/// ConsoleForeground enumeration</param>
		/// <param name="background">A background color specified from the 
		/// ConsoleBackground enumeration</param>
		public static void TextColor(ConsoleForeground foreground, ConsoleBackground background)
		{
			CurrentConsolePen = (int)foreground + (int)background;
			SetConsoleTextAttribute(hConsoleOutput, CurrentConsolePen);
		}
	

		/// <summary>
		/// Resets the console pen color to the original default at the time 
		/// the class was originally initialised.
		/// </summary>
		public static void ResetColor()
		{
			SetConsoleTextAttribute(hConsoleOutput, OriginalConsolePen);
		}
	

		/// <summary>
		/// Clears screen.
		/// </summary>
		public static void Clear()
		{
			int hWrittenChars = 0;
			CONSOLE_SCREEN_BUFFER_INFO strConsoleInfo = new CONSOLE_SCREEN_BUFFER_INFO();			
			COORD Home;		
			Home.x = Home.y = 0;
			
			if (GetConsoleScreenBufferInfo(hConsoleOutput, ref strConsoleInfo) == 0)
			{
				// If the device does not support GetConsoleScreenBufferInfo, then try just
				// writing ^L (ASCII control code for Form Feed) to the screen. This may 
				// work for some scenarios such as using telnet to access a remote console.
				Console.Write('\x0c');	// ^L
				return;
			}
			
			FillConsoleOutputCharacter(hConsoleOutput, EMPTY, 
				strConsoleInfo.dwSize.x * strConsoleInfo.dwSize.y, Home, ref hWrittenChars);
			FillConsoleOutputAttribute(hConsoleOutput, CurrentConsolePen, 
				strConsoleInfo.dwSize.x * strConsoleInfo.dwSize.y, Home, ref hWrittenChars);
			
			SetConsoleCursorPosition(hConsoleOutput, Home);
		}


		/// <summary>
		/// Moves the console cursor to the specified location on the screen.
		/// </summary>
		/// <param name="x">X co-ordinate for desired location (typically 0 to 79)</param>
		/// <param name="y">Y co-ordinate for desired location (typically 0 to 24)</param>
		public static void Move(int x, int y)
		{
			// Check that parameters specified are sane
			CONSOLE_SCREEN_BUFFER_INFO strConsoleInfo = new CONSOLE_SCREEN_BUFFER_INFO();
			GetConsoleScreenBufferInfo(hConsoleOutput, ref strConsoleInfo);

			if (x >= strConsoleInfo.dwSize.x ||  x < 0)
				throw new ArgumentOutOfRangeException("x", x, 
					"The co-ordinates specified must be within the dimensions of the window.");

			if (y >= strConsoleInfo.dwSize.y || y < 0)
				throw new ArgumentOutOfRangeException("y", y, 
					"The co-ordinates specified must be within the dimensions of the window.");

			COORD Location;
			Location.x = (short)x;
			Location.y = (short)y;

			SetConsoleCursorPosition(hConsoleOutput, Location);
		}


		/// <summary>
		/// Writes the specified text at the given location.
		/// </summary>
		/// <remarks>
		/// This is a wrapper function that provides a shorthand for moving to a location and 
		/// writing there. The cursor will be left in the position immediately succeeding the 
		/// rightmost character of the text written to the screen.
		/// </remarks>
		/// <param name="x">X co-ordinate for leftmost character of text</param>
		/// <param name="y">Y co-ordinate for location of text</param>
		/// <param name="text">String to be written to the screen</param>
		public static void WriteAt(int x, int y, string text)
		{
			// No need to validate x and y co-ordinates as they will be tested by Move()
			Move(x, y);

			Console.Write(text);
		}


		/// <summary>
		/// Draws a rectangle on the console window using either 7-bit ASCII characters or
		/// line drawing characters, depending on the style specified. If the dimensions of 
		/// the rectangle exceed the boundaries of the screen, an ArgumentOutOfRangeException
		/// will be thrown.
		/// </summary>
		/// <remarks>
		/// Note that the sides of the rectangle themselves are one character wide,
		/// so, for example, a width and height of 2 will result in a 3-by-3 character rectangle.
		/// This matches the behavior of the equivalent Windows Forms DrawRectangle() method.
		/// </remarks>
		/// <param name="style">A border style specified from the BorderStyle enumeration</param>
		/// <param name="x">X co-ordinate of upper left corner of rectangle</param>
		/// <param name="y">Y co-ordinate of upper left corner of rectangle</param>
		/// <param name="cx">Width of the rectangle</param>
		/// <param name="cy">Height of the rectangle</param>
		public static void DrawRectangle(BorderStyle style, int x, int y, int cx, int cy, bool fill)
		{
			if (style != BorderStyle.None)
			{
				// Set rectangle frame appropriately for the style chosen. Unicode 
				// characters represent horizontal and vertical lines, then NW, NE,
				// SW and SE corners of the rectangle in that order.
				string frame;
				switch(style)
				{
					case BorderStyle.LineSingle:
						frame = "\u2500\u2502\u250c\u2510\u2514\u2518";
						break;
					case BorderStyle.LineDouble:
						frame = "\u2550\u2551\u2554\u2557\u255A\u255D";
						break;
					default:
						frame = @"-|/\\/";
						break;
				}

				// Create top line of box
				StringBuilder line = new StringBuilder(cx+1);
				line.Append(frame[2]);
				for (int i=1; i < cx; i++) line.Append(frame[0]);
				line.Append(frame[3]);
				Move(x, y);
				Console.Write(line);

				// Create sides of box
				for (int i=1; i < cy; i++)
				{
					Move(x, y+i);
					Console.Write(frame[1]);
					Move(x+cx, y+i);
					Console.Write(frame[1]);
				}

				// Create bottom line of box
				line[0] = frame[4];
				line[cx] = frame[5];
				Move(x, y+cy);
				Console.Write(line);
			}
		
			// Fill rectangle with current console pen
			if (fill)
			{
				int hWrittenChars = 0;
				COORD c = new COORD();
				c.x = (short)x;
			
				for (int i=0; i<=cy; i++)
				{
					c.y = (short)(y + i);
					FillConsoleOutputAttribute(hConsoleOutput, CurrentConsolePen, 
						cx + 1, c, ref hWrittenChars);
				}
			}
		}

		
		/// <summary>
		/// Read a single character from the input buffer. Unlike Console.Read(), which 
		/// only reads from the buffer when the read operation has terminated (e.g. by
		/// pressing Enter), this method reads as soon as the character has been entered.
		/// </summary>
		/// <returns>The character read by the system</returns>
		public static char ReadChar()
		{
			// Temporarily disable character echo (ENABLE_ECHO_INPUT) and line input
			// (ENABLE_LINE_INPUT) during this operation
			SetConsoleMode(hConsoleInput, 
				(int) (InputModeFlags.ENABLE_PROCESSED_INPUT | 
				InputModeFlags.ENABLE_WINDOW_INPUT | 
				InputModeFlags.ENABLE_MOUSE_INPUT));

			int lpNumberOfCharsRead = 0;
			StringBuilder buf = new StringBuilder(1);

			bool success = ReadConsole(hConsoleInput, buf, 1, ref lpNumberOfCharsRead, 0);
			
			// Reenable character echo and line input
			SetConsoleMode(hConsoleInput, 
				(int) (InputModeFlags.ENABLE_PROCESSED_INPUT | 
				InputModeFlags.ENABLE_ECHO_INPUT |
				InputModeFlags.ENABLE_LINE_INPUT |
				InputModeFlags.ENABLE_WINDOW_INPUT | 
				InputModeFlags.ENABLE_MOUSE_INPUT));
			
			if (success)
				return Convert.ToChar(buf[0]);
			else 
				throw new ApplicationException("Attempt to call ReadConsole API failed.");
		}
        
        ///
        /// BenZotto wrote this for BillingXCheck
        ///
        public static string ReadHiddenLine()
        {
            StringBuilder sb = new StringBuilder();
            char c;
            
            while((c = ReadChar()) != '\r' && c != '\n')
            {
                sb.Append(c);
            }
            
            return sb.ToString();
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\AzureRunner\test\DeployTests.cs ===
using System;
using System.IO;
using System.Reflection;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace xonline.tools.azurerunner.test
{
    [TestGroup, Owner("darrenan"), TestFrequency("Daily"), Description("Tests the functionality of the Deploy command of AzureRunner.")]
    class DeployTests
    {
        private static string _testStorageAccount;
        private static string _testSubscriptionId;

        private static ProcessWrapper _azureRunnerWrapper;
        private static string _testPackagePath;
        private static string _testCertificatePath;
        private static string _testConfigurationPath;

        [TestGroupSetup]
        public void Setup()
        {
            //===============================
            // Read settings from stf.xml
            //===============================

            XmlNodeList azureRunnerTestNodeList = Global.Config.GetElementsByTagName("azureRunnerTest");
            if (azureRunnerTestNodeList.Count == 0)
            {
                throw new TestSuiteException(
                    "This test suite requires the presence of an <azureRunnerTest /> element in stf.xml.");
            }

            if(azureRunnerTestNodeList.Count > 1)
            {
                Global.RO.Info("Found more than one <azureRunnerTest> element in stf.xml, ignoring all but the first one.");    
            }

            XmlNode azureRunnerTestNode = azureRunnerTestNodeList[0];

            _testStorageAccount = azureRunnerTestNode.Attributes["storageAccount"].Value;
            _testSubscriptionId = azureRunnerTestNode.Attributes["subscriptionId"].Value;

            //===========================================================
            // Make sure we have all the files we need to run the tests.
            //===========================================================

            string suitesDirectory = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);

            // Get the root of the build
            if (suitesDirectory.IndexOf("\\test\\") == -1)
            {
                // This should never happen since we looked up the directory from the 
                // location of the currently running assembly!!?!
                throw new NullReferenceException(
                    string.Format(
                        "The Suites directory {0} is not within a valid build directory structure.  No 'test' parent directory exists.",
                        suitesDirectory));
            }

            string buildRoot = suitesDirectory.Substring(0, suitesDirectory.IndexOf("\\test\\"));

            // Get the SuitesData directory, where the package (AzureRunnerTest.cspkg) and 
            // certificate (AzureRunnerTest.cer) should be.
            string suitesDataDirectory = Path.Combine(buildRoot, "test\\stftests\\SuitesData");
            if (!Directory.Exists(suitesDataDirectory))
            {
                throw new DirectoryNotFoundException(string.Format("The SuitesData directory does not exist at {0}.",
                                                                   suitesDataDirectory));
            }

            // Make sure package, certificate and configuration files exist.
            _testPackagePath = Path.Combine(suitesDataDirectory, "AzureRunnerTest.cspkg");
            if (!File.Exists(_testPackagePath))
            {
                throw new FileNotFoundException(string.Format("The test Azure package does not exist at {0}.",
                                                              _testPackagePath));
            }

            _testCertificatePath = Path.Combine(suitesDataDirectory, "AzureRunnerTest.cer");
            if (!File.Exists(_testCertificatePath))
            {
                throw new FileNotFoundException(string.Format("The test certificate does not exist at {0}.",
                                                              _testCertificatePath));
            }

            _testConfigurationPath = Path.Combine(suitesDataDirectory, "AzureRunnerTest.cscfg");
            if (!File.Exists(_testConfigurationPath))
            {
                throw new FileNotFoundException(string.Format("The test configuration file does not exist at {0}.",
                                                              _testConfigurationPath));
            }

            // AzureRunner.exe is binplaced to the deployment tools directory.
            string azureRunnerPath = Path.Combine(buildRoot, "msi\\esp\\tools\\" + AzureRunnerTestSuite.AzureRunnerExe);
            if (!File.Exists(azureRunnerPath))
            {
                throw new FileNotFoundException(string.Format("AzureRunner.exe was not found at {0}.", azureRunnerPath));
            }
            _azureRunnerWrapper = new ProcessWrapper(AzureRunnerTestSuite.AzureRunnerExe, azureRunnerPath);
        }

        [TestGroupTearDown]
        public void TearDown()
        {
            _azureRunnerWrapper = null;
            _testPackagePath = null;
            _testCertificatePath = null;
            _testConfigurationPath = null;
        }

        [TestCase, Owner("darrenan"), TestCasePriority(0), Description("Positive test case.  Deploy a package to the cloud.")]
        public class P_NewDeployment_Cloud : TestNode
        {
            public override void Run()
            {
                const string deploymentLabel = "AzureRunnerTest";
                const string deploymentName = "AzureRunnerTest";
                const string deploymentSlot = "production";

                string arguments = string.Format(
                    "Deploy -StorageAccount {0} -SubscriptionId {1} -Certificate {2} -PackagePath {3} -Configuration {4} -Label {5} -Name {6} -Slot {7}",
                    _testStorageAccount,
                    _testSubscriptionId,
                    _testCertificatePath,
                    _testPackagePath,
                    _testConfigurationPath,
                    deploymentLabel,
                    deploymentName,
                    deploymentSlot
                    );

                _azureRunnerWrapper.Run(arguments);

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Owner("darrenan"), TestCasePriority(0), Description("Positive test case.  Deploy a package to dev fabric.")]
        public class P_NewDeployment_DevFabric : TestNode
        {
            public override void Run()
            {
                throw new NotImplementedException();
            }
        }

        [TestCase, Owner("darrenan"), TestCasePriority(0), Description("Negative test case.  SubscriptionId parameter not supplied.")]
        public class N_NoSubscriptionId : TestNode
        {
            public override void Run()
            {
                throw new NotImplementedException();
            }
        }

        [TestCase, Owner("darrenan"), TestCasePriority(0), Description("Negative test case.  Certificate parameter not supplied.")]
        public class N_NoCertificate : TestNode
        {
            public override void Run()
            {
                throw new NotImplementedException();
            }
        }

        [TestCase, Owner("darrenan"), TestCasePriority(0), Description("Negative test case.  PackagePath parameter not supplied.")]
        public class N_NoPackagePath : TestNode
        {
            public override void Run()
            {
                throw new NotImplementedException();
            }
        }

        [TestCase, Owner("darrenan"), TestCasePriority(0), Description("Negative test case.  Configuration parameter not supplied.")]
        public class N_NoConfiguration : TestNode
        {
            public override void Run()
            {
                throw new NotImplementedException();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\Enum.cs ===
// Enumerations used for setting console window colors.
using System;

namespace xonline.tools.batman 
{
	/// <summary>
	/// Color definitions for the console foreground.
	/// </summary>
	public enum ConsoleForeground
	{	
		Black      = 0x00,
		Navy       = 0x01,
		DarkGreen  = 0x02,
		Aquamarine = 0x03,
		Maroon     = 0x04,
		Purple     = 0x05,
		Olive      = 0x06,
		LightGray  = 0x07,
		DarkGray   = 0x08,
		Blue       = 0x09,
		Green      = 0x0A,
		Cyan       = 0x0B,
		Red        = 0x0C,
		Magenta    = 0x0D,
		Yellow     = 0x0E,
		White      = 0x0F
	}


	/// <summary>
	/// Color definitions for the console background.
	/// </summary>
	public enum ConsoleBackground
	{	
		Black      = 0x00,
		Navy       = 0x10,
		DarkGreen  = 0x20,
		Aquamarine = 0x30,
		Maroon     = 0x40,
		Purple     = 0x50,
		Olive      = 0x60,
		LightGray  = 0x70,
		DarkGray   = 0x80,
		Blue       = 0x90,
		Green      = 0xA0,
		Cyan       = 0xB0,
		Red        = 0xC0,
		Magenta    = 0xD0,
		Yellow     = 0xE0,
		White      = 0xF0
	}


	/// <summary>
	/// Border styles used for drawing rectangles on the console output window.
	/// </summary>
	public enum BorderStyle
	{
		None,
		Text,
		LineSingle,
		LineDouble
	}


	[Flags]
	public enum InputModeFlags
	{
		ENABLE_PROCESSED_INPUT = 0x01,
		ENABLE_LINE_INPUT      = 0x02,
		ENABLE_ECHO_INPUT      = 0x04,
		ENABLE_WINDOW_INPUT    = 0x08,
		ENABLE_MOUSE_INPUT     = 0x10
	}

	[Flags]
	public enum OutputModeFlags
	{
		ENABLE_PROCESSED_OUTPUT   = 0x01,
		ENABLE_WRAP_AT_EOL_OUTPUT = 0x02
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\Report.cs ===
using Billing.PSO;

using Microsoft.Webstore.WstClient;

using System;
using System.IO;
using System.Collections;
using System.Collections.Specialized;
using System.Data;
using System.Data.SqlClient;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Schema;
using System.Text;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.utilities;

namespace xonline.tools.batman
{
    /// <summary>
    /// This class contains all the info we need about subscriptions
    /// This info is collected in GetSubscriptions
    /// </summary>
    public class CUODBSubscription
    {
        public CUODBSubscription()
        {
            flags = 0;
            instance = null;
            offerid = 0;
            puid = 0;
        }
        public int flags;
        public string instance;
        public int instances;
        public int statusid;
        public long offerid;
        public long puid;
        public string guid;
        public string account;
        public long ownerPuid;
        public string payinfo;
        public string componentID;
        public string gamertag;
    }


    /// <summary>
    /// This class contains all the info we want about a user
    /// This info is collected in GetUsers
    /// </summary
    public class CUser
    {
        public CUser()
        {
            puid = 0;
            account = null;
            ownerPuid = 0;
            gamertag = null;
            payinfo = null;
            aUODBSubscriptions = null;
            aBillingSubscriptions = null;
            aBillingPayInfos = null;
            country = 0;
            goodUser = true;
        }

        public long puid;
        public string account;
        public long ownerPuid;
        public ArrayList aUODBSubscriptions;
        public ArrayList aBillingSubscriptions;
        public ArrayList aBillingPayInfos;
        public string gamertag;
        public string payinfo;
        public string locale;
        public byte country;
        public bool goodUser;
    }


    /// <summary>
    /// This class has GenerateReport which takes a log file
    ///   in CBatman.strPathToLogFile and writes an xml report there
    /// This report contains a list of things that Batman should do on an act.
    ///
    /// We have to do 2 things, fix users and fix subscriptions
    ///
    /// For users we have to fix:
    ///     Duplicate Accounts
    ///     Duplicate Subscriptions
    ///     Bad Payment Info
    ///     Duplicate gamertags
    ///
    /// For subscriptions we have to fix:
    ///     Unpurchased subscriptions
    ///     Unprovisioned subscriptions
    /// </summary>
    public class CReport
    {
        private static Report report = null;
        private static ArrayList deletedAccounts = null;
        private static ArrayList deletedSubscriptions = null;
        private static ArrayList updatePayInfo = null;
        private static ArrayList deletePayInfo = null;
        private static ArrayList rContent = null;
        private static ArrayList purchasedSubscriptions = null;
        private static ArrayList updatedSubscriptions = null;
        private static ArrayList provisionedSubscriptions = null;
        private static ArrayList fixedLocales = null;
        private static BillingProvider _billingservice = null;

        //reporting stats
        public static int numUsers = 0;
        public static int numBadUsers = 0;
        public static int numSubscriptions = 0;
        public static int numBadSubscriptions = 0;

        public static int numQueuedAccounts = 0;
        public static int numQueuedSubscriptions = 0;
        public static int numDuplicateAccounts = 0;
        public static int numDuplicateSubscriptions = 0;
        public static int numUnprovisionedSubscriptions = 0;
        public static int numIncompletePurchases = 0;
        public static int numPaymentInstrumentProblems = 0;
        public static int numBadLocales = 0;

        public static int numBillingDeletes = 0;
        public static int numBillingUpdates = 0;
        public static int numUODBUpdates = 0;


        /// <summary>
        /// Static constructor creates the billing service interface.
        /// </summary>
        static CReport()
        {
            _billingservice = new BillingProvider();
        }

        /// <summary>
        /// Pass-through to billing connection test.
        /// </summary>
        /// <param name="sIn"></param>
        /// <param name="sOut"></param>
        public static void TestConnection(string sIn, out string sOut)
        {
            _billingservice.TestConnection(sIn, out sOut);
        }

        /// <summary>
        /// Do all the investigation and report the results.
        /// </summary>
        /// <param name="dtStartDate"></param>
        /// <param name="dtEndDate"></param>
        public static void GenerateReport(DateTime dtStartDate, DateTime dtEndDate)
        {
            try
            {
                //
                //  Initialize all ArrayLists
                //

                report = new Report();
                deletedAccounts = new ArrayList();
                deletedSubscriptions = new ArrayList();
                updatePayInfo = new ArrayList();
                deletePayInfo = new ArrayList();
                purchasedSubscriptions = new ArrayList();
                updatedSubscriptions = new ArrayList();
                provisionedSubscriptions = new ArrayList();
                fixedLocales = new ArrayList();

                GetListOfContent(out rContent);

                //
                //  Checking all users in date range.
                //

                ArrayList rUsers;
                GetListOfUsers(dtStartDate, dtEndDate, out rUsers);

                numUsers = rUsers.Count;
                foreach(CUser user in rUsers)
                {
                    //
                    //  Get list of subscriptions and payinfos for this user
                    //  from the billing service.
                    //

                    GetBillingSubscriptions(user);
                    GetBillingPaymentInfos(user);

                    //
                    //  Now do all checks for this user.
                    //

                    try
                    {
                        Output.WriteVerbose("Checking user: " + user.gamertag);
                        if (user.account.StartsWith("$XBOX!"))
                        {
                            numQueuedAccounts++;
                            continue;
                        }

                        if (!FixAccounts(user))
                            continue;
                        FixUserSubscriptions(user, rContent);
                        FixPaymentInfo(user);
                        FixLocaleInfo(user);
                        if (!user.goodUser)
                            numBadUsers++;
                    }
                    catch(Exception e)
                    {
                        Output.WriteLineEntryError("User: " + user.gamertag + " had an issue talking to billing: " +
                            e.Message);
                        numBadUsers++;
                    }
                }

                //
                //  Checking all subscriptions in date range.
                //

                ArrayList rSubscriptions;
                GetListOfSubscriptions(dtStartDate, dtEndDate, out rSubscriptions);

                numSubscriptions = rSubscriptions.Count;

                foreach(CUODBSubscription subscription in rSubscriptions)
                {
                    if (subscription.instance.Length == 16)
                        FixSubscription(subscription);
                }

                //write out the file - this is the easy part
                report = new Report();
                report.DeleteAccount = new Account[deletedAccounts.Count];
                deletedAccounts.CopyTo(report.DeleteAccount);
                report.DeleteSubscription = new Subscription[deletedSubscriptions.Count];
                deletedSubscriptions.CopyTo(report.DeleteSubscription);
                report.UpdatePaymentInfos = new UpdatePaymentInfo[updatePayInfo.Count];
                updatePayInfo.CopyTo(report.UpdatePaymentInfos);
                report.DeletePaymentInfos = new PaymentInfo[deletePayInfo.Count];
                deletePayInfo.CopyTo(report.DeletePaymentInfos);
                report.LocaleUpdates = new LocaleFix[fixedLocales.Count];
                fixedLocales.CopyTo(report.LocaleUpdates);
                report.PurchaseSubscriptions = new Subscription[purchasedSubscriptions.Count];
                purchasedSubscriptions.CopyTo(report.PurchaseSubscriptions);
                report.UpdateSubscriptions = new Subscription[updatedSubscriptions.Count];
                updatedSubscriptions.CopyTo(report.UpdateSubscriptions);
                report.ProvisionSubscriptions = new Subscription[provisionedSubscriptions.Count];
                provisionedSubscriptions.CopyTo(report.ProvisionSubscriptions);


                XmlSerializer serializer = new XmlSerializer(typeof(Report));
                TextWriter writer = new StreamWriter(CBatman.strPathToLog);
                serializer.Serialize(writer, report);
                writer.Close();

                //set reporting info
                numBadSubscriptions = report.PurchaseSubscriptions.Length +
                    report.ProvisionSubscriptions.Length + report.UpdateSubscriptions.Length;
                numDuplicateAccounts = report.DeleteAccount.Length;
                numDuplicateSubscriptions = report.DeleteSubscription.Length;
                numIncompletePurchases = report.PurchaseSubscriptions.Length +
                    report.UpdateSubscriptions.Length;
                numUnprovisionedSubscriptions  = report.ProvisionSubscriptions.Length;
                numPaymentInstrumentProblems = report.UpdatePaymentInfos.Length +
                    report.DeletePaymentInfos.Length;
                numBadLocales = report.LocaleUpdates.Length;

                PrintReport();
            }
            catch(Exception e)
            {
                Output.WriteLine(e.Message);
            }
        }

        /// <summary>
        /// GetListOfUsers
        ///
        /// Gets every user inserted or modified during the specified date range.
        /// </summary>
        /// <param name="dtStartDate"></param>
        /// <param name="dtEndDate"></param>
        /// <param name="rUsers">Returned array of CUser objects.</param>
        private static void GetListOfUsers(DateTime dtStartDate, DateTime dtEndDate, out ArrayList rUsers)
        {
            WstConnection conn = null;
            WstCommand cmd = null;
            rUsers = new ArrayList();

            try
            {
                conn = new WstConnection(ConfigUtil.UodbWebstoreApp);
                conn.Open();

                cmd = conn.CreateCommand();

                cmd.WstCommandType = WstCommandType.ReadThenWrite;
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_batman_get_users_by_date";
                cmd.PartitionType = WstPartitionType.Physical;
                cmd.Parameters.Add("@dt_start_date", dtStartDate);
                cmd.Parameters.Add("@dt_end_date", dtEndDate);

                for(cmd.Partition = 0; cmd.Partition < conn.SqlPartitions.Count; ++cmd.Partition)
                {
                    WstDataReader reader = null;

                    try
                    {
                        reader = cmd.ExecuteReader();
                        long last_puid = -1;
                        CUser user = null;

                        while (reader.Read())
                        {
                            //there are a bunch of subscriptions here that belong to these users
                            if (reader.GetInt64(0) != last_puid)
                            {
                                //add the user to the users Array
                                user = new CUser();
                                user.puid = reader.GetInt64(0);
                                user.ownerPuid = reader.GetInt64(1);
                                user.gamertag = reader.GetString(2);
                                user.account = reader.GetString(3);
                                user.payinfo = reader.GetString(4);
                                user.country = reader.GetByte(8);

                                last_puid = user.puid;
                                rUsers.Add(user);
                            }

                            //this user has subscriptions
                            CUODBSubscription subscription = new CUODBSubscription();
                            subscription.instance = reader.GetString(5);
                            subscription.offerid = reader.GetInt64(6);
                            subscription.statusid = reader.GetInt32(7);
                            subscription.flags = reader.GetInt32(9);

                            user.aUODBSubscriptions.Add(subscription);
                        }
                    }
                    catch(Exception)
                    {
                        continue;
                    }
                    finally
                    {
                        if(reader != null)
                        {
                            reader.Close();
                            reader = null;
                        }
                    }
                }
            }
            finally
            {
                if(conn != null)
                {
                    conn.Close();
                    conn = null;
                }
            }
        }

        /// <summary>
        /// GetListOfSubscriptions
        ///
        /// Returns all subscriptions for users whose account has changed
        /// in the specified date range.
        /// </summary>
        /// <param name="rSubscriptions">Returned array of CUODBSubscription objects.</param>
        private static void GetListOfSubscriptions(DateTime dtStartDate, DateTime dtEndDate, out ArrayList rSubscriptions)
        {
            //this iterates through UODB (by dtStartDate and dtEndDate) and gets every subscription
            rSubscriptions = new ArrayList();

            WstConnection conn = null;
            WstCommand cmd = null;

            try
            {
                conn = new WstConnection();
                conn.Open();

                cmd = conn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_batman_get_subscriptions_by_date";
                cmd.WstCommandType = WstCommandType.ReadThenWrite;
                cmd.PartitionType = WstPartitionType.Physical;
                cmd.Parameters.Add("@dt_start_date", dtStartDate);
                cmd.Parameters.Add("@dt_end_date", dtEndDate);

                for (int iCurDb = 0; iCurDb < conn.SqlPartitions.Count; ++iCurDb)
                {
                    cmd.Partition = iCurDb;

                    WstDataReader reader = null;

                    try
                    {
                        reader = cmd.ExecuteReader();

                        while (reader.Read())
                        {
                            //each subscription
                            CUODBSubscription subscription = new CUODBSubscription();
                            subscription.puid = reader.GetInt64(0);
                            subscription.instances = reader.GetInt32(1);
                            subscription.instance = reader.GetString(2);
                            subscription.offerid = reader.GetInt64(3);
                            subscription.statusid = reader.GetInt32(4);
                            subscription.flags = reader.GetInt32(5);
                            subscription.ownerPuid = reader.GetInt64(6);
                            subscription.account = reader.GetString(7);
                            subscription.payinfo = reader.GetString(8);
                            subscription.componentID = reader.GetString(9);
                            subscription.gamertag = reader.GetString(10);

                            if (subscription.instance != "xkdctest")
                                rSubscriptions.Add(subscription);
                        }
                    }
                    catch(Exception)
                    {
                        continue;
                    }
                    finally
                    {
                        if(reader != null)
                        {
                            reader.Close();
                            reader = null;
                        }
                    }
                }
            }
            finally
            {
                if(conn != null)
                {
                    conn.Close();
                    conn = null;
                }
            }
        }

        /// <summary>
        /// GetListOfContent
        ///
        /// Retrieves the complete list of all paid content from UODB.
        /// </summary>
        /// <param name="rContent">ArrayList containing BOIDs</param>
        private static void GetListOfContent(out ArrayList rContent)
        {
            rContent = new ArrayList();

            WstConnection conn = null;
            WstCommand cmd = null;
            WstDataReader reader = null;

            try
            {
                conn = new WstConnection(ConfigUtil.UodbWebstoreApp);
                conn.Open();

                cmd = conn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_batman_get_paid_content";
                cmd.WstCommandType = WstCommandType.ReadThenWrite;
                cmd.PartitionType = WstPartitionType.Logical;
                cmd.Partition = WstCommand.AnyPartition;

                reader = cmd.ExecuteReader();

                while (reader.Read())
                {
                    //each content - just BOID
                    string boid = reader.GetString(0);

                    rContent.Add(boid);
                }
            }
            finally
            {
                if(reader != null)
                {
                    reader.Close();
                    reader = null;
                }

                if(conn != null)
                {
                    conn.Close();
                    conn = null;
                }
            }
        }

        /// <summary>
        /// FixAccounts
        /// </summary>
        /// <param name="user"></param>
        /// <returns></returns>
        private static bool FixAccounts(CUser user)
        {
            //use billing service to get a list of accounts,
            //then cancel the accounts we don't know about
            ArrayList rAccounts;
            ArrayList rActiveAccounts = new ArrayList();
            GetBillingAccounts(user, out rAccounts);

            bool found = false;
            foreach (string account in rAccounts)
            {

                if (account == user.account)
                {
                    found = true;
                }
                else
                {
                    CUser tempUser = new CUser();
                    tempUser.puid = user.puid;
                    tempUser.account = account;

                    GetBillingSubscriptions(tempUser);

                    foreach(SubscriptionInfoSetSubscriptionInfo sub in tempUser.aBillingSubscriptions)
                    {
                        if (sub.SubscriptionStatusInfo.SubscriptionStatus == "ENABLED")
                        {
                            rActiveAccounts.Add(account);
                            break;
                        }
                    }
                }
            }

            if (!found)
            {
                //big error, we should have their account
                Output.WriteLineEntryError("No matching accounts for user " + user.gamertag +
                    ". Has " + rActiveAccounts.Count.ToString() + " bad accounts.");
                numBadUsers++;
                user.goodUser = false;
                return false;
            }

            //Output.WriteLine("User " + user.gamertag + " has accounts!!");
            if (rActiveAccounts.Count > 0)
            {
                Output.WriteEntryHappy("User " + user.gamertag + " has " +
                    rActiveAccounts.Count.ToString() + " bad accounts.  " +
                    "They will be marked for cancellation in the report.");

                user.goodUser = false;
                foreach (string account in rActiveAccounts)
                {
                    DeleteAccount(user, account);
                }
            }

            return true;

        }

        /// <summary>
        /// DeleteAccount
        ///
        /// Adds the specified user account to the list of accounts flagged
        /// for deletion.  These accounts don't actually get deleted by this
        /// tool.  All such accounts are flagged in the output report, which
        /// we pass to the billing team to actually perform the deletion.
        /// </summary>
        /// <param name="user"></param>
        /// <param name="account"></param>
        private static void DeleteAccount(CUser user, string account)
        {
            Account acct = new Account();
            acct.AccountID = account;
            acct.Puid = user.ownerPuid;

            deletedAccounts.Add(acct);

            Output.WriteEntryHappy("Marking account " + account +
                " for cancellation on user " + user.gamertag);
        }

        /// <summary>
        /// FixUserSubscriptions
        /// </summary>
        /// <param name="user"></param>
        /// <param name="rContent"></param>
        private static void FixUserSubscriptions(CUser user, ArrayList rContent)
        {
            int badSubs = 0;

            //
            //  foreach sub in UODB, see if it is in billing
            //

            foreach(CUODBSubscription userSub in user.aUODBSubscriptions)
            {
                //see if the user has unpurchased subscriptions
                if (((int)(userSub.flags) & (int)0x4) == (int)0x4)
                    return;

                //don't check queued subscriptions
                if (userSub.instance.StartsWith("$XBOX"))
                    continue;

                Output.WriteVerbose("Checking for status mismatch on id: " + userSub.statusid);
                bool found = false;
                foreach(SubscriptionInfoSetSubscriptionInfo sub in user.aBillingSubscriptions)
                {
                    //we just see if the sub is in billing, not if it is cancelled or not
                    //if (sub.SubscriptionStatusInfo.SubscriptionStatus.Trim() != "ENABLED")
                    //continue;

                    //see if the user has this sub listed in billing
                    for (int i = 0; i < sub.ServiceInstanceSet.Length; i++)
                    {
                        if (userSub.instance == sub.ServiceInstanceSet[i].ServiceInstanceId)
                        {
                            found = true;
                            if ( (userSub.statusid == 1 && sub.SubscriptionStatusInfo.SubscriptionStatus.Trim() != "ENABLED") ||
                                 (userSub.statusid != 1 && sub.SubscriptionStatusInfo.SubscriptionStatus.Trim() == "ENABLED"))
                            {
                                Output.WriteLineEntryError("User " + user.gamertag + " has subscription: " + userSub.instance +
                                    " in UODB and billing, but there is an enabled/disabled mismatch");
                                badSubs++;
                            }

                            break;
                        }
                    }

                    if(found)
                        break;
                }

                if (!found)
                {
                    Output.WriteLineEntryError("User " + user.gamertag + " has subscription: " + userSub.instance +
                        " in UODB but not in billing.");
                    badSubs++;
                }
            }

            //
            //  For each subscription in billing see if it's in UODB
            //

            foreach (SubscriptionInfoSetSubscriptionInfo sub in user.aBillingSubscriptions)
            {
                bool found = false;

                //skip canceled content
                if (sub.SubscriptionStatusInfo.SubscriptionStatus.Trim() != "ENABLED")
                {
                    continue;
                }

                //skip content
                if (rContent.Contains(sub.OfferingGUID))
                {
                    continue;
                }

                if (sub.ServiceInstanceSet.Length == 0)
                {

                    Output.WriteLineEntryError("User " + user.gamertag + " has unknown subscription " +
                        sub.SubscriptionId + " which has no service instances in billing");

                    continue;
                }

                foreach(CUODBSubscription userSub in user.aUODBSubscriptions)
                {

                    //
                    //see if the user has this sub listed in UODB
                    //

                    for (int i = 0; i < sub.ServiceInstanceSet.Length; i++)
                    {
                        if (userSub.instance == sub.ServiceInstanceSet[i].ServiceInstanceId)
                        {
                            found = true;
                            break;
                        }
                    }

                    if(found)
                        break;
                }


                //billing has the sub but we don't
                //delete the sub
                if(!found)
                {
                    badSubs++;
                    DeleteSub(user, sub);
                }
            }

            if (badSubs > 0)
            {
                user.goodUser = false;
                Output.WriteEntryHappy("User " + user.gamertag + " has " +
                    badSubs.ToString() + " bad subscriptions.  " +
                    "They will be marked for cancellation in the report.");
            }
        }

        /// <summary>
        /// DeleteSub
        ///
        /// Mark a user's subscription for cancellation.
        /// </summary>
        /// <param name="user"></param>
        /// <param name="sub"></param>
        public static void DeleteSub(CUser user, SubscriptionInfoSetSubscriptionInfo sub)
        {
            Subscription xmlSub = new Subscription();
            xmlSub.GUID = sub.OfferingGUID;
            xmlSub.Offerid = 0;
            xmlSub.Account = user.account;
            xmlSub.UserPuid = user.puid;
            xmlSub.OwnerPuid = user.ownerPuid;
            xmlSub.Instance = sub.ServiceInstanceSet[0].ServiceInstanceId;

            deletedSubscriptions.Add(xmlSub);

            Output.WriteEntryHappy("Marking subscription " + sub.OfferingGUID +
                " for cancellation on user " + user.gamertag);
        }

        /// <summary>
        /// FindPayInfoForInstance
        ///
        /// Return the user's payment info, if any, matching the subscription instance
        /// ID passed in.
        /// </summary>
        /// <param name="user"></param>
        /// <param name="instanceID"></param>
        /// <returns></returns>
        private static string FindPayInfoForInstance(CUser user, string instanceID)
        {
            foreach(SubscriptionInfoSetSubscriptionInfo sub in user.aBillingSubscriptions)
            {
                //see if the user has this sub listed in billing
                for (int i = 0; i < sub.ServiceInstanceSet.Length; i++)
                {
                    if (instanceID == sub.ServiceInstanceSet[i].ServiceInstanceId)
                    {
                        foreach(string pis in user.aBillingPayInfos)
                        {
                            if (pis == sub.PaymentInstrumentId)
                            {
                                UpdatePayInfo(user, sub.PaymentInstrumentId);
                                return sub.PaymentInstrumentId;
                            }
                        }
                    }
                }
            }

            return null;
        }

        /// <summary>
        /// FixPaymentInfo
        ///
        /// If there is only one payment info, set UODB = billing.
        /// If there are multiple payment infos, delete all but the
        /// one in UODB.
        /// If the user has no payment info in billing we take no action.
        /// </summary>
        /// <param name="user"></param>
        public static void FixPaymentInfo(CUser user)
        {
            //
            //  Is there one payment info?
            //

            if (user.aBillingPayInfos.Count == 1)
            {
                string pi = (string)(user.aBillingPayInfos[0]);
                if (user.payinfo != pi)
                {
                    //  Payment infos don't match, need to update UODB
                    user.goodUser = false;
                    UpdatePayInfo(user, pi);
                }
            }
            else if (user.aBillingPayInfos.Count > 1)
            {
                //
                //  User has multiple payment infos in billing.  Many cases to consider here.
                //

                Output.WriteVerbose("User " + user.gamertag + " has multiple payment infos in billing.");
                user.goodUser = false;

                //
                //  If the payment info in UODB is not one of the payment infos returned
                //  from billing then we need to update UODB with the 'best' payment info
                //  retrieved from billing.
                //

                if (!user.aBillingPayInfos.Contains(user.payinfo))
                {
                    Output.WriteVerbose("There is no matching payinfo in UODB, attempting to find one.");
                    string base_instance = "";
                    foreach(CUODBSubscription sub in user.aUODBSubscriptions)
                    {
                        if (sub.offerid.ToString("X").ToUpper().StartsWith("FFFE0000"))
                            base_instance = sub.instance;
                    }

                    if (base_instance == "")
                    {
                        Output.WriteLineEntryError("User " + user.gamertag +
                            " has multiple payinfos, but none are equal to" +
                            " what we have in UODB and there are no base subscriptions.");
                    }
                    else
                    {
                        //
                        //  Found a base subscription in UODB for the user and
                        //  got it's instance id in base_instance.  Now look
                        //  through all subscriptions for this user and see if
                        //  any of them have a matching instance id.  If so, use
                        //  the payment info associated with that subscription.
                        //

                        string payInfo = FindPayInfoForInstance(user, base_instance);


                        if(payInfo == null)
                        {
                            //didn't find a matching subscription
                            Output.WriteLineEntryError("User " + user.gamertag +
                                " has multiple payinfos, but none are equal to" +
                                " what we have in UODB and we can't match his base subscription " +
                                base_instance + " to any subscription in billing.");
                        }
                        else
                        {
                            foreach(string pi in user.aBillingPayInfos)
                            {
                                //delete the PIs we aren't updating
                                if (pi != payInfo)
                                {
                                    DeletePayInfo(user, pi);
                                }
                            }
                        }
                    }
                }
                else
                {
                    //
                    //  In this case, we mark all payment infos in billing that don't
                    //  match what we have in UODB for deletion.
                    //

                    Output.WriteVerbose("Marking all unnecessary PIs for deletion.");
                    foreach(string pi in user.aBillingPayInfos)
                    {
                        if (pi != user.payinfo)
                        {
                            DeletePayInfo(user, pi);
                        }
                    }
                }
            } //more than 1 payinfo
            else
            {
                //0 payinfos
                user.goodUser = false;
                Output.WriteLineEntryError("User " + user.gamertag +
                    " has no payinfos.");
            }
        }

        /// <summary>
        /// UpdatePayInfo
        /// </summary>
        /// <param name="user"></param>
        /// <param name="pi"></param>
        public static void UpdatePayInfo(CUser user, string pi)
        {
            UpdatePaymentInfo upi = new UpdatePaymentInfo();
            upi.AccountID = user.account;
            upi.CorrectPaymentInfoID = pi;
            upi.UserPuid = user.puid;

            updatePayInfo.Add(upi);

            Output.WriteEntryHappy("Setting payinfo id to " + pi +
                " for user " + user.gamertag);
        }

        /// <summary>
        /// DeletePayInfo
        /// </summary>
        /// <param name="user"></param>
        /// <param name="pi"></param>
        public static void DeletePayInfo(CUser user, string pi)
        {
            PaymentInfo dpi = new PaymentInfo();
            dpi.AccountID = user.account;
            dpi.PaymentInfoID = pi;
            dpi.UserPuid = user.ownerPuid;

            deletePayInfo.Add(dpi);

            Output.WriteEntryHappy("Marking extra payinfo " +
                pi + " for deletion from user " + user.gamertag);
        }

        /// <summary>
        /// FixSubscription
        /// </summary>
        /// <param name="sub"></param>
        public static void FixSubscription(CUODBSubscription sub)
        {
            if ((sub.flags & 0x4) == 0x4) // Subscription is marked as CANCELLED in UODB
            {
                SubscriptionStatusInfo sii;
                if (sub.instance.StartsWith("$XBOX"))
                    PurchaseSubscription(sub);
                else
                {
                    if (!GetBillingSubscriptionInfo(sub, out sii))
                        return;
                    if (sii.SubscriptionStatus == "ENABLED")
                        SetUODBPurchase(sub);
                    else
                        PurchaseSubscription(sub);
                }
            }
            else if ((sub.flags & 0x1) == 0x1) // Subscription is marked as ENABLED in UODB
            {
                if (sub.instance.StartsWith("$XBOX") || sub.account.StartsWith("$XBOX"))
                    numQueuedSubscriptions++;
                else
                    ProvisionSubscription(sub);
            }
        }

        /// <summary>
        /// SetUODBPurchase
        /// </summary>
        /// <param name="sub"></param>
        public static void SetUODBPurchase(CUODBSubscription sub)
        {
            Subscription xmlSub = new Subscription();

            xmlSub.Account = sub.account;
            xmlSub.Offerid = sub.offerid;
            xmlSub.Instance = sub.instance;
            xmlSub.UserPuid = sub.puid;

            updatedSubscriptions.Add(xmlSub);

            Output.WriteEntryHappy("Setting UODB as purchased for " + sub.account +
                " for user " + sub.puid + " with offerid " + sub.offerid);
        }

        /// <summary>
        /// PurchaseSubscription
        /// </summary>
        /// <param name="sub"></param>
        public static void PurchaseSubscription(CUODBSubscription sub)
        {
           if (!sub.instance.StartsWith("$XBOX"))
               Output.WriteLineEntryError("Purchasing subscription for an instance with no $XBOX: " + sub.instance);

            Subscription xmlSub = new Subscription();

            xmlSub.Account = sub.account;
            xmlSub.Offerid = sub.offerid;
            xmlSub.Instance = sub.instance;
            xmlSub.UserPuid = sub.puid;
            xmlSub.OwnerPuid = sub.ownerPuid;
            xmlSub.Component = sub.componentID;
            xmlSub.GUID = sub.guid;
            xmlSub.GamerTag = sub.gamertag;
            xmlSub.PayInfo = sub.payinfo;

            purchasedSubscriptions.Add(xmlSub);

            Output.WriteEntryHappy("Purchasing subscription " + sub.account +
                " for user " + sub.puid + " with offerid " + sub.offerid);
        }

        /// <summary>
        /// ProvisionSubscription
        /// </summary>
        /// <param name="sub"></param>
        public static void ProvisionSubscription(CUODBSubscription sub)
        {
            Subscription xmlSub = new Subscription();

            xmlSub.Account = sub.account;
            xmlSub.Offerid = sub.offerid;
            xmlSub.Instance = sub.instance;
            xmlSub.UserPuid = sub.puid;
            xmlSub.OwnerPuid = sub.ownerPuid;
            xmlSub.Component = sub.componentID;
            xmlSub.GamerTag = sub.gamertag;

            provisionedSubscriptions.Add(xmlSub);

            Output.WriteEntryHappy("Provisioning subscription " + sub.account +
                " for user " + sub.puid + " with offerid " + sub.offerid);
        }

        /// <summary>
        /// GetBillingAccounts
        /// </summary>
        /// <param name="user"></param>
        /// <param name="rAccounts"></param>
        /// <returns></returns>
        public static bool GetBillingAccounts(CUser user, out ArrayList rAccounts)
        {
            /*
                [in]  LONG lDelegateIdHigh,
                [in]  LONG lDelegateIdLow,
                [in]  LONG lSearchPUIDHigh,
                [in]  LONG lSearchPUIDLow,
                [in]  VARIANT_BOOL fFullData,
                [in]  LONG lMax,
                [out] BSTR *pbstrResultXML,
                [out] LONG *pfMoreRows,
                [out] LONG *plAccountInfoCount,
                [out] BSTR *pbstrAccountInfoSetXML
            */
            int high = (int)(user.ownerPuid >> 32);
            int low  = (int)(user.ownerPuid & 0xFFFFFFFF);
            string result = "";
            int moreRows = 0;
            int numAccounts = 0;
            string accountSet = "";

            BillingProvider.Throttle();
            _billingservice.GetAccountIdFromAdminPUID(
                    0
                ,   0 //delegates can be 0
                ,   high
                ,   low //the OWNER puid
                ,   true //we only need account string
                ,   25 //the max of the max results
                ,   out result //if there are errors we will know here
                ,   out moreRows //0 if there were < than 25.  1 if we need to call again
                ,   out numAccounts //how many accounts we retrieved
                ,   out accountSet //all the info about the accounts
                );

            accountSet = "<?xml version=\"1.0\" encoding=\"UTF-16\" ?>\n" + accountSet;
            //Output.WriteLine("Account set: " + accountSet);
            //Output.WriteLine("Error set: " + result);
            //check result for error

            //check moreRows for excessive number of accounts
            if (moreRows == 1)
            {
                Output.WriteLineEntryError("User " + user.gamertag + " has more than 25 accounts in billing." +
                    " Please fix manually.");
            }
            //add each account from accountSet to rAccounts
            rAccounts = new ArrayList();
            XmlSerializer serializer = new XmlSerializer(typeof(AccountInfoSet));
            AccountInfoSet aiSet = new AccountInfoSet();

            byte[] xmlData = new byte[accountSet.Length * 4];
            UnicodeEncoding aEnc = new  UnicodeEncoding();
            aEnc.GetBytes(accountSet, 0, accountSet.Length, xmlData, 0);

            MemoryStream ms = new MemoryStream(xmlData);
            aiSet = (AccountInfoSet)serializer.Deserialize(ms);


            if (aiSet.AccountInfo == null)
            {
                //Output.WriteLineEntryError("User " + user.gamertag + " has no accounts!");
                return false;
            }


            foreach(AccountInfoSetAccountInfo aii in aiSet.AccountInfo)
            {
                rAccounts.Add(aii.AccountId);
            }

            return true;
        }

        /// <summary>
        /// GetBillingSubscriptionInfostring
        /// </summary>
        /// <param name="sub"></param>
        /// <returns></returns>
        public static string GetBillingSubscriptionInfoString(CUODBSubscription sub)
        {
            string result = "";

            int high = (int)(sub.ownerPuid >> 32);
            int low  = (int)(sub.ownerPuid & 0xFFFFFFFF);

            string xmlset = "";

            Output.WriteDebug("instance: " + sub.instance + "\nowner puid: " + sub.ownerPuid.ToString());

            try
            {
                BillingProvider.Throttle();
                _billingservice.GetSubscriptionStatus(
                        0
                    ,   0 //delegate
                    ,   high
                    ,   low //owner puid
                    ,   sub.instance //the billing instance of this purchase
                    ,   out result //errors go here
                    ,   out xmlset //the actual subscription info
                    );
            }
            catch (System.Web.Services.Protocols.SoapException se)
            {
                //the subscription doesn't exist in billing
                Output.WriteLineEntryError("Subscription instance " + sub.instance + " does not exist in billing." +
                    "\nUser: " + sub.ownerPuid.ToString() +
                    "\nInstance: " + sub.instance +
                    "\nError: " + result +
                    "\nSoapException: " + se.Message);
                return "";
            }
            return xmlset;
        }

        /// <summary>
        /// GetBillingSubscriptionInfo
        ///
        /// Parses the xml subscription details blob contained in the input param
        /// and produces a SubscriptionStatusInfo object.
        /// </summary>
        /// <param name="sub"></param>
        /// <param name="sii"></param>
        /// <returns></returns>
        private static bool GetBillingSubscriptionInfo(CUODBSubscription sub, out SubscriptionStatusInfo sii)
        {
            try
            {
                string xmlset = GetBillingSubscriptionInfoString(sub);

                sii = null;
                if (xmlset.Length == 0)
                    return false;

                //check result
                xmlset = "<?xml version=\"1.0\" encoding=\"UTF-16\" ?>\n" + xmlset;

                //Output.WriteLine(xmlset);
                //put xmlset into rSubs
                XmlSerializer serializer = new XmlSerializer(typeof(SubscriptionStatusInfo));

                byte[] xmlData = new byte[xmlset.Length * 4];
                UnicodeEncoding aEnc = new  UnicodeEncoding();
                aEnc.GetBytes(xmlset, 0, xmlset.Length, xmlData, 0);

                MemoryStream ms = new MemoryStream(xmlData);
                sii = (SubscriptionStatusInfo)serializer.Deserialize(ms);

            }
            catch(Exception e)
            {
                sii = null;
                Output.WriteDebugEntryError("FAIL getting billing info: " + e.Message);
                return false;
            }
            return true;
        }

        /// <summary>
        /// GetBillingSingleSubscription
        ///
        /// Calls GetSubscriptions API to retrieve a single subscription
        /// from the billing service.
        /// </summary>
        /// <param name="ownerPuid"></param>
        /// <param name="sub"></param>
        /// <returns></returns>
        private static string GetBillingSingleSubscription(long ownerPuid, string sub)
        {
            /*
                [in]  LONG lDelegateIdHigh,
                [in]  LONG lDelegateIdLow,
                [in]  LONG lRequesterIdHigh,
                [in]  LONG lRequesterIdLow,
                [in]  BSTR bstrObjectId,
                [out] BSTR *pbstrResultXML,
                [out] LONG *lpSubscriptionInfoCount,
                [out] BSTR *pbstrSubscriptionInfoSetXML
            */

            string result = "";

            int high = (int)(ownerPuid >> 32);
            int low  = (int)(ownerPuid & 0xFFFFFFFF);

            int count = 0;
            string xmlset = "";

            BillingProvider.Throttle();
            _billingservice.GetSubscriptions(
                    0
                ,   0 //delegate
                ,   high
                ,   low //owner puid
                ,   sub
                ,   out result //errors go here
                ,   out count //how many subscriptions
                ,   out xmlset //the actual subscription info
                );

            return xmlset;
        }

        /// <summary>
        /// GetBillingSubscriptions
        ///
        /// Retrieve all subscriptions for the specified user from the billing service.
        /// </summary>
        /// <param name="user"></param>
        /// <param name="rSubs"></param>
        private static void GetBillingSubscriptions(CUser user)
        {
            //
            //  Have we already retrieved subscriptions for this user?
            //  Don't do it again.
            //

            if(user.aBillingSubscriptions != null)
                return;

            //
            //  Do we have a valid user?
            //

            if(user.ownerPuid == 0)
                return;

            user.aBillingSubscriptions = new ArrayList();

            /*
                [in]  LONG lDelegateIdHigh,
                [in]  LONG lDelegateIdLow,
                [in]  LONG lRequesterIdHigh,
                [in]  LONG lRequesterIdLow,
                [in]  BSTR bstrObjectId,
                [out] BSTR *pbstrResultXML,
                [out] LONG *lpSubscriptionInfoCount,
                [out] BSTR *pbstrSubscriptionInfoSetXML
            */

            string result = "";

            int high = (int)(user.ownerPuid >> 32);
            int low  = (int)(user.ownerPuid & 0xFFFFFFFF);

            int count = 0;
            string xmlset = "";

            BillingProvider.Throttle();
            _billingservice.GetSubscriptions(
                    0
                ,   0 //delegate
                ,   high
                ,   low //owner puid
                ,   user.account
                ,   out result //errors go here
                ,   out count //how many subscriptions
                ,   out xmlset //the actual subscription info
                );

            //xmlset = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n" + xmlset;
            //xmlset = xmlset.Replace("UTF-16", "UTF-8");
            //check result
            if (count == 0)
                return;

            //put xmlset into rSubs
            XmlSerializer serializer = new XmlSerializer(typeof(SubscriptionInfoSet));
            SubscriptionInfoSet siSet = new SubscriptionInfoSet();

            byte[] xmlData = new byte[xmlset.Length * 4];
            UnicodeEncoding aEnc = new UnicodeEncoding();
            //UnicodeEncoding aEnc = new  UnicodeEncoding();
            aEnc.GetBytes(xmlset, 0, xmlset.Length, xmlData, 0);

            MemoryStream ms = new MemoryStream(xmlData);
            siSet = (SubscriptionInfoSet)serializer.Deserialize(ms);

            foreach(SubscriptionInfoSetSubscriptionInfo sii in siSet.SubscriptionInfo)
            {
                user.aBillingSubscriptions.Add(sii);
            }
        }

        /// <summary>
        /// GetBillingPaymentInfos
        ///
        /// Retrieves all payment infos for the specified user from the billing service.
        /// </summary>
        /// <param name="user"></param>
        /// <param name="rPaymentInfos"></param>
        private static void GetBillingPaymentInfos(CUser user)
        {
            if(user.aBillingPayInfos != null)
                return;

            user.aBillingPayInfos = new ArrayList();

            /*
                [in]  LONG lDelegateIdHigh,
                [in]  LONG lDelegateIdLow,
                [in]  LONG lRequesterIdHigh,
                [in]  LONG lRequestedIdLow,
                [in]  BSTR bstrObjectId,
                [out] BSTR *pbstrResultXML,
                [out] LONG *plPaymentInstrumentInfoCount,
                [out] BSTR *pbstrPaymentInstrumentInfoSetXML
            */

            string result = "";

            int high = (int)(user.ownerPuid >> 32);
            int low  = (int)(user.ownerPuid & 0xFFFFFFFF);

            int count = 0;
            string xmlset = "";

            BillingProvider.Throttle();
            _billingservice.GetPaymentInstruments(
                    0
                ,   0
                ,   high
                ,   low //owner puid
                ,   user.account
                ,   out result //errors go here
                ,   out count //how many PIs
                ,   out xmlset //the actual PI info
                );

            xmlset = "<?xml version=\"1.0\" encoding=\"UTF-16\" ?>\n" + xmlset;
            //check result
            //as it turns out an error will be thrown if there is a problem

            //put xmlset into rPaymentInfos
            XmlSerializer serializer = new XmlSerializer(typeof(PaymentInstrumentInfoSet));
            PaymentInstrumentInfoSet piSet = new PaymentInstrumentInfoSet();

            byte[] xmlData = new byte[xmlset.Length * 4];
            UnicodeEncoding aEnc = new  UnicodeEncoding();
            aEnc.GetBytes(xmlset, 0, xmlset.Length, xmlData, 0);

            MemoryStream ms = new MemoryStream(xmlData);
            piSet = (PaymentInstrumentInfoSet)serializer.Deserialize(ms);

            if (piSet.PaymentInstrumentInfo == null)
            {
                //Output.WriteLineEntryError("User " + user.gamertag + " has no payment infos");
                return;
            }
            foreach(PaymentInstrumentInfoSetPaymentInstrumentInfo pii in piSet.PaymentInstrumentInfo)
            {
                user.aBillingPayInfos.Add(pii.PaymentInstrumentId);
            }
        }

        private static void FixLocaleInfo(CUser user)
        {
            try
            {
                string locale;
                string bcountry;
                GetBillingLocaleInfo(user, out locale, out bcountry);

                locale = locale.Trim();

                if (locale.Length == 0)
                    return;

                //locale should be in the form en-US
                if (locale.IndexOf("-") != 2 || locale.Length != 5)
                    throw new Exception("Bad locale: " + locale);

                string [] parts = locale.Split('-');
                if (parts.Length != 2)
                    throw new Exception("Bad locale: " + locale);

                string language = parts[0];
                string country = parts[1];

                if (country == bcountry) //they have the same billing country as locale country
                    return;

                uint lang = 1;
                do
                {
                    //loop until we find the right language or run out of languages to check
                    Setting setting = (Setting) Enum.Parse(typeof(Setting), "locale_language" + lang);
                    string loc = Config.GetSetting(setting).Trim();
                    
                    if (loc.Length == 0)
                    {
                        lang = 0;
                        break;
                    }

                    if (loc.Length < 2)
                        throw new Exception("Bad locale for language " + lang + ": " + loc);

                    loc = loc.Substring(0, 2);
                    if (loc.ToUpper() == language.ToUpper())
                        break;

                    lang++;
                } while (true);

                if (lang == 0)
                    throw new Exception("Language " + language + " in locale " + locale + " not supported.");

                if (Locale.BuildValidLocale(lang, bcountry) != locale)
                {
                    user.goodUser = false;
                    SetLocale(user, Locale.BuildValidLocale(lang, bcountry));
                }
            }
            catch(Exception e)
            {
                Output.WriteLineEntryError("Locale error for " + user.gamertag + ": " + e.Message);
            }
        }

        private static void SetLocale(CUser user, string locale)
        {
            LocaleFix fix = new LocaleFix();

            fix.AccountID = user.account;
            fix.UserPuid = user.ownerPuid;
            fix.CorrectLocale = locale;

            fixedLocales.Add(fix);

            Output.WriteEntryHappy("Changing locale on user " + user.gamertag +
                " to " + locale);
        }

        private static void GetBillingLocaleInfo(CUser user, out string locale, out string country)
        {
            //get the local of the user
            string error = "", info = "";

            int high = (int)(user.ownerPuid >> 32);
            int low  = (int)(user.ownerPuid & 0xFFFFFFFF);

            BillingProvider.Throttle();
            _billingservice.GetAccountInfo(
                 0
                ,0
                ,high
                ,low
                ,user.account
                ,out error
                ,out info
                );

            //serialize this stuff
            XmlSerializer serializer = new XmlSerializer(typeof(AccountInfo));
            AccountInfo aiSet = new AccountInfo();

            info = "<?xml version=\"1.0\" encoding=\"UTF-16\" ?>\n" + info;
            //Output.WriteDebug("AccountInfo: " + info);

            byte[] xmlData = new byte[info.Length * 4];
            UnicodeEncoding aEnc = new  UnicodeEncoding();
            aEnc.GetBytes(info, 0, info.Length, xmlData, 0);

            MemoryStream ms = new MemoryStream(xmlData);
            aiSet = (AccountInfo)serializer.Deserialize(ms);

            if (aiSet.Locale == "")
            {
                Output.WriteLineEntryError("User " + user.gamertag + " has no locale!");
                locale = "";
            }

            locale = aiSet.Locale;
            country = aiSet.AddressInfoSet.AddressInfo.CountryCode;

            if (country.ToUpper() != CountryDictionary.CountryCode(user.country).ToUpper())
            {
                //this means that the country listed in UODB != country listed in billing service
                //this should never happen, but it can't hurt to check
                Output.WriteLineEntryError("User: " + user.gamertag + " has country in billing service that does not match country in UODB: " + country + " !=  " + CountryDictionary.CountryCode(user.country));
                locale = "";
            }

        }

        private static void PrintReport()
        {
            Output.WriteLine("Number of users: " + numUsers.ToString());
            Output.WriteLine("Number of bad users: " + numBadUsers.ToString());
            Output.WriteLine("Number of queued users: " + numQueuedAccounts.ToString());
            Output.WriteLine("Number of duplicate accounts: " + numDuplicateAccounts.ToString());
            Output.WriteLine("Number of duplicate subscriptions: " + numDuplicateSubscriptions.ToString());
            Output.WriteLine("Number of bad payinfos: " + numPaymentInstrumentProblems.ToString());
            Output.WriteLine("Number of bad locales: " + numBadLocales.ToString());
            Output.WriteLine("");
            Output.WriteLine("Number of subscriptions: " + numSubscriptions.ToString());
            Output.WriteLine("Number of bad subscriptions: " + numBadSubscriptions.ToString());
            Output.WriteLine("Number of queued subscriptions: " + numQueuedSubscriptions.ToString());
            Output.WriteLine("Number of incomplete purchases: " + numIncompletePurchases.ToString());
            Output.WriteLine("Number of unprovisioned purchases: " + numUnprovisionedSubscriptions.ToString());
            Output.WriteLine("");
            Output.WriteLine("Number of billing calls made: " + BillingProvider.NumBillingCalls.ToString());
            Output.WriteLine("Number of billing deletes: " + numBillingDeletes.ToString());
            Output.WriteLine("Number of billing updates: " + numBillingUpdates.ToString());
            Output.WriteLine("");
            Output.WriteLine("Number of UODB updates: " + numUODBUpdates.ToString());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\ServiceInstance.cs ===
// 
// ServiceInstance.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// SPS 2.5 Object Model
// Xbox Online Service
// 
// Author: Ben Zotto (benzotto)
//
using System;
using System.Collections;
using System.Xml;
using System.Text;
using System.IO;
using System.Diagnostics;
using xonline.common.service;


namespace xonline.tools.batman 
{

public enum InstanceStatusEnum
{
    Pending             = 0,
    Enabled             = 1,
    Suspended           = 2,
    Expired             = 3,
    Canceled            = 4    
}


public class ServiceInstance
{
    private static string[] InstanceStatusTypes = new string[] {  "PENDING",                                                            
                                                          "ENABLED",
                                                          "SUSPENDED",
                                                          "EXPIRED",
                                                          "CANCELED"};    

    public ServiceInstance()
    {
        doneOneInstance = false;        //check for multiple instances in reading XML.
    }

    public bool     MigrationStatus;
    public string   InstanceFriendlyName;
    public int      PuidHigh;
    public int      PuidLow;
    public string   PMN;
    public string   Role;
    public string   ServiceInstanceId;
    public InstanceStatusEnum ServiceInstanceStatus;
    public string   BaseServiceInstanceId;
    public string   ServiceComponentId;
    public string   ServiceComponentName;
    public string   Details;
    public string   ProvisioningStatus;
    public string   ProvisioningErrorCode;

    private bool    doneOneInstance;


    public void FromXml(string xml, string rootNodeName)
    {
        XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
        FromXml(xmlReader, rootNodeName);
        xmlReader.Close();
    }

    public void FromXml(XmlTextReader xmlReader, string rootNodeName)
    {
        Stack docFormat = new Stack();

        xmlReader.MoveToContent(); 
        while (!xmlReader.EOF)   
        {
            if (xmlReader.NodeType == XmlNodeType.EndElement &&
                (xmlReader.Name == rootNodeName))
            {
                xmlReader.Skip();
                break;              // we're done with this section
            }

            switch (xmlReader.Name)
            {

            case "ServiceInstance":
                xmlReader.Read();
                if(doneOneInstance == true && xmlReader.NodeType != XmlNodeType.EndElement) 
                {
                    //
                    // this shouldn't happen.
                    //
                    
                    //XBomTrace( spstrace, L_WARNING, "Seeing another service instance after component " + ServiceComponentId + "!  Ignoring." );
                    
                    return;
                } 
                else
                {                            
                    doneOneInstance = true;
                }
                break;

            case "MigrationStatus":
                MigrationStatus = (XmlSafeConvert.ToInt32(xmlReader.ReadElementString()) == 1) ? true : false;
                break;

            case "PUIDHigh":
                PuidHigh = XmlSafeConvert.ToInt32(xmlReader.ReadElementString());
                break;

            case "PUIDLow":
                PuidLow = XmlSafeConvert.ToInt32(xmlReader.ReadElementString());
                break;

            case "PMN":
                PMN = xmlReader.ReadElementString();
                break;
                    
            case "Role":
                Role = xmlReader.ReadElementString();
                break;

            case "ServiceInstanceId":
                ServiceInstanceId = xmlReader.ReadElementString();
                break;

            case "ServiceInstanceFriendlyName":
                InstanceFriendlyName = xmlReader.ReadElementString();
                break;

            case "ServiceInstanceStatus":
                ServiceInstanceStatus = (InstanceStatusEnum)Array.IndexOf(InstanceStatusTypes, xmlReader.ReadElementString());                        
                if( ServiceInstanceStatus < 0 ) 
                {
                    //XBomTrace( spstrace, L_WARNING, "Bad service instance status, using Pending" );
                    ServiceInstanceStatus = InstanceStatusEnum.Pending;                
                }
                break;

            case "BaseServiceInstanceId":
                BaseServiceInstanceId = xmlReader.ReadElementString();
                break;             

            case "ServiceComponentId":
                ServiceComponentId = xmlReader.ReadElementString();
                break;

            case "ServiceComponentName":
                ServiceComponentName = xmlReader.ReadElementString();
                break;

            case "Details":
                Details = xmlReader.ReadElementString();
                break;

            case "ProvisioningStatus":
                ProvisioningStatus = xmlReader.ReadElementString();
                break;

            case "ProvisioningErrorCode":
                ProvisioningErrorCode = xmlReader.ReadElementString();
                break;

            default:
                
                if (xmlReader.Name == rootNodeName)
                {                                   
                    // advance to the first inner element
                    xmlReader.ReadStartElement();
                    break;
                }

                if(xmlReader.NodeType == XmlNodeType.Element) 
                {
                    docFormat.Push(xmlReader.Name);
                    xmlReader.ReadStartElement();
                } 
                else // EndElement
                {                  
                    if( docFormat.Count == 0 || ((string)docFormat.Peek() != xmlReader.Name)) 
                    {
                        //XBomTrace( spstrace, L_NORMAL, "Unrecognized Xml element: " + xmlReader.Name );
                        xmlReader.Skip();
                    } 
                    else
                    {
                        xmlReader.ReadEndElement();
                        docFormat.Pop();
                    }
                }

                break;
            }
        }
    }

    public string ToXml(string rootNodeName)
    {
        StringBuilder xmlBldr = new StringBuilder();
        ToXml(xmlBldr, rootNodeName);
        return xmlBldr.ToString();
    }


    public void ToXml(StringBuilder xmlBldr, string rootNodeName)
    {
        Debug.Assert(xmlBldr != null, "Invalid Argument");

        xmlBldr.Append("<" + (rootNodeName == null ? "ServiceInstanceSet" : rootNodeName) + " xmlns=\"urn:schemas-microsoft-com:billing-data\">");
        if( MigrationStatus != false ) 
        {
            xmlBldr.Append("<MigrationStatus>1</MigrationStatus>");
        }
        xmlBldr.Append("<ServiceInstance>");    // only describe one service instance

        xmlBldr.Append("<Role>");
        xmlBldr.Append(Role);
        xmlBldr.Append("</Role><PUIDHigh>");
        xmlBldr.Append(PuidHigh);
        xmlBldr.Append("</PUIDHigh><PUIDLow>");
        xmlBldr.Append(PuidLow);
        xmlBldr.Append("</PUIDLow><PMN>");
        xmlBldr.Append(PMN);
        xmlBldr.Append("</PMN><ServiceComponentId>");
        xmlBldr.Append(ServiceComponentId);
        xmlBldr.Append("</ServiceComponentId>");
        if(ServiceComponentName != null) 
        {    
            xmlBldr.Append("<ServiceComponentName>");
            xmlBldr.Append(ServiceComponentName);
            xmlBldr.Append("</ServiceComponentName>");
        }        
        xmlBldr.Append("<ServiceInstanceId>");
        xmlBldr.Append(ServiceInstanceId);
        xmlBldr.Append("</ServiceInstanceId><ServiceInstanceFriendlyName>");
        xmlBldr.Append(InstanceFriendlyName);
        xmlBldr.Append("</ServiceInstanceFriendlyName>");
      
        // don't write this
        /*
        xmlBldr.Append("<ServiceInstanceStatus>");
        xmlBldr.Append(InstanceStatusTypes[(int)ServiceInstanceStatus]);
        xmlBldr.Append("</ServiceInstanceStatus>");
        */
      
        if(BaseServiceInstanceId != null) 
        {
            xmlBldr.Append("<BaseServiceInstanceId>");
            xmlBldr.Append(BaseServiceInstanceId);
            xmlBldr.Append("</BaseServiceInstanceId>");
        } 
        else 
        {
            xmlBldr.Append("<BaseServiceInstanceId/>");
        }

        if(Details != null) 
        {
            xmlBldr.Append("<Details>");
            xmlBldr.Append(Details);
            xmlBldr.Append("</Details>");
        } 
        else 
        {
            xmlBldr.Append("<Details/>");
        }

        if(ProvisioningStatus != null) 
        {
            xmlBldr.Append("<ProvisioningStatus>");
            xmlBldr.Append(ProvisioningStatus);
            xmlBldr.Append("</ProvisioningStatus>");
        }
        if(ProvisioningErrorCode != null)
        {
            xmlBldr.Append("<ProvisioningErrorCode>" + ProvisioningErrorCode + "</ProvisioningErrorCode>");
        }

        xmlBldr.Append("</ServiceInstance>");
        xmlBldr.Append("</" + (rootNodeName == null ? "ServiceInstanceSet" : rootNodeName) + ">");
    }
   
    
    // validates required fieds have been set before generating xml.
    // (should this be debug only?)
    public void ValidateFields()
    {
        if (PuidHigh == 0)          throw new Exception("Missing ServiceInstance.PuidHigh");
        
        // @@slamb: it's quite possible this will be 0 and be valid..
        //if (PuidLow == 0)           throw new Exception("Missing ServiceInstance.PuidLow");
        if (PMN == null)            throw new Exception("Missing ServiceInstance.PMN");
        if (Role == null)           throw new Exception("Missing ServiceInstance.Role");
        if ((int)ServiceInstanceStatus < 0 || (int)ServiceInstanceStatus > 5) 
            throw new Exception("Bad Service Instance Status (ServiceInstance.ServiceInstanceStatus)");

        if (ServiceInstanceId == null)              throw new Exception("Missing ServiceInstance.ServiceInstanceId");
        if (InstanceFriendlyName == null)           throw new Exception("Missing ServiceInstance.ServiceInstanceFriendlyName");
        if (ServiceComponentId == null)             throw new Exception("Missing ServiceInstance.ServiceComponentId");        
    }


    
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\sps.cs ===
//
//  SPS.cs
//
//  Ben Zotto (benzotto), October 2002
//
//
using System;
using System.Collections;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Diagnostics;
using System.Text.RegularExpressions;
                                  
                                     
namespace xonline.tools.batman 
{
    public class OfferingInfoSet
    {
        public string   OfferingGUID;
        public string   OfferingDescription;
        public string   OfferingPriceDescription;
        public string   InternalOfferingDescription;
        public string   LastAvailableDate;
        public string   FirstAvailableDate;
        public string   BaseOffering;
        public string   TermLocation;
        public string   CommitmentTerms;
        public string   MutuallyExclusiveGroupIdSet;
        public string   SignUpURL;
        public string   PaymentInstrumentRequired;                
        public string   PaymentTypeSet;
        public string   PaymentType;
            
        public OfferingInfoSet()
        {
        }
    
        public void FromXml(string xml)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
            FromXml(xmlReader, "OfferingInfoSet");
            xmlReader.Close();
        }
    
        public void FromXml(XmlTextReader xmlReader, string rootNodeName)
        {
            xmlReader.MoveToContent(); 
    
            while (!xmlReader.EOF)   
            {
                if (xmlReader.NodeType == XmlNodeType.EndElement &&
                    (xmlReader.Name == rootNodeName))
                {
                    xmlReader.Skip();
                    break;
                }
    
                if (xmlReader.NodeType != XmlNodeType.Element)
                {
                    xmlReader.Skip();
                    continue;
                }
    
                switch (xmlReader.Name)
                {
                    case "OfferingGUID":
                       OfferingGUID = xmlReader.ReadElementString();
                       break;
    
                    case "OfferingDescription":
                        OfferingDescription = xmlReader.ReadElementString();
                        break;
    
                    case "OfferingPriceDescription":
                        OfferingPriceDescription = xmlReader.ReadElementString();
                        break;
    
                    case "InternalOfferingDescription":
                        InternalOfferingDescription = xmlReader.ReadElementString();
                        break;
    
                    case "LastAvailableDate":
                        LastAvailableDate = xmlReader.ReadElementString();
                        break;
    
                    case "FirstAvailableDate":
                        FirstAvailableDate = xmlReader.ReadElementString();
                        break;
    
                    case "BaseOffering":
                        BaseOffering = xmlReader.ReadElementString();
                        break;
    
                    case "TermLocation":
                        TermLocation = xmlReader.ReadElementString();
                        break;
    
                    case "CommitmentTerms":
                        CommitmentTerms = xmlReader.ReadElementString();
                        break;
    
                    case "MutuallyExclusiveGroupIdSet":
                        MutuallyExclusiveGroupIdSet = xmlReader.ReadElementString();
                        break;
    
                    case "SignUpURL":
                        SignUpURL = xmlReader.ReadElementString();
                        break;
    
                    case "PaymentInstrumentRequired":
                        PaymentInstrumentRequired = xmlReader.ReadElementString();
                        break;
    
                    case "PaymentType":
                        if(PaymentType == null)
                        {
                            PaymentType = xmlReader.ReadElementString();
                        }
                        else
                        {   
                            Output.WriteLine("WARNING: Offering " + OfferingGUID + " has multiple payment types defined.");
                            xmlReader.ReadElementString();
                        }
                        break;   
    
                    default:
                        if (xmlReader.Name == rootNodeName)
                        {
                            // advance to the first inner element
                            xmlReader.ReadStartElement();
                            break;
                        }
                        
                        if (xmlReader.Name == "OfferingInfo")
                        {
                            xmlReader.ReadStartElement();
                            break;
                        }
                        
                        if (xmlReader.Name == "PaymentTypeSet")
                        {
                            xmlReader.ReadStartElement();
                            break;
                        }
                        

                        
                        xmlReader.Skip();
                        break;
                }
            }
        }        
    }    
    
    public class ServiceComponentSet
    {                
        public string   ServiceComponentId;
        public string   InstanceCount;
        public string   ServiceComponentName;
        public string   MaxRoles;
            
        public ServiceComponentSet()
        {
        }
    
        public void FromXml(string xml)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
            FromXml(xmlReader, "ServiceComponentSet");
            xmlReader.Close();
        }
    
        public void FromXml(XmlTextReader xmlReader, string rootNodeName)
        {
            xmlReader.MoveToContent(); 
    
            while (!xmlReader.EOF)   
            {
                if (xmlReader.NodeType == XmlNodeType.EndElement &&
                    (xmlReader.Name == rootNodeName))
                {
                    xmlReader.Skip();
                    break;
                }
    
                if (xmlReader.NodeType != XmlNodeType.Element)
                {
                    xmlReader.Skip();
                    continue;
                }
    
                switch (xmlReader.Name)
                {
                    case "ServiceComponentId":
                       ServiceComponentId = xmlReader.ReadElementString();
                       break;
    
                    case "InstanceCount":
                        InstanceCount = xmlReader.ReadElementString();
                        break;
    
                    case "ServiceComponentName":
                        ServiceComponentName = xmlReader.ReadElementString();
                        break;
    
                    case "MaxRoles":
                        MaxRoles = xmlReader.ReadElementString();
                        break;
    
       
                    default:
                        if (xmlReader.Name == rootNodeName)
                        {
                            // advance to the first inner element
                            xmlReader.ReadStartElement();
                            break;
                        }
                        
                        if (xmlReader.Name == "ServiceComponent")
                        {
                            xmlReader.ReadStartElement();
                            break;
                        }                                                
                        
                        xmlReader.Skip();
                        break;
                }
            }
        }
   
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\ReportSchema.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by xsd, Version=1.0.3705.288.
// 
namespace xonline.tools.batman  {    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="http://www.xboxlive.com", IsNullable=false)]
    public class Account {
        
        /// <remarks/>
        public string AccountID;
        
        /// <remarks/>
        public long Puid;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="http://www.xboxlive.com", IsNullable=false)]
    public class Subscription {
        
        /// <remarks/>
        public string Component;
        
        /// <remarks/>
        public string Instance;
        
        /// <remarks/>
        public long Offerid;
        
        /// <remarks/>
        public long UserPuid;
        
        /// <remarks/>
        public string Account;
        
        /// <remarks/>
        public string GUID;
        
        /// <remarks/>
        public string GamerTag;
        
        /// <remarks/>
        public string PayInfo;
        
        /// <remarks/>
        public long OwnerPuid;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="http://www.xboxlive.com", IsNullable=false)]
    public class PaymentInfo {
        
        /// <remarks/>
        public string AccountID;
        
        /// <remarks/>
        public long UserPuid;
        
        /// <remarks/>
        public string PaymentInfoID;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="http://www.xboxlive.com", IsNullable=false)]
    public class UpdatePaymentInfo {
        
        /// <remarks/>
        public string AccountID;
        
        /// <remarks/>
        public long UserPuid;
        
        /// <remarks/>
        public string CorrectPaymentInfoID;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="http://www.xboxlive.com", IsNullable=false)]
    public class LocaleFix {
        
        /// <remarks/>
        public string AccountID;
        
        /// <remarks/>
        public long UserPuid;
        
        /// <remarks/>
        public string CorrectLocale;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="http://www.xboxlive.com", IsNullable=false)]
    public class Report {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public Account[] DeleteAccount;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public Subscription[] DeleteSubscription;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public PaymentInfo[] DeletePaymentInfos;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public UpdatePaymentInfo[] UpdatePaymentInfos;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public LocaleFix[] LocaleUpdates;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public Subscription[] PurchaseSubscriptions;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public Subscription[] UpdateSubscriptions;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public Subscription[] ProvisionSubscriptions;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\Backup3\billingprovider.cs ===
//
// BillingProvider.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// SPS 2.5 Wrapper Class
// Xbox Online Service
//
// Author: Ben Zotto (benzotto)
//

using System;
using System.IO;
using System.Web;
using System.Data.SqlClient;
using System.Data;
using System.Net;
using System.Text;
using System.Threading;
using System.Xml;
using System.Globalization;
using System.Diagnostics;
using System.Web.Services.Protocols;
using System.Security.Permissions;
using System.Security.Principal;
using xonline.common.config;
using xonline.common.crypto;
using xonline.common.service;
using Microsoft.Webstore.WstClient;


namespace xonline.tools.batman
{

    /// <summary>
    /// Billing Provider class.  Provides static configuration of server and user,
    /// and also throttling.
    /// </summary>
    public class BillingProvider : bdk
    {
        //
        // Private data members.
        //

        private static string _username;
        private static string _password;
        private static string _wsdlLocation;
        private static DateTime _dtLastCall = DateTime.MinValue;
        private static bool _initialized = false;
        private static int _numBillingCalls = 0;
        private static int _numMSBetweenBillingCalls = 0;

        //
        //  Properties
        //

        public static string Username
        {
            get
            {
                if (!_initialized) Init();
                return _username;
            }

            set { _username = value; }
        }

        public static string Password
        {
            get
            {
                if (!_initialized) Init();
                return _password;
            }
            set { _password = value; }
        }

        public static string WsdlLocation
        {
            get
            {
                if (!_initialized) Init();
                return _wsdlLocation;
            }
            set { _wsdlLocation = value; }
        }

        public static int NumBillingCalls
        {
            get { return _numBillingCalls; }
        }

        public static int BillingCallDelay
        {
            get { return _numMSBetweenBillingCalls; }
            set { _numMSBetweenBillingCalls = value; }
        }

        /// <summary>
        /// Initialization function.
        /// </summary>
        public static void Init()
        {
            GetPartnerInfo();

            Output.WriteDebug("BillingProvider: Username=" + _username);
            Output.WriteDebug("BillingProvider: WSDL=" + _wsdlLocation);

            _initialized = true;
        }

        /// <summary>
        /// Throttling settings are shared across all instances of the class.
        /// Number of calls to billing service is also tracked globally.
        /// </summary>
        public static void Throttle()
        {
            _numBillingCalls++;
            if (_numMSBetweenBillingCalls == 0)
                return; //no throttling

            if (_dtLastCall == DateTime.MinValue)
                _dtLastCall = DateTime.Now;
            else
            {
                //they have previously called this, wait until #seconds
                TimeSpan diff = DateTime.Now - _dtLastCall;
                while (diff.TotalMilliseconds < _numMSBetweenBillingCalls)
                {
                    Thread.Sleep(10);  //yeild the proc while we wait
                    diff = DateTime.Now - _dtLastCall;
                }
            }

            _dtLastCall = DateTime.Now;
        }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="server"></param>
        public BillingProvider() : base()
        {
            // set up the bdk that we inherit from
            this.Url     = WsdlLocation;

            this.Credentials = new NetworkCredential(Username, Password);
            this.Timeout     = 20000;
        }



        /// <summary>
        /// Gets the partner key info from UODB.
        /// </summary>
        private static void GetPartnerInfo()
        {
            WstConnection conn = null;
            WstCommand cmd = null;
            WstDataReader reader = null;

            int masterkeyver;
            byte[] encPassword = null;

            try
            {
                Output.WriteDebug("Opening connection to uodb");
                conn = new WstConnection(ConfigUtil.UodbWebstoreApp);
                conn.Open();

                Output.WriteDebug("Getting service keys...");
                cmd = conn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_xbos_get_raw_sps_info";
                cmd.WstCommandType = WstCommandType.ReadThenWrite;
                cmd.PartitionType = WstPartitionType.Logical;
                cmd.Partition = WstCommand.AnyPartition;

                SqlParameter sqlUsername = cmd.Parameters.Add("@username", SqlDbType.NVarChar, 200);
                SqlParameter sqlPassword = cmd.Parameters.Add("@password", SqlDbType.VarBinary, 256);
                SqlParameter sqlWsdlLocation = cmd.Parameters.Add("@wsdllocation", SqlDbType.NVarChar, 200);
                SqlParameter sqlKeyVer = cmd.Parameters.Add("@i_masterkeyversion", SqlDbType.Int);
                sqlUsername.Direction = ParameterDirection.Output;
                sqlPassword.Direction = ParameterDirection.Output;
                sqlWsdlLocation.Direction = ParameterDirection.Output;
                sqlKeyVer.Direction = ParameterDirection.Output;

                reader = cmd.ExecuteReader();

                Username = (string)sqlUsername.Value;
                encPassword = (byte[])sqlPassword.Value;
                WsdlLocation = (string)sqlWsdlLocation.Value;
                masterkeyver = (int)sqlKeyVer.Value;

                Output.WriteDebug("Username = " + (string)sqlUsername.Value + ", WSDL = " + (string)sqlWsdlLocation.Value + ", Master Key Version = " + (int)sqlKeyVer.Value);

                // check the master key version
                if ( masterkeyver == 0 )
                {
                    UnicodeEncoding UE = new UnicodeEncoding();
                    Password = UE.GetString(encPassword);
                }
                else
                {
                    ASCIIEncoding AE = new ASCIIEncoding();
                    Password = AE.GetString(KEKCryptoMgr.DecryptWithMasterKeyWrp( (uint)masterkeyver, (uint)encPassword.Length, encPassword ));
                }
            }
            finally
            {
                if(reader != null)
                {
                    reader.Close();
                    reader = null;
                }

                if(conn != null)
                {
                    conn.Close();
                    conn = null;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\Backup3\Enum.cs ===
// Enumerations used for setting console window colors.
using System;

namespace xonline.tools.batman 
{
	/// <summary>
	/// Color definitions for the console foreground.
	/// </summary>
	public enum ConsoleForeground
	{	
		Black      = 0x00,
		Navy       = 0x01,
		DarkGreen  = 0x02,
		Aquamarine = 0x03,
		Maroon     = 0x04,
		Purple     = 0x05,
		Olive      = 0x06,
		LightGray  = 0x07,
		DarkGray   = 0x08,
		Blue       = 0x09,
		Green      = 0x0A,
		Cyan       = 0x0B,
		Red        = 0x0C,
		Magenta    = 0x0D,
		Yellow     = 0x0E,
		White      = 0x0F
	}


	/// <summary>
	/// Color definitions for the console background.
	/// </summary>
	public enum ConsoleBackground
	{	
		Black      = 0x00,
		Navy       = 0x10,
		DarkGreen  = 0x20,
		Aquamarine = 0x30,
		Maroon     = 0x40,
		Purple     = 0x50,
		Olive      = 0x60,
		LightGray  = 0x70,
		DarkGray   = 0x80,
		Blue       = 0x90,
		Green      = 0xA0,
		Cyan       = 0xB0,
		Red        = 0xC0,
		Magenta    = 0xD0,
		Yellow     = 0xE0,
		White      = 0xF0
	}


	/// <summary>
	/// Border styles used for drawing rectangles on the console output window.
	/// </summary>
	public enum BorderStyle
	{
		None,
		Text,
		LineSingle,
		LineDouble
	}


	[Flags]
	public enum InputModeFlags
	{
		ENABLE_PROCESSED_INPUT = 0x01,
		ENABLE_LINE_INPUT      = 0x02,
		ENABLE_ECHO_INPUT      = 0x04,
		ENABLE_WINDOW_INPUT    = 0x08,
		ENABLE_MOUSE_INPUT     = 0x10
	}

	[Flags]
	public enum OutputModeFlags
	{
		ENABLE_PROCESSED_OUTPUT   = 0x01,
		ENABLE_WRAP_AT_EOL_OUTPUT = 0x02
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\Backup3\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\SPSResultSchema.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by xsd, Version=1.0.3705.288.
// 
namespace xonline.tools.batman  {    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class ErrorPackage {
        
        /// <remarks/>
        public string ErrorHResult;
        
        /// <remarks/>
        public string Message;
        
        /// <remarks/>
        public ErrorPackageErrorDebugInfo ErrorDebugInfo;
        
        /// <remarks/>
        public ErrorPackageErrorDetailSet ErrorDetailSet;
        
        /// <remarks/>
        public string TrackingGUID;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class ErrorPackageErrorDebugInfo {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("DebugInfo")]
        public string[] DebugInfo;
        
        /// <remarks/>
        public string ComputerName;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class ErrorPackageErrorDetailSetErrorDetailErrorDebugInfo {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("DebugInfo")]
        public string[] DebugInfo;
        
        /// <remarks/>
        public string ComputerName;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class ErrorPackageErrorDetailSetErrorDetail {
        
        /// <remarks/>
        public int EventId;
        
        /// <remarks/>
        public string ErrorHResult;
        
        /// <remarks/>
        public string Message;
        
        /// <remarks/>
        public ErrorPackageErrorDetailSetErrorDetailErrorDebugInfo ErrorDebugInfo;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class ErrorPackageErrorDetailSet {
        
        /// <remarks/>
        public ErrorPackageErrorDetailSetErrorDetail ErrorDetail;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute("PaymentInstrumentInfoSet", Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class PaymentInstrumentInfoSet {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("PaymentInstrumentInfo")]
        public PaymentInstrumentInfoSetPaymentInstrumentInfo[] PaymentInstrumentInfo;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class PaymentInstrumentInfoSetPaymentInstrumentInfo {
        
        /// <remarks/>
        public string PaymentInstrumentId;
        
        /// <remarks/>
        public string PaymentInstrumentStatus;
        
        /// <remarks/>
        public string PaymentInstrumentType;
        
        /// <remarks/>
        public string FriendlyName;
        
        /// <remarks/>
        public PaymentInstrumentInfoSetPaymentInstrumentInfoCreditCardInfo CreditCardInfo;
        
        /// <remarks/>
        public PaymentInstrumentInfoSetPaymentInstrumentInfoDirectDebitInfo DirectDebitInfo;
        
        /// <remarks/>
        public PaymentInstrumentInfoSetPaymentInstrumentInfoQwestInfo QwestInfo;
        
        /// <remarks/>
        public PaymentInstrumentInfoSetPaymentInstrumentInfoPhone Phone;
        
        /// <remarks/>
        public PaymentInstrumentInfoSetPaymentInstrumentInfoAddressInfo AddressInfo;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class PaymentInstrumentInfoSetPaymentInstrumentInfoCreditCardInfo {
        
        /// <remarks/>
        public string AccountHolderName;
        
        /// <remarks/>
        public string AccountNumberLastFour;
        
        /// <remarks/>
        public string CardType;
        
        /// <remarks/>
        public string ExpirationDate;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class PaymentInstrumentInfoSetPaymentInstrumentInfoDirectDebitInfo {
        
        /// <remarks/>
        public string AccountHolderName;
        
        /// <remarks/>
        public string AccountNumberLastFour;
        
        /// <remarks/>
        public string BankCode;
        
        /// <remarks/>
        public string BranchCode;
        
        /// <remarks/>
        public string CheckDigits;
        
        /// <remarks/>
        public string MandateStatus;
        
        /// <remarks/>
        public string MandateReceivedDate;
        
        /// <remarks/>
        public string MandateDueDate;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class PaymentInstrumentInfoSetPaymentInstrumentInfoQwestInfo {
        
        /// <remarks/>
        public string AccountHolderName;
        
        /// <remarks/>
        public string AccountNumberLastFour;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class PaymentInstrumentInfoSetPaymentInstrumentInfoPhone {
        
        /// <remarks/>
        public string PhoneType;
        
        /// <remarks/>
        public string PhonePrefix;
        
        /// <remarks/>
        public string PhoneNumber;
        
        /// <remarks/>
        public string PhoneExtension;
        
        /// <remarks/>
        public string CountryCode;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class PaymentInstrumentInfoSetPaymentInstrumentInfoAddressInfo {
        
        /// <remarks/>
        public string AddressId;
        
        /// <remarks/>
        public string FriendlyName;
        
        /// <remarks/>
        public string Street1;
        
        /// <remarks/>
        public string Street2;
        
        /// <remarks/>
        public string Street3;
        
        /// <remarks/>
        public string City;
        
        /// <remarks/>
        public string District;
        
        /// <remarks/>
        public string State;
        
        /// <remarks/>
        public string CountryCode;
        
        /// <remarks/>
        public string PostalCode;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute("ServiceInstanceSet", Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class ServiceInstanceSet {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("ServiceInstance")]
        public ServiceInstanceSetServiceInstance[] ServiceInstance;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class ServiceInstanceSetServiceInstance {
        
        /// <remarks/>
        public string ServiceInstanceId;
        
        /// <remarks/>
        public string ServiceComponentId;
        
        /// <remarks/>
        public string ProvisioningStatus;
        
        /// <remarks/>
        public string ProvisioningErrorCode;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute("SubscriptionInfoSet", Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class SubscriptionInfoSet {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("SubscriptionInfo")]
        public SubscriptionInfoSetSubscriptionInfo[] SubscriptionInfo;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionInfoSetSubscriptionInfo {
        
        /// <remarks/>
        public string SubscriptionId;
        
        /// <remarks/>
        public string AnniversaryDate;
        
        /// <remarks/>
        public string OfferingGUID;
        
        /// <remarks/>
        public string SubscriptionDescription;
        
        /// <remarks/>
        public string SubscriptionPriceDescription;
        
        /// <remarks/>
        public string InternalSubscriptionDescription;
        
        /// <remarks/>
        public string FriendlyName;
        
        /// <remarks/>
        public string ShippingAddressId;
        
        /// <remarks/>
        public SubscriptionInfoSetSubscriptionInfoSubscriptionStatusInfo SubscriptionStatusInfo;
        
        /// <remarks/>
        public string PurchaseDate;
        
        /// <remarks/>
        public string ActivationDate;
        
        /// <remarks/>
        public string EndDate;
        
        /// <remarks/>
        public string RenewalGracePeriod;
        
        /// <remarks/>
        public string RenewOfferingId;
        
        /// <remarks/>
        public string PaymentInstrumentId;
        
        /// <remarks/>
        public string TermCommitCyclesRemaining;
        
        /// <remarks/>
        public SubscriptionInfoSetSubscriptionInfoDelayedConversion DelayedConversion;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("ServiceInstance", IsNullable=false)]
        public SubscriptionInfoSetSubscriptionInfoServiceInstance[] ServiceInstanceSet;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionInfoSetSubscriptionInfoSubscriptionStatusInfo {
        
        /// <remarks/>
        public string SubscriptionStatus;
        
        /// <remarks/>
        public SubscriptionInfoSetSubscriptionInfoSubscriptionStatusInfoViolationSet ViolationSet;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionInfoSetSubscriptionInfoSubscriptionStatusInfoViolationSet {
        
        /// <remarks/>
        public string ViolationId;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionInfoSetSubscriptionInfoDelayedConversion {
        
        /// <remarks/>
        public string OfferingGUID;
        
        /// <remarks/>
        public string ConversionDate;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionInfoSetSubscriptionInfoServiceInstance {
        
        /// <remarks/>
        public string ServiceInstanceId;
        
        /// <remarks/>
        public string ServiceComponentId;
        
        /// <remarks/>
        public string ProvisioningStatus;
        
        /// <remarks/>
        public string ProvisioningErrorCode;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class SubscriptionStatusInfo {
        
        /// <remarks/>
        public string SubscriptionStatus;
        
        /// <remarks/>
        public SubscriptionStatusInfoViolationSet ViolationSet;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionStatusInfoViolationSet {
        
        /// <remarks/>
        public string ViolationId;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute("AccountInfoSet", Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class AccountInfoSet {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("AccountInfo")]
        public AccountInfoSetAccountInfo[] AccountInfo;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoSetAccountInfo {
        
        /// <remarks/>
        public string AccountId;
        
        /// <remarks/>
        public string FriendlyName;
        
        /// <remarks/>
        public AccountInfoSetAccountInfoAccountStatus AccountStatus;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoSetAccountInfoAccountStatus {
        
        /// <remarks/>
        public AccountInfoSetAccountInfoAccountStatusViolationSet ViolationSet;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoSetAccountInfoAccountStatusViolationSet {
        
        /// <remarks/>
        public string ViolationId;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class AccountInfo {
        
        /// <remarks/>
        public string AccountId;
        
        /// <remarks/>
        public AccountInfoAccountStatusInfo AccountStatusInfo;
        
        /// <remarks/>
        public string AccountCreationDate;
        
        /// <remarks/>
        public string AccountHistoryDate;
        
        /// <remarks/>
        public string AccountSource;
        
        /// <remarks/>
        public string LegacyAccountId;
        
        /// <remarks/>
        public string AnniversaryDate;
        
        /// <remarks/>
        public string CustomerType;
        
        /// <remarks/>
        public string DefaultAddressId;
        
        /// <remarks/>
        public string CorporateIdentity;
        
        /// <remarks/>
        public string FriendlyName;
        
        /// <remarks/>
        public string FirstName;
        
        /// <remarks/>
        public string FirstNamePronunciation;
        
        /// <remarks/>
        public string LastName;
        
        /// <remarks/>
        public string LastNamePronunciation;
        
        /// <remarks/>
        public string Email;
        
        /// <remarks/>
        public string CompanyName;
        
        /// <remarks/>
        public string CompanyNamePronunciation;
        
        /// <remarks/>
        public string Locale;
        
        /// <remarks/>
        public string HCI;
        
        /// <remarks/>
        public string Currency;
        
        /// <remarks/>
        public AccountInfoPhoneSet PhoneSet;
        
        /// <remarks/>
        public AccountInfoAddressInfoSet AddressInfoSet;
        
        /// <remarks/>
        public AccountInfoTaxExemptionInfoSet TaxExemptionInfoSet;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoAccountStatusInfo {
        
        /// <remarks/>
        public string AccountStatus;
        
        /// <remarks/>
        public AccountInfoAccountStatusInfoViolationSet ViolationSet;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoAccountStatusInfoViolationSet {
        
        /// <remarks/>
        public string ViolationId;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoPhoneSet {
        
        /// <remarks/>
        public AccountInfoPhoneSetPhone Phone;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoPhoneSetPhone {
        
        /// <remarks/>
        public string PhoneType;
        
        /// <remarks/>
        public string PhonePrefix;
        
        /// <remarks/>
        public string PhoneNumber;
        
        /// <remarks/>
        public string PhoneExtension;
        
        /// <remarks/>
        public string CountryCode;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoAddressInfoSet {
        
        /// <remarks/>
        public AccountInfoAddressInfoSetAddressInfo AddressInfo;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoAddressInfoSetAddressInfo {
        
        /// <remarks/>
        public string AddressId;
        
        /// <remarks/>
        public string FriendlyName;
        
        /// <remarks/>
        public string Street1;
        
        /// <remarks/>
        public string Street2;
        
        /// <remarks/>
        public string Street3;
        
        /// <remarks/>
        public string City;
        
        /// <remarks/>
        public string District;
        
        /// <remarks/>
        public string State;
        
        /// <remarks/>
        public string CountryCode;
        
        /// <remarks/>
        public string PostalCode;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoTaxExemptionInfoSet {
        
        /// <remarks/>
        public AccountInfoTaxExemptionInfoSetTaxExemptionInfo TaxExemptionInfo;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoTaxExemptionInfoSetTaxExemptionInfo {
        
        /// <remarks/>
        public string TECertificateNumber;
        
        /// <remarks/>
        public string TEType;
        
        /// <remarks/>
        public string TEStatus;
        
        /// <remarks/>
        public string TEExpDate;
        
        /// <remarks/>
        public string TEDateAdded;
        
        /// <remarks/>
        public string TEDateReceived;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\Backup3\ReportSchema.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by xsd, Version=1.0.3705.288.
// 
namespace xonline.tools.batman  {    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="http://www.xboxlive.com", IsNullable=false)]
    public class Account {
        
        /// <remarks/>
        public string AccountID;
        
        /// <remarks/>
        public long Puid;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="http://www.xboxlive.com", IsNullable=false)]
    public class Subscription {
        
        /// <remarks/>
        public string Component;
        
        /// <remarks/>
        public string Instance;
        
        /// <remarks/>
        public long Offerid;
        
        /// <remarks/>
        public long UserPuid;
        
        /// <remarks/>
        public string Account;
        
        /// <remarks/>
        public string GUID;
        
        /// <remarks/>
        public string GamerTag;
        
        /// <remarks/>
        public string PayInfo;
        
        /// <remarks/>
        public long OwnerPuid;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="http://www.xboxlive.com", IsNullable=false)]
    public class PaymentInfo {
        
        /// <remarks/>
        public string AccountID;
        
        /// <remarks/>
        public long UserPuid;
        
        /// <remarks/>
        public string PaymentInfoID;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="http://www.xboxlive.com", IsNullable=false)]
    public class UpdatePaymentInfo {
        
        /// <remarks/>
        public string AccountID;
        
        /// <remarks/>
        public long UserPuid;
        
        /// <remarks/>
        public string CorrectPaymentInfoID;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="http://www.xboxlive.com", IsNullable=false)]
    public class LocaleFix {
        
        /// <remarks/>
        public string AccountID;
        
        /// <remarks/>
        public long UserPuid;
        
        /// <remarks/>
        public string CorrectLocale;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="http://www.xboxlive.com", IsNullable=false)]
    public class Report {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public Account[] DeleteAccount;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public Subscription[] DeleteSubscription;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public PaymentInfo[] DeletePaymentInfos;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public UpdatePaymentInfo[] UpdatePaymentInfos;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public LocaleFix[] LocaleUpdates;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public Subscription[] PurchaseSubscriptions;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public Subscription[] UpdateSubscriptions;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public Subscription[] ProvisionSubscriptions;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\Backup3\Action.cs ===
using System;
using System.IO;
using System.Xml.Serialization;
using System.Data;
using System.Data.SqlClient;
using System.Text;
using System.Collections;
using System.Collections.Specialized;
using System.Xml;
using System.Text.RegularExpressions;
using Billing.PSO;


namespace xonline.tools.batman
{
    /// <summary>
    /// Summary description for Action.
    /// </summary>
    public class CAction
    {
        public CAction()
        {

        }

        public static void ProcessReport()
        {
            Report oReport;

            //load the report into memory
            XmlSerializer serializer = new XmlSerializer(typeof(Report));

            // A FileStream is needed to read the XML document.
            FileStream fs = new FileStream(CBatman.strPathToLog, FileMode.Open);

            //Deserialize the xml into the object
            oReport = (Report) serializer.Deserialize(fs);

            fs.Close();

            //now we have the report, we should act on it
            foreach (Account account in oReport.DeleteAccount)
            {
                CReport.numDuplicateAccounts++;
                DeleteAccount(account);
            }

            foreach (Subscription subscription in oReport.DeleteSubscription)
            {
                CReport.numDuplicateSubscriptions++;
                DeleteSubscription(subscription);
            }

            foreach (PaymentInfo payinfo in oReport.DeletePaymentInfos)
            {
                CReport.numPaymentInstrumentProblems++;
                DeletePayInfo(payinfo);
            }

            foreach (UpdatePaymentInfo payinfo in oReport.UpdatePaymentInfos)
            {
                CReport.numPaymentInstrumentProblems++;
                UpdatePayInfo(payinfo);
            }

            foreach (LocaleFix fix in oReport.LocaleUpdates)
            {
                CReport.numBadLocales++;
                UpdateLocale(fix);
            }

            foreach (Subscription sub in oReport.PurchaseSubscriptions)
            {
                CReport.numIncompletePurchases++;
                PurchaseBadSubscription(sub);
            }

            foreach (Subscription sub in oReport.UpdateSubscriptions)
            {
                CReport.numIncompletePurchases++;
                UpdateSubscription(sub);
            }

            foreach (Subscription sub in oReport.ProvisionSubscriptions)
            {
                CReport.numUnprovisionedSubscriptions++;
                ProvisionSubscription(sub);
            }

            CReport.PrintReport();
        }

        public static void DeleteAccount(Account account)
        {
            try
            {
                //delete all subscriptions
                DeleteUserSubscriptions(account);

                //delete all payinfos
                //DeleteUserPayInfos(account);
                Output.WriteEntryHappy("Account: " + account.Puid.ToString() +
                    " has had all subscriptions cancelled. They are effectively gone from the system.");
            }
            catch(Exception e)
            {
                Output.WriteLineEntryError("Error cancelling account " + account.AccountID + ": " + e.Message);
            }
        }

        public static void DeleteUserPayInfos(Account account)
        {
            ArrayList rPayInfos = new ArrayList();

            CUser user = new CUser();
            user.account = account.AccountID;
            user.ownerPuid = account.Puid;
            CReport.GetPaymentInfos(user, out rPayInfos);

            foreach(string payinfoid in rPayInfos)
            {
                PaymentInfo payinfo = new PaymentInfo();
                payinfo.AccountID = user.account;
                payinfo.PaymentInfoID = payinfoid;
                payinfo.UserPuid = user.ownerPuid;
                DeletePayInfo(payinfo);
            }
        }

        public static void DeleteUserSubscriptions(Account account)
        {
            ArrayList rSubs = new ArrayList();

            CUser user = new CUser();
            user.account = account.AccountID;
            user.ownerPuid = account.Puid;
            CReport.GetSpsSubscriptions(user, out rSubs);

            foreach(SubscriptionInfoSetSubscriptionInfo sub in rSubs)
            {
                Subscription csub = new Subscription();
                csub.OwnerPuid = user.ownerPuid;
                if (sub.ServiceInstanceSet.Length == 0)
                {
                    /*
                    Output.WriteLineEntryError("Subscritpion " + sub.SubscriptionId + " on user " +
                        user.ownerPuid.ToString() + " has no service instances. Not deleting.");
                    */
                }
                else
                {
                    csub.Instance = sub.ServiceInstanceSet[0].ServiceInstanceId;
                    if (sub.SubscriptionStatusInfo.SubscriptionStatus == "ENABLED")
                        DeleteSubscription(csub);
                }
            }
        }

        public static void DeleteSubscription(Subscription sub)
        {
            PsoEncrypterClass enc = new PsoEncrypterClass();
            string subid = enc.ConvertServiceRefIDToSubID(sub.Instance);

            try
            {
                string comment = "<CommentInfo xmlns=\"urn:schemas-microsoft-com:billing-data\">";
                comment += "<CommentCode>6</CommentCode>";
                comment += "<CommentText>Duplicate Account - Cancelled by Xbox Live Billing Audit Tool</CommentText>";
                comment += "</CommentInfo>";

                int high = (int)(sub.OwnerPuid >> 32);
                int low  = (int)(sub.OwnerPuid & 0xFFFFFFFF);

                //
                //  Convert instance to subid
                //


                string guid = Guid.NewGuid().ToString();

                string error = "", charged = "", status = "", result = "";
                int count = 0;

                CBatman.Throttle();
                CBatman._sps.CancelSubscription(
                        0
                    ,   0 //delegates can be 0
                    ,   high
                    ,   low
                    ,   guid
                    ,   false
                    ,   subid
                    ,   ""
                    ,   comment
                    ,   out error
                    ,   out charged
                    ,   out status
                    ,   out count
                    ,   out result
                    );

                CReport.numBillingDeletes++;
                Output.WriteEntryHappy("Cancelled subscription: " + subid);
            }
            catch(Exception e)
            {
                Output.WriteLineEntryError("Error cancelling subscription " + subid + ": " + e.Message);
            }

        }

        public static void DeletePayInfo(PaymentInfo payinfo)
        {
            try
            {
                int high = (int)(payinfo.UserPuid >> 32);
                int low  = (int)(payinfo.UserPuid & 0xFFFFFFFF);

                string guid = Guid.NewGuid().ToString();

                string error = "";

                /*
                CBatman.Throttle();
                CBatman._sps.CloseBalance(
                        0
                    ,   0
                    ,   guid
                    ,   payinfo.PaymentInfoID
                    ,   ""
                    ,   out error
                    ,   out charged
                    );

                guid = Guid.NewGuid().ToString();

                CBatman.Throttle();
                CBatman._sps.SettleBalance(
                        0
                    ,   0
                    ,   guid
                    ,   payinfo.PaymentInfoID
                    ,   out error
                    ,   out charged
                    );

                guid = Guid.NewGuid().ToString();
                */
                CBatman.Throttle();
                CBatman._sps.RemovePaymentInstrument(
                        0
                    ,   0 //delegate
                    ,   high
                    ,   low //requester
                    ,   payinfo.PaymentInfoID
                    ,   out error
                    );

                CReport.numBillingDeletes++;
                Output.WriteEntryHappy("Deleted payment info " + payinfo.PaymentInfoID + " on user " +
                    payinfo.UserPuid.ToString());
            }
            catch(Exception e)
            {
                Output.WriteLineEntryError("Error deleting payment info " + payinfo.PaymentInfoID + ": " + e.Message);
            }
        }

        public static void UpdatePayInfo(UpdatePaymentInfo payinfo)
        {
            try
            {
                for (int i = 0; i < CBatman._servers.Length; i++)
                {
                    string server = (string)CBatman._servers[i];

                    SqlConnection cxn = new SqlConnection("server="+ server + ";trusted_connection=true;database=uodb");
                    cxn.Open();

                    SqlCommand cmd = new SqlCommand("p_batman_update_user_payinfo", cxn);
                    cmd.CommandType = CommandType.StoredProcedure;
                    SqlParameter sqlRval = cmd.Parameters.Add("@ReturnValue", 0);
                    sqlRval.Direction = ParameterDirection.ReturnValue;

                    SqlParameter sqlUser = cmd.Parameters.Add("@bi_user_puid", payinfo.UserPuid);
                    SqlParameter sqlNewPayinfo = cmd.Parameters.Add("@vc_billing_payinfo_id", payinfo.CorrectPaymentInfoID);

                    SqlDataReader reader = cmd.ExecuteReader();

                    cxn.Close();

                    if ((int)(sqlRval.Value) == 0)
                    {
                        CReport.numUODBUpdates++;
                        Output.WriteEntryHappy("Payment info for user: " + payinfo.UserPuid.ToString() +
                            " has been updated to " + payinfo.CorrectPaymentInfoID);
                        break;
                    }
                }
            }
            catch(Exception e)
            {
                Output.WriteLineEntryError("Error updating payinfo for user " +
                    payinfo.UserPuid.ToString() + ": " + e.Message);
            }

        }

        public static void PurchaseBadSubscription(Subscription sub)
        {
            PsoEncrypterClass enc = new PsoEncrypterClass();
            string subid = enc.ConvertServiceRefIDToSubID(sub.Instance);

            try
            {
                int high = (int)(sub.OwnerPuid >> 32);
                int low  = (int)(sub.OwnerPuid & 0xFFFFFFFF);

                string guid = Guid.NewGuid().ToString();

                string error = "", charged = "", result = "", newid = "", referral = "";
                int count = 0;


                CBatman.Throttle();
                CBatman._sps.PurchaseOffering(
                        1
                    ,   1
                    ,   high
                    ,   low
                    ,   guid
                    ,   false
                    ,   sub.Offerid.ToString()
                    ,   sub.Account
                    ,   subid
                    ,   sub.GUID
                    ,   0 //amount
                    ,   sub.PayInfo
                    ,   "" //sub.AddressID
                    ,   "" //sub.StartDate
                    ,   "" //sub.EndDate
                    ,   referral
                    ,   out error
                    ,   out newid
                    ,   out charged
                    ,   out count
                    ,   out result
                    );

                if (count != 1)
                    throw new Exception("Purchasing subscription for user " + sub.UserPuid + " on Guid " +
                        sub.GUID + " returned != 1 service instance sets.");

                //use some high quality benzotto code
                ServiceInstance serviceSet = new ServiceInstance();
                serviceSet.FromXml(result, "ServiceInstanceSet");

                // this Purchase output param must be set here,
                // parenthetically to the task at hand.
                string serviceInstanceId = serviceSet.ServiceInstanceId;

                int userHigh = (int)(sub.UserPuid >> 32);
                int userLow  = (int)(sub.UserPuid & 0xFFFFFFFF);

                // now set the inputs for provisioning
                serviceSet.PuidHigh = userHigh;
                serviceSet.PuidLow  = userLow;
                serviceSet.PMN      = sub.GamerTag;
                serviceSet.Role     = "User";
                serviceSet.Details  = "&lt;AlreadyProvisioned&gt;1&lt;/AlreadyProvisioned&gt;";
                serviceSet.ServiceInstanceStatus = InstanceStatusEnum.Enabled;
                serviceSet.InstanceFriendlyName = sub.GamerTag;

                // make sure we have enough information
                serviceSet.ValidateFields();

                string errorXml = "";
                try
                {
                    // now we can make an actual provisioning call.
                    CBatman.Throttle();
                    CBatman._sps.ProvisionServices(0x0, 0x0, high, low,
                        serviceSet.ToXml("ServiceInstanceSet"), out errorXml);
                }
                catch (Exception e)
                {
                    // no-op.
                    //
                    // If a larger exception is thrown here, the purchase may never be committed
                    // which would be a terrible thing since someone is paying for it.
                    // Better that we suck up the fact that SPS doesn't think something is
                    // Provisioned and have it be uncancelable via CSR than leave a paying customer
                    // without content rights, etc.
                    Output.WriteLineEntryError("Provision error! Purchase succeeded, Provision not so."
                        + " Data integrity warning; SPS is out of sync with UODB-- SPS must be notified of the "
                        + " following request. \nSERVICEINSTANCESET:\n"
                        + serviceSet.ToXml("ServiceInstanceSet") + "\nERROR OUTPUT:\n"
                        + e.Message );
                }

                /*
                 *   thanks benzotto - we don't need this anymore
                //check result
                string xmlset = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n" + result;

                //Output.WriteLine(xmlset);
                //put xmlset into rSubs
                XmlSerializer serializer = new XmlSerializer(typeof(ServiceInstanceSet));

                byte[] xmlData = new byte[xmlset.Length];
                ASCIIEncoding aEnc = new  ASCIIEncoding();
                aEnc.GetBytes(xmlset, 0, xmlset.Length, xmlData, 0);

                MemoryStream ms = new MemoryStream(xmlData);
                ServiceInstanceSet sii = (ServiceInstanceSet)serializer.Deserialize(ms);

                if (sii.ServiceInstance.Length != 1)
                    throw new Exception("Purchasing subscription for user " + sub.UserPuid + " on Guid " +
                        sub.GUID + " returned != 1 service instance sets.");

                sub.Instance = sii.ServiceInstance[0].ServiceInstanceId; //new instanceid
                //UpdateSubscription(sub);
                IProvisionSubscription(sub, result);
                */

                CReport.numBillingUpdates++;
                Output.WriteEntryHappy("Purchased subscription: " + subid);
            }
            catch(Exception e)
            {
                Output.WriteLineEntryError("Error purchasing subscription " + subid + ": " + e.Message);
            }

        }

        public static void IProvisionSubscription(Subscription sub, string strServiceInstanceSet)
        {
            try
            {
                int high = (int)(sub.UserPuid >> 32);
                int low  = (int)(sub.UserPuid & 0xFFFFFFFF);

                string guid = Guid.NewGuid().ToString();

                string error = "";

                // do same xml processing with user puid and PMN
                // get svc component etc.

                CBatman.Throttle();
                CBatman._sps.ProvisionServices(
                    0
                    ,   0
                    ,   high
                    ,   low
                    ,   strServiceInstanceSet
                    ,   out error
                    );

                CReport.numBillingUpdates++;
                Output.WriteEntryHappy("Provisioned subscription set: \n" + strServiceInstanceSet);
            }
            catch (Exception e)
            {
                Output.WriteLineEntryError("Error provisioning subscription with service instance set: \n" +
                    strServiceInstanceSet + "\n" + e.Message);
            }
        }

        public static void UpdateSubscription(Subscription sub)
        {
            try
            {
                for (int i = 0; i < CBatman._servers.Length; i++)
                {
                    string server = (string)CBatman._servers[i];

                    SqlConnection cxn = new SqlConnection("server="+ server + ";trusted_connection=true;database=uodb");
                    cxn.Open();

                    SqlCommand cmd = new SqlCommand("p_batman_update_subscription", cxn);
                    cmd.CommandType = CommandType.StoredProcedure;
                    SqlParameter sqlRval = cmd.Parameters.Add("@ReturnValue", 0);
                    sqlRval.Direction = ParameterDirection.ReturnValue;
                    SqlParameter sqlInstance = cmd.Parameters.Add("@vc_svc_instance_id", sub.Instance);
                    SqlParameter sqlUser = cmd.Parameters.Add("@bi_primary_puid", sub.UserPuid);
                    SqlParameter sqlOffer = cmd.Parameters.Add("@bi_offer_id", sub.Offerid);

                    SqlDataReader reader = cmd.ExecuteReader();

                    cxn.Close();

                    if ((int)(sqlRval.Value) == 0)
                    {
                        CReport.numUODBUpdates++;
                        Output.WriteEntryHappy("Updated subscription: " + sub.Instance + " to good flags.");
                        break;
                    }
                }
            }
            catch(Exception e)
            {
                Output.WriteLineEntryError("Error updating subscription " + sub.Instance + ": " + e.Message);
            }
        }

        public static void ProvisionSubscription(Subscription sub)
        {
            try
            {
                int high = (int)(sub.OwnerPuid >> 32);
                int low  = (int)(sub.OwnerPuid & 0xFFFFFFFF);
                int userHigh = (int)(sub.UserPuid >> 32);
                int userLow  = (int)(sub.UserPuid & 0xFFFFFFFF);

                string strServiceInstanceSet = "<ServiceInstanceSet xmlns=\"urn:schemas-microsoft-com:billing-data\">\n";
                strServiceInstanceSet += "<ServiceInstance>\n";
                strServiceInstanceSet += "<Role>User</Role>\n";
                strServiceInstanceSet += "<PUIDHigh>" + userHigh.ToString() + "</PUIDHigh>\n";
                strServiceInstanceSet += "<PUIDLow>" + userLow.ToString() + "</PUIDLow>\n";
                strServiceInstanceSet += "<PMN>" + sub.GamerTag + "</PMN>";
                strServiceInstanceSet += "<ServiceComponentId>" + sub.Component + "</ServiceComponentId>\n";
                strServiceInstanceSet += "<Details>&lt;AlreadyProvisioned&gt;1&lt;/AlreadyProvisioned&gt;</Details>";
                strServiceInstanceSet += "</ServiceInstance>\n";
                strServiceInstanceSet += "</ServiceInstanceSet>";



                string guid = Guid.NewGuid().ToString();

                string error = "";

                // do same xml processing with user puid and PMN
                // get svc component etc.

                CBatman.Throttle();
                CBatman._sps.ProvisionServices(
                        0
                    ,   0
                    ,   high
                    ,   low
                    ,   strServiceInstanceSet
                    ,   out error
                    );

                CReport.numBillingUpdates++;
                Output.WriteEntryHappy("Provisioned subscription set: \n" + strServiceInstanceSet);

                /*
                CSubscription csub = new CSubscription();
                csub.account = sub.Account;
                csub.instance = sub.Instance;
                csub.ownerPuid = sub.UserPuid;
                string siixml = CReport.GetSpsSingleSubscription(csub.ownerPuid, sub.Instance);

                Regex first = new Regex("<ServiceInstanceSet>");
                Regex last = new Regex("</ServiceInstanceSet>");

                string []parts = first.Split(siixml);
                if (parts.Length == 2)
                {
                    string []moreparts = last.Split(parts[1]);
                    if (moreparts.Length == 2)
                    {
                        string strServiceInstanceSet = "<ServiceInstanceSet xmlns=\"urn:schemas-microsoft-com:billing-data\">" +
                                                        moreparts[0] +
                                                        "</ServiceInstanceSet>";
                        IProvisionSubscription(sub, strServiceInstanceSet);
                    }
                    else
                    {
                        Output.WriteDebug("No /service instance set in service: " + siixml);
                    }

                }
                else
                {
                    Output.WriteDebug("No service instance set in service: " + siixml);
                }

                */
            }
            catch (Exception e)
            {
                Output.WriteLineEntryError("FAIL: Provision subscription " + sub.Instance + ": " + e.Message);
            }
        }

        public static void UpdateLocale(LocaleFix fix)
        {
            try
            {
                string strSendXml = "<AccountInfo xmlns=\"urn:schemas-microsoft-com:billing-data\">";
                strSendXml += "\n<Locale>" + fix.CorrectLocale + "</Locale>";
                strSendXml += "\n</AccountInfo>";

                int high = (int)(fix.UserPuid >> 32);
                int low  = (int)(fix.UserPuid & 0xFFFFFFFF);

                string error = "", paperwork = "";

                // do same xml processing with user puid and PMN
                // get svc component etc.

                CBatman.Throttle();
                CBatman._sps.UpdateAccountInfo(
                    0
                    ,   0
                    ,   high
                    ,   low
                    ,   fix.AccountID
                    ,   strSendXml
                    ,   out error
                    ,   out paperwork

                    );

                CReport.numBillingUpdates++;
                Output.WriteEntryHappy("Fixed locale: \n" + strSendXml);
            }
            catch(Exception e)
            {
                Output.WriteLineEntryError("Error updating locale for user: " + fix.UserPuid + ".\n" + e.Message);
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\Backup3\sps.cs ===
//
//  SPS.cs
//
//  Ben Zotto (benzotto), October 2002
//
//
using System;
using System.Collections;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Diagnostics;
using System.Text.RegularExpressions;
                                  
                                     
namespace xonline.tools.batman 
{
    public class OfferingInfoSet
    {
        public string   OfferingGUID;
        public string   OfferingDescription;
        public string   OfferingPriceDescription;
        public string   InternalOfferingDescription;
        public string   LastAvailableDate;
        public string   FirstAvailableDate;
        public string   BaseOffering;
        public string   TermLocation;
        public string   CommitmentTerms;
        public string   MutuallyExclusiveGroupIdSet;
        public string   SignUpURL;
        public string   PaymentInstrumentRequired;                
        public string   PaymentTypeSet;
        public string   PaymentType;
            
        public OfferingInfoSet()
        {
        }
    
        public void FromXml(string xml)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
            FromXml(xmlReader, "OfferingInfoSet");
            xmlReader.Close();
        }
    
        public void FromXml(XmlTextReader xmlReader, string rootNodeName)
        {
            xmlReader.MoveToContent(); 
    
            while (!xmlReader.EOF)   
            {
                if (xmlReader.NodeType == XmlNodeType.EndElement &&
                    (xmlReader.Name == rootNodeName))
                {
                    xmlReader.Skip();
                    break;
                }
    
                if (xmlReader.NodeType != XmlNodeType.Element)
                {
                    xmlReader.Skip();
                    continue;
                }
    
                switch (xmlReader.Name)
                {
                    case "OfferingGUID":
                       OfferingGUID = xmlReader.ReadElementString();
                       break;
    
                    case "OfferingDescription":
                        OfferingDescription = xmlReader.ReadElementString();
                        break;
    
                    case "OfferingPriceDescription":
                        OfferingPriceDescription = xmlReader.ReadElementString();
                        break;
    
                    case "InternalOfferingDescription":
                        InternalOfferingDescription = xmlReader.ReadElementString();
                        break;
    
                    case "LastAvailableDate":
                        LastAvailableDate = xmlReader.ReadElementString();
                        break;
    
                    case "FirstAvailableDate":
                        FirstAvailableDate = xmlReader.ReadElementString();
                        break;
    
                    case "BaseOffering":
                        BaseOffering = xmlReader.ReadElementString();
                        break;
    
                    case "TermLocation":
                        TermLocation = xmlReader.ReadElementString();
                        break;
    
                    case "CommitmentTerms":
                        CommitmentTerms = xmlReader.ReadElementString();
                        break;
    
                    case "MutuallyExclusiveGroupIdSet":
                        MutuallyExclusiveGroupIdSet = xmlReader.ReadElementString();
                        break;
    
                    case "SignUpURL":
                        SignUpURL = xmlReader.ReadElementString();
                        break;
    
                    case "PaymentInstrumentRequired":
                        PaymentInstrumentRequired = xmlReader.ReadElementString();
                        break;
    
                    case "PaymentType":
                        if(PaymentType == null)
                        {
                            PaymentType = xmlReader.ReadElementString();
                        }
                        else
                        {   
                            Output.WriteLine("WARNING: Offering " + OfferingGUID + " has multiple payment types defined.");
                            xmlReader.ReadElementString();
                        }
                        break;   
    
                    default:
                        if (xmlReader.Name == rootNodeName)
                        {
                            // advance to the first inner element
                            xmlReader.ReadStartElement();
                            break;
                        }
                        
                        if (xmlReader.Name == "OfferingInfo")
                        {
                            xmlReader.ReadStartElement();
                            break;
                        }
                        
                        if (xmlReader.Name == "PaymentTypeSet")
                        {
                            xmlReader.ReadStartElement();
                            break;
                        }
                        

                        
                        xmlReader.Skip();
                        break;
                }
            }
        }        
    }    
    
    public class ServiceComponentSet
    {                
        public string   ServiceComponentId;
        public string   InstanceCount;
        public string   ServiceComponentName;
        public string   MaxRoles;
            
        public ServiceComponentSet()
        {
        }
    
        public void FromXml(string xml)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
            FromXml(xmlReader, "ServiceComponentSet");
            xmlReader.Close();
        }
    
        public void FromXml(XmlTextReader xmlReader, string rootNodeName)
        {
            xmlReader.MoveToContent(); 
    
            while (!xmlReader.EOF)   
            {
                if (xmlReader.NodeType == XmlNodeType.EndElement &&
                    (xmlReader.Name == rootNodeName))
                {
                    xmlReader.Skip();
                    break;
                }
    
                if (xmlReader.NodeType != XmlNodeType.Element)
                {
                    xmlReader.Skip();
                    continue;
                }
    
                switch (xmlReader.Name)
                {
                    case "ServiceComponentId":
                       ServiceComponentId = xmlReader.ReadElementString();
                       break;
    
                    case "InstanceCount":
                        InstanceCount = xmlReader.ReadElementString();
                        break;
    
                    case "ServiceComponentName":
                        ServiceComponentName = xmlReader.ReadElementString();
                        break;
    
                    case "MaxRoles":
                        MaxRoles = xmlReader.ReadElementString();
                        break;
    
       
                    default:
                        if (xmlReader.Name == rootNodeName)
                        {
                            // advance to the first inner element
                            xmlReader.ReadStartElement();
                            break;
                        }
                        
                        if (xmlReader.Name == "ServiceComponent")
                        {
                            xmlReader.ReadStartElement();
                            break;
                        }                                                
                        
                        xmlReader.Skip();
                        break;
                }
            }
        }
   
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\Backup3\ConsoleEx.cs ===
// ConsoleEx V1.02 - Tim Sneath <tims@microsoft.com>

// ReadHiddenLine: Ben Zotto (benzotto@xbox.com)

using System;
using System.Runtime.InteropServices;
using System.Text;

namespace xonline.tools.batman 
{
	/// <summary>
	/// This class provides supplemental functionality to that available in the System.Console class. It 
	/// allows a developer to control the cursor location, size and visibility, to manipulate the color
	/// used for writing text on the screen, to read characters individually from the input buffer, to 
	/// manipulate the console window title, to clear the screen and to draw rectangles on the screen. It 
	/// does not replace traditional functions supplied in the System.Console class such as WriteLine() 
	/// and ReadLine(), but is intended to be use in conjunction with calls to that class.
	/// </summary>
	/// <remarks>
	/// This class is largely built using information from the Platform SDK. Documentation on the 
	/// Console APIs within kernel32 can be found at the following location:
	///       http://msdn.microsoft.com/library/en-us/dllproc/base/character_mode_applications.asp
	///
	/// Several of the functions within this class are reworked and expanded versions of those
	/// found in KnowledgeBase articles Q319883 and Q319257.
	/// </remarks>
	public class ConsoleEx
	{	

		#region API and Structure Declarations

		// Standard structures used for interop with kernel32
		[StructLayout(LayoutKind.Sequential)]
			struct COORD
		{
			public short x;
			public short y;
		}

		[StructLayout(LayoutKind.Sequential)]
			struct SMALL_RECT
		{
			public short Left;
			public short Top;
			public short Right;
			public short Bottom;
		}
		
		[StructLayout(LayoutKind.Sequential)]
			struct CONSOLE_SCREEN_BUFFER_INFO
		{
			public COORD dwSize;
			public COORD dwCursorPosition;
			public int wAttributes;
			public SMALL_RECT srWindow;
			public COORD dwMaximumWindowSize;
		}

		[StructLayout(LayoutKind.Sequential)]
			struct CONSOLE_CURSOR_INFO 
		{
			public int dwSize;  
			public bool bVisible;
		} 


		// External function declarations
		[DllImport("kernel32.dll", EntryPoint="GetStdHandle", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int GetStdHandle(int nStdHandle);

		[DllImport("kernel32.dll", EntryPoint="GetConsoleScreenBufferInfo", SetLastError=true, 
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int GetConsoleScreenBufferInfo(int hConsoleOutput,
			ref CONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleTextAttribute", SetLastError=true, 
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int SetConsoleTextAttribute(int hConsoleOutput,
			int wAttributes);

		[DllImport("kernel32.dll", EntryPoint="FillConsoleOutputCharacter", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int FillConsoleOutputCharacter(int hConsoleOutput, 
			byte cCharacter, int nLength, COORD dwWriteCoord, ref int lpNumberOfCharsWritten);

		[DllImport("kernel32.dll", EntryPoint="FillConsoleOutputAttribute", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int FillConsoleOutputAttribute(int hConsoleOutput,
			int wAttribute, int nLength, COORD dwWriteCoord, ref int lpNumberOfAttrsWritten);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleCursorPosition", SetLastError=true, 
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int SetConsoleCursorPosition(int hConsoleOutput, 
			COORD dwCursorPosition);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleTitle", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern bool SetConsoleTitle(string lpConsoleTitle);

		[DllImport("kernel32.dll", EntryPoint="GetConsoleTitle", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int GetConsoleTitle(StringBuilder lpConsoleTitle, 
			int nSize);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleCursorInfo", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int SetConsoleCursorInfo(int hConsoleOutput, 
			ref CONSOLE_CURSOR_INFO lpConsoleCursorInfo);

		[DllImport("kernel32.dll", EntryPoint="GetConsoleCursorInfo", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int GetConsoleCursorInfo(int hConsoleOutput, 
			ref CONSOLE_CURSOR_INFO lpConsoleCursorInfo);
		
		[DllImport("kernel32.dll", EntryPoint="ReadConsole", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern bool ReadConsole(int hConsoleInput,
			StringBuilder buf, int nNumberOfCharsToRead, ref int lpNumberOfCharsRead, int lpReserved);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleMode", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern bool SetConsoleMode(int hConsoleHandle,
			int dwMode);

		[DllImport("kernel32.dll", EntryPoint="GetConsoleMode", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern bool GetConsoleMode(int hConsoleHandle,
			ref int dwMode);

		#endregion


		// Const variables
		private const int  INVALID_HANDLE_VALUE    = -1;
		private const int  STD_INPUT_HANDLE        = -10;
		private const int  STD_OUTPUT_HANDLE       = -11;
		private const byte EMPTY                   = 32;
		private const int  TITLE_LENGTH            = 1024;

		// Internal variables
		private static int hConsoleOutput;	// handle to output buffer
		private static int hConsoleInput;	// handle to input buffer
		private static COORD ConsoleOutputLocation;
		private static CONSOLE_SCREEN_BUFFER_INFO ConsoleInfo;
		private static int OriginalConsolePen;
		private static int CurrentConsolePen;

		
		// Constructors
		static ConsoleEx()
		{
			// Grab input and output buffer handles
			hConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE);
			hConsoleInput = GetStdHandle(STD_INPUT_HANDLE);
			if (hConsoleOutput == INVALID_HANDLE_VALUE || hConsoleInput == INVALID_HANDLE_VALUE)
				throw new ApplicationException("Unable to obtain buffer handle during initialization.");

			// Get information about the console window characteristics.
			ConsoleInfo = new CONSOLE_SCREEN_BUFFER_INFO();
			ConsoleOutputLocation = new COORD();
			GetConsoleScreenBufferInfo(hConsoleOutput, ref ConsoleInfo);
			OriginalConsolePen = ConsoleInfo.wAttributes;

			// Disable wrapping at the end of a line (ENABLE_WRAP_AT_EOL_INPUT); this enables rectangles 
			// to be drawn that fill the screen without the window scrolling.
			SetConsoleMode(hConsoleOutput, 
				(int) OutputModeFlags.ENABLE_PROCESSED_OUTPUT);
		}

		private ConsoleEx() : base()
		{
			throw new NotSupportedException("This object may not be instantiated. Use static methods instead.");
		}


		/// <summary>
		/// Sets or gets the console window title.
		/// </summary>
		public static string Title 
		{
			get
			{
				StringBuilder title = new StringBuilder(TITLE_LENGTH);
				int ret = GetConsoleTitle(title, TITLE_LENGTH);
				return title.ToString(0, ret);
			}
			set 
			{	
				if (value.Length < TITLE_LENGTH)
					SetConsoleTitle(value);
				else
					throw new ArgumentOutOfRangeException(
						"Title", 
						value, 
						"Console window title must be no more than " + TITLE_LENGTH +  " characters.");
			}
		}


		/// <summary>
		/// Gets or sets the visibility of the cursor.
		/// </summary>
		public static bool CursorVisible
		{
			get
			{
				CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
				GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
				return ConsoleCursorInfo.bVisible;
			}
			set
			{
				// Obtain current cursor information, since the CONSOLE_CURSOR_INFO struct
				// also contains information on the shape of the cursor.
				CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
				GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);

				ConsoleCursorInfo.bVisible = value;
				SetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
			}
		}


		/// <summary>
		/// Gets or sets the height of the cursor, as a percentage of the overall character cell.
		/// The value must be a number between 1 and 100, otherwise an ArgumentOutOfRangeException
		/// will be thrown.
		/// </summary>
		public static int CursorHeight
		{
			get
			{
				CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
				GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
				return ConsoleCursorInfo.dwSize;
			}
			set
			{
				if (value >= 1 && value <= 100)
				{
					// Obtain current cursor information, since the CONSOLE_CURSOR_INFO struct
					// also contains information on the visibility of the cursor.
					CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
					GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);

					ConsoleCursorInfo.dwSize = value;
					SetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
				}
				else
					throw new ArgumentOutOfRangeException(
						"CursorHeight", 
						value, 
						"Cursor height must be a percentage of the character cell between 1 and 100.");
			}
		}


		/// <summary>
		/// Sets the console pen color to that specified.
		/// </summary>
		/// <param name="foreground">A foreground color specified from the 
		/// ConsoleForeground enumeration</param>
		/// <param name="background">A background color specified from the 
		/// ConsoleBackground enumeration</param>
		public static void TextColor(ConsoleForeground foreground, ConsoleBackground background)
		{
			CurrentConsolePen = (int)foreground + (int)background;
			SetConsoleTextAttribute(hConsoleOutput, CurrentConsolePen);
		}
	

		/// <summary>
		/// Resets the console pen color to the original default at the time 
		/// the class was originally initialised.
		/// </summary>
		public static void ResetColor()
		{
			SetConsoleTextAttribute(hConsoleOutput, OriginalConsolePen);
		}
	

		/// <summary>
		/// Clears screen.
		/// </summary>
		public static void Clear()
		{
			int hWrittenChars = 0;
			CONSOLE_SCREEN_BUFFER_INFO strConsoleInfo = new CONSOLE_SCREEN_BUFFER_INFO();			
			COORD Home;		
			Home.x = Home.y = 0;
			
			if (GetConsoleScreenBufferInfo(hConsoleOutput, ref strConsoleInfo) == 0)
			{
				// If the device does not support GetConsoleScreenBufferInfo, then try just
				// writing ^L (ASCII control code for Form Feed) to the screen. This may 
				// work for some scenarios such as using telnet to access a remote console.
				Console.Write('\x0c');	// ^L
				return;
			}
			
			FillConsoleOutputCharacter(hConsoleOutput, EMPTY, 
				strConsoleInfo.dwSize.x * strConsoleInfo.dwSize.y, Home, ref hWrittenChars);
			FillConsoleOutputAttribute(hConsoleOutput, CurrentConsolePen, 
				strConsoleInfo.dwSize.x * strConsoleInfo.dwSize.y, Home, ref hWrittenChars);
			
			SetConsoleCursorPosition(hConsoleOutput, Home);
		}


		/// <summary>
		/// Moves the console cursor to the specified location on the screen.
		/// </summary>
		/// <param name="x">X co-ordinate for desired location (typically 0 to 79)</param>
		/// <param name="y">Y co-ordinate for desired location (typically 0 to 24)</param>
		public static void Move(int x, int y)
		{
			// Check that parameters specified are sane
			CONSOLE_SCREEN_BUFFER_INFO strConsoleInfo = new CONSOLE_SCREEN_BUFFER_INFO();
			GetConsoleScreenBufferInfo(hConsoleOutput, ref strConsoleInfo);

			if (x >= strConsoleInfo.dwSize.x ||  x < 0)
				throw new ArgumentOutOfRangeException("x", x, 
					"The co-ordinates specified must be within the dimensions of the window.");

			if (y >= strConsoleInfo.dwSize.y || y < 0)
				throw new ArgumentOutOfRangeException("y", y, 
					"The co-ordinates specified must be within the dimensions of the window.");

			COORD Location;
			Location.x = (short)x;
			Location.y = (short)y;

			SetConsoleCursorPosition(hConsoleOutput, Location);
		}


		/// <summary>
		/// Writes the specified text at the given location.
		/// </summary>
		/// <remarks>
		/// This is a wrapper function that provides a shorthand for moving to a location and 
		/// writing there. The cursor will be left in the position immediately succeeding the 
		/// rightmost character of the text written to the screen.
		/// </remarks>
		/// <param name="x">X co-ordinate for leftmost character of text</param>
		/// <param name="y">Y co-ordinate for location of text</param>
		/// <param name="text">String to be written to the screen</param>
		public static void WriteAt(int x, int y, string text)
		{
			// No need to validate x and y co-ordinates as they will be tested by Move()
			Move(x, y);

			Console.Write(text);
		}


		/// <summary>
		/// Draws a rectangle on the console window using either 7-bit ASCII characters or
		/// line drawing characters, depending on the style specified. If the dimensions of 
		/// the rectangle exceed the boundaries of the screen, an ArgumentOutOfRangeException
		/// will be thrown.
		/// </summary>
		/// <remarks>
		/// Note that the sides of the rectangle themselves are one character wide,
		/// so, for example, a width and height of 2 will result in a 3-by-3 character rectangle.
		/// This matches the behavior of the equivalent Windows Forms DrawRectangle() method.
		/// </remarks>
		/// <param name="style">A border style specified from the BorderStyle enumeration</param>
		/// <param name="x">X co-ordinate of upper left corner of rectangle</param>
		/// <param name="y">Y co-ordinate of upper left corner of rectangle</param>
		/// <param name="cx">Width of the rectangle</param>
		/// <param name="cy">Height of the rectangle</param>
		public static void DrawRectangle(BorderStyle style, int x, int y, int cx, int cy, bool fill)
		{
			if (style != BorderStyle.None)
			{
				// Set rectangle frame appropriately for the style chosen. Unicode 
				// characters represent horizontal and vertical lines, then NW, NE,
				// SW and SE corners of the rectangle in that order.
				string frame;
				switch(style)
				{
					case BorderStyle.LineSingle:
						frame = "\u2500\u2502\u250c\u2510\u2514\u2518";
						break;
					case BorderStyle.LineDouble:
						frame = "\u2550\u2551\u2554\u2557\u255A\u255D";
						break;
					default:
						frame = @"-|/\\/";
						break;
				}

				// Create top line of box
				StringBuilder line = new StringBuilder(cx+1);
				line.Append(frame[2]);
				for (int i=1; i < cx; i++) line.Append(frame[0]);
				line.Append(frame[3]);
				Move(x, y);
				Console.Write(line);

				// Create sides of box
				for (int i=1; i < cy; i++)
				{
					Move(x, y+i);
					Console.Write(frame[1]);
					Move(x+cx, y+i);
					Console.Write(frame[1]);
				}

				// Create bottom line of box
				line[0] = frame[4];
				line[cx] = frame[5];
				Move(x, y+cy);
				Console.Write(line);
			}
		
			// Fill rectangle with current console pen
			if (fill)
			{
				int hWrittenChars = 0;
				COORD c = new COORD();
				c.x = (short)x;
			
				for (int i=0; i<=cy; i++)
				{
					c.y = (short)(y + i);
					FillConsoleOutputAttribute(hConsoleOutput, CurrentConsolePen, 
						cx + 1, c, ref hWrittenChars);
				}
			}
		}

		
		/// <summary>
		/// Read a single character from the input buffer. Unlike Console.Read(), which 
		/// only reads from the buffer when the read operation has terminated (e.g. by
		/// pressing Enter), this method reads as soon as the character has been entered.
		/// </summary>
		/// <returns>The character read by the system</returns>
		public static char ReadChar()
		{
			// Temporarily disable character echo (ENABLE_ECHO_INPUT) and line input
			// (ENABLE_LINE_INPUT) during this operation
			SetConsoleMode(hConsoleInput, 
				(int) (InputModeFlags.ENABLE_PROCESSED_INPUT | 
				InputModeFlags.ENABLE_WINDOW_INPUT | 
				InputModeFlags.ENABLE_MOUSE_INPUT));

			int lpNumberOfCharsRead = 0;
			StringBuilder buf = new StringBuilder(1);

			bool success = ReadConsole(hConsoleInput, buf, 1, ref lpNumberOfCharsRead, 0);
			
			// Reenable character echo and line input
			SetConsoleMode(hConsoleInput, 
				(int) (InputModeFlags.ENABLE_PROCESSED_INPUT | 
				InputModeFlags.ENABLE_ECHO_INPUT |
				InputModeFlags.ENABLE_LINE_INPUT |
				InputModeFlags.ENABLE_WINDOW_INPUT | 
				InputModeFlags.ENABLE_MOUSE_INPUT));
			
			if (success)
				return Convert.ToChar(buf[0]);
			else 
				throw new ApplicationException("Attempt to call ReadConsole API failed.");
		}
        
        ///
        /// BenZotto wrote this for BillingXCheck
        ///
        public static string ReadHiddenLine()
        {
            StringBuilder sb = new StringBuilder();
            char c;
            
            while((c = ReadChar()) != '\r' && c != '\n')
            {
                sb.Append(c);
            }
            
            return sb.ToString();
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\Backup3\ServiceInstance.cs ===
// 
// ServiceInstance.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// SPS 2.5 Object Model
// Xbox Online Service
// 
// Author: Ben Zotto (benzotto)
//
using System;
using System.Collections;
using System.Xml;
using System.Text;
using System.IO;
using System.Diagnostics;
using xonline.common.service;


namespace xonline.tools.batman 
{

public enum InstanceStatusEnum
{
    Pending             = 0,
    Enabled             = 1,
    Suspended           = 2,
    Expired             = 3,
    Canceled            = 4    
}


public class ServiceInstance
{
    private static string[] InstanceStatusTypes = new string[] {  "PENDING",                                                            
                                                          "ENABLED",
                                                          "SUSPENDED",
                                                          "EXPIRED",
                                                          "CANCELED"};    

    public ServiceInstance()
    {
        doneOneInstance = false;        //check for multiple instances in reading XML.
    }

    public bool     MigrationStatus;
    public string   InstanceFriendlyName;
    public int      PuidHigh;
    public int      PuidLow;
    public string   PMN;
    public string   Role;
    public string   ServiceInstanceId;
    public InstanceStatusEnum ServiceInstanceStatus;
    public string   BaseServiceInstanceId;
    public string   ServiceComponentId;
    public string   ServiceComponentName;
    public string   Details;
    public string   ProvisioningStatus;
    public string   ProvisioningErrorCode;

    private bool    doneOneInstance;


    public void FromXml(string xml, string rootNodeName)
    {
        XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
        FromXml(xmlReader, rootNodeName);
        xmlReader.Close();
    }

    public void FromXml(XmlTextReader xmlReader, string rootNodeName)
    {
        Stack docFormat = new Stack();

        xmlReader.MoveToContent(); 
        while (!xmlReader.EOF)   
        {
            if (xmlReader.NodeType == XmlNodeType.EndElement &&
                (xmlReader.Name == rootNodeName))
            {
                xmlReader.Skip();
                break;              // we're done with this section
            }

            switch (xmlReader.Name)
            {

            case "ServiceInstance":
                xmlReader.Read();
                if(doneOneInstance == true && xmlReader.NodeType != XmlNodeType.EndElement) 
                {
                    //
                    // this shouldn't happen.
                    //
                    
                    //XBomTrace( spstrace, L_WARNING, "Seeing another service instance after component " + ServiceComponentId + "!  Ignoring." );
                    
                    return;
                } 
                else
                {                            
                    doneOneInstance = true;
                }
                break;

            case "MigrationStatus":
                MigrationStatus = (XmlSafeConvert.ToInt32(xmlReader.ReadElementString()) == 1) ? true : false;
                break;

            case "PUIDHigh":
                PuidHigh = XmlSafeConvert.ToInt32(xmlReader.ReadElementString());
                break;

            case "PUIDLow":
                PuidLow = XmlSafeConvert.ToInt32(xmlReader.ReadElementString());
                break;

            case "PMN":
                PMN = xmlReader.ReadElementString();
                break;
                    
            case "Role":
                Role = xmlReader.ReadElementString();
                break;

            case "ServiceInstanceId":
                ServiceInstanceId = xmlReader.ReadElementString();
                break;

            case "ServiceInstanceFriendlyName":
                InstanceFriendlyName = xmlReader.ReadElementString();
                break;

            case "ServiceInstanceStatus":
                ServiceInstanceStatus = (InstanceStatusEnum)Array.IndexOf(InstanceStatusTypes, xmlReader.ReadElementString());                        
                if( ServiceInstanceStatus < 0 ) 
                {
                    //XBomTrace( spstrace, L_WARNING, "Bad service instance status, using Pending" );
                    ServiceInstanceStatus = InstanceStatusEnum.Pending;                
                }
                break;

            case "BaseServiceInstanceId":
                BaseServiceInstanceId = xmlReader.ReadElementString();
                break;             

            case "ServiceComponentId":
                ServiceComponentId = xmlReader.ReadElementString();
                break;

            case "ServiceComponentName":
                ServiceComponentName = xmlReader.ReadElementString();
                break;

            case "Details":
                Details = xmlReader.ReadElementString();
                break;

            case "ProvisioningStatus":
                ProvisioningStatus = xmlReader.ReadElementString();
                break;

            case "ProvisioningErrorCode":
                ProvisioningErrorCode = xmlReader.ReadElementString();
                break;

            default:
                
                if (xmlReader.Name == rootNodeName)
                {                                   
                    // advance to the first inner element
                    xmlReader.ReadStartElement();
                    break;
                }

                if(xmlReader.NodeType == XmlNodeType.Element) 
                {
                    docFormat.Push(xmlReader.Name);
                    xmlReader.ReadStartElement();
                } 
                else // EndElement
                {                  
                    if( docFormat.Count == 0 || ((string)docFormat.Peek() != xmlReader.Name)) 
                    {
                        //XBomTrace( spstrace, L_NORMAL, "Unrecognized Xml element: " + xmlReader.Name );
                        xmlReader.Skip();
                    } 
                    else
                    {
                        xmlReader.ReadEndElement();
                        docFormat.Pop();
                    }
                }

                break;
            }
        }
    }

    public string ToXml(string rootNodeName)
    {
        StringBuilder xmlBldr = new StringBuilder();
        ToXml(xmlBldr, rootNodeName);
        return xmlBldr.ToString();
    }


    public void ToXml(StringBuilder xmlBldr, string rootNodeName)
    {
        Debug.Assert(xmlBldr != null, "Invalid Argument");

        xmlBldr.Append("<" + (rootNodeName == null ? "ServiceInstanceSet" : rootNodeName) + " xmlns=\"urn:schemas-microsoft-com:billing-data\">");
        if( MigrationStatus != false ) 
        {
            xmlBldr.Append("<MigrationStatus>1</MigrationStatus>");
        }
        xmlBldr.Append("<ServiceInstance>");    // only describe one service instance

        xmlBldr.Append("<Role>");
        xmlBldr.Append(Role);
        xmlBldr.Append("</Role><PUIDHigh>");
        xmlBldr.Append(PuidHigh);
        xmlBldr.Append("</PUIDHigh><PUIDLow>");
        xmlBldr.Append(PuidLow);
        xmlBldr.Append("</PUIDLow><PMN>");
        xmlBldr.Append(PMN);
        xmlBldr.Append("</PMN><ServiceComponentId>");
        xmlBldr.Append(ServiceComponentId);
        xmlBldr.Append("</ServiceComponentId>");
        if(ServiceComponentName != null) 
        {    
            xmlBldr.Append("<ServiceComponentName>");
            xmlBldr.Append(ServiceComponentName);
            xmlBldr.Append("</ServiceComponentName>");
        }        
        xmlBldr.Append("<ServiceInstanceId>");
        xmlBldr.Append(ServiceInstanceId);
        xmlBldr.Append("</ServiceInstanceId><ServiceInstanceFriendlyName>");
        xmlBldr.Append(InstanceFriendlyName);
        xmlBldr.Append("</ServiceInstanceFriendlyName>");
      
        // don't write this
        /*
        xmlBldr.Append("<ServiceInstanceStatus>");
        xmlBldr.Append(InstanceStatusTypes[(int)ServiceInstanceStatus]);
        xmlBldr.Append("</ServiceInstanceStatus>");
        */
      
        if(BaseServiceInstanceId != null) 
        {
            xmlBldr.Append("<BaseServiceInstanceId>");
            xmlBldr.Append(BaseServiceInstanceId);
            xmlBldr.Append("</BaseServiceInstanceId>");
        } 
        else 
        {
            xmlBldr.Append("<BaseServiceInstanceId/>");
        }

        if(Details != null) 
        {
            xmlBldr.Append("<Details>");
            xmlBldr.Append(Details);
            xmlBldr.Append("</Details>");
        } 
        else 
        {
            xmlBldr.Append("<Details/>");
        }

        if(ProvisioningStatus != null) 
        {
            xmlBldr.Append("<ProvisioningStatus>");
            xmlBldr.Append(ProvisioningStatus);
            xmlBldr.Append("</ProvisioningStatus>");
        }
        if(ProvisioningErrorCode != null)
        {
            xmlBldr.Append("<ProvisioningErrorCode>" + ProvisioningErrorCode + "</ProvisioningErrorCode>");
        }

        xmlBldr.Append("</ServiceInstance>");
        xmlBldr.Append("</" + (rootNodeName == null ? "ServiceInstanceSet" : rootNodeName) + ">");
    }
   
    
    // validates required fieds have been set before generating xml.
    // (should this be debug only?)
    public void ValidateFields()
    {
        if (PuidHigh == 0)          throw new Exception("Missing ServiceInstance.PuidHigh");
        
        // @@slamb: it's quite possible this will be 0 and be valid..
        //if (PuidLow == 0)           throw new Exception("Missing ServiceInstance.PuidLow");
        if (PMN == null)            throw new Exception("Missing ServiceInstance.PMN");
        if (Role == null)           throw new Exception("Missing ServiceInstance.Role");
        if ((int)ServiceInstanceStatus < 0 || (int)ServiceInstanceStatus > 5) 
            throw new Exception("Bad Service Instance Status (ServiceInstance.ServiceInstanceStatus)");

        if (ServiceInstanceId == null)              throw new Exception("Missing ServiceInstance.ServiceInstanceId");
        if (InstanceFriendlyName == null)           throw new Exception("Missing ServiceInstance.ServiceInstanceFriendlyName");
        if (ServiceComponentId == null)             throw new Exception("Missing ServiceInstance.ServiceComponentId");        
    }


    
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\Backup3\Batman.cs ===
using System;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Collections;
using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Globalization;
using xonline.common.service;                                     
using xonline.common.tools.console;

namespace xonline.tools.batman 
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class CBatman
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
        ///
        public static EventLog _eventlog   = null;

        //logging
        public static string strPathToLog = "";

        [STAThread]
        static int Main(string[] rawArgs)
        {
            NamedArgParser args;
            DateTime dtStartDate = DateTime.Now;
            DateTime dtEndDate = DateTime.Now;

            try
            {
                _eventlog = new EventLog();
                _eventlog.Source = "BillingAudit";
            
                //
                //  Validate all command line arguments
                //

                string [] tags = {
                                     "report",
                                     "path",
                                     "startdate",
                                     "enddate",
                                     "throttle",
                                     "output",
                                     "?"
                                 };

                args = new NamedArgParser(tags);

                if (!args.Parse(rawArgs))
                {
                    Help();
                    return 1;
                }

                if (args["?"] != null)
                {
                    Help();
                    return 1;
                }


                if (args["path"] == null)
                {
                    Output.WriteLine("You need to specify a /path");
                    Help();
                    return 1;
                }

                if (args["startdate"] == null || args["enddate"] == null)
                {
                    Output.WriteLine("You need to specify a /startdate and /enddate.");
                    Help();
                    return 1;
                }

                if (args["output"] != null)
                {
                    if (args["output"].ToUpper() == "DEBUG")
                        Output.Level = Output.DEBUG;
                    if (args["output"].ToUpper() == "NORMAL")
                        Output.Level = Output.NORMAL;
                    if (args["output"].ToUpper() == "VERBOSE")
                        Output.Level = Output.VERBOSE;
                    if (args["output"].ToUpper() == "SILENT")
                        Output.Level = Output.SILENT;
                }

                //
                //  The stored procedure that these two date values are passed into excludes the parameters
                //  from the range of users returned, it uses less-than and greater-than when selecting.
                //  To get around this problem we're fudging the parameters here so that it functions 
                //  correctly from the end-user's point of view.
                //  Bug 31824.
                //
                dtStartDate = Convert.ToDateTime(args["startdate"]).AddDays(-1);
                dtEndDate = Convert.ToDateTime(args["enddate"]).AddDays(1);

                //
                // Get throttling value, if any.
                //
                strPathToLog = args["path"];
                if (args["throttle"] != null)
                {
                    if (args["throttle"].IndexOf('S') > 0)
                    {
                        args["throttle"] = args["throttle"].Substring(0,
                            args["throttle"].IndexOf('S'));
                        BillingProvider.BillingCallDelay = 1000 / Int32.Parse(args["throttle"]);
                    }
                    else if (args["throttle"].IndexOf('M') > 0)
                    {
                        args["throttle"] = args["throttle"].Substring(0,
                            args["throttle"].IndexOf('M'));
                        BillingProvider.BillingCallDelay = Convert.ToInt32(1000.0 / 
                            (double)(Double.Parse(args["throttle"]) / 60.0));
                    }
                    else
                        BillingProvider.BillingCallDelay = 0;

                    Output.WriteLine("Number of milliseconds between billing calls = " + BillingProvider.BillingCallDelay.ToString());
                }
            }
            catch(Exception e)
            {
                Output.WriteLine("Problem initializing data: " + e.ToString());
                return 2;
            }

            string outStr;

            // run the simplest test
            try 
            {                
                CReport.TestConnection( "Testing 1, 2, 3..!", out outStr );
            } 
            catch (Exception e) 
            {
                Output.WriteLine( "Error: " + e );
                return 1;
            }

            //
            //  Now generate and display the report.
            //

            CReport.GenerateReport(dtStartDate, dtEndDate);
            
            //
            //  Cleanup
            //

            if (Output.log != null)
                Output.log.Close();

            return 0;
        }

        /// <summary>
        /// Utility function to return the directory that this tool is running from.
        /// </summary>
        /// <returns></returns>
        public static string GetProcessDir()
        {
            return Path.GetDirectoryName(System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName);
        }

        /// <summary>
        /// Command line help.
        /// </summary>
        private static void Help()
        {
            Output.WriteLine("Usage: BillingAudit /path:<path> /startdate:<date> /enddate:<date>");
            Output.WriteLine("Date format: MM-DD-YYYY, eg. 05-17-1980");
            Output.WriteLine("Optional commands: /throttle:<##S | ##M> " +
                "/output:<debug, normal, silent, verbose");
        }        
	}


    /// <summary>
    /// Helper class for doing command line output.
    /// </summary>
    public class Output
    {
        public static int Level = NORMAL;
                                        
        public const int SILENT  = 0;
        public const int NORMAL  = 1;
        public const int VERBOSE = 2;
        public const int DEBUG   = 3;

        public static StreamWriter log = null;

        public static void WriteOut(string s)
        {
            if (log == null)
            {
                
                log = new StreamWriter(Path.Combine(CBatman.GetProcessDir(), "Batman.log"));
                log.WriteLine(Environment.CommandLine);
            }

            string [] lines = s.Split('\n');
            foreach (string line in lines)
                log.WriteLine(line);

            log.Flush();

        }
        public static void WriteLine(string s)
        {
            if(Level >= NORMAL)
            {
                Console.WriteLine(s);
            }
            WriteOut(s);
        }
        
        public static void WriteVerbose(string s)
        {
            if(Level >= VERBOSE)
            {
                Console.WriteLine(s);
            }
            WriteOut(s);
        }
        
        public static void WriteDebug(string s)
        {
            if(Level >= DEBUG)
            {
                Console.WriteLine(s);
            }
            WriteOut(s);
        }

        public static void WriteEntryError(string s)
        {
            if (CBatman._eventlog != null)
            {
                int id;
                unchecked
                {
                    id = (int)XEvent.Id.BATMAN_REQUIRED_FIX & 65535;
                }
                CBatman._eventlog.WriteEntry(s, EventLogEntryType.Error, id);
            }
        }
        
        public static void WriteEntryHappy(string s)
        {
            WriteVerbose(s);
            if (CBatman._eventlog != null)
            {
                int id;
                unchecked
                {
                    id = (int)XEvent.Id.BATMAN_REQUIRED_FIX_1 & 65535;
                }
                CBatman._eventlog.WriteEntry(s, EventLogEntryType.Information, id);
            }
        }                

        public static void WriteLineEntryError(string s)
        {
            WriteLine(s);
            WriteEntryError(s);
        }

        public static void WriteDebugEntryError(string s)
        {
            WriteDebug(s);
            WriteEntryError(s);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\Backup3\Report.cs ===
using Billing.PSO;

using Microsoft.Webstore.WstClient;

using System;
using System.IO;
using System.Collections;
using System.Collections.Specialized;
using System.Data;
using System.Data.SqlClient;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Schema;
using System.Text;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.utilities;

namespace xonline.tools.batman
{
    /// <summary>
    /// This class contains all the info we need about subscriptions
    /// This info is collected in GetSubscriptions
    /// </summary>
    public class CUODBSubscription
    {
        public CUODBSubscription()
        {
            flags = 0;
            instance = null;
            offerid = 0;
            puid = 0;
        }
        public int flags;
        public string instance;
        public int instances;
        public int statusid;
        public long offerid;
        public long puid;
        public string guid;
        public string account;
        public long ownerPuid;
        public string payinfo;
        public string componentID;
        public string gamertag;
    }


    /// <summary>
    /// This class contains all the info we want about a user
    /// This info is collected in GetUsers
    /// </summary
    public class CUser
    {
        public CUser()
        {
            puid = 0;
            account = null;
            ownerPuid = 0;
            gamertag = null;
            payinfo = null;
            aUODBSubscriptions = null;
            aBillingSubscriptions = null;
            aBillingPayInfos = null;
            country = 0;
            goodUser = true;
        }

        public long puid;
        public string account;
        public long ownerPuid;
        public ArrayList aUODBSubscriptions;
        public ArrayList aBillingSubscriptions;
        public ArrayList aBillingPayInfos;
        public string gamertag;
        public string payinfo;
        public string locale;
        public byte country;
        public bool goodUser;
    }


    /// <summary>
    /// This class has GenerateReport which takes a log file
    ///   in CBatman.strPathToLogFile and writes an xml report there
    /// This report contains a list of things that Batman should do on an act.
    ///
    /// We have to do 2 things, fix users and fix subscriptions
    ///
    /// For users we have to fix:
    ///     Duplicate Accounts
    ///     Duplicate Subscriptions
    ///     Bad Payment Info
    ///     Duplicate gamertags
    ///
    /// For subscriptions we have to fix:
    ///     Unpurchased subscriptions
    ///     Unprovisioned subscriptions
    /// </summary>
    public class CReport
    {
        private static Report report = null;
        private static ArrayList deletedAccounts = null;
        private static ArrayList deletedSubscriptions = null;
        private static ArrayList updatePayInfo = null;
        private static ArrayList deletePayInfo = null;
        private static ArrayList rContent = null;
        private static ArrayList purchasedSubscriptions = null;
        private static ArrayList updatedSubscriptions = null;
        private static ArrayList provisionedSubscriptions = null;
        private static ArrayList fixedLocales = null;
        private static BillingProvider _billingservice = null;

        //reporting stats
        public static int numUsers = 0;
        public static int numBadUsers = 0;
        public static int numSubscriptions = 0;
        public static int numBadSubscriptions = 0;

        public static int numQueuedAccounts = 0;
        public static int numQueuedSubscriptions = 0;
        public static int numDuplicateAccounts = 0;
        public static int numDuplicateSubscriptions = 0;
        public static int numUnprovisionedSubscriptions = 0;
        public static int numIncompletePurchases = 0;
        public static int numPaymentInstrumentProblems = 0;
        public static int numBadLocales = 0;

        public static int numBillingDeletes = 0;
        public static int numBillingUpdates = 0;
        public static int numUODBUpdates = 0;


        /// <summary>
        /// Static constructor creates the billing service interface.
        /// </summary>
        static CReport()
        {
            _billingservice = new BillingProvider();
        }

        /// <summary>
        /// Pass-through to billing connection test.
        /// </summary>
        /// <param name="sIn"></param>
        /// <param name="sOut"></param>
        public static void TestConnection(string sIn, out string sOut)
        {
            _billingservice.TestConnection(sIn, out sOut);
        }

        /// <summary>
        /// Do all the investigation and report the results.
        /// </summary>
        /// <param name="dtStartDate"></param>
        /// <param name="dtEndDate"></param>
        public static void GenerateReport(DateTime dtStartDate, DateTime dtEndDate)
        {
            try
            {
                //
                //  Initialize all ArrayLists
                //

                report = new Report();
                deletedAccounts = new ArrayList();
                deletedSubscriptions = new ArrayList();
                updatePayInfo = new ArrayList();
                deletePayInfo = new ArrayList();
                purchasedSubscriptions = new ArrayList();
                updatedSubscriptions = new ArrayList();
                provisionedSubscriptions = new ArrayList();
                fixedLocales = new ArrayList();

                GetListOfContent(out rContent);

                //
                //  Checking all users in date range.
                //

                ArrayList rUsers;
                GetListOfUsers(dtStartDate, dtEndDate, out rUsers);

                numUsers = rUsers.Count;
                foreach(CUser user in rUsers)
                {
                    //
                    //  Get list of subscriptions and payinfos for this user
                    //  from the billing service.
                    //

                    GetBillingSubscriptions(user);
                    GetBillingPaymentInfos(user);

                    //
                    //  Now do all checks for this user.
                    //

                    try
                    {
                        Output.WriteVerbose("Checking user: " + user.gamertag);
                        if (user.account.StartsWith("$XBOX!"))
                        {
                            numQueuedAccounts++;
                            continue;
                        }

                        if (!FixAccounts(user))
                            continue;
                        FixUserSubscriptions(user, rContent);
                        FixPaymentInfo(user);
                        FixLocaleInfo(user);
                        if (!user.goodUser)
                            numBadUsers++;
                    }
                    catch(Exception e)
                    {
                        Output.WriteLineEntryError("User: " + user.gamertag + " had an issue talking to billing: " +
                            e.Message);
                        numBadUsers++;
                    }
                }

                //
                //  Checking all subscriptions in date range.
                //

                ArrayList rSubscriptions;
                GetListOfSubscriptions(dtStartDate, dtEndDate, out rSubscriptions);

                numSubscriptions = rSubscriptions.Count;

                foreach(CUODBSubscription subscription in rSubscriptions)
                {
                    if (subscription.instance.Length == 16)
                        FixSubscription(subscription);
                }

                //write out the file - this is the easy part
                report = new Report();
                report.DeleteAccount = new Account[deletedAccounts.Count];
                deletedAccounts.CopyTo(report.DeleteAccount);
                report.DeleteSubscription = new Subscription[deletedSubscriptions.Count];
                deletedSubscriptions.CopyTo(report.DeleteSubscription);
                report.UpdatePaymentInfos = new UpdatePaymentInfo[updatePayInfo.Count];
                updatePayInfo.CopyTo(report.UpdatePaymentInfos);
                report.DeletePaymentInfos = new PaymentInfo[deletePayInfo.Count];
                deletePayInfo.CopyTo(report.DeletePaymentInfos);
                report.LocaleUpdates = new LocaleFix[fixedLocales.Count];
                fixedLocales.CopyTo(report.LocaleUpdates);
                report.PurchaseSubscriptions = new Subscription[purchasedSubscriptions.Count];
                purchasedSubscriptions.CopyTo(report.PurchaseSubscriptions);
                report.UpdateSubscriptions = new Subscription[updatedSubscriptions.Count];
                updatedSubscriptions.CopyTo(report.UpdateSubscriptions);
                report.ProvisionSubscriptions = new Subscription[provisionedSubscriptions.Count];
                provisionedSubscriptions.CopyTo(report.ProvisionSubscriptions);


                XmlSerializer serializer = new XmlSerializer(typeof(Report));
                TextWriter writer = new StreamWriter(CBatman.strPathToLog);
                serializer.Serialize(writer, report);
                writer.Close();

                //set reporting info
                numBadSubscriptions = report.PurchaseSubscriptions.Length +
                    report.ProvisionSubscriptions.Length + report.UpdateSubscriptions.Length;
                numDuplicateAccounts = report.DeleteAccount.Length;
                numDuplicateSubscriptions = report.DeleteSubscription.Length;
                numIncompletePurchases = report.PurchaseSubscriptions.Length +
                    report.UpdateSubscriptions.Length;
                numUnprovisionedSubscriptions  = report.ProvisionSubscriptions.Length;
                numPaymentInstrumentProblems = report.UpdatePaymentInfos.Length +
                    report.DeletePaymentInfos.Length;
                numBadLocales = report.LocaleUpdates.Length;

                PrintReport();
            }
            catch(Exception e)
            {
                Output.WriteLine(e.Message);
            }
        }

        /// <summary>
        /// GetListOfUsers
        ///
        /// Gets every user inserted or modified during the specified date range.
        /// </summary>
        /// <param name="dtStartDate"></param>
        /// <param name="dtEndDate"></param>
        /// <param name="rUsers">Returned array of CUser objects.</param>
        private static void GetListOfUsers(DateTime dtStartDate, DateTime dtEndDate, out ArrayList rUsers)
        {
            WstConnection conn = null;
            WstCommand cmd = null;
            rUsers = new ArrayList();

            try
            {
                conn = new WstConnection(ConfigUtil.UodbWebstoreApp);
                conn.Open();

                cmd = conn.CreateCommand();

                cmd.WstCommandType = WstCommandType.ReadThenWrite;
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_batman_get_users_by_date";
                cmd.PartitionType = WstPartitionType.Physical;
                cmd.Parameters.Add("@dt_start_date", dtStartDate);
                cmd.Parameters.Add("@dt_end_date", dtEndDate);

                for(cmd.Partition = 0; cmd.Partition < conn.SqlPartitions.Count; ++cmd.Partition)
                {
                    WstDataReader reader = null;

                    try
                    {
                        reader = cmd.ExecuteReader();
                        long last_puid = -1;
                        CUser user = null;

                        while (reader.Read())
                        {
                            //there are a bunch of subscriptions here that belong to these users
                            if (reader.GetInt64(0) != last_puid)
                            {
                                //add the user to the users Array
                                user = new CUser();
                                user.puid = reader.GetInt64(0);
                                user.ownerPuid = reader.GetInt64(1);
                                user.gamertag = reader.GetString(2);
                                user.account = reader.GetString(3);
                                user.payinfo = reader.GetString(4);
                                user.country = reader.GetByte(8);

                                last_puid = user.puid;
                                rUsers.Add(user);
                            }

                            //this user has subscriptions
                            CUODBSubscription subscription = new CUODBSubscription();
                            subscription.instance = reader.GetString(5);
                            subscription.offerid = reader.GetInt64(6);
                            subscription.statusid = reader.GetInt32(7);
                            subscription.flags = reader.GetInt32(9);

                            user.aUODBSubscriptions.Add(subscription);
                        }
                    }
                    catch(Exception)
                    {
                        continue;
                    }
                    finally
                    {
                        if(reader != null)
                        {
                            reader.Close();
                            reader = null;
                        }
                    }
                }
            }
            finally
            {
                if(conn != null)
                {
                    conn.Close();
                    conn = null;
                }
            }
        }

        /// <summary>
        /// GetListOfSubscriptions
        ///
        /// Returns all subscriptions for users whose account has changed
        /// in the specified date range.
        /// </summary>
        /// <param name="rSubscriptions">Returned array of CUODBSubscription objects.</param>
        private static void GetListOfSubscriptions(DateTime dtStartDate, DateTime dtEndDate, out ArrayList rSubscriptions)
        {
            //this iterates through UODB (by dtStartDate and dtEndDate) and gets every subscription
            rSubscriptions = new ArrayList();

            WstConnection conn = null;
            WstCommand cmd = null;

            try
            {
                conn = new WstConnection();
                conn.Open();

                cmd = conn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_batman_get_subscriptions_by_date";
                cmd.WstCommandType = WstCommandType.ReadThenWrite;
                cmd.PartitionType = WstPartitionType.Physical;
                cmd.Parameters.Add("@dt_start_date", dtStartDate);
                cmd.Parameters.Add("@dt_end_date", dtEndDate);

                for (int iCurDb = 0; iCurDb < conn.SqlPartitions.Count; ++iCurDb)
                {
                    cmd.Partition = iCurDb;

                    WstDataReader reader = null;

                    try
                    {
                        reader = cmd.ExecuteReader();

                        while (reader.Read())
                        {
                            //each subscription
                            CUODBSubscription subscription = new CUODBSubscription();
                            subscription.puid = reader.GetInt64(0);
                            subscription.instances = reader.GetInt32(1);
                            subscription.instance = reader.GetString(2);
                            subscription.offerid = reader.GetInt64(3);
                            subscription.statusid = reader.GetInt32(4);
                            subscription.flags = reader.GetInt32(5);
                            subscription.ownerPuid = reader.GetInt64(6);
                            subscription.account = reader.GetString(7);
                            subscription.payinfo = reader.GetString(8);
                            subscription.componentID = reader.GetString(9);
                            subscription.gamertag = reader.GetString(10);

                            if (subscription.instance != "xkdctest")
                                rSubscriptions.Add(subscription);
                        }
                    }
                    catch(Exception)
                    {
                        continue;
                    }
                    finally
                    {
                        if(reader != null)
                        {
                            reader.Close();
                            reader = null;
                        }
                    }
                }
            }
            finally
            {
                if(conn != null)
                {
                    conn.Close();
                    conn = null;
                }
            }
        }

        /// <summary>
        /// GetListOfContent
        ///
        /// Retrieves the complete list of all paid content from UODB.
        /// </summary>
        /// <param name="rContent">ArrayList containing BOIDs</param>
        private static void GetListOfContent(out ArrayList rContent)
        {
            rContent = new ArrayList();

            WstConnection conn = null;
            WstCommand cmd = null;
            WstDataReader reader = null;

            try
            {
                conn = new WstConnection(ConfigUtil.UodbWebstoreApp);
                conn.Open();

                cmd = conn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_batman_get_paid_content";
                cmd.WstCommandType = WstCommandType.ReadThenWrite;
                cmd.PartitionType = WstPartitionType.Logical;
                cmd.Partition = WstCommand.AnyPartition;

                reader = cmd.ExecuteReader();

                while (reader.Read())
                {
                    //each content - just BOID
                    string boid = reader.GetString(0);

                    rContent.Add(boid);
                }
            }
            finally
            {
                if(reader != null)
                {
                    reader.Close();
                    reader = null;
                }

                if(conn != null)
                {
                    conn.Close();
                    conn = null;
                }
            }
        }

        /// <summary>
        /// FixAccounts
        /// </summary>
        /// <param name="user"></param>
        /// <returns></returns>
        private static bool FixAccounts(CUser user)
        {
            //use billing service to get a list of accounts,
            //then cancel the accounts we don't know about
            ArrayList rAccounts;
            ArrayList rActiveAccounts = new ArrayList();
            GetBillingAccounts(user, out rAccounts);

            bool found = false;
            foreach (string account in rAccounts)
            {

                if (account == user.account)
                {
                    found = true;
                }
                else
                {
                    CUser tempUser = new CUser();
                    tempUser.puid = user.puid;
                    tempUser.account = account;

                    GetBillingSubscriptions(tempUser);

                    foreach(SubscriptionInfoSetSubscriptionInfo sub in tempUser.aBillingSubscriptions)
                    {
                        if (sub.SubscriptionStatusInfo.SubscriptionStatus == "ENABLED")
                        {
                            rActiveAccounts.Add(account);
                            break;
                        }
                    }
                }
            }

            if (!found)
            {
                //big error, we should have their account
                Output.WriteLineEntryError("No matching accounts for user " + user.gamertag +
                    ". Has " + rActiveAccounts.Count.ToString() + " bad accounts.");
                numBadUsers++;
                user.goodUser = false;
                return false;
            }

            //Output.WriteLine("User " + user.gamertag + " has accounts!!");
            if (rActiveAccounts.Count > 0)
            {
                Output.WriteEntryHappy("User " + user.gamertag + " has " +
                    rActiveAccounts.Count.ToString() + " bad accounts.  " +
                    "They will be marked for cancellation in the report.");

                user.goodUser = false;
                foreach (string account in rActiveAccounts)
                {
                    DeleteAccount(user, account);
                }
            }

            return true;

        }

        /// <summary>
        /// DeleteAccount
        ///
        /// Adds the specified user account to the list of accounts flagged
        /// for deletion.  These accounts don't actually get deleted by this
        /// tool.  All such accounts are flagged in the output report, which
        /// we pass to the billing team to actually perform the deletion.
        /// </summary>
        /// <param name="user"></param>
        /// <param name="account"></param>
        private static void DeleteAccount(CUser user, string account)
        {
            Account acct = new Account();
            acct.AccountID = account;
            acct.Puid = user.ownerPuid;

            deletedAccounts.Add(acct);

            Output.WriteEntryHappy("Marking account " + account +
                " for cancellation on user " + user.gamertag);
        }

        /// <summary>
        /// FixUserSubscriptions
        /// </summary>
        /// <param name="user"></param>
        /// <param name="rContent"></param>
        private static void FixUserSubscriptions(CUser user, ArrayList rContent)
        {
            int badSubs = 0;

            //
            //  foreach sub in UODB, see if it is in billing
            //

            foreach(CUODBSubscription userSub in user.aUODBSubscriptions)
            {
                //see if the user has unpurchased subscriptions
                if (((int)(userSub.flags) & (int)0x4) == (int)0x4)
                    return;

                //don't check queued subscriptions
                if (userSub.instance.StartsWith("$XBOX"))
                    continue;

                Output.WriteVerbose("Checking for status mismatch on id: " + userSub.statusid);
                bool found = false;
                foreach(SubscriptionInfoSetSubscriptionInfo sub in user.aBillingSubscriptions)
                {
                    //we just see if the sub is in billing, not if it is cancelled or not
                    //if (sub.SubscriptionStatusInfo.SubscriptionStatus.Trim() != "ENABLED")
                    //continue;

                    //see if the user has this sub listed in billing
                    for (int i = 0; i < sub.ServiceInstanceSet.Length; i++)
                    {
                        if (userSub.instance == sub.ServiceInstanceSet[i].ServiceInstanceId)
                        {
                            found = true;
                            if ( (userSub.statusid == 1 && sub.SubscriptionStatusInfo.SubscriptionStatus.Trim() != "ENABLED") ||
                                 (userSub.statusid != 1 && sub.SubscriptionStatusInfo.SubscriptionStatus.Trim() == "ENABLED"))
                            {
                                Output.WriteLineEntryError("User " + user.gamertag + " has subscription: " + userSub.instance +
                                    " in UODB and billing, but there is an enabled/disabled mismatch");
                                badSubs++;
                            }

                            break;
                        }
                    }

                    if(found)
                        break;
                }

                if (!found)
                {
                    Output.WriteLineEntryError("User " + user.gamertag + " has subscription: " + userSub.instance +
                        " in UODB but not in billing.");
                    badSubs++;
                }
            }

            //
            //  For each subscription in billing see if it's in UODB
            //

            foreach (SubscriptionInfoSetSubscriptionInfo sub in user.aBillingSubscriptions)
            {
                bool found = false;

                //skip canceled content
                if (sub.SubscriptionStatusInfo.SubscriptionStatus.Trim() != "ENABLED")
                {
                    continue;
                }

                //skip content
                if (rContent.Contains(sub.OfferingGUID))
                {
                    continue;
                }

                if (sub.ServiceInstanceSet.Length == 0)
                {

                    Output.WriteLineEntryError("User " + user.gamertag + " has unknown subscription " +
                        sub.SubscriptionId + " which has no service instances in billing");

                    continue;
                }

                foreach(CUODBSubscription userSub in user.aUODBSubscriptions)
                {

                    //
                    //see if the user has this sub listed in UODB
                    //

                    for (int i = 0; i < sub.ServiceInstanceSet.Length; i++)
                    {
                        if (userSub.instance == sub.ServiceInstanceSet[i].ServiceInstanceId)
                        {
                            found = true;
                            break;
                        }
                    }

                    if(found)
                        break;
                }


                //billing has the sub but we don't
                //delete the sub
                if(!found)
                {
                    badSubs++;
                    DeleteSub(user, sub);
                }
            }

            if (badSubs > 0)
            {
                user.goodUser = false;
                Output.WriteEntryHappy("User " + user.gamertag + " has " +
                    badSubs.ToString() + " bad subscriptions.  " +
                    "They will be marked for cancellation in the report.");
            }
        }

        /// <summary>
        /// DeleteSub
        ///
        /// Mark a user's subscription for cancellation.
        /// </summary>
        /// <param name="user"></param>
        /// <param name="sub"></param>
        public static void DeleteSub(CUser user, SubscriptionInfoSetSubscriptionInfo sub)
        {
            Subscription xmlSub = new Subscription();
            xmlSub.GUID = sub.OfferingGUID;
            xmlSub.Offerid = 0;
            xmlSub.Account = user.account;
            xmlSub.UserPuid = user.puid;
            xmlSub.OwnerPuid = user.ownerPuid;
            xmlSub.Instance = sub.ServiceInstanceSet[0].ServiceInstanceId;

            deletedSubscriptions.Add(xmlSub);

            Output.WriteEntryHappy("Marking subscription " + sub.OfferingGUID +
                " for cancellation on user " + user.gamertag);
        }

        /// <summary>
        /// FindPayInfoForInstance
        ///
        /// Return the user's payment info, if any, matching the subscription instance
        /// ID passed in.
        /// </summary>
        /// <param name="user"></param>
        /// <param name="instanceID"></param>
        /// <returns></returns>
        private static string FindPayInfoForInstance(CUser user, string instanceID)
        {
            foreach(SubscriptionInfoSetSubscriptionInfo sub in user.aBillingSubscriptions)
            {
                //see if the user has this sub listed in billing
                for (int i = 0; i < sub.ServiceInstanceSet.Length; i++)
                {
                    if (instanceID == sub.ServiceInstanceSet[i].ServiceInstanceId)
                    {
                        foreach(string pis in user.aBillingPayInfos)
                        {
                            if (pis == sub.PaymentInstrumentId)
                            {
                                UpdatePayInfo(user, sub.PaymentInstrumentId);
                                return sub.PaymentInstrumentId;
                            }
                        }
                    }
                }
            }

            return null;
        }

        /// <summary>
        /// FixPaymentInfo
        ///
        /// If there is only one payment info, set UODB = billing.
        /// If there are multiple payment infos, delete all but the
        /// one in UODB.
        /// If the user has no payment info in billing we take no action.
        /// </summary>
        /// <param name="user"></param>
        public static void FixPaymentInfo(CUser user)
        {
            //
            //  Is there one payment info?
            //

            if (user.aBillingPayInfos.Count == 1)
            {
                string pi = (string)(user.aBillingPayInfos[0]);
                if (user.payinfo != pi)
                {
                    //  Payment infos don't match, need to update UODB
                    user.goodUser = false;
                    UpdatePayInfo(user, pi);
                }
            }
            else if (user.aBillingPayInfos.Count > 1)
            {
                //
                //  User has multiple payment infos in billing.  Many cases to consider here.
                //

                Output.WriteVerbose("User " + user.gamertag + " has multiple payment infos in billing.");
                user.goodUser = false;

                //
                //  If the payment info in UODB is not one of the payment infos returned
                //  from billing then we need to update UODB with the 'best' payment info
                //  retrieved from billing.
                //

                if (!user.aBillingPayInfos.Contains(user.payinfo))
                {
                    Output.WriteVerbose("There is no matching payinfo in UODB, attempting to find one.");
                    string base_instance = "";
                    foreach(CUODBSubscription sub in user.aUODBSubscriptions)
                    {
                        if (sub.offerid.ToString("X").ToUpper().StartsWith("FFFE0000"))
                            base_instance = sub.instance;
                    }

                    if (base_instance == "")
                    {
                        Output.WriteLineEntryError("User " + user.gamertag +
                            " has multiple payinfos, but none are equal to" +
                            " what we have in UODB and there are no base subscriptions.");
                    }
                    else
                    {
                        //
                        //  Found a base subscription in UODB for the user and
                        //  got it's instance id in base_instance.  Now look
                        //  through all subscriptions for this user and see if
                        //  any of them have a matching instance id.  If so, use
                        //  the payment info associated with that subscription.
                        //

                        string payInfo = FindPayInfoForInstance(user, base_instance);


                        if(payInfo == null)
                        {
                            //didn't find a matching subscription
                            Output.WriteLineEntryError("User " + user.gamertag +
                                " has multiple payinfos, but none are equal to" +
                                " what we have in UODB and we can't match his base subscription " +
                                base_instance + " to any subscription in billing.");
                        }
                        else
                        {
                            foreach(string pi in user.aBillingPayInfos)
                            {
                                //delete the PIs we aren't updating
                                if (pi != payInfo)
                                {
                                    DeletePayInfo(user, pi);
                                }
                            }
                        }
                    }
                }
                else
                {
                    //
                    //  In this case, we mark all payment infos in billing that don't
                    //  match what we have in UODB for deletion.
                    //

                    Output.WriteVerbose("Marking all unnecessary PIs for deletion.");
                    foreach(string pi in user.aBillingPayInfos)
                    {
                        if (pi != user.payinfo)
                        {
                            DeletePayInfo(user, pi);
                        }
                    }
                }
            } //more than 1 payinfo
            else
            {
                //0 payinfos
                user.goodUser = false;
                Output.WriteLineEntryError("User " + user.gamertag +
                    " has no payinfos.");
            }
        }

        /// <summary>
        /// UpdatePayInfo
        /// </summary>
        /// <param name="user"></param>
        /// <param name="pi"></param>
        public static void UpdatePayInfo(CUser user, string pi)
        {
            UpdatePaymentInfo upi = new UpdatePaymentInfo();
            upi.AccountID = user.account;
            upi.CorrectPaymentInfoID = pi;
            upi.UserPuid = user.puid;

            updatePayInfo.Add(upi);

            Output.WriteEntryHappy("Setting payinfo id to " + pi +
                " for user " + user.gamertag);
        }

        /// <summary>
        /// DeletePayInfo
        /// </summary>
        /// <param name="user"></param>
        /// <param name="pi"></param>
        public static void DeletePayInfo(CUser user, string pi)
        {
            PaymentInfo dpi = new PaymentInfo();
            dpi.AccountID = user.account;
            dpi.PaymentInfoID = pi;
            dpi.UserPuid = user.ownerPuid;

            deletePayInfo.Add(dpi);

            Output.WriteEntryHappy("Marking extra payinfo " +
                pi + " for deletion from user " + user.gamertag);
        }

        /// <summary>
        /// FixSubscription
        /// </summary>
        /// <param name="sub"></param>
        public static void FixSubscription(CUODBSubscription sub)
        {
            if ((sub.flags & 0x4) == 0x4) // Subscription is marked as CANCELLED in UODB
            {
                SubscriptionStatusInfo sii;
                if (sub.instance.StartsWith("$XBOX"))
                    PurchaseSubscription(sub);
                else
                {
                    if (!GetBillingSubscriptionInfo(sub, out sii))
                        return;
                    if (sii.SubscriptionStatus == "ENABLED")
                        SetUODBPurchase(sub);
                    else
                        PurchaseSubscription(sub);
                }
            }
            else if ((sub.flags & 0x1) == 0x1) // Subscription is marked as ENABLED in UODB
            {
                if (sub.instance.StartsWith("$XBOX") || sub.account.StartsWith("$XBOX"))
                    numQueuedSubscriptions++;
                else
                    ProvisionSubscription(sub);
            }
        }

        /// <summary>
        /// SetUODBPurchase
        /// </summary>
        /// <param name="sub"></param>
        public static void SetUODBPurchase(CUODBSubscription sub)
        {
            Subscription xmlSub = new Subscription();

            xmlSub.Account = sub.account;
            xmlSub.Offerid = sub.offerid;
            xmlSub.Instance = sub.instance;
            xmlSub.UserPuid = sub.puid;

            updatedSubscriptions.Add(xmlSub);

            Output.WriteEntryHappy("Setting UODB as purchased for " + sub.account +
                " for user " + sub.puid + " with offerid " + sub.offerid);
        }

        /// <summary>
        /// PurchaseSubscription
        /// </summary>
        /// <param name="sub"></param>
        public static void PurchaseSubscription(CUODBSubscription sub)
        {
           if (!sub.instance.StartsWith("$XBOX"))
               Output.WriteLineEntryError("Purchasing subscription for an instance with no $XBOX: " + sub.instance);

            Subscription xmlSub = new Subscription();

            xmlSub.Account = sub.account;
            xmlSub.Offerid = sub.offerid;
            xmlSub.Instance = sub.instance;
            xmlSub.UserPuid = sub.puid;
            xmlSub.OwnerPuid = sub.ownerPuid;
            xmlSub.Component = sub.componentID;
            xmlSub.GUID = sub.guid;
            xmlSub.GamerTag = sub.gamertag;
            xmlSub.PayInfo = sub.payinfo;

            purchasedSubscriptions.Add(xmlSub);

            Output.WriteEntryHappy("Purchasing subscription " + sub.account +
                " for user " + sub.puid + " with offerid " + sub.offerid);
        }

        /// <summary>
        /// ProvisionSubscription
        /// </summary>
        /// <param name="sub"></param>
        public static void ProvisionSubscription(CUODBSubscription sub)
        {
            Subscription xmlSub = new Subscription();

            xmlSub.Account = sub.account;
            xmlSub.Offerid = sub.offerid;
            xmlSub.Instance = sub.instance;
            xmlSub.UserPuid = sub.puid;
            xmlSub.OwnerPuid = sub.ownerPuid;
            xmlSub.Component = sub.componentID;
            xmlSub.GamerTag = sub.gamertag;

            provisionedSubscriptions.Add(xmlSub);

            Output.WriteEntryHappy("Provisioning subscription " + sub.account +
                " for user " + sub.puid + " with offerid " + sub.offerid);
        }

        /// <summary>
        /// GetBillingAccounts
        /// </summary>
        /// <param name="user"></param>
        /// <param name="rAccounts"></param>
        /// <returns></returns>
        public static bool GetBillingAccounts(CUser user, out ArrayList rAccounts)
        {
            /*
                [in]  LONG lDelegateIdHigh,
                [in]  LONG lDelegateIdLow,
                [in]  LONG lSearchPUIDHigh,
                [in]  LONG lSearchPUIDLow,
                [in]  VARIANT_BOOL fFullData,
                [in]  LONG lMax,
                [out] BSTR *pbstrResultXML,
                [out] LONG *pfMoreRows,
                [out] LONG *plAccountInfoCount,
                [out] BSTR *pbstrAccountInfoSetXML
            */
            int high = (int)(user.ownerPuid >> 32);
            int low  = (int)(user.ownerPuid & 0xFFFFFFFF);
            string result = "";
            int moreRows = 0;
            int numAccounts = 0;
            string accountSet = "";

            BillingProvider.Throttle();
            _billingservice.GetAccountIdFromAdminPUID(
                    0
                ,   0 //delegates can be 0
                ,   high
                ,   low //the OWNER puid
                ,   true //we only need account string
                ,   25 //the max of the max results
                ,   out result //if there are errors we will know here
                ,   out moreRows //0 if there were < than 25.  1 if we need to call again
                ,   out numAccounts //how many accounts we retrieved
                ,   out accountSet //all the info about the accounts
                );

            accountSet = "<?xml version=\"1.0\" encoding=\"UTF-16\" ?>\n" + accountSet;
            //Output.WriteLine("Account set: " + accountSet);
            //Output.WriteLine("Error set: " + result);
            //check result for error

            //check moreRows for excessive number of accounts
            if (moreRows == 1)
            {
                Output.WriteLineEntryError("User " + user.gamertag + " has more than 25 accounts in billing." +
                    " Please fix manually.");
            }
            //add each account from accountSet to rAccounts
            rAccounts = new ArrayList();
            XmlSerializer serializer = new XmlSerializer(typeof(AccountInfoSet));
            AccountInfoSet aiSet = new AccountInfoSet();

            byte[] xmlData = new byte[accountSet.Length * 4];
            UnicodeEncoding aEnc = new  UnicodeEncoding();
            aEnc.GetBytes(accountSet, 0, accountSet.Length, xmlData, 0);

            MemoryStream ms = new MemoryStream(xmlData);
            aiSet = (AccountInfoSet)serializer.Deserialize(ms);


            if (aiSet.AccountInfo == null)
            {
                //Output.WriteLineEntryError("User " + user.gamertag + " has no accounts!");
                return false;
            }


            foreach(AccountInfoSetAccountInfo aii in aiSet.AccountInfo)
            {
                rAccounts.Add(aii.AccountId);
            }

            return true;
        }

        /// <summary>
        /// GetBillingSubscriptionInfostring
        /// </summary>
        /// <param name="sub"></param>
        /// <returns></returns>
        public static string GetBillingSubscriptionInfoString(CUODBSubscription sub)
        {
            string result = "";

            int high = (int)(sub.ownerPuid >> 32);
            int low  = (int)(sub.ownerPuid & 0xFFFFFFFF);

            string xmlset = "";

            Output.WriteDebug("instance: " + sub.instance + "\nowner puid: " + sub.ownerPuid.ToString());

            try
            {
                BillingProvider.Throttle();
                _billingservice.GetSubscriptionStatus(
                        0
                    ,   0 //delegate
                    ,   high
                    ,   low //owner puid
                    ,   sub.instance //the billing instance of this purchase
                    ,   out result //errors go here
                    ,   out xmlset //the actual subscription info
                    );
            }
            catch (System.Web.Services.Protocols.SoapException se)
            {
                //the subscription doesn't exist in billing
                Output.WriteLineEntryError("Subscription instance " + sub.instance + " does not exist in billing." +
                    "\nUser: " + sub.ownerPuid.ToString() +
                    "\nInstance: " + sub.instance +
                    "\nError: " + result +
                    "\nSoapException: " + se.Message);
                return "";
            }
            return xmlset;
        }

        /// <summary>
        /// GetBillingSubscriptionInfo
        ///
        /// Parses the xml subscription details blob contained in the input param
        /// and produces a SubscriptionStatusInfo object.
        /// </summary>
        /// <param name="sub"></param>
        /// <param name="sii"></param>
        /// <returns></returns>
        private static bool GetBillingSubscriptionInfo(CUODBSubscription sub, out SubscriptionStatusInfo sii)
        {
            try
            {
                string xmlset = GetBillingSubscriptionInfoString(sub);

                sii = null;
                if (xmlset.Length == 0)
                    return false;

                //check result
                xmlset = "<?xml version=\"1.0\" encoding=\"UTF-16\" ?>\n" + xmlset;

                //Output.WriteLine(xmlset);
                //put xmlset into rSubs
                XmlSerializer serializer = new XmlSerializer(typeof(SubscriptionStatusInfo));

                byte[] xmlData = new byte[xmlset.Length * 4];
                UnicodeEncoding aEnc = new  UnicodeEncoding();
                aEnc.GetBytes(xmlset, 0, xmlset.Length, xmlData, 0);

                MemoryStream ms = new MemoryStream(xmlData);
                sii = (SubscriptionStatusInfo)serializer.Deserialize(ms);

            }
            catch(Exception e)
            {
                sii = null;
                Output.WriteDebugEntryError("FAIL getting billing info: " + e.Message);
                return false;
            }
            return true;
        }

        /// <summary>
        /// GetBillingSingleSubscription
        ///
        /// Calls GetSubscriptions API to retrieve a single subscription
        /// from the billing service.
        /// </summary>
        /// <param name="ownerPuid"></param>
        /// <param name="sub"></param>
        /// <returns></returns>
        private static string GetBillingSingleSubscription(long ownerPuid, string sub)
        {
            /*
                [in]  LONG lDelegateIdHigh,
                [in]  LONG lDelegateIdLow,
                [in]  LONG lRequesterIdHigh,
                [in]  LONG lRequesterIdLow,
                [in]  BSTR bstrObjectId,
                [out] BSTR *pbstrResultXML,
                [out] LONG *lpSubscriptionInfoCount,
                [out] BSTR *pbstrSubscriptionInfoSetXML
            */

            string result = "";

            int high = (int)(ownerPuid >> 32);
            int low  = (int)(ownerPuid & 0xFFFFFFFF);

            int count = 0;
            string xmlset = "";

            BillingProvider.Throttle();
            _billingservice.GetSubscriptions(
                    0
                ,   0 //delegate
                ,   high
                ,   low //owner puid
                ,   sub
                ,   out result //errors go here
                ,   out count //how many subscriptions
                ,   out xmlset //the actual subscription info
                );

            return xmlset;
        }

        /// <summary>
        /// GetBillingSubscriptions
        ///
        /// Retrieve all subscriptions for the specified user from the billing service.
        /// </summary>
        /// <param name="user"></param>
        /// <param name="rSubs"></param>
        private static void GetBillingSubscriptions(CUser user)
        {
            //
            //  Have we already retrieved subscriptions for this user?
            //  Don't do it again.
            //

            if(user.aBillingSubscriptions != null)
                return;

            //
            //  Do we have a valid user?
            //

            if(user.ownerPuid == 0)
                return;

            user.aBillingSubscriptions = new ArrayList();

            /*
                [in]  LONG lDelegateIdHigh,
                [in]  LONG lDelegateIdLow,
                [in]  LONG lRequesterIdHigh,
                [in]  LONG lRequesterIdLow,
                [in]  BSTR bstrObjectId,
                [out] BSTR *pbstrResultXML,
                [out] LONG *lpSubscriptionInfoCount,
                [out] BSTR *pbstrSubscriptionInfoSetXML
            */

            string result = "";

            int high = (int)(user.ownerPuid >> 32);
            int low  = (int)(user.ownerPuid & 0xFFFFFFFF);

            int count = 0;
            string xmlset = "";

            BillingProvider.Throttle();
            _billingservice.GetSubscriptions(
                    0
                ,   0 //delegate
                ,   high
                ,   low //owner puid
                ,   user.account
                ,   out result //errors go here
                ,   out count //how many subscriptions
                ,   out xmlset //the actual subscription info
                );

            //xmlset = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n" + xmlset;
            //xmlset = xmlset.Replace("UTF-16", "UTF-8");
            //check result
            if (count == 0)
                return;

            //put xmlset into rSubs
            XmlSerializer serializer = new XmlSerializer(typeof(SubscriptionInfoSet));
            SubscriptionInfoSet siSet = new SubscriptionInfoSet();

            byte[] xmlData = new byte[xmlset.Length * 4];
            UnicodeEncoding aEnc = new UnicodeEncoding();
            //UnicodeEncoding aEnc = new  UnicodeEncoding();
            aEnc.GetBytes(xmlset, 0, xmlset.Length, xmlData, 0);

            MemoryStream ms = new MemoryStream(xmlData);
            siSet = (SubscriptionInfoSet)serializer.Deserialize(ms);

            foreach(SubscriptionInfoSetSubscriptionInfo sii in siSet.SubscriptionInfo)
            {
                user.aBillingSubscriptions.Add(sii);
            }
        }

        /// <summary>
        /// GetBillingPaymentInfos
        ///
        /// Retrieves all payment infos for the specified user from the billing service.
        /// </summary>
        /// <param name="user"></param>
        /// <param name="rPaymentInfos"></param>
        private static void GetBillingPaymentInfos(CUser user)
        {
            if(user.aBillingPayInfos != null)
                return;

            user.aBillingPayInfos = new ArrayList();

            /*
                [in]  LONG lDelegateIdHigh,
                [in]  LONG lDelegateIdLow,
                [in]  LONG lRequesterIdHigh,
                [in]  LONG lRequestedIdLow,
                [in]  BSTR bstrObjectId,
                [out] BSTR *pbstrResultXML,
                [out] LONG *plPaymentInstrumentInfoCount,
                [out] BSTR *pbstrPaymentInstrumentInfoSetXML
            */

            string result = "";

            int high = (int)(user.ownerPuid >> 32);
            int low  = (int)(user.ownerPuid & 0xFFFFFFFF);

            int count = 0;
            string xmlset = "";

            BillingProvider.Throttle();
            _billingservice.GetPaymentInstruments(
                    0
                ,   0
                ,   high
                ,   low //owner puid
                ,   user.account
                ,   out result //errors go here
                ,   out count //how many PIs
                ,   out xmlset //the actual PI info
                );

            xmlset = "<?xml version=\"1.0\" encoding=\"UTF-16\" ?>\n" + xmlset;
            //check result
            //as it turns out an error will be thrown if there is a problem

            //put xmlset into rPaymentInfos
            XmlSerializer serializer = new XmlSerializer(typeof(PaymentInstrumentInfoSet));
            PaymentInstrumentInfoSet piSet = new PaymentInstrumentInfoSet();

            byte[] xmlData = new byte[xmlset.Length * 4];
            UnicodeEncoding aEnc = new  UnicodeEncoding();
            aEnc.GetBytes(xmlset, 0, xmlset.Length, xmlData, 0);

            MemoryStream ms = new MemoryStream(xmlData);
            piSet = (PaymentInstrumentInfoSet)serializer.Deserialize(ms);

            if (piSet.PaymentInstrumentInfo == null)
            {
                //Output.WriteLineEntryError("User " + user.gamertag + " has no payment infos");
                return;
            }
            foreach(PaymentInstrumentInfoSetPaymentInstrumentInfo pii in piSet.PaymentInstrumentInfo)
            {
                user.aBillingPayInfos.Add(pii.PaymentInstrumentId);
            }
        }

        private static void FixLocaleInfo(CUser user)
        {
            try
            {
                string locale;
                string bcountry;
                GetBillingLocaleInfo(user, out locale, out bcountry);

                locale = locale.Trim();

                if (locale.Length == 0)
                    return;

                //locale should be in the form en-US
                if (locale.IndexOf("-") != 2 || locale.Length != 5)
                    throw new Exception("Bad locale: " + locale);

                string [] parts = locale.Split('-');
                if (parts.Length != 2)
                    throw new Exception("Bad locale: " + locale);

                string language = parts[0];
                string country = parts[1];

                if (country == bcountry) //they have the same billing country as locale country
                    return;

                uint lang = 1;
                do
                {
                    //loop until we find the right language or run out of languages to check
                    Setting setting = (Setting) Enum.Parse(typeof(Setting), "locale_language" + lang);
                    string loc = Config.GetSetting(setting).Trim();
                    
                    if (loc.Length == 0)
                    {
                        lang = 0;
                        break;
                    }

                    if (loc.Length < 2)
                        throw new Exception("Bad locale for language " + lang + ": " + loc);

                    loc = loc.Substring(0, 2);
                    if (loc.ToUpper() == language.ToUpper())
                        break;

                    lang++;
                } while (true);

                if (lang == 0)
                    throw new Exception("Language " + language + " in locale " + locale + " not supported.");

                if (Locale.BuildValidLocale(lang, bcountry) != locale)
                {
                    user.goodUser = false;
                    SetLocale(user, Locale.BuildValidLocale(lang, bcountry));
                }
            }
            catch(Exception e)
            {
                Output.WriteLineEntryError("Locale error for " + user.gamertag + ": " + e.Message);
            }
        }

        private static void SetLocale(CUser user, string locale)
        {
            LocaleFix fix = new LocaleFix();

            fix.AccountID = user.account;
            fix.UserPuid = user.ownerPuid;
            fix.CorrectLocale = locale;

            fixedLocales.Add(fix);

            Output.WriteEntryHappy("Changing locale on user " + user.gamertag +
                " to " + locale);
        }

        private static void GetBillingLocaleInfo(CUser user, out string locale, out string country)
        {
            //get the local of the user
            string error = "", info = "";

            int high = (int)(user.ownerPuid >> 32);
            int low  = (int)(user.ownerPuid & 0xFFFFFFFF);

            BillingProvider.Throttle();
            _billingservice.GetAccountInfo(
                 0
                ,0
                ,high
                ,low
                ,user.account
                ,out error
                ,out info
                );

            //serialize this stuff
            XmlSerializer serializer = new XmlSerializer(typeof(AccountInfo));
            AccountInfo aiSet = new AccountInfo();

            info = "<?xml version=\"1.0\" encoding=\"UTF-16\" ?>\n" + info;
            //Output.WriteDebug("AccountInfo: " + info);

            byte[] xmlData = new byte[info.Length * 4];
            UnicodeEncoding aEnc = new  UnicodeEncoding();
            aEnc.GetBytes(info, 0, info.Length, xmlData, 0);

            MemoryStream ms = new MemoryStream(xmlData);
            aiSet = (AccountInfo)serializer.Deserialize(ms);

            if (aiSet.Locale == "")
            {
                Output.WriteLineEntryError("User " + user.gamertag + " has no locale!");
                locale = "";
            }

            locale = aiSet.Locale;
            country = aiSet.AddressInfoSet.AddressInfo.CountryCode;

            if (country.ToUpper() != CountryDictionary.CountryCode(user.country).ToUpper())
            {
                //this means that the country listed in UODB != country listed in billing service
                //this should never happen, but it can't hurt to check
                Output.WriteLineEntryError("User: " + user.gamertag + " has country in billing service that does not match country in UODB: " + country + " !=  " + CountryDictionary.CountryCode(user.country));
                locale = "";
            }

        }

        private static void PrintReport()
        {
            Output.WriteLine("Number of users: " + numUsers.ToString());
            Output.WriteLine("Number of bad users: " + numBadUsers.ToString());
            Output.WriteLine("Number of queued users: " + numQueuedAccounts.ToString());
            Output.WriteLine("Number of duplicate accounts: " + numDuplicateAccounts.ToString());
            Output.WriteLine("Number of duplicate subscriptions: " + numDuplicateSubscriptions.ToString());
            Output.WriteLine("Number of bad payinfos: " + numPaymentInstrumentProblems.ToString());
            Output.WriteLine("Number of bad locales: " + numBadLocales.ToString());
            Output.WriteLine("");
            Output.WriteLine("Number of subscriptions: " + numSubscriptions.ToString());
            Output.WriteLine("Number of bad subscriptions: " + numBadSubscriptions.ToString());
            Output.WriteLine("Number of queued subscriptions: " + numQueuedSubscriptions.ToString());
            Output.WriteLine("Number of incomplete purchases: " + numIncompletePurchases.ToString());
            Output.WriteLine("Number of unprovisioned purchases: " + numUnprovisionedSubscriptions.ToString());
            Output.WriteLine("");
            Output.WriteLine("Number of billing calls made: " + BillingProvider.NumBillingCalls.ToString());
            Output.WriteLine("Number of billing deletes: " + numBillingDeletes.ToString());
            Output.WriteLine("Number of billing updates: " + numBillingUpdates.ToString());
            Output.WriteLine("");
            Output.WriteLine("Number of UODB updates: " + numUODBUpdates.ToString());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\bdk.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.0
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.0.3705.0.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
// CODEGEN: The optional WSDL extension element 'binding' from namespace 'http://schemas.microsoft.com/soap-toolkit/wsdl-extension' was not handled.
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="BDKServerObj2SoapBinding", Namespace="http://tempuri.org/wsdl/")]
public class bdk : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public bdk() {
        this.Url = "https://sps25tiexbox1.tiexbox1.ssd.extest.microsoft.com/bdk2/bdk.WSDL";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.Invoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID});
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitsForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForObjectId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.Invoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep});
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitsForObjectId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountId = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrDate = ((string)(results[3]));
        bstrRequiredPaperWorkURL = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountId = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrDate = ((string)(results[3]));
        bstrRequiredPaperWorkURL = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
        object[] results = this.Invoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrRequiredPaperWorkURL = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrRequiredPaperWorkURL = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ActivateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ActivateAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.Invoke("ActivateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginActivateAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ActivateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndActivateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionStatusFromPaymentInstru" +
"ment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrStatusChange,
                    bstrPaymentInstrumentInfoXML,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrStatusChange,
                    bstrPaymentInstrumentInfoXML,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateSubscriptionStatusFromPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromAdminPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromAdminPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrPaymentInstrumentId = ((string)(results[1]));
        pbstrRequiredPaperWorkURL = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrPaymentInstrumentId = ((string)(results[1]));
        pbstrRequiredPaperWorkURL = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.Invoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdatePaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdatePaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemovePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
        object[] results = this.Invoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemovePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReplacePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReplacePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("ReplacePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrRequiredPaperWorkURL = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReplacePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReplacePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReplacePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrRequiredPaperWorkURL = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SettleBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSettleBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TransferBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void TransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTransferBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SwitchPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSwitchPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddComment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddComment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetComments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
        object[] results = this.Invoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        plCommentInfoSetCount = ((int)(results[1]));
        pbstrCommentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetComments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plCommentInfoSetCount = ((int)(results[1]));
        pbstrCommentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOffering", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void PurchaseOffering(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                out string pbstrErrorXML, 
                out string pbstrSubscriptionId, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceCount, 
                out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.Invoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPurchaseOffering(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndPurchaseOffering(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
        object[] results = this.Invoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        plRemovedServiceInstanceCount = ((int)(results[3]));
        pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        plRemovedServiceInstanceCount = ((int)(results[3]));
        pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchAccounts", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSearchAccounts(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptions", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
        object[] results = this.Invoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
        plSubscriptionInfoCount = ((int)(results[1]));
        pbstrSubscriptionInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptions(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plSubscriptionInfoCount = ((int)(results[1]));
        pbstrSubscriptionInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.Invoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptionStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReferralData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
        object[] results = this.Invoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plReferralCount = ((int)(results[1]));
        pbstrReferralSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetReferralData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plReferralCount = ((int)(results[1]));
        pbstrReferralSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ConvertSubscription(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                out string pbstrErrorXML, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceSetCount, 
                out string pbstrAddedServiceInstanceSet, 
                out int plRemovedServiceInstanceSetCount, 
                out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginConvertSubscription(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndConvertSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateSubscriptionInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.Invoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBaseOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetEligibleOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetServiceComponents", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetServiceComponents(string bstrOfferingGUID, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
        object[] results = this.Invoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID});
        pbstrErrorText = ((string)(results[0]));
        plServiceComponentCount = ((int)(results[1]));
        pbstrServiceComponentSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetServiceComponents(string bstrOfferingGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetServiceComponents(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plServiceComponentCount = ((int)(results[1]));
        pbstrServiceComponentSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ValidateProvisioningData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.Invoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndValidateProvisioningData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CheckProvisioningStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.Invoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCheckProvisioningStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ProvisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndProvisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeprovisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void DeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginDeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndDeprovisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportUsageEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReportUsageEvent(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourceBalances", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
        object[] results = this.Invoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID});
        pbstrErrorText = ((string)(results[0]));
        pcResourceInfoCount = ((int)(results[1]));
        pbstrResourceInfoSet = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetResourceBalances(System.IAsyncResult asyncResult, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        pcResourceInfoCount = ((int)(results[1]));
        pbstrResourceInfoSet = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustResourceBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustResourceBalance(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreditPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void OffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginOffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndOffsetLineItem(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TestConnection", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void TestConnection(string bstrInputString, out string pbstrOutputString) {
        object[] results = this.Invoke("TestConnection", new object[] {
                    bstrInputString});
        pbstrOutputString = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTestConnection(string bstrInputString, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TestConnection", new object[] {
                    bstrInputString}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTestConnection(System.IAsyncResult asyncResult, out string pbstrOutputString) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrOutputString = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnbanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnbanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.IsPaymentInstrumentBanned", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void IsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plIsBanned) {
        object[] results = this.Invoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        plIsBanned = ((int)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginIsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndIsPaymentInstrumentBanned(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plIsBanned) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plIsBanned = ((int)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.StopPayments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void StopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
        object[] results = this.Invoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginStopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndStopPayments(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountActivity", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
        object[] results = this.Invoke("GetAccountActivity", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    lBillingPeriodId,
                    bstrLocale,
                    fDeep});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountActivityXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountActivity", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    lBillingPeriodId,
                    bstrLocale,
                    fDeep}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountActivity(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountActivityXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBillingPeriods", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
        object[] results = this.Invoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale});
        pbstrErrorXML = ((string)(results[0]));
        plBillingPeriodCount = ((int)(results[1]));
        pbstrBillingPeriodSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBillingPeriods(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plBillingPeriodCount = ((int)(results[1]));
        pbstrBillingPeriodSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SyncUPSCacheForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, out string pbstrErrorXML) {
        object[] results = this.Invoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSyncUPSCacheForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetKey", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, out string pbstrErrorXML, out string pbstrKeyXml) {
        object[] results = this.Invoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid});
        pbstrErrorXML = ((string)(results[0]));
        pbstrKeyXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetKey(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrKeyXml) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrKeyXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAdjustments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
        object[] results = this.Invoke("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId});
        pbstrErrorXML = ((string)(results[0]));
        pcAppliedAdjustmentCount = ((int)(results[1]));
        pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
        pcAvailableAdjustmentCount = ((int)(results[3]));
        pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAdjustments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pcAppliedAdjustmentCount = ((int)(results[1]));
        pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
        pcAvailableAdjustmentCount = ((int)(results[3]));
        pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CompleteConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCompleteConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plAddedServiceInstanceSetCount = ((int)(results[1]));
        pbstrAddedServiceInstanceSet = ((string)(results[2]));
        plRemovedServiceInstanceSetCount = ((int)(results[3]));
        pbstrRemoveServiceInstanceSet = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plAddedServiceInstanceSetCount = ((int)(results[1]));
        pbstrAddedServiceInstanceSet = ((string)(results[2]));
        plRemovedServiceInstanceSetCount = ((int)(results[3]));
        pbstrRemoveServiceInstanceSet = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ImportSettledBillingItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, out string pbstrResultXML) {
        object[] results = this.Invoke("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML});
        pbstrResultXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndImportSettledBillingItem(System.IAsyncResult asyncResult, out string pbstrResultXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrResultXML = ((string)(results[0]));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BillingXCheck\statler\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BdkApiWrapperGen\BdkApiWrapperGen.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;

using xonline.common.billing;
using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.webstore;


public class MethodComparer : IComparer<MethodInfo>
{
    public int Compare(MethodInfo a, MethodInfo b)
    {
        if (a == null)
        {
            if (b == null)
            {
                return 0;
            }
            else
            {
                return -1;
            }
        }

        else
        {
            if (b == null)
            {
                return 1;
            }

            return a.Name.CompareTo(b.Name);
        }
    }
}

public class BdkWrapperGen
{
    internal static string[] scsApiList =
    {
        "activateToken",
        "addComment",
        "addPaymentInstrument",
        "addRoleAssignment",
        "addViolation",
        "calculateTax",
        "cancelSubscription",
        "checkProvisioningStatus",
        "closeBalance",
        "convertSubscriptionEx",
        "convertSubscription",
        "createAccount",
        "creditPaymentInstrumentEx",
        "creditPaymentInstrument",
        "deprovisionServices",
        "getAccountIdFromAdminPUID",
        "getAccountInfo",
        "getComments",
        "getEligibleOfferings",
        "getKey",
        "getPartnerConfiguration",
        "getPaymentInstruments",
        "getPaymentInstrumentsEx",
        "getPermitsForObjectId",
        "getSubscriptionStatus",
        "getSubscriptions",
        "getTokenInfoEx",
        "loadTokenInstance",
        "migrateOffer",
        "offsetOrder",
        "provisionServices",
        "purchaseItem",
        "purchaseOfferingEx",
        "purchaseOffering",
        "reinstateSubscription",
        "removePaymentInstrument",
        "removeRoleAssignment",
        "removeViolation",
        "setPartnerConfiguration",
        "settleBalance",
        "stopPayments",
        "submitOrder",
        "switchPaymentInstruments",
        "testConnection",
        "transferBalance",
        "updateAccountInfo",
        "updatePaymentInstrumentInfo",
        "updateSubscriptionInfo",
        "validateProvisioningData",
    };

    internal static string[] auditedScsApiList =
    {
        "PurchaseItem",
        "CreateAccount",
        "UpdateAccountInfo",
        "AddPaymentInstrument",
        "RemovePaymentInstrument",
        "PurchaseOffering",
        "PurchaseOfferingEx",
        "PurchaseOfferingEx2",
        "PurchaseOfferingEx3",
        "CancelSubscription",
        "ReinstateSubscription",
        "ProvisionServices",
        "ConvertSubscription",
        "ConvertSubscriptionEx",
        "ConvertSubscriptionEx2",
        "ConvertSubscriptionEx3",
        "MigrateOffer",
        "SwitchPaymentInstruments",
        "TransferBalance",
        "UpdatePaymentInstrumentInfo",
        "OffsetOrder",
        "SubmitOrder",
    };

    internal static string[] userCtxApiList =
    {
        "AddPaymentInstrument",
        "ConvertSubscription",
        "ConvertSubscriptionEx",
        "ConvertSubscriptionEx2",
        "ConvertSubscriptionEx3",
        "CreateAccount",
        "CreateOrder",
        "GetAccountIdFromAdminPUID",
        "GetAccountIdFromPUID",
        "GetAccountIdFromToken",
        "GetAccountInfo",
        "GetBaseOfferingsEx",
        "GetEligibleOfferings",
        "GetEligibleOfferingsEx",
        "GetPaymentInstruments",
        "GetPaymentInstrumentsEx",
        "GetResourceBalances",
        "GetStatement",
        "GetSubscriptions",
        "GetTransactions",
        "GetUserProfile",
        "PurchaseItem",
        "PurchaseOffering",
        "PurchaseOfferingEx",
        "PurchaseOfferingEx2",
        "PurchaseOfferingEx3",
        "SearchAccounts",
        "SearchAccountsEx",
        "UpdateAccountInfo",
        "SubmitOrder",
    };

    internal static Dictionary<string, string> inParamsToSanitize = new Dictionary<string, string>(StringComparer.InvariantCultureIgnoreCase);

    public static bool ParamNeedsSanitization(string apiName, string paramName)
    {
        string key = apiName + "|" + paramName;
        return inParamsToSanitize.ContainsKey(key);
    }

    public static void Main(string[] args)
    {
        BdkWrapper bdk = null;

        if (args.Length > 2)
        {
            bdk = new BdkWrapper();
        }

        Assembly asm = Assembly.GetExecutingAssembly();
        Type t = asm.GetType("BDKWSDL.bdk");
        if (t == null)
        {
            Console.Error.WriteLine("unable to reflect type...  commence to grubbing.");

            Type[] tt = asm.GetTypes();
            for (int i = 0; i < tt.Length; i++)
            {
                Console.WriteLine("type: " + tt[i].Name);
                if (tt[i].FullName == "BDKWSDL.bdk")
                {
                    t = tt[i];
                    break;
                }
            }
        }

        if (t == null)
        {
            Console.Error.WriteLine("unable to reflect type!");
            return;
        }

        inParamsToSanitize.Add("AddPaymentInstrument|bstrPaymentInstrumentInfoXML", "");
        inParamsToSanitize.Add("CreateAccount|bstrPaymentInstrumentXML", "");
        inParamsToSanitize.Add("UpdatePaymentInstrumentInfo|bstrPaymentInstrumentInfoXML", "");

        Hashtable ht = new Hashtable();
        foreach (string api in scsApiList)
        {
            ht.Add(api.ToLower(), api);
        }

        Hashtable auditedApis = new Hashtable();
        foreach (string api in auditedScsApiList)
        {
            auditedApis.Add(api.ToLower(), api);
        }

        Hashtable userCtxApis = new Hashtable();
        foreach (string api in userCtxApiList)
        {
            userCtxApis.Add(api.ToLower(), api);
        }

        List<MethodInfo> webMethods = new List<MethodInfo>();

        MethodInfo[] miArray = t.GetMethods(BindingFlags.Public | BindingFlags.Instance);
        for (int i = 0; i < miArray.Length; i++)
        {
            Object[] attrs = miArray[i].GetCustomAttributes(true);
            for (int j = 0; j < attrs.Length; j++)
            {
                if (attrs[j] is System.Web.Services.Protocols.SoapRpcMethodAttribute)
                {
                    string methodName = miArray[i].Name;

                    //Console.WriteLine("WebMethod: " + miArray[i].Name);

                    if (ht[methodName.ToLower()] != null)
                    {
                        webMethods.Add(miArray[i]);
                    }
                }
            }
        }

        Console.WriteLine(fileHeader);

        MethodComparer mc = new MethodComparer();
        webMethods.Sort(mc);

        foreach (MethodInfo mi in webMethods)
        {
            bool addAuditCode = (auditedApis[mi.Name.ToLower()] != null);
            bool addUserContextData = (userCtxApis[mi.Name.ToLower()] != null);

            GenerateMethodWrapper(mi, addAuditCode, addUserContextData);
        }

        Console.WriteLine(fileFooter);
    }

    public static string GetParameterType(ParameterInfo pi)
    {
        if (pi.ParameterType.Name == "Int16" || pi.ParameterType.Name == "Int16&")
            return "short";

        if (pi.ParameterType.Name == "Int32" || pi.ParameterType.Name == "Int32&")
            return "int";

        if (pi.ParameterType.Name == "Int64" || pi.ParameterType.Name == "Int64&")
            return "long";

        if (pi.ParameterType.Name == "Double" || pi.ParameterType.Name == "Double&")
            return "double";

        if (pi.ParameterType.Name == "String" || pi.ParameterType.Name == "String&")
            return "string";

        if (pi.ParameterType.Name == "Boolean" || pi.ParameterType.Name == "Boolean&")
            return "bool";

        return pi.ParameterType.Name;
    }

    public static string GenerateCallingParameters(ParameterInfo[] pi)
    {
        string paramText = "";

        if (pi.Length > 0)
        {
            ParameterInfo p = pi[0];

            if (p.IsOut)
            {
                paramText += "out ";
            }

            paramText += GetParameterType(p) + " " + p.Name;

            for (int i = 1; i < pi.Length; i++)
            {
                p = pi[i];

                paramText += ", ";

                if (p.IsOut)
                {
                    paramText += "out ";
                }

                paramText += GetParameterType(p) + " " + p.Name;
            }
        }

        return paramText;
    }

    public static string GenerateParameterSignature(ParameterInfo[] pi)
    {
        string paramText = "";

        if (pi.Length > 0)
        {
            ParameterInfo p = pi[0];

            if (p.IsOut)
            {
                paramText += "out ";
            }

            paramText += p.Name;

            for (int i = 1; i < pi.Length; i++)
            {
                p = pi[i];

                paramText += ", ";

                if (p.IsOut)
                {
                    paramText += "out ";
                }

                paramText += p.Name;
            }
        }

        return paramText;
    }

    public static void GenerateMethodWrapper(MethodInfo mi, bool addAuditCode, bool addUserContextData)
    {
        string apiName = mi.Name;

        ParameterInfo[] pi = mi.GetParameters();

        List<ParameterInfo> inParams = new List<ParameterInfo>();
        List<ParameterInfo> outParams = new List<ParameterInfo>();

        for (int i = 0; i < pi.Length; i++)
        {
            if (pi[i].IsOut)
            {
                outParams.Add(pi[i]);
            }
            else
            {
                inParams.Add(pi[i]);
            }
        }

        string paramSignature = GenerateParameterSignature(pi);

        string callingParams = GenerateCallingParameters(pi);

        string inParamArrayText = "string[] inParams = new string[] {\n";
        for (int i = 0; i < inParams.Count; i++)
        {
            string inParamExpr = inParams[i].Name;

            if (ParamNeedsSanitization(apiName, inParams[i].Name))
            {
                inParamExpr = "SanitizeXmlInputParameter(" + inParams[i].Name + ")";
            }

            if (inParams[i].ParameterType.Name == "String")
            {
                inParamArrayText += "        (" + inParams[i].Name + " == null ? \"null\" : " + inParamExpr + ")";
            }
            else
            {
                inParamArrayText += "        " + inParamExpr + ".ToString()";
            }

            if (i < inParams.Count - 1)
            {
                inParamArrayText += ",";
            }

            inParamArrayText += "\n";
        }
        inParamArrayText += "    };";

        bool hasErrorXmlOutParam = false;
        string errorXmlVariable = "errorXmlText";

        for (int i = 0; i < outParams.Count; i++)
        {
            if (outParams[i].Name == "errorXml" || outParams[i].Name == "pbstrErrorXML")
            {
                hasErrorXmlOutParam = true;
                errorXmlVariable = outParams[i].Name;
                break;
            }
        }

        string outParamArrayText = "outParams = new string[] {\n";
        for (int i = 0; i < outParams.Count; i++)
        {
            if (outParams[i].ParameterType.Name == "String&")
            {
                outParamArrayText += "            (" + outParams[i].Name + " == null ? \"null\" : " + outParams[i].Name + ")";
            }
            else
            {
                outParamArrayText += "            " + outParams[i].Name + ".ToString()";
            }


            if (i < outParams.Count - 1)
            {
                outParamArrayText += ",";
            }

            outParamArrayText += "\n";
        }
        outParamArrayText += "        };";

        string methodTemplate =
            "public new virtual void {0}({1})\n" +
            "{{\n" +
            "    string apiName = \"{0}\";\n" +
            "\n" +
            (hasErrorXmlOutParam == false ? "    string errorXmlText;\n\n" : "") +
            "    FastFailTracker ffTracker = null;\n" +
            "\n" +
            "    {3}\n" +
            "\n" +
            "    string[] outParams = null;\n" +
            "\n" +
            "    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();\n" +
            "\n" +
            "    APIResultEnum apiResult = APIResultEnum.Failed;\n" +
            "\n" +
            "    " + errorXmlVariable + " = \"\";\n" +
            "\n" +
            "    try\n" +
            "    {{\n" +
            "        SetSessionBdkApi(apiName);\n" +
            "\n" +
            "        ffTracker = GetFastFailTracker(apiName);\n" +
            "\n" +
            "        int timeout = BillingConfig.GetApiTimeout(apiName);\n" +
            "\n" +
            "        HandlePerfCountersBegin(apiName);\n" +
            "\n" +
            "        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);\n" +
            "\n" +
            "        Timeout = timeout;\n" +
            "\n" +
            "{6}" +
            "        using (HistogramPerfCounterManager.GetHistogramManager(\"BDK\",apiName))\n" +
            "        {{\n" +
            "\n" +
            "            base.{0}({2});\n" +
            "\n" +
            "        }}\n" +

            "\n" +
            "        postCallInjectedBehavior();\n" +
            "\n" +
            "        apiResult = APIResultEnum.Success;\n" +
            "\n" +
            "        ffTracker.IndicateSuccess();\n" +
            "\n" +
            "        {4}\n" +
            "\n" +
            "    }}\n" +
            "    catch (WebException we)\n" +
            "    {{\n" +
            "        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )\n" +
            "        {{\n" +
            "            ffTracker.IndicateTimeout();\n" +
            "\n" +
            "            apiResult = APIResultEnum.Timeout;\n" +
            "\n" +
            "            HandleTimeout(apiName);\n" +
            "        }}\n" +
            "        throw;\n" +
            "    }}\n" +
            "    catch (Exception e)\n" +
            "    {{\n" +
            "        if ( BdkExceptionUtil.IsBillingError(e) )\n" +
            "        {{\n" +
            "            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, \"SCS error: \" + e.Message);\n" +
            "            " + errorXmlVariable + " = e.Message;\n" +
            "            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);\n" +
            "            throw bpe;\n" +
            "        }}\n" +
            "        throw;\n" +
            "    }}\n" +
            "    finally\n" +
            "    {{\n" +
            "        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);\n" +
            "\n" +
            "        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, {5});\n" +
            "\n" +
            "{7}" +
            "        if ( ffTracker != null )\n" +
            "        {{\n" +
            "            ffTracker.IndicateSuccess();\n" +
            "\n" +
            "            ffTracker = null;\n" +
            "        }}\n" +
            "    }}\n" +
            "}}\n" +
            "\n";

        string auditedMethodTemplate =
            "public new virtual void {0}({1})\n" +
            "{{\n" +
            "    string apiName = \"{0}\";\n" +
            "    string auditMessage = string.Empty;\n" +
            "    List<AuditParam> auditParams = new List<AuditParam>();\n" +
            "\n" +
            (hasErrorXmlOutParam == false ? "    string errorXmlText;\n\n" : "") +
            "    FastFailTracker ffTracker = null;\n" +
            "\n" +
            "    {3}\n" +
            "\n" +
            "    string[] outParams = null;\n" +
            "\n" +
            "    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();\n" +
            "\n" +
            "    APIResultEnum apiResult = APIResultEnum.Failed;\n" +
            "\n" +
            "    " + errorXmlVariable + " = \"\";\n" +
            "\n" +
            "    try\n" +
            "    {{\n" +
            "        SetSessionBdkApi(apiName);\n" +
            "\n" +
            "        ffTracker = GetFastFailTracker(apiName);\n" +
            "\n" +
            "        int timeout = BillingConfig.GetApiTimeout(apiName);\n" +
            "\n" +
            "        HandlePerfCountersBegin(apiName);\n" +
            "\n" +
            "        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, ref timeout);\n" +
            "\n" +
            "        Timeout = timeout;\n" +
            "\n" +
            "{8}" +
            "{6}" +
            "\n" +
            "        using (HistogramPerfCounterManager.GetHistogramManager(\"BDK\",apiName))\n" +
            "        {{\n" +
            "\n" +
            "            base.{0}({2});\n" +
            "\n" +
            "        }}\n" +
            "\n" +
            "        postCallInjectedBehavior();\n" +
            "\n" +
            "        apiResult = APIResultEnum.Success;\n" +
            "\n" +
            "        ffTracker.IndicateSuccess();\n" +
            "\n" +
            "        {4}\n" +
            "\n" +
            "        auditMessage = \"success\";\n" +
            "{7}\n" +
            "    }}\n" +
            "    catch (WebException we)\n" +
            "    {{\n" +
            "        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )\n" +
            "        {{\n" +
            "            ffTracker.IndicateTimeout();\n" +
            "            apiResult = APIResultEnum.Timeout;\n" +
            "            HandleTimeout(apiName);\n" +
            "            auditMessage = \"timeout\";\n" +
            "        }}\n" +
            "        else\n" +
            "        {{\n" +
            "            auditMessage = we.Message;\n" +
            "        }}\n" +
            "        throw;\n" +
            "    }}\n" +
            "    catch (Exception e)\n" +
            "    {{\n" +
            "        if ( BdkExceptionUtil.IsBillingError(e) )\n" +
            "        {{\n" +
            "            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, \"SCS error: \" + e.Message);\n" +
            "            " + errorXmlVariable + " = e.Message;\n" +
            "            auditMessage = e.Message;\n" +
            "            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);\n" +
            "            throw bpe;\n" +
            "        }}\n" +
            "\n" +
            "        auditMessage = e.Message;\n" +
            "        throw;\n" +
            "    }}\n" +
            "    finally\n" +
            "    {{\n" +
            "        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);\n" +
            "\n" +
            "        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, {5});\n" +
            "\n" +
            "{9}" +
            "        if ( auditParams.Count > 0 )\n" +
            "        {{\n" +
            "            AuditStream.Write(0, AuditSubsystem.BDK, apiName, auditMessage, auditParams);\n" +
            "        }}\n" +
            "\n" +
            "        if ( ffTracker != null )\n" +
            "        {{\n" +
            "            ffTracker.IndicateSuccess();\n" +
            "\n" +
            "            ffTracker = null;\n" +
            "        }}\n" +
            "    }}\n" +
            "}}\n" +
            "\n";

        string methodText;

        string setUserCtxData = string.Empty;
        string logUserCtxData = string.Empty;
        if (addUserContextData)
        {
            setUserCtxData = "        SetUserContextualData();\n\n";
            logUserCtxData = "        LogUserContextualInfo(this.UserContextualInfoSoapHeaderValue);\n\n";
        }

        if (addAuditCode)
        {
            string auditAddInputParams = string.Empty;
            for (int i = 0; i < inParams.Count; i++)
            {
                string paramName = inParams[i].Name;

                string paramExpr = paramName;
                if (ParamNeedsSanitization(apiName, paramName))
                {
                    paramExpr = "SanitizeXmlInputParameter(" + paramName + ")";
                }

                Match m = Regex.Match(paramName, "^[a-zA-Z]+(XML|Xml)$");
                if (m.Success)
                {
                    auditAddInputParams += "        auditParams.Add(new AuditXmlParam(\"" + paramName + "\", " + paramExpr + "));\n";
                }
                else
                {
                    auditAddInputParams += "        auditParams.Add(new AuditParam(\"" + paramName + "\", " + paramExpr + "));\n";
                }
            }

            string auditAddOutputParams = string.Empty;
            for (int i = 0; i < outParams.Count; i++)
            {
                string paramName = outParams[i].Name;

                if (paramName.ToLower() == "errorxml" || paramName.ToLower() == "pbstrerrorxml")
                    continue;

                Match m = Regex.Match(paramName, "^[a-zA-Z]+(XML|Xml)$");
                if (m.Success)
                {
                    auditAddOutputParams += "        auditParams.Add(new AuditXmlParam(\"" + paramName + "\", " + paramName + "));\n";
                }
                else
                {
                    auditAddOutputParams += "        auditParams.Add(new AuditParam(\"" + paramName + "\", " + paramName + "));\n";
                }
            }

            methodText = String.Format(
                auditedMethodTemplate,
                apiName,
                callingParams,
                paramSignature,
                inParamArrayText,
                outParamArrayText,
                errorXmlVariable,
                auditAddInputParams,
                auditAddOutputParams,
                setUserCtxData,
                logUserCtxData
                );
        }
        else
        {
            methodText = String.Format(
                methodTemplate,
                apiName,
                callingParams,
                paramSignature,
                inParamArrayText,
                outParamArrayText,
                errorXmlVariable,
                setUserCtxData,
                logUserCtxData
                );
        }

        Console.WriteLine(methodText);
    }

    internal static string fileHeader =
        "using System;\n" +
        "using System.Collections;\n" +
        "using System.Collections.Generic;\n" +
        "using System.Net;\n" +
        "using System.Xml;\n" +
        "\n" +
        "using xonline.common.audit;\n" +
        "using xonline.common.config;\n" +
        "using xonline.common.mgmt;\n" +
        "using xonline.common.service;\n" +
        "using xonline.common.utilities2;\n" +
        "\n" +
        "//\n" +
        "// Copyright (c) Microsoft Corporation.  All rights reserved.\n" +
        "//\n" +
        "// THIS FILE IS AUTO-GENERATED!  DO NOT HAND-EDIT THIS FILE!\n" +
        "//\n" +
        "// This file was generated by the tool BdkApiWrapperGen in \\private\\tools\\BdkApiWrapperGen\n" +
        "// If changes are needed to this file, please modify the tool and regenerate the API\n" +
        "// using the tool.  This allows us to easily incorporate new SCS BDK APIs into our\n" +
        "// service without having to resort to the hand-editing we had to do for years.\n" +
        "//\n" +
        "\n" +
        "namespace xonline.common.billing\n" +
        "{\n" +
        "partial class BdkWrapper : BDKWSDL.bdk\n" +
        "{\n";

    internal static string fileFooter =
        "}\n" +
        "}\n";

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\Backup3\SPSResultSchema.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by xsd, Version=1.0.3705.288.
// 
namespace xonline.tools.batman  {    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class ErrorPackage {
        
        /// <remarks/>
        public string ErrorHResult;
        
        /// <remarks/>
        public string Message;
        
        /// <remarks/>
        public ErrorPackageErrorDebugInfo ErrorDebugInfo;
        
        /// <remarks/>
        public ErrorPackageErrorDetailSet ErrorDetailSet;
        
        /// <remarks/>
        public string TrackingGUID;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class ErrorPackageErrorDebugInfo {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("DebugInfo")]
        public string[] DebugInfo;
        
        /// <remarks/>
        public string ComputerName;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class ErrorPackageErrorDetailSetErrorDetailErrorDebugInfo {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("DebugInfo")]
        public string[] DebugInfo;
        
        /// <remarks/>
        public string ComputerName;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class ErrorPackageErrorDetailSetErrorDetail {
        
        /// <remarks/>
        public int EventId;
        
        /// <remarks/>
        public string ErrorHResult;
        
        /// <remarks/>
        public string Message;
        
        /// <remarks/>
        public ErrorPackageErrorDetailSetErrorDetailErrorDebugInfo ErrorDebugInfo;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class ErrorPackageErrorDetailSet {
        
        /// <remarks/>
        public ErrorPackageErrorDetailSetErrorDetail ErrorDetail;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute("PaymentInstrumentInfoSet", Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class PaymentInstrumentInfoSet {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("PaymentInstrumentInfo")]
        public PaymentInstrumentInfoSetPaymentInstrumentInfo[] PaymentInstrumentInfo;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class PaymentInstrumentInfoSetPaymentInstrumentInfo {
        
        /// <remarks/>
        public string PaymentInstrumentId;
        
        /// <remarks/>
        public string PaymentInstrumentStatus;
        
        /// <remarks/>
        public string PaymentInstrumentType;
        
        /// <remarks/>
        public string FriendlyName;
        
        /// <remarks/>
        public PaymentInstrumentInfoSetPaymentInstrumentInfoCreditCardInfo CreditCardInfo;
        
        /// <remarks/>
        public PaymentInstrumentInfoSetPaymentInstrumentInfoDirectDebitInfo DirectDebitInfo;
        
        /// <remarks/>
        public PaymentInstrumentInfoSetPaymentInstrumentInfoQwestInfo QwestInfo;
        
        /// <remarks/>
        public PaymentInstrumentInfoSetPaymentInstrumentInfoPhone Phone;
        
        /// <remarks/>
        public PaymentInstrumentInfoSetPaymentInstrumentInfoAddressInfo AddressInfo;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class PaymentInstrumentInfoSetPaymentInstrumentInfoCreditCardInfo {
        
        /// <remarks/>
        public string AccountHolderName;
        
        /// <remarks/>
        public string AccountNumberLastFour;
        
        /// <remarks/>
        public string CardType;
        
        /// <remarks/>
        public string ExpirationDate;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class PaymentInstrumentInfoSetPaymentInstrumentInfoDirectDebitInfo {
        
        /// <remarks/>
        public string AccountHolderName;
        
        /// <remarks/>
        public string AccountNumberLastFour;
        
        /// <remarks/>
        public string BankCode;
        
        /// <remarks/>
        public string BranchCode;
        
        /// <remarks/>
        public string CheckDigits;
        
        /// <remarks/>
        public string MandateStatus;
        
        /// <remarks/>
        public string MandateReceivedDate;
        
        /// <remarks/>
        public string MandateDueDate;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class PaymentInstrumentInfoSetPaymentInstrumentInfoQwestInfo {
        
        /// <remarks/>
        public string AccountHolderName;
        
        /// <remarks/>
        public string AccountNumberLastFour;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class PaymentInstrumentInfoSetPaymentInstrumentInfoPhone {
        
        /// <remarks/>
        public string PhoneType;
        
        /// <remarks/>
        public string PhonePrefix;
        
        /// <remarks/>
        public string PhoneNumber;
        
        /// <remarks/>
        public string PhoneExtension;
        
        /// <remarks/>
        public string CountryCode;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class PaymentInstrumentInfoSetPaymentInstrumentInfoAddressInfo {
        
        /// <remarks/>
        public string AddressId;
        
        /// <remarks/>
        public string FriendlyName;
        
        /// <remarks/>
        public string Street1;
        
        /// <remarks/>
        public string Street2;
        
        /// <remarks/>
        public string Street3;
        
        /// <remarks/>
        public string City;
        
        /// <remarks/>
        public string District;
        
        /// <remarks/>
        public string State;
        
        /// <remarks/>
        public string CountryCode;
        
        /// <remarks/>
        public string PostalCode;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute("ServiceInstanceSet", Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class ServiceInstanceSet {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("ServiceInstance")]
        public ServiceInstanceSetServiceInstance[] ServiceInstance;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class ServiceInstanceSetServiceInstance {
        
        /// <remarks/>
        public string ServiceInstanceId;
        
        /// <remarks/>
        public string ServiceComponentId;
        
        /// <remarks/>
        public string ProvisioningStatus;
        
        /// <remarks/>
        public string ProvisioningErrorCode;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute("SubscriptionInfoSet", Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class SubscriptionInfoSet {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("SubscriptionInfo")]
        public SubscriptionInfoSetSubscriptionInfo[] SubscriptionInfo;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionInfoSetSubscriptionInfo {
        
        /// <remarks/>
        public string SubscriptionId;
        
        /// <remarks/>
        public string AnniversaryDate;
        
        /// <remarks/>
        public string OfferingGUID;
        
        /// <remarks/>
        public string SubscriptionDescription;
        
        /// <remarks/>
        public string SubscriptionPriceDescription;
        
        /// <remarks/>
        public string InternalSubscriptionDescription;
        
        /// <remarks/>
        public string FriendlyName;
        
        /// <remarks/>
        public string ShippingAddressId;
        
        /// <remarks/>
        public SubscriptionInfoSetSubscriptionInfoSubscriptionStatusInfo SubscriptionStatusInfo;
        
        /// <remarks/>
        public string PurchaseDate;
        
        /// <remarks/>
        public string ActivationDate;
        
        /// <remarks/>
        public string EndDate;
        
        /// <remarks/>
        public string RenewalGracePeriod;
        
        /// <remarks/>
        public string RenewOfferingId;
        
        /// <remarks/>
        public string PaymentInstrumentId;
        
        /// <remarks/>
        public string TermCommitCyclesRemaining;
        
        /// <remarks/>
        public SubscriptionInfoSetSubscriptionInfoDelayedConversion DelayedConversion;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("ServiceInstance", IsNullable=false)]
        public SubscriptionInfoSetSubscriptionInfoServiceInstance[] ServiceInstanceSet;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionInfoSetSubscriptionInfoSubscriptionStatusInfo {
        
        /// <remarks/>
        public string SubscriptionStatus;
        
        /// <remarks/>
        public SubscriptionInfoSetSubscriptionInfoSubscriptionStatusInfoViolationSet ViolationSet;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionInfoSetSubscriptionInfoSubscriptionStatusInfoViolationSet {
        
        /// <remarks/>
        public string ViolationId;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionInfoSetSubscriptionInfoDelayedConversion {
        
        /// <remarks/>
        public string OfferingGUID;
        
        /// <remarks/>
        public string ConversionDate;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionInfoSetSubscriptionInfoServiceInstance {
        
        /// <remarks/>
        public string ServiceInstanceId;
        
        /// <remarks/>
        public string ServiceComponentId;
        
        /// <remarks/>
        public string ProvisioningStatus;
        
        /// <remarks/>
        public string ProvisioningErrorCode;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class SubscriptionStatusInfo {
        
        /// <remarks/>
        public string SubscriptionStatus;
        
        /// <remarks/>
        public SubscriptionStatusInfoViolationSet ViolationSet;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionStatusInfoViolationSet {
        
        /// <remarks/>
        public string ViolationId;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute("AccountInfoSet", Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class AccountInfoSet {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("AccountInfo")]
        public AccountInfoSetAccountInfo[] AccountInfo;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoSetAccountInfo {
        
        /// <remarks/>
        public string AccountId;
        
        /// <remarks/>
        public string FriendlyName;
        
        /// <remarks/>
        public AccountInfoSetAccountInfoAccountStatus AccountStatus;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoSetAccountInfoAccountStatus {
        
        /// <remarks/>
        public AccountInfoSetAccountInfoAccountStatusViolationSet ViolationSet;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoSetAccountInfoAccountStatusViolationSet {
        
        /// <remarks/>
        public string ViolationId;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class AccountInfo {
        
        /// <remarks/>
        public string AccountId;
        
        /// <remarks/>
        public AccountInfoAccountStatusInfo AccountStatusInfo;
        
        /// <remarks/>
        public string AccountCreationDate;
        
        /// <remarks/>
        public string AccountHistoryDate;
        
        /// <remarks/>
        public string AccountSource;
        
        /// <remarks/>
        public string LegacyAccountId;
        
        /// <remarks/>
        public string AnniversaryDate;
        
        /// <remarks/>
        public string CustomerType;
        
        /// <remarks/>
        public string DefaultAddressId;
        
        /// <remarks/>
        public string CorporateIdentity;
        
        /// <remarks/>
        public string FriendlyName;
        
        /// <remarks/>
        public string FirstName;
        
        /// <remarks/>
        public string FirstNamePronunciation;
        
        /// <remarks/>
        public string LastName;
        
        /// <remarks/>
        public string LastNamePronunciation;
        
        /// <remarks/>
        public string Email;
        
        /// <remarks/>
        public string CompanyName;
        
        /// <remarks/>
        public string CompanyNamePronunciation;
        
        /// <remarks/>
        public string Locale;
        
        /// <remarks/>
        public string HCI;
        
        /// <remarks/>
        public string Currency;
        
        /// <remarks/>
        public AccountInfoPhoneSet PhoneSet;
        
        /// <remarks/>
        public AccountInfoAddressInfoSet AddressInfoSet;
        
        /// <remarks/>
        public AccountInfoTaxExemptionInfoSet TaxExemptionInfoSet;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoAccountStatusInfo {
        
        /// <remarks/>
        public string AccountStatus;
        
        /// <remarks/>
        public AccountInfoAccountStatusInfoViolationSet ViolationSet;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoAccountStatusInfoViolationSet {
        
        /// <remarks/>
        public string ViolationId;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoPhoneSet {
        
        /// <remarks/>
        public AccountInfoPhoneSetPhone Phone;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoPhoneSetPhone {
        
        /// <remarks/>
        public string PhoneType;
        
        /// <remarks/>
        public string PhonePrefix;
        
        /// <remarks/>
        public string PhoneNumber;
        
        /// <remarks/>
        public string PhoneExtension;
        
        /// <remarks/>
        public string CountryCode;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoAddressInfoSet {
        
        /// <remarks/>
        public AccountInfoAddressInfoSetAddressInfo AddressInfo;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoAddressInfoSetAddressInfo {
        
        /// <remarks/>
        public string AddressId;
        
        /// <remarks/>
        public string FriendlyName;
        
        /// <remarks/>
        public string Street1;
        
        /// <remarks/>
        public string Street2;
        
        /// <remarks/>
        public string Street3;
        
        /// <remarks/>
        public string City;
        
        /// <remarks/>
        public string District;
        
        /// <remarks/>
        public string State;
        
        /// <remarks/>
        public string CountryCode;
        
        /// <remarks/>
        public string PostalCode;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoTaxExemptionInfoSet {
        
        /// <remarks/>
        public AccountInfoTaxExemptionInfoSetTaxExemptionInfo TaxExemptionInfo;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoTaxExemptionInfoSetTaxExemptionInfo {
        
        /// <remarks/>
        public string TECertificateNumber;
        
        /// <remarks/>
        public string TEType;
        
        /// <remarks/>
        public string TEStatus;
        
        /// <remarks/>
        public string TEExpDate;
        
        /// <remarks/>
        public string TEDateAdded;
        
        /// <remarks/>
        public string TEDateReceived;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Batman\Backup3\bdk.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.0
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.0.3705.0.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
// CODEGEN: The optional WSDL extension element 'binding' from namespace 'http://schemas.microsoft.com/soap-toolkit/wsdl-extension' was not handled.
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="BDKServerObj2SoapBinding", Namespace="http://tempuri.org/wsdl/")]
public class bdk : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public bdk() {
        this.Url = "https://sps25tiexbox1.tiexbox1.ssd.extest.microsoft.com/bdk2/bdk.WSDL";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.Invoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID});
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitsForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForObjectId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.Invoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep});
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitsForObjectId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountId = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrDate = ((string)(results[3]));
        bstrRequiredPaperWorkURL = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountId = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrDate = ((string)(results[3]));
        bstrRequiredPaperWorkURL = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
        object[] results = this.Invoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrRequiredPaperWorkURL = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrRequiredPaperWorkURL = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ActivateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ActivateAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.Invoke("ActivateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginActivateAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ActivateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndActivateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionStatusFromPaymentInstru" +
"ment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrStatusChange,
                    bstrPaymentInstrumentInfoXML,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrStatusChange,
                    bstrPaymentInstrumentInfoXML,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateSubscriptionStatusFromPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromAdminPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromAdminPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrPaymentInstrumentId = ((string)(results[1]));
        pbstrRequiredPaperWorkURL = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrPaymentInstrumentId = ((string)(results[1]));
        pbstrRequiredPaperWorkURL = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.Invoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdatePaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdatePaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemovePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
        object[] results = this.Invoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemovePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReplacePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReplacePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("ReplacePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrRequiredPaperWorkURL = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReplacePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReplacePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReplacePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrRequiredPaperWorkURL = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SettleBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSettleBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TransferBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void TransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTransferBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SwitchPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSwitchPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddComment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddComment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetComments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
        object[] results = this.Invoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        plCommentInfoSetCount = ((int)(results[1]));
        pbstrCommentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetComments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plCommentInfoSetCount = ((int)(results[1]));
        pbstrCommentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOffering", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void PurchaseOffering(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                out string pbstrErrorXML, 
                out string pbstrSubscriptionId, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceCount, 
                out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.Invoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPurchaseOffering(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndPurchaseOffering(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
        object[] results = this.Invoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        plRemovedServiceInstanceCount = ((int)(results[3]));
        pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        plRemovedServiceInstanceCount = ((int)(results[3]));
        pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchAccounts", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSearchAccounts(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptions", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
        object[] results = this.Invoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
        plSubscriptionInfoCount = ((int)(results[1]));
        pbstrSubscriptionInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptions(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plSubscriptionInfoCount = ((int)(results[1]));
        pbstrSubscriptionInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.Invoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptionStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReferralData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
        object[] results = this.Invoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plReferralCount = ((int)(results[1]));
        pbstrReferralSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetReferralData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plReferralCount = ((int)(results[1]));
        pbstrReferralSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ConvertSubscription(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                out string pbstrErrorXML, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceSetCount, 
                out string pbstrAddedServiceInstanceSet, 
                out int plRemovedServiceInstanceSetCount, 
                out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginConvertSubscription(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndConvertSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateSubscriptionInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.Invoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBaseOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetEligibleOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetServiceComponents", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetServiceComponents(string bstrOfferingGUID, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
        object[] results = this.Invoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID});
        pbstrErrorText = ((string)(results[0]));
        plServiceComponentCount = ((int)(results[1]));
        pbstrServiceComponentSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetServiceComponents(string bstrOfferingGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetServiceComponents(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plServiceComponentCount = ((int)(results[1]));
        pbstrServiceComponentSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ValidateProvisioningData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.Invoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndValidateProvisioningData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CheckProvisioningStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.Invoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCheckProvisioningStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ProvisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndProvisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeprovisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void DeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginDeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndDeprovisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportUsageEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReportUsageEvent(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourceBalances", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
        object[] results = this.Invoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID});
        pbstrErrorText = ((string)(results[0]));
        pcResourceInfoCount = ((int)(results[1]));
        pbstrResourceInfoSet = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetResourceBalances(System.IAsyncResult asyncResult, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        pcResourceInfoCount = ((int)(results[1]));
        pbstrResourceInfoSet = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustResourceBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustResourceBalance(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreditPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void OffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginOffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndOffsetLineItem(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TestConnection", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void TestConnection(string bstrInputString, out string pbstrOutputString) {
        object[] results = this.Invoke("TestConnection", new object[] {
                    bstrInputString});
        pbstrOutputString = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTestConnection(string bstrInputString, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TestConnection", new object[] {
                    bstrInputString}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTestConnection(System.IAsyncResult asyncResult, out string pbstrOutputString) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrOutputString = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnbanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnbanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.IsPaymentInstrumentBanned", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void IsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plIsBanned) {
        object[] results = this.Invoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        plIsBanned = ((int)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginIsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndIsPaymentInstrumentBanned(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plIsBanned) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plIsBanned = ((int)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.StopPayments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void StopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
        object[] results = this.Invoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginStopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndStopPayments(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountActivity", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
        object[] results = this.Invoke("GetAccountActivity", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    lBillingPeriodId,
                    bstrLocale,
                    fDeep});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountActivityXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountActivity", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    lBillingPeriodId,
                    bstrLocale,
                    fDeep}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountActivity(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountActivityXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBillingPeriods", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
        object[] results = this.Invoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale});
        pbstrErrorXML = ((string)(results[0]));
        plBillingPeriodCount = ((int)(results[1]));
        pbstrBillingPeriodSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBillingPeriods(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plBillingPeriodCount = ((int)(results[1]));
        pbstrBillingPeriodSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SyncUPSCacheForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, out string pbstrErrorXML) {
        object[] results = this.Invoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSyncUPSCacheForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetKey", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, out string pbstrErrorXML, out string pbstrKeyXml) {
        object[] results = this.Invoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid});
        pbstrErrorXML = ((string)(results[0]));
        pbstrKeyXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetKey(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrKeyXml) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrKeyXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAdjustments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
        object[] results = this.Invoke("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId});
        pbstrErrorXML = ((string)(results[0]));
        pcAppliedAdjustmentCount = ((int)(results[1]));
        pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
        pcAvailableAdjustmentCount = ((int)(results[3]));
        pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAdjustments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pcAppliedAdjustmentCount = ((int)(results[1]));
        pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
        pcAvailableAdjustmentCount = ((int)(results[3]));
        pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CompleteConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCompleteConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plAddedServiceInstanceSetCount = ((int)(results[1]));
        pbstrAddedServiceInstanceSet = ((string)(results[2]));
        plRemovedServiceInstanceSetCount = ((int)(results[3]));
        pbstrRemoveServiceInstanceSet = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plAddedServiceInstanceSetCount = ((int)(results[1]));
        pbstrAddedServiceInstanceSet = ((string)(results[2]));
        plRemovedServiceInstanceSetCount = ((int)(results[3]));
        pbstrRemoveServiceInstanceSet = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ImportSettledBillingItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, out string pbstrResultXML) {
        object[] results = this.Invoke("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML});
        pbstrResultXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndImportSettledBillingItem(System.IAsyncResult asyncResult, out string pbstrResultXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrResultXML = ((string)(results[0]));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BillingXCheck\waldorf\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BillingXCheck\statler\BillingProvider.cs ===
//
// BillingProvider.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// SPS 2.5 Wrapper Class
// Xbox Online Service
//
// Author: Ben Zotto (benzotto)
//

using System;
using System.IO;
using System.Web;
using System.Data.SqlClient;
using System.Data;
using System.Net;
using System.Text;
using System.Xml;
using System.Globalization;
using System.Diagnostics;
using System.Web.Services.Protocols;
using System.Runtime.InteropServices;
using xonline.common.service;
using System.Security.Permissions;
using System.Security.Principal;
using xonline.common.crypto;



namespace xonline.tools.billingxcheck.statler
{


public class BillingProvider : bdk
{

    //
    // Stuff for impersonation to get public key
    //

    [DllImport("c:\\winnt\\system32\\advapi32.dll", EntryPoint="LogonUser", SetLastError=true,
             CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
    public static extern bool LogonUser(String lpszUsername, String lpszDomain, String lpszPassword,
            int dwLogonType, int dwLogonProvider, out int phToken);

    [DllImport("c:\\winnt\\system32\\Kernel32.dll")]
    public static extern int GetLastError();

    //
    // BillingProvider
    //

    private static string _server;
    private static string _iisuser;

    // data that persists across all connections
    public static string Username
    {
        get
        {
            if (!_initalized) Init();
            return _username;
        }

        set { _username = value; }
    }

    public static string Password
    {
        get
        {
            if (!_initalized) Init();
            return _password;
        }
        set { _password = value; }
    }

    public static string WsdlLocation
    {
        get
        {
            if (!_initalized) Init();
            return _wsdlLocation;
        }
        set { _wsdlLocation = value; }
    }


    private static string _username;
    private static string _password;
    private static string _wsdlLocation;
    private static bool _initalized = false;

    public static void Init()
    {
        GetPartnerInfo(_server, _iisuser);

        Output.WriteDebug("BillingProvider: Username=" + _username);
        Output.WriteDebug("BillingProvider: WSDL=" + _wsdlLocation);

        _initalized = true;
    }

    // constructor
    public BillingProvider(string server, string iisuser) : base()
    {
        _server = server;
        _iisuser = iisuser;

        // set up the bdk that we inherit from
        this.Url     = WsdlLocation;

        this.Credentials = new NetworkCredential(Username, Password);
        this.Timeout     = 20000;
    }



    /// <summary>
    /// Gets the partner key info from UODB.
    /// </summary>
    private static void GetPartnerInfo(string server, string iisuser)
    {
        SqlCommand cmd;
        SqlConnection cxn;
        SqlDataReader reader;
        int masterkeyver;
        byte[] encPassword = null;

        Output.WriteDebug("Opening connection to " + server + "...");
        cxn = new SqlConnection("server="+ server + ";trusted_connection=true;database=uodb");
        //cxn = new SqlConnection("server="+ server + ";uid=sa;password=Suck!H3ad;database=uodb");
        cxn.Open();


        Output.WriteDebug("Getting service keys...");
        cmd = new SqlCommand("p_xbos_get_raw_sps_info", cxn);
        cmd.CommandType = CommandType.StoredProcedure;
        SqlParameter sqlUsername = cmd.Parameters.Add("@username", SqlDbType.NVarChar, 200);
        SqlParameter sqlPassword = cmd.Parameters.Add("@password", SqlDbType.VarBinary, 256);
        SqlParameter sqlWsdlLocation = cmd.Parameters.Add("@wsdllocation", SqlDbType.NVarChar, 200);
        SqlParameter sqlKeyVer = cmd.Parameters.Add("@i_masterkeyversion", SqlDbType.Int);
        sqlUsername.Direction = ParameterDirection.Output;
        sqlPassword.Direction = ParameterDirection.Output;
        sqlWsdlLocation.Direction = ParameterDirection.Output;
        sqlKeyVer.Direction = ParameterDirection.Output;

        reader = cmd.ExecuteReader();
        reader.Close();

        Username = (string)sqlUsername.Value;
        encPassword = (byte[])sqlPassword.Value;
        WsdlLocation = (string)sqlWsdlLocation.Value;
        masterkeyver = (int)sqlKeyVer.Value;

        cxn.Close();

        // check the master key version
        if ( masterkeyver == 0 )
        {
            UnicodeEncoding UE = new UnicodeEncoding();
            Password = UE.GetString(encPassword);
        }
        else
        {
            Output.WriteDebug("Impersonating " + iisuser);

            Output.WriteLine("Password for " + iisuser + ": ");
            string pwd = ConsoleEx.ReadHiddenLine();
            Console.WriteLine("");

            string[] userDomain = iisuser.Split( new char[] { '\\' });
            string user = iisuser;
            string domain = "";
            if (userDomain.Length == 2)
            {
                domain = userDomain[0];
                user = userDomain[1];
            }

            int token;

            bool loggedOn = LogonUser(user, domain, pwd, 3, 0, out token);
            if (!loggedOn)
            {
                throw new Exception("ERROR: LogonUser() failed, unable to decrypt SPS service key: " + GetLastError());
            }
            else
            {
                ASCIIEncoding AE = new ASCIIEncoding();
                IntPtr tokenPtr = new IntPtr(token);
                WindowsIdentity wi = new WindowsIdentity(tokenPtr);
                WindowsImpersonationContext impCtx = wi.Impersonate();

                Password = AE.GetString(KEKCryptoMgr.DecryptWithMasterKeyWrp( (uint)masterkeyver, (uint)encPassword.Length, encPassword ));

                // revert to previous identity
                impCtx.Undo();
            }

        }


    /***** CODE BELOW IS LEGACY FOR WEBSTORE USE.  IT CAN BE REVIVED IF NECESSARY/DESIRABLE. ***

        WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
        int masterkeyver = 0;

        ws.ClearParameters();
        // TODO:  RENAME THIS STORED PROC.
        ws.StoredProc = "p_xbos_get_raw_sps_info";

        // intput and output params
        ws.AddParameter(ParamType.OUTPUT, "", 200);     // partner username
        ws.AddParameter(ParamType.OUTPUT, (byte[])null, 256);     // partner key
        ws.AddParameter(ParamType.OUTPUT, "", 200);     // partner WSDL location
        ws.AddParameter(ParamType.OUTPUT, 0);           // master key version to do decryption

        // call the procedure
        ws.ExecuteNonQuery();


        Username = ws.GetStringParameter(0);
        masterkeyver = ws.GetIntParameter(3);
        WsdlLocation = ws.GetStringParameter(2);

        // check the master key version
        if ( masterkeyver == 0 )
        {
            UnicodeEncoding UE = new UnicodeEncoding();
            Password = UE.GetString(ws.GetByteArrayParameter(1) );
        }
        else
        {
            ASCIIEncoding AE = new ASCIIEncoding();
            byte[] encPassword = ws.GetByteArrayParameter(1);
            Password = AE.GetString(KEKCryptoMgr.DecryptWithMasterKeyWrp( (uint)masterkeyver, (uint)encPassword.Length, encPassword ));
        }
        */
    }


}



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BillingXCheck\statler\ConsoleEx.cs ===
// ConsoleEx V1.02 - Tim Sneath <tims@microsoft.com>

// ReadHiddenLine: Ben Zotto (benzotto@xbox.com)

using System;
using System.Runtime.InteropServices;
using System.Text;

namespace xonline.tools.billingxcheck.statler 
{
	/// <summary>
	/// This class provides supplemental functionality to that available in the System.Console class. It 
	/// allows a developer to control the cursor location, size and visibility, to manipulate the color
	/// used for writing text on the screen, to read characters individually from the input buffer, to 
	/// manipulate the console window title, to clear the screen and to draw rectangles on the screen. It 
	/// does not replace traditional functions supplied in the System.Console class such as WriteLine() 
	/// and ReadLine(), but is intended to be use in conjunction with calls to that class.
	/// </summary>
	/// <remarks>
	/// This class is largely built using information from the Platform SDK. Documentation on the 
	/// Console APIs within kernel32 can be found at the following location:
	///       http://msdn.microsoft.com/library/en-us/dllproc/base/character_mode_applications.asp
	///
	/// Several of the functions within this class are reworked and expanded versions of those
	/// found in KnowledgeBase articles Q319883 and Q319257.
	/// </remarks>
	public class ConsoleEx
	{	

		#region API and Structure Declarations

		// Standard structures used for interop with kernel32
		[StructLayout(LayoutKind.Sequential)]
			struct COORD
		{
			public short x;
			public short y;
		}

		[StructLayout(LayoutKind.Sequential)]
			struct SMALL_RECT
		{
			public short Left;
			public short Top;
			public short Right;
			public short Bottom;
		}
		
		[StructLayout(LayoutKind.Sequential)]
			struct CONSOLE_SCREEN_BUFFER_INFO
		{
			public COORD dwSize;
			public COORD dwCursorPosition;
			public int wAttributes;
			public SMALL_RECT srWindow;
			public COORD dwMaximumWindowSize;
		}

		[StructLayout(LayoutKind.Sequential)]
			struct CONSOLE_CURSOR_INFO 
		{
			public int dwSize;  
			public bool bVisible;
		} 


		// External function declarations
		[DllImport("kernel32.dll", EntryPoint="GetStdHandle", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int GetStdHandle(int nStdHandle);

		[DllImport("kernel32.dll", EntryPoint="GetConsoleScreenBufferInfo", SetLastError=true, 
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int GetConsoleScreenBufferInfo(int hConsoleOutput,
			ref CONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleTextAttribute", SetLastError=true, 
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int SetConsoleTextAttribute(int hConsoleOutput,
			int wAttributes);

		[DllImport("kernel32.dll", EntryPoint="FillConsoleOutputCharacter", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int FillConsoleOutputCharacter(int hConsoleOutput, 
			byte cCharacter, int nLength, COORD dwWriteCoord, ref int lpNumberOfCharsWritten);

		[DllImport("kernel32.dll", EntryPoint="FillConsoleOutputAttribute", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int FillConsoleOutputAttribute(int hConsoleOutput,
			int wAttribute, int nLength, COORD dwWriteCoord, ref int lpNumberOfAttrsWritten);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleCursorPosition", SetLastError=true, 
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int SetConsoleCursorPosition(int hConsoleOutput, 
			COORD dwCursorPosition);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleTitle", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern bool SetConsoleTitle(string lpConsoleTitle);

		[DllImport("kernel32.dll", EntryPoint="GetConsoleTitle", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int GetConsoleTitle(StringBuilder lpConsoleTitle, 
			int nSize);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleCursorInfo", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int SetConsoleCursorInfo(int hConsoleOutput, 
			ref CONSOLE_CURSOR_INFO lpConsoleCursorInfo);

		[DllImport("kernel32.dll", EntryPoint="GetConsoleCursorInfo", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int GetConsoleCursorInfo(int hConsoleOutput, 
			ref CONSOLE_CURSOR_INFO lpConsoleCursorInfo);
		
		[DllImport("kernel32.dll", EntryPoint="ReadConsole", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern bool ReadConsole(int hConsoleInput,
			StringBuilder buf, int nNumberOfCharsToRead, ref int lpNumberOfCharsRead, int lpReserved);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleMode", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern bool SetConsoleMode(int hConsoleHandle,
			int dwMode);

		[DllImport("kernel32.dll", EntryPoint="GetConsoleMode", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern bool GetConsoleMode(int hConsoleHandle,
			ref int dwMode);

		#endregion


		// Const variables
		private const int  INVALID_HANDLE_VALUE    = -1;
		private const int  STD_INPUT_HANDLE        = -10;
		private const int  STD_OUTPUT_HANDLE       = -11;
		private const byte EMPTY                   = 32;
		private const int  TITLE_LENGTH            = 1024;

		// Internal variables
		private static int hConsoleOutput;	// handle to output buffer
		private static int hConsoleInput;	// handle to input buffer
		private static COORD ConsoleOutputLocation;
		private static CONSOLE_SCREEN_BUFFER_INFO ConsoleInfo;
		private static int OriginalConsolePen;
		private static int CurrentConsolePen;

		
		// Constructors
		static ConsoleEx()
		{
			// Grab input and output buffer handles
			hConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE);
			hConsoleInput = GetStdHandle(STD_INPUT_HANDLE);
			if (hConsoleOutput == INVALID_HANDLE_VALUE || hConsoleInput == INVALID_HANDLE_VALUE)
				throw new ApplicationException("Unable to obtain buffer handle during initialization.");

			// Get information about the console window characteristics.
			ConsoleInfo = new CONSOLE_SCREEN_BUFFER_INFO();
			ConsoleOutputLocation = new COORD();
			GetConsoleScreenBufferInfo(hConsoleOutput, ref ConsoleInfo);
			OriginalConsolePen = ConsoleInfo.wAttributes;

			// Disable wrapping at the end of a line (ENABLE_WRAP_AT_EOL_INPUT); this enables rectangles 
			// to be drawn that fill the screen without the window scrolling.
			SetConsoleMode(hConsoleOutput, 
				(int) OutputModeFlags.ENABLE_PROCESSED_OUTPUT);
		}

		private ConsoleEx() : base()
		{
			throw new NotSupportedException("This object may not be instantiated. Use static methods instead.");
		}


		/// <summary>
		/// Sets or gets the console window title.
		/// </summary>
		public static string Title 
		{
			get
			{
				StringBuilder title = new StringBuilder(TITLE_LENGTH);
				int ret = GetConsoleTitle(title, TITLE_LENGTH);
				return title.ToString(0, ret);
			}
			set 
			{	
				if (value.Length < TITLE_LENGTH)
					SetConsoleTitle(value);
				else
					throw new ArgumentOutOfRangeException(
						"Title", 
						value, 
						"Console window title must be no more than " + TITLE_LENGTH +  " characters.");
			}
		}


		/// <summary>
		/// Gets or sets the visibility of the cursor.
		/// </summary>
		public static bool CursorVisible
		{
			get
			{
				CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
				GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
				return ConsoleCursorInfo.bVisible;
			}
			set
			{
				// Obtain current cursor information, since the CONSOLE_CURSOR_INFO struct
				// also contains information on the shape of the cursor.
				CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
				GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);

				ConsoleCursorInfo.bVisible = value;
				SetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
			}
		}


		/// <summary>
		/// Gets or sets the height of the cursor, as a percentage of the overall character cell.
		/// The value must be a number between 1 and 100, otherwise an ArgumentOutOfRangeException
		/// will be thrown.
		/// </summary>
		public static int CursorHeight
		{
			get
			{
				CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
				GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
				return ConsoleCursorInfo.dwSize;
			}
			set
			{
				if (value >= 1 && value <= 100)
				{
					// Obtain current cursor information, since the CONSOLE_CURSOR_INFO struct
					// also contains information on the visibility of the cursor.
					CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
					GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);

					ConsoleCursorInfo.dwSize = value;
					SetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
				}
				else
					throw new ArgumentOutOfRangeException(
						"CursorHeight", 
						value, 
						"Cursor height must be a percentage of the character cell between 1 and 100.");
			}
		}


		/// <summary>
		/// Sets the console pen color to that specified.
		/// </summary>
		/// <param name="foreground">A foreground color specified from the 
		/// ConsoleForeground enumeration</param>
		/// <param name="background">A background color specified from the 
		/// ConsoleBackground enumeration</param>
		public static void TextColor(ConsoleForeground foreground, ConsoleBackground background)
		{
			CurrentConsolePen = (int)foreground + (int)background;
			SetConsoleTextAttribute(hConsoleOutput, CurrentConsolePen);
		}
	

		/// <summary>
		/// Resets the console pen color to the original default at the time 
		/// the class was originally initialised.
		/// </summary>
		public static void ResetColor()
		{
			SetConsoleTextAttribute(hConsoleOutput, OriginalConsolePen);
		}
	

		/// <summary>
		/// Clears screen.
		/// </summary>
		public static void Clear()
		{
			int hWrittenChars = 0;
			CONSOLE_SCREEN_BUFFER_INFO strConsoleInfo = new CONSOLE_SCREEN_BUFFER_INFO();			
			COORD Home;		
			Home.x = Home.y = 0;
			
			if (GetConsoleScreenBufferInfo(hConsoleOutput, ref strConsoleInfo) == 0)
			{
				// If the device does not support GetConsoleScreenBufferInfo, then try just
				// writing ^L (ASCII control code for Form Feed) to the screen. This may 
				// work for some scenarios such as using telnet to access a remote console.
				Console.Write('\x0c');	// ^L
				return;
			}
			
			FillConsoleOutputCharacter(hConsoleOutput, EMPTY, 
				strConsoleInfo.dwSize.x * strConsoleInfo.dwSize.y, Home, ref hWrittenChars);
			FillConsoleOutputAttribute(hConsoleOutput, CurrentConsolePen, 
				strConsoleInfo.dwSize.x * strConsoleInfo.dwSize.y, Home, ref hWrittenChars);
			
			SetConsoleCursorPosition(hConsoleOutput, Home);
		}


		/// <summary>
		/// Moves the console cursor to the specified location on the screen.
		/// </summary>
		/// <param name="x">X co-ordinate for desired location (typically 0 to 79)</param>
		/// <param name="y">Y co-ordinate for desired location (typically 0 to 24)</param>
		public static void Move(int x, int y)
		{
			// Check that parameters specified are sane
			CONSOLE_SCREEN_BUFFER_INFO strConsoleInfo = new CONSOLE_SCREEN_BUFFER_INFO();
			GetConsoleScreenBufferInfo(hConsoleOutput, ref strConsoleInfo);

			if (x >= strConsoleInfo.dwSize.x ||  x < 0)
				throw new ArgumentOutOfRangeException("x", x, 
					"The co-ordinates specified must be within the dimensions of the window.");

			if (y >= strConsoleInfo.dwSize.y || y < 0)
				throw new ArgumentOutOfRangeException("y", y, 
					"The co-ordinates specified must be within the dimensions of the window.");

			COORD Location;
			Location.x = (short)x;
			Location.y = (short)y;

			SetConsoleCursorPosition(hConsoleOutput, Location);
		}


		/// <summary>
		/// Writes the specified text at the given location.
		/// </summary>
		/// <remarks>
		/// This is a wrapper function that provides a shorthand for moving to a location and 
		/// writing there. The cursor will be left in the position immediately succeeding the 
		/// rightmost character of the text written to the screen.
		/// </remarks>
		/// <param name="x">X co-ordinate for leftmost character of text</param>
		/// <param name="y">Y co-ordinate for location of text</param>
		/// <param name="text">String to be written to the screen</param>
		public static void WriteAt(int x, int y, string text)
		{
			// No need to validate x and y co-ordinates as they will be tested by Move()
			Move(x, y);

			Console.Write(text);
		}


		/// <summary>
		/// Draws a rectangle on the console window using either 7-bit ASCII characters or
		/// line drawing characters, depending on the style specified. If the dimensions of 
		/// the rectangle exceed the boundaries of the screen, an ArgumentOutOfRangeException
		/// will be thrown.
		/// </summary>
		/// <remarks>
		/// Note that the sides of the rectangle themselves are one character wide,
		/// so, for example, a width and height of 2 will result in a 3-by-3 character rectangle.
		/// This matches the behavior of the equivalent Windows Forms DrawRectangle() method.
		/// </remarks>
		/// <param name="style">A border style specified from the BorderStyle enumeration</param>
		/// <param name="x">X co-ordinate of upper left corner of rectangle</param>
		/// <param name="y">Y co-ordinate of upper left corner of rectangle</param>
		/// <param name="cx">Width of the rectangle</param>
		/// <param name="cy">Height of the rectangle</param>
		public static void DrawRectangle(BorderStyle style, int x, int y, int cx, int cy, bool fill)
		{
			if (style != BorderStyle.None)
			{
				// Set rectangle frame appropriately for the style chosen. Unicode 
				// characters represent horizontal and vertical lines, then NW, NE,
				// SW and SE corners of the rectangle in that order.
				string frame;
				switch(style)
				{
					case BorderStyle.LineSingle:
						frame = "\u2500\u2502\u250c\u2510\u2514\u2518";
						break;
					case BorderStyle.LineDouble:
						frame = "\u2550\u2551\u2554\u2557\u255A\u255D";
						break;
					default:
						frame = @"-|/\\/";
						break;
				}

				// Create top line of box
				StringBuilder line = new StringBuilder(cx+1);
				line.Append(frame[2]);
				for (int i=1; i < cx; i++) line.Append(frame[0]);
				line.Append(frame[3]);
				Move(x, y);
				Console.Write(line);

				// Create sides of box
				for (int i=1; i < cy; i++)
				{
					Move(x, y+i);
					Console.Write(frame[1]);
					Move(x+cx, y+i);
					Console.Write(frame[1]);
				}

				// Create bottom line of box
				line[0] = frame[4];
				line[cx] = frame[5];
				Move(x, y+cy);
				Console.Write(line);
			}
		
			// Fill rectangle with current console pen
			if (fill)
			{
				int hWrittenChars = 0;
				COORD c = new COORD();
				c.x = (short)x;
			
				for (int i=0; i<=cy; i++)
				{
					c.y = (short)(y + i);
					FillConsoleOutputAttribute(hConsoleOutput, CurrentConsolePen, 
						cx + 1, c, ref hWrittenChars);
				}
			}
		}

		
		/// <summary>
		/// Read a single character from the input buffer. Unlike Console.Read(), which 
		/// only reads from the buffer when the read operation has terminated (e.g. by
		/// pressing Enter), this method reads as soon as the character has been entered.
		/// </summary>
		/// <returns>The character read by the system</returns>
		public static char ReadChar()
		{
			// Temporarily disable character echo (ENABLE_ECHO_INPUT) and line input
			// (ENABLE_LINE_INPUT) during this operation
			SetConsoleMode(hConsoleInput, 
				(int) (InputModeFlags.ENABLE_PROCESSED_INPUT | 
				InputModeFlags.ENABLE_WINDOW_INPUT | 
				InputModeFlags.ENABLE_MOUSE_INPUT));

			int lpNumberOfCharsRead = 0;
			StringBuilder buf = new StringBuilder(1);

			bool success = ReadConsole(hConsoleInput, buf, 1, ref lpNumberOfCharsRead, 0);
			
			// Reenable character echo and line input
			SetConsoleMode(hConsoleInput, 
				(int) (InputModeFlags.ENABLE_PROCESSED_INPUT | 
				InputModeFlags.ENABLE_ECHO_INPUT |
				InputModeFlags.ENABLE_LINE_INPUT |
				InputModeFlags.ENABLE_WINDOW_INPUT | 
				InputModeFlags.ENABLE_MOUSE_INPUT));
			
			if (success)
				return Convert.ToChar(buf[0]);
			else 
				throw new ApplicationException("Attempt to call ReadConsole API failed.");
		}
        
        ///
        /// BenZotto wrote this for BillingXCheck
        ///
        public static string ReadHiddenLine()
        {
            StringBuilder sb = new StringBuilder();
            char c;
            
            while((c = ReadChar()) != '\r' && c != '\n')
            {
                sb.Append(c);
            }
            
            return sb.ToString();
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BillingXCheck\statler\SPS.cs ===
//
//  SPS.cs
//
//  Ben Zotto (benzotto), October 2002
//
//
using System;
using System.Collections;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Diagnostics;
using System.Text.RegularExpressions;
                                  
                                     
namespace xonline.tools.billingxcheck.statler 
{

    class SPS
    {
        private static BillingProvider _bdk = null;
        public static string Server;
        public static string IISUser;
                        
        public static int CheckOfferInBilling(string offeringID, string serviceComponentID, string opd)
        {
            if(_bdk == null) { _bdk = new BillingProvider(Server, IISUser); }
            
            int errorCount = 0;
            string errorText;
            int    offeringInfoCount, serviceComponentCount;
            string offeringInfoSet, serviceComponentSet;
            
            try
            {
                _bdk.GetBaseOfferings(offeringID, "", "", "en-US", "", out errorText, out offeringInfoCount, out offeringInfoSet);
            }
            catch (Exception e)
            {                
                if(e.Message.StartsWith("<ErrorPackage><ErrorHResult>0x80049E84"))
                {
                    errorCount++;
                    Output.WriteLine("FAIL: SPS doesn't know about offering " + offeringID + " (in expected en-US locale, anyways)");
                    return errorCount;
                }
                else
                    throw;
            }
            
            if(offeringInfoCount != 1)
            {
                    errorCount++;
                    Output.WriteLine("FAIL: SPS reports " + offeringInfoCount + " offerings matching " + offeringID + "!");
                    Output.WriteVerbose("\t(in en-US locale, anyways)");
                    return errorCount;                
            }
            
            //
            // get info set            
            //             
            if(opd != null && opd != "")
            {            
                OfferingInfoSet ois = new OfferingInfoSet();
                ois.FromXml(offeringInfoSet);            
                
                if(opd != ois.OfferingPriceDescription.Trim())
                {
                    errorCount++;
                    Output.WriteLine("WARNING: Offer " + offeringID + " has mismatching OPD set!");
                    Output.WriteVerbose("\tin SPS: \"" + ois.OfferingPriceDescription + "\" expecting: \"" + opd + "\"");                            
                }
            }
            
            //
            // Get Service Compoent info
            //                                 
            if(serviceComponentID != null && serviceComponentID != "")
            {
                try
                {
                    _bdk.GetServiceComponents(offeringID, out errorText, out serviceComponentCount, out serviceComponentSet);
                }
                catch (Exception e)
                {                
                    if(e.Message.StartsWith("<ErrorPackage><ErrorHResult>0x80049E84"))
                    {
                        errorCount++;
                        Output.WriteLine("FAIL: SPS doesn't know about offering " + offeringID);
                        return errorCount;
                    }
                    else
                        throw;
                }
                
                if(serviceComponentCount != 1)
                {
                        errorCount++;
                        Output.WriteLine("FAIL: SPS reports " + serviceComponentCount + " components matching " + offeringID + "!");
                        Output.WriteVerbose("\t(in en-US locale, anyways)");
                        return errorCount;                
                }
                
                ServiceComponentSet scs = new ServiceComponentSet();
                scs.FromXml(serviceComponentSet);            
                
                if(serviceComponentID.ToUpper() != scs.ServiceComponentId.ToUpper())
                {
                    errorCount++;
                    Output.WriteLine("WARNING: Offer " + offeringID + " has mismatching Service Component!");
                    Output.WriteVerbose("\tin SPS: \"" + scs.ServiceComponentId + "\" expecting: \"" + serviceComponentID + "\"");                            
                }
                
            }                                 
                                        
            return errorCount; 
        }
                
    }
    
    
    public class OfferingInfoSet
    {
        public string   OfferingGUID;
        public string   OfferingDescription;
        public string   OfferingPriceDescription;
        public string   InternalOfferingDescription;
        public string   LastAvailableDate;
        public string   FirstAvailableDate;
        public string   BaseOffering;
        public string   TermLocation;
        public string   CommitmentTerms;
        public string   MutuallyExclusiveGroupIdSet;
        public string   SignUpURL;
        public string   PaymentInstrumentRequired;                
        public string   PaymentTypeSet;
        public string   PaymentType;
            
        public OfferingInfoSet()
        {
        }
    
        public void FromXml(string xml)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
            FromXml(xmlReader, "OfferingInfoSet");
            xmlReader.Close();
        }
    
        public void FromXml(XmlTextReader xmlReader, string rootNodeName)
        {
            xmlReader.MoveToContent(); 
    
            while (!xmlReader.EOF)   
            {
                if (xmlReader.NodeType == XmlNodeType.EndElement &&
                    (xmlReader.Name == rootNodeName))
                {
                    xmlReader.Skip();
                    break;
                }
    
                if (xmlReader.NodeType != XmlNodeType.Element)
                {
                    xmlReader.Skip();
                    continue;
                }
    
                switch (xmlReader.Name)
                {
                    case "OfferingGUID":
                       OfferingGUID = xmlReader.ReadElementString();
                       break;
    
                    case "OfferingDescription":
                        OfferingDescription = xmlReader.ReadElementString();
                        break;
    
                    case "OfferingPriceDescription":
                        OfferingPriceDescription = xmlReader.ReadElementString();
                        break;
    
                    case "InternalOfferingDescription":
                        InternalOfferingDescription = xmlReader.ReadElementString();
                        break;
    
                    case "LastAvailableDate":
                        LastAvailableDate = xmlReader.ReadElementString();
                        break;
    
                    case "FirstAvailableDate":
                        FirstAvailableDate = xmlReader.ReadElementString();
                        break;
    
                    case "BaseOffering":
                        BaseOffering = xmlReader.ReadElementString();
                        break;
    
                    case "TermLocation":
                        TermLocation = xmlReader.ReadElementString();
                        break;
    
                    case "CommitmentTerms":
                        CommitmentTerms = xmlReader.ReadElementString();
                        break;
    
                    case "MutuallyExclusiveGroupIdSet":
                        MutuallyExclusiveGroupIdSet = xmlReader.ReadElementString();
                        break;
    
                    case "SignUpURL":
                        SignUpURL = xmlReader.ReadElementString();
                        break;
    
                    case "PaymentInstrumentRequired":
                        PaymentInstrumentRequired = xmlReader.ReadElementString();
                        break;
    
                    case "PaymentType":
                        if(PaymentType == null)
                        {
                            PaymentType = xmlReader.ReadElementString();
                        }
                        else
                        {   
                            Output.WriteLine("WARNING: Offering " + OfferingGUID + " has multiple payment types defined.");
                            xmlReader.ReadElementString();
                        }
                        break;   
    
                    default:
                        if (xmlReader.Name == rootNodeName)
                        {
                            // advance to the first inner element
                            xmlReader.ReadStartElement();
                            break;
                        }
                        
                        if (xmlReader.Name == "OfferingInfo")
                        {
                            xmlReader.ReadStartElement();
                            break;
                        }
                        
                        if (xmlReader.Name == "PaymentTypeSet")
                        {
                            xmlReader.ReadStartElement();
                            break;
                        }
                        

                        
                        xmlReader.Skip();
                        break;
                }
            }
        }        
    }    
    
    public class ServiceComponentSet
    {                
        public string   ServiceComponentId;
        public string   InstanceCount;
        public string   ServiceComponentName;
        public string   MaxRoles;
            
        public ServiceComponentSet()
        {
        }
    
        public void FromXml(string xml)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
            FromXml(xmlReader, "ServiceComponentSet");
            xmlReader.Close();
        }
    
        public void FromXml(XmlTextReader xmlReader, string rootNodeName)
        {
            xmlReader.MoveToContent(); 
    
            while (!xmlReader.EOF)   
            {
                if (xmlReader.NodeType == XmlNodeType.EndElement &&
                    (xmlReader.Name == rootNodeName))
                {
                    xmlReader.Skip();
                    break;
                }
    
                if (xmlReader.NodeType != XmlNodeType.Element)
                {
                    xmlReader.Skip();
                    continue;
                }
    
                switch (xmlReader.Name)
                {
                    case "ServiceComponentId":
                       ServiceComponentId = xmlReader.ReadElementString();
                       break;
    
                    case "InstanceCount":
                        InstanceCount = xmlReader.ReadElementString();
                        break;
    
                    case "ServiceComponentName":
                        ServiceComponentName = xmlReader.ReadElementString();
                        break;
    
                    case "MaxRoles":
                        MaxRoles = xmlReader.ReadElementString();
                        break;
    
       
                    default:
                        if (xmlReader.Name == rootNodeName)
                        {
                            // advance to the first inner element
                            xmlReader.ReadStartElement();
                            break;
                        }
                        
                        if (xmlReader.Name == "ServiceComponent")
                        {
                            xmlReader.ReadStartElement();
                            break;
                        }                                                
                        
                        xmlReader.Skip();
                        break;
                }
            }
        }
        
    
        
    
            
    }      
        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BillingXCheck\statler\Enum.cs ===
// Enumerations used for setting console window colors.
using System;

namespace xonline.tools.billingxcheck.statler 
{
	/// <summary>
	/// Color definitions for the console foreground.
	/// </summary>
	public enum ConsoleForeground
	{	
		Black      = 0x00,
		Navy       = 0x01,
		DarkGreen  = 0x02,
		Aquamarine = 0x03,
		Maroon     = 0x04,
		Purple     = 0x05,
		Olive      = 0x06,
		LightGray  = 0x07,
		DarkGray   = 0x08,
		Blue       = 0x09,
		Green      = 0x0A,
		Cyan       = 0x0B,
		Red        = 0x0C,
		Magenta    = 0x0D,
		Yellow     = 0x0E,
		White      = 0x0F
	}


	/// <summary>
	/// Color definitions for the console background.
	/// </summary>
	public enum ConsoleBackground
	{	
		Black      = 0x00,
		Navy       = 0x10,
		DarkGreen  = 0x20,
		Aquamarine = 0x30,
		Maroon     = 0x40,
		Purple     = 0x50,
		Olive      = 0x60,
		LightGray  = 0x70,
		DarkGray   = 0x80,
		Blue       = 0x90,
		Green      = 0xA0,
		Cyan       = 0xB0,
		Red        = 0xC0,
		Magenta    = 0xD0,
		Yellow     = 0xE0,
		White      = 0xF0
	}


	/// <summary>
	/// Border styles used for drawing rectangles on the console output window.
	/// </summary>
	public enum BorderStyle
	{
		None,
		Text,
		LineSingle,
		LineDouble
	}


	[Flags]
	public enum InputModeFlags
	{
		ENABLE_PROCESSED_INPUT = 0x01,
		ENABLE_LINE_INPUT      = 0x02,
		ENABLE_ECHO_INPUT      = 0x04,
		ENABLE_WINDOW_INPUT    = 0x08,
		ENABLE_MOUSE_INPUT     = 0x10
	}

	[Flags]
	public enum OutputModeFlags
	{
		ENABLE_PROCESSED_OUTPUT   = 0x01,
		ENABLE_WRAP_AT_EOL_OUTPUT = 0x02
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BillingXCheck\statler\bdk.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.0
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.0.3705.0.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
// CODEGEN: The optional WSDL extension element 'binding' from namespace 'http://schemas.microsoft.com/soap-toolkit/wsdl-extension' was not handled.
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="BDKServerObj2SoapBinding", Namespace="http://tempuri.org/wsdl/")]
public class bdk : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public bdk() {
        this.Url = "https://sps25tiexbox1.tiexbox1.ssd.extest.microsoft.com/bdk2/bdk.WSDL";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.Invoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID});
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitsForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForObjectId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.Invoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep});
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitsForObjectId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountId = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrDate = ((string)(results[3]));
        bstrRequiredPaperWorkURL = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountId = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrDate = ((string)(results[3]));
        bstrRequiredPaperWorkURL = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
        object[] results = this.Invoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrRequiredPaperWorkURL = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrRequiredPaperWorkURL = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ActivateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ActivateAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.Invoke("ActivateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginActivateAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ActivateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndActivateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionStatusFromPaymentInstru" +
"ment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrStatusChange,
                    bstrPaymentInstrumentInfoXML,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrStatusChange,
                    bstrPaymentInstrumentInfoXML,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateSubscriptionStatusFromPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromAdminPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromAdminPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrPaymentInstrumentId = ((string)(results[1]));
        pbstrRequiredPaperWorkURL = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrPaymentInstrumentId = ((string)(results[1]));
        pbstrRequiredPaperWorkURL = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.Invoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdatePaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdatePaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemovePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
        object[] results = this.Invoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemovePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReplacePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReplacePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("ReplacePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrRequiredPaperWorkURL = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReplacePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReplacePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReplacePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrRequiredPaperWorkURL = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SettleBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSettleBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TransferBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void TransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTransferBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SwitchPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSwitchPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddComment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddComment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetComments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
        object[] results = this.Invoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        plCommentInfoSetCount = ((int)(results[1]));
        pbstrCommentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetComments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plCommentInfoSetCount = ((int)(results[1]));
        pbstrCommentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOffering", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void PurchaseOffering(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                out string pbstrErrorXML, 
                out string pbstrSubscriptionId, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceCount, 
                out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.Invoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPurchaseOffering(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndPurchaseOffering(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
        object[] results = this.Invoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        plRemovedServiceInstanceCount = ((int)(results[3]));
        pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        plRemovedServiceInstanceCount = ((int)(results[3]));
        pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchAccounts", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSearchAccounts(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptions", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
        object[] results = this.Invoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
        plSubscriptionInfoCount = ((int)(results[1]));
        pbstrSubscriptionInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptions(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plSubscriptionInfoCount = ((int)(results[1]));
        pbstrSubscriptionInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.Invoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptionStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReferralData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
        object[] results = this.Invoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plReferralCount = ((int)(results[1]));
        pbstrReferralSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetReferralData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plReferralCount = ((int)(results[1]));
        pbstrReferralSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ConvertSubscription(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                out string pbstrErrorXML, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceSetCount, 
                out string pbstrAddedServiceInstanceSet, 
                out int plRemovedServiceInstanceSetCount, 
                out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginConvertSubscription(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndConvertSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateSubscriptionInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.Invoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBaseOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetEligibleOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetServiceComponents", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetServiceComponents(string bstrOfferingGUID, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
        object[] results = this.Invoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID});
        pbstrErrorText = ((string)(results[0]));
        plServiceComponentCount = ((int)(results[1]));
        pbstrServiceComponentSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetServiceComponents(string bstrOfferingGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetServiceComponents(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plServiceComponentCount = ((int)(results[1]));
        pbstrServiceComponentSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ValidateProvisioningData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.Invoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndValidateProvisioningData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CheckProvisioningStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.Invoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCheckProvisioningStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ProvisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndProvisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeprovisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void DeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginDeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndDeprovisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportUsageEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReportUsageEvent(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourceBalances", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
        object[] results = this.Invoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID});
        pbstrErrorText = ((string)(results[0]));
        pcResourceInfoCount = ((int)(results[1]));
        pbstrResourceInfoSet = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetResourceBalances(System.IAsyncResult asyncResult, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        pcResourceInfoCount = ((int)(results[1]));
        pbstrResourceInfoSet = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustResourceBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustResourceBalance(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreditPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void OffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginOffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndOffsetLineItem(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TestConnection", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void TestConnection(string bstrInputString, out string pbstrOutputString) {
        object[] results = this.Invoke("TestConnection", new object[] {
                    bstrInputString});
        pbstrOutputString = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTestConnection(string bstrInputString, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TestConnection", new object[] {
                    bstrInputString}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTestConnection(System.IAsyncResult asyncResult, out string pbstrOutputString) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrOutputString = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnbanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnbanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.IsPaymentInstrumentBanned", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void IsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plIsBanned) {
        object[] results = this.Invoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        plIsBanned = ((int)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginIsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndIsPaymentInstrumentBanned(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plIsBanned) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plIsBanned = ((int)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.StopPayments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void StopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
        object[] results = this.Invoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginStopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndStopPayments(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountActivity", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
        object[] results = this.Invoke("GetAccountActivity", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    lBillingPeriodId,
                    bstrLocale,
                    fDeep});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountActivityXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountActivity", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    lBillingPeriodId,
                    bstrLocale,
                    fDeep}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountActivity(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountActivityXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBillingPeriods", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
        object[] results = this.Invoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale});
        pbstrErrorXML = ((string)(results[0]));
        plBillingPeriodCount = ((int)(results[1]));
        pbstrBillingPeriodSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBillingPeriods(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plBillingPeriodCount = ((int)(results[1]));
        pbstrBillingPeriodSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SyncUPSCacheForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, out string pbstrErrorXML) {
        object[] results = this.Invoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSyncUPSCacheForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetKey", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, out string pbstrErrorXML, out string pbstrKeyXml) {
        object[] results = this.Invoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid});
        pbstrErrorXML = ((string)(results[0]));
        pbstrKeyXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetKey(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrKeyXml) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrKeyXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAdjustments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
        object[] results = this.Invoke("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId});
        pbstrErrorXML = ((string)(results[0]));
        pcAppliedAdjustmentCount = ((int)(results[1]));
        pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
        pcAvailableAdjustmentCount = ((int)(results[3]));
        pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAdjustments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pcAppliedAdjustmentCount = ((int)(results[1]));
        pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
        pcAvailableAdjustmentCount = ((int)(results[3]));
        pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CompleteConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCompleteConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plAddedServiceInstanceSetCount = ((int)(results[1]));
        pbstrAddedServiceInstanceSet = ((string)(results[2]));
        plRemovedServiceInstanceSetCount = ((int)(results[3]));
        pbstrRemoveServiceInstanceSet = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plAddedServiceInstanceSetCount = ((int)(results[1]));
        pbstrAddedServiceInstanceSet = ((string)(results[2]));
        plRemovedServiceInstanceSetCount = ((int)(results[3]));
        pbstrRemoveServiceInstanceSet = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ImportSettledBillingItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, out string pbstrResultXML) {
        object[] results = this.Invoke("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML});
        pbstrResultXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndImportSettledBillingItem(System.IAsyncResult asyncResult, out string pbstrResultXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrResultXML = ((string)(results[0]));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BillingXCheck\waldorf\Repository.cs ===
//
//  Repository.cs
//
//  Ben Zotto (benzotto), September 2002
//
//
using System;
using System.Collections;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Diagnostics;
using System.Text.RegularExpressions;
                                  
                                     
namespace xonline.tools.billingxcheck.waldorf 
{

    class Repository
    {           
    
        public Repository()
        {
                   
        }
        
        
        public Stream OpenForRead(string filename)
        {
            return new FileStream(filename, FileMode.Open, FileAccess.Read);
        }
                        
        public DepotEnumerator GetEnumerator(string filespec)
        {
            return new DepotEnumerator(Directory.GetCurrentDirectory(), filespec);    
        }
        
        
        //
        // Find all offerings that have billing offer IDs which are in a given PCF file.
        //
        // ASSUMPTION: when an offering has one "relevant" billing offer ID, then this tool will
        // expect ALL of that offer's Billing info to be in the PCF supplied.  So you can't later add
        // other countries to an offer with new billing GUIDs without somehow appending the old
        // PCF data to the new PCF data.
        // 
        
        public DepotOffer[] GetAllRelevantOfferings(PCF pcf)
        {   
            DepotEnumerator de = GetEnumerator("*.sql2");
            ArrayList offers   = new ArrayList();
            string filename, line;
            StreamReader thisFile;
            DepotOffer offer;
            
            while((filename = de.Next()) != null)
            {
                thisFile = new StreamReader(OpenForRead(filename));
                while((line = thisFile.ReadLine()) != null)
                {
                    foreach(PCF.PCFOffer po in pcf.Offers)
                    {
                        if(line.IndexOf(po._offeringID) > 0)
                        {   
                            Output.WriteDebug("GetAllRevelantOfferings: [" + filename + "] is relevant.");
                            offer = new DepotOffer();
                            thisFile.Close();
                            try
                            {
                                offer.LoadFromSQL2(filename);
                            } 
                            catch(Exception e)
                            {
                                Output.WriteVerbose("GetAllRelevantOfferings: FAILURE parsing .sql2 file " + filename);
                                Output.WriteDebug(e.ToString());
                                throw;
                            }
                            offers.Add(offer); 
                            goto nextfile;           
                        }
                    }
                    
                }
                
                thisFile.Close();
                
                nextfile:
                ;
            }
            Output.WriteDebug("GetAllRevelantOfferings: Returning " + offers.Count + " relevant offers.");
           
            return (DepotOffer[])offers.ToArray(Type.GetType("Waldorf.DepotOffer"));
        }
        
        //
        //  GetAllOfferings
        //        
        public DepotOffer[] GetAllOfferings()
        {   
            DepotEnumerator de = GetEnumerator("*.sql2");
            ArrayList offers   = new ArrayList();
            string filename, line;
            StreamReader thisFile;
            DepotOffer offer;
            
            while((filename = de.Next()) != null)
            {
                thisFile = new StreamReader(OpenForRead(filename));
                while((line = thisFile.ReadLine()) != null)
                {
                        Output.WriteDebug("GetAllOfferings: [" + filename + "]");
                        offer = new DepotOffer();
                        thisFile.Close();
                        try
                        {
                            offer.LoadFromSQL2(filename);
                        } 
                        catch(Exception e)
                        {
                            Output.WriteVerbose("GetAllOfferings: FAILURE parsing .sql2 file " + filename);
                            Output.WriteDebug(e.ToString());
                            throw;
                        }
                        offers.Add(offer); 
                        goto nextfile;           
                }
                
                thisFile.Close();
                
                nextfile:
                ;
            }
            Output.WriteDebug("GetAllOfferings: Returning " + offers.Count + " offers.");
           
            return (DepotOffer[])offers.ToArray(Type.GetType("Waldorf.DepotOffer"));
        }
        
        
        
        //
        // Sign off on the stuff in a PCF
        // 
        // 
        public int SignOffOnPCFOffers(DepotOffer[] tmrOffers, PCF pcf, out string[] ignoredOffers)
        {
            int errorCount = 0;
            bool bFound;
            ArrayList ignorelist = new ArrayList();
            
            foreach(PCF.PCFOffer po in pcf.Offers)
            {
                bFound = false;
                foreach(DepotOffer offer in tmrOffers)
                {
                    foreach(DepotOffer.OfferRegion or in offer.OfferRegions)
                    {
                        if(po._offeringID == or.OfferingID)
                        {
                            bFound = true;
                            //
                            //  If we're here, this depot offer has this billing GUID in it
                            //  Cross check it!!
                            //
                            
                            if(offer._startDate < Convert.ToDateTime(po._offer.StartDate) || offer._endDate > Convert.ToDateTime(po._offer.EndDate))
                            {
                                errorCount++;
                                Output.WriteLine("FAIL: Offering date mismatch offer " + po._offeringID + "!");
                                Output.WriteVerbose("\texpect range " + offer._startDate + "-" + offer._endDate + " actual range = " + po._offer.StartDate + "-" + po._offer.EndDate);
                            }
                            
//                            if(offer._offeringType == 1 && (po.opdOfferType != "basic subscription" && po.opdOfferType != "premium subscription"))
//                            {
//                                errorCount++;
//                                Output.WriteLine("WARNING: Offering type mismatch offer " + po._offeringID + "!");
//                                Output.WriteVerbose("\texpect subscription, actually is " + po.opdOfferType);                                
//                            }
//                            
//                            if(offer._offeringType == 2 && po.opdOfferType != "premium content")
//                            {
//                                errorCount++;
//                                Output.WriteLine("WARNING: Offering type mismatch offer " + po._offeringID + "!");
//                                Output.WriteVerbose("\texpect content, actually is " + po.opdOfferType);                                
//                            }
//                            
//                            if((offer._policyFlags & 0x1) != 0 && (po.opdOfferType != "basic subscription" && po.opdOfferType != "premium subscription"))
//                            {
//                                errorCount++;
//                                Output.WriteLine("WARNING: Offering flags mismatch offer " + po._offeringID + "!");
//                                Output.WriteVerbose("\texpect 0x1 or 0x101, actually is " + po.opdOfferType);                                
//                            }
//                            
//                            if((offer._policyFlags & 0x2) != 0 && po.opdOfferType != "premium content")
//                            {
//                                errorCount++;
//                                Output.WriteLine("WARNING: Offering flags mismatch offer " + po._offeringID + "!");
//                                Output.WriteVerbose("\texpect 0x2 or 0x102, actually is " + po.opdOfferType);                                
//                            }
//                            
//                            if(offer._offeringFrequency == 0 && (po.opdRecurrence != null && po.opdRecurrence != ""))
//                            {
//                                errorCount++;
//                                Output.WriteLine("WARNING: Offering frequency mismatch offer " + po._offeringID + "!");
//                                Output.WriteVerbose("\texpect nonterminating, actually is " + po.opdRecurrence);                                
//                            }
//                            
//                            if(offer._offeringFrequency == 1 && po.opdRecurrence != "monthly")
//                            {
//                                errorCount++;
//                                Output.WriteLine("WARNING: Offering frequency mismatch offer " + po._offeringID + "!");
//                                Output.WriteVerbose("\texpect monthly, actually is " + ((po.opdRecurrence == null || po.opdRecurrence == "") ? "(nonterminating)" : po.opdRecurrence));                                
//                            }
//                             
//                            if(offer._offeringFrequency == 2 && po.opdRecurrence != "yearly")
//                            {
//                                errorCount++;
//                                Output.WriteLine("WARNING: Offering frequency mismatch offer " + po._offeringID + "!");
//                                Output.WriteVerbose("\texpect yearly, actually is " + ((po.opdRecurrence == null || po.opdRecurrence == "") ? "(nonterminating)" : po.opdRecurrence));                                                               
//                            }

                            // all subs should have a service component
//                            if(po.opdOfferType != "premium content" && offer._svcComponentID != po._offer.ServiceInstanceList[0].ServiceComponentID)
//                            {
//                                errorCount++;
//                                Output.WriteLine("FAIL: Offering " + po._offeringID + " has the wrong service component!!");
//                                Output.WriteVerbose("\tTMR says: " + offer._svcComponentID + " PCF says: " + po._offer.ServiceInstanceList[0].ServiceComponentID);
//                            }
//                            
//                            if(offer._friendlyName != po.opdOfferFriendlyName)
//                            {
//                                errorCount++;
//                                Output.WriteLine("WARNING: Friendly name mismatch for " + po._offeringID);
//                                Output.WriteVerbose("\tTMR says: \"" + offer._friendlyName + "\" PCF says: \"" + po.opdOfferFriendlyName + "\"");                                
//                            }
//                            
                            //
                            // global offer details
                            //
                            
                            // assemble from parts
//                            ushort globalDetails = 0;
//                            globalDetails = (ushort)(po.opdNumberFreeMonths << 8);                              
//                            globalDetails |= ((po._duration > 9000) ? (ushort)0 : (ushort)(po._duration << 4));
//                            if(po.opdRecurrence == null || po.opdRecurrence == "")
//                            {
//                                // do nothing  (nonterminating == 0)
//                            }
//                            else if(po.opdRecurrence == "monthly")
//                            {
//                                globalDetails |= (ushort)(1 << 1);
//                            }
//                            else if(po.opdRecurrence == "yearly")
//                            {
//                                globalDetails |= (ushort)(4 << 1);
//                            }
//
//                            if(globalDetails != offer._globalOfferDetails)
//                            {
//                                errorCount++;
//                                Output.WriteLine("WARNING: Global offer details mismatch for " + po._offeringID);
//                                Output.WriteVerbose("\tTMR says: 0x" + offer._globalOfferDetails.ToString("x") + " PCF says: 0x" + globalDetails.ToString("x"));                                                                
//                            }  
                            
                            //
                            // Hey presto! Since we happen to already be examining the context of an Offer Region,
                            // we can go ahead and cross check the specifics right away!  W00t!
                            //                                                                                              
                            
                            //
                            // is the country correct?
                            //
                            bool found = false;
                            foreach(PCTDataOfferingCountryListCountry list in po._offer.CountryList)
                            {   
                                if(list.Country == CountryDictionary.CountryCode((byte)or.CountryID))
                                {
                                    found = true;
                                }
                            }
                            
                            if(found == false)
                            {
                                errorCount++;
                                Output.WriteLine("FAIL: Country mismatch for offer " + po._offeringID);
                                Output.WriteVerbose("\tTMR says: " + or.CountryID + "(" + CountryDictionary.CountryCode((byte)or.CountryID) + ") PCF doesn't include this");                                                                
                            }
                            
                            //
                            // check price
                            // 
                            
//                            if(or.PriceWhole != po.opdPriceWhole || or.PriceFractional != po.opdPriceFractional)
//                            {
//                                errorCount++;
//                                Output.WriteLine("FAIL: PRICE mismatch for offer " + po._offeringID);
//                                Output.WriteVerbose("\tTMR says: " + or.PriceWhole + "." + or.PriceFractional + " PCF says " + po.opdPriceWhole + "." + po.opdPriceFractional);                                                                                                
//                            }
                            
                            //
                            // specific offer details (only tax type is here at this time)
                            //
//                            ushort specificDetails = 0;
//                            if(po.opdTax == "plus applicable taxes")
//                            {
//                                specificDetails = 0;      // NO_TAX
//                            }
//                            else if(po.opdTax == "vat included")
//                            {
//                                specificDetails = 3;      // VAT_INCLUDED
//                            }
                            
//                            if(specificDetails != or.SpecificOfferDetails)
//                            {
//                                errorCount++;
//                                Output.WriteLine("WARNING: Specific offer details (TAX) mismatch for offer " + po._offeringID);
//                                Output.WriteVerbose("\tTMR says: 0x" + or.SpecificOfferDetails.ToString("x") + " PCF says 0x" + specificDetails.ToString("x") + " (" + po.opdTax + ")"); 
//                            }                                                      
                            
                        }
                    }

                }
                
   
             
                if(bFound == false)
                {
                    ignorelist.Add(po._offeringID);
                }
            }
            
            
            ignoredOffers = (string[])ignorelist.ToArray(Type.GetType("System.String"));
            return errorCount;
        }
       
        
        
                                              
    }
    
    
    class DepotEnumerator
    {
        private ArrayList _filelist;
        private string[]  _titledirs;
        private int _n;
        
        public DepotEnumerator(string basedir, string filespec)
        {
            _n       = 0;
            _filelist = new ArrayList();
            string[] names;
            
            _titledirs = Directory.GetDirectories(basedir);
            
            foreach(string titleid in _titledirs)
            {
                names = null;
                                       
                names = Directory.GetFiles(titleid, filespec);
                
                foreach(string name in names)
                {                       
                    //Output.WriteDebug("DepotEnumerator: match: [" + name + "]");
                    _filelist.Add(name);
                }                
            }
            
            Output.WriteDebug("DepotEnumerator: Found " + _filelist.Count + " matching files.");                
        }
        
        public string Next()
        {
            if(_n == _filelist.Count) return null;
            
            return (String)_filelist[_n++];            
        }
    }
    
    
    class DepotOffer 
    {
        string   _filename;
        
        public ulong    _offeringID;
        public ulong    _offeringType;
        public ulong    _offeringFrequency;
        public ulong    _policyFlags;
        public DateTime _startDate;
        public DateTime _endDate;              
        public string   _svcComponentID;
        public ushort   _globalOfferDetails;
        public bool     _cancelable;
        public string   _friendlyName;
        
        ArrayList _offerRegions;
        
        public DepotOffer()
        {
            _offerRegions = new ArrayList();
        }
        
        public ArrayList OfferRegions
        {
            get
            {
                return _offerRegions;
            }
        }
               
        /// <summary>
        /// ParseQueryString():
        /// Parses given query string and sets up the webstore client for the stored procedure call.
        /// This method and the ones following are ripped off from TitleMgr, courtesy RoxAra.
        /// </summary>
        public void LoadFromSQL2(string filename)
        {
            _filename = filename;
            StreamReader sr = File.OpenText(filename);

            string strFileContent = sr.ReadToEnd();
            string[] strStoredProcedures = Regex.Split(strFileContent, "exec");
                        
            foreach(string strStoredProc in strStoredProcedures)
            {
                if(strStoredProc == "") continue;
                
                string[] paramsArray = Regex.Split(strStoredProc, "[,]");
                
                for(int i = 0 ; i < paramsArray.GetLength(0); i++)
                {
                    paramsArray[i] = paramsArray[i].Trim();
                }
              
                string[] strFirst = Regex.Split(paramsArray[0], "\\s+");
                string strSPName = strFirst[0];
                paramsArray[0] = strFirst[1];
    
                switch (strSPName)
                {
                    case "p_svc_insert_offers":
                        ParseParamsInsertOffers(paramsArray);
                        break;
                    case "p_svc_insert_subscriptions":
                        ParseParamsInsertSubscriptions(paramsArray);
                        break;
                    case "p_svc_insert_offer_regions":
                        ParseParamsInsertOfferRegions(paramsArray);
                        break;
                    case "p_svc_offer_change_dates":
                        ParseParamsChangeOfferDates(paramsArray);
                        break;
                    default:
                        // not one of the stored procs we care about...
                       break;        
                }
            }
        
        }

        
        private void ParseParamsInsertOffers(string[] paramsArray)
        {
            try
            {
                _globalOfferDetails = 0x0;
                _cancelable = false;
                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                        // bigint in hexa
                        case 1://bi_offer_id 
                            _offeringID = Convert.ToUInt64(paramsArray[i], 16);                            
                            break;
                        case 15://i_policy_flags
                            _policyFlags = Convert.ToUInt32(paramsArray[i], 16);
                            break;
                        case 9://i_offer_type_id
                            _offeringType = Convert.ToUInt32(paramsArray[i], 16);
                            break;
                        case 10://i_offer_frequency_id 
                            _offeringFrequency = Convert.ToUInt32(paramsArray[i], 16);
                            break;
                        // datetime
						case 11: //dt_start_date
						    _startDate = Convert.ToDateTime(paramsArray[i]);
                            break;
                        case 12: //dt_end_date
							_endDate = Convert.ToDateTime(paramsArray[i]);
							break;
                        //strings
						case 8: // vc_billing_svc_component_id
                            _svcComponentID = paramsArray[i].Replace("'","");;
                            break;
                        case 13:// vc_friendly_name                            
                            _friendlyName = paramsArray[i].Replace("'","");							
							break;
                        default:        
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }

        private void ParseParamsInsertSubscriptions(string[] paramsArray)
        {
            try
            {
                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                            // bigint in hexa
                        case 1://bi_offer_id 
                            _offeringID = Convert.ToUInt64(paramsArray[i], 16);                            
                            break;
                        // binaries
                        case 15://i_policy_flags
                            _policyFlags = Convert.ToUInt32(paramsArray[i], 16);
                            break;
                        case 9://i_offer_type_id
                            _offeringType = Convert.ToUInt32(paramsArray[i], 16);
                            break;
                        case 10://i_offer_frequency_id 
                            _offeringFrequency = Convert.ToUInt32(paramsArray[i], 16);
                            break;
                        // datetime
						case 11: //dt_start_date
						    _startDate = Convert.ToDateTime(paramsArray[i]);
                            break;
                        case 12: //dt_end_date
							_endDate = Convert.ToDateTime(paramsArray[i]);
							break;
                            //strings
						case 8: // vc_billing_svc_component_id
                            _svcComponentID = paramsArray[i].Replace("'","");
                            break;
                        case 13:// vc_friendly_name                            
                            _friendlyName = paramsArray[i].Replace("'","");							
							break;
                        case 3:
                            _cancelable = (Convert.ToUInt32(paramsArray[i]) != 0 ? true : false);
                            break;
                        case 16: //si_global_offer_details
                            _globalOfferDetails = Convert.ToUInt16(paramsArray[i], 16);
                            break;
                        default:
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
        }
   
        private void ParseParamsInsertOfferRegions(string[] paramsArray)
        {
            OfferRegion or = new OfferRegion();
            
            try
            {
                for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
                {
                    switch(i)
                    {
                        case 1:
                            or.CountryID = Convert.ToInt32(paramsArray[i]);
                            break;
                        case 2:
                            or.OfferingID = paramsArray[i].Replace("'","");
                            break;
                        case 3:
                            or.PriceWhole = Convert.ToUInt32(paramsArray[i]);
                            break;
                        case 4:
                            or.PriceFractional = Convert.ToUInt32(paramsArray[i]);
                            break;                            
                        case 5:
                            or.SpecificOfferDetails = Convert.ToUInt16(paramsArray[i], 16);                            
                            break;
                        default:
                            break;
                    }
                }
            }
            catch(System.Exception)
            {
                throw;
            }
            
            _offerRegions.Add(or);
        }

 
		private void ParseParamsChangeOfferDates(string[] paramsArray)
		{
			try
			{
				for (int i = 0 ; i < paramsArray.GetLength(0) ; i++)
				{
					switch(i)
					{
						case 1: //dt_start_date
						    _startDate = Convert.ToDateTime(paramsArray[i]);
                            break;
                        case 2: //dt_end_date
							_endDate = Convert.ToDateTime(paramsArray[i]);
							break;
                        default:
                            break;
					}
				}
			}
			catch(System.Exception)
			{
				throw;
			}
		}

    
        public class OfferRegion
        {
            public int     CountryID;
            public string  OfferingID;
            public uint    PriceWhole;
            public uint    PriceFractional;
            public ushort  SpecificOfferDetails;            
        }
          
        
    }
    
    
    class CountryDictionary
    {
        public static string CountryCode(byte countryId)
        {
            switch(countryId)
            {
            case 16:
                return "CA";
            case 24:
                return "DE";
            case 34:
                return "FR";
            case 35:
                return "GB";
            case 53:
                return "JP";
            case 103:   
                return "US";
            default:
                return "ADD ME TO THE TOOL!";        
            }
        }
    }

        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BillingXCheck\waldorf\PCF.cs ===
//
//  PCF.cs
//
//  Waldorf (Billing-Cross-Check) tool
//
//  Ben Zotto (benzotto), September/October 2002
//
//
using System;
using System.IO;
using System.Collections;
using System.Xml;
using System.Xml.Serialization;
using System.Diagnostics;
using System.Text.RegularExpressions; 
using System.Globalization;                                    
                                     
namespace xonline.tools.billingxcheck.waldorf 
{

    class PCF
    {
            private PCTData _pcf = null;
            private ArrayList _offers = new ArrayList();
            private ArrayList _svcComponents = new ArrayList();
            
            public ArrayList Offers
            {
                get { return _offers; }
            }
            
            public void LoadFromFile(string filename)
            {
                Stream pcfFile;
                
                Output.WriteVerbose("Opening PCF file " + filename);
                
                try
                {
                    pcfFile = new FileStream(filename, FileMode.Open);                                       
                }
                catch
                {
                    throw new InvalidUsageException("Cannot open file " + filename + "!");
                }
                
                XmlSerializer xs = new XmlSerializer(typeof(PCTData));
                _pcf = (PCTData)xs.Deserialize(pcfFile);
                
                GetHierarchical();
                Output.WriteVerbose("Loaded " + _offers.Count + " offers and " + _svcComponents.Count + " service components.");                                                
            
                Output.WriteVerbose("PCF data loaded successfully.");
            }
                        
            //
            //  Looks at PCF data in a vacuum and ensures that some basic stuff looks OK.
            //  This method encapsulates some business logic, so if the requirements of PCF
            //  files change, this section should change accordingly.
            //            
            public int BaselineVerify()
            {
                int errorCount = 0;
                string wsdlExpected = "";
                
                
               
                foreach(PCFServiceComponent component in _svcComponents)
                {
                    //
                    // Make sure WSDLs are right.
                    //
                    
                    // WSDL location
                
                        
                    foreach(PCTDataServiceComponentServiceComponentAttributeListServiceComponentAttribute attr in component._sc.ServiceComponentAttributeList)
                    {
                    
                        Output.WriteDebug("Environment: " + attr.Environment);
                        
                        switch(attr.Environment)
                        {
                            // devnet/testnet
                            case "StratDev":
                                wsdlExpected = "https://192.168.86.203/xcbk/sprov.asmx?wsdl";
                                break;
                                
                            // partnernet
                            case "StratTest":
                                wsdlExpected = "https://131.107.228.179/xcbk/sprov.asmx?wsdl";
                                break;
                                
                            // betanet
                            case "IntTest":
                                wsdlExpected = "https://131.107.228.181/xcbk/sprov.asmx?wsdl";
                                break;
                                
                            // betanet/preprod
                            case "PreProduction":
                                wsdlExpected = "https://131.107.23.199/xcbk/sprov.asmx?wsdl";
                                break;
                                
                            // prod
                            case "Production":
                                wsdlExpected = "https://207.46.247.190/xcbk/sprov.asmx?wsdl";
                                break;                                
                                
                            default:
                                errorCount++;
                                Output.WriteLine("WARNING: Unknown SPS environment: " + attr.Environment);
                                goto SkipComponents;                                                                
                        }                         
                        
                        
                        foreach(PCTDataServiceComponentServiceComponentAttributeListServiceComponentAttributeMetaData metadata in attr.MetaDataSet)
                        {
                            string wsdl = metadata.SoapParameters.wsdlFile;
                            
                            if(wsdl != wsdlExpected)
                            {
                                errorCount++;
                                Output.WriteLine("FAIL: Bad Service Provider URL for component " + component._sc.ServiceComponentName.Trim());
                                Output.WriteVerbose("\t(" + attr.Environment + ")\n\texpected = " + wsdlExpected + "\n\tactual   = " + wsdl);                            
                            }                                                
                            
                        }
                    }

SkipComponents:            
                    
                    // Provision delay
                    
                    if(component._sc.ProvisionDelay != 0)
                    {
                        errorCount++;
                        Output.WriteLine("WARNING: Suspicious ProvisionDelay (nonzero) for " + component._sc.ServiceComponentName.Trim());    
                    }
                    
                }

                
                foreach(PCFOffer po in _offers)
                {
                    //
                    // Check basic offer stuff
                    //
                    if(po._offer.BaseOffering == 0)
                    {
                        errorCount++;
                        Output.WriteLine("FAIL: Offering " + po._offer.OfferingID + " is not configured as a BaseOffering!");
                        Output.WriteVerbose("\t(" + po._offer.InternalOfferingDescription.Trim() + ")");
                    }
                                 
                    if(po._offer.CycleForward == 0)
                    {
                        errorCount++;
                        Output.WriteLine("WARNING: Offering " + po._offer.OfferingID + " is not set to cycle forward!");
                        Output.WriteVerbose("\t(" + po._offer.InternalOfferingDescription.Trim() + ")");                                        
                    }    
                                       
                    if(po._offer.ServiceInstanceList.Length > 1)
                    {
                        errorCount++;
                        Output.WriteLine("FAIL: Offering " + po._offeringID + " has " + po._offer.ServiceInstanceList.Length + " service components!");
                        Output.WriteVerbose("\t(expect no more than 1 service component per offer)"); 
                    }
                    
                    foreach(PCTDataOfferingUDE ude in po._offer.UDEList)
                    {
                        
                        if(ude.Type != "PurchaseSubscription" && 
                           ude.Type != "Subscription_Cycle" &&
                           ude.Type != "Renew" &&
                           ude.Type != "ConvertTo" &&
                           ude.Type != "ConvertFrom")
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Offering " + po._offeringID + " has unexpected UDE type!");
                            Output.WriteVerbose("\tactual = " + ude.Type);                         
                        }
                        
                        if(ude.Type == "Subscription_Cycle")
                        {
                            foreach(PCTDataOfferingUDERatingRuleListRatingRule rule in ude.RatingRuleList.RatingRule)
                            {
                                po._duration = rule.CycleEnd - rule.CycleStart;    

                            }
                        }

                    }
                    
                    foreach(PCTDataOfferingLanguage language in po._offer.LanguageList)
                    {
                       
                        if(language.Code == "en-US")
                        {
                            po._hasUSEnglish = true;
                        }
                    }
                        
                    if(po._hasUSEnglish != true)
                    {
                        errorCount++;
                        Output.WriteLine("FAIL: No en-US locale on offer " + po._offeringID);
                    }
                    
                    foreach(PCTDataOfferingPaymentInstrumentListPaymentInstrument payinfolist in po._offer.PaymentInstrumentList)
                    {
                        if(payinfolist.PaymentInstrument != "CREDITCARD")
                        {
                            errorCount++;
                            Output.WriteLine("FAIL: Offering " + po._offeringID + " doesn't accept CREDITCARD");
                            Output.WriteVerbose("\tactual set for= " + payinfolist.PaymentInstrument);                                             
                        }
                    }
                    
/*                    foreach(PCTDataPartnerOffering partneroffering in po._partnerOfferings)
                    {
                        if(partneroffering.PartnerID != "ecc7b465-3064-4e85-8d79-b4c84a5b27fe")
                        {
                            errorCount++;
                            Output.WriteLine("FAIL: Offering " + partneroffering.OfferingID + " not for Xbox Live!");
                            Output.WriteVerbose("\tBad partner ID= " + partneroffering.PartnerID);                                                                     
                        }
                    }
*/                
                
                }   // end loop over each offer
                

                return errorCount;                
            }
            
            
            public int OfferPerTypeVerify()
            {
                int errorCount = 0;
            
                //
                // Check thru all offers for per-offer data
                // TODO: revenue SKUs?
                //   

                foreach(PCFOffer o in _offers)
                {
                    if(o.opdOfferType == null || o.opdOfferType == "")
                    {
                        errorCount++;
                        Output.WriteLine("FAIL: Cannot typecheck offer " + o._offeringID + " because it has no valid OPD.");
                        continue;
                    }
                    
                    if(o.opdOfferType == "basic subscription")
                    {
                        if(o._duration > 15 && o._duration < 9000)
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Base sub " + o._offeringID + " has invalid (> 15 duration!"); 
                        }
                        
                        if(o.opdISOCurrency != o._offer.Currency)
                        {
                            errorCount++;
                            Output.WriteLine("FAIL: Base sub " + o._offeringID + " has mismatched currency!"); 
                            Output.WriteVerbose("\tOPD says: " + o.opdISOCurrency + ", actual: " + o._offer.Currency);                           
                        }
                        
                        
                        if(o.isFree == false)
                        {   
                            if(o._offer.ImmediateSettlement == 0)
                            {
                                errorCount++;
                                Output.WriteLine("WARNING: Non-free base sub " + o._offeringID + " not immediately settled!");
                            }
                        }
                        
                        //
                        // make sure price matches
                        //
                        
                        foreach(PCTDataOfferingUDE ude in o._offer.UDEList)
                        {
                            foreach(PCTDataOfferingUDERatingRuleListRatingRule rule in ude.RatingRuleList.RatingRule)
                            {
                                if(o.isFree == true)
                                {
                                    if(rule.Rate != 0)
                                    {
                                        errorCount++;
                                        Output.WriteLine("FAIL: Base sub " + o._offeringID + " should be free in PCF!!");
                                        Output.WriteVerbose("\tSPS thinks it costs: " + rule.Rate);
                                    }
                                }
                                else
                                {
                                    // Yen seem to be a special case where there is no decimal part at all in the rate
                                    //                                
                                    if(o.opdISOCurrency == "JPY")
                                    {
                                        if(o.opdPriceWhole != rule.Rate)
                                        {   
                                            errorCount++;
                                            Output.WriteLine("FAIL: Base sub " + o._offeringID + " has incorrect price!! Rating type=" + rule.Type );
                                            Output.WriteVerbose("\tSPS thinks it costs: " + rule.Rate + ", should be: " + o.opdPriceWhole);
                                        }
                                    }
                                    else
                                    {
                                        if(o.opdPriceWhole != (int)(rule.Rate / 100) || o.opdPriceFractional != (int)(rule.Rate % 100))
                                        {   
                                            errorCount++;
                                            Output.WriteLine("FAIL: Base sub " + o._offeringID + " has incorrect price!! Rating type=" + rule.Type );
                                            Output.WriteVerbose("\tSPS thinks it costs: " + rule.Rate + ", should be: " + o.opdPriceWhole + o.opdPriceFractional.ToString());
                                        }                                    
                                    }
                                }
                                
                                
                                if(o.opdNumberFreeMonths != (rule.CycleStart - 1))
                                {
                                    errorCount++;
                                    Output.WriteLine("WARNING: Base sub " + o._offeringID + " has incorrect free period");
                                    Output.WriteVerbose("\tSPS cycles: " + rule.CycleStart + "-" + rule.CycleEnd + " / expect: " + o.opdNumberFreeMonths );                                    
                                }
                            }                       
                        }
                        


                        if( o._offer.MaxOwnership != 0 &&
                            o._offer.MaxOwnership != 1 &&
                            o._offer.MaxOwnership != 2 )
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Base sub " + o._offeringID + " max ownership invalid value!");
                        }

                        if(o._offer.SuppressEmailOnRenew != 0)
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Base sub " + o._offeringID + " not suppressing email renewal!");
                        }
                                                
                        if(o._offer.ServiceInstanceList.Length != 1)
                        {
                            errorCount++;
                            Output.WriteLine("FAIL: Expect exactly one service component for base sub " + o._offeringID );
                        }
                        

                        
                    }
                                                                 
                    if(o.opdOfferType == "premium subscription")
                    {
                        if(o._duration > 15 && o._duration < 9000)
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Prem sub " + o._offeringID + " has invalid (> 15 duration!"); 
                        }
                                                
                        if(o.opdISOCurrency != o._offer.Currency)
                        {
                            errorCount++;
                            Output.WriteLine("FAIL: Prem sub " + o._offeringID + " has mismatched currency!"); 
                            Output.WriteVerbose("\tOPD says: " + o.opdISOCurrency + ", actual: " + o._offer.Currency);                           
                        }
                        
                        //
                        // make sure price matches
                        //
                            
                        foreach(PCTDataOfferingUDE ude in o._offer.UDEList)
                        {
                            foreach(PCTDataOfferingUDERatingRuleListRatingRule rule in ude.RatingRuleList.RatingRule)
                            {
                        
                                if(o.isFree == true)
                                {
                                    if(rule.Rate != 0)
                                    {
                                        errorCount++;
                                        Output.WriteLine("FAIL: Prem sub " + o._offeringID + " should be free in PCF!!");
                                        Output.WriteVerbose("\tSPS thinks it costs: " + rule.Rate);
                                    }
                                }
                                else
                                {
                                    // Yen seem to be a special case where there is no decimal part at all in the rate
                                    //                                
                                    if(o.opdISOCurrency == "JPY")
                                    {
                                        if(o.opdPriceWhole != rule.Rate)
                                        {   
                                            errorCount++;
                                            Output.WriteLine("FAIL: Prem sub " + o._offeringID + " has incorrect price!! Rating type=" + rule.Type );
                                            Output.WriteVerbose("\tSPS thinks it costs: " + rule.Rate + ", should be: " + o.opdPriceWhole);
                                        }
                                    }
                                    else
                                    {
                                        if(o.opdPriceWhole != (int)(rule.Rate / 100) || o.opdPriceFractional != (int)(rule.Rate % 100))
                                        {   
                                            errorCount++;
                                            Output.WriteLine("FAIL: Prem sub " + o._offeringID + " has incorrect price!! Rating type=" + rule.Type );
                                            Output.WriteVerbose("\tSPS thinks it costs: " + rule.Rate + ", should be: " + o.opdPriceWhole + o.opdPriceFractional.ToString());
                                        }                                    
                                    }
                                }
                            
                                if(o.opdNumberFreeMonths != (rule.CycleStart - 1))
                                {
                                    errorCount++;
                                    Output.WriteLine("WARNING: Prem sub " + o._offeringID + " has incorrect free period");
                                    Output.WriteVerbose("\tSPS cycles: " + rule.CycleStart + "-" + rule.CycleEnd + " / expect: " + o.opdNumberFreeMonths );                                    
                                }

                            }
                        }

                    
                        if(o.isFree == false)
                        {   
                            if(o._offer.ImmediateSettlement == 0)
                            {
                                errorCount++;
                                Output.WriteLine("WARNING: Non-free prem sub " + o._offeringID + " not immediately settled!");
                            }
                        }

                        if( o._offer.MaxOwnership != 0 &&
                            o._offer.MaxOwnership != 1 &&
                            o._offer.MaxOwnership != 2 )
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Prem sub " + o._offeringID + " max ownership invalid value!");
                        }

                        if(o._offer.SuppressEmailOnRenew != 0)
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Prem sub " + o._offeringID + " not suppressing email renewal!");
                        }
                                                
                        if(o._offer.ServiceInstanceList.Length != 1)
                        {
                            errorCount++;
                            Output.WriteLine("FAIL: Expect exactly one service component for prem sub " + o._offeringID );
                        }
                                                        
                    }

                    if(o.opdOfferType == "premium content")
                    {
                        if(o._duration != 0 || (o._duration > 0 && o._duration < 9000))
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Content " + o._offeringID + " has invalid duration!"); 
                        }
                                                
                        if(o.opdISOCurrency != o._offer.Currency)
                        {
                            errorCount++;
                            Output.WriteLine("FAIL: Content " + o._offeringID + " has mismatched currency!"); 
                            Output.WriteVerbose("\tOPD says: " + o.opdISOCurrency + ", actual: " + o._offer.Currency);                           
                        }                        

                        //
                        // make sure price matches
                        //
                            
                        foreach(PCTDataOfferingUDE ude in o._offer.UDEList)
                        {
                            foreach(PCTDataOfferingUDERatingRuleListRatingRule rule in ude.RatingRuleList.RatingRule)
                            {
                                if(o.isFree == true)
                                {
                                    if(rule.Rate != 0)
                                    {
                                        errorCount++;
                                        Output.WriteLine("FAIL: Content " + o._offeringID + " should be free in PCF!!");
                                        Output.WriteVerbose("\tSPS thinks it costs: " + rule.Rate);
                                    }
                                }
                                else
                                {
                                    // Yen seem to be a special case where there is no decimal part at all in the rate
                                    //                                
                                    if(o.opdISOCurrency == "JPY")
                                    {
                                        if(o.opdPriceWhole != rule.Rate)
                                        {   
                                            errorCount++;
                                            Output.WriteLine("FAIL: Content " + o._offeringID + " has incorrect price!! Rating type=" + rule.Type );
                                            Output.WriteVerbose("\tSPS thinks it costs: " + rule.Rate + ", should be: " + o.opdPriceWhole);
                                        }
                                    }
                                    else
                                    {
                                        if(o.opdPriceWhole != (int)(rule.Rate / 100) || o.opdPriceFractional != (int)(rule.Rate % 100))
                                        {   
                                            errorCount++;
                                            Output.WriteLine("FAIL: Content " + o._offeringID + " has incorrect price!! Rating type=" + rule.Type );
                                            Output.WriteVerbose("\tSPS thinks it costs: " + rule.Rate + ", should be: " + o.opdPriceWhole + o.opdPriceFractional.ToString());
                                        }                                    
                                    }
                                }
                                
                                if(o.opdNumberFreeMonths != 0 || rule.CycleStart != 1)
                                {
                                    errorCount++;
                                    Output.WriteLine("WARNING: Content " + o._offeringID + " has incorrect free period");
                                    Output.WriteVerbose("\tSPS cycles: " + rule.CycleStart + "-" + rule.CycleEnd + " / expect: " + o.opdNumberFreeMonths );                                    
                                }
                            }
                        }

                        
                        if(o.isFree == false)
                        {   
                            if(o._offer.ImmediateSettlement == 0)
                            {
                                errorCount++;
                                Output.WriteLine("WARNING: Non-free content " + o._offeringID + " not immediately settled!");
                            }
                        }

                        if( o._offer.MaxOwnership != 0 &&
                            o._offer.MaxOwnership != 1 &&
                            o._offer.MaxOwnership != 2 )
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Content " + o._offeringID + " max ownership invalid value!");
                        }

                        if(o._offer.SuppressEmailOnRenew == 0)
                        {
                            errorCount++;
                            Output.WriteLine("WARNING: Content " + o._offeringID + " is suppressing email renewal!");
                        }
                        
                        if(o._offer.ServiceInstanceList.Length != 0)
                        {
                            errorCount++;
                            Output.WriteLine("FAIL: Expect ZERO service components for offer " + o._offeringID );
                        }
                        
                        foreach(PCTDataOfferingUDE ude in o._offer.UDEList)
                        {
                            if(ude.Type != "PurchaseSubscription")
                            {
                                errorCount++;
                                Output.WriteLine("WARNING: Offering " + o._offeringID + " has unexpected UDE type!");
                                Output.WriteVerbose("\tactual = " + ude.Type);                         
                            }
                        }
                                                        
                    }

                }

                                            
                return errorCount;
            }
           
            
            private void GetHierarchical()
            {
                PCFOffer po;
                foreach(PCTDataOffering offer in _pcf.Offering)
                {
                    po = new PCFOffer();
                    if(offer.OfferingName.StartsWith("XBX") == false)
                    {
                        Output.WriteVerbose("IGNORING: Offer " + offer.OfferingName);
                    }
                    else 
                    {
                        po.LoadFromPCF(offer, _pcf);
                        _offers.Add(po);    
                    }
                }
                
                PCFServiceComponent psc;
                foreach(PCTDataServiceComponent pasc in _pcf.ServiceComponent)
                {
                    if(pasc.PartnerID == "ecc7b465-3064-4e85-8d79-b4c84a5b27fe")                     
                    {
                        psc = new PCFServiceComponent();
                        psc.LoadFromPCF(pasc.ServiceComponentID, _pcf);
                        _svcComponents.Add(psc);
                    }
                }

            }
            
                
            public void TempDumpOffers()
            {
                       
                Output.WriteLine("*** This PCF file contains the following offers: ");
                foreach(PCTDataOffering offer in _pcf.Offering)
                {
                    Output.WriteLine("    " + offer.InternalOfferingDescription.Trim());
                }
                            
            }
            
            public class PCFServiceComponent
            {
                string _SCID;
                
                //
                // PCF native types
                //
                public PCTDataServiceComponent  _sc;
                
                // load em up
                public void LoadFromPCF(string componentID, PCTData pcf)
                {
                    _SCID = componentID;
                    
                    // get each field
                    foreach(PCTDataServiceComponent sc in pcf.ServiceComponent)
                    {
                        if(sc.ServiceComponentID == componentID)
                        {
                            _sc = sc;   
                        }
                    }
                }    
            }
            
            public class PCFOffer
            {
                public string _offeringID = null;
                public bool   _hasUSEnglish = false;                
                //
                // PCF native types
                //
                public PCTDataOffering          _offer;
                public int                      _duration;
                
                
                //
                // OPD fields
                //
                public string Opd;
                public bool   opdParsedOK = false;
                public string opdOfferType;
                public string opdOfferFriendlyName;
                public string opdPrice;
                public string opdTax;
                public string opdRecurrence;
                public string opdFreeTrial;
                public int    opdPriceWhole;
                public int    opdPriceFractional;
                public int    opdNumberFreeMonths;
                public string opdISOCurrency;
                
                public bool   isFree = false;                
                
                // load em up
                public void LoadFromPCF(PCTDataOffering o, PCTData pcf)
                {
                    _offer = o;
                    _offeringID = o.OfferingID; 
                    
                    Output.WriteDebug(_offeringID + ":");                                                                        
                    Output.WriteDebug("\tServiceInstanceList: " + ((_offer.ServiceInstanceList == null) ? "null" : _offer.ServiceInstanceList.Length.ToString()));
                    Output.WriteDebug("\tPaymentInstrumentList: " + ((_offer.PaymentInstrumentList == null) ? "null" : _offer.PaymentInstrumentList.Length.ToString()));
                    Output.WriteDebug("\tCountryList: " + ((_offer.CountryList == null) ? "null" : _offer.CountryList.Length.ToString()));                    
                    Output.WriteDebug("\tLanguageList: " + ((_offer.LanguageList == null) ? "null" : _offer.LanguageList.Length.ToString()));
                    Output.WriteDebug("\tUDEList: " + ((_offer.UDEList == null) ? "null" : _offer.UDEList.Length.ToString()));                                                              
                }
              
                
                /// This call will take a supposed OPD input string and spit out:
                ///    -1: couldn't parse it into valid OPD fields
                ///     0: successful
                ///     n: where n is the field (1-6) which contains errors.
                ///         there might be other error fields also; you'll only get
                ///         them one at a time as you fix them right now.
                ///
                public int ParseOfferingPriceDescription(string opd)
                {
                    string[] opdFields;
                    int r = 0;
                    try
                    {
                        opdFields = opd.Split(new char[] {'|'});
                    } 
                    catch
                    {
                        r = -1;
                        goto Error;
                    }
                    
                    if(opdFields.Length != 6)
                    {
                        //
                        // overall parse problem
                        //
                        r = -1;                           
                        goto Error;
                    }
                    
                    Opd                     = opd.Trim();;
                    opdOfferType            = opdFields[0].Trim().ToLower();
                    opdOfferFriendlyName    = opdFields[1].Trim();
                    opdPrice                = opdFields[2].Trim();
                    opdTax                  = opdFields[3].Trim().ToLower();
                    opdRecurrence           = opdFields[4].Trim().ToLower();
                    opdFreeTrial            = opdFields[5].Trim();
                    
                    if(opdOfferType != "basic subscription" && opdOfferType != "premium subscription" && opdOfferType != "premium content")
                    {
                        r = 1;
                    }
                    
                    if(opdOfferFriendlyName == null || opdOfferFriendlyName == "")
                    {
                        r = 2;
                    }
                    
                    if(opdPrice == null || opdPrice == "" || ParsePrice(opdPrice) != true)
                    {
                        r = 3;
                    }
                    
                    if(opdTax != "plus applicable taxes" && opdTax != "vat included")
                    {
                        r = 4;                        
                    }
                    
                    if(opdRecurrence != "" && (opdRecurrence != "monthly" && opdRecurrence != "yearly"))
                    {   
                        r = 5;
                    }
                    
                    if(opdFreeTrial == null || opdFreeTrial == "")
                    {
                        opdNumberFreeMonths = 0;
                    }
                    else
                    {
                        try
                        {
                            opdNumberFreeMonths = Convert.ToInt32(opdFreeTrial);
                        }
                        catch
                        {
                            r = 6;
                        }
                    }
                    
                    if(opdNumberFreeMonths > 15)
                    {
                        r = 6;
                    }
Error:
                    return r;                             
                    
                }
                
                //
                // assumes en-US formatting
                //            
                // UPDATE ME FOR FURTHER CURRENCIES!!
                //    
                private bool ParsePrice(string p)
                {
                    int n = 0;
                    string[] fields;
                    string cursym;
                    string jpy = Char.ToString(Convert.ToChar(0x00A5));
                    string gbp = Char.ToString(Convert.ToChar(0x00A3));
                    string eur = Char.ToString(Convert.ToChar(0x20AC));
                    

                    try
                    {
                        fields = p.Substring(n).Split(new char[] {' '});
                        
                        cursym = fields[0].Substring(0,1);
                        if(cursym == "$")
                        {
                            if(fields.Length == 2 && fields[1] == "CAD")
                            {
                                //
                                // There's a CAD differentiator here
                                //
                                opdISOCurrency = "CAD";
                            }
                            else
                            {
                                opdISOCurrency = "USD";
                            }
                        }
                        else if(cursym == jpy)
                        {
                            opdISOCurrency = "JPY";
                        }
                        else if(cursym == gbp)
                        {
                            opdISOCurrency = "GBP";
                        }
                        else if(cursym == eur)
                        {
                            opdISOCurrency = "EUR";
                        }
                        else
                        {
                            Output.WriteDebug("BAD CURRENCY MARKER: " + Convert.ToUInt16(Char.Parse(cursym)).ToString("x"));
                            return false;
                        }        
    
                        if(opdISOCurrency == "JPY")
                        {
                            opdPriceWhole = int.Parse(fields[0].Substring(1,fields[0].Length-1));
                            opdPriceFractional = 0;
                        }
                        else
                        {   
                            opdPriceWhole = int.Parse(fields[0].Substring(1, fields[0].Length-4));
                            opdPriceFractional = int.Parse(fields[0].Substring(fields[0].Length-2, 2));    
                        }
                    }
                    catch
                    {                    
                        return false;   
                    }
     
                    if(opdPriceFractional > 99 || opdISOCurrency.Length != 3)
                    {
                        return false;
                    }
                    
                    if(opdPriceWhole == 0 && opdPriceFractional == 0)
                    {
                        isFree = true;
                    }

                    return true;                                                         
                }
                
                
            }
            
           
                                           
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BillingXCheck\statler\Statler.cs ===
//
//  Statler (BillingXCheck (Billing-Cross-Check)) tool (SPS version)
//
//  Ben Zotto (benzotto), September 2002
//
//
using System;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Security.Permissions;
using System.Security.Principal;

[assembly:SecurityPermissionAttribute(SecurityAction.RequestMinimum, UnmanagedCode=true)]                                                           
                                     
namespace xonline.tools.billingxcheck.statler 
{
    public class Statler
    {
        static int Main(string[] args)
        {                                                        
            string versionDate;
            string versionVersion;
            
            GetVerInfo("Statler.exe", out versionDate, out versionVersion);
            Output.WriteLine("Statler { Xbox Live SPS consistency tool } version " + versionVersion);
            Output.WriteLine("Copyright (c) Microsoft Corporation.  All Rights Reserved.  Author: Ben Zotto\n");

            if(args == null || args.Length < 1) 
            {
                ShowUsage(null);
                return 1;        
            }
            
            //
            // Interpret command line arguments here
            // 
            string outlevel = GetCommandOption(args, "output", "o");
            if(outlevel == null)
            {                
                Output.Level = Output.NORMAL;
                Output.WriteLine("Defaulting to normal output level...");
            }
            else
            {
                switch(outlevel)
                {
                case "silent":
                    Output.Level = Output.SILENT;
                    break;
                case "normal":
                    Output.Level = Output.NORMAL;
                    break;
                case "verbose":
                    Output.Level = Output.VERBOSE;
                    break;
                case "debug":
                    Output.Level = Output.DEBUG;
                    break;
                default:
                    Output.Level = Output.NORMAL;
                    Output.WriteLine("Invalid output level \"" + outlevel + "\"-- defaulting to \"normal\"...");
                    break;
                }
            }
            
            string uodbserver = GetCommandOption(args, "uodb", "u");
            if(uodbserver == null)
            {
                ShowUsage("Must specify a UODB server name!");
                return 1;
            }
            else
            {
                SPS.Server = uodbserver;
            }
            
            string iisuser = GetCommandOption(args, "iisuser", "i");
            if(iisuser == null)
            {
                ShowUsage("Must specify an IIS user name!");
                return 1;
            }
            else
            {
                SPS.IISUser = iisuser;
            }

            
            //
            // go to SPS
            //
            StreamReader sr;
             
            try
            {
                sr = new StreamReader(new FileStream(args[args.Length-1], FileMode.Open));
            }
            catch          
            {               
                ShowUsage("Unable to open inputfile " + args[args.Length-1]);
                return 1;                
            }

            string line;
            string[] pieces;
            int n = 0;
            int i = 0;
            int errorCount = 0;
            while((line = sr.ReadLine()) != null)
            {
                n++;  // count of actual lines
                
                if(line.StartsWith("//"))
                {
                    continue;
                }
                
                i++;  // count of offerings
                
                pieces = line.Split(new char[] { ';' });
                
                if(pieces.Length != 3 || pieces[0].Length < 36)
                {
                    Output.WriteLine("Fatal parsing error.  File " + args[args.Length-1] + ", line " + n);
                    goto Cleanup;
                }
                
                try 
                {
                    errorCount += SPS.CheckOfferInBilling(pieces[0], pieces[1], pieces[2]);    
                }
                catch(Exception e)
                {
                    errorCount++;
                    Output.WriteDebug("SPS Error (line " + n + "): " + e );
                    Output.WriteLine("SPS Error (line " + n + "): " + e.Message);
                }
            }
            
            Output.WriteLine("Statler: Processed " + i + " offerings. Total " + errorCount + " failures/warnings.");
Cleanup:            
            Output.WriteVerbose("\nStatler: done.");
            return 0; 

        }
        
        public static void ShowUsage(string extraInfo)
        {
            if(extraInfo != null)
            {
                Output.WriteLine(extraInfo + "\n");
            }
            
            Output.WriteLine("usage: statler [/output:<level>] /uodb:<server> /iisuser:<user> <tmrdata.txt>");
            Output.WriteLine("\n\twhere <tmrdata.txt> is the file that WALDORF generated,");
            Output.WriteLine("\tand <server> is the name of any UODB SQL server in this");
            Output.WriteLine("\tenvironment. <user> is the IIS user account used to get the");
            Output.WriteLine("\tpublic master key with. <level> (optional) is the output");
            Output.WriteLine("\tlevel (silent, normal, verbose)");
        }
        
        
        public static string GetCommandOption(string[] args, string longoptname, string shortoptname)
        {
            foreach(string arg in args)
            {
                if(arg.ToLower().StartsWith("/" + longoptname.ToLower()) || arg.ToLower().StartsWith("/" + shortoptname.ToLower()))
                {
                    int i = arg.IndexOf(":");
                    if(i > 1 && (i < arg.Length-1 ))
                    {
                        return arg.Substring(i+1).ToLower(); 
                    }
                }
            }
            
            return null;
        }
                
        //
        // Slyly shell out to yoink the version and date info.  If we can't get them,
        // just return ????
        //
        public static void GetVerInfo(string s, out string d, out string v)
        {
            try
            {
                Process p = new Process();
                p.StartInfo.UseShellExecute = false;
                p.StartInfo.RedirectStandardOutput = true;
                p.StartInfo.FileName = "filever";
                p.StartInfo.Arguments = s;
                p.Start();
                string output = p.StandardOutput.ReadToEnd();
                p.WaitForExit();
    
                Regex ex = new Regex("\\s+");
                output = output.Trim();
                string []fields = ex.Split(output);
    
                string date = fields[fields.Length - 2];
                string ver = fields[4];
                
                d = date;
                v = ver;
            }
            catch
            {
                d = "??/??/??";
                v = "????";
            }            
            
            return;
        }
        
        
                
        
    }
    
    
    public class Output
    {
        public static int Level = NORMAL;
                                        
        public const int SILENT  = 0;
        public const int NORMAL  = 1;
        public const int VERBOSE = 2;
        public const int DEBUG   = 3;

        
        public static void WriteLine(string s)
        {
            if(Level >= NORMAL)
            {
                Console.WriteLine(s);
            }
        }
        
        public static void WriteVerbose(string s)
        {
            if(Level >= VERBOSE)
            {
                Console.WriteLine(s);
            }
        }
        
        public static void WriteDebug(string s)
        {
            if(Level >= DEBUG)
            {
                Console.WriteLine(s);
            }
        }
                
    }


    //
    // Xbox Live environments 
    //
   
    public class XboxLive
    {

        public const int DEVNET     = 0;
        public const int TESTNET    = 1;
        public const int PARTNERNET = 2;
        public const int BETANET    = 3;
        public const int PREPROD    = 4;
        public const int PRODUCTION = 10;
        
        
        public int Environment;
    }
  
    
    public class InvalidUsageException : System.Exception
    {
        public string Cause = null; 

        public InvalidUsageException()
        {
        }
        
        public InvalidUsageException(string s)
        {
            Cause = s;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BillingXCheck\waldorf\Waldorf.cs ===
//
//  Waldorf (Billing-Cross-Check) tool
//
//  Ben Zotto (benzotto), September 2002
//
//
using System;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Globalization;
using System.Threading;
using xonline.common.tools.console;                                     
                                                           
                                     
namespace xonline.tools.billingxcheck.waldorf 
{

    class Waldorf
    {                                     
        static int Main(string[] args)
        {                        
            Repository tmr;
            PCF pcf = null;            
            string versionDate;
            string versionVersion;
                      
            
            GetVerInfo("Waldorf.exe", out versionDate, out versionVersion);
            Output.WriteLine("Waldorf { Xbox Live SPS/TMR consistency tool } version " + versionVersion);
            Output.WriteLine("Copyright (c) Microsoft Corporation.  All Rights Reserved.  Author: Ben Zotto\n");


            //
            // Interpret command line arguments here
            // 
            if(args == null || args.Length < 1)
            {
                ShowUsage(null);
                return 1;        
            }                        
            
            string outlevel = GetCommandOption(args, "output", "o");
            if(outlevel == null)
            {                
                Output.Level = Output.NORMAL;
                Output.WriteLine("Defaulting to normal output level...");
            }
            else
            {
                switch(outlevel)
                {
                case "silent":
                    Output.Level = Output.SILENT;
                    break;
                case "normal":
                    Output.Level = Output.NORMAL;
                    break;
                case "verbose":
                    Output.Level = Output.VERBOSE;
                    break;
                case "debug":
                    Output.Level = Output.DEBUG;
                    break;
                default:
                    Output.Level = Output.NORMAL;
                    Output.WriteLine("Invalid output level \"" + outlevel + "\"-- defaulting to \"normal\"...");
                    break;
                }
            }
               
            
            string pcfPath = GetCommandOption(args, "pcf", "p");
            string outFile = args[args.Length-1];
            
            if(outFile.StartsWith("/"))
            {
                ShowUsage(null);
                return 1;
            }
            
            try
            {
                DepotOffer[] TMRoffers;
                if(pcfPath != null)
                {          
                    pcf = new PCF();                                        
        
                    //
                    // Do all the initialization steps here
                    //
                    
                    try 
                    {  
                        pcf.LoadFromFile(pcfPath);
                    }
                    catch(InvalidUsageException e)
                    {               
                        ShowUsage(e.Cause);
                        return 1;                
                    }
                    catch(Exception e)
                    {
                        Output.WriteLine("Error: " + e.Message);
                        return 1;                
                    }
        
                    //
                    // Check just the PCF data.
                    //
        
                    Output.WriteLine("Sanity-checking PCF data...");
                    if(pcf.BaselineVerify() == 0)
                    {
                        Output.WriteLine("...success!! (PCF data OK)");
                    }
        
                    //
                    // Go to title manager.
                    //                    
        
                    tmr = new Repository();
                    
                    Output.WriteLine("Checking TMR against PCF...");
                    TMRoffers = tmr.GetAllRelevantOfferings(pcf);                           
                    string[] ignored;
                    if(tmr.SignOffOnPCFOffers(TMRoffers, pcf, out ignored) == 0)
                    {
                        Output.WriteLine("...success!! (TMR<-->PCF OK)");
                    }
                }
                else // pcfPath == null, so we want all the offers.
                {             
        
                    tmr = new Repository();
                    
                    Output.WriteLine("Loading all offers from repository");
                    TMRoffers = tmr.GetAllOfferings();                                           
                }
                
                //
                // Record
                //
                StreamWriter sw;
                 
                try
                {
                    sw = new StreamWriter(new FileStream(outFile, FileMode.Create));
                }
                catch          
                {               
                    ShowUsage("Unable to open outputfile " + outFile);
                    return 1;                
                }
    
                sw.WriteLine("// " + outFile);
                sw.WriteLine("//");
                sw.WriteLine("// This file was autogenerated by the WALDORF tool.  It is to be used as");
                sw.WriteLine("// input for the STATLER tool to perform final verification against");
                sw.WriteLine("// the live SPS system. The STATLER tool must be run from a machine");
                sw.WriteLine("// with UODB and SPS (outbound) access, such as XBOS or XUACS.");
                sw.WriteLine("//");
                sw.WriteLine("// Generated from: " + ((pcfPath != null) ? pcfPath : "(complete repository)"));
                sw.WriteLine("//             On: " + DateTime.Now.ToString());
                sw.WriteLine("//");
                            
                if(pcfPath != null)
                {
                    foreach(DepotOffer doff in TMRoffers)
                    {
                        foreach(DepotOffer.OfferRegion or in doff.OfferRegions)
                        {
                            foreach(PCF.PCFOffer po in pcf.Offers)
                            {
                                if(po._offeringID == or.OfferingID)
                                {
                                    if(po._offer.ServiceInstanceList.Length == 1)
                                    {
                                        sw.WriteLine(or.OfferingID + ";" + po._offer.ServiceInstanceList[0].ServiceComponentID + ";" + po.Opd);                            
                                    }
                                    else
                                    {                                
                                        sw.WriteLine(or.OfferingID + ";;" + po.Opd);                            
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    foreach(DepotOffer doff in TMRoffers)
                    {
                        foreach(DepotOffer.OfferRegion or in doff.OfferRegions)
                        {
                             if(or.PriceWhole != 0 || or.PriceFractional != 0)
                             {    
                                 if(or.OfferingID == null || or.OfferingID == "")
                                 {  
                                    Output.WriteLine("TMR Data: Ignoring for-fee (nonready) offering " + doff._offeringID.ToString("x"));
                                    goto nextOffer;
                                 }
                                 
                                 if((doff._policyFlags & 0x1) != 0 && (doff._svcComponentID == null ||doff._svcComponentID == ""))
                                 {
                                    Output.WriteLine("TMR Data: Subscription " + doff._offeringID.ToString("x") + " with BOIDs is missing service component. Proceeding...");
                                 }
                                 
                                 if(doff._svcComponentID != "")
                                 {
                                    sw.WriteLine(or.OfferingID + ";" + doff._svcComponentID + ";");                            
                                 }
                                 else
                                 {                                
                                    sw.WriteLine(or.OfferingID + ";;");                            
                                 }
                             }
                        }
                        nextOffer:
                        ;
                    }
                    
                }
    
                sw.Flush();
                sw.Close();
            }
            catch(Exception e)
            {
                Output.WriteLine("Error: " + e.Message);
            }
                                        
            Output.WriteVerbose("\nWaldorf: done.");
            return 0; 

        }
        
        public static void ShowUsage(string extraInfo)
        {
            if(extraInfo != null)
            {
                Output.WriteLine(extraInfo + "\n");
            }
            
            Output.WriteLine("usage: waldorf [/pcf:<pcffile.xml>]");
            Output.WriteLine("               [/output:<level>] <tmrdata.txt>" );
            Output.WriteLine("\n\twhere <tmrdata.txt> is the output file will be cross-checked");
            Output.WriteLine("\tagainst SPS with STATLER, <pcffile.xml> (optional)");
            Output.WriteLine("\tspecifies the SPS 2.5 PCF file to cross-check against, <level>");
            Output.WriteLine("\tindicates the output level (silent, normal, verbose).");
            Output.WriteLine("NOTE: This tool will only output a tmrdata file of the entire TMR");
            Output.WriteLine("      repository if no PCF is specified. Else a tmrdata file will");
            Output.WriteLine("      be created which matches the offers in the PCF file only.");            
        }
        
        
        public static string GetCommandOption(string[] args, string longoptname, string shortoptname)
        {
            foreach(string arg in args)
            {
                if(arg.ToLower().StartsWith("/" + longoptname.ToLower()) || arg.ToLower().StartsWith("/" + shortoptname.ToLower()))
                {
                    int i = arg.IndexOf(":");
                    if(i > 1 && (i < arg.Length-1 ))
                    {
                        return arg.Substring(i+1).ToLower(); 
                    }
                }
            }
            
            return null;
        }

                
        //
        // Slyly shell out to yoink the version and date info.  If we can't get them,
        // just return ????
        //
        public static void GetVerInfo(string s, out string d, out string v)
        {
            try
            {
                Process p = new Process();
                p.StartInfo.UseShellExecute = false;
                p.StartInfo.RedirectStandardOutput = true;
                p.StartInfo.FileName = "filever";
                p.StartInfo.Arguments = s;
                p.Start();
                string output = p.StandardOutput.ReadToEnd();
                p.WaitForExit();
    
                Regex ex = new Regex("\\s+");
                output = output.Trim();
                string []fields = ex.Split(output);
    
                string date = fields[fields.Length - 2];
                string ver = fields[4];
                
                d = date;
                v = ver;
            }
            catch
            {
                d = "??/??/??";
                v = "????";
            }            
            
            return;
        }
        
        
                
        
    }
    
    
    public class Output
    {
        public static int Level = NORMAL;
                                        
        public const int SILENT  = 0;
        public const int NORMAL  = 1;
        public const int VERBOSE = 2;
        public const int DEBUG   = 3;

        
        public static void WriteLine(string s)
        {
            if(Level >= NORMAL)
            {
                Console.WriteLine(s);
            }
        }
        
        public static void WriteVerbose(string s)
        {
            if(Level >= VERBOSE)
            {
                Console.WriteLine(s);
            }
        }
        
        public static void WriteDebug(string s)
        {
            if(Level >= DEBUG)
            {
                Console.WriteLine(s);
            }
        }
                
    }


    
    public class InvalidUsageException : System.Exception
    {
        public string Cause = null; 

        public InvalidUsageException()
        {
        }
        
        public InvalidUsageException(string s)
        {
            Cause = s;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\BillingXCheck\waldorf\pctdata.cs ===
//------------------------------------------------------------------------------
// Autogenerated by xsd.exe and then patched by benzotto to work with XR2 PCFs.
//
// Next time, we should just steal code from their PCFSpy tool. Sheesh.
//------------------------------------------------------------------------------

using System.Xml.Serialization;


/// <remarks/>
[System.Xml.Serialization.XmlRootAttribute("PCTData", Namespace="", IsNullable=false)]
public class PCTData {
    
/*    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("Offering", typeof(PCTDataOffering))]
    [System.Xml.Serialization.XmlElementAttribute("Category", typeof(PCTDataCategory))]
    [System.Xml.Serialization.XmlElementAttribute("Resource", typeof(PCTDataResource))]
    [System.Xml.Serialization.XmlElementAttribute("S