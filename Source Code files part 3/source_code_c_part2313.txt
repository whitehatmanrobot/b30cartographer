re->getLinear()->getBPP();

    // copy palette away
    DWORD adwPalette[256];
    memcpy (adwPalette, (char*)pPalAddr, 256 * dwBPP);

    // determine the new texture format and create palette builder object
    CPaletteBuilder palBuilder;
    DWORD dwOriginalFormat = pTexture->getOriginalFormat();
    DWORD dwPalType;
    switch(dwOriginalFormat)
    {
    case NV_SURFACE_FORMAT_A8R8G8B8:
        dwPalType   = PT_8888;
        break;
    case NV_SURFACE_FORMAT_X8R8G8B8:
        dwPalType   = PT_X888;
        break;
    default:
        // unhandled texture format
        nvAssert(0);
        dbgTracePop();
        return FALSE;
    }

    // convert back
    DWORD dwWidth  = pTexture->getWidth();
    DWORD dwHeight = pTexture->getHeight();
    int nMMC    = pTexture->getMipMapCount();
    int nCount;
    DWORD dwSrcOffset = 0, dwDestOffset = 0;

    DWORD sx[20];       // to keep history of sizes
    DWORD sy[20];

    // for correct handling of deep mipmaps (ex: 128x512x9)
    // the correct sequence to be generated is:  512x128 (level 8), 256x64, .....8x2 (level 2), 4x1 (1), 2x1 (0)

    for (nCount = 0; nCount < nMMC; nCount++)
    {
        dwSrcOffset  += dwWidth * dwHeight;
        dwDestOffset += dwWidth * dwHeight * dwBPP;

        sx[nCount]=dwWidth;
        sy[nCount]=dwHeight;

        dwWidth >>= (dwWidth == 1 ? 0 : 1);
        dwHeight >>= (dwHeight == 1 ? 0 : 1);
    }

    for (nCount = nMMC-1; nCount >= 0; nCount--)
    {
        dwSrcOffset  -= sx[nCount] * sy[nCount];
        dwDestOffset -= sx[nCount] * sy[nCount] * dwBPP;

        palBuilder.depalettizeInPlace(dwPalType, dwAddr + dwSrcOffset, dwAddr + dwDestOffset, sx[nCount], sy[nCount], (DWORD*)adwPalette);
    }

#ifdef CAPTURE
    if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
        CAPTURE_MEMORY_WRITE memwr;
        memwr.dwJmpCommand         = CAPTURE_JMP_COMMAND;
        memwr.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
        memwr.dwExtensionID        = CAPTURE_XID_MEMORY_WRITE;
        memwr.dwCtxDMAHandle       = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;
        memwr.dwOffset             = pTexture->getSwizzled()->getOffset();
        memwr.dwSize               = pTexture->getSwizzled()->getSize();
        captureLog (&memwr, sizeof(memwr));
        captureLog ((void*)pTexture->getSwizzled()->getAddress(), memwr.dwSize);
    }
#endif

    dbgTracePop();
    return TRUE;
}

//---------------------------------------------------------------------------

void nvAutoPaletteCheckAndRevert(CTexture* pTexture, BOOL bFullSurface)
{
    dbgTracePush ("nvAutoPaletteCheckAndRevert");

    if (pTexture->hasAutoPalette()) {
        // will need to modify palettization logic if this assert fails
        nvAssert(pTexture == pTexture->getBaseTexture());
        if (!bFullSurface) {
            // copy texture contents forward only for partial blits
            nvUnpalettize(pTexture->getWrapper());
        }
        if (pTexture->hasColorKey() && (pTexture->getOriginalFormat() == NV_SURFACE_FORMAT_X8R8G8B8)) {
            pTexture->setColorKey(pTexture->getColorKey() & 0x00FFFFFF); // restore colour-key alpha
        }
        pTexture->resetOriginalFormat();
        pTexture->untagAutoPalettized();
        pTexture->tagUnpalettized(); // tag so we don't try palettizing this texture again
    }

    dbgTracePop();
}

//---------------------------------------------------------------------------

// nvCountStreamDMAs

// counts the number of unique context DMAs and the total number
// of system streams from among the first 'dwStreamCount' streams.
// the former is returned in bits 15:0 and the latter in 31:16

DWORD nvCountStreamDMAs (PNVD3DCONTEXT pContext, DWORD dwStreamCount)
{
    DWORD KnownContextDMAs[NV_CAPS_MAX_STREAMS];
    DWORD dwStreamSelector;
    DWORD dwContextDMA;
    DWORD dwUniqueDMACount;
    DWORD dwSystemDMACount;
    DWORD i,j;

    CVertexShader *pVertexShader = pContext->pCurrentVShader;
    nvAssert (pVertexShader);

    dwUniqueDMACount = 0;
    dwSystemDMACount = 0;

    for (i=0; i<dwStreamCount; i++)
    {
        dwStreamSelector = pVertexShader->getVAStream(i);
        if (dwStreamSelector != CVertexShader::VA_STREAM_NONE)
        {
            if (!pContext->ppDX8Streams[dwStreamSelector]) {
                // simply aborts if we hit a NULL pointer. presumably things aren't entirely set up
                // yet and this function will get called again once everything is in its final state
                return (0);
            }
            dwContextDMA = pContext->ppDX8Streams[dwStreamSelector]->getContextDMA();
            if (dwContextDMA == NV_CONTEXT_DMA_NONE)
            {
                //fake the context DMA by using the stream number or'd with 0xFFFF0000
                //this way we'll track the total number of system streams in use
                dwContextDMA = dwStreamSelector | 0xFFFF0000;

                for (j=0; j<dwUniqueDMACount; j++) {
                    if (dwContextDMA == KnownContextDMAs[j]) break;
                }
                if (j == dwUniqueDMACount) {
                    KnownContextDMAs[j] = dwContextDMA;
                    dwUniqueDMACount++;
                    dwSystemDMACount++;
                }
            }
            else
            {
                for (j=0; j<dwUniqueDMACount; j++) {
                    if (dwContextDMA == KnownContextDMAs[j]) break;
                }
                if (j == dwUniqueDMACount) {
                    KnownContextDMAs[j] = dwContextDMA;
                    dwUniqueDMACount++;
                }
            }
        }
    }

    return ((dwUniqueDMACount << 0) | (dwSystemDMACount << 16));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvFormats.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvFormats.cpp
//      routines for generating lists of surface formats supported
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        05Mar2001         creation
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

//---------------------------------------------------------------------------

#ifdef TEXFORMAT_CRD

// surface descriptors for DX7 and earlier

static DDSURFACEDESC nvSurfaceDescriptorsBasic[] = {
    NV_TFMT_X1R5G5B5,
    NV_TFMT_A1R5G5B5,
    NV_TFMT_A4R4G4B4,
    NV_TFMT_R5G6B5,
    NV_TFMT_X8R8G8B8,
    NV_TFMT_A8R8G8B8
};

static DDSURFACEDESC nvSurfaceDescriptorsBumpmap[] = {
    NV_TFMT_BUMPMAP_DV8_DU8,
    NV_TFMT_BUMPMAP_L6_DV5_DU5,
    NV_TFMT_BUMPMAP_L8_DV8_DU8
};

static DDSURFACEDESC nvSurfaceDescriptorsDXT[] = {
    NV_TFMT_DXT1,
    NV_TFMT_DXT2,
    NV_TFMT_DXT3,
    NV_TFMT_DXT4,
    NV_TFMT_DXT5
};

static DDSURFACEDESC nvSurfaceDescriptorsPalettized[] = {
    NV_TFMT_RGB8
};

static DDSURFACEDESC nvSurfaceDescriptorsNVxn[] = {
    NV_TFMT_FOURCC(FOURCC_NVT0),
    NV_TFMT_FOURCC(FOURCC_NVT1),
    NV_TFMT_FOURCC(FOURCC_NVT2),
    NV_TFMT_FOURCC(FOURCC_NVT3),
    NV_TFMT_FOURCC(FOURCC_NVT4),
    NV_TFMT_FOURCC(FOURCC_NVT5),
    NV_TFMT_FOURCC(FOURCC_NVS0),
    NV_TFMT_FOURCC(FOURCC_NVS1),
    NV_TFMT_FOURCC(FOURCC_NVS2),
    NV_TFMT_FOURCC(FOURCC_NVS3),
    NV_TFMT_FOURCC(FOURCC_NVS4),
    NV_TFMT_FOURCC(FOURCC_NVS5)
};

static DDSURFACEDESC nvSurfaceDescriptorsHILO[] = {
    NV_TFMT_NVHU,
    NV_TFMT_NVHS
};

// pixel formats for DX8 and later

static DDPIXELFORMAT nvPixelFormatsBasicCelsius[] = {
    NV_TFMT_X1R5G5B5_DX8,
    NV_TFMT_A1R5G5B5_DX8,
    NV_TFMT_A4R4G4B4_DX8,
    NV_TFMT_R5G6B5_DX8_CELSIUS_MULTISAMPLE,
    NV_TFMT_X8R8G8B8_DX8_CELSIUS_MULTISAMPLE,
    NV_TFMT_A8R8G8B8_DX8_CELSIUS_MULTISAMPLE
};

static DDPIXELFORMAT nvPixelFormatsBasicKelvin[] = {
    NV_TFMT_X1R5G5B5_DX8,
    NV_TFMT_A1R5G5B5_DX8,
    NV_TFMT_A4R4G4B4_DX8,
    NV_TFMT_R5G6B5_DX8_KELVIN_MULTISAMPLE,
    NV_TFMT_X8R8G8B8_DX8_KELVIN_MULTISAMPLE,
    NV_TFMT_A8R8G8B8_DX8_KELVIN_MULTISAMPLE
};

static DDPIXELFORMAT nvPixelFormatsBumpmap[] = {
    NV_TFMT_BUMPMAP_DV8_DU8_DX8,
    NV_TFMT_BUMPMAP_L6_DV5_DU5_DX8,
    NV_TFMT_BUMPMAP_L8_DV8_DU8_DX8
};

static DDPIXELFORMAT nvPixelFormatsDXT[] = {
    NV_TFMT_DXT1_DX8,
    NV_TFMT_DXT2_DX8,
    NV_TFMT_DXT3_DX8,
    NV_TFMT_DXT4_DX8,
    NV_TFMT_DXT5_DX8
};

static DDPIXELFORMAT nvPixelFormatsPalettized[] = {
    NV_TFMT_RGB8_DX8
};

static DDPIXELFORMAT nvPixelFormatsNVxn[] = {
    NV_TFMT_DX8(FOURCC_NVT0, D3D_TEXTURE),
    NV_TFMT_DX8(FOURCC_NVT1, D3D_TEXTURE),
    NV_TFMT_DX8(FOURCC_NVT2, D3D_TEXTURE),
    NV_TFMT_DX8(FOURCC_NVT3, D3D_TEXTURE),
    NV_TFMT_DX8(FOURCC_NVT4, D3D_TEXTURE),
    NV_TFMT_DX8(FOURCC_NVT5, D3D_TEXTURE),
    NV_TFMT_DX8(FOURCC_NVS0, D3D_TEXTURE),
    NV_TFMT_DX8(FOURCC_NVS1, D3D_TEXTURE),
    NV_TFMT_DX8(FOURCC_NVS2, D3D_TEXTURE),
    NV_TFMT_DX8(FOURCC_NVS3, D3D_TEXTURE),
    NV_TFMT_DX8(FOURCC_NVS4, D3D_TEXTURE),
    NV_TFMT_DX8(FOURCC_NVS5, D3D_TEXTURE),
};

static DDPIXELFORMAT nvPixelFormatsHILO[] = {
    NV_TFMT_NVHU_DX8,
    NV_TFMT_NVHS_DX8,
};

static DDPIXELFORMAT nvPixelFormatsZetaCelsius[] = {
    NV_TFMT_Z16_CELSIUS_MULTISAMPLE,
    NV_TFMT_Z24_CELSIUS_MULTISAMPLE,
    NV_TFMT_Z24_S8_CELSIUS_MULTISAMPLE
};

static DDPIXELFORMAT nvPixelFormatsZetaKelvin[] = {
    NV_TFMT_Z16_KELVIN_MULTISAMPLE,
    NV_TFMT_Z24_KELVIN_MULTISAMPLE,
    NV_TFMT_Z24_S8_KELVIN_MULTISAMPLE
};

static DDPIXELFORMAT nvPixelFormatsMisc[] = {
    NV_TFMT_Q8W8V8U8_DX8
};

//---------------------------------------------------------------------------

BOOL nvEnumerateFourCCs (void)
{
    DWORD dwNum = 0;

    // A few other random things that never change
    pDriverData->fourCC[dwNum++] = FOURCC_UYVY;
    pDriverData->fourCC[dwNum++] = FOURCC_UYNV;
    pDriverData->fourCC[dwNum++] = FOURCC_YUY2;
    pDriverData->fourCC[dwNum++] = FOURCC_YUNV;
    pDriverData->fourCC[dwNum++] = FOURCC_YV12;
    pDriverData->fourCC[dwNum++] = FOURCC_YVU9;
    pDriverData->fourCC[dwNum++] = FOURCC_IF09;
    pDriverData->fourCC[dwNum++] = FOURCC_IV32;
    pDriverData->fourCC[dwNum++] = FOURCC_IV31;
    pDriverData->fourCC[dwNum++] = FOURCC_RAW8;

    if ((pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN))
        &&
        ((getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_NVXN) ||
         (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_NVXN))
       )
    {
        pDriverData->fourCC[dwNum++] = FOURCC_NVDS;
        pDriverData->fourCC[dwNum++] = FOURCC_NVT0;
        pDriverData->fourCC[dwNum++] = FOURCC_NVT1;
        pDriverData->fourCC[dwNum++] = FOURCC_NVT2;
        pDriverData->fourCC[dwNum++] = FOURCC_NVT3;
        pDriverData->fourCC[dwNum++] = FOURCC_NVT4;
        pDriverData->fourCC[dwNum++] = FOURCC_NVT5;
        pDriverData->fourCC[dwNum++] = FOURCC_NVS0;
        pDriverData->fourCC[dwNum++] = FOURCC_NVS1;
        pDriverData->fourCC[dwNum++] = FOURCC_NVS2;
        pDriverData->fourCC[dwNum++] = FOURCC_NVS3;
        pDriverData->fourCC[dwNum++] = FOURCC_NVS4;
        pDriverData->fourCC[dwNum++] = FOURCC_NVS5;
    }

    if ((pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN))
        &&
        ((getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_DXT) ||
         (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_DXT))
       )
    {
        pDriverData->fourCC[dwNum++] = FOURCC_DXT1;
        pDriverData->fourCC[dwNum++] = FOURCC_DXT2;
        pDriverData->fourCC[dwNum++] = FOURCC_DXT3;
        pDriverData->fourCC[dwNum++] = FOURCC_DXT4;
        pDriverData->fourCC[dwNum++] = FOURCC_DXT5;
    }

    if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
        &&
        ((getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_HILO) ||
         (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_HILO))
       )
    {
        pDriverData->fourCC[dwNum++] = FOURCC_NVHS;
        pDriverData->fourCC[dwNum++] = FOURCC_NVHU;
    }

    return (TRUE);
}

//---------------------------------------------------------------------------

#define COPY_AND_INCREMENT(a,b)     \
{                                   \
    memcpy (a, &(b), sizeof(b));    \
    a += sizeof(b);                 \
}

//---------------------------------------------------------------------------

BOOL nvEnumerateSurfaceFormats (void)
{
    DWORD  dwSize;
    BYTE  *pCopyAddr;

    dbgTracePush ("nvEnumerateSurfaceFormats");

    // free any memory we may already have allocated
    if (getDC()->pSurfaceDescriptors) {
        FreeIPM(getDC()->pSurfaceDescriptors);
        getDC()->pSurfaceDescriptors = NULL;
    }
    if (getDC()->pPixelFormats) {
        FreeIPM(getDC()->pPixelFormats);
        getDC()->pPixelFormats = NULL;
    }

    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {

        // surface descriptors
        dwSize = 0;
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_BASIC)      dwSize += sizeof(nvSurfaceDescriptorsBasic);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_BUMPMAP)    dwSize += sizeof(nvSurfaceDescriptorsBumpmap);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_DXT)        dwSize += sizeof(nvSurfaceDescriptorsDXT);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_PALETTIZED) dwSize += sizeof(nvSurfaceDescriptorsPalettized);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_NVXN)       dwSize += sizeof(nvSurfaceDescriptorsNVxn);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_HILO)       dwSize += sizeof(nvSurfaceDescriptorsHILO);

        getDC()->dwSurfaceDescriptorCount = dwSize / sizeof(DDSURFACEDESC);
        getDC()->pSurfaceDescriptors = (DDSURFACEDESC *) AllocIPM (dwSize);
        if (!getDC()->pSurfaceDescriptors) {
            dbgTracePop();
            return FALSE;
        }

        pCopyAddr = (BYTE *) getDC()->pSurfaceDescriptors;
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_BASIC)      COPY_AND_INCREMENT (pCopyAddr, nvSurfaceDescriptorsBasic     );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_BUMPMAP)    COPY_AND_INCREMENT (pCopyAddr, nvSurfaceDescriptorsBumpmap   );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_DXT)        COPY_AND_INCREMENT (pCopyAddr, nvSurfaceDescriptorsDXT       );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_PALETTIZED) COPY_AND_INCREMENT (pCopyAddr, nvSurfaceDescriptorsPalettized);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_NVXN)       COPY_AND_INCREMENT (pCopyAddr, nvSurfaceDescriptorsNVxn      );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_HILO)       COPY_AND_INCREMENT (pCopyAddr, nvSurfaceDescriptorsHILO      );

        // pixel formats
        dwSize = 0;
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_BASIC)      dwSize += sizeof(nvPixelFormatsBasicKelvin);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_BUMPMAP)    dwSize += sizeof(nvPixelFormatsBumpmap);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_DXT)        dwSize += sizeof(nvPixelFormatsDXT);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_PALETTIZED) dwSize += sizeof(nvPixelFormatsPalettized);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_NVXN)       dwSize += sizeof(nvPixelFormatsNVxn);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_HILO)       dwSize += sizeof(nvPixelFormatsHILO);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_ZETA)       dwSize += sizeof(nvPixelFormatsZetaKelvin);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_MISC)       dwSize += sizeof(nvPixelFormatsMisc);

        getDC()->dwPixelFormatCount = dwSize / sizeof(DDPIXELFORMAT);
        getDC()->pPixelFormats = (DDPIXELFORMAT *) AllocIPM (dwSize);
        if (!getDC()->pPixelFormats) {
            FreeIPM(getDC()->pSurfaceDescriptors);
            getDC()->pSurfaceDescriptors = NULL;
            dbgTracePop();
            return FALSE;
        }

        pCopyAddr = (BYTE *) getDC()->pPixelFormats;
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_BASIC)      COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsBasicKelvin);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_BUMPMAP)    COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsBumpmap    );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_DXT)        COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsDXT        );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_PALETTIZED) COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsPalettized );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_NVXN)       COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsNVxn       );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_HILO)       COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsHILO       );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_ZETA)       COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsZetaKelvin );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_MISC)       COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsMisc       );

    }

    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {

        // surface descriptors
        dwSize = 0;
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_BASIC)      dwSize += sizeof(nvSurfaceDescriptorsBasic);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_DXT)        dwSize += sizeof(nvSurfaceDescriptorsDXT);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_PALETTIZED) dwSize += sizeof(nvSurfaceDescriptorsPalettized);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_NVXN)       dwSize += sizeof(nvSurfaceDescriptorsNVxn);

        getDC()->dwSurfaceDescriptorCount = dwSize / sizeof(DDSURFACEDESC);
        getDC()->pSurfaceDescriptors = (DDSURFACEDESC *) AllocIPM (dwSize);
        if (!getDC()->pSurfaceDescriptors) {
            dbgTracePop();
            return FALSE;
        }

        pCopyAddr = (BYTE *) getDC()->pSurfaceDescriptors;
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_BASIC)      COPY_AND_INCREMENT (pCopyAddr, nvSurfaceDescriptorsBasic     );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_DXT)        COPY_AND_INCREMENT (pCopyAddr, nvSurfaceDescriptorsDXT       );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_PALETTIZED) COPY_AND_INCREMENT (pCopyAddr, nvSurfaceDescriptorsPalettized);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_NVXN)       COPY_AND_INCREMENT (pCopyAddr, nvSurfaceDescriptorsNVxn      );

        // pixel formats
        dwSize = 0;
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_BASIC)      dwSize += sizeof(nvPixelFormatsBasicCelsius);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_DXT)        dwSize += sizeof(nvPixelFormatsDXT);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_PALETTIZED) dwSize += sizeof(nvPixelFormatsPalettized);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_NVXN)       dwSize += sizeof(nvPixelFormatsNVxn);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_ZETA)       dwSize += sizeof(nvPixelFormatsZetaCelsius);

        getDC()->dwPixelFormatCount = dwSize / sizeof(DDPIXELFORMAT);
        getDC()->pPixelFormats = (DDPIXELFORMAT *) AllocIPM (dwSize);
        if (!getDC()->pPixelFormats) {
            FreeIPM(getDC()->pSurfaceDescriptors);
            getDC()->pSurfaceDescriptors = NULL;
            dbgTracePop();
            return FALSE;
        }

        pCopyAddr = (BYTE *) getDC()->pPixelFormats;
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_BASIC)      COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsBasicCelsius);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_DXT)        COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsDXT         );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_PALETTIZED) COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsPalettized  );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_NVXN)       COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsNVxn        );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_ZETA)       COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsZetaCelsius );

    }

    else {

        // surface descriptors
        nvAssert (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_DXTRI);

        dwSize = 0;
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_BASIC)      dwSize += sizeof(nvSurfaceDescriptorsBasic);

        getDC()->dwSurfaceDescriptorCount = dwSize / sizeof(DDSURFACEDESC);
        getDC()->pSurfaceDescriptors = (DDSURFACEDESC *) AllocIPM (dwSize);
        if (!getDC()->pSurfaceDescriptors) {
            dbgTracePop();
            return FALSE;
        }

        pCopyAddr = (BYTE *) getDC()->pSurfaceDescriptors;
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_BASIC)      COPY_AND_INCREMENT (pCopyAddr, nvSurfaceDescriptorsBasic);

        // pixel formats
        getDC()->dwPixelFormatCount = 0;
        getDC()->pPixelFormats = NULL;

    }

    dbgTracePop();
    return TRUE;
}

#endif  // TEXFORMAT_CRD

#endif // (NVARCH >= 0x04)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvFlipper.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvFlipper.cpp
//      a flipping class, for use with kelvin-style semaphores
//      (possibly to be expanded to handle flipping more generally)
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        26Jun2000         created, NV20 development
//
// **************************************************************************

#include "nvprecomp.h"
#pragma hdrstop

#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES

//---------------------------------------------------------------------------

BOOL CFlipper::create (void)
{
    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL CFlipper::init (DWORD dwChainSize)
{
    m_dwFlipChainSize = dwChainSize;
    m_dwIndex         = 0;

    // initialize semaphores
    for (DWORD i=0; i<(dwChainSize-1); i++) {
        m_ppSemaphores[i] = getDC()->nvSemaphoreManager.allocate (SEMAPHORE_READY_FOR_RENDER);
    }
    m_ppSemaphores[dwChainSize-1] = getDC()->nvSemaphoreManager.allocate (SEMAPHORE_READY_FOR_SCANOUT);

    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL CFlipper::destroy (void)
{
    // free semaphores
    for (DWORD i=0; i<m_dwFlipChainSize; i++) {
        getDC()->nvSemaphoreManager.free (m_ppSemaphores[i]);
    }

    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL CFlipper::flip (CPushBuffer *pPusher3D,
                     CPushBuffer *pPusherDAC,
                     LPDDRAWI_DDRAWSURFACE_LCL pSurfCurr,
                     LPDDRAWI_DDRAWSURFACE_LCL pSurfTarg,
                     BOOL bNoVSync)
{
    CSemaphore *pCurrSem, *pNextSem, *pLastSem;
    DWORD       dwNextIndex, dwLastIndex;
    DWORD       dwDAC, dwNumHeads;
    DWORD       dwFormat;
    BOOL        bMultiHead;

    dwNextIndex = (m_dwIndex + 1) % m_dwFlipChainSize;
    dwLastIndex = (m_dwIndex + m_dwFlipChainSize - 1) % m_dwFlipChainSize;

    pCurrSem = m_ppSemaphores[m_dwIndex];
    pNextSem = m_ppSemaphores[dwNextIndex];
    pLastSem = m_ppSemaphores[dwLastIndex];

    m_dwIndex = dwNextIndex;

#ifdef WINNT
    // on Win2K we don't support real NV11 multimon, so anything with more than 1 DAC is treated like clone mode
    bMultiHead = pDriverData->ppdev->ulNumberDacsActive > 1;
    dwDAC      = NV_DD_VIDEO_LUT_CURSOR_DAC;
#else  // !WINNT
    bMultiHead = pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE;
    dwDAC      = NV_DD_VIDEO_LUT_CURSOR_DAC + pDXShare->dwHeadNumber;
#endif  // !WINNT

    // we don't handle multi-head stuff yet
    nvAssert (!bMultiHead);

    PRIMARY_BUFFER_INDEX ^= 0x1;

    dwNumHeads = bMultiHead ? pDriverData->dwHeads : 1;
    dwFormat   = DRF_DEF (07C, _SET_IMAGE_FORMAT, _NOTIFY, _WRITE_ONLY) |
                 DRF_NUM (07C, _SET_IMAGE_FORMAT, _PITCH,  pSurfTarg->lpGbl->lPitch);
    dwFormat  |= bNoVSync   ? DRF_DEF (07C, _SET_IMAGE_FORMAT, _WHEN, _IMMEDIATELY) :
                              DRF_DEF (07C, _SET_IMAGE_FORMAT, _WHEN, _NOT_WITHIN_BUFFER);
    dwFormat  |= bMultiHead ? DRF_DEF (07C, _SET_IMAGE_FORMAT, _MULTIHEAD_SYNC, _ENABLED) :
                              DRF_DEF (07C, _SET_IMAGE_FORMAT, _MULTIHEAD_SYNC, _DISABLED);

    for (DWORD dwLogicalHead = 0; dwLogicalHead < dwNumHeads; dwLogicalHead ++) {
        // calculate offset, the RM will add the pan & scan adjustment from the display driver if needed
        DWORD dwOffset = pSurfTarg->lpGbl->fpVidMem - pDriverData->BaseAddress;
#ifdef WINNT
        DWORD dwPhysicalHead = pDriverData->ppdev->ulDeviceDisplay[dwLogicalHead];
        // add the span mode offset
        dwOffset += pDriverData->ppdev->ulHeadDisplayOffset[dwPhysicalHead];
#else // !WINNT
        DWORD dwPhysicalHead = dwLogicalHead;
#endif // !WINNT
        // BUGBUG eventually this needs to be per DAC object!!

        // the 3D rendering pipe releases its current target and waits to acquire the next
        pCurrSem->release (SEMAPHORE_READY_FOR_SCANOUT, pPusher3D, NV_DD_KELVIN, CSemaphore::SEMAPHORE_RELEASE_KELVIN_BACKEND);
        pNextSem->acquire (SEMAPHORE_READY_FOR_RENDER,  pPusher3D);

        // the DAC acquires the new scanout source, and posts a flip
        // (note the release method gets issued before the flip itself because it really just
        // sets a trigger that gets executed _after_ the subsequent flip has actually occurred)
        pCurrSem->acquire (SEMAPHORE_READY_FOR_SCANOUT, pPusherDAC);
        pLastSem->release (SEMAPHORE_FLIP_COMPLETE, pPusherDAC, NV_DD_SUBCH_DAC, CSemaphore::SEMAPHORE_RELEASE_DAC);
        // program the flip
        // BUGBUG eventually set the correct DAC object
        //pPusherDAC->push (x, (0x00040000 | (NV_DD_SUBCH_DAC << 13)));
        //pPusherDAC->push (x, dwDAC + dwPhysicalHead);
        pPusherDAC->push (0, (0x00080000 | (NV_DD_SUBCH_DAC << 13) | NV07C_SET_IMAGE_OFFSET(PRIMARY_BUFFER_INDEX)));
        pPusherDAC->push (1, dwOffset);
        pPusherDAC->push (2, dwFormat);
        pPusherDAC->adjust (3);

        // the DAC channel waits for the flip to come back, after which it can
        // finally release this source back to the 3D channel and itself proceed.
        // important: this ensures vital serialization of flips and methods on the DAC channel
        pLastSem->acquire (SEMAPHORE_FLIP_COMPLETE, pPusherDAC);
        pLastSem->release (SEMAPHORE_READY_FOR_RENDER, pPusherDAC);

    }  // for...

    #ifdef SPOOF_KELVIN
    // delay to make winbench happy
    NV_SLEEP1;
    #endif

    return (TRUE);
}

#endif  // KELVIN_SEMAPHORES
#endif  // NVARCH >= 0x020
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvHeap.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
/********************************* Direct 3D *******************************\
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 07/27/99 - created                      *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

NVOS11_PARAMETERS HeapParams;

/*****************************************************************************
 *****************************************************************************
 *****************************************************************************
 *** CHeap *******************************************************************
 *****************************************************************************
 *****************************************************************************
 *****************************************************************************/

//
// switches
//

//
// globals
//
BOOL CInterProcessHeap::m_bInitialized = FALSE;
CInterProcessHeap g_nvIPHeap;

/*****************************************************************************
 * CInterProcessHeap::dbgTestIntegrity
 *
 * check that the heap is in good shape
 */
#ifdef CHEAP_SANITY_CHECK
void CInterProcessHeap::dbgTestIntegrity
(
    void
)
{
    HEADER *pFastHeader, *pSlowHeader;
    DWORD dwCount = 0;

    // check linked list
    for (pSlowHeader = pFastHeader = m_pBase; pFastHeader;)
    {
        if (pFastHeader->pNext)
        {
            if (pFastHeader->pNext->pPrev != pFastHeader)
            {
                DPF ("CInterProcessHeap::dbgTestIntegrity: list doesn't point to its parent");
                __asm int 3;
            }
        }

        pFastHeader = pFastHeader->pNext;

        if (dwCount & 0x01) pSlowHeader = pSlowHeader->pNext;
        dwCount ++;
        if (pSlowHeader == pFastHeader)
        {
            DPF ("CInterProcessHeap::dbgTestIntegrity: list points to itself!");
            __asm int 3;
            return;
        }
    }

    // check free list
    dwCount = 0;
    for (pSlowHeader = pFastHeader = m_pBaseFree; pFastHeader;)
    {
        pFastHeader = pFastHeader->pNextFree;
        if (dwCount & 0x01) pSlowHeader = pSlowHeader->pNextFree;
        dwCount++;
        if (pSlowHeader == pFastHeader)
        {
            DPF ("CInterProcessHeap::dbgTestIntegrity: free list points to itself!");
            __asm int 3;
            return;
        }
    }
}
#endif

//
// display use of IPM heap
//
void CInterProcessHeap::checkHeapUsage
(
   void
)
{

    // defragmenting here prevents the un-allocated heap from growing without bound
    combineFreeBlocks();

    // release any blocks that are completely unused
    releaseFreeBlocks();


#ifdef DEBUG
    if (m_pBase)
    {
        DPF_LEVEL(NVDBG_LEVEL_HEAP_USAGE, "*** IPM heap usage ***");
        DPF_LEVEL(NVDBG_LEVEL_HEAP_USAGE, "pHeader  end      (start)  (size)   pPrev    pCaller");
        DWORD dwBlocksInUse = 0, dwBlocksFree = 0;
        DWORD dwBytesInUse  = 0, dwBytesFree  = 0;
        HEADER *pHeader = m_pBase;
        while(pHeader != NULL)
        {

            if(pHeader->pPrev)
                DPF_LEVEL(NVDBG_LEVEL_HEAP_USAGE, "%08x %08x %08x %08x %08x %08x %c%c", pHeader,
                pHeader + pHeader->dwRealSize, pHeader->dwUserStart, pHeader->dwUserSize,
                pHeader->pPrev, pHeader->pCaller, isBoundary(pHeader) ? 'B' : ' ', isAlloc(pHeader) ? '*' : ' ');
            else
                DPF_LEVEL(NVDBG_LEVEL_HEAP_USAGE, "%08x %08x %08x %08x **NULL** %08x %c%c", pHeader,
                pHeader + pHeader->dwRealSize, pHeader->dwUserStart, pHeader->dwUserSize, pHeader->pCaller,
                isBoundary(pHeader) ? 'B' : ' ', isAlloc(pHeader) ? '*' : ' ');

            if (isAlloc(pHeader))
            {
                dwBlocksInUse ++;
                dwBytesInUse += pHeader->dwRealSize;
            }
            else
            {
                dwBlocksFree ++;
                dwBytesFree += pHeader->dwRealSize;
            }

            pHeader = pHeader->pNext;
        }
        DPF_LEVEL(NVDBG_LEVEL_HEAP_USAGE, "Blocks in use: %8d", dwBlocksInUse);
        DPF_LEVEL(NVDBG_LEVEL_HEAP_USAGE, "Blocks free  : %8d", dwBlocksFree);
        DPF_LEVEL(NVDBG_LEVEL_HEAP_USAGE, "Bytes in use : %08x", dwBytesInUse);
        DPF_LEVEL(NVDBG_LEVEL_HEAP_USAGE, "Bytes free   : %08x", dwBytesFree);
        DPF_LEVEL(NVDBG_LEVEL_HEAP_USAGE, "**********************");
    }
#endif
}

/*****************************************************************************
 * CInterProcessHeap::init
 *
 * initialize the IP heap
 */
void CInterProcessHeap::init
(
    void
)
{
    // make sure we only do this once since some apps may load the DLL twice
    if (!m_bInitialized) {
        m_pBase        = NULL;
        m_pBaseFree    = NULL;
        m_dwRMID       = IPM_MEMORY_OBJECT_LO;
#ifndef WINNT
        char devName[128];
        DWORD res;
        res = NvRmAllocRoot(&m_dwRootHandle);
        nvAssert(res == NVOS01_STATUS_SUCCESS);
        m_dwDeviceHandle = IPM_DEVICE_HANDLE;
        res = NvRmAllocDevice (m_dwRootHandle, m_dwDeviceHandle, NV01_DEVICE_0, (BYTE*)devName);
        nvAssert(res == NVOS06_STATUS_SUCCESS);
#endif
        m_bInitialized = TRUE;
    }
}

/*****************************************************************************
 * CInterProcessHeap::create
 *
 * alloc IP memory directly from RM to create a new (or bigger) heap
 */
CInterProcessHeap::HEADER* CInterProcessHeap::create
(
    DWORD dwSize
)
{
    DPF_LEVEL(NVDBG_LEVEL_HEAP_ACTIVITY, "---IPM---Create: %08x bytes", dwSize);

    // sanity check
    nvAssert (!(dwSize & 0xfff)); // must be multiple of 4k

    // allocate the memory
    DWORD adwMem[2], dwRes = FALSE, dwExtraFlags = 0;

    dwSize--; // allocator wants a limit, not a size

#ifdef WINNT
    adwMem[0] = (DWORD) EngAllocMem(FL_ZERO_MEMORY, dwSize + 1, 'x_VN');
#else  // !WINNT
    DWORD dwFlags = (NVOS02_FLAGS_PHYSICALITY_NONCONTIGUOUS << 4)
                  | (NVOS02_FLAGS_LOCATION_PCI << 8)
                  | (NVOS02_FLAGS_COHERENCY_CACHED << 12);
    if (global.b16BitCode)
    {
        DRVSERVICE_ALLOC_MEMORY dam;
        dam.dwObjectID   = m_dwRMID;
        dam.dwAllocFlags = dwFlags;
        dam.dwNumBytes   = dwSize + 1;
        dwRes = !DrvCallbackFunc(NV_DRVSERVICE_ALLOC_MEMORY, &dam, adwMem);
        dwExtraFlags = FLAG_16BIT;
    }
    else
    {
        dwRes = NvRmAllocMemory(m_dwRootHandle, m_dwDeviceHandle,
            m_dwRMID,
            NV01_MEMORY_SYSTEM,
            dwFlags,
            (PVOID*)adwMem,
            (unsigned long*)&dwSize);
    }
#endif  // !WINNT

    if (dwRes || (adwMem[0] == NULL))
    {
        DPF ("CInterProcessHeap::create: Memory allocation failed");
        dbgD3DError();
        return  FALSE;
    }


    // populate header
    HEADER *pHeader     = (HEADER*)adwMem[0];
#ifdef DEBUG
    memset (pHeader,0xcc,dwSize);
#endif
    pHeader->dwFlags    = FLAG_BOUNDARY | dwExtraFlags;
    pHeader->dwRealSize = dwSize + 1;
    pHeader->dwRMID     = m_dwRMID;

    // prepare for next
    nvAssert(m_dwRMID < IPM_MEMORY_OBJECT_HI);
    m_dwRMID ++;

    // add new header to list
    AddToList(pHeader);

    // add new header to free list
    AddToFreeList(pHeader);

    return pHeader;
}

__forceinline void CInterProcessHeap::freeBlock(HEADER *pHeader)
{
#ifdef WINNT
    EngFreeMem((PVOID) pHeader);
#else
    nvAssert(!global.b16BitCode);
    if (pHeader->dwFlags & FLAG_16BIT)
    {
        // this block was allocated from 16 bit land, so we need to use an ESC call to free it
        MyExtEscape(pDXShare->dwHeadNumber, NV_ESC_FREE_MEMORY, sizeof(DWORD), (LPCSTR)&pHeader->dwRMID, 0, NULL);
    }
    else
    {
        NvRmFree (m_dwRootHandle, m_dwDeviceHandle, pHeader->dwRMID);
    }
#endif
}

/*****************************************************************************
 * CInterProcessHeap::destroy
 *
 * destroys the IP heap
 */

void CInterProcessHeap::destroy
(
    void
)
{
    dbgTestIntegrity();

    // release all the blocks in the heap
    for (HEADER *pHeader = m_pBase; pHeader;)
    {
        HEADER *pHeader2 = pHeader->pNext;

        if (pHeader2 && !isBoundary(pHeader2))
        {
            // skip towards end of block
            pHeader->pNext = pHeader2->pNext;
        }
        else
        {
            // free the block
            nvAssert(isBoundary(pHeader));
            freeBlock(pHeader);
            pHeader = pHeader2;
        }
    }

#ifndef WINNT
    DWORD res = NvRmFree (m_dwRootHandle, NV01_NULL_OBJECT, m_dwRootHandle);
    nvAssert(res == NVOS00_STATUS_SUCCESS);
#endif

    // reset
    m_pBase     = NULL;
    m_pBaseFree = NULL;
    m_bInitialized = FALSE;
}

/*****************************************************************************
 * CInterProcessHeap::combineFreeBlocks
 *
 * combine adjacent free blocks so we have larger available space in a
 *  once fragmented heap
 */
void CInterProcessHeap::combineFreeBlocks
(
    void
)
{
    // for all blocks
    for (HEADER *pHeader = m_pBase; pHeader;)
    {
        HEADER *pHeader2 = pHeader->pNext;

        // combinable?
        if (pHeader2
         && isFree(pHeader)
         && !isBoundary(pHeader2)
         && isFree(pHeader2))
        {
            // combine
            pHeader->dwRealSize += pHeader2->dwRealSize;
            pHeader->pNext       = pHeader2->pNext;
            if (pHeader->pNext) pHeader->pNext->pPrev = pHeader;

            RemoveFromFreeList(pHeader2);

            // test
            dbgTestIntegrity();
        }
        else
        {
            pHeader = pHeader2;
        }
    }
}

/*****************************************************************************
 * CInterProcessHeap::releaseFreeBlocks
 *
 * releases any heap blocks that are no longer in use
 * note that the heap must be defragmented first with combineFreeBlocks for this to work properly
 */
void CInterProcessHeap::releaseFreeBlocks
(
    void
)
{
    HEADER *pHeader = m_pBase;

    while (pHeader)
    {
        HEADER *pNext = pHeader->pNext;

        if (pNext)
        {
            // release the block only if all parts are free
            if (isBoundary(pHeader)
             && isFree(pHeader)
             && isBoundary(pNext))
            {
                RemoveFromList(pHeader);
                RemoveFromFreeList(pHeader);
                freeBlock(pHeader);
            }
        }
        else
        {
            // this is the last block
            if (isFree(pHeader)
             && isBoundary(pHeader))
            {
                RemoveFromList(pHeader);
                RemoveFromFreeList(pHeader);
                freeBlock(pHeader);
            }
        }

        // get next header
        pHeader = pNext;
    }
}

/*****************************************************************************

 * CInterProcessHeap::alloc
 *
 * allocates IP memory
 */
void* CInterProcessHeap::alloc
(
#ifdef DEBUG
    DWORD dwSize,
    void *pCaller // = 0
#else
    DWORD dwSize
#endif
)
{
    dbgTestIntegrity();

#ifdef DEBUG
    if (!pCaller)
    {
        _asm mov eax, [EBP]
        _asm mov eax, [eax + 4]
        _asm mov [pCaller], eax
    }
    DPF_LEVEL(NVDBG_LEVEL_HEAP_ACTIVITY, "---IPM---Alloc: %08x bytes, pCaller = %08x", dwSize, pCaller);
#endif // DEBUG

    // find a free block to use. we make three passes:
    //  1) look for a block
    //  2) apply defragmentation, then look again
    //  3) allocate a block we know must be big enough, looking for it cannot fail
    DWORD dwRealSize     = dwSize + sizeof(HEADER) + ALIGN; // size to fit
    DWORD dwRequiredSize = dwRealSize + sizeof(HEADER);     // size for a split

    for (DWORD dwTry = 0; ; dwTry++)
    {
        // look for free space
        for (HEADER *pHeader = m_pBaseFree; pHeader; pHeader = pHeader->pNextFree)
        {
            // will it fit in a block without splitting up?
            if ((pHeader->dwRealSize >= dwRealSize)             // at least big enough
                && (pHeader->dwRealSize <= (dwRealSize + 128))) // not too big
            {
                // found a block
                pHeader->dwFlags    |= FLAG_ALLOCATED;
                pHeader->dwUserSize  = dwSize;
                pHeader->dwUserStart = (DWORD(pHeader) + sizeof(HEADER) + ALIGN - 1) & ~(ALIGN - 1);
                *(DWORD*)(pHeader->dwUserStart - 4) = DWORD(pHeader);
#ifdef DEBUG
                pHeader->pCaller = pCaller;
#endif

                RemoveFromFreeList(pHeader);

                // sanity check
                dbgTestIntegrity();

                // done
                DPF_LEVEL(NVDBG_LEVEL_HEAP_ACTIVITY, "              : ptr = %08x", pHeader->dwUserStart);
                return (void*)pHeader->dwUserStart;
            }
            else
                // will it fit in a large block that we split up?
                if (pHeader->dwRealSize >= dwRequiredSize)
                {
                    // found a block, split it up
                    HEADER *pHeader2     = (HEADER*)(DWORD(pHeader) + dwRealSize);
                    pHeader2->dwFlags    = 0;
                    pHeader2->dwRealSize = pHeader->dwRealSize - dwRealSize;
                    pHeader2->pPrev      = pHeader;
                    pHeader2->pNext      = pHeader->pNext;

                    if (pHeader->pNext) pHeader->pNext->pPrev = pHeader2;

                    AddToFreeList(pHeader2);

                    pHeader->pNext       = pHeader2;
                    pHeader->dwRealSize  = dwRealSize;
                    pHeader->dwFlags    |= FLAG_ALLOCATED;
                    pHeader->dwUserSize  = dwSize;
                    pHeader->dwUserStart = (DWORD(pHeader) + sizeof(HEADER) + ALIGN - 1) & ~(ALIGN - 1);
                    *(DWORD*)(pHeader->dwUserStart - 4) = DWORD(pHeader);
#ifdef DEBUG
                    pHeader->pCaller = pCaller;
#endif

                    RemoveFromFreeList(pHeader);

                    // sanity check
                    assert (pHeader2->dwRealSize >= sizeof(HEADER));
                    assert ((pHeader->dwUserStart + pHeader->dwUserSize) <= DWORD(pHeader2));
                    dbgTestIntegrity();

                    // done
                    DPF_LEVEL(NVDBG_LEVEL_HEAP_ACTIVITY, "              : ptr = %08x", pHeader->dwUserStart);
                    return (void*)pHeader->dwUserStart;
                }
        }

        // do something before we try again
        switch (dwTry)
        {
            case 0:
            {
                // combine adjacent free blocks
                combineFreeBlocks();
                break;
            }
            default:
            {
                // alloc a large enough block
                DWORD dwBlockSize = max(dwRequiredSize,65536);
                      dwBlockSize = (dwBlockSize + 4095) & ~4095;
                if (!create(dwBlockSize))
                {
                    return NULL;
                }
                break;
            }
        }
    }
}

/*****************************************************************************
 * CInterProcessHeap::realloc
 *
 * resize IP memory
 */
BOOL CInterProcessHeap::realloc
(
    void  *pOldMem,
    DWORD  dwNewSize,
    void  **ppNewMem
)
{
    HEADER *pHeader;

#ifdef DEBUG
    void* pCaller;
    _asm mov eax, [EBP]
    _asm mov eax, [eax + 4]
    _asm mov [pCaller], eax
#endif // DEBUG

    DPF_LEVEL(NVDBG_LEVEL_HEAP_ACTIVITY, "---IPM---ReAlloc: ptr = %08x, size = %d", pOldMem, dwNewSize);

    nvAssert(dwNewSize);

    // defragment the heap
    combineFreeBlocks();

    // realloc by resizing the old block if possible
    if (pOldMem)
    {
        pHeader = (HEADER*)*(DWORD*)(DWORD(pOldMem) - 4);
        HEADER *pHeader2 = pHeader->pNext;

        if (pHeader2
         && isFree(pHeader2)
         && !isBoundary(pHeader2))
        {
            DWORD dwCombinedSize = pHeader->dwRealSize + pHeader2->dwRealSize; // total size of combined blocks
            DWORD dwRequiredSize = dwNewSize + sizeof(HEADER) + ALIGN;         // size required

            if (dwCombinedSize >= dwRequiredSize + sizeof(HEADER) + 128) // size required for split with some spare change
            {
                // adjust the free block (pHeader2)
                HEADER *pNewHeader     = (HEADER*)(DWORD(pHeader) + dwRequiredSize);
                pNewHeader->pPrevFree  = pHeader2->pPrevFree; // must set these four first, in this order
                pNewHeader->pPrev      = pHeader2->pPrev;     // in case of overlap between pNewHeader and pHeader2
                pNewHeader->pNextFree  = pHeader2->pNextFree;
                pNewHeader->pNext      = pHeader2->pNext;
                pNewHeader->dwFlags    = 0;                   // mark block as free
                pNewHeader->dwRealSize = dwCombinedSize - dwRequiredSize;

                // update linked references to the adjusted free block
                if (pNewHeader->pPrev)     pNewHeader->pPrev->pNext     = pNewHeader;
                if (pNewHeader->pNext)     pNewHeader->pNext->pPrev     = pNewHeader;
                nvAssert(m_pBase != pHeader2);
                if (pNewHeader->pPrevFree)   pNewHeader->pPrevFree->pNextFree = pNewHeader;
                if (pNewHeader->pNextFree)   pNewHeader->pNextFree->pPrevFree = pNewHeader;
                if (m_pBaseFree == pHeader2) m_pBaseFree = pNewHeader;

                // enlarge the allocated block (pHeader)
                nvAssert(isAlloc(pHeader));
                pHeader->dwRealSize  = dwRequiredSize;
                pHeader->dwUserSize  = dwNewSize;

                dbgTestIntegrity();

                *ppNewMem = pOldMem;
                return TRUE;
            }
            else if (dwCombinedSize >= dwRequiredSize)
            {
                // combine
                pHeader->dwRealSize += pHeader2->dwRealSize;
                pHeader->dwUserSize  = dwNewSize;
                pHeader->pNext       = pHeader2->pNext;
                if (pHeader->pNext) pHeader->pNext->pPrev = pHeader;

                RemoveFromFreeList(pHeader2);

                dbgTestIntegrity();

                *ppNewMem = pOldMem;
                return TRUE;
            }
        }
    }

    // realloc by copying to new block
#ifdef DEBUG
    *ppNewMem = alloc(dwNewSize, pCaller);
#else // !DEBUG
    *ppNewMem = alloc(dwNewSize);
#endif // !DEBUG
    if (!*ppNewMem) return FALSE;

    if (pOldMem)
    {
        DPF_LEVEL(NVDBG_LEVEL_HEAP_ACTIVITY, "                : memcpy (%08x, %08x, %d)", *ppNewMem, pOldMem, pHeader->dwUserSize);
        memcpy (*ppNewMem, pOldMem, pHeader->dwUserSize);
        free (pOldMem);
    }

    return TRUE;
}

/*****************************************************************************
 * CInterProcessHeap::free
 *
 * free IP memory
 */
void CInterProcessHeap::free
(
    void *pMemory
)
{
    dbgTestIntegrity();

    DPF_LEVEL(NVDBG_LEVEL_HEAP_ACTIVITY, "---IPM---Free: ptr = %08x", pMemory);

    // get header
    HEADER *pHeader = (HEADER*)*(DWORD*)(DWORD(pMemory) - 4);

    // this will assert if we try to free the same memory twice
    nvAssert(pHeader->dwFlags & FLAG_ALLOCATED);

    // free it
    if (pHeader->dwFlags & FLAG_ALLOCATED)
    {
        pHeader->dwFlags &= ~FLAG_ALLOCATED;
        AddToFreeList(pHeader);
    }

    // done
    dbgTestIntegrity();
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvMem.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvMem.cpp                                                         *
*   NVIDIA Fast memory copy loops - copyright strictly enforced             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 11/05/98 - Created                      *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#include "x86.h"

/*
 * local macros
 */
#define movaps_r_rm8(r,rm,ofs)      __asm _emit 0x0f __asm _emit 0x28 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movaps_rm8_r(rm,ofs,r)      __asm _emit 0x0f __asm _emit 0x29 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movups_r_rm8(r,rm,ofs)      __asm _emit 0x0f __asm _emit 0x10 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movups_rm8_r(rm,ofs,r)      __asm _emit 0x0f __asm _emit 0x11 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define prefetch_rm8(h,rm,ofs)      __asm _emit 0x0f __asm _emit 0x18 __asm _emit (mREG(h) | (rm)) __asm _emit (ofs)

/*
 * nvMemCopy1
 *
 * copies src to dest using byte atoms
 */
__inline void nvMemCopy1
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount
)
{
    while (dwCount)
    {
        *(BYTE*)dwDest = *(BYTE*)dwSrc;
        dwSrc  ++;
        dwDest ++;
        dwCount--;
    }
}

/*
 * nvMemCopy4
 *
 * copies src to dest using dword atoms.
 */
__inline void nvMemCopy4
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount   // in dwords
)
{
    while (dwCount)
    {
        *(DWORD*)dwDest = *(DWORD*)dwSrc;
        dwSrc  += 4;
        dwDest += 4;
        dwCount--;
    }
}

/*
 * nvMemCopy16
 *
 * copies src to dest using 4*dword atoms (if possible).
 */
__inline void nvMemCopy16
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount
)
{
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
    {
        if (dwSrc & 15)
        {
            if (dwDest & 15)
            {
                __asm
                {
                    push ebx
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_11: movups_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movups_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_11
                    pop ebx
                }
            }
            else
            {
                __asm
                {
                    push ebx
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_12: movups_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movaps_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_12
                    pop ebx
                }
            }
        }
        else
        {
            if (dwDest & 15)
            {
                __asm
                {
                    push ebx
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_13: movaps_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movups_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_13
                    pop ebx
                }
            }
            else
            {
                __asm
                {
                    push ebx
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_14: movaps_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movaps_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_14
                    pop ebx
                }
            }
        }
    }
    else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_MMX)
    {
        __asm
        {
            push ebx
            mov ebx,[dwSrc]
            mov edx,[dwDest]
            mov ecx,[dwCount]
mc16_2:      movq mm0,[ebx]
             movq mm1,[ebx+8]
             add ebx,16
             movq [edx],mm0
             movq [edx+8],mm1
             add edx,16
             dec ecx
            jnz mc16_2
            emms
            pop ebx
        }
    }
    else
    {
        nvMemCopy4 (dwDest,dwSrc,dwCount*4);
    }
}

/*
 * nvMemCopy64
 *
 * copies src to dest using 16*dword atoms (if possible).
 */
__inline void nvMemCopy64
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount   // in dwords
)
{
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
    {
        if (dwSrc & 15)
        {
            if (dwDest & 15)
            {
                __asm
                {
                    push ebx
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_11:     movups_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movups_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movups_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movups_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64
                     movups_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movups_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movups_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movups_rm8_r (rmIND8(rEDX),48,rXMM3)
                     add edx,64
                     dec ecx
                    jnz mc64_11
                    pop ebx
                }
            }
            else
            {
                __asm
                {
                    push ebx
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_12:     movups_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movups_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movups_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movups_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64
                     movaps_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movaps_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movaps_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movaps_rm8_r (rmIND8(rEDX),48,rXMM3)
                     add edx,64
                     dec ecx
                    jnz mc64_12
                    pop ebx
                }
            }
        }
        else
        {
            if (dwDest & 15)
            {
                __asm
                {
                    push ebx
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_13:     movaps_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movaps_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movaps_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movaps_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64
                     movups_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movups_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movups_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movups_rm8_r (rmIND8(rEDX),48,rXMM3)
                     add edx,64
                     dec ecx
                    jnz mc64_13
                    pop ebx
                }
            }
            else
            {
                __asm
                {
                    push ebx
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_14:     movaps_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movaps_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movaps_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movaps_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64

                     movaps_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movaps_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movaps_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movaps_rm8_r (rmIND8(rEDX),48,rXMM3)

                     add edx,64
                     dec ecx
                    jnz mc64_14
                    pop ebx
                }
            }
        }
    }
    else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_MMX)
    {
        __asm
        {
            push ebx
            mov ebx,[dwSrc]
            mov edx,[dwDest]
            mov ecx,[dwCount]
mc64_2:      movq mm0,[ebx+ 0]
             movq mm1,[ebx+ 8]
             movq mm2,[ebx+16]
             movq mm3,[ebx+24]
             movq mm4,[ebx+32]
             movq mm5,[ebx+40]
             movq mm6,[ebx+48]
             movq mm7,[ebx+56]
             add ebx,64
             movq [edx+ 0],mm0
             movq [edx+ 8],mm1
             movq [edx+16],mm2
             movq [edx+24],mm3
             movq [edx+32],mm4
             movq [edx+40],mm5
             movq [edx+48],mm6
             movq [edx+56],mm7
             add edx,64
             dec ecx
            jnz mc64_2
            emms
            pop ebx
        }
    }
    else
    {
        nvMemCopy4 (dwDest,dwSrc,dwCount*16);
    }
}

typedef void (__cdecl *PFNCUSTOMCOPY)(DWORD dwDest,DWORD dwSrc);
typedef void (__cdecl *PFNCUSTOMCOPY2)(DWORD dwDest,DWORD dwSrc,DWORD dwCnt);

/*
 * nvMemCopy
 *
 * copy memory as fast as we can
 */
void nvMemCopy
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount
)
{
#ifdef DEBUG
    if (IsBadReadPtr((void*)dwSrc,dwCount)
     || IsBadWritePtr((void*)dwDest,dwCount))
    {
        DPF ("nvMemCopy: bad copy requested. Call ignored.");
        __asm int 3;
        return;
    }
#endif
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
    {                        
        if ( (dwCount >= 2048) && (dwDest & 0x3f) )
        {
            if (!global.adwMemCopy[0])
            {
                global.adwMemCopy[0] = nvBuildCustomCopyRoutineMisAligned();
            }
            PFNCUSTOMCOPY2 pfn = (PFNCUSTOMCOPY2)(global.dwILCData + global.adwMemCopy[0]);
            pfn (dwDest,dwSrc,dwCount);
        }
        else
        {
            
            //
            // copy large blocks
            //
            if (dwCount >= 256)
            {
                if (!global.adwMemCopy[128])
                {
                    global.adwMemCopy[128] = nvBuildCustomCopyRoutine(128);
                }

                PFNCUSTOMCOPY pfn = (PFNCUSTOMCOPY)(global.dwILCData + global.adwMemCopy[128]);
                DWORD dwPrefetchSrc = dwSrc;
                while (dwCount >= 128)
                {
                    if (dwPrefetchSrc <= dwSrc)
                    {
                        DWORD dwPrefetchCount = min(2048,dwCount);
                        __asm
                        {
                            mov ecx,[dwPrefetchCount]
                            mov eax,[dwPrefetchSrc]
                        next0:
                             cmp ecx,4
                             jl  done0
                             mov edx,[eax]
                             sub ecx,32
                             add eax,32
                            jmp next0
                        done0:
                            mov [dwPrefetchSrc],eax
                        }
                    }

                    pfn (dwDest,dwSrc);
                    dwSrc   += 128;
                    dwDest  += 128;
                    dwCount -= 128;
                }
            }

            //
            // copy small blocks
            //
            if (dwCount)
            {
                if (!global.adwMemCopy[dwCount])
                {
                    // build routine
                    global.adwMemCopy[dwCount] = nvBuildCustomCopyRoutine(dwCount);
                }
                ((PFNCUSTOMCOPY)(global.dwILCData + global.adwMemCopy[dwCount]))(dwDest,dwSrc);
            }
        }
    }
    else
   {


        //
        // copy large blocks
        //
        if (dwCount >= 256)
        {
            if (!global.adwMemCopy[128])
            {
                global.adwMemCopy[128] = nvBuildCustomCopyRoutine(128);
            }

            PFNCUSTOMCOPY pfn = (PFNCUSTOMCOPY)(global.dwILCData + global.adwMemCopy[128]);
            DWORD dwPrefetchSrc = dwSrc;
            while (dwCount >= 128)
            {
                if (dwPrefetchSrc <= dwSrc)
                {
                    DWORD dwPrefetchCount = min(2048,dwCount);
                    __asm
                    {
                        mov ecx,[dwPrefetchCount]
                        mov eax,[dwPrefetchSrc]
                    next:
                         cmp ecx,4
                         jl  done
                         mov edx,[eax]
                         sub ecx,32
                         add eax,32
                        jmp next
                    done:
                        mov [dwPrefetchSrc],eax
                    }
                }

                pfn (dwDest,dwSrc);
                dwSrc   += 128;
                dwDest  += 128;
                dwCount -= 128;
            }
        }

        //
        // copy small blocks
        //
        if (dwCount)
        {
            if (!global.adwMemCopy[dwCount])
            {
                // build routine
                global.adwMemCopy[dwCount] = nvBuildCustomCopyRoutine(dwCount);
            }
            ((PFNCUSTOMCOPY)(global.dwILCData + global.adwMemCopy[dwCount]))(dwDest,dwSrc);
        }
    }
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvMini.cpp ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvMini.cpp                                                        *
* Hardware specific driver setup routines.                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman               01/31/98 - created.                     *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#if IS_WIN9X
#include <stdio.h> // For sprintf
#endif

#include "nvReg.h"

//---------------------------------------------------------------------------

/*
 * Developer Identification String
 * Before sending a pre-release driver to a developer, this data can be modified in the binary to identify
 * the developer it is being sent to.  This will give us an identification mechanism if the driver mysteriously
 * finds it's way on the the net.
 */
BYTE bDeveloperID[32 + 32] =
{
    0x0F, 0xAD, 0xCA, 0xFE, 0xDE, 0xAF, 0xFE, 0xED,
    0xDE, 0xAF, 0xBA, 0xBE, 0xDE, 0xAD, 0xF0, 0x0D,
    0x0B, 0xAD, 0xCA, 0xFE, 0x0D, 0xEA, 0xDF, 0xED,
    0xDE, 0xAD, 0xBA, 0xBE, 0x0B, 0xAD, 0xF0, 0x0D,

    0x61, 0x34, 0x42, 0x34, 0xf6, 0xf4, 0x82, 0xe1,
    0xb7, 0xec, 0x5c, 0x23, 0x82, 0x00, 0x60, 0x84,
    0x67, 0x8c, 0x45, 0x2c, 0x47, 0x31, 0x85, 0x32,
    0x30, 0x05, 0x06, 0x20, 0x93, 0x10, 0x40, 0x92,
};

//---------------------------------------------------------------------------

//
// Query a value in the D3D driver registry key
//
#ifdef WINNT
BOOL  NvD3DRegQueryDwordValueNT(PDEV *pdev, LPCTSTR valuename, LPDWORD value)
{

   CHAR  newvaluename[256];      // This should be more then enough space
   WCHAR tmpStrBuf[256];
   ULONG  inpStrLen, outStrLen;
   DWORD retStatus;
   DWORD keyValSize;

   // Make sure that we have something with meaning
   if (!valuename)
       return (FALSE);

   // We need to prepend this for NT
   strcpy(newvaluename,"D3D_");

   // Tac on the value name given to us
   strcat(newvaluename,valuename);

   // Get the combined length for conversion to unicode
   inpStrLen = strlen(newvaluename);

   // Make sure it fits in our non-dynamically allocated buffer
   if ((inpStrLen+1) > 256)
       return (FALSE);

   // The miniport only likes unicode
   EngMultiByteToUnicodeN((LPWSTR)tmpStrBuf, 256*sizeof(WCHAR), &outStrLen,
                          (char *)newvaluename, (inpStrLen+1)*sizeof(CHAR));

   // Ask the miniport for help on this one
   retStatus = EngDeviceIoControl(pdev->hDriver,
                               IOCTL_VIDEO_QUERY_REGISTRY_VAL,
                               (LPVOID)tmpStrBuf,
                               outStrLen,
                               (LPVOID) value,
                               sizeof(DWORD),
                               &keyValSize);


   // Make a final decision on this whole thing
   if(retStatus == NO_ERROR) {
      return (TRUE);
   }
   else {
      return (FALSE);
   }

}
#endif

//---------------------------------------------------------------------------

BOOL nvReadRegistryDWORD
(
#ifdef WINNT
    PDEV   *pDev,
#else
    HKEY    hKey,
#endif
    LPCTSTR lpValueName,
    LPDWORD lpData
)
{
#ifdef WINNT
    return NvD3DRegQueryDwordValueNT(pDev,lpValueName,lpData);
#else
    DWORD dwType  = REG_DWORD;
    DWORD dwCount = sizeof(DWORD);
    return (RegQueryValueEx (hKey,lpValueName,NULL,&dwType,(BYTE*)lpData,&dwCount) == ERROR_SUCCESS);
#endif
}

//---------------------------------------------------------------------------

BOOL nvReadRegistryString
(
#ifdef WINNT
    PDEV   *pDev,
#else
    HKEY    hKey,
#endif
    LPCTSTR lpValueName,
    LPBYTE  lpData
)
{
#ifdef WINNT
    return (FALSE);
#else
    DWORD dwType  = REG_SZ;
    DWORD dwCount = D3D_REG_STRING_LENGTH;
    return (RegQueryValueEx (hKey,lpValueName,NULL,&dwType,lpData,&dwCount) == ERROR_SUCCESS);
#endif
}

//---------------------------------------------------------------------------

// open the D3D registry key for the device associated with this
// instance of DirectX

HKEY OpenLocalD3DRegKey (void)
{
#ifdef WINNT    // We do nothing on NT
    return NULL;
#else           // !WINNT
    HKEY        hKey, hPrimaryKey;
    char        lpLocalRegPath[128];
    char        lpD3DSubKey[256];
    static BOOL bPrintedKeyBefore = FALSE;

    // get the registry path for this particular device
    // (of the many devices possible in a multi-mon configuration)
    MyExtEscape (pDXShare->dwHeadNumber, NV_ESC_GET_LOCAL_REGISTRY_PATH, 0, NULL, 128, lpLocalRegPath);

    // the first DWORD of the value returned is the primary key (e.g. HKEY_LOCAL_MACHINE)
    hPrimaryKey = (HKEY)(*(DWORD *)lpLocalRegPath);

    // the NV subkey for this device starts after the first four bytes.
    // concatenate this with D3D's subtree's name
    sprintf (lpD3DSubKey, "%s\\%s", lpLocalRegPath+4, NV4_REG_DIRECT3D_SUBKEY);

    //
    // for the mere mortals among us, print this damn key so that we know where to look
    //
    if (!bPrintedKeyBefore)
    {
        DPF ("---------------- NVDD32.DLL ----------------------");
        DPF ("REG: %s", lpD3DSubKey);
        bPrintedKeyBefore = TRUE;
    }

    //
    // open it
    //
    if (RegOpenKeyEx(hPrimaryKey, lpD3DSubKey, 0, KEY_QUERY_VALUE, &hKey) != ERROR_SUCCESS) {
        hKey = NULL;
    }

    return (hKey);
#endif  // !WINNT
}

//---------------------------------------------------------------------------

/*
 * Read the current driver settings from the registry.
 */
#pragma warning(disable: 4296)

void D3DReadRegistry
(
    GLOBALDATA *pDriverData
)
{
    dbgTracePush("D3DReadRegistry");

    /*
     * Set the defaults first.
     */
    // booleans
    getDC()->nvD3DRegistryData.regD3DEnableBits1       =     D3D_REG_DEFAULT_ALTERNATEZENABLE
                                                           | D3D_REG_DEFAULT_ANTIALIASENABLE
                                                           | D3D_REG_DEFAULT_ANTIALIASFORCEENABLE
                                                           | D3D_REG_DEFAULT_ANTIALIASCONVOLUTIONFASTMODE
                                                           | D3D_REG_DEFAULT_CKCOMPATABILITYENABLE
                                                           | D3D_REG_DEFAULT_CONTROLTRAFFICENABLE
                                                           | D3D_REG_DEFAULT_DIRECTMAPENABLE
                                                           | D3D_REG_DEFAULT_ENFORCESTRICTTRILINEAR
                                                           | D3D_REG_DEFAULT_FLUSHAFTERBLITENABLE
                                                           | D3D_REG_DEFAULT_FOGTABLEENABLE
                                                           | D3D_REG_DEFAULT_FORCEBLITWAITFLAGENABLE
                                                           | D3D_REG_DEFAULT_LIMITQUEUEDFBBLITSENABLE
                                                           | D3D_REG_DEFAULT_LOGOENABLE
#ifndef TEXFORMAT_CRD
                                                           | D3D_REG_DEFAULT_PALETTEENABLE
#endif  // !TEXFORMAT_CRD
                                                           | D3D_REG_DEFAULT_SQUASHW
                                                           | D3D_REG_DEFAULT_SSYNCENABLE
#ifndef TEXFORMAT_CRD
                                                           | D3D_REG_DEFAULT_TEXTURECOMPRESSIONENABLE
#endif  // !TEXFORMAT_CRD
                                                           | D3D_REG_DEFAULT_TEXTUREMANAGEMENTENABLE
                                                           | D3D_REG_DEFAULT_TILINGENABLE
                                                           | D3D_REG_DEFAULT_ZCULLENABLE

                                                           | D3D_REG_DEFAULT_USERMIPMAPENABLE
                                                           | D3D_REG_DEFAULT_VIDEOTEXTUREENABLE
                                                           | D3D_REG_VS_HOS_EMULATION_DISABLE
                                                           | D3D_REG_DEFAULT_WBUFFERENABLE
                                                           | D3D_REG_DEFAULT_Z24ENABLE
                                                           | D3D_REG_DEFAULT_ZCOMPRESSENABLE;

    // non-boolean enumerated values
    getDC()->nvD3DRegistryData.regCaptureConfig           = D3D_REG_DEFAULT_CAPTURCONFIG;
    getDC()->nvD3DRegistryData.regCaptureEnable           = D3D_REG_DEFAULT_CAPTURENABLE;
    getDC()->nvD3DRegistryData.regMipMapDitherMode        = D3D_REG_DEFAULT_MIPMAPDITHERMODE;
#ifdef TEXFORMAT_CRD
    getDC()->nvD3DRegistryData.regSurfaceFormatsDX7       = D3D_REG_DEFAULT_SURFACEFORMATSDX7;
    getDC()->nvD3DRegistryData.regSurfaceFormatsDX8       = D3D_REG_DEFAULT_SURFACEFORMATSDX8;
#endif  // TEXFORMAT_CRD
    getDC()->nvD3DRegistryData.regTexelAlignment          = D3D_REG_DEFAULT_TEXELALIGNMENT;
    getDC()->nvD3DRegistryData.regTextureManageStrategy   = D3D_REG_DEFAULT_TEXTUREMANAGESTRATEGY;
    getDC()->nvD3DRegistryData.regValidateZMethod         = D3D_REG_DEFAULT_VALIDATEZMETHOD;
    getDC()->nvD3DRegistryData.regVSyncMode               = D3D_REG_DEFAULT_VSYNCMODE;
    getDC()->nvD3DRegistryData.regW16Format               = D3D_REG_DEFAULT_W16FORMAT;
    getDC()->nvD3DRegistryData.regW32Format               = D3D_REG_DEFAULT_W32FORMAT;

    // non-boolean non-enumerated values
    getDC()->nvD3DRegistryData.regAACompatibilityBits     = D3D_REG_DEFAULT_AACOMPATIBILITYBITS;
    getDC()->nvD3DRegistryData.regAAReadCompatibilityFile = D3D_REG_DEFAULT_AAREADCOMPATIBILITYFILE;
    getDC()->nvD3DRegistryData.regAntiAliasQuality        = D3D_REG_DEFAULT_ANTIALIASQUALITY;
    getDC()->nvD3DRegistryData.regAntiAliasDynamicMSpF    = D3D_REG_DEFAULT_ANTIALIASDYNAMICFPS;
    getDC()->nvD3DRegistryData.regAGPTexCutOff            = D3D_REG_DEFAULT_AGPTEXCUTOFF;
    getDC()->nvD3DRegistryData.regCapturePlayFilenum      = D3D_REG_DEFAULT_CAPTUREPLAYFILENUM;
    getDC()->nvD3DRegistryData.regCaptureRecordFilenum    = D3D_REG_DEFAULT_CAPTURERECORDFILENUM;
    getDC()->nvD3DRegistryData.regColorkeyRef             = D3D_REG_DEFAULT_CKREF;
    getDC()->nvD3DRegistryData.regD3DContextMax           = D3D_REG_DEFAULT_D3DCONTEXTMAX;
    getDC()->nvD3DRegistryData.regD3DTextureMax           = D3D_REG_DEFAULT_D3DTEXTUREMAX;
    getDC()->nvD3DRegistryData.regDebugLevel              = D3D_REG_DEFAULT_DEBUGLEVEL;
    getDC()->nvD3DRegistryData.regAnisotropicLevel        = D3D_REG_DEFAULT_ANISOTROPICLEVEL;
    getDC()->nvD3DRegistryData.regLODBiasAdjust           = D3D_REG_DEFAULT_LODBIASADJUST;
    getDC()->nvD3DRegistryData.regMinVideoTextureSize     = D3D_REG_DEFAULT_MINVIDEOTEXSIZE;
    getDC()->nvD3DRegistryData.regPCITexHeapSize          = D3D_REG_DEFAULT_PCITEXHEAPSIZE;
    getDC()->nvD3DRegistryData.regPreRenderLimit          = D3D_REG_DEFAULT_PRERENDERLIMIT;
    getDC()->nvD3DRegistryData.regPushBufferSizeMax       = D3D_REG_DEFAULT_PUSHBUFFERSIZEMAX;
    getDC()->nvD3DRegistryData.regfWScale16               = (float)((DWORD)D3D_REG_DEFAULT_WSCALE16);
    getDC()->nvD3DRegistryData.regfWScale24               = (float)((DWORD)D3D_REG_DEFAULT_WSCALE24);
    getDC()->nvD3DRegistryData.regfZBias                  = D3D_REG_DEFAULT_ZBIAS;

    // strings
    nvStrNCpy (getDC()->nvD3DRegistryData.regszCapturePlayFilename,   D3D_REG_DEFAULT_CAPTUREPLAYFILENAME,   D3D_REG_STRING_LENGTH);
    nvStrNCpy (getDC()->nvD3DRegistryData.regszCapturePlayPath,       D3D_REG_DEFAULT_CAPTUREPLAYPATH,       D3D_REG_STRING_LENGTH);
    nvStrNCpy (getDC()->nvD3DRegistryData.regszCaptureRecordFilename, D3D_REG_DEFAULT_CAPTURERECORDFILENAME, D3D_REG_STRING_LENGTH);
    nvStrNCpy (getDC()->nvD3DRegistryData.regszCaptureRecordPath,     D3D_REG_DEFAULT_CAPTURERECORDPATH,     D3D_REG_STRING_LENGTH);

    // DirectX VA default flags
    pDriverData->dwDXVAFlags = DXVA_ENABLED_IN_REGISTRY;

    // Next try reading the overrides from the registry.
    DWORD dwValue;
    char  szString[D3D_REG_STRING_LENGTH];

#ifdef WINNT
    PDEV *hKey = ppdev;
#else
    HKEY  hKey = OpenLocalD3DRegKey();
    if (hKey)
#endif
    {
        decryptRegistryKeys();

        // booleans
        if (nvReadRegistryDWORD(hKey,reg.szAntiAliasEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_ANTIALIASENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_ANTIALIASENABLE_ENABLE : D3D_REG_ANTIALIASENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szAntiAliasForceEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_ANTIALIASFORCEENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_ANTIALIASFORCEENABLE_ENABLE : D3D_REG_ANTIALIASFORCEENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szAntiAliasDynamicEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_ANTIALIASDYNAMICENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_ANTIALIASDYNAMICENABLE_ENABLE : D3D_REG_ANTIALIASDYNAMICENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szAntiAliasConvolutionFastModeString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_ANTIALIASCONVOLUTIONFASTMODE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_ANTIALIASCONVOLUTIONFASTMODE_ENABLE : D3D_REG_ANTIALIASCONVOLUTIONFASTMODE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szAntiAliasQualityString,&dwValue))
        {
            if (dwValue < D3D_REG_ANTIALIASQUALITY_MIN) dwValue = D3D_REG_ANTIALIASQUALITY_MIN;
            if (dwValue > D3D_REG_ANTIALIASQUALITY_MAX) dwValue = D3D_REG_ANTIALIASQUALITY_MAX;
            getDC()->nvD3DRegistryData.regAntiAliasQuality = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szAntiAliasDynamicFPS,&dwValue))
        {
            if (dwValue < D3D_REG_ANTIALIASDYNAMICFPS_MIN) dwValue = D3D_REG_ANTIALIASDYNAMICFPS_MIN;
            if (dwValue > D3D_REG_ANTIALIASDYNAMICFPS_MAX) dwValue = D3D_REG_ANTIALIASDYNAMICFPS_MAX;
            getDC()->nvD3DRegistryData.regAntiAliasDynamicMSpF = 1000 / dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szCKCompatabilityEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_CKCOMPATABILITYENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_CKCOMPATABILITYENABLE_ENABLE : D3D_REG_CKCOMPATABILITYENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szDirectMapEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_DIRECTMAPENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_DIRECTMAPENABLE_ENABLE : D3D_REG_DIRECTMAPENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szEnforceStrictTrilinearString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_ENFORCESTRICTTRILINEAR_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_ENFORCESTRICTTRILINEAR_ENABLE : D3D_REG_ENFORCESTRICTTRILINEAR_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szFlushAfterBlitEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_FLUSHAFTERBLITENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_FLUSHAFTERBLITENABLE_ENABLE : D3D_REG_FLUSHAFTERBLITENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szFogTableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_FOGTABLEENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_FOGTABLEENABLE_ENABLE : D3D_REG_FOGTABLEENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szForceBlitWaitFlagEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_FORCEBLITWAITFLAGENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_FORCEBLITWAITFLAGENABLE_ENABLE : D3D_REG_FORCEBLITWAITFLAGENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szLimitQueuedFBBlitsEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_LIMITQUEUEDFBBLITSENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_LIMITQUEUEDFBBLITSENABLE_ENABLE : D3D_REG_LIMITQUEUEDFBBLITSENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szLogoEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_LOGOENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_LOGOENABLE_ENABLE : D3D_REG_LOGOENABLE_DISABLE;
        }

#ifndef TEXFORMAT_CRD
        if (nvReadRegistryDWORD(hKey,reg.szPaletteEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_PALETTEENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_PALETTEENABLE_ENABLE : D3D_REG_PALETTEENABLE_DISABLE;
        }
#endif  // !TEXFORMAT_CRD

        if (nvReadRegistryDWORD(hKey,reg.szSquashWString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_SQUASHW_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_SQUASHW_ENABLE : D3D_REG_SQUASHW_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szSceneSyncString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_SSYNCENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_SSYNCENABLE_ENABLE : D3D_REG_SSYNCENABLE_DISABLE;
        }

#ifndef TEXFORMAT_CRD
        if (nvReadRegistryDWORD(hKey,reg.szTextureCompressionEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_TEXTURECOMPRESSIONENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE : D3D_REG_TEXTURECOMPRESSIONENABLE_DISABLE;
        }
#endif  // !TEXFORMAT_CRD

        if (nvReadRegistryDWORD(hKey,reg.szTextureManagementEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_TEXTUREMANAGEMENTENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_TEXTUREMANAGEMENTENABLE_ENABLE : D3D_REG_TEXTUREMANAGEMENTENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szTilingString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_TILINGENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_TILINGENABLE_ENABLE : D3D_REG_TILINGENABLE_DISABLE;
        }


        if (nvReadRegistryDWORD(hKey,reg.szZCullEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_ZCULLENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_ZCULLENABLE_ENABLE : D3D_REG_ZCULLENABLE_DISABLE;
        }


        if (nvReadRegistryDWORD(hKey,reg.szUserMipMapsString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_USERMIPMAPENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_USERMIPMAPENABLE_ENABLE : D3D_REG_USERMIPMAPENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szVideoTextureString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_VIDEOTEXTUREENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_VIDEOTEXTUREENABLE_ENABLE : D3D_REG_VIDEOTEXTUREENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szVS_HOS_EmulationString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_VS_HOS_EMULATION_MASK ;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_VS_HOS_EMULATION_ENABLE  : D3D_REG_VS_HOS_EMULATION_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szWEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_WBUFFERENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_WBUFFERENABLE_ENABLE : D3D_REG_WBUFFERENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szZ24EnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_Z24ENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_Z24ENABLE_ENABLE : D3D_REG_Z24ENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szZCompressEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_ZCOMPRESSENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_ZCOMPRESSENABLE_ENABLE : D3D_REG_ZCOMPRESSENABLE_DISABLE;
        }

        // Entry to enable/disable DirectX VA.  The default is enabled.
        if (nvReadRegistryDWORD(hKey, "DXVAEnable", &dwValue))
        {
            pDriverData->dwDXVAFlags = (dwValue) ? DXVA_ENABLED_IN_REGISTRY : 0;
        }

        // non-boolean enumerated types

        if (nvReadRegistryDWORD(hKey,reg.szAntiAliasQualityString,&dwValue))
        {
            if (dwValue < D3D_REG_ANTIALIASQUALITY_MIN) dwValue = D3D_REG_ANTIALIASQUALITY_MIN;
            if (dwValue > D3D_REG_ANTIALIASQUALITY_MAX) dwValue = D3D_REG_ANTIALIASQUALITY_MAX;
            getDC()->nvD3DRegistryData.regAntiAliasQuality = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szCaptureConfigString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regCaptureConfig = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szCaptureEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regCaptureEnable = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szCKRefString,&dwValue))
        {
            if (dwValue > D3D_REG_CKREF_MAX)
                dwValue = D3D_REG_DEFAULT_CKREF;
            getDC()->nvD3DRegistryData.regColorkeyRef = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szAnisotropicLevelString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regAnisotropicLevel = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szMipMapDitherEnableString,&dwValue))
        {
            if (dwValue > D3D_REG_MIPMAPDITHERMODE_MAX)
                dwValue = D3D_REG_DEFAULT_MIPMAPDITHERMODE;
            getDC()->nvD3DRegistryData.regMipMapDitherMode = dwValue;
        }

#ifdef TEXFORMAT_CRD
        if (nvReadRegistryDWORD(hKey,reg.szSurfaceFormatsDX7String,&dwValue))
        {
            getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szSurfaceFormatsDX8String,&dwValue))
        {
            getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 = dwValue;
        }
#endif  // TEXFORMAT_CRD

        if (nvReadRegistryDWORD(hKey,reg.szTexelAlignmentString,&dwValue))
        {
            if (dwValue > D3D_REG_TEXELALIGNMENT_MAX)
                dwValue = D3D_REG_DEFAULT_TEXELALIGNMENT;
            getDC()->nvD3DRegistryData.regTexelAlignment = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szTextureManageStrategyString,&dwValue))
        {
            if (dwValue > D3D_REG_TEXTUREMANAGESTRATEGY_AGGRESSIVE)
                dwValue = D3D_REG_TEXTUREMANAGESTRATEGY_AGGRESSIVE;
            getDC()->nvD3DRegistryData.regTexelAlignment = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szValidateZMethodString,&dwValue))
        {
            if (dwValue > D3D_REG_VALIDATEZMETHOD_MAX)
                dwValue = D3D_REG_DEFAULT_VALIDATEZMETHOD;
            getDC()->nvD3DRegistryData.regValidateZMethod = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szVSyncModeString,&dwValue))
        {
            if (dwValue > D3D_REG_VSYNCMODE_MAX)
                dwValue = D3D_REG_DEFAULT_VSYNCMODE;
            getDC()->nvD3DRegistryData.regVSyncMode = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szW16FormatString,&dwValue))
        {
            if (dwValue < D3D_REG_WFORMAT_MIN)
                dwValue = D3D_REG_DEFAULT_W16FORMAT;
            if (dwValue > D3D_REG_WFORMAT_MAX)
                dwValue = D3D_REG_DEFAULT_W16FORMAT;
            getDC()->nvD3DRegistryData.regW16Format = (WORD)dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szW32FormatString,&dwValue))
        {
            if (dwValue < D3D_REG_WFORMAT_MIN)
                dwValue = D3D_REG_DEFAULT_W32FORMAT;
            if (dwValue > D3D_REG_WFORMAT_MAX)
                dwValue = D3D_REG_DEFAULT_W32FORMAT;
            getDC()->nvD3DRegistryData.regW32Format = (WORD)dwValue;
        }

        // non-boolean non-enumerated types

        if (nvReadRegistryDWORD(hKey,reg.szAACompatibilityBitsString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regAACompatibilityBits = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szAAReadCompatibilityFileString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regAAReadCompatibilityFile = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szAGPTextureCutoff,&dwValue))
        {
            getDC()->nvD3DRegistryData.regAGPTexCutOff = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szCapturePlayFilenum,&dwValue))
        {
            getDC()->nvD3DRegistryData.regCapturePlayFilenum = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szCaptureRecordFilenum,&dwValue))
        {
            getDC()->nvD3DRegistryData.regCaptureRecordFilenum = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szD3DContextMaxString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DContextMax = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szD3DTextureMaxString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DTextureMax = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szDebugLevelString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regDebugLevel = dwValue;
            #ifdef DEBUG
            dbgLevel = dwValue;
            #endif
        }

        if (nvReadRegistryDWORD(hKey,reg.szLodBiasAdjustString,&dwValue))
        {
            //if (dwValue & 0xFFFFFF00)
            //    dwValue = D3D_REG_DEFAULT_LODBIASADJUST;
            //this need to be a float value -- don't do that comparison
            getDC()->nvD3DRegistryData.regLODBiasAdjust = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szMinVideoTexSizeString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regMinVideoTextureSize = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szPCITexHeapSizeString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regPCITexHeapSize = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szPreRenderLimitString,&dwValue))
        {
            if (dwValue > D3D_REG_PRERENDERLIMIT_MAX)
                dwValue = D3D_REG_PRERENDERLIMIT_MAX;
            if (dwValue < D3D_REG_PRERENDERLIMIT_MIN)
                dwValue = D3D_REG_PRERENDERLIMIT_MIN;
            getDC()->nvD3DRegistryData.regPreRenderLimit = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szPushBufferSizeMaxString,&dwValue))
        {
            if (dwValue)
            {
                getDC()->nvD3DRegistryData.regPushBufferSizeMax = dwValue;
            }
            else
            {
                getDC()->nvD3DRegistryData.regPushBufferSizeMax = D3D_REG_DEFAULT_PUSHBUFFERSIZEMAX;
            }
        }

        if (nvReadRegistryDWORD(hKey,reg.szWScale16String,&dwValue))
        {
            if (dwValue > D3D_REG_WSCALE16_MAX)
                dwValue = D3D_REG_DEFAULT_WSCALE16;
            getDC()->nvD3DRegistryData.regfWScale16 = (float)dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szWScale24String,&dwValue))
        {
            if (dwValue > D3D_REG_WSCALE24_MAX)
                dwValue = D3D_REG_DEFAULT_WSCALE24;
            getDC()->nvD3DRegistryData.regfWScale24 = (float)dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szZBiasString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regfZBias = (float)dwValue;
        }

        // strings
        if (nvReadRegistryString(hKey,reg.szCapturePlayFilenameString,(LPBYTE)szString))
        {
            nvStrNCpy (getDC()->nvD3DRegistryData.regszCapturePlayFilename, szString, D3D_REG_STRING_LENGTH);
        }

        if (nvReadRegistryString(hKey,reg.szCapturePlayPathString,(LPBYTE)szString))
        {
            nvStrNCpy (getDC()->nvD3DRegistryData.regszCapturePlayPath, szString, D3D_REG_STRING_LENGTH);
        }

        if (nvReadRegistryString(hKey,reg.szCaptureRecordPathString,(LPBYTE)szString))
        {
            nvStrNCpy (getDC()->nvD3DRegistryData.regszCaptureRecordPath, szString, D3D_REG_STRING_LENGTH);
        }

        if (nvReadRegistryString(hKey,reg.szCaptureRecordFilenameString,(LPBYTE)szString))
        {
            nvStrNCpy (getDC()->nvD3DRegistryData.regszCaptureRecordFilename, szString, D3D_REG_STRING_LENGTH);
        }

#ifndef WINNT
        RegCloseKey(hKey);
#endif
    }

#ifdef  STEREO_SUPPORT
    LoadStereoRegistry();
#endif  //STEREO_SUPPORT

    dbgTracePop();
    return;
}

#pragma warning(default: 4296)

//---------------------------------------------------------------------------

/*
 * Read the current driver settings from the registry.
 */

void D3DModifyCapabilities
(
    D3DHAL_GLOBALDRIVERDATA  *pNvGlobal,
    GLOBALDATA               *pDriverData
)
{
    // Set the Fog Table Caps bit based on the registry setting.
    pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps &= ~D3DPRASTERCAPS_FOGTABLE;
    pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  &= ~D3DPRASTERCAPS_FOGTABLE;
    if (getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_FOGTABLEENABLE_ENABLE) {
        pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps |= D3DPRASTERCAPS_FOGTABLE;
        pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  |= D3DPRASTERCAPS_FOGTABLE;
    }

    // Set anti-aliasing capabilities based on the registry setting.
    pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps &= ~(D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT | D3DPRASTERCAPS_ANTIALIASEDGES);
    pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  &= ~(D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT | D3DPRASTERCAPS_ANTIALIASEDGES);

    if (getDC()->nvD3DPerfData.dwHaveAALines) {
        pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps |= D3DPRASTERCAPS_ANTIALIASEDGES;
        pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  |= D3DPRASTERCAPS_ANTIALIASEDGES;
        getDC()->nvD3DDevCaps.dwD3DCap8.RasterCaps |= D3DPRASTERCAPS_ANTIALIASEDGES;
    }

    if (((getDC()->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) ||
        (getDC()->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)) &&
        (getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASENABLE_ENABLE)) {
        /* for now we only support scene aa
        pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps |= (D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT | D3DPRASTERCAPS_ANTIALIASEDGES);
        pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  |= (D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT | D3DPRASTERCAPS_ANTIALIASEDGES);
        */
        pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps |= (D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT);
        pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  |= (D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT);
    }

    // Set w-buffer capabilities based on the registry setting.
    pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps &= ~D3DPRASTERCAPS_WBUFFER;
    pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  &= ~D3DPRASTERCAPS_WBUFFER;
    if (getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_WBUFFERENABLE_ENABLE) {
        pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps |= D3DPRASTERCAPS_WBUFFER;
        pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  |= D3DPRASTERCAPS_WBUFFER;
    }

#ifndef TEXFORMAT_CRD
    // Remove 8 bit texture formats if the registry says so, and if we have palette support
    if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN)) {
        if ((global.dwDXRuntimeVersion < 0x0800) ||
            ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_PALETTEENABLE_MASK) == D3D_REG_PALETTEENABLE_DISABLE)) {
            pNvGlobal->dwNumTextureFormats -= NV_NUM_8BIT_TEXTURE_FORMATS;
        }
    }
#endif  // !TEXFORMATS_CRD

    // Export only 16bit z-buffer formats when the registry says so.
    if (!(getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_Z24ENABLE_ENABLE)) {
        pNvGlobal->hwCaps.dwDeviceZBufferBitDepth &= ~(DDBD_24 | DDBD_32);
    }

    // enable the direct-mapped TSS extension
    if (getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_DIRECTMAPENABLE_ENABLE) {
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxTextureBlendStages = 8;
    }

    // enable emulation of Higher order surface and vertex shaders on celsius class devices.
    if ((pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN)) == (NVCLASS_FAMILY_CELSIUS)) {
        if(getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_VS_HOS_EMULATION_ENABLE){
            getDC()->nvD3DDevCaps.dwD3DCap8.DevCaps |= (D3DDEVCAPS_QUINTICRTPATCHES | D3DDEVCAPS_RTPATCHES);
            getDC()->nvD3DDevCaps.dwD3DCap8.VertexShaderVersion = D3DVS_VERSION(1,1);
        }
    }

    return;
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvLine.cpp ===
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvLine.cpp                                                        *
*   The Direct3D line rendering routines.                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       04/12/97 - created                      *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

static WORD awWireframeIndices[6*3] =
{
    0,  1,  2,
    1,  2,  3,
    4,  5,  6,
    5,  6,  7,
    8,  9, 10,
    9, 10, 11
};

// true if line is more vertical than horizontal
#define Y_MAJOR(a,b)     (fabs(LineVerts[a].sx - LineVerts[b].sx) < fabs(LineVerts[a].sy - LineVerts[b].sy))
#define Y_MAJOR_FVF(a,b) (fabs (((LPD3DTLVERTEX)(pLineVert[a]))->sx - ((LPD3DTLVERTEX)(pLineVert[b]))->sx)  <   \
                          fabs (((LPD3DTLVERTEX)(pLineVert[a]))->sy - ((LPD3DTLVERTEX)(pLineVert[b]))->sy))

//---------------------------------------------------------------------------

/*
 * Non-Indexed TLVertex Format Line Lists.
 */
void nvDrawLine
(
    NV_INNERLOOP_ARGLIST
)
{
    DWORD           dwControl;
    DWORD           dwOldCull;
    D3DTLVERTEX     LineVerts[4];

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&LineVerts[0]), 4*sizeof(D3DTLVERTEX), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLESTRIP;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 4*sizeof(D3DTLVERTEX);

    if (dwCount)
    {
        LPD3DTLVERTEX pVertices   = (LPD3DTLVERTEX)(pVertexBufferBase + dwVertexBufferOffset);
        DWORD         dwVertexInc = ((dwCachedDP2Op == D3DDP2OP_INDEXEDLINESTRIP) || (dwCachedDP2Op == D3DDP2OP_LINESTRIP)) ? 1 : 2;

        // Calculate the new hardware state if neccessary.
        if (pContext->bStateChange) {
            if (pContext->bUseDX6Class) {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class) {
                    nvSetHardwareState (pContext);
                }
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable culling.
        dwControl = pContext->ctxInnerLoop.dwControl;
        pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Force first call to be to the triangle state setup routine.
        NV_FORCE_TRI_SETUP(pContext);

        // Draw the lines.
        while (dwCount--)
        {
            // Each line is rendered as a one pixel wide rectangle.
            LineVerts[0] = pVertices[0];
            LineVerts[2] = pVertices[0];
            LineVerts[1] = pVertices[1];
            LineVerts[3] = pVertices[1];
            pVertices += dwVertexInc;

            if (Y_MAJOR(0,1))
            {
                LineVerts[0].sx -= HALF_LINE_WIDTH;
                LineVerts[1].sx -= HALF_LINE_WIDTH;
                LineVerts[2].sx += HALF_LINE_WIDTH;
                LineVerts[3].sx += HALF_LINE_WIDTH;
            }
            else
            {
                LineVerts[0].sy -= HALF_LINE_WIDTH;
                LineVerts[1].sy -= HALF_LINE_WIDTH;
                LineVerts[2].sy += HALF_LINE_WIDTH;
                LineVerts[3].sy += HALF_LINE_WIDTH;
            }

            // Call the low level rendering routine to draw the "line".
            nvTriangleDispatch (pContext, 2);
        }

        // Restore the culling mode.
        pContext->ctxInnerLoop.dwControl = dwControl;
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force next render call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);
    return;
}

//-------------------------------------------------------------------------

/*
 * Indexed TLVertex Format Line Lists.
 */
void nvIndexedLine
(
    NV_INNERLOOP_ARGLIST
)
{
    DWORD           dwControl;
    DWORD           dwOldCull;
    D3DTLVERTEX     LineVerts[4];

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&LineVerts[0]), 4*sizeof(D3DTLVERTEX), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLESTRIP;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 4*sizeof(D3DTLVERTEX);

    if (dwCount)
    {
        LPD3DTLVERTEX pVertices  = (LPD3DTLVERTEX)(pVertexBufferBase + dwVertexBufferOffset);
        LPWORD        pIndices   = (LPWORD)(pContext->dp2.dwIndices);
        DWORD         dwIndexInc = (dwCachedDP2Op == D3DDP2OP_INDEXEDLINESTRIP) ? 1 : 2;

        pContext->dp2.dwIndices = NULL;

        // Calculate the new hardware state if neccessary.
        if (pContext->bStateChange) {
            if (pContext->bUseDX6Class) {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class)
                    nvSetHardwareState (pContext);
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable culling.
        dwControl = pContext->ctxInnerLoop.dwControl;
        pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Force first call to be to the triangle state setup routine.
        NV_FORCE_TRI_SETUP(pContext);

        // Draw the lines.
        while (dwCount--)
        {
            // Each line is rendered as a one pixel wide rectangle.

#ifdef WINNT
            // we're responsible for validating data under NT. ugh.
            DWORD dwLocalOffset;
            LPD3DTLVERTEX pVert;
            dwLocalOffset = pIndices[0] * sizeof(D3DTLVERTEX);

            if ((dwVertexBufferOffset + dwLocalOffset) < dwCachedMaxOffset) {
                pVert   =(LPD3DTLVERTEX) ((DWORD)pVertices + dwLocalOffset);
                LineVerts[0] = *pVert;
                LineVerts[2] = *pVert;
            }
            else {
                DPF ("vertex data is out of range in nvIndexedLine");
                dbgD3DError();
                LineVerts[0] = pVertices[0];
                LineVerts[2] = pVertices[0];
            }
            dwLocalOffset = pIndices[1] * sizeof(D3DTLVERTEX);
            if ((dwVertexBufferOffset + dwLocalOffset) < dwCachedMaxOffset) {
                pVert   =(LPD3DTLVERTEX) ((DWORD)pVertices + dwLocalOffset);
                LineVerts[1] = *pVert;
                LineVerts[3] = *pVert;
            }
            else {
                DPF ("vertex data is out of range in nvIndexedLine");
                dbgD3DError();
                LineVerts[1] = pVertices[0];
                LineVerts[3] = pVertices[0];
            }
#else  // !WINNT

            LineVerts[0] = pVertices[pIndices[0]];
            LineVerts[2] = pVertices[pIndices[0]];
            LineVerts[1] = pVertices[pIndices[1]];
            LineVerts[3] = pVertices[pIndices[1]];
#endif  // !WINNT

            pIndices += dwIndexInc;

            if (Y_MAJOR(0,1))
            {
                LineVerts[0].sx -= HALF_LINE_WIDTH;
                LineVerts[1].sx -= HALF_LINE_WIDTH;
                LineVerts[2].sx += HALF_LINE_WIDTH;
                LineVerts[3].sx += HALF_LINE_WIDTH;
            }
            else
            {
                LineVerts[0].sy -= HALF_LINE_WIDTH;
                LineVerts[1].sy -= HALF_LINE_WIDTH;
                LineVerts[2].sy += HALF_LINE_WIDTH;
                LineVerts[3].sy += HALF_LINE_WIDTH;
            }

            // Call the low level rendering routine to draw the "line".
            nvTriangleDispatch (pContext, 2);
        }

        // Restore the culling mode.
        pContext->ctxInnerLoop.dwControl = dwControl;
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force first call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);

    return;
}

//-------------------------------------------------------------------------

DWORD nvRenderLine
(
    NV_INNERLOOP_ARGLIST
)
{
    nvIndexedLine (NV_INNERLOOP_ARGS);
    return (DD_OK);
}

//-------------------------------------------------------------------------

void nvDrawWireframeTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    D3DTLVERTEX LineVerts[12];
    DWORD       v0,v1,v2;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    DWORD       dwEdgeFlags, dwEdgeMask;
    float       dwCullValue;

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&LineVerts[0]), 12*sizeof(D3DTLVERTEX), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_INDEXEDTRIANGLELIST2;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 12*sizeof(D3DTLVERTEX);

    dwEdgeFlags = pContext->dp2.dwEdgeFlags;
    dwEdgeMask  = 0x1;

    if (dwCount) {

        LPD3DTLVERTEX pVertices = (LPD3DTLVERTEX)(pVertexBufferBase + dwVertexBufferOffset);
        DWORD         dwStrides = nv4DP2OpToStride[dwCachedDP2Op];

        // Calculate the new hardware state if neccessary.
        if (pContext->bStateChange) {
            if (pContext->bUseDX6Class) {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class) {
                    nvSetHardwareState (pContext);
                }
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable lower level culling while drawing lines.
        dwControl = pContext->ctxInnerLoop.dwControl;
        pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Calculate the culling masks.
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        // Force first call to be to the triangle state setup routine.
        NV_FORCE_TRI_SETUP(pContext);

        dwStrides     &= 0xffffff; // mask interesting bits
        dwIndex1       = 0;
        dwIndex2       = 1;
        dwIndexStrides = dwStrides;

        // Draw all triangles as a wireframe.
        nvAssert (dwCount <= 0xffff);
        WORD  wPrim = dwCount;  // save the number of primitives
        WORD  wTri, wTriangleNum;
        WORD  awMaskedIndices[6*3];

        while (dwCount--)
        {
            wTriangleNum = wPrim-dwCount; // (1...nPrim)

            v0 = dwIndex1;
            v1 = dwIndex2 + (dwIndexStrides >> 24);
            v2 = dwIndex2 + ((dwIndexStrides >> 24) ^ 1);

            // Move on to the next triangle.
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwStrides << 8) & 0xff000000;

            // Since culling needs to be disabled to insure that the triangle edges get drawn properly,
            // back face culling of the triangle needs to be performed up front by software.
            IF_NOT_CULLED_BEGIN ((BYTE *)&pVertices[v0], (BYTE *)&pVertices[v1], (BYTE *)&pVertices[v2], dwCullValue)

                // render each edge as a "line" (thin rectangle)
                LineVerts[ 0] = pVertices[v0];
                LineVerts[ 2] = pVertices[v0];
                LineVerts[ 9] = pVertices[v0];
                LineVerts[11] = pVertices[v0];

                LineVerts[ 1] = pVertices[v1];
                LineVerts[ 3] = pVertices[v1];
                LineVerts[ 4] = pVertices[v1];
                LineVerts[ 6] = pVertices[v1];

                LineVerts[ 5] = pVertices[v2];
                LineVerts[ 7] = pVertices[v2];
                LineVerts[ 8] = pVertices[v2];
                LineVerts[10] = pVertices[v2];

                // fd. a bit uggly here, but I don't know the correct answer,
                // that makes WHQL happy.

                if ((dwCachedDP2Op!=D3DDP2OP_TRIANGLESTRIP)
                    && (pContext->dwRenderState[D3DRS_SHADEMODE]==D3DSHADE_FLAT))
                {
                    DWORD color=pVertices[v0].color;

                    LineVerts[ 1].color = color;
                    LineVerts[ 3].color = color;
                    LineVerts[ 4].color = color;
                    LineVerts[ 6].color = color;

                    LineVerts[ 5].color = color;
                    LineVerts[ 7].color = color;
                    LineVerts[ 8].color = color;
                    LineVerts[10].color = color;
                }

                if (Y_MAJOR(0,1))
                {
                    LineVerts[ 0].sx -= HALF_LINE_WIDTH;
                    LineVerts[ 1].sx -= HALF_LINE_WIDTH;
                    LineVerts[ 2].sx += HALF_LINE_WIDTH;
                    LineVerts[ 3].sx += HALF_LINE_WIDTH;
                }
                else
                {
                    LineVerts[ 0].sy -= HALF_LINE_WIDTH;
                    LineVerts[ 1].sy -= HALF_LINE_WIDTH;
                    LineVerts[ 2].sy += HALF_LINE_WIDTH;
                    LineVerts[ 3].sy += HALF_LINE_WIDTH;
                }

                if (Y_MAJOR(4,5))
                {
                    LineVerts[ 4].sx -= HALF_LINE_WIDTH;
                    LineVerts[ 5].sx -= HALF_LINE_WIDTH;
                    LineVerts[ 6].sx += HALF_LINE_WIDTH;
                    LineVerts[ 7].sx += HALF_LINE_WIDTH;
                }
                else
                {
                    LineVerts[ 4].sy -= HALF_LINE_WIDTH;
                    LineVerts[ 5].sy -= HALF_LINE_WIDTH;
                    LineVerts[ 6].sy += HALF_LINE_WIDTH;
                    LineVerts[ 7].sy += HALF_LINE_WIDTH;
                }

                if (Y_MAJOR(8,9))
                {
                    LineVerts[ 8].sx -= HALF_LINE_WIDTH;
                    LineVerts[ 9].sx -= HALF_LINE_WIDTH;
                    LineVerts[10].sx += HALF_LINE_WIDTH;
                    LineVerts[11].sx += HALF_LINE_WIDTH;
                }
                else
                {
                    LineVerts[ 8].sy -= HALF_LINE_WIDTH;
                    LineVerts[ 9].sy -= HALF_LINE_WIDTH;
                    LineVerts[10].sy += HALF_LINE_WIDTH;
                    LineVerts[11].sy += HALF_LINE_WIDTH;
                }

                // if D3DDP2OP_TRIANGLEFAN_IMM, decide which edges are drawn and which are not
                // by inference from the reference rasterizer, the rules appear to be:
                // - interior spokes are NEVER drawn
                // - bit0 controls edge 0->1   where 0 is center vertex
                // - bitN controls edge N->N+1 where N = 1...triangle_count
                // - bitX controls edge X->0   where X = triangle_count+1

                if (dwCachedDP2Op == D3DDP2OP_TRIANGLEFAN_IMM)
                {
                    wTri = 0;

                    // v0-v1
                    // we never draw this edge for anything but the first triangle
                    if (wTriangleNum == 1) {
                        if (dwEdgeFlags & dwEdgeMask) {
                            awMaskedIndices[wTri*3+0] = awWireframeIndices[0*3+0];
                            awMaskedIndices[wTri*3+1] = awWireframeIndices[0*3+1];
                            awMaskedIndices[wTri*3+2] = awWireframeIndices[0*3+2];
                            wTri++;
                            awMaskedIndices[wTri*3+0] = awWireframeIndices[1*3+0];
                            awMaskedIndices[wTri*3+1] = awWireframeIndices[1*3+1];
                            awMaskedIndices[wTri*3+2] = awWireframeIndices[1*3+2];
                            wTri++;
                        }
                        dwEdgeMask <<= 1;
                    }

                    // v1-v2
                    if (dwEdgeFlags & dwEdgeMask) {
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[2*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[2*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[2*3+2];
                        wTri++;
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[3*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[3*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[3*3+2];
                        wTri++;
                    }
                    dwEdgeMask <<= 1;

                    // v2-v0
                    // we never draw this edge for anything but the last triangle
                    if (wTriangleNum == wPrim) {
                        if (dwEdgeFlags & dwEdgeMask) {
                            awMaskedIndices[wTri*3+0] = awWireframeIndices[4*3+0];
                            awMaskedIndices[wTri*3+1] = awWireframeIndices[4*3+1];
                            awMaskedIndices[wTri*3+2] = awWireframeIndices[4*3+2];
                            wTri++;
                            awMaskedIndices[wTri*3+0] = awWireframeIndices[5*3+0];
                            awMaskedIndices[wTri*3+1] = awWireframeIndices[5*3+1];
                            awMaskedIndices[wTri*3+2] = awWireframeIndices[5*3+2];
                            wTri++;
                        }
                        dwEdgeMask <<= 1;
                    }

                    pContext->dp2.dwIndices = (DWORD)(awMaskedIndices);

                    // Draw the specified triangle edges.
                    nvTriangleDispatch (pContext, wTri);

                }

                else
                {
                    pContext->dp2.dwIndices = (DWORD)(awWireframeIndices);

                    // Draw all triangle edges
                    nvTriangleDispatch (pContext, 6);
                }

            IF_NOT_CULLED_END

        }

        // Restore the culling mode.
        pContext->ctxInnerLoop.dwControl = dwControl;
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force first call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);
    return;
}

//-------------------------------------------------------------------------

void nvIndexedWireframeTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    D3DTLVERTEX LineVerts[12];
    DWORD       v0,v1,v2;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&LineVerts[0]), 12*sizeof(D3DTLVERTEX), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_INDEXEDTRIANGLELIST2;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 12*sizeof(D3DTLVERTEX);

    if (dwCount)
    {
        LPD3DTLVERTEX pVertices = (LPD3DTLVERTEX)(pVertexBufferBase + dwVertexBufferOffset);
        LPWORD        pIndices  = (LPWORD)(pContext->dp2.dwIndices);
        DWORD         dwStrides = nv4DP2OpToStride[dwCachedDP2Op];

        // Calculate the new hardware state if neccessary.
        if (pContext->bStateChange) {
            if (pContext->bUseDX6Class) {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class) {
                    nvSetHardwareState (pContext);
                }
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable lower level culling while drawing lines.
        dwControl = pContext->ctxInnerLoop.dwControl;
        pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Calculate the culling masks.
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        // Force first call to be to the triangle state setup routine.
        NV_FORCE_TRI_SETUP(pContext);

        dwStrides     &= 0xffffff; // mask interesting bits
        dwIndex1       = (DWORD)pIndices;
        dwIndex2       = (DWORD)pIndices + 2;
        dwIndexStrides = dwStrides * 2;

        // Draw all triangles as a wireframe.
        while (dwCount--)
        {
            v0 = *(WORD*) dwIndex1;
            v1 = *(WORD*)(dwIndex2 +  (dwIndexStrides >> 24));
            v2 = *(WORD*)(dwIndex2 + ((dwIndexStrides >> 24) ^ 2));

            // Move on to the next triangle.
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            // Since culling needs to be disabled to insure that the triangle edges get drawn properly,
            // back face culling of the triangle needs to be performed up front by software.
            IF_NOT_CULLED_BEGIN ((BYTE *)&pVertices[v0], (BYTE *)&pVertices[v1], (BYTE *)&pVertices[v2], dwCullValue)

                // render each edge as a "line" (thin rectangle)
                LineVerts[ 0] = pVertices[v0];
                LineVerts[ 2] = pVertices[v0];
                LineVerts[ 9] = pVertices[v0];
                LineVerts[11] = pVertices[v0];

                LineVerts[ 1] = pVertices[v1];
                LineVerts[ 3] = pVertices[v1];
                LineVerts[ 4] = pVertices[v1];
                LineVerts[ 6] = pVertices[v1];

                LineVerts[ 5] = pVertices[v2];
                LineVerts[ 7] = pVertices[v2];
                LineVerts[ 8] = pVertices[v2];
                LineVerts[10] = pVertices[v2];

                if (pContext->dwRenderState[D3DRS_SHADEMODE]==D3DSHADE_FLAT)
                {
                    DWORD color=pVertices[v0].color;
                    LineVerts[ 1].color = color;
                    LineVerts[ 3].color = color;
                    LineVerts[ 4].color = color;
                    LineVerts[ 6].color = color;

                    LineVerts[ 5].color = color;
                    LineVerts[ 7].color = color;
                    LineVerts[ 8].color = color;
                    LineVerts[10].color = color;
                }

                if (Y_MAJOR(0,1))
                {
                    LineVerts[ 0].sx -= HALF_LINE_WIDTH;
                    LineVerts[ 1].sx -= HALF_LINE_WIDTH;
                    LineVerts[ 2].sx += HALF_LINE_WIDTH;
                    LineVerts[ 3].sx += HALF_LINE_WIDTH;
                }
                else
                {
                    LineVerts[ 0].sy -= HALF_LINE_WIDTH;
                    LineVerts[ 1].sy -= HALF_LINE_WIDTH;
                    LineVerts[ 2].sy += HALF_LINE_WIDTH;
                    LineVerts[ 3].sy += HALF_LINE_WIDTH;
                }

                if (Y_MAJOR(4,5))
                {
                    LineVerts[ 4].sx -= HALF_LINE_WIDTH;
                    LineVerts[ 5].sx -= HALF_LINE_WIDTH;
                    LineVerts[ 6].sx += HALF_LINE_WIDTH;
                    LineVerts[ 7].sx += HALF_LINE_WIDTH;
                }
                else
                {
                    LineVerts[ 4].sy -= HALF_LINE_WIDTH;
                    LineVerts[ 5].sy -= HALF_LINE_WIDTH;
                    LineVerts[ 6].sy += HALF_LINE_WIDTH;
                    LineVerts[ 7].sy += HALF_LINE_WIDTH;
                }

                if (Y_MAJOR(8,9))
                {
                    LineVerts[ 8].sx -= HALF_LINE_WIDTH;
                    LineVerts[ 9].sx -= HALF_LINE_WIDTH;
                    LineVerts[10].sx += HALF_LINE_WIDTH;
                    LineVerts[11].sx += HALF_LINE_WIDTH;
                }
                else
                {
                    LineVerts[ 8].sy -= HALF_LINE_WIDTH;
                    LineVerts[ 9].sy -= HALF_LINE_WIDTH;
                    LineVerts[10].sy += HALF_LINE_WIDTH;
                    LineVerts[11].sy += HALF_LINE_WIDTH;
                }

                // If this was called with RenderPrim, dwStrides will be LEGACY_STRIDES, otherwise it won't.
                if ((dwStrides != (LEGACY_STRIDES & 0xffffff)) ||
                    (( ((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLETRIANGLE) == D3DTRIFLAG_EDGEENABLETRIANGLE))
                {
                    pContext->dp2.dwIndices = (DWORD)(awWireframeIndices);
                    // Draw the triangle edges.
                    nvTriangleDispatch (pContext, 6);
                }

                else
                {
                    WORD wTri;
                    WORD awMaskedIndices[6*3];

                    wTri = 0;
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE1)
                    {
                        awMaskedIndices[0*3+0] = awWireframeIndices[0*3+0];
                        awMaskedIndices[0*3+1] = awWireframeIndices[0*3+1];
                        awMaskedIndices[0*3+2] = awWireframeIndices[0*3+2];
                        wTri++;
                        awMaskedIndices[1*3+0] = awWireframeIndices[1*3+0];
                        awMaskedIndices[1*3+1] = awWireframeIndices[1*3+1];
                        awMaskedIndices[1*3+2] = awWireframeIndices[1*3+2];
                        wTri++;
                    }
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE2)
                    {
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[2*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[2*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[2*3+2];
                        wTri++;
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[3*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[3*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[3*3+2];
                        wTri++;
                    }
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE3)
                    {
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[4*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[4*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[4*3+2];
                        wTri++;
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[5*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[5*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[5*3+2];
                        wTri++;
                    }

                    if (wTri)
                    {
                        pContext->dp2.dwIndices = (DWORD)(awMaskedIndices);
                        // Draw the specified triangle edges.
                        nvTriangleDispatch (pContext, wTri);
                    }
                }

            IF_NOT_CULLED_END

        }

        // Restore the culling mode.
        pContext->ctxInnerLoop.dwControl = dwControl;
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force first call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);
    return;
}

//-------------------------------------------------------------------------

/*
 * Non-Indexed Flexible Vertex Format Lines.
 */
void nvFVFDrawLine
(
    NV_INNERLOOP_ARGLIST
)
{
    BYTE   LineVerts[4 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    BYTE  *pLineVert[4];
    BYTE  *pVert0, *pVert1;
    DWORD  i, dwDwordsPerVert;
    DWORD  dwControl;
    DWORD  dwOldCull;
    DWORD  dwVertexStride;
    DWORD  dwNextLine;

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&LineVerts[0]), 4*((sizeof(D3DTLVERTEX))+(7*2*4)), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLESTRIP;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 4 * ((sizeof(D3DTLVERTEX)) + (7*2*4));

    if (dwCount)
    {
        LPBYTE pVertices   = pVertexBufferBase + dwVertexBufferOffset;
        DWORD  dwVertexInc = ((dwCachedDP2Op == D3DDP2OP_INDEXEDLINESTRIP) || (dwCachedDP2Op == D3DDP2OP_LINESTRIP)) ? 1 : 2;

        // Calculate the new hardware state if neccessary.
        if (pContext->bStateChange) {
            if (pContext->bUseDX6Class) {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class) {
                    nvSetHardwareState (pContext);
                }
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable culling.
        if (!pContext->bUseDX6Class)
        {
            dwControl = pContext->ctxInnerLoop.dwControl;
            pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else
        {
            dwControl = pContext->mtsState.dwControl0;
            pContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Force first call to be to the triangle state setup routine.
        NV_FORCE_TRI_SETUP(pContext);

        // Calculate number of vertex bytes to increment after each line.
        dwVertexStride  = pContext->pCurrentVShader->getStride();
        dwNextLine      = dwVertexInc * dwVertexStride;
        dwDwordsPerVert = pContext->pCurrentVShader->getStride() >> 2;

        // Get pointers to each of the 4 FVF line vertices.
        GET_FVF_POINTER (pLineVert[0], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 0, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[1], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 1, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[2], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 2, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[3], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 3, pContext->pCurrentVShader->getStride());

        // Draw the lines.
        while (dwCount--)
        {
            // Each line is rendered as a one pixel wide rectangle.
            // Since we're contstructing new TLVERTEX structures anyway,
            // Construct full TLVERTEX structures up front from the FVF data
            // structures and then just call the TLVERTEX rendering loop.

            // Get pointers to each vertex of current line.
            GET_FVF_POINTER (pVert0, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 0, pContext->pCurrentVShader->getStride());
            GET_FVF_POINTER (pVert1, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 1, pContext->pCurrentVShader->getStride());
            pVertices += dwNextLine;

            // copy vertex data
            for (i = 0; i < dwDwordsPerVert; i++)
            {
                DWORD   dwValue;
                dwValue = ((DWORD *)pVert0)[i];
                ((DWORD *)(pLineVert[0]))[i] = dwValue;
                ((DWORD *)(pLineVert[2]))[i] = dwValue;

                dwValue = ((DWORD *)pVert1)[i];
                ((DWORD *)(pLineVert[1]))[i] = dwValue;
                ((DWORD *)(pLineVert[3]))[i] = dwValue;
            }

            if (Y_MAJOR_FVF(0,1))
            {
                ((LPD3DTLVERTEX)(pLineVert[0]))->sx -= HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[1]))->sx -= HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[2]))->sx += HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[3]))->sx += HALF_LINE_WIDTH;
            }
            else
            {
                ((LPD3DTLVERTEX)(pLineVert[0]))->sy -= HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[1]))->sy -= HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[2]))->sy += HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[3]))->sy += HALF_LINE_WIDTH;
            }

            // Call the low level rendering routine to draw the "line".
            nvTriangleDispatch (pContext, 2);
        }  // while (dwCount)

        // Restore the culling mode.
        if (!pContext->bUseDX6Class)
            pContext->ctxInnerLoop.dwControl = dwControl;
        else
            pContext->mtsState.dwControl0 = dwControl;

        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force next render call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);
    return;
}

//-------------------------------------------------------------------------

/*
 * Indexed Flexible Vertex Format Lines.
 */
void nvFVFIndexedLine
(
    NV_INNERLOOP_ARGLIST
)
{
    BYTE   LineVerts[4 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    BYTE  *pLineVert[4];
    BYTE  *pVert0, *pVert1;
    DWORD  i, dwDwordsPerVert;
    DWORD  dwControl;
    DWORD  dwOldCull;

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&LineVerts[0]), 4*((sizeof(D3DTLVERTEX))+(7*2*4)), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLESTRIP;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 4 * ((sizeof(D3DTLVERTEX)) + (7*2*4));

    if (dwCount)
    {
        LPBYTE pVertices  = pVertexBufferBase + dwVertexBufferOffset;
        LPWORD pIndices   = (LPWORD)(pContext->dp2.dwIndices);
        DWORD  dwIndexInc = (dwCachedDP2Op == D3DDP2OP_INDEXEDLINESTRIP) ? 1 : 2;

        pContext->dp2.dwIndices = NULL;

        // Calculate the new hardware state if neccessary.
        if (pContext->bStateChange) {
            if (pContext->bUseDX6Class) {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class) {
                    nvSetHardwareState (pContext);
                }
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable culling.
        if (!pContext->bUseDX6Class)
        {
            dwControl = pContext->ctxInnerLoop.dwControl;
            pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else
        {
            dwControl = pContext->mtsState.dwControl0;
            pContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Force first call to be to the triangle state setup routine.
        NV_FORCE_TRI_SETUP(pContext);

        dwDwordsPerVert = pContext->pCurrentVShader->getStride() >> 2;

        // Get pointers to each of the 4 vertices of the rectangle that
        // will approximate the line
        GET_FVF_POINTER (pLineVert[ 0], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 0, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 1], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 1, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 2], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 2, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 3], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 3, pContext->pCurrentVShader->getStride());

        // Draw the lines.
        while (dwCount--)
        {
            // Each line is rendered as a one pixel wide rectangle.
            // Since we're contstructing new TLVERTEX structures anyway,
            // Construct full TLVERTEX structures up front from the FVF data
            // structures and then just call the TLVERTEX rendering loop.

            // Get pointers to each vertex of current line.
            GET_FVF_POINTER (pVert0, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), pIndices[0], pContext->pCurrentVShader->getStride());
            GET_FVF_POINTER (pVert1, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), pIndices[1], pContext->pCurrentVShader->getStride());

            pIndices += dwIndexInc;

            // Copy vertex data
            for (i = 0; i < dwDwordsPerVert; i++)
            {
                DWORD dwValue;
                dwValue = ((DWORD *)pVert0)[i];
                ((DWORD *)(pLineVert[0]))[i] = dwValue;
                ((DWORD *)(pLineVert[2]))[i] = dwValue;

                dwValue = ((DWORD *)pVert1)[i];
                ((DWORD *)(pLineVert[1]))[i] = dwValue;
                ((DWORD *)(pLineVert[3]))[i] = dwValue;
            }

            if (Y_MAJOR_FVF(0,1))
            {
                ((LPD3DTLVERTEX)(pLineVert[0]))->sx -= HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[1]))->sx -= HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[2]))->sx += HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[3]))->sx += HALF_LINE_WIDTH;
            }
            else
            {
                ((LPD3DTLVERTEX)(pLineVert[0]))->sy -= HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[1]))->sy -= HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[2]))->sy += HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[3]))->sy += HALF_LINE_WIDTH;
            }

            // Call the low level rendering routine to draw the "line".
            nvTriangleDispatch (pContext, 2);
        }  // while (dwCount)

        // Restore the culling mode.
        if (!pContext->bUseDX6Class)
            pContext->ctxInnerLoop.dwControl = dwControl;
        else
            pContext->mtsState.dwControl0 = dwControl;

        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force next render call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);
    return;
}

//-------------------------------------------------------------------------

void nvFVFDrawWireframeTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    BYTE        LineVerts[12 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    BYTE       *pLineVert[12];
    BYTE       *pVert0, *pVert1, *pVert2;
    DWORD       i, dwDwordsPerVert;
    DWORD       v0,v1,v2;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    DWORD       dwEdgeFlags, dwEdgeMask;
    float       dwCullValue;

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&LineVerts[0]), 12*((sizeof(D3DTLVERTEX))+(7*2*4)), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_INDEXEDTRIANGLELIST2;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 12 * ((sizeof(D3DTLVERTEX)) + (7*2*4));

    dwEdgeFlags = pContext->dp2.dwEdgeFlags;
    dwEdgeMask  = 0x1;

    if (dwCount) {

        LPBYTE pVertices = pVertexBufferBase + dwVertexBufferOffset;
        DWORD  dwStrides = nv4DP2OpToStride[dwCachedDP2Op];

        // Calculate the new hardware state if neccessary.
        if (pContext->bStateChange) {
            if (pContext->bUseDX6Class) {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class) {
                    nvSetHardwareState (pContext);
                }
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable lower level culling while drawing lines.
        if (!pContext->bUseDX6Class)
        {
            dwControl = pContext->ctxInnerLoop.dwControl;
            pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else
        {
            dwControl = pContext->mtsState.dwControl0;
            pContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Calculate the culling masks.
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        // Force first call to be to the triangle state setup routine.
        NV_FORCE_TRI_SETUP(pContext);

        dwStrides      &= 0xffffff; // mask interesting bits
        dwIndex1        = 0;
        dwIndex2        = 1;
        dwIndexStrides  = dwStrides;
        dwDwordsPerVert = pContext->pCurrentVShader->getStride() >> 2;

        // Get pointers to each of the 12 FVF wireframe line vertices.
        GET_FVF_POINTER (pLineVert[ 0], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 0, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 1], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 1, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 2], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 2, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 3], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 3, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 4], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 4, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 5], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 5, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 6], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 6, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 7], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 7, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 8], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 8, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 9], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 9, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[10], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 10, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[11], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 11, pContext->pCurrentVShader->getStride());

        // Draw all triangles as a wireframe.
        nvAssert (dwCount <= 0xffff);
        WORD  wPrim = dwCount;  // save the number of primitives
        WORD  wTri, wTriangleNum;
        WORD  awMaskedIndices[6*3];

        while (dwCount--)
        {
            wTriangleNum = wPrim-dwCount; // (1...nPrim)

            v0 = dwIndex1;
            v1 = dwIndex2 + (dwIndexStrides >> 24);
            v2 = dwIndex2 + ((dwIndexStrides >> 24) ^ 1);

            // Move on to the next triangle.
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwStrides << 8) & 0xff000000;

            // Each edge line is rendered as a one pixel wide rectangle.

            // Get pointers to each vertex of current triangle.
            GET_FVF_POINTER (pVert0, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), v0, pContext->pCurrentVShader->getStride());
            GET_FVF_POINTER (pVert1, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), v1, pContext->pCurrentVShader->getStride());
            GET_FVF_POINTER (pVert2, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), v2, pContext->pCurrentVShader->getStride());

            // Since culling needs to be disabled to insure that the triangle edges get drawn properly,
            // back face culling of the triangle needs to be performed up front by software.
            IF_NOT_CULLED_BEGIN (pVert0, pVert1, pVert2, dwCullValue)

                // copy vertex data
                for (i = 0; i < dwDwordsPerVert; i++)
                {
                    DWORD dwValue;
                    dwValue = ((DWORD *)pVert0)[i];
                    ((DWORD *)(pLineVert[ 0]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 2]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 9]))[i] = dwValue;
                    ((DWORD *)(pLineVert[11]))[i] = dwValue;

                    dwValue = ((DWORD *)pVert1)[i];
                    ((DWORD *)(pLineVert[ 1]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 3]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 4]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 6]))[i] = dwValue;

                    dwValue = ((DWORD *)pVert2)[i];
                    ((DWORD *)(pLineVert[ 5]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 7]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 8]))[i] = dwValue;
                    ((DWORD *)(pLineVert[10]))[i] = dwValue;
                }

                if (Y_MAJOR_FVF(0,1))
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 0]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 1]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 2]))->sx += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 3]))->sx += HALF_LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 0]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 1]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 2]))->sy += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 3]))->sy += HALF_LINE_WIDTH;
                }

                if (Y_MAJOR_FVF(4,5))
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 4]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 5]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 6]))->sx += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 7]))->sx += HALF_LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 4]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 5]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 6]))->sy += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 7]))->sy += HALF_LINE_WIDTH;
                }

                if (Y_MAJOR_FVF(8,9))
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 8]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 9]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[10]))->sx += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[11]))->sx += HALF_LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 8]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 9]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[10]))->sy += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[11]))->sy += HALF_LINE_WIDTH;
                }

                // if D3DDP2OP_TRIANGLEFAN_IMM, decide which edges are drawn and which are not
                // by inference from the reference rasterizer, the rules appear to be:
                // - interior spokes are NEVER drawn
                // - bit0 controls edge 0->1   where 0 is center vertex
                // - bitN controls edge N->N+1 where N = 1...triangle_count
                // - bitX controls edge X->0   where X = triangle_count+1

                if (dwCachedDP2Op == D3DDP2OP_TRIANGLEFAN_IMM)
                {
                    wTri = 0;

                    // v0-v1
                    // we never draw this edge for anything but the first triangle
                    if (wTriangleNum == 1) {
                        if (dwEdgeFlags & dwEdgeMask) {
                            awMaskedIndices[wTri*3+0] = awWireframeIndices[0*3+0];
                            awMaskedIndices[wTri*3+1] = awWireframeIndices[0*3+1];
                            awMaskedIndices[wTri*3+2] = awWireframeIndices[0*3+2];
                            wTri++;
                            awMaskedIndices[wTri*3+0] = awWireframeIndices[1*3+0];
                            awMaskedIndices[wTri*3+1] = awWireframeIndices[1*3+1];
                            awMaskedIndices[wTri*3+2] = awWireframeIndices[1*3+2];
                            wTri++;
                        }
                        dwEdgeMask <<= 1;
                    }

                    // v1-v2
                    if (dwEdgeFlags & dwEdgeMask) {
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[2*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[2*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[2*3+2];
                        wTri++;
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[3*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[3*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[3*3+2];
                        wTri++;
                    }
                    dwEdgeMask <<= 1;

                    // v2-v0
                    // we never draw this edge for anything but the last triangle
                    if (wTriangleNum == wPrim) {
                        if (dwEdgeFlags & dwEdgeMask) {
                            awMaskedIndices[wTri*3+0] = awWireframeIndices[4*3+0];
                            awMaskedIndices[wTri*3+1] = awWireframeIndices[4*3+1];
                            awMaskedIndices[wTri*3+2] = awWireframeIndices[4*3+2];
                            wTri++;
                            awMaskedIndices[wTri*3+0] = awWireframeIndices[5*3+0];
                            awMaskedIndices[wTri*3+1] = awWireframeIndices[5*3+1];
                            awMaskedIndices[wTri*3+2] = awWireframeIndices[5*3+2];
                            wTri++;
                        }
                        dwEdgeMask <<= 1;
                    }

                    pContext->dp2.dwIndices = (DWORD)(awMaskedIndices);

                    // Draw the specified triangle edges.
                    nvTriangleDispatch (pContext, wTri);
                }

                else {

                    pContext->dp2.dwIndices = (DWORD)(awWireframeIndices);

                    // Draw the all triangle edges.
                    nvTriangleDispatch (pContext, 6);
                }

                IF_NOT_CULLED_END

            }  // while (dwCount)

            // Restore the culling mode.
            if (!pContext->bUseDX6Class)
                pContext->ctxInnerLoop.dwControl = dwControl;
            else
                pContext->mtsState.dwControl0 = dwControl;

            pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
        }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force first call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);
    return;
}

//-------------------------------------------------------------------------

void nvFVFIndexedWireframeTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    BYTE        LineVerts[12 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    BYTE       *pLineVert[12];
    BYTE       *pVert0, *pVert1, *pVert2;
    DWORD       i, dwDwordsPerVert;
    DWORD       v0,v1,v2;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&LineVerts[0]), 12*((sizeof(D3DTLVERTEX))+(7*2*4)), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_INDEXEDTRIANGLELIST2;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 12 * ((sizeof(D3DTLVERTEX)) + (7*2*4));

    if (dwCount)
    {
        LPBYTE pVertices = pVertexBufferBase + dwVertexBufferOffset;
        LPWORD pIndices  = (LPWORD)(pContext->dp2.dwIndices);
        DWORD  dwStrides = nv4DP2OpToStride[dwCachedDP2Op];

        // Calculate the new hardware state if neccessary.
        if (pContext->bStateChange)
        {
            if (pContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class) {
                    nvSetHardwareState (pContext);
                }
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable lower level culling while drawing lines.
        if (!pContext->bUseDX6Class)
        {
            dwControl = pContext->ctxInnerLoop.dwControl;
            pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else
        {
            dwControl = pContext->mtsState.dwControl0;
            pContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Calculate the culling masks.
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        // Force first call to be to the triangle state setup routine.
        NV_FORCE_TRI_SETUP(pContext);

        dwStrides      &= 0xffffff; // mask interesting bits
        dwIndex1        = (DWORD)pIndices;
        dwIndex2        = (DWORD)pIndices + 2;
        dwIndexStrides  = dwStrides * 2;
        dwDwordsPerVert = pContext->pCurrentVShader->getStride() >> 2;

        // Get pointers to each of the 12 FVF wireframe line vertices.
        GET_FVF_POINTER (pLineVert[ 0], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 0, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 1], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 1, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 2], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 2, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 3], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 3, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 4], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 4, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 5], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 5, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 6], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 6, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 7], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 7, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 8], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 8, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 9], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 9, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[10], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 10, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[11], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 11, pContext->pCurrentVShader->getStride());

        // Draw all triangles as a wireframe.
        while (dwCount--)
        {
            v0 = *(WORD*) dwIndex1;
            v1 = *(WORD*)(dwIndex2 +  (dwIndexStrides >> 24));
            v2 = *(WORD*)(dwIndex2 + ((dwIndexStrides >> 24) ^ 2));

            // Move on to the next triangle.
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            // Each edge line is rendered as a one pixel wide rectangle.

            // Get pointers to each vertex of current triangle.
            GET_FVF_POINTER (pVert0, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), v0, pContext->pCurrentVShader->getStride());
            GET_FVF_POINTER (pVert1, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), v1, pContext->pCurrentVShader->getStride());
            GET_FVF_POINTER (pVert2, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), v2, pContext->pCurrentVShader->getStride());

            // Since culling needs to be disabled to insure that the triangle edges get drawn properly,
            // back face culling of the triangle needs to be performed up front by software.
            IF_NOT_CULLED_BEGIN (pVert0, pVert1, pVert2, dwCullValue)

                // copy vertex data
                for (i = 0; i < dwDwordsPerVert; i++)
                {
                    DWORD dwValue;
                    dwValue = ((DWORD *)pVert0)[i];
                    ((DWORD *)(pLineVert[ 0]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 2]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 9]))[i] = dwValue;
                    ((DWORD *)(pLineVert[11]))[i] = dwValue;

                    dwValue = ((DWORD *)pVert1)[i];
                    ((DWORD *)(pLineVert[ 1]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 3]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 4]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 6]))[i] = dwValue;

                    dwValue = ((DWORD *)pVert2)[i];
                    ((DWORD *)(pLineVert[ 5]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 7]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 8]))[i] = dwValue;
                    ((DWORD *)(pLineVert[10]))[i] = dwValue;
                }


                if ((dwCachedDP2Op==D3DDP2OP_INDEXEDTRIANGLESTRIP)
                    && (pContext->dwRenderState[D3DRS_SHADEMODE]==D3DSHADE_FLAT)
                    && pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE]))
                {
                    BYTE * c0, * c1, * c2;
                    DWORD Off;

                    GET_FVF_POINTER (c0, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_DIFFUSE]), v0, pContext->pCurrentVShader->getStride());
                    GET_FVF_POINTER (c1, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_DIFFUSE]), v1, pContext->pCurrentVShader->getStride());
                    GET_FVF_POINTER (c2, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_DIFFUSE]), v2, pContext->pCurrentVShader->getStride());

                    Off=pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_DIFFUSE]);

                    *((DWORD *)(pLineVert[ 1]+Off))=*((DWORD *)c0);
                    *((DWORD *)(pLineVert[ 3]+Off))=*((DWORD *)c0);
                    *((DWORD *)(pLineVert[ 4]+Off))=*((DWORD *)c0);
                    *((DWORD *)(pLineVert[ 6]+Off))=*((DWORD *)c0);

                    *((DWORD *)(pLineVert[ 5]+Off))=*((DWORD *)c0);
                    *((DWORD *)(pLineVert[ 7]+Off))=*((DWORD *)c0);
                    *((DWORD *)(pLineVert[ 8]+Off))=*((DWORD *)c0);
                    *((DWORD *)(pLineVert[ 10]+Off))=*((DWORD *)c0);
                }


                if (Y_MAJOR_FVF(0,1))
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 0]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 1]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 2]))->sx += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 3]))->sx += HALF_LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 0]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 1]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 2]))->sy += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 3]))->sy += HALF_LINE_WIDTH;
                }

                if (Y_MAJOR_FVF(4,5))
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 4]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 5]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 6]))->sx += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 7]))->sx += HALF_LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 4]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 5]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 6]))->sy += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 7]))->sy += HALF_LINE_WIDTH;
                }

                if (Y_MAJOR_FVF(8,9))
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 8]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 9]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[10]))->sx += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[11]))->sx += HALF_LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 8]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 9]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[10]))->sy += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[11]))->sy += HALF_LINE_WIDTH;
                }

                // If this was called with RenderPrim, dwStrides will be LEGACY_STRIDES, otherwise it won't.
                if ((dwStrides != (LEGACY_STRIDES & 0xffffff)) ||
                    (( ((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLETRIANGLE) == D3DTRIFLAG_EDGEENABLETRIANGLE))
                {
                    pContext->dp2.dwIndices = (DWORD)(awWireframeIndices);
                    // Draw the triangle edges.
                    nvTriangleDispatch (pContext, 6);
                }

                else
                {
                    WORD wTri;
                    WORD awMaskedIndices[6*3];

                    wTri = 0;
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE1)
                    {
                        awMaskedIndices[0*3+0] = awWireframeIndices[0*3+0];
                        awMaskedIndices[0*3+1] = awWireframeIndices[0*3+1];
                        awMaskedIndices[0*3+2] = awWireframeIndices[0*3+2];
                        wTri++;
                        awMaskedIndices[1*3+0] = awWireframeIndices[1*3+0];
                        awMaskedIndices[1*3+1] = awWireframeIndices[1*3+1];
                        awMaskedIndices[1*3+2] = awWireframeIndices[1*3+2];
                        wTri++;
                    }
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE2)
                    {
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[2*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[2*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[2*3+2];
                        wTri++;
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[3*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[3*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[3*3+2];
                        wTri++;
                    }
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE3)
                    {
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[4*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[4*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[4*3+2];
                        wTri++;
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[5*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[5*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[5*3+2];
                        wTri++;
                    }
                    if (wTri)
                    {
                        pContext->dp2.dwIndices = (DWORD)(awMaskedIndices);
                        // Draw the specified triangle edges.
                        nvTriangleDispatch (pContext, wTri);
                    }
                }

            IF_NOT_CULLED_END

        }  // while (nPrimCount)

        // Restore the culling mode.
        if (!pContext->bUseDX6Class)
            pContext->ctxInnerLoop.dwControl = dwControl;
        else
            pContext->mtsState.dwControl0 = dwControl;

        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force first call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);
    return;
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvLight.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 * PORTIONS COPYRIGHT (C) Microsoft Corporation, 1998.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvLight.cpp                                                       *
*   NV4 T&L lighting routines                                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    01Dec98    created                              *
*                                                                           *
\***************************************************************************/

#include "nvprecomp.h"

//---------------------------------------------------------------------------

BOOL nvLightIsDefined(nvLight *pLight)
{
    return (pLight->dwFlags & NVLIGHT_DEFINED);
}

//---------------------------------------------------------------------------

BOOL nvLightIsEnabled(nvLight *pLight)
{
    return (pLight->dwFlags & NVLIGHT_ENABLED);
}

#if (NVARCH >= 0x10)

//---------------------------------------------------------------------------

HRESULT nvLightSetLight(nvLight *pnvLight, LPD3DLIGHT7 pLight7)
{
    float phi2, theta2;

    nvAssert (pLight7);

    // Validate the parameters passed
    switch (pLight7->dltType) {

        case D3DLIGHT_POINT:

            pnvLight->Light7 = *pLight7;

            // sanity-check attenuation
            if ((DWORD_FROM_FLOAT(pnvLight->Light7.dvAttenuation0) == 0) &&
                (DWORD_FROM_FLOAT(pnvLight->Light7.dvAttenuation1) == 0) &&
                (DWORD_FROM_FLOAT(pnvLight->Light7.dvAttenuation2) == 0)) {
                DPF ("d3d gave us a divide by 0 error b/c all attenuations are 0. nice.");
                pnvLight->Light7.dvAttenuation0 = 1.f;
            }

            break;

        case D3DLIGHT_SPOT:

            pnvLight->Light7 = *pLight7;

            // sanity-check attenuation
            if ((DWORD_FROM_FLOAT(pnvLight->Light7.dvAttenuation0) == 0) &&
                (DWORD_FROM_FLOAT(pnvLight->Light7.dvAttenuation1) == 0) &&
                (DWORD_FROM_FLOAT(pnvLight->Light7.dvAttenuation2) == 0)) {
                DPF ("d3d gave us a divide by 0 error b/c all attenuations are 0. nice.");
                pnvLight->Light7.dvAttenuation0 = 1.f;
            }

            // negate direction vector to align with OpenGL
            ReverseVector3 (&(pnvLight->direction), &(pnvLight->Light7.dvDirection));
            NormalizeVector3 (&(pnvLight->direction));  // necessary??

            // calculate falloff and direction
            explut (pnvLight->Light7.dvFalloff, &(pnvLight->falloffParams.L), &(pnvLight->falloffParams.M));
            pnvLight->falloffParams.N = 1.f + pnvLight->falloffParams.L - pnvLight->falloffParams.M;

            // Attenuate the spot direction to get falloff to work
            theta2 = (float) cos(0.5*pnvLight->Light7.dvTheta);
            phi2   = (float) cos(0.5*pnvLight->Light7.dvPhi);
            // Handle case in which theta gets close to or overtakes phi, since hardware can't.
            if (phi2 >= theta2) {        // outer angle <= inner angle, oops
                phi2 = 0.999f * theta2;  // make outer angle cosine slightly smaller
            }

            pnvLight->dvScale = nvInv (theta2 - phi2);
            pnvLight->dvW     = -phi2 * pnvLight->dvScale;

            break;

        case D3DLIGHT_DIRECTIONAL:

            pnvLight->Light7 = *pLight7;

            // negate direction vector to align with OpenGL
            ReverseVector3 (&(pnvLight->direction), &(pnvLight->Light7.dvDirection));
            NormalizeVector3 (&(pnvLight->direction));  // necessary??

            break;

        default:

            // No other light types are allowed
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "Invalid light type passed");
            return DDERR_INVALIDPARAMS;
            break;

    }

    pnvLight->dwFlags |= NVLIGHT_DEFINED;

    return DD_OK;
}

//---------------------------------------------------------------------------

void nvLightInit(nvLight *pnvLight)
{
    pnvLight->dwFlags = 0;
    pnvLight->pNext   = NULL;

    ZeroMemory(&(pnvLight->Light7), sizeof(pnvLight->Light7));
    return;
}

//---------------------------------------------------------------------------

void nvLightEnable(nvLight *pnvLight, nvLight **ppRoot)
{
    nvLight *pTmp;

    // Assert that it is not already enabled
    if (nvLightIsEnabled(pnvLight)) return;

    // Assert that Root Ptr is not Null
    if (ppRoot == NULL) return;

    pTmp = *ppRoot;
    *ppRoot = pnvLight;
    pnvLight->pNext = pTmp;
    pnvLight->dwFlags |= NVLIGHT_ENABLED;

    return;
}

//---------------------------------------------------------------------------

void nvLightDisable(nvLight *pnvLight, nvLight **ppRoot)
{
    nvLight *pLightPrev;

    // Assert that the light is enabled
    if (!nvLightIsEnabled(pnvLight)) return;

    // Assert that Root Ptr is not Null
    if (ppRoot == NULL) return;

    pLightPrev = *ppRoot;

    // If this is the first light in the active list
    if (pLightPrev == pnvLight)
    {
        *ppRoot = pnvLight->pNext;
        pnvLight->dwFlags &= ~NVLIGHT_ENABLED;
        return;
    }

    while (pLightPrev->pNext != pnvLight)
    {
        // Though this light was marked as enabled, it is not on
        // the active list. Assert this.
        if (pLightPrev->pNext == NULL) {
            pnvLight->dwFlags &= ~NVLIGHT_ENABLED;
            return;
        }

        // Else get the next pointer
        pLightPrev = pLightPrev->pNext;
    }

    pLightPrev->pNext = pnvLight->pNext;
    pnvLight->dwFlags &= ~NVLIGHT_ENABLED;

    return;
}

//---------------------------------------------------------------------------

HRESULT nvGrowLightArray (PNVD3DCONTEXT pContext, DWORD dwIndex)
{
    DWORD dwNewArraySize;
    nvLight *pTmpLightArray;
    nvLight *pTmp;
    DWORD i;

    // allocate a few extra in anticipation of more lights being used in the future
    dwNewArraySize = dwIndex+16;
    pTmpLightArray = (nvLight *) new BYTE[dwNewArraySize * sizeof(nvLight)];
    if (pTmpLightArray == NULL) return (DDERR_OUTOFMEMORY);

    // Start the active light list from scratch
    pContext->lighting.pActiveLights = NULL;

    // copy all the current lights into the new array
    for (i=0; i<pContext->dwLightArraySize; i++)
    {
        pTmpLightArray[i] = pContext->pLightArray[i];

        // if the light is enabled, add it to the active list
        if (nvLightIsEnabled(&(pContext->pLightArray[i])))
        {
            pTmp = pContext->lighting.pActiveLights;
            pContext->lighting.pActiveLights = &pTmpLightArray[i];
            pTmpLightArray[i].pNext = pTmp;
        }
    }

    // initialize the remainder of the array
    for (i=pContext->dwLightArraySize; i<dwNewArraySize; i++) {
        nvLightInit(&(pTmpLightArray[i]));
    }

    // free the old lights (if any) and set pointer to the new
    if (pContext->pLightArray) {
        delete [](pContext->pLightArray);
    }
    pContext->pLightArray = pTmpLightArray;
    pContext->dwLightArraySize = dwNewArraySize;

    return (D3D_OK);
}

#endif  // NVARCH >= 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvOverlaySurf_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvOverlaySurf_link.cpp
//      a pointer to a shared file
//
// **************************************************************************
#include "nvprecomp.h"

#include "..\..\..\common\src\nvOverlaySurf.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvMip.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvMip.cpp                                                         *
*   Mipmapping routines.                                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 04/20/98 - wrote it                     *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

static int nvMipMapTable[64] = {
// make, copy idx for 1, copy idx for 0
    0, 0, 2, -1, // 0 = 00 00  ....
    0, 0, 1, -1, // 1 = 10 00  0...
    0, 1, 0, -1, // 2 = 01 00  .0..
    1, 0, 2, -1, // 3 = 11 00  1...   bottom
    0, 2, 3, -1, // 4 = 00 10  ..0.
    0, 2, 1, -1, // 5 = 10 10  ..1.   left
    1, 1, 3, -1, // 6 = 01 10  .1..   equal - look at error
    1, 0, 3, -1, // 7 = 11 10  2...
    0, 3, 0, -1, // 8 = 00 01  ...0
    1, 3, 1, -1, // 9 = 10 01  ...1   equal - look at error
    1, 1, 2, -1, // a = 01 01  .2..   right
    1, 3, 2, -1, // b = 11 01  ...2
    0, 2, 0, -1, // c = 00 11  ..2.   top
    1, 0, 1, -1, // d = 10 11  3...
    1, 1, 0, -1, // e = 01 11  .3..
    1, 2, 0, -1, // f = 11 11  ..3.
};

extern BYTE nvTexelScratchBuffer[8192];
DWORD nvTextureCalcMipMapSize (DWORD dwLogU,DWORD dwLogV,DWORD dwMipMapLevels);
DWORD _key;

typedef void (*NVCOMBINETEXELFPTR)(DWORD);

/****************************************************************************/
/* 16 bpp                                                                   */
/****************************************************************************/

/*
 * x1r5g5b5 no color key
 */
void nvCombineTexelsX1R5G5B5
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD REDBLU = 0x7c1f;
        DWORD GRN    = 0x03e0;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = a >> 16;
        c = *(DWORD*)(src+4);
        d = c >> 16;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        *(WORD*)dst = (WORD)(rb|ag);

        src   += 8;
        dst   += 2;
        count -= 4;
    }
}

/*
 * a1r5g5b5 no color key
 */
void nvCombineTexelsA1R5G5B5
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD t00 = *(WORD*)(src+0);
        DWORD t01 = *(WORD*)(src+2);
        DWORD t10 = *(WORD*)(src+4);
        DWORD t11 = *(WORD*)(src+6);

        DWORD alp = ((t00 & 0x8000) >> 13)
                  | ((t01 & 0x8000) >> 12)
                  | ((t10 & 0x8000) >> 11)
                  | ((t11 & 0x8000) >> 10);

        *(WORD*)dst = *(WORD*)(src+(nvMipMapTable[alp + 1 + nvMipMapTable[alp]] << 1));

        src   += 8;
        dst   += 2;
        count -= 4;
    }
}

/*
 * a4r4g4b4 no color key
 */
void nvCombineTexelsA4R4G4B4
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD REDBLU = 0x0f0f;
        DWORD ALPGRN = 0xf0f0;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = a >> 16;
        c = *(DWORD*)(src+4);
        d = c >> 16;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & ALPGRN) + (b & ALPGRN) + (c & ALPGRN) + (d & ALPGRN)) >> 2) & ALPGRN;

        *(WORD*)dst = (WORD)(rb|ag);

        src   += 8;
        dst   += 2;
        count -= 4;
    }
}

/*
 * r5g6b5 no color key
 */
void nvCombineTexelsR5G6B5
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD REDBLU = 0xf81f;
        DWORD GRN    = 0x07e0;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = a >> 16;
        c = *(DWORD*)(src+4);
        d = c >> 16;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        *(WORD*)dst = (WORD)(rb|ag);

        src   += 8;
        dst   += 2;
        count -= 4;
    }
}

/*
 * y16 no color key
 */
void nvCombineTexelsY16CK
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD t00 = *(WORD*)(src+0);
        DWORD t01 = *(WORD*)(src+2);
        DWORD t10 = *(WORD*)(src+4);
        DWORD t11 = *(WORD*)(src+6);

        DWORD alp = ((t00 != _key) ?  4 : 0)
                  | ((t01 != _key) ?  8 : 0)
                  | ((t10 != _key) ? 16 : 0)
                  | ((t11 != _key) ? 32 : 0);

        if (nvMipMapTable[alp])
        {
            *(WORD*)dst = *(WORD*)(src+(nvMipMapTable[alp+1] << 1));
        }
        else
        {
            *(WORD*)dst = (WORD)_key;
        }

        src   += 8;
        dst   += 2;
        count -= 4;
    }
}

/****************************************************************************/
/* 32 bpp                                                                   */
/****************************************************************************/

/*
 * x8r8g8b8 no color key
 */
void nvCombineTexelsX8R8G8B8
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD REDBLU = 0x00ff00ff;
        DWORD GRN    = 0x0000ff00;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = *(DWORD*)(src+4);
        c = *(DWORD*)(src+8);
        d = *(DWORD*)(src+12);

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        *(DWORD*)dst = rb|ag;

        src   += 16;
        dst   += 4;
        count -= 4;
    }
}

/*
 * a8r8g8b8 no color key
 */
void nvCombineTexelsA8R8G8B8
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD REDBLU = 0x00ff00ff;
        DWORD GRN    = 0x0000ff00;
        DWORD ALP    = 0xff000000;
        DWORD a,b,c,d;
        DWORD A,B,C,D;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);  A = a & ALP;
        b = *(DWORD*)(src+4);  B = b & ALP;
        c = *(DWORD*)(src+8);  C = c & ALP;
        d = *(DWORD*)(src+12); D = d & ALP;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        A = (A>>24) + (B>>24) + (C>>24) + (D>>24);
        A = (A >> 2) << 24;

        *(DWORD*)dst = rb|ag|A;

        src   += 16;
        dst   += 4;
        count -= 4;
    }
}

/*
 * y32 no color key
 */
void nvCombineTexelsY32CK
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD t00 = *(DWORD*)(src+ 0);
        DWORD t01 = *(DWORD*)(src+ 4);
        DWORD t10 = *(DWORD*)(src+ 8);
        DWORD t11 = *(DWORD*)(src+12);

        DWORD alp = ((t00 != _key) ?  4 : 0)
                  | ((t01 != _key) ?  8 : 0)
                  | ((t10 != _key) ? 16 : 0)
                  | ((t11 != _key) ? 32 : 0);

        if (nvMipMapTable[alp])
        {
            *(DWORD*)dst = *(DWORD*)(src+(nvMipMapTable[alp+1] << 2));
        }
        else
        {
            *(DWORD*)dst = _key;
        }

        src   += 16;
        dst   += 4;
        count -= 4;
    }
}

// BUGBUG no automipmaps. do we care?
#if 0

/*
 * nvTextureAutoMipMap
 *
 * automipmap given texture
 */
void nvTextureAutoMipMap
(
    CTexture *pTexture
)
{
    NVCOMBINETEXELFPTR fncCombineTexels;

    /*
     * sanity checks
     */
    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));
    nvAssert (pTexture);

    /*
     * get proper reduction function
     */
    {
        LPDDRAWI_DDRAWSURFACE_LCL lpLcl;

        lpLcl = pTexture->getDDSurfaceLcl();

        if (lpLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) // have colorkey and it matters
        {
            switch (pTexture->getFormat())
            {
                case NV_SURFACE_FORMAT_X1R5G5B5:
                case NV_SURFACE_FORMAT_R5G6B5:
                case NV_SURFACE_FORMAT_A1R5G5B5:
                case NV_SURFACE_FORMAT_A4R4G4B4:
                    fncCombineTexels = nvCombineTexelsY16CK;
                    _key  = lpLcl->ddckCKSrcBlt.dwColorSpaceHighValue & 0x00007FFF;
                    break;
                case NV_SURFACE_FORMAT_X8R8G8B8:
                case NV_SURFACE_FORMAT_A8R8G8B8:
                    fncCombineTexels = nvCombineTexelsY32CK;
                    _key  = lpLcl->ddckCKSrcBlt.dwColorSpaceHighValue;
                    break;
            }
        }
        else
        {
            switch (pTexture->getFormat())
            {
                case NV_SURFACE_FORMAT_X1R5G5B5: fncCombineTexels = nvCombineTexelsX1R5G5B5;
                                                 break;
                case NV_SURFACE_FORMAT_R5G6B5:   fncCombineTexels = nvCombineTexelsR5G6B5;
                                                 break;
                case NV_SURFACE_FORMAT_A1R5G5B5: fncCombineTexels = nvCombineTexelsA1R5G5B5;
                                                 break;
                case NV_SURFACE_FORMAT_A4R4G4B4: fncCombineTexels = nvCombineTexelsA4R4G4B4;
                                                 break;
                case NV_SURFACE_FORMAT_X8R8G8B8: fncCombineTexels = nvCombineTexelsX8R8G8B8;
                                                 break;
                case NV_SURFACE_FORMAT_A8R8G8B8: fncCombineTexels = nvCombineTexelsA8R8G8B8;
                                                 break;
            }
        }
    }

    /*
     * sync
     */
	DDLOCKINDEX(NVSTAT_LOCK_AUTO_MIP);
    pTexture->cpuLockSwz (CSimpleSurface::LOCK_NORMAL);

    {
        int   i,s,c;
        DWORD dwAddr[12];
        DWORD dwOffset[12];
        DWORD dwCount[12];
        DWORD dwMipMapLevel;

        DWORD dwLogU         = pTexture->getLogWidth();
        DWORD dwLogV         = pTexture->getLogHeight();
        DWORD dwMipMapLevels = pTexture->getMipMapCount();
        DWORD dwBPP          = (pTexture->getBPP() == 4) ? 2 : 1; // shift amount

        /*
         * setup mipmap base tables
         */
        s = pTexture->getSwizzled()->getAddress();
        c  = 1 << (dwLogU + dwLogV);
        for (i = dwMipMapLevels-1; i >= 0; i--)
        {
            dwAddr[i]   = s;
            dwOffset[i] = 0;
            dwCount[i]  = c;

            s  += c << dwBPP;
            c >>= 2;
        }

        /*
         * for all pending work
         */
        for (dwMipMapLevel = dwMipMapLevels - 1; dwMipMapLevel; )
        {
            /*
             * setup
             */
            DWORD dwMip  = dwMipMapLevel;
            DWORD dwToGo = min(dwCount[dwMip],1024);

            /*
             * read a line
             */
            nvMemCopy ((DWORD)nvTexelScratchBuffer,
                       dwAddr[dwMip] + (dwOffset[dwMip] << dwBPP),
                       dwToGo << dwBPP);

            /*
             * for as many mipmaps we can possibly do
             */
            for (; dwMip && (dwToGo >= 4); )
            {
                /*
                 * mipmap cached block of data
                 */
                (fncCombineTexels)(dwToGo);

                /*
                 * write dest
                 */
                nvMemCopy (dwAddr[dwMip-1] + ((dwOffset[dwMip] >> 2) << dwBPP),
                           (DWORD)nvTexelScratchBuffer,
                           (dwToGo >> 2) << dwBPP);

                /*
                 * advance to next mip level
                 */
                dwCount[dwMip]  -= dwToGo;
                dwOffset[dwMip] += dwToGo;
                dwToGo >>= 2;
                dwMip--;
            }

            /*
             * advance to next level
             */
            while (dwMipMapLevel && !dwCount[dwMipMapLevel])  dwMipMapLevel--;
        }
    }

    pTexture->cpuUnlockSwz();
}

#endif  // 0

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvObjectLists.cpp ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvObjectLists.cpp                                                 *
*   Routines for management of NvObject lists added in DX7                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe (paulvdk)   3 Mar 2001 created                   *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

//--------------------------------------------------------------------------

// Creates an empty list of NvObjects to be associated with the
// given DIRECTDRAW_LCL

PNV_OBJECT_LIST nvCreateObjectList
(
    DWORD dwDDLclID,
    NV_OBJECT_LIST **ppList
)
{
    PNV_OBJECT_LIST pNvObjectList;
    DWORD           dwSize;

    dbgTracePush ("nvCreateObjectList");

    // make sure we have a DD_LCL
    nvAssert (dwDDLclID);

    // allocate space for the new list and initialize its contents
    dwSize = sizeof(NV_OBJECT_LIST);
    pNvObjectList = (PNV_OBJECT_LIST) AllocIPM (dwSize);
    if (!pNvObjectList) {
        DPF("Out of memory creating object list");
        dbgTracePop();
        return NULL;
    }
    memset (pNvObjectList, 0, dwSize);

    dwSize = NV_OBJECT_LIST_SIZE_DEFAULT * sizeof(CNvObject *);
    pNvObjectList->ppObjectList = (CNvObject **) AllocIPM (dwSize);
    if (!pNvObjectList->ppObjectList) {
        DPF("Out of memory creating object list");
        FreeIPM(pNvObjectList);
        dbgTracePop();
        return NULL;
    }
    memset (pNvObjectList->ppObjectList, 0, dwSize);
    pNvObjectList->dwListSize = NV_OBJECT_LIST_SIZE_DEFAULT;
    pNvObjectList->dwDDLclID = dwDDLclID;

    // insert the new list at the beginning of the list of lists
    pNvObjectList->pNext = *ppList;
    *ppList = pNvObjectList;

    dbgTracePop();
    return pNvObjectList;
}

//--------------------------------------------------------------------------

// Deletes the list of NvObjects being maintained for the given DD_LCL

BOOL nvDeleteObjectList
(
    DWORD dwDDLclID,
    NV_OBJECT_LIST **ppList
)
{
    PNV_OBJECT_LIST pNvObjectList;
    PNV_OBJECT_LIST pNvObjectListNext;

    dbgTracePush ("nvDeleteObjectList");

    // make sure we have a DD_LCL
    nvAssert (dwDDLclID);

    // get the head of the list of lists
    pNvObjectList = *ppList;

    if (!pNvObjectList) {
        // nothing to delete. no list was ever created in the first place
        dbgTracePop();
        return (FALSE);
    }

    // check for the case in which the list to be deleted is at the head
    if (pNvObjectList->dwDDLclID == dwDDLclID) {
        if (pNvObjectList->dwListSize) {
            FreeIPM (pNvObjectList->ppObjectList);
        }
        *ppList = pNvObjectList->pNext;
        FreeIPM (pNvObjectList);

        dbgTracePop();
        return (TRUE);
    }

    // if not at the head, then search down the list
    while (pNvObjectList->pNext != NULL) {
        if (pNvObjectList->pNext->dwDDLclID == dwDDLclID) break;
        pNvObjectList = pNvObjectList->pNext;
    }

    // now pNvObjectList->pNext is the one we actually want to delete
    pNvObjectListNext = pNvObjectList->pNext;
    if (pNvObjectListNext == NULL) {
        // no list for this DD_LCL was found.
        dbgTracePop();
        return (FALSE);
    }

    if (pNvObjectListNext->dwListSize) {
        FreeIPM (pNvObjectListNext->ppObjectList);
    }
    pNvObjectList->pNext = pNvObjectListNext->pNext;
    FreeIPM (pNvObjectListNext);

    dbgTracePop();
    return (TRUE);
}

//--------------------------------------------------------------------------

// Allocates more memory and enlarges a list of NvObjects (private)

BOOL nvExpandObjectList
(
    PNV_OBJECT_LIST pNvObjectList,
    DWORD           dwHandle
)
{
    DWORD       dwNewListSize;
    CNvObject **ppNewList;

    dbgTracePush ("nvExpandObjectList");

    // allocate a bigger list
    dwNewListSize = (dwHandle + NV_OBJECT_LIST_SIZE_INCREMENTAL) & ~(NV_OBJECT_LIST_SIZE_INCREMENTAL - 1);

    DWORD dwSize = dwNewListSize * sizeof(CNvObject *);
    ReallocIPM(pNvObjectList->ppObjectList, dwSize, (void**)&ppNewList);

    if (!ppNewList) {
        DPF ("memory allocation failed. could not expand object list");
        dbgD3DError();
        dbgTracePop();
        return FALSE;
    }

    memset (&ppNewList[pNvObjectList->dwListSize], 0, (dwNewListSize - pNvObjectList->dwListSize) * sizeof(CNvObject*));
    pNvObjectList->dwListSize = dwNewListSize;
    pNvObjectList->ppObjectList = ppNewList;

    dbgTracePop();
    return TRUE;
}

//--------------------------------------------------------------------------

// Returns the list of NvObjects associated with a particular DIRECTDRAW_LCL

PNV_OBJECT_LIST nvFindObjectList
(
    DWORD dwDDLclID,
    NV_OBJECT_LIST **ppList
)
{
    PNV_OBJECT_LIST pNvObjectList;

    dbgTracePush ("nvFindObjectList");

    // make sure we have a DD_LCL
    nvAssert (dwDDLclID);
    
    // get the head of the list of lists
    pNvObjectList = *ppList;

    // find the list for this DD_LCL
    while (pNvObjectList != NULL) {
        if (pNvObjectList->dwDDLclID == dwDDLclID) break;
        pNvObjectList = pNvObjectList->pNext;
    }

    // if no object list was found, create one
    if (pNvObjectList == NULL) {
        dbgTracePop();
        return nvCreateObjectList(dwDDLclID, ppList);
    }
    
    dbgTracePop();
    return (pNvObjectList);
}

//--------------------------------------------------------------------------

// Searches the list of NvObject pointers associated with 'lpDDLcl'
// and returns the pointer to the object indexed by 'handle'

CNvObject *nvGetObjectFromHandle
(
    DWORD dwDDLclID,
    DWORD dwHandle,
    NV_OBJECT_LIST **ppList
)
{
    PNV_OBJECT_LIST pNvObjectList;

    dbgTracePush ("nvGetObjectFromHandle");

    if (global.dwDXRuntimeVersion < 0x0700 && (*ppList == global.pNvSurfaceLists))
    {
        // For DX6 the handle is a pointer to the surface local structure.
        // We just get the object from there.
        if (!dwHandle) {
            dbgTracePop();
            return NULL;
        }
        return (GET_PNVOBJ ((LPDDRAWI_DDRAWSURFACE_LCL)dwHandle));
    }

    pNvObjectList = nvFindObjectList (dwDDLclID, ppList);
    if (!pNvObjectList) {
        dbgTracePop();
        return NULL;
    }

    // the handle should be less than the current list size.
    if (dwHandle >= pNvObjectList->dwListSize) {
        DPF ("handle exceeded list size in nvGetObjectFromHandle");
        dbgTracePop();
        return NULL;
    }

    dbgTracePop();
    return pNvObjectList->ppObjectList[dwHandle];
}

//--------------------------------------------------------------------------

BOOL nvClearObjectListEntry
(
    CNvObject *pObj,
    NV_OBJECT_LIST **ppList
)
{
    dbgTracePush ("nvClearObjectListEntry");

    // make sure we're dealing with DX7 or higher
    if (global.dwDXRuntimeVersion < 0x0700 && (*ppList == global.pNvSurfaceLists)) {
        dbgTracePop();
        return FALSE;
    }

    nvAssert (pObj);
    DWORD dwDDLclID = pObj->getDDLclID();

    if (dwDDLclID) {

        PNV_OBJECT_LIST pNvObjectList = nvFindObjectList (dwDDLclID, ppList);
        if (!pNvObjectList) {
            dbgTracePop();
            return FALSE;
        }

        // we should never get a handle less than 1 (this is because
        // internally, MS uses list[0] to store the list size)
        DWORD dwHandle = pObj->getHandle();

#ifdef WINNT
        // under WIN NT we often get a DestroyDriver call before all the surfaces
        // are destroyed. in this case the handle value may exceed the list size.
        // ignore the request in this case
        if (dwHandle >= pNvObjectList->dwListSize) {
            dbgTracePop();
            return TRUE;
        }
#else
        // the handle should be less than the current list size.
        nvAssert (dwHandle < pNvObjectList->dwListSize);
#endif

        // if this object had a handle associated with it and the handle
        // is still being used for it, clear the entry
        if ((dwHandle) && (pNvObjectList->ppObjectList[dwHandle] == pObj)) {
            pNvObjectList->ppObjectList[dwHandle] = NULL;
        }

    }

    dbgTracePop();
    return TRUE;
}

//--------------------------------------------------------------------------

DWORD nvAddObjectToList
(
    PNV_OBJECT_LIST pNvObjectList,
    CNvObject       *pObj,
    DWORD           dwHandle
)
{
    dbgTracePush ("nvAddObjectToList");
    
    // make sure we get a valid object and handle
    nvAssert (pObj);
    //nvAssert (dwHandle);      //we now have defaults objects of handle 0 when all else fails on vertexshader
    
    // grow the list if necessary
    if (dwHandle >= pNvObjectList->dwListSize) {
        BOOL bRes = nvExpandObjectList (pNvObjectList, dwHandle);
        if (!bRes) {
            dbgTracePop();
            return DDERR_OUTOFMEMORY;
        }
    }
    
    // insert the obbject in the list
    pNvObjectList->ppObjectList[dwHandle] = pObj;
    
    // the object has to know what list it's part of
    pObj->setDDLclID (pNvObjectList->dwDDLclID);
    pObj->setHandle (dwHandle);
    
    // mark the object as dirty, this is used to ensure that rendertargets are up-to-date after mode switches
    pObj->setDirty();
    
    dbgTracePop();
    return DD_OK;
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvpe_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//      a pointer to a shared file
//
// **************************************************************************
#include "nvprecomp.h"
#include "..\..\..\common\VPE\src\nvpe.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvLogo.cpp ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvLogo.cpp                                                        *
*   NVIDIA Logo loading/drawing routines.                                   *
*                                                                           *
*   If the Direct3D registry key "LOGOENABLE" is set to 1, a logo is        *
*   automatically drawn to the render target before EndScene                *
*                                                                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe 05/26/99 - created.                              *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#define ASPECT 1.25 // aspect ratio (width/height)
#define MIN_SIZE 64 // minimum size for logo

#define WIDTH      128
#define HEIGHT     128
#define LOG_WIDTH  7
#define LOG_HEIGHT 7
#define PITCH      (4 * WIDTH)
#define FORMAT     NV_SURFACE_FORMAT_A8R8G8B8

// this file was created using MakeLogo.exe
unsigned dwLogoImage[128 * 128] = {
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x0A808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0B808080, 0x05808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x18878787, 0x45989898, 0x50999999, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x50999999, 0x4A999999, 0x268D8D8D, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0B808080, 0x4A9A9A9A, 0x72D7D7D7, 0x78D9D9D9, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D9D9D9, 0x77DCDCDC, 0x5FB1B1B1, 0x17828282, 0x04808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0C808080, 0x50999999, 0x78D6D6D6, 0x7CD1D1D1, 0x70BDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6CBFBFBF, 0x6AC3C3C3, 0x5C989898, 0x44686868, 0x25727272, 0x057F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0C808080, 0x4D989898, 0x78D4D4D4, 0x6FBABABA, 0x26797979, 0x19787878, 0x167A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x137C7C7C, 0x20818181, 0x65575757, 0x75262626, 0x604E4E4E, 0x107D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0C808080, 0x4D989898, 0x78D4D4D4, 0x6DBBBBBB, 0x167A7A7A, 0x05797979, 0x037C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x037B7B7B, 0x017D7D7D, 0x12838383, 0x66585858, 0x7D262626, 0x6B4E4E4E, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0C808080, 0x4D989898, 0x78D4D4D4, 0x6CBCBCBC, 0x137D7D7D, 0x017D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01818181, 0x14878787, 0x635D5D5D, 0x7C2A2A2A, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0C808080, 0x4F999999, 0x78D3D3D3, 0x6CBBBBBB, 0x127D7D7D, 0x007D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0C808080, 0x4F989898, 0x78D4D4D4, 0x6CBDBDBD, 0x127F7F7F, 0x007F7F7F, 0x00818181, 0x00808080, 0x01808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x08808080, 0x10818181, 0x1E828282, 0x5B9B9B9B, 0x78D4D4D4, 0x63BBBBBB, 0x1F7E7E7E, 0x12808080, 0x12838383, 0x0F848484, 0x09868686, 0x04858585, 0x01818181, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x06808080, 0x11818181, 0x1A868686, 0x39929292, 0x63A2A2A2, 0x70ADADAD, 0x77B5B5B5, 0x65A7A7A7, 0x3B898989, 0x61505050, 0x6B515151, 0x67555555, 0x595E5E5E, 0x30707070, 0x177C7C7C, 0x12848484, 0x0A858585, 0x02828282, 0x01818181, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x05808080, 0x14818181, 0x318F8F8F, 0x64A9A9A9, 0x6EC0C0C0, 0x74D3D3D3, 0x7CE5E5E5, 0x7EE5E5E5, 0x71CCCCCC, 0x367E7E7E, 0x52646464, 0x772B2B2B, 0x7C2B2B2B, 0x7B2E2E2E, 0x792B2B2B, 0x71353535, 0x6C424242, 0x63535353, 0x3C6B6B6B, 0x17808080, 0x0B868686, 0x02828282, 0x00808080, 0x007F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x13808080, 0x2C8D8D8D, 0x64B0B0B0, 0x72CBCBCB, 0x7CE4E4E4, 0x7EE5E5E5, 0x7EE4E4E4, 0x7CDFDFDF, 0x75D3D3D3, 0x76A5A5A5, 0x6D565656, 0x744A4A4A, 0x68585858, 0x625D5D5D, 0x635B5B5B, 0x66585858, 0x68565656, 0x6B4D4D4D, 0x6E3D3D3D, 0x6D404040, 0x644E4E4E, 0x3A6C6C6C, 0x15828282, 0x05848484, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x0C808080, 0x21868686, 0x62ABABAB, 0x71CCCCCC, 0x7CE5E5E5, 0x7EE5E5E5, 0x7DE4E4E4, 0x78D6D6D6, 0x6EBCBCBC, 0x64A5A5A5, 0x41919191, 0x5E636363, 0x791C1C1C, 0x6F323232, 0x227F7F7F, 0x11808080, 0x10808080, 0x11808080, 0x11808080, 0x147F7F7F, 0x23757575, 0x48666666, 0x64535353, 0x674C4C4C, 0x5B575757, 0x24767676, 0x0B868686, 0x02828282, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x18808080, 0x4B999999, 0x6BCACACA, 0x7CE2E2E2, 0x7EE5E5E5, 0x7DE5E5E5, 0x78D8D8D8, 0x6AB5B5B5, 0x509A9A9A, 0x27818181, 0x21808080, 0x23808080, 0x58646464, 0x732C2C2C, 0x63474747, 0x298B8B8B, 0x16858585, 0x13808080, 0x10808080, 0x05808080, 0x01808080, 0x03808080, 0x0B808080, 0x14808080, 0x2F707070, 0x595B5B5B, 0x58545454, 0x306E6E6E, 0x0F828282, 0x02818181, 0x00808080, 0x007F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x04808080, 0x1C818181, 0x62AFAFAF, 0x78D9D9D9, 0x7DE5E5E5, 0x7DE5E5E5, 0x79DFDFDF, 0x6AB9B9B9, 0x50999999, 0x2A808080, 0x287C7C7C, 0x52626262, 0x69474747, 0x6E343434, 0x72404040, 0x52646464, 0x2B838383, 0x62C7C7C7, 0x6DC3C3C3, 0x6CBDBDBD, 0x62A8A8A8, 0x298B8B8B, 0x12808080, 0x06808080, 0x01808080, 0x01808080, 0x06808080, 0x12808080, 0x2C707070, 0x4A5F5F5F, 0x3F656565, 0x127D7D7D, 0x02808080, 0x007F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x0A808080, 0x258A8A8A, 0x63C5C5C5, 0x7CE2E2E2, 0x7EE5E5E5, 0x7CE5E5E5, 0x6ECCCCCC, 0x549B9B9B, 0x2C838383, 0x34747474, 0x63464646, 0x6E282828, 0x78212121, 0x7D1C1C1C, 0x7C1A1A1A, 0x6D333333, 0x3F6F6F6F, 0x2F8B8B8B, 0x62C1C1C1, 0x6DC4C4C4, 0x6EC6C6C6, 0x6FD0D0D0, 0x69D0D0D0, 0x62B8B8B8, 0x2E8E8E8E, 0x12808080, 0x03808080, 0x00808080, 0x01808080, 0x06808080, 0x137E7E7E, 0x336A6A6A, 0x33666666, 0x0E7C7C7C, 0x017F7F7F, 0x007E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x14808080, 0x3E949494, 0x6AD3D3D3, 0x7CE5E5E5, 0x7EE5E5E5, 0x7BE4E4E4, 0x66B5B5B5, 0x358C8C8C, 0x2D7D7D7D, 0x624A4A4A, 0x71212121, 0x7C1B1B1B, 0x7E1A1A1A, 0x7C1A1A1A, 0x721D1D1D, 0x68373737, 0x4D6D6D6D, 0x6AB9B9B9, 0x64AEAEAE, 0x23878787, 0x15848484, 0x1D898989, 0x2C8F8F8F, 0x47969696, 0x66AEAEAE, 0x63C5C5C5, 0x5EA7A7A7, 0x1D818181, 0x05808080, 0x00808080, 0x00808080, 0x01808080, 0x09808080, 0x15767676, 0x1A6E6E6E, 0x067E7E7E, 0x00818181, 0x00808080, 0x007F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x1B808080, 0x5B9F9F9F, 0x73DCDCDC, 0x7DE5E5E5, 0x7CE5E5E5, 0x73DBDBDB, 0x5FA0A0A0, 0x34828282, 0x51646464, 0x6C2A2A2A, 0x7B1A1A1A, 0x7E1A1A1A, 0x7C1A1A1A, 0x6F252525, 0x61535353, 0x30717171, 0x22787878, 0x4D989898, 0x77D3D3D3, 0x6CBBBBBB, 0x147C7C7C, 0x037B7B7B, 0x037E7E7E, 0x057D7D7D, 0x0C7C7C7C, 0x127C7C7C, 0x20858585, 0x5BA1A1A1, 0x56AFAFAF, 0x248B8B8B, 0x09808080, 0x01808080, 0x00808080, 0x00808080, 0x02808080, 0x077C7C7C, 0x07777777, 0x017F7F7F, 0x00818181, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x1D828282, 0x63A7A7A7, 0x7AE1E1E1, 0x7EE5E5E5, 0x7CE5E5E5, 0x68D1D1D1, 0x3C929292, 0x317C7C7C, 0x634F4F4F, 0x781B1B1B, 0x7D1A1A1A, 0x7C1A1A1A, 0x731C1C1C, 0x614F4F4F, 0x24787878, 0x107E7E7E, 0x07808080, 0x11808080, 0x54999999, 0x79D8D8D8, 0x6DBEBEBE, 0x19838383, 0x06828282, 0x01828282, 0x00808080, 0x017F7F7F, 0x007E7E7E, 0x037E7E7E, 0x107D7D7D, 0x22898989, 0x469F9F9F, 0x25919191, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x017D7D7D, 0x01828282, 0x027E7E7E, 0x007E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x1D838383, 0x64ADADAD, 0x7CE4E4E4, 0x7EE5E5E5, 0x7BE5E5E5, 0x64C6C6C6, 0x29898989, 0x2B787878, 0x64454545, 0x7B1A1A1A, 0x7E1A1A1A, 0x7B1A1A1A, 0x66363636, 0x336F6F6F, 0x14808080, 0x0A808080, 0x11808080, 0x18878787, 0x2F8D8D8D, 0x6AA3A3A3, 0x6FC3C3C3, 0x6CA3A3A3, 0x416B6B6B, 0x2E6E6E6E, 0x187C7C7C, 0x12858585, 0x08848484, 0x01818181, 0x017F7F7F, 0x007F7F7F, 0x047E7E7E, 0x0F818181, 0x128B8B8B, 0x08888888, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01818181, 0x098A8A8A, 0x06828282, 0x017F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x1C828282, 0x63AFAFAF, 0x7CE4E4E4, 0x7EE5E5E5, 0x7BE3E3E3, 0x62BEBEBE, 0x21838383, 0x27777777, 0x653F3F3F, 0x7C1A1A1A, 0x7E1A1A1A, 0x7B1E1E1E, 0x624A4A4A, 0x1D7E7E7E, 0x0B808080, 0x14808080, 0x318F8F8F, 0x62A3A3A3, 0x6DC5C5C5, 0x72DDDDDD, 0x6DC7C7C7, 0x2E848484, 0x54666666, 0x70272727, 0x72272727, 0x6D333333, 0x644C4C4C, 0x356E6E6E, 0x15848484, 0x07868686, 0x02818181, 0x007F7F7F, 0x00808080, 0x03838383, 0x02838383, 0x017E7E7E, 0x017F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x06838383, 0x17909090, 0x0E858585, 0x027F7F7F, 0x007F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x1C818181, 0x63AAAAAA, 0x7CE0E0E0, 0x7EE5E5E5, 0x7BE1E1E1, 0x62B8B8B8, 0x1F818181, 0x22797979, 0x64424242, 0x7C1A1A1A, 0x7E1A1A1A, 0x7A212121, 0x5F545454, 0x1D808080, 0x0F808080, 0x268A8A8A, 0x64AAAAAA, 0x72D0D0D0, 0x7CE5E5E5, 0x7EE5E5E5, 0x7BE5E5E5, 0x64C1C1C1, 0x36747474, 0x625C5C5C, 0x6D3C3C3C, 0x6C414141, 0x6C414141, 0x6B3C3C3C, 0x65393939, 0x5D515151, 0x22787878, 0x0A878787, 0x01808080, 0x007F7F7F, 0x00808080, 0x01808080, 0x07787878, 0x0B787878, 0x047F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x12888888, 0x2F969696, 0x12828282, 0x037C7C7C, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x1A808080, 0x61A5A5A5, 0x7CDDDDDD, 0x7EE5E5E5, 0x7CE3E3E3, 0x62B6B6B6, 0x1E818181, 0x1D7E7E7E, 0x624B4B4B, 0x7C1B1B1B, 0x7E1A1A1A, 0x79222222, 0x5C5A5A5A, 0x1D808080, 0x1A808080, 0x4B999999, 0x6CC6C6C6, 0x7CE2E2E2, 0x7EE5E5E5, 0x7DE5E5E5, 0x75D6D6D6, 0x62C1C1C1, 0x34828282, 0x65262626, 0x6C383838, 0x237B7B7B, 0x13808080, 0x12808080, 0x14808080, 0x27757575, 0x575C5C5C, 0x52565656, 0x21727272, 0x04828282, 0x00818181, 0x007F7F7F, 0x00808080, 0x067C7C7C, 0x1A6F6F6F, 0x17747474, 0x07808080, 0x01808080, 0x00808080, 0x00808080, 0x09808080, 0x35959595, 0x459A9A9A, 0x127D7D7D, 0x037C7C7C, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13808080, 0x579D9D9D, 0x79D9D9D9, 0x7EE5E5E5, 0x7CE3E3E3, 0x63BBBBBB, 0x1F858585, 0x16808080, 0x595D5D5D, 0x7A202020, 0x7E1A1A1A, 0x7B202020, 0x5E575757, 0x1D808080, 0x1F808080, 0x61A5A5A5, 0x78D7D7D7, 0x7DE5E5E5, 0x7EE5E5E5, 0x7ADBDBDB, 0x69BBBBBB, 0x46959595, 0x2A808080, 0x4B666666, 0x761A1A1A, 0x6C363636, 0x137D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x04808080, 0x0F808080, 0x1A787878, 0x226C6C6C, 0x087A7A7A, 0x01808080, 0x007F7F7F, 0x00808080, 0x02818181, 0x0F7B7B7B, 0x33666666, 0x23727272, 0x06808080, 0x00808080, 0x00808080, 0x01808080, 0x15808080, 0x53A2A2A2, 0x3B949494, 0x0E797979, 0x017F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0A808080, 0x3E949494, 0x73D4D4D4, 0x7EE5E5E5, 0x7CE5E5E5, 0x65C0C0C0, 0x20878787, 0x0C808080, 0x3A6C6C6C, 0x732D2D2D, 0x7E1A1A1A, 0x7C1B1B1B, 0x614E4E4E, 0x1E7E7E7E, 0x1F838383, 0x63B0B0B0, 0x7BDDDDDD, 0x7EE5E5E5, 0x7CE5E5E5, 0x71CCCCCC, 0x5F9F9F9F, 0x30838383, 0x396F6F6F, 0x56626262, 0x6F565656, 0x77303030, 0x66393939, 0x197B7B7B, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x06808080, 0x037C7C7C, 0x04848484, 0x027E7E7E, 0x017D7D7D, 0x00818181, 0x05838383, 0x20747474, 0x495C5C5C, 0x1A7A7A7A, 0x03808080, 0x00808080, 0x00808080, 0x03808080, 0x21888888, 0x56A7A7A7, 0x258A8A8A, 0x067A7A7A, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x278B8B8B, 0x6AC9C9C9, 0x7DE5E5E5, 0x7CE5E5E5, 0x69C8C8C8, 0x298C8C8C, 0x08808080, 0x1E7A7A7A, 0x68404040, 0x7D1A1A1A, 0x7D1A1A1A, 0x683C3C3C, 0x227A7A7A, 0x1F818181, 0x62B5B5B5, 0x7CE2E2E2, 0x7EE5E5E5, 0x7CE5E5E5, 0x67C0C0C0, 0x378D8D8D, 0x3D727272, 0x654C4C4C, 0x72292929, 0x79202020, 0x77383838, 0x58656565, 0x496C6C6C, 0x3B959595, 0x14808080, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x108C8C8C, 0x148A8A8A, 0x077B7B7B, 0x017E7E7E, 0x01818181, 0x0C838383, 0x3B696969, 0x4C5F5F5F, 0x14808080, 0x01808080, 0x00808080, 0x00808080, 0x09808080, 0x3B949494, 0x56A1A1A1, 0x16808080, 0x027D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x18848484, 0x63BCBCBC, 0x7CE5E5E5, 0x7EE5E5E5, 0x71D1D1D1, 0x36919191, 0x0A808080, 0x12808080, 0x5A5B5B5B, 0x7A1E1E1E, 0x7E1A1A1A, 0x732D2D2D, 0x3C6C6C6C, 0x25808080, 0x63ADADAD, 0x7BE3E3E3, 0x7EE5E5E5, 0x7CE2E2E2, 0x64B5B5B5, 0x2F878787, 0x416B6B6B, 0x6B323232, 0x7C1B1B1B, 0x7E1A1A1A, 0x7C1A1A1A, 0x69434343, 0x478F8F8F, 0x66A1A1A1, 0x67B8B8B8, 0x4D9C9C9C, 0x0D808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0D828282, 0x3C999999, 0x218A8A8A, 0x077B7B7B, 0x01808080, 0x02838383, 0x17808080, 0x565C5C5C, 0x3E696969, 0x0A808080, 0x00808080, 0x00808080, 0x01808080, 0x17808080, 0x5CA0A0A0, 0x40959595, 0x0F787878, 0x027E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x3B979797, 0x74D9D9D9, 0x7EE5E5E5, 0x7ADADADA, 0x559C9C9C, 0x12808080, 0x06808080, 0x2C717171, 0x702E2E2E, 0x7E1A1A1A, 0x7B1F1F1F, 0x5D595959, 0x287F7F7F, 0x61A4A4A4, 0x7CDFDFDF, 0x7EE5E5E5, 0x7BE3E3E3, 0x64AFAFAF, 0x2A838383, 0x416A6A6A, 0x6E292929, 0x7D1A1A1A, 0x7D1A1A1A, 0x76272727, 0x644E4E4E, 0x3E8A8A8A, 0x68CDCDCD, 0x6FB5B5B5, 0x3A8E8E8E, 0x3E999999, 0x10838383, 0x07808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0E808080, 0x50989898, 0x60B0B0B0, 0x1E848484, 0x067A7A7A, 0x02818181, 0x12898989, 0x496A6A6A, 0x63474747, 0x22787878, 0x03808080, 0x00808080, 0x00808080, 0x0F808080, 0x5B9B9B9B, 0x66BBBBBB, 0x22868686, 0x09787878, 0x017F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x04808080, 0x258C8C8C, 0x70CECECE, 0x7CE1E1E1, 0x65A9A9A9, 0x1A808080, 0x02808080, 0x0C808080, 0x4B626262, 0x781A1A1A, 0x7D1A1A1A, 0x683E3E3E, 0x267B7B7B, 0x3C939393, 0x74D8D8D8, 0x7EE5E5E5, 0x7CE5E5E5, 0x62B8B8B8, 0x23828282, 0x32707070, 0x6C2E2E2E, 0x7D1A1A1A, 0x7C1A1A1A, 0x6D2E2E2E, 0x46676767, 0x237E7E7E, 0x4F9A9A9A, 0x77D3D3D3, 0x6DBBBBBB, 0x1A797979, 0x0D7F7F7F, 0x19727272, 0x33696969, 0x11808080, 0x02808080, 0x00808080, 0x00808080, 0x04808080, 0x24898989, 0x6CBABABA, 0x7BD4D4D4, 0x60A3A3A3, 0x15787878, 0x02808080, 0x16878787, 0x62595959, 0x79282828, 0x5E555555, 0x10808080, 0x00808080, 0x03808080, 0x21868686, 0x6CBBBBBB, 0x7BD8D8D8, 0x62AAAAAA, 0x127C7C7C, 0x007D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x14808080, 0x6CB7B7B7, 0x72CDCDCD, 0x308B8B8B, 0x06808080, 0x00808080, 0x06808080, 0x326E6E6E, 0x72282828, 0x74282828, 0x3A6C6C6C, 0x16808080, 0x549F9F9F, 0x79DFDFDF, 0x7CE5E5E5, 0x65C1C1C1, 0x1F868686, 0x137D7D7D, 0x63434343, 0x7C1A1A1A, 0x7D1A1A1A, 0x6B2F2F2F, 0x31707070, 0x0E808080, 0x0F808080, 0x549A9A9A, 0x79D3D3D3, 0x6CBABABA, 0x137D7D7D, 0x01818181, 0x147D7D7D, 0x5B4F4F4F, 0x45666666, 0x0B808080, 0x00808080, 0x03808080, 0x1D848484, 0x63B5B5B5, 0x7CDBDBDB, 0x7DD5D5D5, 0x67B8B8B8, 0x12808080, 0x05818181, 0x29747474, 0x70383838, 0x7E232323, 0x6D3C3C3C, 0x18777777, 0x03808080, 0x15818181, 0x62A7A7A7, 0x7CD8D8D8, 0x7DD5D5D5, 0x67B6B6B6, 0x12808080, 0x017C7C7C, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0F808080, 0x5EA0A0A0, 0x74D1D1D1, 0x48979797, 0x0B808080, 0x00808080, 0x02808080, 0x197A7A7A, 0x6D3C3C3C, 0x6E383838, 0x1B808080, 0x06808080, 0x278B8B8B, 0x70D5D5D5, 0x72D2D2D2, 0x2D8D8D8D, 0x07808080, 0x15797979, 0x6D3B3B3B, 0x7E1A1A1A, 0x742A2A2A, 0x3D6B6B6B, 0x0C808080, 0x01808080, 0x0D808080, 0x549A9A9A, 0x79D3D3D3, 0x6CBABABA, 0x127E7E7E, 0x027D7D7D, 0x13898989, 0x4C646464, 0x64454545, 0x21787878, 0x05808080, 0x1A818181, 0x63AAAAAA, 0x7BDADADA, 0x7DD5D5D5, 0x74C7C7C7, 0x46979797, 0x0C7D7D7D, 0x18808080, 0x62505050, 0x7C2A2A2A, 0x7C262626, 0x61505050, 0x117E7E7E, 0x09808080, 0x3B939393, 0x75CCCCCC, 0x7ED8D8D8, 0x76CBCBCB, 0x44969696, 0x0F787878, 0x017E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x2B8D8D8D, 0x70D1D1D1, 0x68AEAEAE, 0x12808080, 0x00808080, 0x00808080, 0x11808080, 0x66515151, 0x702C2C2C, 0x2E717171, 0x06808080, 0x14808080, 0x6CC0C0C0, 0x6EC5C5C5, 0x1B868686, 0x02808080, 0x12808080, 0x67505050, 0x7C1D1D1D, 0x68565656, 0x17808080, 0x01808080, 0x00808080, 0x0D808080, 0x549A9A9A, 0x79D3D3D3, 0x6CBABABA, 0x127E7E7E, 0x027C7C7C, 0x05858585, 0x1C7F7F7F, 0x69424242, 0x575E5E5E, 0x1C7F7F7F, 0x569D9D9D, 0x7AD5D5D5, 0x7EDADADA, 0x79CDCDCD, 0x549B9B9B, 0x1C767676, 0x0E828282, 0x47666666, 0x76323232, 0x7E262626, 0x6F3A3A3A, 0x28747474, 0x07808080, 0x20858585, 0x68BCBCBC, 0x7DDADADA, 0x7CD1D1D1, 0x63A9A9A9, 0x197A7A7A, 0x047C7C7C, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x15818181, 0x6CBBBBBB, 0x6EC5C5C5, 0x1C878787, 0x02808080, 0x00808080, 0x0A808080, 0x43686868, 0x732B2B2B, 0x5B5D5D5D, 0x0F808080, 0x10808080, 0x64A5A5A5, 0x71D7D7D7, 0x33909090, 0x07808080, 0x0B808080, 0x4B656565, 0x752B2B2B, 0x625E5E5E, 0x10808080, 0x00808080, 0x00808080, 0x0D808080, 0x549A9A9A, 0x79D3D3D3, 0x6CBABABA, 0x127E7E7E, 0x007D7D7D, 0x01808080, 0x13878787, 0x5E5A5A5A, 0x6B3F3F3F, 0x36898989, 0x6ECCCCCC, 0x7EDADADA, 0x7BD0D0D0, 0x64A7A7A7, 0x21777777, 0x08828282, 0x207B7B7B, 0x6A3E3E3E, 0x7D2A2A2A, 0x792C2C2C, 0x575E5E5E, 0x11808080, 0x18818181, 0x63AAAAAA, 0x7CD8D8D8, 0x7DD5D5D5, 0x69BDBDBD, 0x21858585, 0x057A7A7A, 0x01818181, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0F808080, 0x5CA0A0A0, 0x71D2D2D2, 0x3F949494, 0x08808080, 0x00808080, 0x02808080, 0x1E787878, 0x6E393939, 0x6B484848, 0x147F7F7F, 0x07808080, 0x36919191, 0x72D7D7D7, 0x63A5A5A5, 0x10808080, 0x03808080, 0x22767676, 0x6E373737, 0x6A494949, 0x137E7E7E, 0x00808080, 0x00808080, 0x0D808080, 0x549A9A9A, 0x79D3D3D3, 0x6CBABABA, 0x127E7E7E, 0x007D7D7D, 0x01808080, 0x09868686, 0x2E707070, 0x65444444, 0x6EA4A4A4, 0x7BDBDBDB, 0x7BD3D3D3, 0x62B4B4B4, 0x1F7C7C7C, 0x0A7A7A7A, 0x1B878787, 0x5F565656, 0x7B2D2D2D, 0x7C282828, 0x67484848, 0x1E7B7B7B, 0x0F808080, 0x49989898, 0x77D0D0D0, 0x7ED8D8D8, 0x75CBCBCB, 0x42959595, 0x0F787878, 0x027F7F7F, 0x01838383, 0x00828282, 0x007F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x23888888, 0x6FCCCCCC, 0x67AAAAAA, 0x11808080, 0x00808080, 0x00808080, 0x117F7F7F, 0x63545454, 0x6F363636, 0x29737373, 0x06808080, 0x17838383, 0x6CBFBFBF, 0x6DBFBFBF, 0x15818181, 0x01808080, 0x117F7F7F, 0x61535353, 0x6E363636, 0x25757575, 0x04808080, 0x00808080, 0x0D808080, 0x549A9A9A, 0x79D3D3D3, 0x6CBABABA, 0x127E7E7E, 0x007D7D7D, 0x00808080, 0x01808080, 0x097E7E7E, 0x26747474, 0x5E9E9E9E, 0x79D3D3D3, 0x68C1C1C1, 0x21848484, 0x0B787878, 0x14898989, 0x47676767, 0x76333333, 0x7E272727, 0x72333333, 0x356E6E6E, 0x0C808080, 0x278B8B8B, 0x6CC6C6C6, 0x7DD9D9D9, 0x7BD1D1D1, 0x62A7A7A7, 0x1B797979, 0x047C7C7C, 0x03818181, 0x0F808080, 0x0F808080, 0x03838383, 0x017E7E7E, 0x007F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x12808080, 0x67AFAFAF, 0x6DC3C3C3, 0x1C858585, 0x02808080, 0x00808080, 0x07808080, 0x3A6C6C6C, 0x6F323232, 0x55606060, 0x0D808080, 0x0F808080, 0x5EA1A1A1, 0x6FCFCFCF, 0x2E8E8E8E, 0x05808080, 0x07808080, 0x326F6F6F, 0x6E343434, 0x52626262, 0x0D808080, 0x00808080, 0x0D808080, 0x549A9A9A, 0x79D3D3D3, 0x6CBABABA, 0x127E7E7E, 0x007D7D7D, 0x00808080, 0x00808080, 0x01808080, 0x097B7B7B, 0x258B8B8B, 0x5AB8B8B8, 0x3A939393, 0x11767676, 0x0C888888, 0x27767676, 0x6B3C3C3C, 0x7D2B2B2B, 0x7B262626, 0x5D575757, 0x16808080, 0x20858585, 0x64B9B9B9, 0x7CD9D9D9, 0x7CD3D3D3, 0x64B9B9B9, 0x1F818181, 0x07797979, 0x04848484, 0x1B808080, 0x5F4C4C4C, 0x5F454545, 0x1D7D7D7D, 0x07868686, 0x017F7F7F, 0x007F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x3B939393, 0x6DCECECE, 0x46979797, 0x0B808080, 0x00808080, 0x01808080, 0x177D7D7D, 0x6A464646, 0x6A464646, 0x167C7C7C, 0x05808080, 0x25898989, 0x6EC6C6C6, 0x63A6A6A6, 0x10808080, 0x01808080, 0x147F7F7F, 0x63494949, 0x68464646, 0x167E7E7E, 0x01808080, 0x0D808080, 0x549A9A9A, 0x79D3D3D3, 0x6CBABABA, 0x127E7E7E, 0x007D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x017F7F7F, 0x05808080, 0x0F838383, 0x097D7D7D, 0x08868686, 0x1D818181, 0x63494949, 0x7C2D2D2D, 0x7C242424, 0x65464646, 0x217A7A7A, 0x1F818181, 0x64AEAEAE, 0x7CD8D8D8, 0x7DD3D3D3, 0x6CC6C6C6, 0x2A8B8B8B, 0x0A787878, 0x05818181, 0x18858585, 0x5A5B5B5B, 0x7A2E2E2E, 0x7B2D2D2D, 0x5F404040, 0x1A777777, 0x0A858585, 0x02818181, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x16808080, 0x66B6B6B6, 0x66B5B5B5, 0x14828282, 0x01808080, 0x00808080, 0x0D808080, 0x51626262, 0x6E363636, 0x336F6F6F, 0x07808080, 0x11808080, 0x62A9A9A9, 0x6DC4C4C4, 0x1C848484, 0x02808080, 0x06808080, 0x30707070, 0x663C3C3C, 0x346E6E6E, 0x07808080, 0x0D808080, 0x549A9A9A, 0x79D3D3D3, 0x6CBABABA, 0x127E7E7E, 0x007D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x017E7E7E, 0x05858585, 0x1D848484, 0x60525252, 0x7B2E2E2E, 0x7D242424, 0x6D373737, 0x2E727272, 0x20808080, 0x62A5A5A5, 0x7CD5D5D5, 0x7ED6D6D6, 0x77CCCCCC, 0x4B989898, 0x13787878, 0x06808080, 0x16898989, 0x47676767, 0x75323232, 0x7E292929, 0x782C2C2C, 0x55616161, 0x23727272, 0x266B6B6B, 0x0F808080, 0x03838383, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x3E949494, 0x69C3C3C3, 0x2E8E8E8E, 0x05808080, 0x00808080, 0x03808080, 0x20787878, 0x6B3D3D3D, 0x61545454, 0x11808080, 0x04808080, 0x25898989, 0x68C0C0C0, 0x509B9B9B, 0x0D808080, 0x01808080, 0x12808080, 0x585A5A5A, 0x5C585858, 0x13808080, 0x0E808080, 0x549A9A9A, 0x79D3D3D3, 0x6CBABABA, 0x127E7E7E, 0x007D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x06868686, 0x1D838383, 0x61525252, 0x7B2E2E2E, 0x7E262626, 0x762C2C2C, 0x4C656565, 0x27818181, 0x599D9D9D, 0x79D5D5D5, 0x7ED7D7D7, 0x7CCFCFCF, 0x61A3A3A3, 0x1B797979, 0x077E7E7E, 0x10898989, 0x366E6E6E, 0x6E363636, 0x7D2B2B2B, 0x7C282828, 0x60525252, 0x197F7F7F, 0x0A7F7F7F, 0x21707070, 0x34656565, 0x16797979, 0x05838383, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x17808080, 0x64B6B6B6, 0x63ADADAD, 0x13808080, 0x01808080, 0x00808080, 0x0E808080, 0x54606060, 0x6B3F3F3F, 0x22777777, 0x04808080, 0x0E808080, 0x519B9B9B, 0x67B3B3B3, 0x1B808080, 0x02808080, 0x02808080, 0x1A808080, 0x4F5B5B5B, 0x2C6F6F6F, 0x13808080, 0x529A9A9A, 0x79D3D3D3, 0x6CBABABA, 0x127E7E7E, 0x007D7D7D, 0x00808080, 0x007F7F7F, 0x017F7F7F, 0x02818181, 0x07878787, 0x1D808080, 0x61505050, 0x7B2E2E2E, 0x7E282828, 0x79292929, 0x5D5B5B5B, 0x31818181, 0x60A1A1A1, 0x79D2D2D2, 0x7ED7D7D7, 0x7CD1D1D1, 0x64ACACAC, 0x1E7C7C7C, 0x087C7C7C, 0x0D898989, 0x2A747474, 0x693B3B3B, 0x7C2C2C2C, 0x7C242424, 0x64464646, 0x1E7B7B7B, 0x03808080, 0x01808080, 0x07808080, 0x1D757575, 0x3A616161, 0x19757575, 0x05838383, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39929292, 0x68C3C3C3, 0x2E8E8E8E, 0x05808080, 0x00808080, 0x03808080, 0x1D7A7A7A, 0x66444444, 0x555F5F5F, 0x0F808080, 0x02808080, 0x1A828282, 0x60AEAEAE, 0x4F9B9B9B, 0x0E808080, 0x00808080, 0x03808080, 0x19797979, 0x36646464, 0x187A7A7A, 0x4C969696, 0x77D4D4D4, 0x6CBABABA, 0x137D7D7D, 0x017C7C7C, 0x01808080, 0x02818181, 0x05868686, 0x12898989, 0x23797979, 0x634A4A4A, 0x7B2D2D2D, 0x7E262626, 0x782A2A2A, 0x5C5C5C5C, 0x34818181, 0x5E9F9F9F, 0x79CFCFCF, 0x7ED8D8D8, 0x7CD1D1D1, 0x63B3B3B3, 0x1F7C7C7C, 0x087B7B7B, 0x0C898989, 0x25777777, 0x66404040, 0x7C2D2D2D, 0x7C242424, 0x663E3E3E, 0x22787878, 0x04808080, 0x00808080, 0x00808080, 0x00808080, 0x04808080, 0x107D7D7D, 0x236C6C6C, 0x19757575, 0x057F7F7F, 0x017F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x15808080, 0x62B5B5B5, 0x62AFAFAF, 0x13808080, 0x01808080, 0x00808080, 0x0B808080, 0x47666666, 0x66424242, 0x22787878, 0x03808080, 0x05808080, 0x298C8C8C, 0x5BB0B0B0, 0x1F888888, 0x03808080, 0x00808080, 0x04808080, 0x10777777, 0x16797979, 0x64A1A1A1, 0x7CD8D8D8, 0x6DC1C1C1, 0x15868686, 0x05858585, 0x0B888888, 0x13888888, 0x1B7F7F7F, 0x48666666, 0x6B3F3F3F, 0x7C2C2C2C, 0x7D262626, 0x772C2C2C, 0x5C5D5D5D, 0x35828282, 0x63A4A4A4, 0x7ACFCFCF, 0x7ED7D7D7, 0x7CD1D1D1, 0x63AFAFAF, 0x1E7F7F7F, 0x087B7B7B, 0x0B898989, 0x207C7C7C, 0x63454545, 0x7C2C2C2C, 0x7C242424, 0x6A393939, 0x2C727272, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x04808080, 0x20838383, 0x4A9C9C9C, 0x1D868686, 0x07797979, 0x02818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x06808080, 0x318F8F8F, 0x66C1C1C1, 0x2D8D8D8D, 0x05808080, 0x00808080, 0x02808080, 0x187F7F7F, 0x5E4D4D4D, 0x575D5D5D, 0x0F808080, 0x01808080, 0x0B808080, 0x39959595, 0x3E9B9B9B, 0x0B808080, 0x00808080, 0x00808080, 0x01808080, 0x10828282, 0x61A1A1A1, 0x79B4B4B4, 0x6AAFAFAF, 0x227C7C7C, 0x187A7A7A, 0x2B727272, 0x54626262, 0x6B474747, 0x772F2F2F, 0x7D272727, 0x7C242424, 0x70343434, 0x55636363, 0x36858585, 0x66AAAAAA, 0x7BD3D3D3, 0x7ED9D9D9, 0x7CD0D0D0, 0x63B2B2B2, 0x1E828282, 0x08797979, 0x0A888888, 0x207C7C7C, 0x62484848, 0x7B2D2D2D, 0x7D242424, 0x6E363636, 0x376D6D6D, 0x0A808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x1D838383, 0x64ABABAB, 0x77D2D2D2, 0x61B8B8B8, 0x19858585, 0x047D7D7D, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13808080, 0x61A9A9A9, 0x62AEAEAE, 0x15808080, 0x01808080, 0x00808080, 0x05808080, 0x28747474, 0x5D4C4C4C, 0x22777777, 0x04808080, 0x01808080, 0x0B808080, 0x168B8B8B, 0x08878787, 0x02808080, 0x00808080, 0x00808080, 0x09808080, 0x426C6C6C, 0x6B5A5A5A, 0x5E686868, 0x693C3C3C, 0x6D383838, 0x71313131, 0x792A2A2A, 0x7D252525, 0x7D252525, 0x772E2E2E, 0x68484848, 0x466E6E6E, 0x43909090, 0x68B8B8B8, 0x7CD7D7D7, 0x7ED8D8D8, 0x7CD0D0D0, 0x63ADADAD, 0x1E818181, 0x097B7B7B, 0x0C898989, 0x207B7B7B, 0x63464646, 0x7B2D2D2D, 0x7D232323, 0x71323232, 0x43686868, 0x0F808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x1E848484, 0x63AFAFAF, 0x7CD6D6D6, 0x7ED6D6D6, 0x73CECECE, 0x34959595, 0x0A7B7B7B, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x20868686, 0x5FB4B4B4, 0x35919191, 0x07808080, 0x00808080, 0x00808080, 0x0E808080, 0x4B636363, 0x545B5B5B, 0x15808080, 0x01808080, 0x00808080, 0x02808080, 0x02808080, 0x09787878, 0x0B808080, 0x04808080, 0x0D808080, 0x53606060, 0x77202020, 0x76383838, 0x6F4A4A4A, 0x6F393939, 0x742F2F2F, 0x74303030, 0x6F3C3C3C, 0x6A4B4B4B, 0x54656565, 0x35808080, 0x619F9F9F, 0x72C7C7C7, 0x7CDADADA, 0x7DD7D7D7, 0x78CCCCCC, 0x62A6A6A6, 0x1D7D7D7D, 0x0A7B7B7B, 0x128B8B8B, 0x26777777, 0x64474747, 0x7C2E2E2E, 0x7D242424, 0x72313131, 0x4A656565, 0x12808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x1F858585, 0x64B0B0B0, 0x7CD7D7D7, 0x7ED7D7D7, 0x7BCFCFCF, 0x62A7A7A7, 0x177F7F7F, 0x037F7F7F, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0A808080, 0x42969696, 0x5FADADAD, 0x1A818181, 0x02808080, 0x00808080, 0x02808080, 0x177E7E7E, 0x505B5B5B, 0x39696969, 0x0A808080, 0x00808080, 0x00808080, 0x02808080, 0x15757575, 0x3C636363, 0x24747474, 0x1D808080, 0x53666666, 0x781A1A1A, 0x6F363636, 0x26797979, 0x23747474, 0x3B6B6B6B, 0x3F6B6B6B, 0x32747474, 0x2D808080, 0x50979797, 0x6BB5B5B5, 0x7AD2D2D2, 0x7ED9D9D9, 0x7CD4D4D4, 0x6CC1C1C1, 0x4D999999, 0x1A7A7A7A, 0x077E7E7E, 0x188B8B8B, 0x32717171, 0x67404040, 0x7C2D2D2D, 0x7D222222, 0x72323232, 0x46676767, 0x137F7F7F, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x0D808080, 0x278B8B8B, 0x64B7B7B7, 0x7CD8D8D8, 0x7ED7D7D7, 0x7BCDCDCD, 0x61A3A3A3, 0x1F7B7B7B, 0x057B7B7B, 0x02818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x16808080, 0x58A0A0A0, 0x4F9C9C9C, 0x10808080, 0x01808080, 0x00808080, 0x02808080, 0x177C7C7C, 0x38646464, 0x13767676, 0x02808080, 0x00808080, 0x00808080, 0x0A7F7F7F, 0x39696969, 0x5D494949, 0x69535353, 0x72565656, 0x75303030, 0x63414141, 0x20818181, 0x19858585, 0x2B8C8C8C, 0x43939393, 0x66A2A2A2, 0x6DBBBBBB, 0x76D2D2D2, 0x7DDBDBDB, 0x7ED6D6D6, 0x79CECECE, 0x64B2B2B2, 0x26898989, 0x12787878, 0x06818181, 0x1B878787, 0x49676767, 0x6D3B3B3B, 0x7C2B2B2B, 0x7C212121, 0x6E363636, 0x47666666, 0x127F7F7F, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x18808080, 0x49989898, 0x6CC4C4C4, 0x7CDADADA, 0x7DD5D5D5, 0x78CDCDCD, 0x5FA1A1A1, 0x1E7B7B7B, 0x057A7A7A, 0x017F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x1A818181, 0x4D9F9F9F, 0x268D8D8D, 0x05808080, 0x00808080, 0x00808080, 0x02808080, 0x0B7D7D7D, 0x0C757575, 0x037E7E7E, 0x01808080, 0x00808080, 0x01808080, 0x0C7F7F7F, 0x2C727272, 0x62484848, 0x69414141, 0x55676767, 0x3F747474, 0x64B5B5B5, 0x6DB9B9B9, 0x70C4C4C4, 0x75CFCFCF, 0x7CD9D9D9, 0x7EDDDDDD, 0x7DD7D7D7, 0x77CDCDCD, 0x6CBABABA, 0x549C9C9C, 0x1B7F7F7F, 0x067E7E7E, 0x0D858585, 0x1F7C7C7C, 0x5F565656, 0x76323232, 0x7D282828, 0x7C222222, 0x693C3C3C, 0x356E6E6E, 0x0F7E7E7E, 0x02808080, 0x00808080, 0x00808080, 0x02808080, 0x0A808080, 0x20858585, 0x62A7A7A7, 0x77D3D3D3, 0x7DDEDEDE, 0x7CD3D3D3, 0x6FC5C5C5, 0x529B9B9B, 0x1B7A7A7A, 0x057A7A7A, 0x01808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x1A868686, 0x409D9D9D, 0x12838383, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x02818181, 0x09868686, 0x05808080, 0x01808080, 0x01808080, 0x05808080, 0x117E7E7E, 0x27838383, 0x64A0A0A0, 0x6DA2A2A2, 0x6DC5C5C5, 0x73D5D5D5, 0x79D6D6D6, 0x77D2D2D2, 0x71C8C8C8, 0x6DBDBDBD, 0x69AFAFAF, 0x47979797, 0x19808080, 0x107A7A7A, 0x09818181, 0x177F7F7F, 0x43686868, 0x69444444, 0x7B2C2C2C, 0x7E262626, 0x7B262626, 0x65464646, 0x2B727272, 0x0A7F7F7F, 0x01808080, 0x00808080, 0x01808080, 0x05808080, 0x18838383, 0x43969696, 0x69BEBEBE, 0x7CDDDDDD, 0x7ED9D9D9, 0x7CD0D0D0, 0x65B9B9B9, 0x2F8D8D8D, 0x15777777, 0x047D7D7D, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x1C8C8C8C, 0x22939393, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x06838383, 0x21929292, 0x268F8F8F, 0x12808080, 0x05808080, 0x00808080, 0x0A808080, 0x41979797, 0x75D1D1D1, 0x6EB7B7B7, 0x27838383, 0x34919191, 0x529B9B9B, 0x49989898, 0x288D8D8D, 0x16848484, 0x157A7A7A, 0x11787878, 0x0A818181, 0x14828282, 0x30707070, 0x63525252, 0x762F2F2F, 0x7D282828, 0x7D262626, 0x74313131, 0x5D575757, 0x1D7C7C7C, 0x05808080, 0x01808080, 0x00808080, 0x04808080, 0x13818181, 0x2C8D8D8D, 0x64AFAFAF, 0x76D2D2D2, 0x7DDDDDDD, 0x7DD3D3D3, 0x75CBCBCB, 0x64AAAAAA, 0x207F7F7F, 0x10747474, 0x047E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x04808080, 0x0C888888, 0x08888888, 0x01818181, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x52A2A2A2, 0x5BA0A0A0, 0x2A8C8C8C, 0x13808080, 0x16808080, 0x52989898, 0x79D5D5D5, 0x6DBDBDBD, 0x177A7A7A, 0x0F767676, 0x14787878, 0x0F797979, 0x087D7D7D, 0x0A808080, 0x10808080, 0x187D7D7D, 0x396C6C6C, 0x63555555, 0x71383838, 0x7C2A2A2A, 0x7E282828, 0x7A2E2E2E, 0x68454545, 0x3E6A6A6A, 0x15808080, 0x03808080, 0x00808080, 0x04808080, 0x12808080, 0x288B8B8B, 0x62A5A5A5, 0x71C7C7C7, 0x7CDEDEDE, 0x7EDADADA, 0x7BCDCDCD, 0x68BBBBBB, 0x3E939393, 0x20747474, 0x0A787878, 0x03818181, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x02838383, 0x017E7E7E, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x1C808080, 0x5FA7A7A7, 0x68BBBBBB, 0x67ADADAD, 0x52969696, 0x70A3A3A3, 0x7BD4D4D4, 0x63C0C0C0, 0x20848484, 0x15838383, 0x15858585, 0x157F7F7F, 0x22757575, 0x406A6A6A, 0x61585858, 0x6C494949, 0x74333333, 0x7C292929, 0x7E272727, 0x7B2B2B2B, 0x6F3C3C3C, 0x595B5B5B, 0x1C7E7E7E, 0x09808080, 0x02808080, 0x04808080, 0x11808080, 0x25898989, 0x60A3A3A3, 0x71C2C2C2, 0x7CDADADA, 0x7EDDDDDD, 0x7CD3D3D3, 0x70C3C3C3, 0x60A2A2A2, 0x207F7F7F, 0x13747474, 0x057E7E7E, 0x01818181, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x037C7C7C, 0x0E747474, 0x0D808080, 0x03808080, 0x00808080, 0x00808080, 0x03808080, 0x15808080, 0x3E949494, 0x67BEBEBE, 0x72CBCBCB, 0x78C1C1C1, 0x6AA2A2A2, 0x3F8A8A8A, 0x62505050, 0x6C4D4D4D, 0x6C4D4D4D, 0x6D464646, 0x6F3C3C3C, 0x75323232, 0x7C272727, 0x7E272727, 0x7D2A2A2A, 0x78313131, 0x6E414141, 0x5D585858, 0x28747474, 0x10808080, 0x03808080, 0x08808080, 0x12808080, 0x278A8A8A, 0x61A4A4A4, 0x70C2C2C2, 0x7CD7D7D7, 0x7EDBDBDB, 0x7CD5D5D5, 0x73C5C5C5, 0x65ABABAB, 0x2D8B8B8B, 0x1C747474, 0x0A787878, 0x03818181, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x14767676, 0x3B616161, 0x20767676, 0x0F808080, 0x02808080, 0x00808080, 0x01808080, 0x09808080, 0x1A808080, 0x4E9A9A9A, 0x639C9C9C, 0x566A6A6A, 0x655C5C5C, 0x782B2B2B, 0x7C272727, 0x7C292929, 0x7C282828, 0x7B292929, 0x782F2F2F, 0x73393939, 0x6E434343, 0x67545454, 0x4F636363, 0x20787878, 0x10808080, 0x09808080, 0x10808080, 0x18808080, 0x3B939393, 0x66B1B1B1, 0x70C9C9C9, 0x7CD4D4D4, 0x7ED8D8D8, 0x7CD5D5D5, 0x72C8C8C8, 0x66AEAEAE, 0x338F8F8F, 0x1C777777, 0x10757575, 0x057D7D7D, 0x01818181, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x06808080, 0x22747474, 0x53525252, 0x535D5D5D, 0x1C808080, 0x0C808080, 0x02808080, 0x00808080, 0x02808080, 0x17808080, 0x5B606060, 0x742C2C2C, 0x773E3E3E, 0x655D5D5D, 0x625C5C5C, 0x645A5A5A, 0x625B5B5B, 0x5D5E5E5E, 0x4E646464, 0x326E6E6E, 0x1C777777, 0x13808080, 0x10808080, 0x12808080, 0x13808080, 0x278A8A8A, 0x62A7A7A7, 0x6DBFBFBF, 0x74CFCFCF, 0x7DD6D6D6, 0x7ED7D7D7, 0x7BD3D3D3, 0x70C7C7C7, 0x65ADADAD, 0x328F8F8F, 0x187A7A7A, 0x0D777777, 0x047D7D7D, 0x02818181, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x20787878, 0x565C5C5C, 0x603E3E3E, 0x4F626262, 0x1C808080, 0x11808080, 0x09808080, 0x0E808080, 0x55636363, 0x791E1E1E, 0x6E363636, 0x207E7E7E, 0x10808080, 0x10808080, 0x10808080, 0x10808080, 0x14808080, 0x16808080, 0x14808080, 0x14808080, 0x288B8B8B, 0x61A4A4A4, 0x6CBBBBBB, 0x70CDCDCD, 0x7CD3D3D3, 0x7ED5D5D5, 0x7DD6D6D6, 0x74D3D3D3, 0x6DBEBEBE, 0x5DA0A0A0, 0x25898989, 0x127D7D7D, 0x087A7A7A, 0x027D7D7D, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x137E7E7E, 0x396C6C6C, 0x62404040, 0x68292929, 0x66464646, 0x40696969, 0x23808080, 0x5A636363, 0x761D1D1D, 0x63393939, 0x207C7C7C, 0x12808080, 0x12808080, 0x13808080, 0x19858585, 0x3A939393, 0x60A0A0A0, 0x6BB5B5B5, 0x6DC6C6C6, 0x71CDCDCD, 0x7CD5D5D5, 0x7ED5D5D5, 0x7DD4D4D4, 0x76D5D5D5, 0x6EC7C7C7, 0x66AAAAAA, 0x39929292, 0x18828282, 0x117B7B7B, 0x067A7A7A, 0x017E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x09808080, 0x1B7A7A7A, 0x4A656565, 0x68383838, 0x6A1E1E1E, 0x6D212121, 0x753B3B3B, 0x5F5D5D5D, 0x37757575, 0x62B7B7B7, 0x6CBEBEBE, 0x6CBFBFBF, 0x6CC4C4C4, 0x6ECACACA, 0x74D1D1D1, 0x7CD6D6D6, 0x7ED5D5D5, 0x7ED4D4D4, 0x7AD4D4D4, 0x70D4D4D4, 0x6DC8C8C8, 0x68ADADAD, 0x43969696, 0x1A848484, 0x117E7E7E, 0x097C7C7C, 0x037C7C7C, 0x007E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x0B7F7F7F, 0x157C7C7C, 0x31707070, 0x62535353, 0x6A494949, 0x40717171, 0x3B909090, 0x69D4D4D4, 0x75D7D7D7, 0x77D7D7D7, 0x75D8D8D8, 0x74D6D6D6, 0x70D3D3D3, 0x6DCECECE, 0x6CC0C0C0, 0x6BB1B1B1, 0x579D9D9D, 0x278B8B8B, 0x15848484, 0x127D7D7D, 0x0A7C7C7C, 0x027D7D7D, 0x007D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x06808080, 0x177F7F7F, 0x46949494, 0x6BCCCCCC, 0x68B5B5B5, 0x3B909090, 0x40959595, 0x47979797, 0x41959595, 0x38939393, 0x268D8D8D, 0x19878787, 0x13808080, 0x127C7C7C, 0x0E7D7D7D, 0x047D7D7D, 0x017E7E7E, 0x007D7D7D, 0x007E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0B808080, 0x4B989898, 0x78D3D3D3, 0x6EBBBBBB, 0x1A7A7A7A, 0x0F787878, 0x0E7A7A7A, 0x0C7A7A7A, 0x0A7A7A7A, 0x077A7A7A, 0x037C7C7C, 0x007E7E7E, 0x007E7E7E, 0x007E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0C808080, 0x4D989898, 0x78D3D3D3, 0x6CBCBCBC, 0x137D7D7D, 0x037B7B7B, 0x017E7E7E, 0x017E7E7E, 0x017E7E7E, 0x017E7E7E, 0x007E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0C808080, 0x51999999, 0x78D3D3D3, 0x6CBDBDBD, 0x14808080, 0x027F7F7F, 0x03828282, 0x03828282, 0x03828282, 0x03828282, 0x03828282, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x05838383, 0x17878787, 0x625C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0D808080, 0x549C9C9C, 0x79DDDDDD, 0x6EC5C5C5, 0x23898989, 0x16898989, 0x188B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x1A8B8B8B, 0x1C8C8C8C, 0x288D8D8D, 0x5F626262, 0x7B2A2A2A, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x06808080, 0x2E909090, 0x64B7B7B7, 0x6AA0A0A0, 0x52666666, 0x51646464, 0x4E666666, 0x50656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x50656565, 0x4D666666, 0x50686868, 0x734A4A4A, 0x7D282828, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x06818181, 0x19848484, 0x47686868, 0x71272727, 0x78262626, 0x78272727, 0x78262626, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x77272727, 0x77282828, 0x7D242424, 0x7E202020, 0x6A4A4A4A, 0x127C7C7C, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x06808080, 0x2B6F6F6F, 0x63484848, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D444444, 0x6A434343, 0x525F5F5F, 0x0D7E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x077E7E7E, 0x127B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157A7A7A, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157A7A7A, 0x147A7A7A, 0x0E7D7D7D, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x05808080, 0x07808080, 0x05808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x05808080, 0x07808080, 0x08808080, 0x07808080, 0x05808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x06808080, 0x07808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x07808080, 0x05808080, 0x01808080, 0x00808080, 0x00808080, 0x01808080, 0x05808080, 0x07808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x07808080, 0x06808080, 0x02808080, 0x00808080, 0x00808080, 0x01808080, 0x05808080, 0x07808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x07808080, 0x05808080, 0x01808080, 0x01808080, 0x01808080, 0x05808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x05808080, 0x01808080, 0x01808080, 0x01808080, 0x01808080, 0x01808080, 0x01808080, 0x01808080, 0x01808080, 0x01808080, 0x01808080, 0x01808080, 0x01808080, 0x01808080, 0x05808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x05808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x05808080, 0x07808080, 0x05808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x11838383, 0x298F8F8F, 0x35939393, 0x288F8F8F, 0x0D838383, 0x01808080, 0x00808080, 0x02808080, 0x11838383, 0x298F8F8F, 0x36939393, 0x39939393, 0x36939393, 0x298F8F8F, 0x11838383, 0x02808080, 0x00808080, 0x05818181, 0x1B898989, 0x30919191, 0x38939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x36939393, 0x288F8F8F, 0x0A838383, 0x01808080, 0x01808080, 0x0A838383, 0x288F8F8F, 0x36939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x38939393, 0x30919191, 0x1B898989, 0x05818181, 0x01808080, 0x0A838383, 0x288F8F8F, 0x36939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x36939393, 0x278F8F8F, 0x09838383, 0x01808080, 0x0A838383, 0x288F8F8F, 0x36939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x36939393, 0x298F8F8F, 0x13838383, 0x06808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x0A838383, 0x288F8F8F, 0x36939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x36939393, 0x288F8F8F, 0x0A838383, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x0A838383, 0x288F8F8F, 0x35939393, 0x288F8F8F, 0x0A838383, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x16838383, 0x519B9B9B, 0x6EC6C6C6, 0x73D2D2D2, 0x6AC4C4C4, 0x3D959595, 0x09818181, 0x02808080, 0x16838383, 0x519B9B9B, 0x6EC6C6C6, 0x73D2D2D2, 0x74D2D2D2, 0x73D2D2D2, 0x6EC6C6C6, 0x4F9B9B9B, 0x0D838383, 0x02808080, 0x19898989, 0x62AFAFAF, 0x72CCCCCC, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x73D2D2D2, 0x65C2C2C2, 0x238F8F8F, 0x07808080, 0x06808080, 0x288F8F8F, 0x66C2C2C2, 0x73D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x72CCCCCC, 0x61AFAFAF, 0x16898989, 0x07808080, 0x278F8F8F, 0x66C2C2C2, 0x73D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x71CECECE, 0x59B6B6B6, 0x1C8B8B8B, 0x0B808080, 0x268F8F8F, 0x66C2C2C2, 0x73D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x73D2D2D2, 0x6FC6C6C6, 0x5E9F9F9F, 0x2E8F8F8F, 0x0F838383, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x288F8F8F, 0x66C2C2C2, 0x73D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x73D2D2D2, 0x65C2C2C2, 0x238F8F8F, 0x07808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x288F8F8F, 0x66C2C2C2, 0x73D2D2D2, 0x65C2C2C2, 0x238F8F8F, 0x07808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x16838383, 0x529B9B9B, 0x76C9C9C9, 0x7DE2E2E2, 0x7EE2E2E2, 0x77CCCCCC, 0x569F9F9F, 0x1C7A7A7A, 0x0F808080, 0x509B9B9B, 0x76C9C9C9, 0x7DE2E2E2, 0x7EE2E2E2, 0x7BD5D5D5, 0x75D2D2D2, 0x72CECECE, 0x5EB2B2B2, 0x1D808080, 0x0E7C7C7C, 0x228D8D8D, 0x6EC0C0C0, 0x7EDEDEDE, 0x7DDBDBDB, 0x79D4D4D4, 0x75D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x73D2D2D2, 0x61BEBEBE, 0x26808080, 0x23707070, 0x127C7C7C, 0x38939393, 0x74D2D2D2, 0x7EE2E2E2, 0x7CD5D5D5, 0x75D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x73D2D2D2, 0x71D0D0D0, 0x62B8B8B8, 0x22808080, 0x1C767676, 0x32919191, 0x72D2D2D2, 0x7EE2E2E2, 0x7CD5D5D5, 0x75D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x73D2D2D2, 0x65C2C2C2, 0x398B8B8B, 0x2E707070, 0x2A707070, 0x2E8F8F8F, 0x70D2D2D2, 0x7EE2E2E2, 0x7CD5D5D5, 0x75D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74CECECE, 0x72C2C2C2, 0x69B6B6B6, 0x47989898, 0x0D838383, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7EE2E2E2, 0x7CD5D5D5, 0x75D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x73D2D2D2, 0x61BEBEBE, 0x26808080, 0x23707070, 0x0A7C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7DE2E2E2, 0x6CC4C4C4, 0x27858585, 0x1F727272, 0x0A7C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x10838383, 0x519B9B9B, 0x76C9C9C9, 0x7DE2E2E2, 0x7DE2E2E2, 0x76C9C9C9, 0x599D9D9D, 0x307A7A7A, 0x544D4D4D, 0x2D7A7A7A, 0x6CC4C4C4, 0x7DE2E2E2, 0x7DE2E2E2, 0x77C9C9C9, 0x619F9F9F, 0x3E939393, 0x33939393, 0x25818181, 0x59535353, 0x46666666, 0x1F808080, 0x5E9F9F9F, 0x7ACBCBCB, 0x71B6B6B6, 0x52999999, 0x3C939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x30808080, 0x62414141, 0x653D3D3D, 0x2F707070, 0x3B939393, 0x74D2D2D2, 0x7CD5D5D5, 0x6AA3A3A3, 0x40939393, 0x39939393, 0x39939393, 0x38939393, 0x378F8F8F, 0x3B747474, 0x64434343, 0x60505050, 0x2D898989, 0x6ED2D2D2, 0x7CD5D5D5, 0x6AA3A3A3, 0x40939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x30808080, 0x64414141, 0x70313131, 0x60494949, 0x2B878787, 0x6ED2D2D2, 0x7BD5D5D5, 0x66A3A3A3, 0x40939393, 0x39939393, 0x39939393, 0x39939393, 0x3D939393, 0x40939393, 0x40939393, 0x40939393, 0x3D939393, 0x39939393, 0x39939393, 0x3D939393, 0x569B9B9B, 0x5BAAAAAA, 0x198B8B8B, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7CD5D5D5, 0x6AA3A3A3, 0x40939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x30808080, 0x62414141, 0x653D3D3D, 0x28707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x78D5D5D5, 0x5C999999, 0x59606060, 0x62474747, 0x2A707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x06808080, 0x2F8F8F8F, 0x6FC6C6C6, 0x7DE2E2E2, 0x7DE2E2E2, 0x76C9C9C9, 0x529B9B9B, 0x1E838383, 0x356C6C6C, 0x6D373737, 0x65606060, 0x79C8C8C8, 0x7DE2E2E2, 0x73C9C9C9, 0x549B9B9B, 0x1A838383, 0x09808080, 0x08808080, 0x19767676, 0x67505050, 0x6B434343, 0x31707070, 0x338F8F8F, 0x5FB4B4B4, 0x40959595, 0x15818181, 0x09808080, 0x08808080, 0x08808080, 0x127C7C7C, 0x34707070, 0x5F5C5C5C, 0x7A2A2A2A, 0x742D2D2D, 0x3B6C6C6C, 0x2E8F8F8F, 0x65C2C2C2, 0x66C2C2C2, 0x318F8F8F, 0x0D808080, 0x08808080, 0x0A808080, 0x1D7C7C7C, 0x50646464, 0x6E363636, 0x7C1F1F1F, 0x6D333333, 0x267E7E7E, 0x61C2C2C2, 0x66C2C2C2, 0x318F8F8F, 0x0D808080, 0x08808080, 0x08808080, 0x127C7C7C, 0x34707070, 0x5F5C5C5C, 0x7A2A2A2A, 0x7A2A2A2A, 0x5B606060, 0x2B8C8C8C, 0x63C2C2C2, 0x62BEBEBE, 0x2B838383, 0x117C7C7C, 0x08808080, 0x08808080, 0x127C7C7C, 0x2F707070, 0x3D6C6C6C, 0x3F6C6C6C, 0x3D6C6C6C, 0x30707070, 0x177C7C7C, 0x0A808080, 0x08808080, 0x10838383, 0x1C8C8C8C, 0x07838383, 0x01808080, 0x02808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x288F8F8F, 0x66C2C2C2, 0x67C2C2C2, 0x308F8F8F, 0x0D808080, 0x08808080, 0x08808080, 0x127C7C7C, 0x34707070, 0x5F5C5C5C, 0x7A2A2A2A, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x42919191, 0x52666666, 0x713D3D3D, 0x4B666666, 0x0D7E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x5E9F9F9F, 0x7BD5D5D5, 0x7EE2E2E2, 0x77C9C9C9, 0x539B9B9B, 0x16838383, 0x0A808080, 0x386C6C6C, 0x71333333, 0x6F535353, 0x7BC4C4C4, 0x77D3D3D3, 0x4F959595, 0x2B757575, 0x0B7C7C7C, 0x01808080, 0x00808080, 0x0D7E7E7E, 0x4C666666, 0x713D3D3D, 0x4B666666, 0x15818181, 0x1C8C8C8C, 0x12808080, 0x18747474, 0x057C7C7C, 0x00808080, 0x04808080, 0x26707070, 0x673D3D3D, 0x7B2A2A2A, 0x7E1D1D1D, 0x742D2D2D, 0x376C6C6C, 0x11838383, 0x248F8F8F, 0x238B8B8B, 0x1A777777, 0x057C7C7C, 0x02808080, 0x107C7C7C, 0x4C646464, 0x74363636, 0x7D1D1D1D, 0x7D1D1D1D, 0x6B393939, 0x24737373, 0x268F8F8F, 0x238B8B8B, 0x1A777777, 0x057C7C7C, 0x00808080, 0x05808080, 0x28707070, 0x673D3D3D, 0x7B2A2A2A, 0x7E1D1D1D, 0x752D2D2D, 0x3C6C6C6C, 0x11838383, 0x228F8F8F, 0x25808080, 0x53515151, 0x22707070, 0x07808080, 0x05808080, 0x28707070, 0x663D3D3D, 0x732D2D2D, 0x742D2D2D, 0x732D2D2D, 0x6D393939, 0x4B646464, 0x0F7C7C7C, 0x00808080, 0x01808080, 0x02808080, 0x01808080, 0x097C7C7C, 0x1A747474, 0x0E7C7C7C, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x0A838383, 0x258F8F8F, 0x268F8F8F, 0x0F838383, 0x05808080, 0x01808080, 0x05808080, 0x28707070, 0x673D3D3D, 0x7B2A2A2A, 0x7E1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x426C6C6C, 0x74373737, 0x694C4C4C, 0x1D767676, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x7AD5D5D5, 0x5C9F9F9F, 0x19838383, 0x02808080, 0x08808080, 0x3C6C6C6C, 0x673D3D3D, 0x3A747474, 0x71CECECE, 0x79C8C8C8, 0x62646464, 0x60434343, 0x24707070, 0x07808080, 0x01808080, 0x08808080, 0x3B6C6C6C, 0x74373737, 0x694C4C4C, 0x1D767676, 0x07808080, 0x19737373, 0x405D5D5D, 0x1B808080, 0x0D838383, 0x06808080, 0x27707070, 0x6E393939, 0x7D212121, 0x7B2A2A2A, 0x673D3D3D, 0x28707070, 0x05808080, 0x06808080, 0x1B737373, 0x435D5D5D, 0x1B808080, 0x11838383, 0x2E707070, 0x6E393939, 0x7D1D1D1D, 0x7D1D1D1D, 0x74363636, 0x4C646464, 0x107C7C7C, 0x07808080, 0x1B737373, 0x3F5D5D5D, 0x1B808080, 0x0D838383, 0x0A808080, 0x366C6C6C, 0x742D2D2D, 0x7E1D1D1D, 0x7B2A2A2A, 0x673D3D3D, 0x28707070, 0x05808080, 0x07808080, 0x22707070, 0x53515151, 0x25808080, 0x238F8F8F, 0x11838383, 0x376C6C6C, 0x742D2D2D, 0x7E1D1D1D, 0x7B2A2A2A, 0x752D2D2D, 0x73313131, 0x60494949, 0x1A747474, 0x04808080, 0x00808080, 0x00808080, 0x04808080, 0x25707070, 0x60494949, 0x4B646464, 0x107C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x05808080, 0x0F838383, 0x268F8F8F, 0x258F8F8F, 0x0A838383, 0x08808080, 0x366C6C6C, 0x742D2D2D, 0x7E1D1D1D, 0x7B2A2A2A, 0x673D3D3D, 0x28707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x75D2D2D2, 0x74D2D2D2, 0x40939393, 0x3E6C6C6C, 0x742F2F2F, 0x72333333, 0x2F6E6E6E, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x09808080, 0x3D939393, 0x75D2D2D2, 0x7CE2E2E2, 0x65C2C2C2, 0x28838383, 0x087C7C7C, 0x02808080, 0x117C7C7C, 0x51646464, 0x64494949, 0x29838383, 0x6ECBCBCB, 0x7DA8A8A8, 0x7A404040, 0x6F313131, 0x2C767676, 0x1F8D8D8D, 0x0A838383, 0x09808080, 0x3B6C6C6C, 0x742F2F2F, 0x72333333, 0x2F6E6E6E, 0x06808080, 0x077C7C7C, 0x21838383, 0x5EB2B2B2, 0x4F9B9B9B, 0x12838383, 0x137C7C7C, 0x59606060, 0x783A3A3A, 0x695C5C5C, 0x30707070, 0x0A7C7C7C, 0x01808080, 0x01808080, 0x0E808080, 0x3A8F8F8F, 0x61B6B6B6, 0x53989898, 0x5B646464, 0x792A2A2A, 0x7E1D1D1D, 0x75363636, 0x4D646464, 0x157C7C7C, 0x02808080, 0x01808080, 0x077C7C7C, 0x21838383, 0x5EB2B2B2, 0x4F9B9B9B, 0x18838383, 0x396C6C6C, 0x742D2D2D, 0x7B2A2A2A, 0x645C5C5C, 0x2E707070, 0x0A7C7C7C, 0x01808080, 0x01808080, 0x097C7C7C, 0x23838383, 0x61BEBEBE, 0x65C2C2C2, 0x2F8F8F8F, 0x3D6C6C6C, 0x742D2D2D, 0x7B2A2A2A, 0x665C5C5C, 0x3F6C6C6C, 0x366C6C6C, 0x28707070, 0x0F808080, 0x1A8B8B8B, 0x0D838383, 0x02808080, 0x04808080, 0x27707070, 0x6D3D3D3D, 0x6C3D3D3D, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x288F8F8F, 0x66C2C2C2, 0x66C2C2C2, 0x288F8F8F, 0x0C808080, 0x386C6C6C, 0x742D2D2D, 0x7B2A2A2A, 0x645C5C5C, 0x2E707070, 0x0A7C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x74D2D2D2, 0x3F939393, 0x366E6E6E, 0x72333333, 0x742F2F2F, 0x376C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x72D2D2D2, 0x3B878787, 0x4C595959, 0x19747474, 0x09808080, 0x27707070, 0x67494949, 0x54646464, 0x3A8F8F8F, 0x71B2B2B2, 0x79595959, 0x7D212121, 0x79373737, 0x629B9B9B, 0x62BCBCBC, 0x288F8F8F, 0x127E7E7E, 0x4C666666, 0x782B2B2B, 0x742D2D2D, 0x376C6C6C, 0x07808080, 0x07808080, 0x34939393, 0x72CECECE, 0x6EC6C6C6, 0x298F8F8F, 0x0D808080, 0x3D6C6C6C, 0x723D3D3D, 0x60606060, 0x177C7C7C, 0x02808080, 0x00808080, 0x05808080, 0x288F8F8F, 0x68C6C6C6, 0x7BDEDEDE, 0x79B6B6B6, 0x79494949, 0x7D1D1D1D, 0x7A2A2A2A, 0x58606060, 0x187C7C7C, 0x02808080, 0x00808080, 0x00808080, 0x07808080, 0x34939393, 0x72CECECE, 0x6EC6C6C6, 0x308F8F8F, 0x3D6C6C6C, 0x742D2D2D, 0x752D2D2D, 0x3F6C6C6C, 0x0C808080, 0x01808080, 0x00808080, 0x00808080, 0x07808080, 0x34939393, 0x73D2D2D2, 0x74D2D2D2, 0x3E939393, 0x3F6C6C6C, 0x742D2D2D, 0x752D2D2D, 0x3F6C6C6C, 0x0F808080, 0x07808080, 0x07808080, 0x1C8C8C8C, 0x5AAAAAAA, 0x47989898, 0x0E838383, 0x01808080, 0x127C7C7C, 0x57606060, 0x703D3D3D, 0x3A6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x74D2D2D2, 0x37939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x752D2D2D, 0x3F6C6C6C, 0x0C808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x74D2D2D2, 0x39939393, 0x23767676, 0x694D4D4D, 0x74373737, 0x3B6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x7AC2C2C2, 0x645D5D5D, 0x4C646464, 0x1A808080, 0x1D8B8B8B, 0x2C707070, 0x64414141, 0x3A707070, 0x579B9B9B, 0x6AA2A2A2, 0x7A3D3D3D, 0x7B1D1D1D, 0x714B4B4B, 0x78BCBCBC, 0x73D0D0D0, 0x39939393, 0x23767676, 0x694D4D4D, 0x7D242424, 0x742D2D2D, 0x376C6C6C, 0x07808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x37939393, 0x0F808080, 0x386C6C6C, 0x73313131, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7CE2E2E2, 0x74B2B2B2, 0x7C3D3D3D, 0x7E1D1D1D, 0x6F393939, 0x2E707070, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x3E939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x0E838383, 0x47989898, 0x5CAAAAAA, 0x1F8C8C8C, 0x03808080, 0x06808080, 0x2E707070, 0x69494949, 0x51646464, 0x117C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7EE2E2E2, 0x70C6C6C6, 0x2A8F8F8F, 0x127E7E7E, 0x4C666666, 0x723D3D3D, 0x4D666666, 0x0D7E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x09808080, 0x3D939393, 0x75D2D2D2, 0x7DE0E0E0, 0x78ACACAC, 0x6E4F4F4F, 0x36707070, 0x49979797, 0x5AAAAAAA, 0x237C7C7C, 0x514D4D4D, 0x28808080, 0x5EB2B2B2, 0x3D7C7C7C, 0x712D2D2D, 0x712D2D2D, 0x3E808080, 0x71D2D2D2, 0x74D2D2D2, 0x3F939393, 0x366E6E6E, 0x72333333, 0x7E1E1E1E, 0x72333333, 0x2F6E6E6E, 0x06808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x09808080, 0x3F939393, 0x75D2D2D2, 0x71D5D5D5, 0x3A8B8B8B, 0x71313131, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x02808080, 0x10838383, 0x2A8F8F8F, 0x2A8F8F8F, 0x10838383, 0x02808080, 0x117C7C7C, 0x51646464, 0x69494949, 0x2E707070, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x75D2D2D2, 0x7BD5D5D5, 0x609F9F9F, 0x13838383, 0x09808080, 0x3B6C6C6C, 0x74373737, 0x694C4C4C, 0x1D767676, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x77CCCCCC, 0x596C6C6C, 0x663B3B3B, 0x277C7C7C, 0x64B6B6B6, 0x559B9B9B, 0x13808080, 0x1B747474, 0x2C8F8F8F, 0x6DAEAEAE, 0x714D4D4D, 0x7B1D1D1D, 0x7B3D3D3D, 0x72B2B2B2, 0x7BE2E2E2, 0x73D2D2D2, 0x3E939393, 0x426C6C6C, 0x752D2D2D, 0x7D232323, 0x694C4C4C, 0x1D767676, 0x02808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x6CD2D2D2, 0x26808080, 0x6C2D2D2D, 0x752D2D2D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x1F8C8C8C, 0x5DAAAAAA, 0x47989898, 0x0F838383, 0x09808080, 0x3A6C6C6C, 0x703D3D3D, 0x57606060, 0x127C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x75D2D2D2, 0x3F939393, 0x09808080, 0x07808080, 0x386C6C6C, 0x742F2F2F, 0x72333333, 0x2F6E6E6E, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7BDEDEDE, 0x70B4B4B4, 0x74434343, 0x6E313131, 0x32858585, 0x66C0C0C0, 0x3D939393, 0x09808080, 0x06808080, 0x248F8F8F, 0x5F9F9F9F, 0x7A3D3D3D, 0x7C1D1D1D, 0x734D4D4D, 0x7CC2C2C2, 0x7EE2E2E2, 0x6FC6C6C6, 0x338C8C8C, 0x5C606060, 0x7A2A2A2A, 0x782B2B2B, 0x4D666666, 0x0D7E7E7E, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x366C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x6CD2D2D2, 0x24808080, 0x6C2D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x10838383, 0x569B9B9B, 0x69B6B6B6, 0x2F8F8F8F, 0x0B808080, 0x29707070, 0x6E3D3D3D, 0x6E3D3D3D, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x73D2D2D2, 0x36939393, 0x07808080, 0x07808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x376C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x07808080, 0x35939393, 0x73D2D2D2, 0x71D2D2D2, 0x3D808080, 0x6F313131, 0x6E434343, 0x6DA2A2A2, 0x71C8C8C8, 0x39939393, 0x08808080, 0x01808080, 0x09838383, 0x2E787878, 0x72313131, 0x712A2A2A, 0x3C747474, 0x71CECECE, 0x7BD5D5D5, 0x639F9F9F, 0x34737373, 0x6E393939, 0x7E1D1D1D, 0x742D2D2D, 0x396C6C6C, 0x07808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x74CECECE, 0x39939393, 0x0D808080, 0x29707070, 0x6E393939, 0x73313131, 0x386C6C6C, 0x07808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7EE2E2E2, 0x6BC6C6C6, 0x2B7C7C7C, 0x6D2D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x3B939393, 0x71C2C2C2, 0x5E9F9F9F, 0x14838383, 0x137C7C7C, 0x59606060, 0x703D3D3D, 0x3B6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7DDEDEDE, 0x68BABABA, 0x248C8C8C, 0x04808080, 0x07808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x05808080, 0x288F8F8F, 0x65C2C2C2, 0x6EB2B2B2, 0x6F494949, 0x6F313131, 0x3D7E7E7E, 0x71CCCCCC, 0x73D0D0D0, 0x37939393, 0x08808080, 0x01808080, 0x127C7C7C, 0x55606060, 0x7A2A2A2A, 0x71313131, 0x3C8B8B8B, 0x71D5D5D5, 0x75D2D2D2, 0x46939393, 0x3D6C6C6C, 0x732D2D2D, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x72C2C2C2, 0x3F939393, 0x0A808080, 0x137C7C7C, 0x59606060, 0x713D3D3D, 0x3D6C6C6C, 0x08808080, 0x09808080, 0x3F939393, 0x75D2D2D2, 0x7AD5D5D5, 0x609D9D9D, 0x4C6A6A6A, 0x752B2B2B, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x6FC2C2C2, 0x6FC2C2C2, 0x298F8F8F, 0x0D808080, 0x3D6C6C6C, 0x713D3D3D, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x75D2D2D2, 0x77C5C5C5, 0x4A6C6C6C, 0x1D737373, 0x05808080, 0x08808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x01808080, 0x0A838383, 0x238F8F8F, 0x297C7C7C, 0x6F313131, 0x7B3D3D3D, 0x72B2B2B2, 0x7BDEDEDE, 0x70C6C6C6, 0x298F8F8F, 0x05808080, 0x06808080, 0x2E707070, 0x6F393939, 0x7E1D1D1D, 0x7C3D3D3D, 0x74B2B2B2, 0x7CE2E2E2, 0x73D2D2D2, 0x3E939393, 0x436C6C6C, 0x752D2D2D, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x72C2C2C2, 0x609F9F9F, 0x13838383, 0x0A808080, 0x3D6C6C6C, 0x713D3D3D, 0x59606060, 0x137C7C7C, 0x14838383, 0x609F9F9F, 0x7BD5D5D5, 0x70D2D2D2, 0x34898989, 0x684D4D4D, 0x7D242424, 0x742D2D2D, 0x376C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x72C2C2C2, 0x3D939393, 0x10808080, 0x386C6C6C, 0x73313131, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x7CBEBEBE, 0x66545454, 0x29707070, 0x1C8B8B8B, 0x10838383, 0x376C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x01808080, 0x07808080, 0x23707070, 0x633D3D3D, 0x72515151, 0x7CC2C2C2, 0x7BD5D5D5, 0x609F9F9F, 0x13838383, 0x01808080, 0x127C7C7C, 0x57606060, 0x7A2A2A2A, 0x7C1D1D1D, 0x734D4D4D, 0x7CC2C2C2, 0x7EE2E2E2, 0x6FC6C6C6, 0x338C8C8C, 0x5C606060, 0x7A2A2A2A, 0x752D2D2D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x73CECECE, 0x70C6C6C6, 0x298F8F8F, 0x0C808080, 0x386C6C6C, 0x73313131, 0x6E393939, 0x2E707070, 0x2E8F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x6CD2D2D2, 0x25818181, 0x6C333333, 0x7E1E1E1E, 0x72333333, 0x2F6E6E6E, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x72C2C2C2, 0x609F9F9F, 0x1A838383, 0x396C6C6C, 0x742D2D2D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x7DBEBEBE, 0x6A545454, 0x257C7C7C, 0x55B2B2B2, 0x2C8F8F8F, 0x2E707070, 0x6E393939, 0x73313131, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x01808080, 0x0A7C7C7C, 0x26737373, 0x438F8F8F, 0x75D2D2D2, 0x75D2D2D2, 0x3F939393, 0x09808080, 0x05808080, 0x29707070, 0x6E393939, 0x7E1D1D1D, 0x712A2A2A, 0x3E747474, 0x71CECECE, 0x7BD5D5D5, 0x639F9F9F, 0x34737373, 0x6E393939, 0x7E1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x73CECECE, 0x37939393, 0x0E808080, 0x366C6C6C, 0x742D2D2D, 0x742D2D2D, 0x3D6C6C6C, 0x3E939393, 0x74D2D2D2, 0x7EE2E2E2, 0x6CC6C6C6, 0x287C7C7C, 0x6D2D2D2D, 0x7D232323, 0x694C4C4C, 0x1D767676, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74CECECE, 0x70C6C6C6, 0x308F8F8F, 0x3B6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3D939393, 0x75D2D2D2, 0x7CE2E2E2, 0x73B2B2B2, 0x69515151, 0x25808080, 0x62BEBEBE, 0x38939393, 0x197C7C7C, 0x59606060, 0x713D3D3D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x2A8F8F8F, 0x68C6C6C6, 0x7CE2E2E2, 0x74D2D2D2, 0x37939393, 0x08808080, 0x08808080, 0x3B6C6C6C, 0x752D2D2D, 0x7C1D1D1D, 0x693D3D3D, 0x438F8F8F, 0x73D5D5D5, 0x75D2D2D2, 0x46939393, 0x3D6C6C6C, 0x732D2D2D, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x72C2C2C2, 0x3F939393, 0x0E808080, 0x29707070, 0x6E393939, 0x73313131, 0x3F6C6C6C, 0x40939393, 0x74D2D2D2, 0x7BD5D5D5, 0x639F9F9F, 0x3D707070, 0x722D2D2D, 0x782B2B2B, 0x4D666666, 0x0D7E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x3B939393, 0x30707070, 0x6E393939, 0x73313131, 0x386C6C6C, 0x07808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x71D5D5D5, 0x3A8B8B8B, 0x63414141, 0x3B747474, 0x67BBBBBB, 0x39939393, 0x10808080, 0x3D6C6C6C, 0x713D3D3D, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7EE2E2E2, 0x70C6C6C6, 0x298F8F8F, 0x05808080, 0x137C7C7C, 0x59606060, 0x7A2A2A2A, 0x722A2A2A, 0x41707070, 0x69C2C2C2, 0x7CE2E2E2, 0x73D2D2D2, 0x3E939393, 0x436C6C6C, 0x752D2D2D, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x72C2C2C2, 0x609F9F9F, 0x14838383, 0x137C7C7C, 0x59606060, 0x713D3D3D, 0x446C6C6C, 0x3F939393, 0x74D2D2D2, 0x72D2D2D2, 0x3D8F8F8F, 0x5C606060, 0x7A2A2A2A, 0x742D2D2D, 0x3B6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x3A939393, 0x1A7C7C7C, 0x59606060, 0x713D3D3D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x6CD2D2D2, 0x26808080, 0x6A313131, 0x734D4D4D, 0x74AEAEAE, 0x3F939393, 0x10808080, 0x386C6C6C, 0x73313131, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x7BD5D5D5, 0x609F9F9F, 0x13838383, 0x05808080, 0x29707070, 0x6E393939, 0x7E1D1D1D, 0x6D2D2D2D, 0x2B808080, 0x6DD2D2D2, 0x7EE2E2E2, 0x6FC6C6C6, 0x338C8C8C, 0x5C606060, 0x7A2A2A2A, 0x752D2D2D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x73CECECE, 0x70C6C6C6, 0x298F8F8F, 0x0D808080, 0x3D6C6C6C, 0x713D3D3D, 0x5D606060, 0x378F8F8F, 0x71D2D2D2, 0x6DD2D2D2, 0x27838383, 0x6A393939, 0x7E1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x10808080, 0x3D6C6C6C, 0x713D3D3D, 0x59606060, 0x137C7C7C, 0x01808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7EE2E2E2, 0x6BC6C6C6, 0x22808080, 0x603D3D3D, 0x6F515151, 0x79B2B2B2, 0x609F9F9F, 0x1A838383, 0x376C6C6C, 0x742D2D2D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x75D2D2D2, 0x75D2D2D2, 0x3F939393, 0x09808080, 0x08808080, 0x3B6C6C6C, 0x752D2D2D, 0x7C1D1D1D, 0x693D3D3D, 0x418F8F8F, 0x72D5D5D5, 0x7BD5D5D5, 0x639F9F9F, 0x34737373, 0x6E393939, 0x7E1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x73CECECE, 0x37939393, 0x0E808080, 0x366C6C6C, 0x73313131, 0x6A393939, 0x27838383, 0x6DD2D2D2, 0x6CD2D2D2, 0x24808080, 0x6C2D2D2D, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x73313131, 0x6E393939, 0x29707070, 0x05808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x75D2D2D2, 0x7BD5D5D5, 0x5F9F9F9F, 0x15808080, 0x22707070, 0x28838383, 0x6FCBCBCB, 0x6FC6C6C6, 0x2C8F8F8F, 0x2D707070, 0x6E393939, 0x73313131, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x74D2D2D2, 0x39939393, 0x09808080, 0x137C7C7C, 0x59606060, 0x7A2A2A2A, 0x722A2A2A, 0x41707070, 0x69C2C2C2, 0x7CE2E2E2, 0x75D2D2D2, 0x44939393, 0x3D6C6C6C, 0x732D2D2D, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x72C2C2C2, 0x3F939393, 0x0E808080, 0x29707070, 0x6E393939, 0x6C313131, 0x26808080, 0x6CD2D2D2, 0x6CD2D2D2, 0x26808080, 0x6C2D2D2D, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x75D2D2D2, 0x3F939393, 0x0A808080, 0x07808080, 0x238F8F8F, 0x65C2C2C2, 0x65C2C2C2, 0x268F8F8F, 0x177C7C7C, 0x59606060, 0x713D3D3D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x74D2D2D2, 0x37939393, 0x0C808080, 0x29707070, 0x6E393939, 0x7E1D1D1D, 0x6D2D2D2D, 0x28808080, 0x6DD2D2D2, 0x7EE2E2E2, 0x70C6C6C6, 0x308F8F8F, 0x3D6C6C6C, 0x742D2D2D, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x72C2C2C2, 0x609F9F9F, 0x14838383, 0x137C7C7C, 0x59606060, 0x6D414141, 0x3A8B8B8B, 0x71D5D5D5, 0x71CECECE, 0x3B747474, 0x712A2A2A, 0x752D2D2D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x74D2D2D2, 0x37939393, 0x08808080, 0x01808080, 0x0A838383, 0x258F8F8F, 0x258F8F8F, 0x0A838383, 0x0A808080, 0x3D6C6C6C, 0x713D3D3D, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7EE2E2E2, 0x70C6C6C6, 0x298F8F8F, 0x0D808080, 0x3B6C6C6C, 0x752D2D2D, 0x7E1D1D1D, 0x6A393939, 0x27838383, 0x6DD2D2D2, 0x7BD5D5D5, 0x609F9F9F, 0x1A838383, 0x396C6C6C, 0x742D2D2D, 0x752D2D2D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x73CECECE, 0x70C6C6C6, 0x298F8F8F, 0x0D808080, 0x3D6C6C6C, 0x704D4D4D, 0x69A6A6A6, 0x7ADEDEDE, 0x7CC2C2C2, 0x734D4D4D, 0x7C1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7EE2E2E2, 0x70C6C6C6, 0x2A8F8F8F, 0x09808080, 0x07808080, 0x08808080, 0x09808080, 0x05808080, 0x01808080, 0x07808080, 0x366C6C6C, 0x73313131, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x7BD5D5D5, 0x609F9F9F, 0x14838383, 0x137C7C7C, 0x59606060, 0x7A2A2A2A, 0x7A2A2A2A, 0x5D606060, 0x378F8F8F, 0x71D2D2D2, 0x75D2D2D2, 0x3F939393, 0x11808080, 0x3B6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x73CECECE, 0x37939393, 0x0F808080, 0x386C6C6C, 0x67444444, 0x3A8B8B8B, 0x6FD2D2D2, 0x74B2B2B2, 0x7C3D3D3D, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x10808080, 0x3D6C6C6C, 0x752D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x7BD5D5D5, 0x609F9F9F, 0x1C808080, 0x28707070, 0x366C6C6C, 0x366C6C6C, 0x28707070, 0x0A7C7C7C, 0x01808080, 0x05808080, 0x29707070, 0x6E393939, 0x73313131, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x75D2D2D2, 0x3F939393, 0x0E808080, 0x29707070, 0x6E393939, 0x7E1D1D1D, 0x752D2D2D, 0x426C6C6C, 0x3F939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x157E7E7E, 0x4C666666, 0x782B2B2B, 0x742D2D2D, 0x376C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x72C2C2C2, 0x3F939393, 0x10808080, 0x386C6C6C, 0x62414141, 0x26808080, 0x5FC2C2C2, 0x3A8B8B8B, 0x71313131, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x3A939393, 0x1A7C7C7C, 0x59606060, 0x7A2A2A2A, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x75D2D2D2, 0x42939393, 0x35707070, 0x673D3D3D, 0x732D2D2D, 0x732D2D2D, 0x653D3D3D, 0x23707070, 0x07808080, 0x02808080, 0x137C7C7C, 0x59606060, 0x713D3D3D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x366C6C6C, 0x742D2D2D, 0x7E1D1D1D, 0x6E393939, 0x32707070, 0x43939393, 0x75D2D2D2, 0x74D2D2D2, 0x3B939393, 0x24767676, 0x694D4D4D, 0x7D262626, 0x71333333, 0x2E6E6E6E, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x72C2C2C2, 0x609F9F9F, 0x1A838383, 0x376C6C6C, 0x62414141, 0x24808080, 0x5BBEBEBE, 0x28808080, 0x6D2D2D2D, 0x752D2D2D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x75D2D2D2, 0x74D2D2D2, 0x3D939393, 0x31707070, 0x6E393939, 0x7E1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x71D2D2D2, 0x378F8F8F, 0x5B606060, 0x7A2A2A2A, 0x7E1D1D1D, 0x7A2A2A2A, 0x62414141, 0x26808080, 0x238F8F8F, 0x0A838383, 0x0A808080, 0x3D6C6C6C, 0x713D3D3D, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x09808080, 0x3C939393, 0x75D2D2D2, 0x74D2D2D2, 0x39939393, 0x10808080, 0x3B6C6C6C, 0x742D2D2D, 0x7A2A2A2A, 0x5A606060, 0x24808080, 0x609F9F9F, 0x7BD5D5D5, 0x74D2D2D2, 0x3F939393, 0x366E6E6E, 0x70373737, 0x76343434, 0x63565656, 0x1A787878, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74CECECE, 0x70C6C6C6, 0x2E8F8F8F, 0x2C707070, 0x554D4D4D, 0x25838383, 0x60BBBBBB, 0x3B747474, 0x712A2A2A, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x74D2D2D2, 0x40939393, 0x3D6C6C6C, 0x742D2D2D, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x75D2D2D2, 0x6DD2D2D2, 0x27838383, 0x6A393939, 0x7E1D1D1D, 0x7B2A2A2A, 0x5E5C5C5C, 0x2B7C7C7C, 0x60B2B2B2, 0x65BEBEBE, 0x288F8F8F, 0x0C808080, 0x386C6C6C, 0x73313131, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x0E818181, 0x51999999, 0x78D4D4D4, 0x74D2D2D2, 0x39939393, 0x157E7E7E, 0x4C666666, 0x782B2B2B, 0x752D2D2D, 0x426C6C6C, 0x318F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x73D2D2D2, 0x3D939393, 0x416C6C6C, 0x6C3D3D3D, 0x4E686868, 0x45959595, 0x12858585, 0x0E7A7A7A, 0x047E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x74D2D2D2, 0x38939393, 0x117C7C7C, 0x1C747474, 0x2C8F8F8F, 0x6EAEAEAE, 0x734D4D4D, 0x7C1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x73D2D2D2, 0x3E939393, 0x436C6C6C, 0x752D2D2D, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x01808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x6CD2D2D2, 0x24808080, 0x6C2D2D2D, 0x7E1D1D1D, 0x6F393939, 0x2F707070, 0x16838383, 0x5F9F9F9F, 0x72C2C2C2, 0x3D939393, 0x10808080, 0x366C6C6C, 0x742D2D2D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x02808080, 0x1C898989, 0x6BB3B3B3, 0x7DDCDCDC, 0x74D2D2D2, 0x3A939393, 0x24767676, 0x694D4D4D, 0x7D242424, 0x732D2D2D, 0x3D6C6C6C, 0x44939393, 0x75D2D2D2, 0x7EE2E2E2, 0x6FC6C6C6, 0x328C8C8C, 0x54646464, 0x65494949, 0x2D818181, 0x59B4B4B4, 0x2D7B7B7B, 0x4C5C5C5C, 0x1A767676, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x74CECECE, 0x39939393, 0x09808080, 0x06808080, 0x248F8F8F, 0x5F9F9F9F, 0x7A3D3D3D, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3D939393, 0x75D2D2D2, 0x7EE2E2E2, 0x6FC6C6C6, 0x338C8C8C, 0x5C606060, 0x7A2A2A2A, 0x752D2D2D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x6DD2D2D2, 0x28808080, 0x6D2D2D2D, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x0A808080, 0x3F939393, 0x72C2C2C2, 0x609F9F9F, 0x18838383, 0x2A707070, 0x6E393939, 0x73313131, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x06808080, 0x30919191, 0x73CCCCCC, 0x7EE1E1E1, 0x72CCCCCC, 0x35919191, 0x376E6E6E, 0x72333333, 0x7E1E1E1E, 0x70333333, 0x35727272, 0x639F9F9F, 0x7BD5D5D5, 0x7BD5D5D5, 0x629F9F9F, 0x32737373, 0x66494949, 0x53646464, 0x3A8F8F8F, 0x6FAEAEAE, 0x714F4F4F, 0x6E373737, 0x2F6E6E6E, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x72C2C2C2, 0x3F939393, 0x09808080, 0x01808080, 0x09838383, 0x2E787878, 0x72313131, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x7BD5D5D5, 0x639F9F9F, 0x34737373, 0x6E393939, 0x7E1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7CE2E2E2, 0x69C2C2C2, 0x41707070, 0x722A2A2A, 0x752D2D2D, 0x3D6C6C6C, 0x08808080, 0x08808080, 0x39939393, 0x74CECECE, 0x70C6C6C6, 0x2A8F8F8F, 0x177C7C7C, 0x59606060, 0x713D3D3D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x08808080, 0x38939393, 0x74D2D2D2, 0x7DDBDBDB, 0x6BB2B2B2, 0x26878787, 0x4D666666, 0x772B2B2B, 0x7D232323, 0x694C4C4C, 0x2C858585, 0x6DC6C6C6, 0x7EE2E2E2, 0x74D2D2D2, 0x40939393, 0x30707070, 0x5A4D4D4D, 0x35737373, 0x569B9B9B, 0x6BA2A2A2, 0x7B3D3D3D, 0x742D2D2D, 0x376C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x72C2C2C2, 0x609F9F9F, 0x13838383, 0x01808080, 0x127C7C7C, 0x55606060, 0x7A2A2A2A, 0x752D2D2D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3D6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x06808080, 0x2F8F8F8F, 0x71C6C6C6, 0x7EE2E2E2, 0x74D2D2D2, 0x43939393, 0x426C6C6C, 0x742D2D2D, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x75D2D2D2, 0x72D5D5D5, 0x418F8F8F, 0x693D3D3D, 0x7C1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x37939393, 0x10808080, 0x3D6C6C6C, 0x713D3D3D, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080,
0x00808080, 0x09808080, 0x3C939393, 0x75D2D2D2, 0x78D4D4D4, 0x53999999, 0x27787878, 0x694D4D4D, 0x7D242424, 0x772B2B2B, 0x51666666, 0x3A919191, 0x72D2D2D2, 0x7EE2E2E2, 0x6EC6C6C6, 0x2A8C8C8C, 0x2B707070, 0x2B707070, 0x298C8C8C, 0x60B2B2B2, 0x3D7C7C7C, 0x712D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74CECECE, 0x70C6C6C6, 0x298F8F8F, 0x09808080, 0x29707070, 0x6E393939, 0x7E1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x3D939393, 0x31707070, 0x6E393939, 0x73313131, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x02808080, 0x19838383, 0x5F9F9F9F, 0x7BD5D5D5, 0x7EE2E2E2, 0x6FC6C6C6, 0x338C8C8C, 0x5C606060, 0x7A2A2A2A, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x6DD2D2D2, 0x28808080, 0x6D2D2D2D, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x08808080, 0x38939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x376C6C6C, 0x73313131, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080,
0x00808080, 0x0E818181, 0x51999999, 0x78D4D4D4, 0x75D2D2D2, 0x42939393, 0x366E6E6E, 0x72333333, 0x7E1E1E1E, 0x72333333, 0x396E6E6E, 0x41939393, 0x74D2D2D2, 0x7BD5D5D5, 0x609F9F9F, 0x25777777, 0x46595959, 0x1F747474, 0x298F8F8F, 0x63A2A2A2, 0x6F494949, 0x7B1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x37939393, 0x0E808080, 0x366C6C6C, 0x742D2D2D, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x3A939393, 0x1A7C7C7C, 0x59606060, 0x713D3D3D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x01808080, 0x10838383, 0x529B9B9B, 0x77C9C9C9, 0x7EE2E2E2, 0x7AD5D5D5, 0x619F9F9F, 0x39737373, 0x6F393939, 0x7E1D1D1D, 0x752D2D2D, 0x3B6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x6DD2D2D2, 0x28808080, 0x6D2D2D2D, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x01808080, 0x06808080, 0x30919191, 0x73CCCCCC, 0x74D0D0D0, 0x39939393, 0x0E808080, 0x2F6E6E6E, 0x72333333, 0x742F2F2F, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080,
0x02808080, 0x1C898989, 0x6BB3B3B3, 0x7DDCDCDC, 0x73D2D2D2, 0x3E939393, 0x436C6C6C, 0x752D2D2D, 0x7D232323, 0x6A4C4C4C, 0x27787878, 0x53999999, 0x78D4D4D4, 0x75D2D2D2, 0x3F939393, 0x107C7C7C, 0x18747474, 0x0D808080, 0x1F8C8C8C, 0x41707070, 0x752D2D2D, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x75D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x10808080, 0x3B6C6C6C, 0x703D3D3D, 0x59606060, 0x137C7C7C, 0x02808080, 0x0A808080, 0x318F8F8F, 0x6FC6C6C6, 0x7DE2E2E2, 0x7DE2E2E2, 0x6EC6C6C6, 0x398C8C8C, 0x5A606060, 0x7A2A2A2A, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7DE2E2E2, 0x6BC2C2C2, 0x41707070, 0x722A2A2A, 0x752D2D2D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x02808080, 0x1C898989, 0x6BB3B3B3, 0x74C8C8C8, 0x3C939393, 0x0B808080, 0x1D767676, 0x694D4D4D, 0x74373737, 0x3B6C6C6C, 0x08808080, 0x00808080, 0x00808080,
0x06808080, 0x30919191, 0x73CCCCCC, 0x7EE1E1E1, 0x70CCCCCC, 0x348D8D8D, 0x5C606060, 0x7A2A2A2A, 0x782B2B2B, 0x4E666666, 0x26878787, 0x6BB3B3B3, 0x7DDCDCDC, 0x74D2D2D2, 0x38939393, 0x08808080, 0x04808080, 0x138B8B8B, 0x3E969696, 0x6C454545, 0x7C1D1D1D, 0x7A2A2A2A, 0x57606060, 0x127C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x752D2D2D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x05808080, 0x08808080, 0x1C838383, 0x619F9F9F, 0x7BD5D5D5, 0x74D2D2D2, 0x40939393, 0x3D6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x01808080, 0x05808080, 0x0F808080, 0x41939393, 0x75D2D2D2, 0x74D2D2D2, 0x39939393, 0x0D808080, 0x29707070, 0x6C3D3D3D, 0x6C3D3D3D, 0x26707070, 0x16838383, 0x318F8F8F, 0x68A3A3A3, 0x7CD5D5D5, 0x7EE2E2E2, 0x77C9C9C9, 0x559B9B9B, 0x37737373, 0x6F393939, 0x7E1D1D1D, 0x7A2A2A2A, 0x57606060, 0x127C7C7C, 0x01808080, 0x01808080, 0x05808080, 0x0F808080, 0x41939393, 0x75D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x366C6C6C, 0x742D2D2D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x02808080, 0x0E808080, 0x41939393, 0x75D2D2D2, 0x75D5D5D5, 0x4D939393, 0x68494949, 0x7B212121, 0x732D2D2D, 0x356C6C6C, 0x07808080, 0x01808080, 0x05808080, 0x15818181, 0x59999999, 0x75C2C2C2, 0x51999999, 0x0E818181, 0x0D7E7E7E, 0x4B666666, 0x713D3D3D, 0x4B666666, 0x0C7E7E7E, 0x00808080, 0x00808080,
0x08808080, 0x38939393, 0x74D2D2D2, 0x7DDBDBDB, 0x6BB2B2B2, 0x2D797979, 0x6C393939, 0x7E1D1D1D, 0x742D2D2D, 0x3E6C6C6C, 0x37919191, 0x72CCCCCC, 0x7EE1E1E1, 0x73CCCCCC, 0x30919191, 0x06808080, 0x01808080, 0x0E808080, 0x426C6C6C, 0x762D2D2D, 0x7E1D1D1D, 0x6F393939, 0x2E707070, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x74CECECE, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x0A838383, 0x288F8F8F, 0x3D939393, 0x619F9F9F, 0x79C9C9C9, 0x7EE2E2E2, 0x74D2D2D2, 0x3B939393, 0x2F707070, 0x663D3D3D, 0x663D3D3D, 0x28707070, 0x05808080, 0x01808080, 0x0A838383, 0x288F8F8F, 0x3F939393, 0x6CA3A3A3, 0x7DD5D5D5, 0x74D2D2D2, 0x39939393, 0x09808080, 0x107C7C7C, 0x4A646464, 0x5C4D4D4D, 0x2E808080, 0x5B9F9F9F, 0x71C6C6C6, 0x7CD5D5D5, 0x7EE2E2E2, 0x7AD5D5D5, 0x609F9F9F, 0x2E808080, 0x59606060, 0x7A2A2A2A, 0x7E1D1D1D, 0x6F393939, 0x2E707070, 0x06808080, 0x01808080, 0x0A838383, 0x288F8F8F, 0x3F939393, 0x6CA3A3A3, 0x7DD5D5D5, 0x74D2D2D2, 0x39939393, 0x0D808080, 0x28707070, 0x663D3D3D, 0x663D3D3D, 0x28707070, 0x05808080, 0x05818181, 0x1B898989, 0x38919191, 0x6BA3A3A3, 0x7DD5D5D5, 0x72D2D2D2, 0x3A8F8F8F, 0x4F646464, 0x6A3D3D3D, 0x68494949, 0x23737373, 0x05808080, 0x0A838383, 0x288F8F8F, 0x3F939393, 0x6FA3A3A3, 0x7CCBCBCB, 0x6BB2B2B2, 0x1C898989, 0x08808080, 0x2A707070, 0x63474747, 0x535C5C5C, 0x10797979, 0x01808080, 0x00808080,
0x08808080, 0x39939393, 0x74D2D2D2, 0x78D4D4D4, 0x56999999, 0x3A6E6E6E, 0x722D2D2D, 0x7E1D1D1D, 0x6E393939, 0x31707070, 0x3C939393, 0x74D2D2D2, 0x7DDBDBDB, 0x6BB2B2B2, 0x1C898989, 0x02808080, 0x06808080, 0x2D707070, 0x6A393939, 0x7D1D1D1D, 0x7A2A2A2A, 0x57606060, 0x127C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x72C2C2C2, 0x3F939393, 0x11808080, 0x3B6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x288F8F8F, 0x66C2C2C2, 0x75D2D2D2, 0x7BD5D5D5, 0x7EE2E2E2, 0x7DE2E2E2, 0x6EC6C6C6, 0x298F8F8F, 0x0F7C7C7C, 0x25707070, 0x26707070, 0x0F7C7C7C, 0x05808080, 0x06808080, 0x288F8F8F, 0x66C2C2C2, 0x75D2D2D2, 0x7CD5D5D5, 0x7EE2E2E2, 0x74D2D2D2, 0x37939393, 0x08808080, 0x02808080, 0x0C7C7C7C, 0x1D808080, 0x5FB2B2B2, 0x7AD2D2D2, 0x7EE2E2E2, 0x7EE2E2E2, 0x7BD5D5D5, 0x68C2C2C2, 0x358C8C8C, 0x50646464, 0x75363636, 0x7E1D1D1D, 0x7A2A2A2A, 0x57606060, 0x127C7C7C, 0x01808080, 0x05808080, 0x288F8F8F, 0x66C2C2C2, 0x75D2D2D2, 0x7CD5D5D5, 0x7EE2E2E2, 0x74D2D2D2, 0x37939393, 0x08808080, 0x0A7C7C7C, 0x25707070, 0x26707070, 0x0F7C7C7C, 0x07808080, 0x1A898989, 0x62AFAFAF, 0x74CCCCCC, 0x7CD5D5D5, 0x7EE2E2E2, 0x73D2D2D2, 0x37939393, 0x137C7C7C, 0x1A7C7C7C, 0x37969696, 0x14888888, 0x0A808080, 0x268F8F8F, 0x66C2C2C2, 0x75D2D2D2, 0x7CD5D5D5, 0x7EE0E0E0, 0x72CCCCCC, 0x2E919191, 0x07808080, 0x0A7C7C7C, 0x1F727272, 0x19767676, 0x087E7E7E, 0x04808080, 0x01808080,
0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x42939393, 0x436C6C6C, 0x752D2D2D, 0x7A2A2A2A, 0x59606060, 0x1A7C7C7C, 0x3A939393, 0x74D2D2D2, 0x78D4D4D4, 0x51999999, 0x0E818181, 0x02808080, 0x187C7C7C, 0x58606060, 0x7A2A2A2A, 0x7E1D1D1D, 0x6F393939, 0x2E707070, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x72C2C2C2, 0x5F9F9F9F, 0x1B818181, 0x4C666666, 0x782B2B2B, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7EE2E2E2, 0x7CD5D5D5, 0x75D2D2D2, 0x6EC6C6C6, 0x509B9B9B, 0x10838383, 0x02808080, 0x05808080, 0x0F7C7C7C, 0x26707070, 0x25707070, 0x127C7C7C, 0x38939393, 0x74D2D2D2, 0x7EE2E2E2, 0x7CD5D5D5, 0x75D2D2D2, 0x66C2C2C2, 0x288F8F8F, 0x05808080, 0x00808080, 0x00808080, 0x0D838383, 0x4F9B9B9B, 0x6EC6C6C6, 0x73D2D2D2, 0x6FC6C6C6, 0x619F9F9F, 0x388F8F8F, 0x32737373, 0x6E393939, 0x7D1D1D1D, 0x7D1D1D1D, 0x6E393939, 0x2E707070, 0x06808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7EE2E2E2, 0x7CD5D5D5, 0x75D2D2D2, 0x66C2C2C2, 0x288F8F8F, 0x05808080, 0x01808080, 0x05808080, 0x0F7C7C7C, 0x26707070, 0x28707070, 0x278D8D8D, 0x6FCCCCCC, 0x7EE1E1E1, 0x7DDBDBDB, 0x78D4D4D4, 0x67C2C2C2, 0x288F8F8F, 0x05808080, 0x04838383, 0x15888888, 0x21747474, 0x28707070, 0x2E8F8F8F, 0x70D2D2D2, 0x7EE2E2E2, 0x7CD5D5D5, 0x75D2D2D2, 0x66C2C2C2, 0x278F8F8F, 0x05808080, 0x01808080, 0x04808080, 0x0C7C7C7C, 0x26707070, 0x25707070, 0x0C7C7C7C,
0x08808080, 0x37939393, 0x74D2D2D2, 0x71D2D2D2, 0x388F8F8F, 0x5D606060, 0x7A2A2A2A, 0x752D2D2D, 0x3D6C6C6C, 0x10808080, 0x37939393, 0x74D2D2D2, 0x74D2D2D2, 0x3B939393, 0x0E808080, 0x187C7C7C, 0x4E646464, 0x75363636, 0x7E1D1D1D, 0x7A2A2A2A, 0x57606060, 0x127C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x73CECECE, 0x6CC6C6C6, 0x25868686, 0x674D4D4D, 0x7D242424, 0x742D2D2D, 0x376C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7BD5D5D5, 0x67A3A3A3, 0x44939393, 0x308F8F8F, 0x18838383, 0x09808080, 0x07808080, 0x0C808080, 0x2F707070, 0x673D3D3D, 0x663D3D3D, 0x2F707070, 0x3B939393, 0x74D2D2D2, 0x7BD5D5D5, 0x67A3A3A3, 0x44939393, 0x2F8F8F8F, 0x12838383, 0x08808080, 0x07808080, 0x07808080, 0x09808080, 0x18838383, 0x308F8F8F, 0x3C939393, 0x338C8C8C, 0x34737373, 0x416C6C6C, 0x645C5C5C, 0x7B2A2A2A, 0x7E1D1D1D, 0x75363636, 0x4C646464, 0x107C7C7C, 0x01808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7BD5D5D5, 0x67A3A3A3, 0x44939393, 0x2F8F8F8F, 0x12838383, 0x08808080, 0x07808080, 0x0C808080, 0x2F707070, 0x673D3D3D, 0x623D3D3D, 0x25838383, 0x6DD2D2D2, 0x7CDBDBDB, 0x6CB6B6B6, 0x54999999, 0x338F8F8F, 0x12838383, 0x08808080, 0x0C808080, 0x2F707070, 0x663D3D3D, 0x613D3D3D, 0x26838383, 0x6DD2D2D2, 0x7BD5D5D5, 0x67A3A3A3, 0x44939393, 0x2F8F8F8F, 0x12838383, 0x08808080, 0x07808080, 0x0C808080, 0x2F707070, 0x673D3D3D, 0x663D3D3D, 0x2C707070,
0x05808080, 0x298F8F8F, 0x6EC6C6C6, 0x70CACACA, 0x39777777, 0x6E363636, 0x7E1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x0B808080, 0x298F8F8F, 0x6EC6C6C6, 0x71CECECE, 0x328F8F8F, 0x30707070, 0x59606060, 0x75363636, 0x7D1D1D1D, 0x7D1D1D1D, 0x6E393939, 0x2E707070, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x6EC6C6C6, 0x6CCECECE, 0x28818181, 0x6D333333, 0x7E1E1E1E, 0x72333333, 0x2F6E6E6E, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x288F8F8F, 0x65C2C2C2, 0x63BEBEBE, 0x31808080, 0x3B6C6C6C, 0x3C6C6C6C, 0x396C6C6C, 0x386C6C6C, 0x386C6C6C, 0x3E6C6C6C, 0x645C5C5C, 0x7B2A2A2A, 0x742D2D2D, 0x3B6C6C6C, 0x2E8F8F8F, 0x65C2C2C2, 0x63BEBEBE, 0x31808080, 0x3B6C6C6C, 0x3C6C6C6C, 0x396C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x396C6C6C, 0x3C6C6C6C, 0x436C6C6C, 0x5C606060, 0x6E393939, 0x742D2D2D, 0x7B2A2A2A, 0x7E1D1D1D, 0x7A2A2A2A, 0x58606060, 0x187C7C7C, 0x02808080, 0x00808080, 0x00808080, 0x05808080, 0x288F8F8F, 0x65C2C2C2, 0x63BEBEBE, 0x31808080, 0x3B6C6C6C, 0x3C6C6C6C, 0x396C6C6C, 0x386C6C6C, 0x386C6C6C, 0x3E6C6C6C, 0x645C5C5C, 0x7B2A2A2A, 0x6D2D2D2D, 0x267C7C7C, 0x61C2C2C2, 0x63C0C0C0, 0x34858585, 0x3A6E6E6E, 0x3C6C6C6C, 0x396C6C6C, 0x386C6C6C, 0x3E6C6C6C, 0x645C5C5C, 0x7B2A2A2A, 0x6D2D2D2D, 0x267C7C7C, 0x61C2C2C2, 0x63BEBEBE, 0x31808080, 0x3B6C6C6C, 0x3C6C6C6C, 0x396C6C6C, 0x386C6C6C, 0x386C6C6C, 0x3E6C6C6C, 0x645C5C5C, 0x7B2A2A2A, 0x742D2D2D, 0x3D6C6C6C,
0x01808080, 0x10838383, 0x4F9B9B9B, 0x6AA6A6A6, 0x70494949, 0x7C1D1D1D, 0x7D1D1D1D, 0x6D393939, 0x29707070, 0x05808080, 0x10838383, 0x4F9B9B9B, 0x60B2B2B2, 0x3A747474, 0x68393939, 0x7A2A2A2A, 0x7E1D1D1D, 0x7D1D1D1D, 0x74363636, 0x4C646464, 0x107C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x10838383, 0x4F9B9B9B, 0x61B2B2B2, 0x40707070, 0x722A2A2A, 0x7D232323, 0x694C4C4C, 0x1D767676, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x0A838383, 0x238F8F8F, 0x26808080, 0x61414141, 0x732D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x752D2D2D, 0x7B2A2A2A, 0x7E1D1D1D, 0x742D2D2D, 0x376C6C6C, 0x11838383, 0x238F8F8F, 0x26808080, 0x61414141, 0x732D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x752D2D2D, 0x7A2A2A2A, 0x7E1D1D1D, 0x7E1D1D1D, 0x7A2A2A2A, 0x742D2D2D, 0x673D3D3D, 0x2D707070, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x0A838383, 0x238F8F8F, 0x26808080, 0x61414141, 0x732D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x752D2D2D, 0x7B2A2A2A, 0x7E1D1D1D, 0x702D2D2D, 0x2E707070, 0x268F8F8F, 0x26808080, 0x61414141, 0x722D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x752D2D2D, 0x7B2A2A2A, 0x7E1D1D1D, 0x702D2D2D, 0x2E707070, 0x268F8F8F, 0x26808080, 0x61414141, 0x732D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x752D2D2D, 0x7B2A2A2A, 0x7E1D1D1D, 0x742D2D2D, 0x3D6C6C6C,
0x00808080, 0x02808080, 0x0D838383, 0x217C7C7C, 0x6B3D3D3D, 0x7C212121, 0x74363636, 0x4C646464, 0x107C7C7C, 0x01808080, 0x02808080, 0x0D838383, 0x1E808080, 0x60494949, 0x7B212121, 0x7E1D1D1D, 0x7A2A2A2A, 0x6E393939, 0x4C646464, 0x157C7C7C, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x0D838383, 0x1E808080, 0x62494949, 0x7B212121, 0x772B2B2B, 0x4B666666, 0x0D7E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x07808080, 0x23707070, 0x653D3D3D, 0x732D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x732D2D2D, 0x663D3D3D, 0x28707070, 0x05808080, 0x07808080, 0x23707070, 0x653D3D3D, 0x732D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x732D2D2D, 0x6F393939, 0x59606060, 0x3B6C6C6C, 0x28707070, 0x0A7C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x07808080, 0x23707070, 0x653D3D3D, 0x732D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x732D2D2D, 0x663D3D3D, 0x26707070, 0x0C808080, 0x23707070, 0x653D3D3D, 0x732D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x732D2D2D, 0x663D3D3D, 0x26707070, 0x0C808080, 0x23707070, 0x653D3D3D, 0x732D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x732D2D2D, 0x663D3D3D, 0x2C707070,
0x00808080, 0x00808080, 0x00808080, 0x0D7C7C7C, 0x4A646464, 0x66454545, 0x4C646464, 0x157C7C7C, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x0D7C7C7C, 0x4A646464, 0x6D393939, 0x6E393939, 0x58606060, 0x2E707070, 0x107C7C7C, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0D7C7C7C, 0x4A646464, 0x6D393939, 0x663D3D3D, 0x2A707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x0A7C7C7C, 0x28707070, 0x366C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x366C6C6C, 0x28707070, 0x0A7C7C7C, 0x01808080, 0x01808080, 0x0A7C7C7C, 0x28707070, 0x366C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x366C6C6C, 0x29707070, 0x127C7C7C, 0x08808080, 0x05808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x0A7C7C7C, 0x28707070, 0x366C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x366C6C6C, 0x28707070, 0x0A7C7C7C, 0x02808080, 0x0A7C7C7C, 0x28707070, 0x366C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x366C6C6C, 0x28707070, 0x0A7C7C7C, 0x02808080, 0x0A7C7C7C, 0x28707070, 0x366C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x366C6C6C, 0x28707070, 0x0C7C7C7C,
0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x0E7C7C7C, 0x1B747474, 0x0E7C7C7C, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x107C7C7C, 0x27707070, 0x27707070, 0x127C7C7C, 0x06808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x107C7C7C, 0x27707070, 0x25707070, 0x0A7C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x05808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x05808080, 0x01808080, 0x00808080, 0x00808080, 0x01808080, 0x05808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x05808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x05808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x05808080, 0x01808080, 0x00808080, 0x01808080, 0x05808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x05808080, 0x01808080, 0x00808080, 0x01808080, 0x05808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x05808080, 0x01808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x02808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x04808080, 0x04808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x04808080, 0x04808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
};

//---------------------------------------------------------------------------

//
// Load the NVIDIA logo image
//

void nvLoadLogo
(
    void
)
{
    // bail out if logo isn't enabled
    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_LOGOENABLE_MASK) == D3D_REG_LOGOENABLE_DISABLE) {
        return;
    }

    // abort if logo already allocated
    if (getDC()->pLogoTexture) {
        return;
    }

    // this should be all or nothing. unallocated texture -> everything else unallocated too.
    nvAssert (getDC()->pLogoObject == NULL);
    nvAssert (getDC()->pLogoVertexBuffer == NULL);
    nvAssert (getDC()->pLogoVertexShader == NULL);

    getDC()->pLogoTexture = new CTexture;
    if (!getDC()->pLogoTexture) {
        DPF("Unable to create logo texture");
        nvAssert(0);
        return;
    }

    getDC()->pLogoObject = new CNvObject(0);
    if (!getDC()->pLogoObject) {
        DPF("Unable to create logo object");
        delete getDC()->pLogoTexture;
        getDC()->pLogoTexture = NULL;
        return;
    }
#ifdef WINNT
    getDC()->pLogoObject->setDDSLcl(NULL);
#endif

    getDC()->pLogoObject->setObject(CNvObject::NVOBJ_TEXTURE, getDC()->pLogoTexture);

    BOOL bRes = getDC()->pLogoTexture->create (getDC()->pLogoObject, WIDTH, HEIGHT, 1, 4, 4, 1, NV_SURFACE_FORMAT_A8R8G8B8,
                                               CSimpleSurface::HEAP_VID, CSimpleSurface::HEAP_VID);

    if (bRes) {
        getDC()->pLogoTexture->updateLinearSurface();
        nvMemCopy ((void*)getDC()->pLogoTexture->getLinear()->getAddress(), &dwLogoImage, PITCH * HEIGHT);
        getDC()->pLogoTexture->getLinear()->tagUpToDate();
        getDC()->pLogoTexture->getSwizzled()->tagOutOfDate();
    }
    else {
        // allocation failed
        DPF("Couldn't allocate video memory for logo texture\n");
        nvFreeLogo();
        nvAssert(0);
        return;
    }

    getDC()->pLogoVertexBuffer = new CVertexBuffer;
    if (!getDC()->pLogoVertexBuffer) {
        DPF("Unable to create logo vertex buffer");
        nvAssert(0);
        nvFreeLogo();
        return;
    }

    getDC()->pLogoVertexShader = new CVertexShader;
    if (!getDC()->pLogoVertexShader) {
        DPF("Unable to create logo vertex shader");
        nvAssert(0);
        nvFreeLogo();
        return;
    }
}

//---------------------------------------------------------------------------

//
// Free NVIDIA logo texture
//

void nvFreeLogo
(
    void
)
{
    // release to logo object if this is the last context
    if (getDC()->pLogoObject) {
        getDC()->pLogoObject->release();
        getDC()->pLogoObject  = NULL;
        getDC()->pLogoTexture = NULL;
    }

    if (getDC()->pLogoVertexBuffer) {
        delete getDC()->pLogoVertexBuffer;
        getDC()->pLogoVertexBuffer = NULL;
    }

    if (getDC()->pLogoVertexShader) {
        delete getDC()->pLogoVertexShader;
        getDC()->pLogoVertexShader = NULL;
    }
}

//---------------------------------------------------------------------------

//
// Draw the NVIDIA logo
//

typedef struct _dwStateSet
{
    DWORD dwState;
    DWORD dwValue;
} STATESETDATA;

#define NUM_STATES 14

STATESETDATA dwStateSet[NUM_STATES] =
{
    { D3DRENDERSTATE_CULLMODE,         D3DCULL_NONE             },
    { D3DRENDERSTATE_ZFUNC,            D3DCMP_ALWAYS            },
    { D3DRENDERSTATE_ALPHAFUNC,        D3DCMP_ALWAYS            },
    { D3DRENDERSTATE_ALPHABLENDENABLE, TRUE                     },
    { D3DRENDERSTATE_SRCBLEND,         D3DBLEND_SRCALPHA        },
    { D3DRENDERSTATE_DESTBLEND,        D3DBLEND_INVSRCALPHA     },
    { D3DRENDERSTATE_WRAP0,            0                        },
    { D3DRENDERSTATE_STENCILENABLE,    FALSE                    },
    { D3DRENDERSTATE_FILLMODE,         D3DFILL_SOLID            },
    { D3DRENDERSTATE_FOGENABLE,        FALSE                    },
    { D3DRENDERSTATE_WRAPU,            0                        },
    { D3DRENDERSTATE_WRAPV,            0                        },
    { D3DRENDERSTATE_TEXTUREMAPBLEND,  D3DPTBLENDCAPS_MODULATE  },
    { D3DRENDERSTATE_SPECULARENABLE,   FALSE                    }
};

void nvDrawLogo
(
    PNVD3DCONTEXT pContext,
    BOOL bClear // draw the logo if FALSE otherwise just clear the space behind the logo
)
{
    HRESULT rval;

    // check if the context is valid
    if (!pContext) return;

    // check if we have a valid render target
    if (!pContext->pRenderTarget) return;

    // is this a non-essential clear request
    if (bClear && !pContext->bClearLogo) return;

    // reject if the render target is a texture
    CNvObject *pNVObj = pContext->pRenderTarget->getWrapper();
    if (!pNVObj) return;
    if (pNVObj->getTexture()) return;

    // check if we have a logo shader
    if (!getDC()->pLogoVertexShader) return;

    DWORD wScrWidth   = pContext->pRenderTarget->getWidth();
    DWORD wScrHeight  = pContext->pRenderTarget->getHeight();
    DWORD wLogoWidth  = (int)min(wScrWidth, wScrHeight * ASPECT) / 8;
    DWORD wLogoHeight = (int)(wLogoWidth / ASPECT);

    // clamp minimum size
    if (wLogoWidth < MIN_SIZE)
    {
        wLogoWidth = MIN_SIZE;
        wLogoHeight = (int)(MIN_SIZE / ASPECT);
    }

    // reject if logo is too big for screen
    if ((wLogoWidth > wScrWidth) || (wLogoHeight > wScrHeight)) return;

    if (bClear)
    {
        DWORD dwData[16];
        LPD3DHAL_DP2COMMAND pCommand = (LPD3DHAL_DP2COMMAND)&dwData;

        // make sure we have enough space
        nvAssert((DWORD)((LPBYTE)pCommand + sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2CLEAR)) < (DWORD)dwData + sizeof(dwData));

        // create the Clear command
        pCommand->bCommand        = D3DDP2OP_CLEAR;
        pCommand->wPrimitiveCount = 1;
        LPD3DHAL_DP2CLEAR pClear  = (LPD3DHAL_DP2CLEAR)((LPBYTE)(pCommand) + sizeof(D3DHAL_DP2COMMAND));

        pClear->dwFlags         = D3DCLEAR_TARGET;
        pClear->dwFillColor     = pContext->dwLastFillColor;
        pClear->dvFillDepth     = 0;
        pClear->dwFillStencil   = 0;
        pClear->Rects[0].left   = (LONG)(wScrWidth - wLogoWidth);
        pClear->Rects[0].right  = (LONG)wScrWidth;
        pClear->Rects[0].top    = (LONG)(wScrHeight - wLogoHeight);
        pClear->Rects[0].bottom = (LONG)wScrHeight;

        ((*(pContext->pDP2FunctionTable))[D3DDP2OP_CLEAR]) (pContext, &pCommand, 0, 0, 0);

        return;
    }

    // set up state
    DWORD dwOldState[NUM_STATES];
    for (DWORD i = 0; i < NUM_STATES; i++)
    {
        dwOldState[i] = pContext->dwRenderState[dwStateSet[i].dwState];
        nvSetContextState(pContext, dwStateSet[i].dwState, dwStateSet[i].dwValue, &rval);
    }

    // set the logo texture
    NVD3DTEXSTAGESTATE tssPrevState[2];
    nvMemCopy (tssPrevState, pContext->tssState, sizeof(tssPrevState));
    memset (&pContext->tssState[0], 0, sizeof(tssPrevState));
    pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP    ] = (DWORD)getDC()->pLogoObject;
    pContext->tssState[0].dwValue[D3DTSS_COLOROP       ] = D3DTOP_SELECTARG1;
    pContext->tssState[0].dwValue[D3DTSS_COLORARG1     ] = D3DTA_TEXTURE;
    pContext->tssState[0].dwValue[D3DTSS_ALPHAOP       ] = D3DTOP_SELECTARG1;
    pContext->tssState[0].dwValue[D3DTSS_ALPHAARG1     ] = D3DTA_TEXTURE;
    pContext->tssState[0].dwValue[D3DTSS_ADDRESSU      ] = D3DTADDRESS_WRAP;
    pContext->tssState[0].dwValue[D3DTSS_ADDRESSV      ] = D3DTADDRESS_WRAP;
    pContext->tssState[0].dwValue[D3DTSS_MAGFILTER     ] = D3DTFG_LINEAR;
    pContext->tssState[0].dwValue[D3DTSS_MINFILTER     ] = D3DTFN_LINEAR;
    pContext->tssState[0].dwValue[D3DTSS_MIPFILTER     ] = D3DTFP_NONE;
    pContext->tssState[0].dwValue[D3DTSS_MAXANISOTROPY ] = 1;
    pContext->tssState[1].dwValue[D3DTSS_COLOROP       ] = D3DTOP_DISABLE;

    // make sure everything gets updated
#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= celsiusDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
    pContext->hwState.dwDirtyFlags |= kelvinDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF | KELVIN_DIRTY_FVF;
#endif
    NV_FORCE_TRI_SETUP(pContext);

    // set up the vertex buffer, one vertex for each corner of the logo
    D3DTLVERTEX pVB[4] =
    {
        {
            (float)(wScrWidth - wLogoWidth), (float)(wScrHeight - wLogoHeight), 1, 1, // x, y, z, rhw
            RGB(255, 255, 255), RGB(0, 0, 0),                                         // colour, specular
            0, 0                                                                      // u, v
        },
        {
            (float)wScrWidth, (float)(wScrHeight - wLogoHeight), 1, 1,
            RGB(255, 255, 255), RGB(0, 0, 0),
            1, 0
        },
        {
            (float)(wScrWidth - wLogoWidth), (float)wScrHeight, 1, 1,
            RGB(255, 255, 255), RGB(0, 0, 0),
            0, 1
        },
        {
            (float)wScrWidth, (float)wScrHeight, 1, 1,
            RGB(255, 255, 255), RGB(0, 0, 0),
            1, 1
        }
    };

    // create the command buffer
    DWORD dwData[16];
    void* pData = &dwData;
    LPD3DHAL_DP2COMMAND pCommands = (LPD3DHAL_DP2COMMAND)pData;

    // create the TriangleStrip command
    pCommands->bCommand        = D3DDP2OP_TRIANGLESTRIP;
    pCommands->wPrimitiveCount = 2;
    LPD3DHAL_DP2TRIANGLESTRIP pTriStrip = (LPD3DHAL_DP2TRIANGLESTRIP)((LPBYTE)(pCommands) + sizeof(D3DHAL_DP2COMMAND));
    pTriStrip->wVStart = 0;

    // move the command pointer along to the beginning of the next command
    pCommands = (LPD3DHAL_DP2COMMAND)((LPBYTE)pCommands + sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TRIANGLESTRIP));

    // make sure we had enough space
    nvAssert((DWORD)pCommands < (DWORD)dwData + sizeof(dwData));

    // set up the ddraw local & global
#ifdef WINNT
    DD_SURFACE_GLOBAL ddGbl;
    DD_SURFACE_LOCAL  ddLcl;
    ddLcl.lpGbl = &ddGbl;
    ddGbl.fpVidMem = (FLATPTR)pData; // pointer to command buffer
    ddLcl.dwReserved1 = NULL;
#else
    typedef struct {
        DDRAWI_DDRAWSURFACE_GBL_MORE ddGblMore;
        LPDWORD                      dwReserved1;
        DDRAWI_DDRAWSURFACE_GBL      ddGbl;
    } EXT_DDRAWI_DDRAWSURFACE_GBL;
    DDRAWI_DDRAWSURFACE_LCL     ddLcl;
    EXT_DDRAWI_DDRAWSURFACE_GBL eddGbl;
    eddGbl.ddGbl.fpVidMem = (FLATPTR)pData; // pointer to command buffer
    eddGbl.dwReserved1 = (LPDWORD)&eddGbl.ddGblMore;
    eddGbl.ddGblMore.dwDriverReserved = NULL;
    ddLcl.lpGbl = &eddGbl.ddGbl;
#endif

    // set up the DP2 command
    D3DHAL_DRAWPRIMITIVES2DATA dp2;
    dp2.dwhContext      = (ULONG_PTR)pContext;
    dp2.dwFlags         = D3DHALDP2_USERMEMVERTICES;
    dp2.dwVertexType    = D3DFVF_TLVERTEX;
    dp2.dwVertexSize    = sizeof(pVB[0]);
    dp2.lpDDCommands    = &ddLcl;
    dp2.dwCommandOffset = 0;
    dp2.dwCommandLength = (DWORD)pCommands - (DWORD)pData;
    dp2.lpVertices      = &pVB;
    dp2.dwVertexOffset  = 0;
    dp2.dwVertexLength  = 4;
    dp2.lpdwRStates     = NULL;

    // create a vertex buffer
    getDC()->pLogoVertexBuffer->own((DWORD)&pVB, dp2.dwVertexSize * 4, CSimpleSurface::HEAP_SYS);
    getDC()->pLogoVertexBuffer->setVertexStride(dp2.dwVertexSize);

    // create a vertex shader from the FVF format
    getDC()->pLogoVertexShader->create (pContext, dp2.dwVertexType, CVertexShader::getHandleFromFvf( dp2.dwVertexType ) );

    // save the current vertex buffer and vertex shader
    CVertexShader *pOldVertexShader = pContext->pCurrentVShader;
    CVertexBuffer *pOldVertexBuffer = pContext->ppDX8Streams[0];
    DWORD          dwStreamDMACount = pContext->dwStreamDMACount;
    DWORD          dwDxAppVersion   = pContext->dwDXAppVersion;

    // set the logo vertex buffer & shader
    pContext->pCurrentVShader  = getDC()->pLogoVertexShader;
    pContext->ppDX8Streams[0]  = getDC()->pLogoVertexBuffer;
    pContext->dwStreamDMACount = 0x00010000;
    pContext->dwDXAppVersion   = 0x800;

    // draw the logo
    nvDrawPrimitives2(&dp2);

    // restore original vertex buffer & shader
    pContext->pCurrentVShader  = pOldVertexShader;
    pContext->ppDX8Streams[0]  = pOldVertexBuffer;
    pContext->dwStreamDMACount = dwStreamDMACount;
    pContext->dwDXAppVersion   = dwDxAppVersion;

    // restore state
    for (i = 0; i < NUM_STATES; i++)
    {
        nvSetContextState(pContext, dwStateSet[i].dwState, dwOldState[i], &rval);
    }

    // restore texture stage state
    nvMemCopy(pContext->tssState, tssPrevState, sizeof(tssPrevState));

    // make sure everything gets updated
#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= celsiusDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
    pContext->hwState.dwDirtyFlags |= kelvinDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF | KELVIN_DIRTY_FVF;
#endif
    NV_FORCE_TRI_SETUP(pContext);
    
#if (NVARCH >= 0x020)
    if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)) {
        if (pContext->kelvinAA.IsEnabled()) {
            //fixes flickering text in sample apps with aa and logo on.
            getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
        }
    }
#endif 
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvPatch.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvPatch.cpp
//
// **************************************************************************
//
//  History:
//      Daniel Rohrer?             Jun00             DX8 development
//
// **************************************************************************

#include "nvprecomp.h"
#define PB_DUMP_SIZE 256
NV_PATCH_DRIVER_CALLBACKS CPatch::m_callbacks = {CPatch::alloc, CPatch::free, CPatch::memcpy, NULL};
#define DCR_CACHEDPB_OPT

//scratch space
static float scratch[16][36][4];
NV_PATCH_ALLOC_CACHE MyCache[MAX_EV_CACHE];

DWORD nvDrawTriSurface (PNVD3DCONTEXT pContext, DWORD dwHandle,
                        float *pfSegs, D3DTRIPATCH_INFO *pTSInfo)
{
    float Segs[4];
    CNvObject *pObj = NULL;
    CPatch *pNvPatch = NULL;
    DWORD dwDirty = 0;
    DWORD retVal = D3D_OK;
    int i;   

    if(!pContext->pCurrentVShader) return D3DERR_DRIVERINTERNALERROR;  //must have a vertex shader bound    

    //if no pfSegs info get it from the renderstate
    if (!pfSegs) {
        Segs[0] = Segs[1] = Segs[2] = *(float*)(&(pContext->dwRenderState[D3DRS_PATCHSEGMENTS]));
    }
    else {
        if (pContext->dwRenderState[D3DRS_PATCHEDGESTYLE] == 0x1)
            for (i=0; i < 4; i++) Segs[i] = pfSegs[i];
        else
            for (i=0; i < 4; i++) Segs[i] = int(pfSegs[i]);
    }
    Segs[3] = 0;    

    // check to see if we've cached this patch.
    // Note a handle of 0 implies NOT to cache the patch.
    if (dwHandle) pObj = nvGetObjectFromHandle(pContext->dwDDLclID, dwHandle, &global.pNvPatchLists);
    if (pObj) {
        //we have a pObj then we have a cached patch.
        pNvPatch = pObj->getPatch();
        assert(pNvPatch);
        if(Segs[0] != pNvPatch->getSeg(0) || Segs[1] != pNvPatch->getSeg(1) ||
           Segs[2] != pNvPatch->getSeg(2))
        {
            //tessellation has changed recalc parameterization
            pNvPatch->setCalc(NV_PATCH_DIRTY_TESSELLATION);
            pNvPatch->setTessellation(Segs, NV_PATCH_FLAG_TYPE_TRIANGULAR);
        }
        else
            //used cached FD params directly
            pNvPatch->setCalc(NV_PATCH_DIRTY_NONE);
    }

    //patch hasn't been cached -- build a new one
    if(pObj == NULL || pTSInfo){
        if(pObj){
            //pObj was previously cached and pRSInfo is new so we need to rebuild anyway
            //remove the cached one and rebuild from scratch
            PNV_OBJECT_LIST pNvPL = nvFindObjectList(pContext->dwDDLclID, &global.pNvPatchLists);
            nvClearObjectListEntry(pObj, &pNvPL);
            pObj->release();
        }
        pObj  =  new CNvObject(0);
        pNvPatch = new CPatch(pObj, dwHandle);      //cache the handle, and original segs.
        pNvPatch->setContext(pContext);
        DPF_LEVEL(NVDBG_LEVEL_HOS_INFO,"Creating TRI Patch #%d",dwHandle);

        nvAssert(pObj);
        nvAssert(pNvPatch);
        if(!pObj || !pNvPatch){ retVal = D3DERR_DRIVERINTERNALERROR; goto nvPatch_Mem_Fault; }
        pObj->setObject(CNvObject::NVOBJ_CACHEDPATCH, pNvPatch);    //bind wrapper
        if(dwHandle){
            //cache the patch if the handle isn't 0.
            PNV_OBJECT_LIST pNvPL = nvFindObjectList(pContext->dwDDLclID, &global.pNvPatchLists);
            nvAddObjectToList(pNvPL ,pObj, dwHandle);
        }
        pNvPatch->setTessellation(Segs, NV_PATCH_FLAG_TYPE_TRIANGULAR);
        pNvPatch->setOriginalTessellation(Segs, NV_PATCH_FLAG_TYPE_TRIANGULAR);
    }

    if(pTSInfo){    //new RenderSurface info -- reinitialize the patch data
        //select backend stream type
        if(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0097_KELVIN) pNvPatch->setOutputMode(NV_PATCH_BACKEND_KELVIN);
        else pNvPatch->setOutputMode(NV_PATCH_BACKEND_CELSIUS);

        //given this is a new cached patch  assume there is a valid pRSInfo.
        //initialize the patch structure
        pNvPatch->setDimension(1, 1);
        pNvPatch->setBasis((NV_PATCH_BASIS_TYPE)pTSInfo->Basis);    //int cast to deal with enum casts.
        pNvPatch->setOrder(pTSInfo->Order);
        pNvPatch->setStride(pTSInfo->Order);                       //IS THIS RIGHT FOR TRI PATCHES????
        pNvPatch->setPrimMode(NV_PATCH_FLAG_TYPE_TRIANGULAR);

        //alwasy set as fractional tessellation until they get their renderstate defined.
        if(pContext->dwRenderState[D3DRS_PATCHEDGESTYLE] == 0x1)
            pNvPatch->setTessMode(NV_PATCH_FLAG_TESS_FRACTIONAL);
        else pNvPatch->setTessMode(NV_PATCH_FLAG_TESS_INTEGER);

        //do this AFTER the normal/uv/stream setup cause they use these variable to figure out what to allocate
        pNvPatch->setCalc(NV_PATCH_DIRTY_TESSELLATION | NV_PATCH_DIRTY_CONTROL_POINTS);
        dwDirty = NV_PATCH_DIRTY_TESSELLATION | NV_PATCH_DIRTY_CONTROL_POINTS;

        //defined in # of vertices in a logical 2 dimensional Vertex buffer
        pNvPatch->setVertexOffset(pTSInfo->StartVertexOffset);

        //copy data to scratch.
        pNvPatch->setupStreams(pContext);
    }

    //setup celsius strides for inlining vertices
#ifdef HOSURF_ENABLE
    //set ptr to cache parameters
    nvHWLockTextures (pContext);    

    switch(pNvPatch->getBasis()){
    case NV_PATCH_BASIS_BEZIER:

        //if bezier don't cycle through multiple patches in the width/height fashion as bsplines
        if(dwDirty & NV_PATCH_DIRTY_CONTROL_POINTS){
            pNvPatch->copyDataToScratchTri(pContext,0,0);
            pNvPatch->freeCached();     //free up old cached data and reinit for a new patch to be built.
            if(!pNvPatch->allocCached(1)){
                retVal = D3DERR_DRIVERINTERNALERROR;
                goto nvPatch_Mem_Fault;
            }
            pNvPatch->getCachedData(0);
        }
        pNvPatch->setTextureOffsets(0.0,1.0,0.0,1.0); 
        pNvPatch->setupStreams(pContext);
       
    
#ifdef DCR_CACHEDPB_OPT
        if(dwDirty == NV_PATCH_DIRTY_NONE){
            if(pNvPatch->getCachedPBSize() == 0){
                DWORD dwWC = pDriverData->nvPusher.getWrapCount();                
                DWORD dwCPut = pDriverData->nvPusher.getPut();
                retVal = nvEvalPatchSetup(pNvPatch->getInfo());    
                nvAllocInfoScratch(pNvPatch->getInfo());
                retVal = nvEvalPatch(pNvPatch->getInfo());
                if(dwWC == pDriverData->nvPusher.getWrapCount()){
                    //we didn't actually wrap so copy off the pb to be used later.
                    pNvPatch->allocCachedPB((pDriverData->nvPusher.getPut() - dwCPut));
                    nvMemCopy((unsigned char *)pNvPatch->getCachedPB(),(unsigned char *)dwCPut, pNvPatch->getCachedPBSize());
                }
            }
            else{
                DWORD dwSize = pNvPatch->getCachedPBSize();
                DWORD *dwPB = (DWORD *)(&(pNvPatch->getCachedPB()[0]));
                pDriverData->nvPusher.makeSpace(dwSize);
                nvMemCopy(pDriverData->nvPusher.getPut(), (DWORD)dwPB, dwSize);               
                pDriverData->nvPusher.inc(dwSize>>2);    //push the put forward                    

                /* DWORD dwPut;
                DWORD dwSize = (pNvPatch->getCachedPBSize() % (PB_DUMP_SIZE*sizeof(DWORD)));
                DWORD dwCount = (pNvPatch->getCachedPBSize() - dwSize)/(PB_DUMP_SIZE*sizeof(DWORD));
                DWORD *dwPB;    
                DWORD i;

                dwPB  = (DWORD *)(&(pNvPatch->getCachedPB()[0]));
                for(i=0; i < dwCount; i++){
                    pDriverData->nvPusher.makeSpace(PB_DUMP_SIZE);
                    dwPut = pDriverData->nvPusher.getPut();             //don't calc cause the PB could wrap.
                    nvMemCopy(dwPut, (DWORD)dwPB, PB_DUMP_SIZE*sizeof(DWORD));
                    pDriverData->nvPusher.inc(PB_DUMP_SIZE);            //push the put forward                    
                    dwPB+=PB_DUMP_SIZE;
                }
                pDriverData->nvPusher.makeSpace(dwSize);
                nvMemCopy(pDriverData->nvPusher.getPut(), (DWORD)dwPB, dwSize);               
                pDriverData->nvPusher.inc(dwSize>>2);    //push the put forward */
            }
            pDriverData->nvPusher.start(TRUE);
        }
        else {
            pNvPatch->freeCachedPB();
#endif
        retVal = nvEvalPatchSetup(pNvPatch->getInfo());    
        nvAllocInfoScratch(pNvPatch->getInfo());
        if(dwDirty & NV_PATCH_DIRTY_CONTROL_POINTS){
            nvAllocFDMatricesEtc(pNvPatch->getInfo());   
            retVal |= nvEvalPatch(pNvPatch->getInfo());
            pNvPatch->saveCachedData(0);
        }
        else{
            retVal |= nvEvalPatch(pNvPatch->getInfo());
        }
        pDriverData->nvPusher.start(FALSE);
#ifdef DCR_CACHEDPB_OPT
        }
#endif
        break;
    case NV_PATCH_BASIS_BSPLINE:
    case NV_PATCH_BASIS_CATMULL_ROM:
        nvAssert(0);  //THIS SHOULD NEVER HAPPEN FOR TRI PATCHES!!!
    }

    nvEvalPatchCleanup(pNvPatch->getInfo());
    nvHWUnlockTextures (pContext);
#else
    retVal = D3D_OK;
#endif

    //if handle is 0 we don't want this cached and should release the pNvObj, patch, and cached data
    if(dwHandle == 0){
        pObj->release();
    }

nvPatch_Mem_Fault:
    return retVal;
}

static DWORD SizeCounter = 0;
static DWORD PatchCounter = 0;
DWORD nvDrawRectSurface (PNVD3DCONTEXT pContext, DWORD dwHandle,
                         float *pfSegs, D3DRECTPATCH_INFO *pRSInfo)
{
    float      Segs[4];
    CNvObject *pObj = NULL;
    CPatch    *pNvPatch = NULL;
    DWORD      num_subpatches = 0;
    DWORD      dwDirty = 0;
    DWORD      retVal = D3D_OK;
    int i;

    if(!pContext->pCurrentVShader) return D3DERR_DRIVERINTERNALERROR;  //must have a vertex shader bound

    //if no pfSegs info get it from the renderstate
    if (!pfSegs) {
        Segs[0] = Segs[1] = Segs[2] = Segs[3] = *(float*)(&(pContext->dwRenderState[D3DRS_PATCHSEGMENTS]));
    }
    else {
        if(pContext->dwRenderState[D3DRS_PATCHEDGESTYLE] == 0x1)
            for(i=0; i < 4; i++) Segs[i] = pfSegs[i];
        else
            for(i=0; i < 4; i++) Segs[i] = int(pfSegs[i]);
    }

    //check to see if we've cached this patch.
    //Note a handle of 0 implies NOT to cache the patch.
    if (dwHandle) pObj = nvGetObjectFromHandle(pContext->dwDDLclID, dwHandle, &global.pNvPatchLists);
    if(pObj){
        //we have a pObj then we have a cached patch.
        pNvPatch = pObj->getPatch();
        assert(pNvPatch);
        if(Segs[0] != pNvPatch->getSeg(0) || Segs[1] != pNvPatch->getSeg(1) ||
           Segs[2] != pNvPatch->getSeg(2) || Segs[3] != pNvPatch->getSeg(3))
        {
            //tessellation has changed recalc parameterization
            pNvPatch->setCalc(NV_PATCH_DIRTY_TESSELLATION);
            pNvPatch->setTessellation(Segs, NV_PATCH_FLAG_TYPE_PATCH);
            dwDirty = NV_PATCH_DIRTY_TESSELLATION;
        }
        else{
            //used cached FD params directly
            pNvPatch->setCalc(NV_PATCH_DIRTY_NONE);
        }
    }

    //patch hasn't been cached -- build a new one
    if(pObj == NULL || pRSInfo){
        if(pObj){
            //pObj was previously cached and pRSInfo is new so we need to rebuild anyway
            //remove the cached one and rebuild   from scratch
            PNV_OBJECT_LIST pNvPL = nvFindObjectList(pContext->dwDDLclID, &global.pNvPatchLists);
            nvClearObjectListEntry(pObj, &pNvPL);
            pObj->release();
        }
        pObj  =  new CNvObject(0);
        pNvPatch = new CPatch(pObj, dwHandle);      //cache the handle, and original segs.
        pNvPatch->setContext(pContext);
        DPF_LEVEL(NVDBG_LEVEL_HOS_INFO,"Creating QUAD Patch #%d PObj = %08x pNvPatch = %08x DDLcl = %08x",dwHandle,pObj,pNvPatch,pContext->dwDDLclID);

        nvAssert(pObj);
        nvAssert(pNvPatch);
        if(!pObj || !pNvPatch){ retVal = D3DERR_DRIVERINTERNALERROR; goto nvPatch_Mem_Fault; }
        pObj->setObject(CNvObject::NVOBJ_CACHEDPATCH, pNvPatch);    //bind wrapper

        if(dwHandle){
            //cache the patch if the handle isn't 0.
            PNV_OBJECT_LIST pNvPL = nvFindObjectList(pContext->dwDDLclID, &global.pNvPatchLists);
            nvAddObjectToList(pNvPL ,pObj, dwHandle);
        }
        pNvPatch->setTessellation(Segs, NV_PATCH_FLAG_TYPE_PATCH);
        pNvPatch->setOriginalTessellation(Segs, NV_PATCH_FLAG_TYPE_PATCH);        
    }
    
    if(pRSInfo){    //new RenderSurface info -- reinitialize the patch data
        //select backend stream type
        if(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0097_KELVIN) pNvPatch->setOutputMode(NV_PATCH_BACKEND_KELVIN);
        else pNvPatch->setOutputMode(NV_PATCH_BACKEND_CELSIUS);

        //given this is a new cached patch  assume there is a valid pRSInfo.
        //initialize the patch structure
        pNvPatch->setDimension(pRSInfo->Width, pRSInfo->Height);
        pNvPatch->setBasis((NV_PATCH_BASIS_TYPE)pRSInfo->Basis);    //int cast to deal with enum casts.
        pNvPatch->setOrder(pRSInfo->Order);
        pNvPatch->setStride(pRSInfo->Stride);                       //IS THIS RIGHT??

        //alwasy set as fractional tessellation until they get their renderstate defined.
        if(pContext->dwRenderState[D3DRS_PATCHEDGESTYLE] == 0x1)
            pNvPatch->setTessMode(NV_PATCH_FLAG_TESS_FRACTIONAL);
        else pNvPatch->setTessMode(NV_PATCH_FLAG_TESS_INTEGER);
        
        //do this AFTER the normal/uv/stream setup cause they use these variable to figure out what to allocate
        pNvPatch->setCalc(NV_PATCH_DIRTY_TESSELLATION | NV_PATCH_DIRTY_CONTROL_POINTS);
        dwDirty = NV_PATCH_DIRTY_TESSELLATION | NV_PATCH_DIRTY_CONTROL_POINTS;

        //defined in # of vertices in a logical 2 dimensional Vertex buffer
        pNvPatch->setVertexOffset(pRSInfo->StartVertexOffsetHeight * pRSInfo->Stride + pRSInfo->StartVertexOffsetWidth);

        //copy data to scratch.
        pNvPatch->setupStreams(pContext);
    }

    //setup celsius strides for inlining vertices
#ifdef HOSURF_ENABLE
    //set ptr to cache parameters
    nvHWLockTextures (pContext);

    switch(pNvPatch->getBasis()){
    case NV_PATCH_BASIS_BEZIER:

        //if bezier don't cycle through multiple patches in the width/height fashion as bsplines
        //if we dirtied the control points -- free them up and reallocate some cached space for them.
        if(dwDirty & NV_PATCH_DIRTY_CONTROL_POINTS){
            pNvPatch->copyDataToScratch(pContext,0,0);
            pNvPatch->freeCached();     //free up old cached data and reinit for a new patch to be built.
            if(!pNvPatch->allocCached(1)){
                retVal = D3DERR_DRIVERINTERNALERROR;
                goto nvPatch_Mem_Fault;
            }
            pNvPatch->getCachedData(0);
        }

        pNvPatch->setTextureOffsets(0.0,1.0,0.0,1.0);
        pNvPatch->setupStreams(pContext);
    
#ifdef DCR_CACHEDPB_OPT
        if(dwDirty == NV_PATCH_DIRTY_NONE){
            if(pNvPatch->getCachedPBSize() == 0){
                DWORD dwWC = pDriverData->nvPusher.getWrapCount();
                DWORD dwCPut = pDriverData->nvPusher.getPut();
                retVal = nvEvalPatchSetup(pNvPatch->getInfo());    
                nvAllocInfoScratch(pNvPatch->getInfo());
                retVal = nvEvalPatch(pNvPatch->getInfo());
                if(dwWC == pDriverData->nvPusher.getWrapCount()){
                    //we didn't actually wrap so copy off the pb to be used later.
                    pNvPatch->allocCachedPB((pDriverData->nvPusher.getPut() - dwCPut));
                    nvMemCopy((unsigned char *)pNvPatch->getCachedPB(),(unsigned char *)dwCPut, pNvPatch->getCachedPBSize());
                }
            }
            else{
                DWORD dwSize = pNvPatch->getCachedPBSize();
                DWORD *dwPB = (DWORD *)(&(pNvPatch->getCachedPB()[0]));
                pDriverData->nvPusher.makeSpace(dwSize);
                nvMemCopy(pDriverData->nvPusher.getPut(), (DWORD)dwPB, dwSize);               
                pDriverData->nvPusher.inc(dwSize>>2);    //push the put forward                    

                /* DWORD dwPut;
                DWORD dwSize = (pNvPatch->getCachedPBSize() % (PB_DUMP_SIZE*sizeof(DWORD)));
                DWORD dwCount = (pNvPatch->getCachedPBSize() - dwSize)/(PB_DUMP_SIZE*sizeof(DWORD));
                DWORD *dwPB;    
                DWORD i;

                dwPB  = (DWORD *)(&(pNvPatch->getCachedPB()[0]));
                for(i=0; i < dwCount; i++){
                    pDriverData->nvPusher.makeSpace(PB_DUMP_SIZE);
                    dwPut = pDriverData->nvPusher.getPut();             //don't calc cause the PB could wrap.
                    nvMemCopy(dwPut, (DWORD)dwPB, PB_DUMP_SIZE*sizeof(DWORD));
                    pDriverData->nvPusher.inc(PB_DUMP_SIZE);            //push the put forward                    
                    dwPB+=PB_DUMP_SIZE;
                }
                pDriverData->nvPusher.makeSpace(dwSize);
                nvMemCopy(pDriverData->nvPusher.getPut(), (DWORD)dwPB, dwSize);               
                pDriverData->nvPusher.inc(dwSize>>2);    //push the put forward */
            }
            pDriverData->nvPusher.start(TRUE);
        }
        else {
            pNvPatch->freeCachedPB();
#endif
            retVal = nvEvalPatchSetup(pNvPatch->getInfo());    
            nvAllocInfoScratch(pNvPatch->getInfo());
            if(dwDirty & NV_PATCH_DIRTY_CONTROL_POINTS){
                nvAllocFDMatricesEtc(pNvPatch->getInfo());
                retVal |= nvEvalPatch(pNvPatch->getInfo());
                pNvPatch->saveCachedData(0);
            }
            else{
                retVal |= nvEvalPatch(pNvPatch->getInfo());
            }
            pDriverData->nvPusher.start(FALSE);
#ifdef DCR_CACHEDPB_OPT
        }
#endif
        break;
    case NV_PATCH_BASIS_BSPLINE:
    case NV_PATCH_BASIS_CATMULL_ROM:
        DWORD upatches = pNvPatch->getWidth()  - pNvPatch->getOrder();
        DWORD vpatches = pNvPatch->getHeight() - pNvPatch->getOrder();
        float ustep,vstep;

        //allocate some data for
        if(dwDirty & NV_PATCH_DIRTY_CONTROL_POINTS){
            pNvPatch->freeCached();     //free up old cached data and reinit for a new patch to be rebuilt.
            if(!pNvPatch->allocCached(upatches*vpatches)){
                retVal = D3DERR_DRIVERINTERNALERROR;
                goto nvPatch_Mem_Fault;
            }

        }

        //reset the tessellation value here to account for subpatches.  The tessellation is meant to describe
        //the ENTIRE patch, not each subpatch.  Divide the tessellation by the # of subpatches in each direction.
        if(dwDirty){
            if(pContext->dwRenderState[D3DRS_PATCHEDGESTYLE] == 0x1){
                //fractional
                Segs[0] = max(2.0,Segs[0]/upatches); Segs[1] = max(2.0,Segs[1]/vpatches);
                Segs[2] = max(2.0,Segs[2]/upatches); Segs[3] = max(2.0,Segs[3]/vpatches);
            }
            else{
                //integer
                Segs[0] = max(1.0,int(Segs[0]/upatches+0.5)); Segs[1] = max(1.0,int(Segs[1]/vpatches+0.5));
                Segs[2] = max(1.0,int(Segs[2]/upatches+0.5)); Segs[3] = max(1.0,int(Segs[3]/vpatches+0.5));
            }

            switch(dwDirty){ //deliverately falls through.
            case NV_PATCH_DIRTY_CONTROL_POINTS | NV_PATCH_DIRTY_TESSELLATION:
            case NV_PATCH_DIRTY_CONTROL_POINTS:
                pNvPatch->setOriginalTessellation(Segs, NV_PATCH_FLAG_TYPE_PATCH);
            case NV_PATCH_DIRTY_TESSELLATION:
                pNvPatch->setTessellation(Segs, NV_PATCH_FLAG_TYPE_PATCH);
            }
        }

        //bpsline -- observe that width/height in PRSInfo implies multiple subpatches...
        //render and cache each one seperately.
        //pNvPatch->setupStreams(pContext);

        ustep = 1.0/upatches;
        vstep = 1.0/vpatches;
        unsigned int i,j;
        for(i=0; i < (upatches); i++){
            for(j=0; j < (vpatches); j++){
                pNvPatch->setCalc(dwDirty);     //reset these flags everytime through loop
                                                //because they'll be cleared internally for each map
                                                //though technically I'm rebuilding all here
                pNvPatch->getCachedData(upatches*i+j);
                pNvPatch->setTextureOffsets(i*ustep, (i+1)*ustep, j*vstep, (j+1)*vstep);
                pNvPatch->copyDataToScratch(pContext, i, j);
                pNvPatch->setupStreams(pContext);

                //if we dirtied the control points -- free them up and reallocate some cached space for them.
                nvEvalPatchSetup(pNvPatch->getInfo());
                if(dwDirty & NV_PATCH_DIRTY_CONTROL_POINTS){
                    nvAllocFDMatricesEtc(pNvPatch->getInfo());                
                    nvAllocInfoScratch(pNvPatch->getInfo());
                    retVal = nvEvalPatch(pNvPatch->getInfo());
                    pNvPatch->saveCachedData(upatches*i+j);
                } else {
                    retVal = nvEvalPatch(pNvPatch->getInfo());
                }
                nvEvalPatchCleanup(pNvPatch->getInfo());
            }
        }
    }
    
    nvEvalPatchCleanup(pNvPatch->getInfo());
    nvHWUnlockTextures (pContext);
#else
    retVal = D3D_OK;
#endif

    //if handle is 0 we don't want this cached and should release the pNvObj, patch, and cached data
    if(dwHandle == 0){
        pObj->release();
    }

nvPatch_Mem_Fault:
    return retVal;

}

CPatch::CPatch(CNvObject *pObj, DWORD dwHandle)
{
    int i;
    m_dwHandle = dwHandle;
    m_pWrapperObject = pObj;

    m_PatchData.backendType = NV_PATCH_BACKEND_CELSIUS; //default
    m_subpatchcount = 0;
    m_dwStride = m_dwWidth = m_dwHeight = 0;
    m_dwOrder = 1;
    m_PatchData.srcNormal = -1;
    m_PatchData.dstNormal = -1;
    m_PatchData.maxSwatch = NV_PATCH_KELVIN_SWATCH_SIZE;
    m_PatchData.nAttr = NV_PATCH_NUMBER_OF_ATTRIBS;
    m_PatchData.maxAttr = NV_PATCH_NUMBER_OF_ATTRIBS;
    m_PatchData.maxOrder = NV_PATCH_MAX_ORDER;    
    m_PatchData.evalEnables = 0;
    //ffm_PatchData.evAlloc9FDMatrices.pBase = NULL;
    m_PatchData.quadInfo = NULL;
    m_PatchData.cachedPB = NULL;
    m_PatchData.cachedPBSize = 0;
    m_PatchData.cachedPBCounter = 0;
    m_PatchData.normalPatch = NULL;
    m_PatchData.UVPatch = NULL;
    for(i=0; i < 8; i++){
        m_PatchData.srcUV[i] = -1;
        m_PatchData.dstUV[i] = -1; }
    m_PatchData.tess.tensor.nu0 = m_PatchData.tess.tensor.nu1 = m_PatchData.tess.tensor.nv0 = m_PatchData.tess.tensor.nv1 = 0;
       //init ptrs to null
    m00 = m10 = m01 = m11 = NULL;
    guardQF = NULL;
    guardTF = NULL;
    cachedQuadInfo = NULL;

    //output buffer pts for a DP2 stream
    m_PatchData.buffer = 0;
    m_PatchData.bufferLength = NULL;

    //
    for(i=0; i < MAX_EV_CACHE; i++){
        m_PatchData.pCache[i] = &MyCache[i];       
    }

    //flag for assembly loop optimizations
    m_PatchData.cpuType = pDriverData->nvD3DPerfData.dwCPUFeatureSet;

    //setup default render flags
    m_PatchData.flags = 0x0;    //TESS=FLOAT, PRIM=QUAD, NO BUFFER ALLOCATED

    //setup allocation callbacks.
    m_PatchData.callbacks = &m_callbacks;

    return;
}

CPatch::~CPatch(){
            
    freeCachedPB();
    freeCached();   //free any cached data we might have hanging around.

    return;
}

void CPatch::setStream(UINT streamID, void *memptr, DWORD stride, DWORD pitch, NV_PATCH_VERTEX_FORMAT_TYPE mt, UINT order)
{
    m_PatchData.maps[streamID].maptype       = NV_PATCH_VERTEX_FORMAT_FLOAT_4;//shared code deals in 4 vectors!!!                                                                             
    //copy to scratch routine will expand.
    m_PatchData.maps[streamID].Originaltype  = mt;
    m_PatchData.maps[streamID].rawData       = (float*)memptr;
    m_PatchData.maps[streamID].stride        = stride;
    m_PatchData.maps[streamID].pitch         = pitch;                           //in # of vertices to next row.
    m_PatchData.maps[streamID].ufStride      = 4;                               //# of floats to next vertex in u.
    m_PatchData.maps[streamID].vfStride      = pitch*4;                         //# of floats to next vertex in v.
    m_PatchData.maps[streamID].uorder        = order;
    m_PatchData.maps[streamID].vorder        = order;
    if(order == 0) m_PatchData.evalEnables &= ~(0x1 << streamID);
    else m_PatchData.evalEnables |= (0x1 << streamID);
}

void CPatch::setOutputMode(NV_PATCH_BACKEND_TYPE rf)
{
    NV_PATCH_BACKEND_TYPE old_rf;
    old_rf = m_PatchData.backendType;

    //if stream type has changed, unhook old buffer
    switch(rf){
        case NV_PATCH_BACKEND_CELSIUS:
            m_PatchData.backend = &nvCelsiusImm_Backend;
            m_PatchData.maxSwatch = 0x40;
            break;
        case NV_PATCH_BACKEND_KELVIN:
            m_PatchData.backend = &nvKelvinImm_Backend;
            m_PatchData.maxSwatch = NV_PATCH_KELVIN_SWATCH_SIZE;
            break;
        default:
            nvAssert(0);
    }
    m_PatchData.backendType = rf;
}

void CPatch::getCachedData(DWORD i){
    m_PatchData.quadInfo = cachedQuadInfo[i];
}

void CPatch::saveCachedData(DWORD i){
    //this assumes that the EVALLOC routines in the shared code allocate Quadinfo first yes?
    cachedQuadInfo[i] = (NV_PATCH_QUAD_INFO*)(m_PatchData.pCache[EV_CACHE_QUADINFO_ETC]->pBaseCache);    
    m_PatchData.pCache[EV_CACHE_QUADINFO_ETC]->pBaseCache = NULL;    
    m_PatchData.pCache[EV_CACHE_QUADINFO_ETC]->bytesAllocCache = 0;        
}


BOOL CPatch::allocCached(DWORD dwNumSubPatches){
    DWORD evalEnables = m_PatchData.evalEnables;
    DWORD i;

    //new char[NV_PATCH_NUMBER_OF_ATTRIBS*dwNumSubPatches*sizeof(FDMatrix*)]
    if(m_PatchData.flags & NV_PATCH_FLAG_AUTO_UV){
        for(i=0; i < 8; i++){   if(m_PatchData.dstUV[i] != 0xFFFFFFFF) evalEnables |= (1<< m_PatchData.dstUV[i]); }
    }
    if(m_PatchData.flags & NV_PATCH_FLAG_AUTO_NORMAL){ evalEnables |= (1<< m_PatchData.dstNormal); }
   
    //allocate set of ptrs to our cached data structures
    m_subpatchcount = dwNumSubPatches;
    bool failed = FALSE;

    //allocate space for quadInfo structs
    cachedQuadInfo = new NV_PATCH_QUAD_INFO*[dwNumSubPatches];
    for(i=0; i < dwNumSubPatches; i++){ cachedQuadInfo[i] = NULL; }
    if(cachedQuadInfo == NULL){ failed = TRUE; }    
    
/*  
    for(subpatch = 0; subpatch < dwNumSubPatches; subpatch++){
        if(!(cachedQuadInfo[subpatch] = new NV_PATCH_QUAD_INFO)){ failed = TRUE;}
    }
*/

    return TRUE;
}

void CPatch::freeCached(){       
    DWORD i;

    for(i=0; i < this->m_subpatchcount; i++){       
        if(cachedQuadInfo[i]) delete cachedQuadInfo[i];
        cachedQuadInfo[i] = NULL;
    }
    if(cachedQuadInfo){ delete []cachedQuadInfo; cachedQuadInfo = NULL; }    
    m_PatchData.quadInfo = NULL;

    return;
}

void *CPatch::alloc(void *context, size_t bytes){
    BYTE *ptr = new BYTE[bytes];
    return (void*)ptr;
}

void CPatch::free(void *context, void *ptr){
    delete [](BYTE*)ptr;
    return;
}

void  CPatch::memcpy(void *dst, const void *src, size_t size){
    nvMemCopy(dst, const_cast <void *>(src), (DWORD)size);
    return;
}

void CPatch::setupStreams(PNVD3DCONTEXT pContext){
    DWORD i, dwOffset, dwVBStride, dwOrder, dwStream;
    BYTE *dwVBBase;
    NV_PATCH_VERTEX_FORMAT_TYPE dwType;
    

    CVertexShader *lpCurrent = pContext->pCurrentVShader;
    //16 is the # of attributes handled by Kelvin -- should probably be changed to an RM
    //configurable constant based on chip architecture.
    m_PatchData.nAttr = 0x0;

    for (i=0; i < NV_PATCH_NUMBER_OF_ATTRIBS; i++) {
        dwStream = lpCurrent->getVAStream(i);
        if ( lpCurrent                        &&
            (dwStream != 0xFFFFFFFF)          &&
            (lpCurrent->getVAFlag(i)==CVertexShader::AUTONONE) &&
            pContext->ppDX8Streams[dwStream])
        {
            dwType = (NV_PATCH_VERTEX_FORMAT_TYPE)lpCurrent->getVAType(i);
            //type of incoming data -- copy to scratch will expand to a 4-vector for the shared code
            //CelsiusBackend will convert it back.
            dwVBStride = 4*sizeof(float);   //stride size for shared code -- i.e. vector.
            dwVBBase = (BYTE*)&scratch[i][0][0];
            dwOffset = 0;
            dwOrder    = (DWORD)getOrder()+1;
        }

        else {
            //vsize+=0;
            dwVBBase = NULL;
            dwOffset = dwVBStride = dwOrder = 0;
            dwType = (NV_PATCH_VERTEX_FORMAT_TYPE)0;
        }
        setStream (i, dwVBBase + dwOffset, dwVBStride, dwOrder, dwType, dwOrder);
    }

    //get auto generated normals
    dwStream = pContext->pCurrentVShader->getAutoNormalStream();
    if (dwStream != -1) {        
        //destination should be the normal stream itself
        setAutoNormal (pContext->pCurrentVShader->getVASrc(dwStream), dwStream);
    }
 
    //get auto generated texture coordinates
    for (i=0; i < 8; i++){
        //shouldn't need to swap here.
        dwStream = pContext->pCurrentVShader->getAutoTextureStream(i);
        if (dwStream != -1) {            
            //destination should be texture stream itself
            setAutoUV (pContext->pCurrentVShader->getVASrc(dwStream), dwStream, i);
        }
    }

    //if stream 2 is enabled it is assumed there is a guard curved normal active... 
    dwStream = pContext->pCurrentVShader->getVAStream(2);
    if(dwStream != 0xFFFFFFFF){ m_PatchData.dstNormal = 0x2; }    //BUG BUG HACK!!!!

    setVertexStride (pContext->hwState.dwInlineVertexStride >> 2);

    return;
}

#define VIEW_AS_DWORD(f) (*(DWORD *)(&(f)))
void CPatch::copyDataToScratch(PNVD3DCONTEXT pContext, DWORD offsetu, DWORD offsetv){

    DWORD i,j,k, pitch, vertexcount;
    float *data;
    DWORD evalEnables, dwOffset, dwStream, dwStride;
    DWORD order;
    order = m_dwOrder+1;

    evalEnables = m_PatchData.evalEnables;

    for (i=0; i < NV_PATCH_NUMBER_OF_ATTRIBS; i++) {
        if (evalEnables & (1<<i)) {
            if(pContext->pCurrentVShader && pContext->ppDX8Streams[pContext->pCurrentVShader->getVAStream(i)]){
                dwStream   = pContext->pCurrentVShader->getVAStream(i);
                data = (float*) pContext->ppDX8Streams[dwStream]->getAddress();
                dwOffset = (offsetv*getWidth() + offsetu) + m_dwVertexOffset;
                dwStride =  pContext->ppDX8Streams[dwStream]->getVertexStride() >> 2; //convert to float
                data += dwOffset * dwStride;
                //BUG BUG: THIS IS WEIRD TO ADD AN OFFSET TO OFFSETS?? NEED TO LOOK INTO THIS
                data += (pContext->pCurrentVShader->getVAOffset(i)>>0x2);  //vertex offset converted to offset in float
                pitch = getStride()*dwStride;   //getStride returns a stride value in vertices for mosaiced patches
                vertexcount = 0;

                switch(m_PatchData.maps[i].Originaltype){
                    case NV_PATCH_VERTEX_FORMAT_FLOAT_1:
                        for(j=0; j < order; j++){
                            for(k=0; k < order*dwStride; k+=dwStride){
                                scratch[i][vertexcount][0] = data[k+0]; scratch[i][vertexcount][1] = 0.0;
                                scratch[i][vertexcount][2] = 0.0;       scratch[i][vertexcount][3] = 1.0; vertexcount++;
                            }
                            data+=pitch;
                        }
                        break;
                    case NV_PATCH_VERTEX_FORMAT_FLOAT_2:
                        for(j=0; j < order; j++){
                            for(k=0; k < order*dwStride; k+=dwStride){
                                scratch[i][vertexcount][0] = data[k+0]; scratch[i][vertexcount][1] = data[k+1];
                                scratch[i][vertexcount][2] = 0.0;       scratch[i][vertexcount][3] = 1.0; vertexcount++;
                            }
                            data+=pitch;
                        }
                        break;
                    case NV_PATCH_VERTEX_FORMAT_FLOAT_3:
                        for(j=0; j < order; j++){
                            for(k=0; k < order*dwStride; k+=dwStride){
                                scratch[i][vertexcount][0] = data[k+0]; scratch[i][vertexcount][1] = data[k+1];
                                scratch[i][vertexcount][2] = data[k+2]; scratch[i][vertexcount][3] = 1.0; vertexcount++;
                            }
                            data+=pitch;
                        }
                        break;
                    case NV_PATCH_VERTEX_FORMAT_FLOAT_4:
                        for(j=0; j < order; j++){
                            for(k=0; k < order*dwStride; k+=dwStride){
                                scratch[i][vertexcount][0] = data[k+0]; scratch[i][vertexcount][1] = data[k+1];
                                scratch[i][vertexcount][2] = data[k+2]; scratch[i][vertexcount][3] = data[k+3]; vertexcount++;
                            }
                            data+=pitch;
                        }
                        break;
                    case NV_PATCH_VERTEX_FORMAT_D3DCOLOR:
                    case NV_PATCH_VERTEX_FORMAT_UBYTE:
                        for(j=0; j < order; j++){
                            for(k=0; k < order*dwStride; k+=dwStride){
                                scratch[i][vertexcount][0] = ((VIEW_AS_DWORD(data[k])&0x00ff0000)>>16)/255.0;
                                scratch[i][vertexcount][1] = ((VIEW_AS_DWORD(data[k])&0x0000ff00)>>8 )/255.0;
                                scratch[i][vertexcount][2] = ((VIEW_AS_DWORD(data[k])&0x000000ff)>>0 )/255.0;
                                scratch[i][vertexcount][3] = ((VIEW_AS_DWORD(data[k])&0xff000000)>>24)/255.0;                                             
                                vertexcount++;
                            }
                            data+=pitch;
                        }
                        break;
                    default:
                        nvAssert(0);    //short cases -- what do we do here?
                } // switch
            }
        }
    }

    if(m_dwOrder > 1){  //conversions not necessary for linear maps.
        switch(m_PatchData.basis){
        case NV_PATCH_BASIS_BEZIER:
            //convert data inline from BSpline to Scratch.
            break;
        case NV_PATCH_BASIS_BSPLINE:
            //convert basis inline from BSpline to Scratch.
            convertBsplineToBezier();
            break;
        case NV_PATCH_BASIS_CATMULL_ROM:
            nvAssert(m_dwOrder == 3);   //we only ever expect a cubic catmull rom here.
            //convert basis inline from Catmul Rom to Scratch.
            convertCatmullRomToBezier();
            break;
        }
    }


    return;
}

static int trilookup_1[] = {2, 1, 0};
static int trilookup_3[] = {12,9,8,6,5,4,3,2,1,0};
static int trilookup_5[] = {30,25,24,20,19,18,15,14,13,12,10,9,8,7,6,5,4,3,2,1,0};
void CPatch::copyDataToScratchTri(PNVD3DCONTEXT pContext, DWORD offsetu, DWORD offsetv){

    DWORD i,j,pitch;
    float *data;
    DWORD evalEnables, dwOffset, dwStream, dwStride, vertex;
    DWORD order;
    order = m_dwOrder+1;
    int *lookup;
    DWORD count = 0;
    evalEnables = m_PatchData.evalEnables;
    for(i=0; i < NV_PATCH_NUMBER_OF_ATTRIBS; i++){
        if(evalEnables & (1<<i)){
            //BUG BUG: THIS IS WEIRD TO ADD AN OFFSET TO OFFSETS?? NEED TO LOOK INTO THIS
            if(pContext->pCurrentVShader && pContext->ppDX8Streams[pContext->pCurrentVShader->getVAStream(i)]){
                dwStream   = pContext->pCurrentVShader->getVAStream(i);
                data = (float*) pContext->ppDX8Streams[dwStream]->getAddress();
                dwOffset = (offsetv*getWidth() + offsetu) + m_dwVertexOffset;
                dwStride = pContext->ppDX8Streams[dwStream]->getVertexStride() >> 2; //convert to float
                data += dwOffset * dwStride;
                data += (pContext->pCurrentVShader->getVAOffset(i)>>2);  //vertex offset converted to offset in bytes
                pitch = getStride()*dwStride; //in vertices
                switch(order){
                    case 2: lookup = trilookup_1; count = 3;  break;    //linear
                    case 4: lookup = trilookup_3; count = 10; break;    //cubic
                    case 6: lookup = trilookup_5; count = 21; break;    //quintic
                    default: nvAssert(0);                   //shouldn't ever be here.
                }
                switch(m_PatchData.maps[i].Originaltype) {
                case NV_PATCH_VERTEX_FORMAT_FLOAT_1:
                    for(j=0; j < count; j++){
                        vertex = lookup[j];
                        scratch[i][vertex][0] = data[0];   scratch[i][vertex][1] = 0.0;
                        scratch[i][vertex][2] = 0.0;       scratch[i][vertex][3] = 1.0;
                        data+=dwStride;
                    }
                    break;
                case NV_PATCH_VERTEX_FORMAT_FLOAT_2:
                    for(j=0; j < count; j++){
                        vertex = lookup[j];
                        scratch[i][vertex][0] = data[0];   scratch[i][vertex][1] = data[1];
                        scratch[i][vertex][2] = 0.0;       scratch[i][vertex][3] = 1.0;
                        data+=dwStride;
                    }
                    break;
                case NV_PATCH_VERTEX_FORMAT_FLOAT_3:
                    for(j=0; j < count; j++){
                        vertex = lookup[j];
                        scratch[i][vertex][0] = data[0];   scratch[i][vertex][1] = data[1];
                        scratch[i][vertex][2] = data[2];   scratch[i][vertex][3] = 1.0;
                        data+=dwStride;
                    }
                    break;
                case NV_PATCH_VERTEX_FORMAT_FLOAT_4:
                    for(j=0; j < count; j++){
                        vertex = lookup[j];
                        scratch[i][vertex][0] = data[0];   scratch[i][vertex][1] = data[1];
                        scratch[i][vertex][2] = data[2];   scratch[i][vertex][3] = data[3];
                        data+=dwStride;
                    }
                    break;
                case NV_PATCH_VERTEX_FORMAT_UBYTE:
                case NV_PATCH_VERTEX_FORMAT_D3DCOLOR:
                    for(j=0; j < count; j++){
                        vertex = lookup[j];
                        scratch[i][vertex][0] = ((VIEW_AS_DWORD(data[0])&0x00ff0000)>>16)/255.0;
                        scratch[i][vertex][1] = ((VIEW_AS_DWORD(data[0])&0x0000ff00)>>8 )/255.0;
                        scratch[i][vertex][2] = ((VIEW_AS_DWORD(data[0])&0x000000ff)>>0 )/255.0;
                        scratch[i][vertex][3] = ((VIEW_AS_DWORD(data[0])&0xff000000)>>24)/255.0;                                             
                        data+=dwStride;
                    }
                    break;
                default:
                    nvAssert(0);
                }
            }
        }
    }
    return;
}


__inline void catrom2bez3(float *in, int stride) {

    float in1_1x,in1_1y,in1_1z,in1_1w;
    float in0_1x,in0_1y,in0_1z,in0_1w;
    float in2_1x,in2_1y,in2_1z,in2_1w;

    in1_1x = (1.0/6.0)*in[1*stride+0];
    in1_1y = (1.0/6.0)*in[1*stride+1];
    in1_1z = (1.0/6.0)*in[1*stride+2];
    in1_1w = (1.0/6.0)*in[1*stride+3];
    in0_1x = (1.0/6.0)*in[0*stride+0];
    in0_1y = (1.0/6.0)*in[0*stride+1];
    in0_1z = (1.0/6.0)*in[0*stride+2];
    in0_1w = (1.0/6.0)*in[0*stride+3];
    in2_1x = in[2*stride+0];
    in2_1y = in[2*stride+1];
    in2_1z = in[2*stride+2];
    in2_1w = in[2*stride+3];

    in[0*stride+0] = in[1*stride+0];
    in[0*stride+1] = in[1*stride+1];
    in[0*stride+2] = in[1*stride+2];
    in[0*stride+3] = in[1*stride+3];
    in[1*stride+0] = -in0_1x + in[1*stride+0] +  (1.0/6.0)*in[2*stride+0];
    in[1*stride+1] = -in0_1y + in[1*stride+1] +  (1.0/6.0)*in[2*stride+1];
    in[1*stride+2] = -in0_1z + in[1*stride+2] +  (1.0/6.0)*in[2*stride+2];
    in[1*stride+3] = -in0_1w + in[1*stride+3] +  (1.0/6.0)*in[2*stride+3];
    in[2*stride+0] =  in1_1x + in[2*stride+0] + -(1.0/6.0)*in[3*stride+0];
    in[2*stride+1] =  in1_1y + in[2*stride+1] + -(1.0/6.0)*in[3*stride+1];
    in[2*stride+2] =  in1_1z + in[2*stride+2] + -(1.0/6.0)*in[3*stride+2];
    in[2*stride+3] =  in1_1w + in[2*stride+3] + -(1.0/6.0)*in[3*stride+3];
    in[3*stride+0] = in2_1x;
    in[3*stride+1] = in2_1y;
    in[3*stride+2] = in2_1z;
    in[3*stride+3] = in2_1w;

}


__inline void bsp2bez5(float *in, int stride) {
    float in2_66x,in2_66y,in2_66z,in2_66w;
    float in3_66x,in3_66y,in3_66z,in3_66w;
    float in1_1x,in1_1y,in1_1z,in1_1w;
    float in2_48x,in2_48y,in2_48z,in2_48w;
    float in2_36x,in2_36y,in2_36z,in2_36w;

    in2_66x = (66.0f/120.0f)*in[2*stride+0]; in2_66y = (66.0f/120.0f)*in[2*stride+1];
    in2_66z = (66.0f/120.0f)*in[2*stride+2]; in2_66w = (66.0f/120.0f)*in[2*stride+3];
    in3_66x = (66.0f/120.0f)*in[3*stride+0]; in3_66y = (66.0f/120.0f)*in[3*stride+1];
    in3_66z = (66.0f/120.0f)*in[3*stride+2]; in3_66w = (66.0f/120.0f)*in[3*stride+3];
    in1_1x =  (1.0f/120.0f)*in[1*stride+0];  in1_1y  = (1.0f/120.0f)*in[1*stride+1];
    in1_1z =  (1.0f/120.0f)*in[1*stride+2];  in1_1w  = (1.0f/120.0f)*in[1*stride+3];
    in2_48x = (48.0f/120.0f)*in[2*stride+0]; in2_48y =  (48.0f/120.0f)*in[2*stride+1];
    in2_48z = (48.0f/120.0f)*in[2*stride+2]; in2_48w = (48.0f/120.0f)*in[2*stride+3];
    in2_36x = (36.0f/120.0f)*in[2*stride+0]; in2_36y = (36.0f/120.0f)*in[2*stride+1];
    in2_36z = (36.0f/120.0f)*in[2*stride+2]; in2_36w = (36.0f/120.0f)*in[2*stride+3];

    //in[0] = (1.0f/120.0f)*in[0] + (26.0f/120.0f)*in[1]          + in2_66  + (26.0f/120.0f)*in[3]         + ( 1.0f/120.0f)*in[4];
    in[0] = (1.0f/120.0f)*in[0]   + (26.0f/120.0f)*in[1*stride+0] + in2_66x + (26.0f/120.0f)*in[3*stride+0] + ( 1.0f/120.0f)*in[4*stride+0];
    in[1] = (1.0f/120.0f)*in[1]   + (26.0f/120.0f)*in[1*stride+1] + in2_66y + (26.0f/120.0f)*in[3*stride+1] + ( 1.0f/120.0f)*in[4*stride+1];
    in[2] = (1.0f/120.0f)*in[2]   + (26.0f/120.0f)*in[1*stride+2] + in2_66z + (26.0f/120.0f)*in[3*stride+2] + ( 1.0f/120.0f)*in[4*stride+2];
    in[3] = (1.0f/120.0f)*in[3]   + (26.0f/120.0f)*in[1*stride+3] + in2_66w + (26.0f/120.0f)*in[3*stride+3] + ( 1.0f/120.0f)*in[4*stride+3];

    //move this up here to avoid conflicts on in place operations -- this ONLY works because pt5 is only used in the last pt calc and no where else
    //in[5] =         ( 1.0f/120.0f)*in[1]          + (26.0f/120.0f)*in[2]          + in3_66  + (26.0f/120.0f)*in[4]          + (1.0f/120.0f)*in[5];
    in[5*stride+0] =  in1_1x + (26.0f/120.0f)*in[2*stride+0] + in3_66x + (26.0f/120.0f)*in[4*stride+0] + (1.0f/120.0f)*in[5*stride+0];
    in[5*stride+1] =  in1_1y + (26.0f/120.0f)*in[2*stride+1] + in3_66y + (26.0f/120.0f)*in[4*stride+1] + (1.0f/120.0f)*in[5*stride+1];
    in[5*stride+2] =  in1_1z + (26.0f/120.0f)*in[2*stride+2] + in3_66z + (26.0f/120.0f)*in[4*stride+2] + (1.0f/120.0f)*in[5*stride+2];
    in[5*stride+3] =  in1_1w + (26.0f/120.0f)*in[2*stride+3] + in3_66w + (26.0f/120.0f)*in[4*stride+3] + (1.0f/120.0f)*in[5*stride+3];

    //in[1] =         (16.0f/120.0f)*in[1]          + in2_66  + (36.0f/120.0f)*in[3]          + ( 2.0f/120.0f)*in[4];
    in[1*stride+0] =  (16.0f/120.0f)*in[1*stride+0] + in2_66x + (36.0f/120.0f)*in[3*stride+0] + ( 2.0f/120.0f)*in[4*stride+0];
    in[1*stride+1] =  (16.0f/120.0f)*in[1*stride+1] + in2_66y + (36.0f/120.0f)*in[3*stride+1] + ( 2.0f/120.0f)*in[4*stride+1];
    in[1*stride+2] =  (16.0f/120.0f)*in[1*stride+2] + in2_66z + (36.0f/120.0f)*in[3*stride+2] + ( 2.0f/120.0f)*in[4*stride+2];
    in[1*stride+3] =  (16.0f/120.0f)*in[1*stride+3] + in2_66w + (36.0f/120.0f)*in[3*stride+3] + ( 2.0f/120.0f)*in[4*stride+3];

    //in[2] =         ( 8.0f/120.0f)*in[1]          + (60.0f/120.0f)*in[2]          + (48.0f/120.0f)*in[3]          + ( 4.0f/120.0f)*in[4];
    in[2*stride+0] =  in1_1x*8 + (60.0f/120.0f)*in[2*stride+0] + (48.0f/120.0f)*in[3*stride+0] + ( 4.0f/120.0f)*in[4*stride+0];
    in[2*stride+1] =  in1_1y*8 + (60.0f/120.0f)*in[2*stride+1] + (48.0f/120.0f)*in[3*stride+1] + ( 4.0f/120.0f)*in[4*stride+1];
    in[2*stride+2] =  in1_1z*8 + (60.0f/120.0f)*in[2*stride+2] + (48.0f/120.0f)*in[3*stride+2] + ( 4.0f/120.0f)*in[4*stride+2];
    in[2*stride+3] =  in1_1w*8 + (60.0f/120.0f)*in[2*stride+3] + (48.0f/120.0f)*in[3*stride+3] + ( 4.0f/120.0f)*in[4*stride+3];

    //in[3] =         ( 4.0f/120.0f)*in[1]          + (48.0f/120.0f)*in[2]          + (60.0f/120.0f)*in[3]          + ( 8.0f/120.0f)*in[4];
    in[3*stride+0] =  in1_1x*4 + in2_48x + (60.0f/120.0f)*in[3*stride+0] + ( 8.0f/120.0f)*in[4*stride+0];
    in[3*stride+1] =  in1_1y*4 + in2_48y + (60.0f/120.0f)*in[3*stride+1] + ( 8.0f/120.0f)*in[4*stride+1];
    in[3*stride+2] =  in1_1z*4 + in2_48z + (60.0f/120.0f)*in[3*stride+2] + ( 8.0f/120.0f)*in[4*stride+2];
    in[3*stride+3] =  in1_1w*4 + in2_48w + (60.0f/120.0f)*in[3*stride+3] + ( 8.0f/120.0f)*in[4*stride+3];

    //in[4] =         ( 2.0f/120.0f)*in[1]          + (36.0f/120.0f)*in[2]          + in3_66  + (16.0f/120.0f)*in[4];
    in[4*stride+0] =  in1_1x*2 + in2_36x + in3_66x + (16.0f/120.0f)*in[4*stride+0];
    in[4*stride+1] =  in1_1y*2 + in2_36y + in3_66y + (16.0f/120.0f)*in[4*stride+1];
    in[4*stride+2] =  in1_1z*2 + in2_36z + in3_66z + (16.0f/120.0f)*in[4*stride+2];
    in[4*stride+3] =  in1_1w*2 + in2_36w + in3_66w + (16.0f/120.0f)*in[4*stride+3];
}

//stride = 4 or 16;
// 4 ---> traverses across a row
//16 ---> traverses down a column
__inline void bsp2bez3(float *in, int stride) {
    float in1_4x,in1_4y,in1_4z,in1_4w;
    float in2_4x,in2_4y,in2_4z,in2_4w;
    float in1_2x,in1_2y,in1_2z,in1_2w;
    float in1_6x,in1_6y,in1_6z,in1_6w;

    in1_4x = (4.0f/6.0f) * in[stride+0];
    in1_4y = (4.0f/6.0f) * in[stride+1];
    in1_4z = (4.0f/6.0f) * in[stride+2];
    in1_4w = (4.0f/6.0f) * in[stride+3];

    in2_4x = (4.0f/6.0f) * in[2*stride+0];
    in2_4y = (4.0f/6.0f) * in[2*stride+1];
    in2_4z = (4.0f/6.0f) * in[2*stride+2];
    in2_4w = (4.0f/6.0f) * in[2*stride+3];

    in1_2x = (2.0f/6.0f) * in[stride+0];
    in1_2y = (2.0f/6.0f) * in[stride+1];
    in1_2z = (2.0f/6.0f) * in[stride+2];
    in1_2w = (2.0f/6.0f) * in[stride+3];

    in1_6x = in[stride+0];
    in1_6y = in[stride+1];
    in1_6z = in[stride+2];
    in1_6w = in[stride+3];

    // Note about precision:
    // We want to ensure that the same formulas give the same result, 
    // regardless of the order of input data.  Unfortunately, floating
    // point arithmetic is not associative, and hence we need to force
    // a consistent order of operations.  This is not possible in the 
    // general case without actually sorting your data, but here we make 
    // the observation that in any one formula, there are never more than
    // two components which could potentially be swapped (i.e., they
    // have the same scaling value).  We thus group components in this way.

    in[0] =          (1.0f/6.0f)*(in[0] + in[2*stride+0]) + in1_4x;  //x
    in[1] =          (1.0f/6.0f)*(in[1] + in[2*stride+1]) + in1_4y;  //y
    in[2] =          (1.0f/6.0f)*(in[2] + in[2*stride+2]) + in1_4z;  //z
    in[3] =          (1.0f/6.0f)*(in[3] + in[2*stride+3]) + in1_4w;  //w

    in[stride+0] =   in1_4x + (2.0f/6.0f) * in[2*stride+0];          //x
    in[stride+1] =   in1_4y + (2.0f/6.0f) * in[2*stride+1];          //y
    in[stride+2] =   in1_4z + (2.0f/6.0f) * in[2*stride+2];          //z
    in[stride+3] =   in1_4w + (2.0f/6.0f) * in[2*stride+3];          //w

    in[2*stride+0] = in1_2x + in2_4x;                                //x
    in[2*stride+1] = in1_2y + in2_4y;                                //y
    in[2*stride+2] = in1_2z + in2_4z;                                //z
    in[2*stride+3] = in1_2w + in2_4w;                                //w

    in[3*stride+0] = (1.0f/6.0f)*(in1_6x + in[3*stride+0]) + in2_4x; //x
    in[3*stride+1] = (1.0f/6.0f)*(in1_6y + in[3*stride+1]) + in2_4y; //y
    in[3*stride+2] = (1.0f/6.0f)*(in1_6z + in[3*stride+2]) + in2_4z; //z
    in[3*stride+3] = (1.0f/6.0f)*(in1_6w + in[3*stride+3]) + in2_4w; //w
}

void CPatch::convertCatmullRomToBezier(){
    int i;
    for(i=0; i < NV_PATCH_NUMBER_OF_ATTRIBS; i++){
        if(m_PatchData.evalEnables & (1<<i)){
            switch(m_dwOrder){
            case 1:
            case 2:
            case 4:
            case 5:
                nvAssert(0);    //we shouldn't ever get these.
                break;
            case 3:
                //convert cubic bezier patch.
                catrom2bez3(&scratch[i][0][0],  4);  //row1
                catrom2bez3(&scratch[i][4][0],  4);  //row2
                catrom2bez3(&scratch[i][8][0],  4);  //row3
                catrom2bez3(&scratch[i][12][0], 4);  //row4
                catrom2bez3(&scratch[i][0][0], 16);  //column 1
                catrom2bez3(&scratch[i][1][0], 16);  //column 2
                catrom2bez3(&scratch[i][2][0], 16);  //column 3
                catrom2bez3(&scratch[i][3][0], 16);  //column 4
                break;
            }
        }
    }
}

void CPatch::convertBsplineToBezier(){

    int i;
    for(i=0; i < NV_PATCH_NUMBER_OF_ATTRIBS; i++){
        if(m_PatchData.evalEnables & (1<<i)){
            switch(m_dwOrder){
            case 3:
                //convert cubic bezier patch.
                bsp2bez3(&scratch[i][0][0],  4);  //row1
                bsp2bez3(&scratch[i][4][0],  4);  //row2
                bsp2bez3(&scratch[i][8][0],  4);  //row3
                bsp2bez3(&scratch[i][12][0], 4);  //row4
                bsp2bez3(&scratch[i][0][0], 16);  //column 1
                bsp2bez3(&scratch[i][1][0], 16);  //column 2
                bsp2bez3(&scratch[i][2][0], 16);  //column 3
                bsp2bez3(&scratch[i][3][0], 16);  //column 4
                break;
            case 5:
                //convert quintic bezier patch.
                bsp2bez5(&scratch[i][0][0],  4);  //row1
                bsp2bez5(&scratch[i][6][0],  4);  //row2
                bsp2bez5(&scratch[i][12][0], 4);  //row3
                bsp2bez5(&scratch[i][18][0], 4);  //row4
                bsp2bez5(&scratch[i][24][0], 4);  //row1
                bsp2bez5(&scratch[i][30][0], 4);  //row2
                bsp2bez5(&scratch[i][0][0],  24);  //column1
                bsp2bez5(&scratch[i][1][0],  24);  //column2
                bsp2bez5(&scratch[i][2][0],  24);  //column3
                bsp2bez5(&scratch[i][3][0],  24);  //column4
                bsp2bez5(&scratch[i][4][0],  24);  //column5
                bsp2bez5(&scratch[i][5][0],  24);  //column6
                break;
            default:
                nvAssert(0);
                break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvpkrnl_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//      a pointer to a shared file
//
// **************************************************************************
#include "nvprecomp.h"
#include "..\..\..\common\VPE\src\nvpkrnl.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvPalette.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPalette.cpp
//   HW Palette routines.
//
//  History:
//      Daniel Rohrer   9/20/99
//
/********************************************************************/

#include "nvprecomp.h"
#pragma hdrstop

// IDirectDraw interface function callback through HAL
// Microsoft says they won't ever give us this.. callback despite
// the fact that it is exposed the ddrawi.h
DWORD __stdcall CreatePalette32(LPDDHAL_CREATEPALETTEDATA lpCreatePaletteData)
{
    dbgTracePush("CreatePalette32");
    assert(0);
    dbgTracePop();

    return (DDHAL_DRIVER_HANDLED);
}

// IDirectDrawPalette interface function callback through HAL
// set's the palette entries for the current palette
// Microsoft says they won't ever give us this.. callback despite
// the fact that it is exposed the ddrawi.h
DWORD __stdcall SetEntries32(LPDDHAL_SETENTRIESDATA lpDDSetEntriesData)
{
    dbgTracePush("SetEntries32");
    assert(0);
    dbgTracePop();

    return (DDHAL_DRIVER_HANDLED);
}

// IDirectDrawSurface interface function callback through HAL
// binds a palette object to the surface in question --
// Microsoft says they won't ever give us this.. callback despite
// the fact that it is exposed the ddrawi.h
DWORD __stdcall SetPalette32(LPDDHAL_SETPALETTEDATA lpDDSetPaletteData)
{
    dbgTracePush("SetPalette32");
    assert(0);
    dbgTracePop();

    return (DDHAL_DRIVER_HANDLED);
}

// This function is defined in the callback struct unlike the GetEntries but isn't
// described in the DX7 Help files, I'm assuming this call isn't for the general user
// but is a notification from Microsoft that we should clean up after ourselves in
// any data structures we might have lying around.
// Microsoft says they won't ever give us this.. callback despite
// the fact that it is exposed the ddrawi.h
DWORD __stdcall DestroyPalette32(LPDDHAL_DESTROYPALETTEDATA lpDDDestroyPaletteData)
{
    dbgTracePush("DestroyPalette32");
    assert(0);
    dbgTracePop();

    return (DDHAL_DRIVER_HANDLED);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvPoint.cpp ===
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvPoint.cpp                                                       *
*   The Direct3D point rendering routines.                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       04/12/97 - created                      *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"


#if (NVARCH >= 0x04)

//-------------------------------------------------------------------------

/*
 * Non-Indexed TLVertex Point Lists.
 * This routine renders the specified number of points starting
 * with the vertex pointed to by lpVertices.
 * lpVertices is assumed to point to the first point to be rendered.
 */
void nvDrawPointList
(
    NV_INNERLOOP_ARGLIST
)
{
    DWORD           dwControl;
    DWORD           dwOldCull;
    D3DTLVERTEX     PointVerts[4];

    dbgTracePush ("nvDrawPointList");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;
    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&PointVerts[0]), 4*sizeof(D3DTLVERTEX), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLEFAN;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 4 * sizeof(D3DTLVERTEX);

    LPD3DTLVERTEX pVertices = (LPD3DTLVERTEX)(pVertexBufferBase + dwVertexBufferOffset);

    // Calculate the new hardware state if neccessary.
    if (pContext->bStateChange) {
        if (pContext->bUseDX6Class){
            nvSetMultiTextureHardwareState (pContext);
            if (pContext->bUseDX6Class) {
                nvSetHardwareState (pContext);
            }
        }
        else {
            nvSetHardwareState (pContext);
        }
    }

    // Disable lower level culling while drawing lines.
    dwControl = pContext->ctxInnerLoop.dwControl;
    pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
    pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
    dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
    pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

    // Force first call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);

    // Draw all points.
    while (dwCount--)
    {
        // Render each point as a POINT_SIZE square

        // replicate the data
        PointVerts[0] = *pVertices;
        PointVerts[1] = *pVertices;
        PointVerts[2] = *pVertices;
        PointVerts[3] = *pVertices;

        // adjust vertex 0
        PointVerts[0].sx -= HALF_POINT_SIZE;
        PointVerts[0].sy -= HALF_POINT_SIZE;
        // adjust vertex 1
        PointVerts[1].sx -= HALF_POINT_SIZE;
        PointVerts[1].sy += HALF_POINT_SIZE;
        // adjust vertex 2
        PointVerts[2].sx += HALF_POINT_SIZE;
        PointVerts[2].sy += HALF_POINT_SIZE;
        // adjust vertex 3
        PointVerts[3].sx += HALF_POINT_SIZE;
        PointVerts[3].sy -= HALF_POINT_SIZE;

        nvTriangleDispatch (pContext, 2);

        pVertices++;
    }

    // Restore cull mode
    pContext->ctxInnerLoop.dwControl = dwControl;
    pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force next render call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------

DWORD nvRenderPoint
(
    NV_INNERLOOP_ARGLIST
)
{
    nvDrawPointList (NV_INNERLOOP_ARGS);
    return (DD_OK);
}

//-------------------------------------------------------------------------

void nvDrawPointTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    D3DTLVERTEX PointVerts[4];
    DWORD       adwIndex[3], dwIndex;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    dbgTracePush ("nvDrawPointTriangle");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&PointVerts[0]), 4*sizeof(D3DTLVERTEX), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLEFAN;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 4 * sizeof(D3DTLVERTEX);

    if (dwCount)
    {
        LPD3DTLVERTEX pVertices = (LPD3DTLVERTEX)(pVertexBufferBase + dwVertexBufferOffset);
        DWORD         dwStrides = nv4DP2OpToStride[dwCachedDP2Op];

        // Calculate the new hardware state if neccessary
        if (pContext->bStateChange) {
            if (pContext->bUseDX6Class) {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class) {
                    nvSetHardwareState (pContext);
                }
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable lower level culling while drawing lines
        dwControl = pContext->ctxInnerLoop.dwControl;
        pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Calculate the culling masks.
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        // Force first call to be to the triangle state setup routine
        NV_FORCE_TRI_SETUP(pContext);

        dwStrides     &= 0xffffff; // mask interesting bits
        dwIndex1       = 0;
        dwIndex2       = 1;
        dwIndexStrides = dwStrides;

        // draw all triangles
        while (dwCount--)
        {
            adwIndex[0] = dwIndex1;
            adwIndex[1] = dwIndex2 + (dwIndexStrides >> 24);
            adwIndex[2] = dwIndex2 + ((dwIndexStrides >> 24) ^ 1);

            // Move on to the next triangle.
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            // Since culling needs to be disabled to insure that the triangle edges get drawn properly,
            // back face culling of the triangle needs to be performed up front by software.
            IF_NOT_CULLED_BEGIN((DWORD)&pVertices[adwIndex[0]],(DWORD)&pVertices[adwIndex[1]],(DWORD)&pVertices[adwIndex[2]],dwCullValue)

                // draw each vertex, expanding it to a POINT_SIZE square
                for (DWORD dwVert=0; dwVert<3; dwVert++) {

                    dwIndex = adwIndex[dwVert];

                    // replicate the data
                    PointVerts[0] = pVertices[dwIndex];
                    PointVerts[1] = pVertices[dwIndex];
                    PointVerts[2] = pVertices[dwIndex];
                    PointVerts[3] = pVertices[dwIndex];

                    // adjust vertex 0
                    PointVerts[0].sx -= HALF_POINT_SIZE;
                    PointVerts[0].sy -= HALF_POINT_SIZE;
                    // adjust vertex 1
                    PointVerts[1].sx -= HALF_POINT_SIZE;
                    PointVerts[1].sy += HALF_POINT_SIZE;
                    // adjust vertex 2
                    PointVerts[2].sx += HALF_POINT_SIZE;
                    PointVerts[2].sy += HALF_POINT_SIZE;
                    // adjust vertex 3
                    PointVerts[3].sx += HALF_POINT_SIZE;
                    PointVerts[3].sy -= HALF_POINT_SIZE;

                    // draw
                    nvTriangleDispatch (pContext, 2);
                }

            IF_NOT_CULLED_END
        }

        // Restore the culling mode.
        pContext->ctxInnerLoop.dwControl = dwControl;
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force first call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------

void nvIndexedPointTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    D3DTLVERTEX PointVerts[4];
    DWORD       adwIndex[3], dwIndex;
    DWORD       dwControl;
    DWORD       dwOldCull;
    PBYTE       pIndex1, pIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    dbgTracePush ("nvIndexedPointTriangle");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&PointVerts[0]), 4*sizeof(D3DTLVERTEX), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLEFAN;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 4 * sizeof(D3DTLVERTEX);

    if (dwCount)
    {
        LPD3DTLVERTEX pVertices = (LPD3DTLVERTEX)(pVertexBufferBase + dwVertexBufferOffset);
        LPWORD        pIndices  = (LPWORD)(pContext->dp2.dwIndices);
        DWORD         dwStrides = nv4DP2OpToStride[dwCachedDP2Op];

        pContext->dp2.dwIndices = NULL;

        // Calculate the new hardware state if neccessary.
        if (pContext->bStateChange) {
            if (pContext->bUseDX6Class) {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class) {
                    nvSetHardwareState (pContext);
                }
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable lower level culling while drawing lines.
        dwControl = pContext->ctxInnerLoop.dwControl;
        pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Calculate the culling masks.
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        // Force first call to be to the triangle state setup routine.
        NV_FORCE_TRI_SETUP(pContext);

        dwStrides     &= 0xffffff; // mask interesting bits
        pIndex1        = (PBYTE)pIndices;
        pIndex2        = (PBYTE)pIndices + 2;
        dwIndexStrides = dwStrides * 2;

        // draw all triangles
        while (dwCount--)
        {
            adwIndex[0] = *(WORD*)(pIndex1);
            adwIndex[1] = *(WORD*)(pIndex2 +  (dwIndexStrides >> 24));
            adwIndex[2] = *(WORD*)(pIndex2 + ((dwIndexStrides >> 24) ^ 2));

            // Move on to the next triangle.
            pIndex1        += (BYTE)(dwIndexStrides >> 8);
            pIndex2        += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            // Since culling needs to be disabled to insure that the triangle edges get drawn properly,
            // back face culling of the triangle needs to be performed up front by software.
            IF_NOT_CULLED_BEGIN((DWORD)&pVertices[adwIndex[0]],(DWORD)&pVertices[adwIndex[1]],(DWORD)&pVertices[adwIndex[2]],dwCullValue)

            // draw each vertex, expanding it to a POINT_SIZE square
            for (DWORD dwVert=0; dwVert<3; dwVert++) {

                dwIndex = adwIndex[dwVert];

                // replicate the data
                PointVerts[0] = pVertices[dwIndex];
                PointVerts[1] = pVertices[dwIndex];
                PointVerts[2] = pVertices[dwIndex];
                PointVerts[3] = pVertices[dwIndex];

                // adjust vertex 0
                PointVerts[0].sx -= HALF_POINT_SIZE;
                PointVerts[0].sy -= HALF_POINT_SIZE;
                // adjust vertex 1
                PointVerts[1].sx -= HALF_POINT_SIZE;
                PointVerts[1].sy += HALF_POINT_SIZE;
                // adjust vertex 2
                PointVerts[2].sx += HALF_POINT_SIZE;
                PointVerts[2].sy += HALF_POINT_SIZE;
                // adjust vertex 3
                PointVerts[3].sx += HALF_POINT_SIZE;
                PointVerts[3].sy -= HALF_POINT_SIZE;

                // draw
                nvTriangleDispatch (pContext, 2);
            }

            IF_NOT_CULLED_END
        }

        // Restore the culling mode.
        pContext->ctxInnerLoop.dwControl = dwControl;
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force first call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------

/*
 * Non-Indexed Flexible Vertex Format Point Lists.
 * This routine renders the specified number of points starting
 * with the vertex pointed to by pVertices.
 * pVertices is assumed to point to the first point to be rendered.
 */
void nvFVFDrawPointList
(
    NV_INNERLOOP_ARGLIST
)
{
    BYTE          PointVerts[4 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    BYTE         *pPointVert[4];
    BYTE         *pVert0;
    DWORD         i, dwDwordsPerVert;
    DWORD         dwControl;
    DWORD         dwOldCull;
    DWORD         dwVertexStride;

    dbgTracePush ("nvFVFDrawPointList");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&PointVerts[0]), 4*((sizeof(D3DTLVERTEX))+(7*2*4)), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLEFAN;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 4 * ((sizeof(D3DTLVERTEX)) + (7*2*4));

    LPBYTE pVertices = pVertexBufferBase + dwVertexBufferOffset;

    // Calculate the new hardware state if neccessary.
    if (pContext->bStateChange) {
        if (pContext->bUseDX6Class) {
            nvSetMultiTextureHardwareState (pContext);
            if (pContext->bUseDX6Class) {
                nvSetHardwareState (pContext);
            }
        }
        else {
            nvSetHardwareState (pContext);
        }
    }

    // Disable lower level culling while drawing lines.
    if (!pContext->bUseDX6Class) {
        dwControl = pContext->ctxInnerLoop.dwControl;
        pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
    }
    else {
        dwControl = pContext->mtsState.dwControl0;
        pContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
        pContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
    }
    dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
    pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

    // Force first call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);

    dwVertexStride  = pContext->pCurrentVShader->getStride();
    dwDwordsPerVert = pContext->pCurrentVShader->getStride() >> 2;

    // get pointers to each of the 4 FVF point vertices.
    GET_FVF_POINTER (pPointVert[0], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 0, pContext->pCurrentVShader->getStride());
    GET_FVF_POINTER (pPointVert[1], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 1, pContext->pCurrentVShader->getStride());
    GET_FVF_POINTER (pPointVert[2], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 2, pContext->pCurrentVShader->getStride());
    GET_FVF_POINTER (pPointVert[3], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 3, pContext->pCurrentVShader->getStride());

    // Render each point as a POINT_SIZE square
    while (dwCount--)
    {
        // Get pointers to the vertex of current point.
        GET_FVF_POINTER (pVert0, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 0, pContext->pCurrentVShader->getStride());

        pVertices += dwVertexStride;

        // replicate the vertex data
        for (i = 0; i < dwDwordsPerVert; i++) {
            DWORD dwValue;
            dwValue = ((DWORD *)pVert0)[i];
            ((DWORD *)(pPointVert[0]))[i] = dwValue;
            ((DWORD *)(pPointVert[1]))[i] = dwValue;
            ((DWORD *)(pPointVert[2]))[i] = dwValue;
            ((DWORD *)(pPointVert[3]))[i] = dwValue;
        }

        // adjust vertex 0
        ((LPD3DTLVERTEX)(pPointVert[0]))->sx -= HALF_POINT_SIZE;
        ((LPD3DTLVERTEX)(pPointVert[0]))->sy -= HALF_POINT_SIZE;
        // adjust vertex 1
        ((LPD3DTLVERTEX)(pPointVert[1]))->sx -= HALF_POINT_SIZE;
        ((LPD3DTLVERTEX)(pPointVert[1]))->sy += HALF_POINT_SIZE;
        // adjust vertex 2
        ((LPD3DTLVERTEX)(pPointVert[2]))->sx += HALF_POINT_SIZE;
        ((LPD3DTLVERTEX)(pPointVert[2]))->sy += HALF_POINT_SIZE;
        // adjust vertex 3
        ((LPD3DTLVERTEX)(pPointVert[3]))->sx += HALF_POINT_SIZE;
        ((LPD3DTLVERTEX)(pPointVert[3]))->sy -= HALF_POINT_SIZE;

        nvTriangleDispatch (pContext, 2);

    }  // while (dwCount)

    // Restore cull mode.
    if (!pContext->bUseDX6Class)
        pContext->ctxInnerLoop.dwControl = dwControl;
    else
        pContext->mtsState.dwControl0 = dwControl;
    pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force next render call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------

void nvFVFDrawPointTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    BYTE        PointVerts[4 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    BYTE       *pPointVert[4];
    BYTE       *pVert[3];
    DWORD       i, dwDwordsPerVert;
    DWORD       adwIndex[3];
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    dbgTracePush ("nvFVFDrawPointTriangle");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&PointVerts[0]), 4*((sizeof(D3DTLVERTEX))+(7*2*4)), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLEFAN;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 4 * ((sizeof(D3DTLVERTEX)) + (7*2*4));

    if (dwCount)
    {
        LPBYTE pVertices = pVertexBufferBase + dwVertexBufferOffset;
        DWORD  dwStrides = nv4DP2OpToStride[dwCachedDP2Op];

        // Calculate the new hardware state if neccessary.
        if (pContext->bStateChange) {
            if (pContext->bUseDX6Class) {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class) {
                    nvSetHardwareState (pContext);
                }
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable lower level culling while drawing lines.
        if (!pContext->bUseDX6Class) {
            dwControl = pContext->ctxInnerLoop.dwControl;
            pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else {
            dwControl = pContext->mtsState.dwControl0;
            pContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Calculate the culling masks.
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        // Force first call to be to the triangle state setup routine.
        NV_FORCE_TRI_SETUP(pContext);

        dwStrides      &= 0xffffff; // mask interesting bits
        dwIndex1        = 0;
        dwIndex2        = 1;
        dwIndexStrides  = dwStrides;
        dwDwordsPerVert = pContext->pCurrentVShader->getStride() >> 2;

        // Get pointers to each of the 9 FVF point triangle vertices.
        GET_FVF_POINTER (pPointVert[0], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 0, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pPointVert[1], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 1, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pPointVert[2], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 2, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pPointVert[3], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 3, pContext->pCurrentVShader->getStride());

        // draw all triangles
        while (dwCount--)
        {
            adwIndex[0] = dwIndex1;
            adwIndex[1] = dwIndex2 + (dwIndexStrides >> 24);
            adwIndex[2] = dwIndex2 + ((dwIndexStrides >> 24) ^ 1);

            // Move on to the next triangle.
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            // Get a pointer to triangle vertex
            GET_FVF_POINTER (pVert[0], pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), adwIndex[0], pContext->pCurrentVShader->getStride());
            GET_FVF_POINTER (pVert[1], pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), adwIndex[1], pContext->pCurrentVShader->getStride());
            GET_FVF_POINTER (pVert[2], pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), adwIndex[2], pContext->pCurrentVShader->getStride());

            // Since culling needs to be disabled to insure that the triangle edges get drawn properly,
            // back face culling of the triangle needs to be performed up front by software.
            IF_NOT_CULLED_BEGIN(pVert[0],pVert[1],pVert[2],dwCullValue)

                // draw each vertex, expanding it to a POINT_SIZE square
                for (DWORD dwVert=0; dwVert<3; dwVert++) {

                    // replicate data
                    for (i=0; i < dwDwordsPerVert; i++) {
                        DWORD dwValue;
                        dwValue = ((DWORD *)pVert[dwVert])[i];
                        ((DWORD *)(pPointVert[0]))[i] = dwValue;
                        ((DWORD *)(pPointVert[1]))[i] = dwValue;
                        ((DWORD *)(pPointVert[2]))[i] = dwValue;
                        ((DWORD *)(pPointVert[3]))[i] = dwValue;
                    }

                    // adjust vertex 0
                    ((LPD3DTLVERTEX)(pPointVert[0]))->sx -= HALF_POINT_SIZE;
                    ((LPD3DTLVERTEX)(pPointVert[0]))->sy -= HALF_POINT_SIZE;
                    // adjust vertex 1
                    ((LPD3DTLVERTEX)(pPointVert[1]))->sx -= HALF_POINT_SIZE;
                    ((LPD3DTLVERTEX)(pPointVert[1]))->sy += HALF_POINT_SIZE;
                    // adjust vertex 2
                    ((LPD3DTLVERTEX)(pPointVert[2]))->sx += HALF_POINT_SIZE;
                    ((LPD3DTLVERTEX)(pPointVert[2]))->sy += HALF_POINT_SIZE;
                    // adjust vertex 3
                    ((LPD3DTLVERTEX)(pPointVert[3]))->sx += HALF_POINT_SIZE;
                    ((LPD3DTLVERTEX)(pPointVert[3]))->sy -= HALF_POINT_SIZE;

                    // draw
                    nvTriangleDispatch (pContext, 2);
                }

            IF_NOT_CULLED_END
        }

        // Restore the culling mode.
        if (!pContext->bUseDX6Class)
            pContext->ctxInnerLoop.dwControl = dwControl;
        else
            pContext->mtsState.dwControl0 = dwControl;

        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force first call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------

void nvFVFIndexedPointTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    BYTE        PointVerts[4 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    BYTE       *pPointVert[4];
    BYTE       *pVert[3];
    DWORD       i, dwDwordsPerVert;
    DWORD       adwIndex[3];
    DWORD       dwControl;
    DWORD       dwOldCull;
    PBYTE       pIndex1, pIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    dbgTracePush ("nvFVFIndexedPointTriangle");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&PointVerts[0]), 4*((sizeof(D3DTLVERTEX))+(7*2*4)), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLEFAN;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 4 * ((sizeof(D3DTLVERTEX)) + (7*2*4));

    if (dwCount)
    {
        LPBYTE pVertices = pVertexBufferBase + dwVertexBufferOffset;
        LPWORD pIndices  = (LPWORD)(pContext->dp2.dwIndices);
        DWORD  dwStrides = nv4DP2OpToStride[dwCachedDP2Op];

        pContext->dp2.dwIndices = NULL;

        // Calculate the new hardware state if neccessary.
        if (pContext->bStateChange) {
            if (pContext->bUseDX6Class) {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class) {
                    nvSetHardwareState (pContext);
                }
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable lower level culling while drawing lines.
        if (!pContext->bUseDX6Class) {
            dwControl = pContext->ctxInnerLoop.dwControl;
            pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else {
            dwControl = pContext->mtsState.dwControl0;
            pContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Calculate the culling masks.
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        // Force first call to be to the triangle state setup routine.
        NV_FORCE_TRI_SETUP(pContext);

        dwStrides      &= 0xffffff; // mask interesting bits
        pIndex1         = (PBYTE)pIndices;
        pIndex2         = (PBYTE)pIndices + 2;
        dwIndexStrides  = dwStrides * 2;
        dwDwordsPerVert = pContext->pCurrentVShader->getStride() >> 2;

        // Get pointers to each of the 4 FVF point triangle vertices.
        GET_FVF_POINTER (pPointVert[0], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 0, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pPointVert[1], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 1, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pPointVert[2], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 2, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pPointVert[3], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 3, pContext->pCurrentVShader->getStride());

        // draw all triangles
        while (dwCount--)
        {
            adwIndex[0] = *(WORD*)(pIndex1);
            adwIndex[1] = *(WORD*)(pIndex2 +  (dwIndexStrides >> 24));
            adwIndex[2] = *(WORD*)(pIndex2 + ((dwIndexStrides >> 24) ^ 2));

            // Move on to the next triangle.
            pIndex1        += (BYTE)(dwIndexStrides >> 8);
            pIndex2        += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            // Get pointers to each vertex of current triangle.
            GET_FVF_POINTER (pVert[0], pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), adwIndex[0], pContext->pCurrentVShader->getStride());
            GET_FVF_POINTER (pVert[1], pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), adwIndex[1], pContext->pCurrentVShader->getStride());
            GET_FVF_POINTER (pVert[2], pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), adwIndex[2], pContext->pCurrentVShader->getStride());

            // Since culling needs to be disabled to insure that the triangle edges get drawn properly,
            // back face culling of the triangle needs to be performed up front by software.
            IF_NOT_CULLED_BEGIN(pVert[0],pVert[1],pVert[2],dwCullValue)

                // draw each vertex, expanding it to a POINT_SIZE square
                for (DWORD dwVert=0; dwVert<3; dwVert++) {

                    // replicate data
                    for (i=0; i < dwDwordsPerVert; i++) {
                        DWORD dwValue;
                        dwValue = ((DWORD *)pVert[dwVert])[i];
                        ((DWORD *)(pPointVert[0]))[i] = dwValue;
                        ((DWORD *)(pPointVert[1]))[i] = dwValue;
                        ((DWORD *)(pPointVert[2]))[i] = dwValue;
                        ((DWORD *)(pPointVert[3]))[i] = dwValue;
                    }

                    // adjust vertex 0
                    ((LPD3DTLVERTEX)(pPointVert[0]))->sx -= HALF_POINT_SIZE;
                    ((LPD3DTLVERTEX)(pPointVert[0]))->sy -= HALF_POINT_SIZE;
                    // adjust vertex 1
                    ((LPD3DTLVERTEX)(pPointVert[1]))->sx -= HALF_POINT_SIZE;
                    ((LPD3DTLVERTEX)(pPointVert[1]))->sy += HALF_POINT_SIZE;
                    // adjust vertex 2
                    ((LPD3DTLVERTEX)(pPointVert[2]))->sx += HALF_POINT_SIZE;
                    ((LPD3DTLVERTEX)(pPointVert[2]))->sy += HALF_POINT_SIZE;
                    // adjust vertex 3
                    ((LPD3DTLVERTEX)(pPointVert[3]))->sx += HALF_POINT_SIZE;
                    ((LPD3DTLVERTEX)(pPointVert[3]))->sy -= HALF_POINT_SIZE;

                    // draw
                    nvTriangleDispatch (pContext, 2);

                }

            IF_NOT_CULLED_END

        }

        // Restore the culling mode.
        if (!pContext->bUseDX6Class)
            pContext->ctxInnerLoop.dwControl = dwControl;
        else
            pContext->mtsState.dwControl0 = dwControl;

        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force first call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);

    dbgTracePop();
    return;
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvprecomp.cpp ===
#include "nvprecomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvpopupagent.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION
//
// Module: nvPopupAgent.h
//
// Description: implements CPopupAgent class being declared in common/PopupAgent.h
//				that works with the NVIDIA Stereo Driver.
//            
///////////////////////////////////////////////////////////////////////////////
//                                                               
// History:                                                                  
//       02/16/01  Created       
//                         
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////
#include "nvprecomp.h"
#include "nvPopupList.h"

#ifndef WINNT
	#define IMPLEMENT_POPUP_AGENT
#endif //WINNT

#ifdef IMPLEMENT_POPUP_AGENT

///////////////////////////////////////////////////////////////////////////////////////////////////
//export stuff from nvStereo.cpp

//data/events/errors logging
extern void __cdecl LOG(char * szFormat, ...);
//stereo configuration -- need it for statistics
extern CONFIG_ASSIST_INFO ConfigAssistInfo;
///////////////////////////////////////////////////////////////////////////////////////////////////
CPopupAgent*	popupAgentList=0; 
///////////////////////////////////////////////////////////////////////////////////////////////////
#define DEFAULT_MODULE_NAME "nvstres.dll"
///////////////////////////////////////////////////////////////////////////////////////////////////
CPopupAgent::CPopupAgent()
{
	pTexture=0;
	pTextureObj=0;
	pContext=0;
	hMod=0;

	pVB=0;
	pVS=0;

	HRESULT rc=createVertexData();
}
///////////////////////////////////////////////////////////////////////////////////////////////////
CPopupAgent::~CPopupAgent()
{
	destroyTexture();
	destroyVertexData();
}
///////////////////////////////////////////////////////////////////////////////////////////////////
#define SAFE_DELETE(p)  if(p) {delete p;p=0;}
#define SAFE_RELEASE(p) if(p) {p->release();p=0;}
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef struct PopupStateSet_s
{
    DWORD state;
    DWORD value;
    DWORD oldvalue;
} PopupStateSet;
///////////////////////////////////////////////////////////////////////////////////////////////////
static PopupStateSet popupStatesSolid[] =
{
//for non-textured:
		{ D3DRENDERSTATE_CULLMODE,         D3DCULL_NONE             ,0},
		{ D3DRENDERSTATE_ZFUNC,            D3DCMP_ALWAYS            ,0},
		{ D3DRENDERSTATE_ALPHAFUNC,        D3DCMP_ALWAYS            ,0},
		{ D3DRENDERSTATE_ALPHABLENDENABLE, FALSE                    ,0},
		{ D3DRENDERSTATE_STENCILENABLE,    FALSE                    ,0},
		{ D3DRENDERSTATE_FILLMODE,         D3DFILL_SOLID            ,0},
		{ D3DRENDERSTATE_FOGENABLE,        FALSE                    ,0},
		{ D3DRENDERSTATE_TEXTUREMAPBLEND,  D3DPTBLENDCAPS_MODULATE  ,0},
		{ D3DRENDERSTATE_SPECULARENABLE,   FALSE                    ,0},
		//-------<< terminator HAS TO BE HERE >>-------------------------
		{0,0},
};
///////////////////////////////////////////////////////////////////////////////////////////////////
static PopupStateSet popupStatesTextured[] =
{
//for textured:
    { D3DRENDERSTATE_CULLMODE,         D3DCULL_NONE             ,0},
    { D3DRENDERSTATE_ZFUNC,            D3DCMP_ALWAYS            ,0},
    { D3DRENDERSTATE_ALPHAFUNC,        D3DCMP_ALWAYS            ,0},
    { D3DRENDERSTATE_ALPHABLENDENABLE, TRUE                     ,0},
    { D3DRENDERSTATE_SRCBLEND,         D3DBLEND_SRCALPHA        ,0},
    { D3DRENDERSTATE_DESTBLEND,        D3DBLEND_INVSRCALPHA     ,0},
    { D3DRENDERSTATE_WRAP0,            0                        ,0},
	{ D3DRENDERSTATE_STENCILENABLE,    FALSE                    ,0},
    { D3DRENDERSTATE_FILLMODE,         D3DFILL_SOLID            ,0},
    { D3DRENDERSTATE_FOGENABLE,        FALSE                    ,0},
    { D3DRENDERSTATE_WRAPU,            0                        ,0},
    { D3DRENDERSTATE_WRAPV,            0                        ,0},
    { D3DRENDERSTATE_TEXTUREMAPBLEND,  D3DPTBLENDCAPS_MODULATE  ,0},
    { D3DRENDERSTATE_SPECULARENABLE,   FALSE                    ,0},
	//-------<< terminator HAS TO BE HERE >>-------------------------
	{0,0}
};
///////////////////////////////////////////////////////////////////////////////////////////////////
static NVD3DTEXSTAGESTATE tssPrevState[2];
///////////////////////////////////////////////////////////////////////////////////////////////////
void CPopupAgent::destroyTexture()
{
	SAFE_RELEASE(pTextureObj);
	pTexture=0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void CPopupAgent::destroyVertexData()
{
	SAFE_DELETE(pVB);
	SAFE_DELETE(pVS);
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CPopupAgent::createVertexData()
{
    pVB = new CVertexBuffer;
    if (!pVB) 
	{
        DPF("Unable to create popup vertex buffer");
        nvAssert(0);
        return E_FAIL;
    }

    pVS = new CVertexShader;
    if (!pVS) 
	{
        DPF("Unable to create popup vertex shader");
        nvAssert(0);
        return E_FAIL;
    }
	return S_OK;
}

// load library and call Init ////////////////////////////////////////////////////////////////////////
//
// [in] const char* module -- module name
//
//////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CPopupAgent::bindPopupAgent( HMODULE hmod )
{
	nvAssert(hmod);
	hMod = hmod;

	InitPopupAgentType		pInitPopupAgent=0;
	pInitPopupAgent   = (InitPopupAgentType)    GetProcAddress(hMod, "InitPopupAgent");
	
	nvAssert(pInitPopupAgent);

	if(pInitPopupAgent)
		pInitPopupAgent(this);

	//assert whether it's a valid popup
	nvAssert(m_pFlipCallback);
	
	return S_OK;
}
// call DestroyPopup and free library ////////////////////////////////////////////////////////////
HRESULT CPopupAgent::unbindPopupAgent( )
{
	
	if(!hMod) 
	{
		DPF("CPopupAgent: trying to unbind non-loaded library" );
		nvAssert(0);
		return E_FAIL;
	}
	
	DestroyPopupAgentType	pDestroyPopupAgent=0;
	pDestroyPopupAgent= (DestroyPopupAgentType) GetProcAddress(hMod, "DestroyPopupAgent");
	
	nvAssert(pDestroyPopupAgent);
	
	if(pDestroyPopupAgent)
		pDestroyPopupAgent(this);
	
	hMod = 0;
	
	return S_OK;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CPopupAgent::CreateTextureMap(DWORD dwWidth, DWORD dwHeight, DWORD dwColorKey, unsigned short *pusData)
{
	DWORD				hei=dwHeight;
	DWORD				wid=dwWidth;
	DWORD				pitch;
	WORD				wColorKey;
	DWORD				opaque = 0xFF000000;
	DWORD*				cp=0;				//current texel
	unsigned short*		source=pusData;		//source of texels (16 bpp anticipated)
	DWORD				i,j;

	//alternatively, we can bail out here if texture has been already created
	destroyTexture();

/////////////////////////////////////////////////////////////////////////////////////
//#define	TEST_CREATE_POPUP_TEXTURE
#ifdef	TEST_CREATE_POPUP_TEXTURE
		const T_W=32;
		const T_H=32;
		static unsigned short test[T_W*T_H];

		//some nice pattern:
		for(i=0; i<T_W*T_H; i++) 
			test[i]= ((i&T_W<<2) | ~(i&T_H))<<4; 

		//now, concoct parameters:
		wid = T_W;
		hei = T_H;
		wColorKey = 0;
		source = test;
#endif	//TEST_CREATE_POPUP_TEXTURE
/////////////////////////////////////////////////////////////////////////////////////

	pTexture = new CTexture;
	if (!pTexture)
	{
		DPF("CPopupAgent::CreateTextureMap: new CTexture failed");
		return E_FAIL;
	}

	pTextureObj = new CNvObject(0);
	if (!pTextureObj)
	{
		DPF("CPopupAgent::CreateTextureMap: new CNvObject failed");
		destroyTexture();
		return E_FAIL;
	}
#ifdef WINNT
    pTextureObj->setDDSLcl(NULL);
#endif

	pTextureObj->setObject(CNvObject::NVOBJ_TEXTURE, pTexture);

	BOOL rc = pTexture->create (pTextureObj, wid, hei, 1, 4, 4, 1, NV_SURFACE_FORMAT_A8R8G8B8,
									  CSimpleSurface::HEAP_VID, CSimpleSurface::HEAP_VID);

	if (!rc) // allocation failed
	{
		DPF("CPopupAgent::CreateTextureMap: Couldn't create texture for popup agent");
		destroyTexture();
		return E_FAIL;
	}

	//ready to copy content into texture surface 
    nvAssert(wid == pTexture->getWidth() && hei == pTexture->getHeight());
	
	//convert it to the 16-bit word
    wColorKey = (WORD)(((dwColorKey & 0xF80000) >> 8) | ((dwColorKey & 0xFC00) >> 5) | ((dwColorKey & 0xF8) >> 3));

	pitch = pTexture->getPitch() >> 2; //in 32 bit words

	pTexture->updateLinearSurface();
    
	cp = (DWORD *)pTexture->getLinear()->getAddress();

    nvAssert(cp && source);
	//copy with color keying
	for (i = 0; i < hei; i++ )
    {
        for (j = 0; j < wid; j++)
        {
            WORD c = source[j];

			if ( c == wColorKey) 
				cp[j] = 0;
			else
				cp[j] = (((DWORD)c & 0xF800) << 8) | (((DWORD)c & 0x07E0) << 5) | (((DWORD)c & 0x001F) << 2) | opaque;

			//cp[j] = (((DWORD)c & 0xF800) << 8) | (((DWORD)c & 0x07E0) << 5) | (((DWORD)c & 0x001F) << 2);
        }
		source += wid;
		cp += pitch;
    }
    pTexture->getLinear()->tagUpToDate();
    pTexture->getSwizzled()->tagOutOfDate();

	return S_OK;
}
//////////////////////////////////////////////////////////////////////////////////////////////
#define RENDER_POPUP_FALLBACK
//#define RENDER_POPUP_INDEXED
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef RENDER_POPUP_INDEXED
HRESULT CPopupAgent::RenderTriangles(Vertex *pVertexData, unsigned short *pusIndexData, int nIndexCount, DWORD dwFlags)
{

    // check if the context is valid
    if (!pContext) return E_FAIL;

    // check if we have a valid render target
    if (!pContext->pRenderTarget) return E_FAIL;

    // reject if the render target is a texture
    CNvObject *pNVObj = pContext->pRenderTarget->getWrapper();
    if (!pNVObj) return E_FAIL;
    if (pNVObj->getTexture()) return E_FAIL;

	DWORD		fvfCode = D3DFVF_POPUP_VERTEX;
	DWORD		vertexSize  = sizeof(Vertex);
	Vertex*		vertices = pVertexData;
	WORD*		indices = pusIndexData;		
	DWORD		triQty = nIndexCount/3;
	DWORD		vertexLength= triQty*2; //true only for special case
	
	int i,ind;
	Vertex v;
	int max_ind = 0;

	//static int dumpIt=0; int n=1;
	for(i=0; i<nIndexCount; i++)
	{
		ind = pusIndexData[i];
		v = pVertexData[ind];
		//figure out the number of vertices (assuming continuos indices) 
		if(max_ind<ind) max_ind = ind;
		
		//NB: debug stub
		/*
		if(dumpIt) 
		{
			if( !(i%3) ) LOG("--> %d", n++);
			LOG("v%d(ind=%d) = {%d, %d, %f, %d, %x, %x, %f, %f},",i,ind,(int)v.sx,(int)v.sy,v.sz,(int)v.rhw,v.color,v.specular,v.tu,v.tv);
		}
		*/
	}
	//NB: debug stub
	/*
	if(dumpIt) 
		LOG("indQty=%d,	max ind=%d, triQty=%d", nIndexCount, max_ind+1, triQty);
	++dumpIt;
	*/
	/**/
	//this is unsafe -- we should have it as an additional parameter
	//for straight case
	//vertexLength = max_ind+1;
	/**/
	nIndexCount = 3;
	triQty = nIndexCount/3;
	//vertexLength = triQty*2;
	/**/
///////////////////////////////////////////////////////////////////////////////////
//#define TEST_RENDER_TRIANGLE
#ifdef TEST_RENDER_TRIANGLE

    Vertex quad[] =
	{
		{0, 15, 0.9f, 1, 0, 0, 0.1094, 0.0146},{0, 0, 0.9f, 1, 0, 0, 0.1094, 0.0f},{7, 15, 0.9f, 1, 0, 0, 0.1162, 0.0146},
		{7, 0, 0.9f, 1, 0, 0, 0.1162, 0.0f},{7, 15, 0.9f, 1, 0, 0, 0.1162, 0.0146},{0, 0, 0.9f, 1, 0, 0, 0.1094, 0.0f},

		{7, 15, 0.9f, 1, 0, 0, 0.15625, 0.0146},{7, 0, 0.9f, 1, 0, 0, 0.15625, 0.0f},{14, 15, 0.9f, 1, 0, 0, 0.163, 0.0146},
		{14, 0, 0.9f, 1, 0, 0, 0.163, 0.0f},{14, 15, 0.9f, 1, 0, 0, 0.163, 0.0146},{7, 0, 0.9f, 1, 0, 0, 0.15625, 0.0f},

		{14, 15, 0.9f, 1, 0, 0, 0.086, 0.0146},{14, 0, 0.9f, 1, 0, 0, 0.086, 0.0f},{17, 15, 0.9f, 1, 0, 0, 0.0889, 0.0146},
		{17, 0, 0.9f, 1, 0, 0, 0.0889, 0.0f},{17, 15, 0.9f, 1, 0, 0, 0.0889, 0.0146},{14, 0, 0.9f, 1, 0, 0, 0.086, 0.0f},

		{17, 15, 0.9f, 1, 0, 0, 0.125, 0.0146},{17, 0, 0.9f, 1, 0, 0, 0.125, 0.0f},{24, 15, 0.9f, 1, 0, 0, 0.1318, 0.0146},
		{24, 0, 0.9f, 1, 0, 0, 0.1318, 0.0f},{24, 15, 0.9f, 1, 0, 0, 0.1318, 0.0146},{17, 0, 0.9f, 1, 0, 0, 0.125, 0.0f},

		{24, 15, 0.9f, 1, 0, 0, 0.164, 0.0146},{24, 0, 0.9f, 1, 0, 0, 0.164, 0.0f},{31, 15, 0.9f, 1, 0, 0, 0.170, 0.0146},
		{31, 0, 0.9f, 1, 0, 0, 0.170, 0.0f},{31, 15, 0.9f, 1, 0, 0, 0.170, 0.0146},{24, 0, 0.9f, 1, 0, 0, 0.164, 0.0f},

		{31, 15, 0.9f, 1, 0, 0, 0.0f, 0.0146},{31, 0, 0.9f, 1, 0, 0, 0.0f, 0.0f},{34, 15, 0.9f, 1, 0, 0, 0.002929, 0.0146},
		{34, 0, 0.9f, 1, 0, 0, 0.002929, 0.0f},{34, 15, 0.9f, 1, 0, 0, 0.002929, 0.0146},{31, 0, 0.9f, 1, 0, 0, 0.0f, 0.0f},

		{34, 15, 0.9f, 1, 0, 0, 0.2666, 0.0146},{34, 0, 0.9f, 1, 0, 0, 0.2666, 0.0f},{40, 15, 0.9f, 1, 0, 0, 0.2724, 0.0146},
		{40, 0, 0.9f, 1, 0, 0, 0.2724, 0.0f},{40, 15, 0.9f, 1, 0, 0, 0.2724, 0.0146},{34, 0, 0.9f, 1, 0, 0, 0.2666, 0.0f},

		{40, 15, 0.9f, 1, 0, 0, 0.3486, 0.0146},{40, 0, 0.9f, 1, 0, 0, 0.3486, 0.0f},{48, 15, 0.9f, 1, 0, 0, 0.3564, 0.0146},
		{48, 0, 0.9f, 1, 0, 0, 0.3564, 0.0f},{48, 15, 0.9f, 1, 0, 0, 0.3564, 0.0146},{40, 0, 0.9f, 1, 0, 0, 0.3486, 0.0f},

		{48, 15, 0.9f, 1, 0, 0, 0.376, 0.0146},	{48, 0, 0.9f, 1, 0, 0, 0.376, 0.0f},{56, 15, 0.9f, 1, 0, 0, 0.384, 0.0146},
		{56, 0, 0.9f, 1, 0, 0, 0.384, 0.0f},{56, 15, 0.9f, 1, 0, 0, 0.384, 0.0146},{48, 0, 0.9f, 1, 0, 0, 0.376, 0.0f},
	};
	
	WORD quadIdx[]=	
	{
		 0, 1, 2,  3, 2, 1,  4, 5, 6,  7, 6, 5,  8, 9,10, 11,10, 9, 12,13,14, 15,14,13, //0-8
		16,17,18, 19,18,17, 20,21,22, 23,22,21, 24,25,26, 27,26,25, 28,29,30, 31,30,29, //9-16
		32,33,34, 35,34,33																//17-18
	};
	
	//nIndexCount = sizeof(quadIdx)/sizeof(WORD);
	//nIndexCount=54;	triQty=18;
	nIndexCount=6;	triQty=nIndexCount/3;

	vertexLength = triQty*2;
	vertices = quad;
	indices = quadIdx;

#endif //TEST_RENDER_TRIANGLE
///////////////////////////////////////////////////////////////////////////////////
//define this to examine possible defects
#define DEBUG_MAGNIFY_POPUP

#ifdef DEBUG_MAGNIFY_POPUP
	//scale for better view
	for(i=0; i<vertexLength; i++)
	{
		vertices[i].sx*=10;
		vertices[i].sy*=10;
		vertices[i].sy+=100;
	}
#endif //DEBUG_MAGNIFY_POPUP

    DWORD dwData[256];
	memset(dwData,0,sizeof(dwData));
    void* pData = &dwData;
    LPD3DHAL_DP2COMMAND pCommands = (LPD3DHAL_DP2COMMAND)pData;

    // create the IndexedTriangleList2  command
    pCommands->bCommand        = D3DDP2OP_INDEXEDTRIANGLELIST2;
    pCommands->wPrimitiveCount = triQty;
    D3DHAL_DP2INDEXEDTRIANGLELIST2* pTriList = (D3DHAL_DP2INDEXEDTRIANGLELIST2*)((LPBYTE)(pCommands) + sizeof(D3DHAL_DP2COMMAND));
    
	//memcpy(pTriList,indices,sizeof(WORD)*nIndexCount);
	
	int k;
	for(i=0,k=0; i<triQty/2; i+=2,k+=4)
	{
		k=4;
		pTriList[i+0].wV1 = k+0;
		pTriList[i+0].wV2 = k+1;
		pTriList[i+0].wV3 = k+2;

		pTriList[i+1].wV1 = k+3;
		pTriList[i+1].wV2 = k+2;
		pTriList[i+1].wV3 = k+1;
	}
	
	
    int indSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2INDEXEDTRIANGLELIST2)*triQty;
    // move the command pointer along to the beginning of the next command
    pCommands = (LPD3DHAL_DP2COMMAND)((LPBYTE)pCommands + indSize);

	int d = (DWORD)pCommands - (DWORD)pData;
    // make sure we had enough space
	nvAssert((DWORD)pCommands < (DWORD)dwData + sizeof(dwData));
    // set up the ddraw local & global
#ifdef WINNT
    DD_SURFACE_GLOBAL ddGbl;
    DD_SURFACE_LOCAL  ddLcl;
    ddLcl.lpGbl = &ddGbl;
    ddGbl.fpVidMem = (FLATPTR)pData; // pointer to command buffer
    ddLcl.dwReserved1 = NULL;
#else
    typedef struct {
        DDRAWI_DDRAWSURFACE_GBL_MORE ddGblMore;
        LPDWORD                      dwReserved1;
        DDRAWI_DDRAWSURFACE_GBL      ddGbl;
    } EXT_DDRAWI_DDRAWSURFACE_GBL;

    DDRAWI_DDRAWSURFACE_LCL     ddLcl;
    EXT_DDRAWI_DDRAWSURFACE_GBL eddGbl;
    eddGbl.ddGbl.fpVidMem = (FLATPTR)pData; // pointer to command buffer
    eddGbl.dwReserved1 = (LPDWORD)&eddGbl.ddGblMore;
    eddGbl.ddGblMore.dwDriverReserved = NULL;
    ddLcl.lpGbl = &eddGbl.ddGbl;
#endif

    // set up the DP2 command
    D3DHAL_DRAWPRIMITIVES2DATA dp2;
    dp2.dwhContext      = (ULONG_PTR)pContext;
    dp2.dwFlags         = D3DHALDP2_USERMEMVERTICES;
    dp2.dwVertexType    = fvfCode;
	dp2.dwVertexSize    = vertexSize;
    dp2.lpDDCommands    = &ddLcl;
    dp2.dwCommandOffset = 0;
    dp2.dwCommandLength = (DWORD)pCommands - (DWORD)pData;
    dp2.lpVertices      = vertices;
    dp2.dwVertexOffset  = 0;
    dp2.dwVertexLength  = vertexLength;
    dp2.lpdwRStates     = NULL;

    // create a vertex buffer
    pVB->own((DWORD)vertices, dp2.dwVertexSize * vertexLength, CSimpleSurface::HEAP_SYS);

    pVB->setVertexStride(dp2.dwVertexSize);

    // create a vertex shader from the FVF format
    pVS->create (pContext, dp2.dwVertexType, CVertexShader::getHandleFromFvf( dp2.dwVertexType ) );

    // save the current vertex buffer and vertex shader
    CVertexShader *pOldVertexShader = pContext->pCurrentVShader;
    CVertexBuffer *pOldVertexBuffer = pContext->ppDX8Streams[0];
    DWORD          dwStreamDMACount = pContext->dwStreamDMACount;
    DWORD          dwDxAppVersion   = pContext->dwDXAppVersion;

	setupStates(dwFlags);

    // set the popup vertex buffer & shader
    pContext->pCurrentVShader  = pVS;
    pContext->ppDX8Streams[0]  = pVB;
    pContext->dwStreamDMACount = 0x00010000;
    pContext->dwDXAppVersion   = 0x800;

    nvDrawPrimitives2(&dp2);

    // restore original vertex buffer & shader
    pContext->pCurrentVShader  = pOldVertexShader;
    pContext->ppDX8Streams[0]  = pOldVertexBuffer;
    pContext->dwStreamDMACount = dwStreamDMACount;
    pContext->dwDXAppVersion   = dwDxAppVersion;

	restoreStates(dwFlags);

	return S_OK;
}
#endif //RENDER_POPUP_INDEXED

#ifdef RENDER_POPUP_FALLBACK
///////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CPopupAgent::RenderTriangles(Vertex *pVertexData, unsigned short *pusIndexData, int nIndexCount, DWORD dwFlags)
{

    // check if the context is valid
    if (!pContext) return E_FAIL;

    // check if we have a valid render target
    if (!pContext->pRenderTarget) return E_FAIL;

    // reject if the render target is a texture
    CNvObject *pNVObj = pContext->pRenderTarget->getWrapper();
    if (!pNVObj) return E_FAIL;
    if (pNVObj->getTexture()) return E_FAIL;

	//BUGBUG: lame workaround -- still can't setup indexed tri list
    ////////////////////////////////////////////////////
#define POPUP_MAX_IND     120
	static Vertex	buf[POPUP_MAX_IND];
	static WORD		idx[POPUP_MAX_IND];

    if(nIndexCount>POPUP_MAX_IND)
    {
        nIndexCount = POPUP_MAX_IND;
        nvAssert(0);
    }
    ////////////////////////////////////////////////////
    DWORD		fvfCode = D3DFVF_POPUP_VERTEX;
	DWORD		vertexSize  = sizeof(Vertex);
	Vertex*		vertices = pVertexData;
	WORD*		indices = pusIndexData;		
	DWORD		triQty = nIndexCount/3;
	DWORD		vertexLength= triQty*2; //true only for special case
	
	int i,ind;
	Vertex v;
	int max_ind = 0;

	//static int dumpIt=0; int n=1;
	for(i=0; i<nIndexCount; i++)
	{
		ind = pusIndexData[i];
		v = pVertexData[ind];
		//figure out the number of vertices (assuming continuos indices) 
		if(max_ind<ind) max_ind = ind;
		
		//BUGBUG: untangling indices/vertices. Lame. 
		buf[i] = v;
		idx[i] = i;
	}
	///////// START: for untangled indices only ///////////////
	/**/
	vertexLength = nIndexCount;
	vertices = buf;
	indices  = idx;
	/**/
	///////// END: for untangled indices only ///////////////

///////////////////////////////////////////////////////////////////////////////////
//#define TEST_RENDER_TRIANGLE
#ifdef TEST_RENDER_TRIANGLE

    Vertex quad[] =
	{
		{0, 15, 0.9f, 1, 0, 0, 0.1094, 0.0146},{0, 0, 0.9f, 1, 0, 0, 0.1094, 0.0f},{7, 15, 0.9f, 1, 0, 0, 0.1162, 0.0146},
		{7, 0, 0.9f, 1, 0, 0, 0.1162, 0.0f},{7, 15, 0.9f, 1, 0, 0, 0.1162, 0.0146},{0, 0, 0.9f, 1, 0, 0, 0.1094, 0.0f},

		{7, 15, 0.9f, 1, 0, 0, 0.15625, 0.0146},{7, 0, 0.9f, 1, 0, 0, 0.15625, 0.0f},{14, 15, 0.9f, 1, 0, 0, 0.163, 0.0146},
		{14, 0, 0.9f, 1, 0, 0, 0.163, 0.0f},{14, 15, 0.9f, 1, 0, 0, 0.163, 0.0146},{7, 0, 0.9f, 1, 0, 0, 0.15625, 0.0f},

		{14, 15, 0.9f, 1, 0, 0, 0.086, 0.0146},{14, 0, 0.9f, 1, 0, 0, 0.086, 0.0f},{17, 15, 0.9f, 1, 0, 0, 0.0889, 0.0146},
		{17, 0, 0.9f, 1, 0, 0, 0.0889, 0.0f},{17, 15, 0.9f, 1, 0, 0, 0.0889, 0.0146},{14, 0, 0.9f, 1, 0, 0, 0.086, 0.0f},

		{17, 15, 0.9f, 1, 0, 0, 0.125, 0.0146},{17, 0, 0.9f, 1, 0, 0, 0.125, 0.0f},{24, 15, 0.9f, 1, 0, 0, 0.1318, 0.0146},
		{24, 0, 0.9f, 1, 0, 0, 0.1318, 0.0f},{24, 15, 0.9f, 1, 0, 0, 0.1318, 0.0146},{17, 0, 0.9f, 1, 0, 0, 0.125, 0.0f},

		{24, 15, 0.9f, 1, 0, 0, 0.164, 0.0146},{24, 0, 0.9f, 1, 0, 0, 0.164, 0.0f},{31, 15, 0.9f, 1, 0, 0, 0.170, 0.0146},
		{31, 0, 0.9f, 1, 0, 0, 0.170, 0.0f},{31, 15, 0.9f, 1, 0, 0, 0.170, 0.0146},{24, 0, 0.9f, 1, 0, 0, 0.164, 0.0f},

		{31, 15, 0.9f, 1, 0, 0, 0.0f, 0.0146},{31, 0, 0.9f, 1, 0, 0, 0.0f, 0.0f},{34, 15, 0.9f, 1, 0, 0, 0.002929, 0.0146},
		{34, 0, 0.9f, 1, 0, 0, 0.002929, 0.0f},{34, 15, 0.9f, 1, 0, 0, 0.002929, 0.0146},{31, 0, 0.9f, 1, 0, 0, 0.0f, 0.0f},

		{34, 15, 0.9f, 1, 0, 0, 0.2666, 0.0146},{34, 0, 0.9f, 1, 0, 0, 0.2666, 0.0f},{40, 15, 0.9f, 1, 0, 0, 0.2724, 0.0146},
		{40, 0, 0.9f, 1, 0, 0, 0.2724, 0.0f},{40, 15, 0.9f, 1, 0, 0, 0.2724, 0.0146},{34, 0, 0.9f, 1, 0, 0, 0.2666, 0.0f},

		{40, 15, 0.9f, 1, 0, 0, 0.3486, 0.0146},{40, 0, 0.9f, 1, 0, 0, 0.3486, 0.0f},{48, 15, 0.9f, 1, 0, 0, 0.3564, 0.0146},
		{48, 0, 0.9f, 1, 0, 0, 0.3564, 0.0f},{48, 15, 0.9f, 1, 0, 0, 0.3564, 0.0146},{40, 0, 0.9f, 1, 0, 0, 0.3486, 0.0f},

		{48, 15, 0.9f, 1, 0, 0, 0.376, 0.0146},	{48, 0, 0.9f, 1, 0, 0, 0.376, 0.0f},{56, 15, 0.9f, 1, 0, 0, 0.384, 0.0146},
		{56, 0, 0.9f, 1, 0, 0, 0.384, 0.0f},{56, 15, 0.9f, 1, 0, 0, 0.384, 0.0146},{48, 0, 0.9f, 1, 0, 0, 0.376, 0.0f},
	};
	
	//nIndexCount = sizeof(quadIdx)/sizeof(WORD);
	nIndexCount=54;	triQty=18;

	vertexLength = triQty*2;
	vertices = (Vertex*)quad;
	indices = quadIdx;

#endif //TEST_RENDER_TRIANGLE
///////////////////////////////////////////////////////////////////////////////////
//define this to examine possible defects
//#define DEBUG_MAGNIFY_POPUP

#ifdef DEBUG_MAGNIFY_POPUP
	//scale for better view
	for(i=0; i<vertexLength; i++)
	{
		vertices[i].sx*=10;
		vertices[i].sy*=10;
		vertices[i].sy+=100;
	}
#endif //DEBUG_MAGNIFY_POPUP

    DWORD dwData[256];
	memset(dwData,0,sizeof(dwData));
    void* pData = &dwData;
    LPD3DHAL_DP2COMMAND pCommands = (LPD3DHAL_DP2COMMAND)pData;

    // create the TriangleList  command
    pCommands->bCommand        = D3DDP2OP_TRIANGLELIST;
    pCommands->wPrimitiveCount = triQty;
    D3DHAL_DP2TRIANGLELIST* pTriList = (D3DHAL_DP2TRIANGLELIST*)((LPBYTE)(pCommands) + sizeof(D3DHAL_DP2COMMAND));
    
	pTriList->wVStart=0;

    int size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TRIANGLELIST);
    // move the command pointer along to the beginning of the next command
    pCommands = (LPD3DHAL_DP2COMMAND)((LPBYTE)pCommands + size);
    // make sure we had enough space
	nvAssert((DWORD)pCommands < (DWORD)dwData + sizeof(dwData));
    // set up the ddraw local & global
#ifdef WINNT
    DD_SURFACE_GLOBAL ddGbl;
    DD_SURFACE_LOCAL  ddLcl;
    ddLcl.lpGbl = &ddGbl;
    ddGbl.fpVidMem = (FLATPTR)pData; // pointer to command buffer
    ddLcl.dwReserved1 = NULL;
#else
    typedef struct {
        DDRAWI_DDRAWSURFACE_GBL_MORE ddGblMore;
        LPDWORD                      dwReserved1;
        DDRAWI_DDRAWSURFACE_GBL      ddGbl;
    } EXT_DDRAWI_DDRAWSURFACE_GBL;

    DDRAWI_DDRAWSURFACE_LCL     ddLcl;
    EXT_DDRAWI_DDRAWSURFACE_GBL eddGbl;
    eddGbl.ddGbl.fpVidMem = (FLATPTR)pData; // pointer to command buffer
    eddGbl.dwReserved1 = (LPDWORD)&eddGbl.ddGblMore;
    eddGbl.ddGblMore.dwDriverReserved = NULL;
    ddLcl.lpGbl = &eddGbl.ddGbl;
#endif

    // set up the DP2 command
    D3DHAL_DRAWPRIMITIVES2DATA dp2;
    dp2.dwhContext      = (ULONG_PTR)pContext;
    dp2.dwFlags         = D3DHALDP2_USERMEMVERTICES;
    dp2.dwVertexType    = fvfCode;
	dp2.dwVertexSize    = vertexSize;
    dp2.lpDDCommands    = &ddLcl;
    dp2.dwCommandOffset = 0;
    dp2.dwCommandLength = (DWORD)pCommands - (DWORD)pData;
    dp2.lpVertices      = vertices;
    dp2.dwVertexOffset  = 0;
    dp2.dwVertexLength  = vertexLength;
    dp2.lpdwRStates     = NULL;

    // create a vertex buffer
    pVB->own((DWORD)vertices, dp2.dwVertexSize * vertexLength, CSimpleSurface::HEAP_SYS);

    pVB->setVertexStride(dp2.dwVertexSize);

    // create a vertex shader from the FVF format
    pVS->create (pContext, dp2.dwVertexType, CVertexShader::getHandleFromFvf( dp2.dwVertexType ) );

    // save the current vertex buffer and vertex shader
    CVertexShader *pOldVertexShader = pContext->pCurrentVShader;
    CVertexBuffer *pOldVertexBuffer = pContext->ppDX8Streams[0];
    DWORD          dwStreamDMACount = pContext->dwStreamDMACount;
    DWORD          dwDxAppVersion   = pContext->dwDXAppVersion;

	setupStates(dwFlags);

    // set the popup vertex buffer & shader
    pContext->pCurrentVShader  = pVS;
    pContext->ppDX8Streams[0]  = pVB;
    pContext->dwStreamDMACount = 0x00010000;
    pContext->dwDXAppVersion   = 0x800;

    nvDrawPrimitives2(&dp2);

    // restore original vertex buffer & shader
    pContext->pCurrentVShader  = pOldVertexShader;
    pContext->ppDX8Streams[0]  = pOldVertexBuffer;
    pContext->dwStreamDMACount = dwStreamDMACount;
    pContext->dwDXAppVersion   = dwDxAppVersion;

	restoreStates(dwFlags);

	return S_OK;
}
#endif //RENDER_POPUP_FALLBACK
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CPopupAgent::setupStates( DWORD dwFlags )
{
	if(!pContext) return E_FAIL;
    // set up state
	HRESULT rval;
	
	PopupStateSet* popupStates = popupStatesTextured;

	if(dwFlags ==  RTF_NOTEXTURE )
		popupStates = popupStatesSolid;

	while(popupStates->state)
    {
		//save old state
        popupStates->oldvalue = pContext->dwRenderState[popupStates->state];
		//set desired state
        nvSetContextState(pContext, popupStates->state, popupStates->value, &rval);
		++popupStates;
	}

	//setting up texturing
	nvMemCopy(tssPrevState, pContext->tssState, sizeof(tssPrevState));
	memset(&pContext->tssState[0], 0, sizeof(tssPrevState));
	
	if(dwFlags == RTF_NOTEXTURE )
	{
		
		pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP    ] = 0;
		pContext->tssState[0].dwValue[D3DTSS_COLOROP       ] = D3DTOP_SELECTARG1;
		pContext->tssState[0].dwValue[D3DTSS_COLORARG1     ] = D3DTA_DIFFUSE;
		//pContext->tssState[0].dwValue[D3DTSS_ALPHAOP       ] = D3DTOP_DISABLE;
		//pContext->tssState[0].dwValue[D3DTSS_ALPHAOP       ] = D3DTOP_SELECTARG1;
		//pContext->tssState[0].dwValue[D3DTSS_ALPHAARG1     ] = D3DTA_DIFFUSE;
		//pContext->tssState[0].dwValue[D3DTSS_ADDRESSU      ] = D3DTADDRESS_WRAP;
		//pContext->tssState[0].dwValue[D3DTSS_ADDRESSV      ] = D3DTADDRESS_WRAP;
		//pContext->tssState[0].dwValue[D3DTSS_MAGFILTER     ] = D3DTFG_LINEAR;
		//pContext->tssState[0].dwValue[D3DTSS_MINFILTER     ] = D3DTFN_LINEAR;
		//pContext->tssState[0].dwValue[D3DTSS_MIPFILTER     ] = D3DTFP_NONE;
		//pContext->tssState[0].dwValue[D3DTSS_MAXANISOTROPY ] = 1;
		//pContext->tssState[1].dwValue[D3DTSS_COLOROP       ] = D3DTOP_DISABLE;
	}
	else
	{
		pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP    ] = (DWORD)pTextureObj;
		pContext->tssState[0].dwValue[D3DTSS_COLOROP       ] = D3DTOP_SELECTARG1;
		pContext->tssState[0].dwValue[D3DTSS_COLORARG1     ] = D3DTA_TEXTURE;
		pContext->tssState[0].dwValue[D3DTSS_ALPHAOP       ] = D3DTOP_SELECTARG1;
		pContext->tssState[0].dwValue[D3DTSS_ALPHAARG1     ] = D3DTA_TEXTURE;
		pContext->tssState[0].dwValue[D3DTSS_ADDRESSU      ] = D3DTADDRESS_WRAP;
		pContext->tssState[0].dwValue[D3DTSS_ADDRESSV      ] = D3DTADDRESS_WRAP;
		pContext->tssState[0].dwValue[D3DTSS_MAGFILTER     ] = D3DTFG_LINEAR;
		pContext->tssState[0].dwValue[D3DTSS_MINFILTER     ] = D3DTFN_LINEAR;
		pContext->tssState[0].dwValue[D3DTSS_MIPFILTER     ] = D3DTFP_NONE;
		pContext->tssState[0].dwValue[D3DTSS_MAXANISOTROPY ] = 1;
		pContext->tssState[1].dwValue[D3DTSS_COLOROP       ] = D3DTOP_DISABLE;
		pContext->tssState[2].dwValue[D3DTSS_COLOROP       ] = D3DTOP_DISABLE;
		pContext->tssState[3].dwValue[D3DTSS_COLOROP       ] = D3DTOP_DISABLE;
	}
    // make sure everything gets updated
#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= celsiusDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
    pContext->hwState.dwDirtyFlags |= kelvinDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF | KELVIN_DIRTY_FVF;
#endif
    NV_FORCE_TRI_SETUP(pContext);

	return S_OK;
}

HRESULT CPopupAgent::restoreStates(DWORD dwFlags)
{
	HRESULT rval;
	
	if(!pContext) return E_FAIL;
    // restore state
	PopupStateSet* popupStates = popupStatesTextured;

	if(dwFlags ==  RTF_NOTEXTURE )
		popupStates = popupStatesSolid;

    while(popupStates->state)
    {
        nvSetContextState(pContext, popupStates->state, popupStates->oldvalue, &rval);
		++popupStates;
    }

    // restore texture stage state
    nvMemCopy(pContext->tssState, tssPrevState, sizeof(tssPrevState));
    // make sure everything gets updated
#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= celsiusDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
    pContext->hwState.dwDirtyFlags |= kelvinDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF | KELVIN_DIRTY_FVF;
#endif
    NV_FORCE_TRI_SETUP(pContext);
    
#if (NVARCH >= 0x020)
    if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)) {
        if (pContext->kelvinAA.IsEnabled()) {
            //fixes flickering text in sample apps with aa and logo on.
            getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
        }
    }
#endif 

	
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////
CPopupAgentList::CPopupAgentList()
{
	popupAgentList = 0;
	hMod = 0;
    bPerfStat = false;
    bStereoStat = false;
    isPopupEnabled = false;

    memset(&hotkeys,0,sizeof(hotkeys));

    strcpy(strModule, DEFAULT_MODULE_NAME);
}

CPopupAgentList::~CPopupAgentList()
{
	destroy();
}

void    CPopupAgentList::add(CPopupAgent* that)
{
    CPopupAgentBase* cp=(CPopupAgentBase*)popupAgentList;
    CPopupAgentBase* nextAgent=cp;
    
    if(!cp) //list is empty yet
    {
        popupAgentList = that;
        return;
    }
    //else, go to the end of list:
    for(nextAgent=cp->GetNextAgent(); nextAgent; cp=nextAgent);
    //insert
    cp->SetNextAgent(that);
}

HRESULT CPopupAgentList::create()
{
    return create(DEFAULT_MODULE_NAME);
}

void    CPopupAgentList::getOptions()
{
    HKEY hKey;
    char popupKey[MAX_PATH];

    nvStrCpy(popupKey, NV4_REG_GLOBAL_BASE_PATH);
    nvStrCat(popupKey, "\\");
    nvStrCat(popupKey, NV4_REG_STEREO_SUBKEY);
    nvStrCat(popupKey, "\\");
    nvStrCat(popupKey, NV_REG_STEREO_POPUP_SUBKEY);

    DWORD rc=0;

    rc = RegOpenKeyEx(NV4_REG_GLOBAL_BASE_KEY, popupKey, 0, KEY_READ, &hKey);
    if (rc == ERROR_SUCCESS) 
    {
        DWORD   dwSize = sizeof(long);
        DWORD   dwType = REG_DWORD;
        long    lValue;

        if (RegQueryValueEx(hKey, NV_REG_STEREO_POPUP_FPS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            bPerfStat = lValue?true:false;
        }
        if (RegQueryValueEx(hKey, NV_REG_STEREO_POPUP_STAT, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            bStereoStat = lValue?true:false;
        }

        //configure hot key interface

        if (RegQueryValueEx(hKey, NV_REG_STEREO_POPUP_HOTKEY, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            hotkeys.PopupToggle.dwValue = lValue;   // The hot key to toggle all popups
        }
        if (RegQueryValueEx(hKey, NV_REG_STEREO_POPUP_FPS_HOTKEY, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            hotkeys.FPStoggle.dwValue = lValue;   // The hot key to toggle FPS popup
        }
        if (RegQueryValueEx(hKey, NV_REG_STEREO_POPUP_STATS_HOTKEY, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            hotkeys.StatsToggle.dwValue = lValue;   // The hot key to toggle Stereo Statistics popup
        }
        
        RegCloseKey(hKey);
    }
}

HRESULT  CPopupAgentList::initHotKeys()
{
    // add hotkeys 
    nvAssert(pStereoData->StereoKeys.pHotKeyI);

    CREATESTEREOHOTKEY(hotkeys.PopupToggle);
    //CREATESTEREOHOTKEY(hotkeys.FPStoggle);
    //CREATESTEREOHOTKEY(hotkeys.StatsToggle);

    return S_OK;
}

HRESULT  CPopupAgentList::finiHotKeys()
{
    DESTROYSTEREOHOTKEY(hotkeys.PopupToggle);
    //DESTROYSTEREOHOTKEY(hotkeys.FPStoggle);
    //DESTROYSTEREOHOTKEY(hotkeys.StatsToggle);
    return S_OK;
}
HRESULT CPopupAgentList::create(const char* aModule)
{
	HRESULT rc=E_FAIL;

	if(popupAgentList)
	{
		rc = destroy();
	}
	
    if(aModule)
	{
		strcpy(strModule,aModule);
	}
	
    if(bPerfStat || bStereoStat)
    {
    	nvAssert(!hMod);
        hMod = LoadLibrary(strModule);
	    if(!hMod) 
	    {
		    LOG("CPopupAgentList::create : can't load %s", strModule );
		    return E_FAIL;
	    }
    }
    // construction zone. to be generalized for arbitrary number & type of popups
	/////// Create popup with FPS info /////////////////////////////
    if(bPerfStat)
    {
	    CPerfStatPopup*	fpsPopup=0;
	    fpsPopup = new CPerfStatPopup;
	    if(!fpsPopup)
	    {
		    DPF("CPopupAgentList::create : FPS popup allocation failed");
		    return E_FAIL;
	    }
	    fpsPopup->bindPopupAgent(hMod);
	    add(fpsPopup); 
    }
	/////// Create popup with stereo statistics /////////////////////////////
    if(bStereoStat)
    {
        CStereoStatPopup*	stsPopup=0;
	    stsPopup = new CStereoStatPopup;
	    if(!stsPopup)
	    {
		    DPF("CPopupAgentList::create : StereoStat popup allocation failed");
		    return E_FAIL;
	    }
	    stsPopup->bindPopupAgent(hMod);
        add(stsPopup);
    }
	/////////////////////////////////
	rc=S_OK;

	return rc;
}

HRESULT CPopupAgentList::destroy()
{
	HRESULT rc=E_FAIL;

	CPopupAgent* cp=popupAgentList;
	CPopupAgent* nextAgent;

	for(nextAgent = cp; nextAgent; cp = nextAgent )
	{
		nextAgent = (CPopupAgent*)cp->GetNextAgent();
		cp->unbindPopupAgent();
		cp->SetFlipCallback(0);
		delete cp;
		cp=0;
	}
	popupAgentList=0;

	if(hMod) 
	{
		FreeLibrary(hMod);
		hMod = 0;
	}
    
    rc=S_OK;
	return rc;
}

//render pop-up agents
//[in]  driver context 
HRESULT CPopupAgentList::render(NVD3DCONTEXT* pContext)
{
	HRESULT rc = E_FAIL;

    //required for POLLSTEREOHOTKEY
    BOOL res_ = FALSE;
    
    POLLSTEREOHOTKEY(hotkeys.PopupToggle)
    {
        toggle();
    }
    
    //TODO: add individual popup hotkey processing code 

    if(!enabled()) 
    {
        return S_OK;
    }

	CPopupAgent* cp=popupAgentList;
	CPopupAgent* nextAgent;

	for( nextAgent = cp; nextAgent; cp = nextAgent )
	{
		nextAgent = (CPopupAgent*)cp->GetNextAgent();
		//NB: context is validated during renderTriangles call
        cp->setContext(pContext);

		FlipCallbackType callback= cp->GetFlipCallback();
		
		if( !callback )
		{
			 DPF("CPopupAgentList::render : flip callback points to null");
			 nvAssert(0);
			 continue;
		}
		rc = callback(cp);					//grant application a chance to wreak havoc

	}

	rc=S_OK;
	return rc;
}

////////////////////////////////////////////////////////////////////////////////////////////
CPopupAgentList popupAgents;
//////////////////////////////////////////////////////////////////////////////////////////

CPerfStatPopup::CPerfStatPopup()
{
	m_dwAgentID = PERF_STATS_ID;
}

CPerfStatPopup::~CPerfStatPopup()
{
}
//////////////////////////////////////////////////////////////////////////////////////////
//Stereo Statistics

CStereoStatPopup::CStereoStatPopup()
{
	//memset((STEREOSTATS*)this,0,sizeof(STEREOSTATS));
	//shoot to foot -- our user data (STEREOSTATS) contained in the self
	SetUserData(this);
	m_dwAgentID = STEREO_STATS_ID;
}

CStereoStatPopup::~CStereoStatPopup()
{
}

void CStereoStatPopup::setContext(NVD3DCONTEXT* aContext)
{
	//call base class
	CPopupAgent::setContext(aContext);

	if(!STEREO_ENABLED || !pContext) return;

	dwWidth  = pContext->pRenderTarget->getWidth();
    dwHeight = pContext->pRenderTarget->getHeight();
    dwBpp = pContext->pRenderTarget->getBPP();

	dwFlags = 0;

	StereoSeparation  = pStereoData->StereoSettings.fStereoSeparation;
	StereoConvergence = pStereoData->StereoSettings.fStereoConvergence;

	if(pStereoData->dwHWTnL)
	{
		//gather HW T&L statistics
		dwFlags |= HW_TnL;
		ZNear = ConfigAssistInfo.szMin;
		ZFar = 	ConfigAssistInfo.szMax;
	}
	else
	{
		//gather SW T&L statistics
		rhwMin =  ConfigAssistInfo.rhwMin;
		rhwMax =  ConfigAssistInfo.rhwMax;
		rhwMin2D =  ConfigAssistInfo.rhwMin2D;
		rhwMax2D =  ConfigAssistInfo.rhwMax2D;

		if (pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN)
		{
			dwFlags |= RHWGREATERATSCREEN;
			RHWGreaterAtScreen = pStereoData->StereoSettings.fRHWGreaterAtScreen;
		}
		if (pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN)
		{
			dwFlags |= RHWLESSATSCREEN;
			RHWLessAtScreen = pStereoData->StereoSettings.fRHWLessAtScreen;
		}
	}
//for now, always defined in the nvStereo.h
#ifdef STEREO_CONFIG_ASSIST 
	dwFlags |= CONFIGASSISTON;
#endif

}
#endif //IMPLEMENT_POPUP_AGENT -- Gr
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvPrim.cpp ===
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvPrim.cpp                                                        *
*   NV4 DX5 DrawPrimitives and DrawOnePrimitive DDI routines.               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/98 - created                      *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"


#if (NVARCH >= 0x04)

#ifndef WINNT

void nvDrawPrimitive
(
    PNVD3DCONTEXT pContext,
    WORD          wPrimType,
    WORD          wNumVertices,
    LPBYTE        lpVertexData
)
{
    WORD            wPrimCount;
    CVertexBuffer  *pVertexBuffer;

    pContext->dp2.dwVertexBufferOffset = 0;
    pContext->dp2.dwVStart = 0;
    pContext->dp2.dwTotalOffset = 0;

    DDSTARTTICK(PRIM_DRAWPRIMITIVE);

#if (NVARCH >= 0x010)
    pContext->pCurrentVShader->create (pContext, D3DFVF_TLVERTEX, CVertexShader::getHandleFromFvf(D3DFVF_TLVERTEX));
    pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_TL_MODE |
                                       CELSIUS_DIRTY_FVF |
                                       CELSIUS_DIRTY_LIGHTS);
    pContext->hwState.dwDirtyFlags |= (KELVIN_DIRTY_FVF |
                                       KELVIN_DIRTY_LIGHTS);
#endif  // nv10

    // cast plain vertex data into a vertex buffer
    pVertexBuffer = getDC()->defaultSysVB.getVB();
    pVertexBuffer->own ((DWORD)(lpVertexData), wNumVertices*sizeof(D3DTLVERTEX), CSimpleSurface::HEAP_SYS);
    // cast vertex buffer into DX8-style streams
    for (int i=0; i<NV_CAPS_MAX_STREAMS; i++) {
        pContext->ppDX8Streams[i] = pVertexBuffer;
    }

    switch (wPrimType) {

        case D3DPT_TRIANGLELIST:

            pContext->dp2.dwDP2Prim = D3DDP2OP_TRIANGLELIST;
            pContext->dp2.dwIndices = NULL;

            wPrimCount = wNumVertices / 3;

#if (NVARCH >= 0x020)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                DPF ("ugh. got a legacy call to nvDrawPrimitive on an nv20.");
                DPF ("this is totally untested, may very well not work.");
                dbgD3DError();
                nvKelvinDispatchNonIndexedPrimitive (pContext, wPrimCount);
            }
            else
#endif  // (NVARCH >= 0x020)
#if (NVARCH >= 0x010)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                DPF ("ugh. got a legacy call to nvDrawPrimitive on an nv10.");
                DPF ("this is totally untested, may very well not work.");
                dbgD3DError();
                nvCelsiusDispatchNonIndexedPrimitive (pContext, wPrimCount);
            }
            else
#endif  // NVARCH >= 0x010
            {
                switch (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE])
                {
                    case D3DFILL_SOLID:
                        DDSTARTTICK(PRIM_SOLIDNONINDEXEDTRI);
                        DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wNumVertices);
                        nvTriangleDispatch (pContext, wPrimCount);
                        DDENDTICK(PRIM_SOLIDNONINDEXEDTRI);
                        break;
                    case D3DFILL_WIREFRAME:
                        DDSTARTTICK(PRIM_WIREFRAMENONINDEXEDTRI);
                        DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wNumVertices);
                        nvDrawWireframeTriangle (pContext, wPrimCount);
                        DDENDTICK(PRIM_WIREFRAMENONINDEXEDTRI);
                        break;
                    case D3DFILL_POINT:
                        DDSTARTTICK(PRIM_POINTNONINDEXEDTRI);
                        DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wNumVertices);
                        nvDrawPointTriangle (pContext, wPrimCount);
                        DDENDTICK(PRIM_POINTNONINDEXEDTRI);
                        break;
                }
            }

            break;

        case D3DPT_TRIANGLESTRIP:

            pContext->dp2.dwDP2Prim = D3DDP2OP_TRIANGLESTRIP;
            pContext->dp2.dwIndices = NULL;

            wPrimCount = wNumVertices - 2;

#if (NVARCH >= 0x020)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                DPF ("ugh. got a legacy call to nvDrawPrimitive on an nv20.");
                DPF ("this is totally untested, may very well not work.");
                dbgD3DError();
                nvKelvinDispatchNonIndexedPrimitive (pContext, wPrimCount);
            }
            else
#endif  // (NVARCH >= 0x020)
#if (NVARCH >= 0x010)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                DPF ("ugh. got a legacy call to nvDrawPrimitive on an nv10.");
                DPF ("this is totally untested, may very well not work.");
                dbgD3DError();
                nvCelsiusDispatchNonIndexedPrimitive (pContext, wPrimCount);
            }
            else
#endif  // NVARCH >= 0x010
            {
                switch (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE])
                {
                    case D3DFILL_SOLID:
                        DDSTARTTICK (PRIM_DRAWSTRIPSOLIDNONINDEXED);
                        DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wNumVertices);
                        nvTriangleDispatch (pContext, wPrimCount);
                        DDENDTICK (PRIM_DRAWSTRIPSOLIDNONINDEXED);
                        break;
                    case D3DFILL_WIREFRAME:
                        DDSTARTTICK (PRIM_DRAWSTRIPWIRENONINDEXED);
                        DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wNumVertices);
                        nvDrawWireframeTriangle (pContext, wPrimCount);
                        DDENDTICK (PRIM_DRAWSTRIPWIRENONINDEXED);
                        break;
                    case D3DFILL_POINT:
                        DDSTARTTICK (PRIM_DRAWSTRIPSOLIDNONINDEXED);
                        DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wNumVertices);
                        nvDrawWireframeTriangle (pContext, wPrimCount);
                        DDENDTICK (PRIM_DRAWSTRIPSOLIDNONINDEXED);
                        break;
                }
            }

            break;

        case D3DPT_TRIANGLEFAN:

            pContext->dp2.dwDP2Prim = D3DDP2OP_TRIANGLEFAN;
            pContext->dp2.dwIndices = NULL;

            wPrimCount = wNumVertices - 2;
            if (wPrimCount == 0) break;

#if (NVARCH >= 0x020)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                DPF ("ugh. got a legacy call to nvDrawPrimitive on an nv20.");
                DPF ("this is totally untested, may very well not work.");
                dbgD3DError();
                nvKelvinDispatchNonIndexedPrimitive (pContext, wPrimCount);
            }
            else
#endif  // (NVARCH >= 0x020)
#if (NVARCH >= 0x010)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                DPF ("ugh. got a legacy call to nvDrawPrimitive on an nv10.");
                DPF ("this is totally untested, may very well not work.");
                dbgD3DError();
                nvCelsiusDispatchNonIndexedPrimitive (pContext, wPrimCount);
            }
            else
#endif  // NVARCH >= 0x010
            {
                switch (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE])
                {
                    case D3DFILL_SOLID:
                        DDSTARTTICK(PRIM_DRAWFANSOLIDNONINDEXED);
                        DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wNumVertices);
                        nvTriangleDispatch (pContext, wPrimCount);
                        DDENDTICK(PRIM_DRAWFANSOLIDNONINDEXED);
                        break;
                    case D3DFILL_WIREFRAME:
                        DDSTARTTICK(PRIM_DRAWFANWIREDNONINDEXED);
                        DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wNumVertices);
                        nvDrawWireframeTriangle (pContext, wPrimCount);
                        DDENDTICK(PRIM_DRAWFANWIREDNONINDEXED);
                        break;
                    case D3DFILL_POINT:
                        DDSTARTTICK(PRIM_DRAWFANPOINTNONINDEXED);
                        DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wNumVertices);
                        nvDrawWireframeTriangle (pContext, wPrimCount);
                        DDSTARTTICK(PRIM_DRAWFANPOINTNONINDEXED);
                        break;
                }
            }

            break;

        case D3DPT_LINELIST:

            pContext->dp2.dwDP2Prim = D3DDP2OP_LINELIST;
            pContext->dp2.dwIndices = NULL;

            wPrimCount = wNumVertices / 2;

#if (NVARCH >= 0x020)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                DPF ("ugh. got a legacy call to nvDrawPrimitive on an nv20.");
                DPF ("this is totally untested, may very well not work.");
                dbgD3DError();
                nvKelvinDispatchNonIndexedPrimitive (pContext, wPrimCount);
            }
            else
#endif  // (NVARCH >= 0x020)
#if (NVARCH >= 0x010)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                DPF ("ugh. got a legacy call to nvDrawPrimitive on an nv10.");
                DPF ("this is totally untested, may very well not work.");
                dbgD3DError();
                nvCelsiusDispatchNonIndexedPrimitive (pContext, wPrimCount);
            }
            else
#endif  // NVARCH >= 0x010
            {
                DDSTARTTICK(PRIM_DRAWLINELISTNONINDEXED);
                DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wNumVertices);
                nvDrawLine (pContext, wPrimCount);
                DDENDTICK(PRIM_DRAWLINELISTNONINDEXED);
            }

            break;

        case D3DPT_LINESTRIP:

            pContext->dp2.dwDP2Prim = D3DDP2OP_LINESTRIP;
            pContext->dp2.dwIndices = NULL;

            wPrimCount = wNumVertices - 1;

#if (NVARCH >= 0x020)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                DPF ("ugh. got a legacy call to nvDrawPrimitive on an nv20.");
                DPF ("this is totally untested, may very well not work.");
                dbgD3DError();
                nvKelvinDispatchNonIndexedPrimitive (pContext, wPrimCount);
            }
            else
#endif  // (NVARCH >= 0x020)
#if (NVARCH >= 0x010)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                DPF ("ugh. got a legacy call to nvDrawPrimitive on an nv10.");
                DPF ("this is totally untested, may very well not work.");
                dbgD3DError();
                nvCelsiusDispatchNonIndexedPrimitive (pContext, wPrimCount);
            }
            else
#endif  // NVARCH >= 0x010
            {
                DDSTARTTICK(PRIM_DRAWLINESTRIPNONINDEXED);
                DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wNumVertices);
                nvDrawLine (pContext, wPrimCount);
                DDENDTICK(PRIM_DRAWLINESTRIPNONINDEXED);
            }

            break;

        case D3DPT_POINTLIST:

            // nvDrawPointList((DWORD)((LPD3DHAL_DP2POINTS)lpPrim)->wCount, (LPD3DTLVERTEX)&pVertices[((LPD3DHAL_DP2POINTS)lpPrim)->wVStart]);
            break;

    }

    /*
     * Update the put offset.
     */
    nvPusherStart (FALSE);
    pDriverData->TwoDRenderingOccurred   = 0;
    pDriverData->ThreeDRenderingOccurred = TRUE;
    DDENDTICK(PRIM_DRAWPRIMITIVE);
    return;
}

//---------------------------------------------------------------------------

/*
 * DirectX 5.0 DrawOnePrimitive entry point.
 */

DWORD nvDrawOnePrimitive
(
    LPD3DHAL_DRAWONEPRIMITIVEDATA pdopd
)
{
    dbgTracePush ("nvDrawOnePrimitive");

    DDSTARTTICK(PRIM_DRAWONEPRIMITIVE);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, pdopd->dwNumVertices);

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

#ifdef NV_NULL_DRIVER
    pdopd->ddrval = DD_OK;
    DDENDTICK(PRIM_DRAWONEPRIMITIVE);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
#endif //NV_NULL_DRIVER

    nvAssert (global.dwDXRuntimeVersion < 0x0700);

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pdopd);

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED)
    {
        pdopd->ddrval = DD_OK;
        DDENDTICK(PRIM_DRAWONEPRIMITIVE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

#if (NVARCH >= 0x010)
    if (pContext && pContext->aa.isEnabled())
    {
        pContext->aa.makeSuperBufferValid(pContext);
        if(pContext->aa.pSuperZetaBuffer) pContext->aa.makeSuperZBValid(pContext);
    }
#endif  // NVARCH >= 0x010

    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvD3DRecover();
        }
        else {
            pdopd->ddrval = DD_OK;
            DDENDTICK(PRIM_DRAWONEPRIMITIVE);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

    // Just pass off this call to the DrawPrimitive helper routine.
    if (pdopd->dwNumVertices)
    {
        // If the surface has changed since the last render call, switch it now.
        nvDrawPrimitive (pContext,
                         (WORD)pdopd->PrimitiveType,
                         (WORD)pdopd->dwNumVertices,
                         (LPBYTE)pdopd->lpvVertices);
    }

    // Return successfully.
    pdopd->ddrval = DD_OK;
    DDENDTICK(PRIM_DRAWONEPRIMITIVE);

    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

//---------------------------------------------------------------------------

/*
 * DirectX 5.0 DrawPrimitives entry point.
 */

DWORD nvDrawPrimitives
(
    LPD3DHAL_DRAWPRIMITIVESDATA pdpd
)
{
    WORD                        wStateCount;
    LPBYTE                      lpData;
    LPDWORD                     lpStateChanges;
    LPD3DHAL_DRAWPRIMCOUNTS     lpDrawPrimCounts;

    dbgTracePush ("nvDrawPrimitives");

    DDSTARTTICK(PRIM_DRAWPRIMITIVES);

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

#ifdef NV_NULL_DRIVER
    pdpd->ddrval = DD_OK;
    DDENDTICK(PRIM_DRAWPRIMITIVES);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
#endif //NV_NULL_DRIVER

    nvAssert (global.dwDXRuntimeVersion < 0x0700);

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pdpd);

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        pdpd->ddrval = DD_OK;
        DDENDTICK(PRIM_DRAWPRIMITIVES);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvD3DRecover();
        }
        else {
            pdpd->ddrval = DD_OK;
            DDENDTICK(PRIM_DRAWPRIMITIVES);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

    if ((pContext->bStateChange || pDriverData->TwoDRenderingOccurred)
     || (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE))
        NV_FORCE_TRI_SETUP(pContext);

    /*
     * Get the pointer to the primitive data.
     */
    lpData            = (LPBYTE)pdpd->lpvData;
    lpDrawPrimCounts  = (LPD3DHAL_DRAWPRIMCOUNTS)lpData;

    /*
     * Step through callback data until there are no more vertices left
     * in the structure.
     */
    do
    {
        /*
         * Get the next draw primitive data structure.
         */
        lpDrawPrimCounts  = (LPD3DHAL_DRAWPRIMCOUNTS)lpData;
        lpData           += sizeof(D3DHAL_DRAWPRIMCOUNTS);

        DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)lpDrawPrimCounts->wNumVertices);
        if (!lpDrawPrimCounts)
        {
            dbgD3DError();
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvDrawPrimitives - Invalid lpDrawPrimCounts!!");
        }

        /*
         * Get the pointer to the first set of state change data.
         * If the wNumStateChanges value is 0, then there are no
         * state changes for this set of vertices.  This can happen
         * at any time, including for the first set of vertices, which
         * means that the current state should be used, or even for
         * two or more blocks of vertices in a row.
         */
        lpStateChanges    = (LPDWORD)lpData;
        if (!lpStateChanges)
        {
            dbgD3DError();
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvDrawPrimitives - Invalid lpDrawPrimCounts!!");
        }
        if (wStateCount = lpDrawPrimCounts->wNumStateChanges)
        {
            while (wStateCount--)
            {
                // Process the state changes for the next set of vertices.
                nvSetContextState (pContext, lpStateChanges[0], lpStateChanges[1], &pdpd->ddrval);
                if (pdpd->ddrval != DD_OK)
                {
                    DDENDTICK(PRIM_DRAWPRIMITIVES);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
                lpStateChanges += 2;
            }
            /*
             * If the state has changed force a hardware state load.
             */
            if (pContext->bStateChange) {
                NV_FORCE_TRI_SETUP(pContext);
            }
        }

        /*
         * Move the pointer to the first block of vertices to be rendered.
         */
        lpData += ((lpDrawPrimCounts->wNumStateChanges * sizeof(DWORD) * 2) + 31);
        lpData = (LPBYTE)((DWORD)lpData & ~31);

        /*
         * Render the vertices.
         */
        if (lpDrawPrimCounts->wNumVertices)
        {
            WORD wPrimitiveType = lpDrawPrimCounts->wPrimitiveType;

            nvDrawPrimitive (pContext,
                             wPrimitiveType,
                             lpDrawPrimCounts->wNumVertices,
                             lpData);

            lpData += (lpDrawPrimCounts->wNumVertices * sizeof(D3DTLVERTEX));
        }
    } while (lpDrawPrimCounts->wNumVertices);

    /*
     * Return successfully.
     */
    pdpd->ddrval = DD_OK;
    DDENDTICK(PRIM_DRAWPRIMITIVES);

    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

//---------------------------------------------------------------------------

DWORD nvDrawOneIndexedPrimitive
(
    LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA pdoipd
)
{
    CVertexBuffer *pVertexBuffer;
    LPBYTE pIndices;
    DWORD  dwPrimCount;

    dbgTracePush ("nvDrawOneIndexedPrimitive");

    DDSTARTTICK(PRIM_DRAWONEINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)pdoipd->dwNumIndices);

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

#ifdef NV_NULL_DRIVER
    pdoipd->ddrval = DD_OK;
    DDENDTICK(PRIM_DRAWONEINDEXED);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
#endif //NV_NULL_DRIVER

    nvAssert (global.dwDXRuntimeVersion < 0x0700);

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pdoipd);

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        pdoipd->ddrval = DD_OK;
        DDENDTICK(PRIM_DRAWONEINDEXED);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

#if (NVARCH >= 0x010)
    if (pContext && pContext->aa.isEnabled())
    {
        pContext->aa.makeSuperBufferValid(pContext);
        if(pContext->aa.pSuperZetaBuffer) pContext->aa.makeSuperZBValid(pContext);
    }
#endif  // NVARCH >= 0x010

    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvD3DRecover();
        }
        else {
            pdoipd->ddrval = DD_OK;
            DDENDTICK(PRIM_DRAWONEINDEXED);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

    pContext->pCurrentVShader->create (pContext, D3DFVF_TLVERTEX, CVertexShader::getHandleFromFvf(D3DFVF_TLVERTEX));

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_TL_MODE |
                                       CELSIUS_DIRTY_FVF |
                                       CELSIUS_DIRTY_LIGHTS);
    pContext->hwState.dwDirtyFlags |= (KELVIN_DIRTY_FVF |
                                       KELVIN_DIRTY_LIGHTS);
#endif  // nv20

    if (pdoipd->dwNumVertices && pdoipd->dwNumIndices)
    {
        pIndices           = (LPBYTE)(pdoipd->lpwIndices);

        // cast plain vertex data into a vertex buffer
        pVertexBuffer = getDC()->defaultSysVB.getVB();
        pVertexBuffer->own ((DWORD)(pdoipd->lpvVertices),
                            pdoipd->dwNumVertices * sizeof(D3DTLVERTEX),
                            CSimpleSurface::HEAP_SYS);
        // cast vertex buffer into DX8-style streams
        for (int i=0; i<NV_CAPS_MAX_STREAMS; i++) {
            pContext->ppDX8Streams[i] = pVertexBuffer;
        }

        /*
         * Send down the surface information if neccessary.
         */
        switch (pdoipd->PrimitiveType) {

            case D3DPT_TRIANGLELIST:

                pContext->dp2.dwDP2Prim = D3DDP2OP_INDEXEDTRIANGLELIST2;
                pContext->dp2.dwIndices = (DWORD)(pIndices);

                dwPrimCount =  pdoipd->dwNumIndices / 3;

#if (NVARCH >= 0x020)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                    DPF ("ugh. got a legacy call to nvDrawOneIndexedPrimitive on an nv20.");
                    DPF ("this is totally untested, may very well not work.");
                    dbgD3DError();
                    nvKelvinDispatchIndexedPrimitive (pContext, (WORD)dwPrimCount);
                }
                else
#endif  // (NVARCH >= 0x020)
#if (NVARCH >= 0x010)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                    DPF ("ugh. got a legacy call to nvDrawOneIndexedPrimitive on an nv10.");
                    DPF ("this is totally untested, may very well not work.");
                    dbgD3DError();
                    nvCelsiusDispatchIndexedPrimitive (pContext, (WORD)dwPrimCount);
                }
                else
#endif  // NVARCH >= 0x010
                {
                    switch (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]) {
                        case D3DFILL_SOLID:
                            nvTriangleDispatch (pContext, (WORD)dwPrimCount);
                            break;
                        case D3DFILL_WIREFRAME:
                            nvIndexedWireframeTriangle (pContext, (WORD)dwPrimCount);
                            break;
                        case D3DFILL_POINT:
                            nvIndexedPointTriangle (pContext, (WORD)dwPrimCount);
                            break;
                    }
                }

                break;

            case D3DPT_TRIANGLESTRIP:

                pContext->dp2.dwDP2Prim = D3DDP2OP_INDEXEDTRIANGLESTRIP;
                pContext->dp2.dwIndices = (DWORD)(pIndices);

                dwPrimCount = pdoipd->dwNumIndices - 2;

#if (NVARCH >= 0x020)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                    DPF ("ugh. got a legacy call to nvDrawOneIndexedPrimitive on an nv20.");
                    DPF ("this is totally untested, may very well not work.");
                    dbgD3DError();
                    nvKelvinDispatchIndexedPrimitive (pContext, (WORD)dwPrimCount);
                }
                else
#endif  // (NVARCH >= 0x020)
#if (NVARCH >= 0x010)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                    DPF ("ugh. got a legacy call to nvDrawOneIndexedPrimitive on an nv10.");
                    DPF ("this is totally untested, may very well not work.");
                    dbgD3DError();
                    nvCelsiusDispatchIndexedPrimitive (pContext, (WORD)dwPrimCount);
                }
                else
#endif  // NVARCH >= 0x010
                {
                    switch (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]) {
                        case D3DFILL_SOLID:
                            nvTriangleDispatch (pContext, (WORD)dwPrimCount);
                            break;
                        case D3DFILL_WIREFRAME:
                            nvIndexedWireframeTriangle (pContext, (WORD)dwPrimCount);
                            break;
                        case D3DFILL_POINT:
                            nvIndexedPointTriangle (pContext, (WORD)dwPrimCount);
                            break;
                    }
                }

                break;

            case D3DPT_TRIANGLEFAN:

                pContext->dp2.dwDP2Prim = D3DDP2OP_INDEXEDTRIANGLEFAN;
                pContext->dp2.dwIndices = (DWORD)(pIndices);

                dwPrimCount = pdoipd->dwNumIndices - 2;

#if (NVARCH >= 0x020)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                    DPF ("ugh. got a legacy call to nvDrawOneIndexedPrimitive on an nv20.");
                    DPF ("this is totally untested, may very well not work.");
                    dbgD3DError();
                    nvKelvinDispatchIndexedPrimitive (pContext, (WORD)dwPrimCount);
                }
                else
#endif  // (NVARCH >= 0x020)
#if (NVARCH >= 0x010)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                    DPF ("ugh. got a legacy call to nvDrawOneIndexedPrimitive on an nv10.");
                    DPF ("this is totally untested, may very well not work.");
                    dbgD3DError();
                    nvCelsiusDispatchIndexedPrimitive (pContext, (WORD)dwPrimCount);
                }
                else
#endif  // NVARCH >= 0x010
                {
                    switch (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]) {
                        case D3DFILL_SOLID:
                            nvTriangleDispatch (pContext, (WORD)dwPrimCount);
                            break;
                        case D3DFILL_WIREFRAME:
                            nvIndexedWireframeTriangle (pContext, (WORD)dwPrimCount);
                            break;
                        case D3DFILL_POINT:
                            nvIndexedPointTriangle (pContext, (WORD)dwPrimCount);
                            break;
                    }
                }

                break;

            case D3DPT_LINELIST:

                pContext->dp2.dwDP2Prim = D3DDP2OP_INDEXEDLINELIST;
                pContext->dp2.dwIndices = (DWORD)(pIndices);

                dwPrimCount = pdoipd->dwNumIndices / 2;

#if (NVARCH >= 0x020)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                    DPF ("ugh. got a legacy call to nvDrawOneIndexedPrimitive on an nv20.");
                    DPF ("this is totally untested, may very well not work.");
                    dbgD3DError();
                    nvKelvinDispatchIndexedPrimitive (pContext, (WORD)dwPrimCount);
                }
                else
#endif  // (NVARCH >= 0x020)
#if (NVARCH >= 0x010)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                    DPF ("ugh. got a legacy call to nvDrawOneIndexedPrimitive on an nv10.");
                    DPF ("this is totally untested, may very well not work.");
                    dbgD3DError();
                    nvCelsiusDispatchIndexedPrimitive (pContext, (WORD)dwPrimCount);
                }
                else
#endif  // NVARCH >= 0x010
                {
                    nvIndexedLine (pContext, (WORD)dwPrimCount);
                }

                break;

            case D3DPT_LINESTRIP:

                pContext->dp2.dwDP2Prim = D3DDP2OP_INDEXEDLINESTRIP;
                dwPrimCount = pdoipd->dwNumIndices - 1;

#if (NVARCH >= 0x020)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                    DPF ("ugh. got a legacy call to nvDrawOneIndexedPrimitive on an nv20.");
                    DPF ("this is totally untested, may very well not work.");
                    dbgD3DError();
                    nvKelvinDispatchIndexedPrimitive (pContext, (WORD)dwPrimCount);
                }
                else
#endif // (NVARCH >= 0x020)
#if (NVARCH >= 0x010)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                    DPF ("ugh. got a legacy call to nvDrawOneIndexedPrimitive on an nv10.");
                    DPF ("this is totally untested, may very well not work.");
                    dbgD3DError();
                    nvCelsiusDispatchIndexedPrimitive (pContext, (WORD)dwPrimCount);
                }
                else
#endif  // NVARCH >= 0x010
                {
                    nvIndexedLine (pContext, (WORD)dwPrimCount);
                }

                break;

            case D3DPT_POINTLIST:
                /*
                 * Indexed points kind of suck under the current scheme.
                 */
                break;
        }

        /*
         * Tell DDRAW that thee global clip state has changed.
         * Probably don't need this, but I'd rather be safe.
         */
        pDriverData->ddClipUpdate = TRUE;
    }

    /*
     * Update the put offset.
     */
    nvPusherStart (FALSE);

    pDriverData->TwoDRenderingOccurred   = 0;
    pDriverData->ThreeDRenderingOccurred = TRUE;

    /*
     * Return successfully.
     */
    pdoipd->ddrval = DD_OK;
    DDENDTICK(PRIM_DRAWONEINDEXED);

    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

#endif  // !WINNT

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvProf.cpp ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvProf.cpp                                                        *
*   NV4 specific profiling routines.                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 05/28/98 - NV4 development.             *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#ifdef WINNT
#include "nvapi.h"
#endif

#include "nvaccess.h"

#include "..\..\..\common\src\nvPM.c"

#ifdef CAPTURE
#ifndef WINNT
#include "..\..\..\common\src\nvCapture.c"
#endif
#endif

//
// nv_ref.h - RM guys wil get me a better way to read this
//
#define NV_PBUS_PCI_NV_18                                0x00001848 /* RW-4R */
#define NV_PBUS_PCI_NV_18__ALIAS_1              NV_CONFIG_PCI_NV_18 /*       */
#define NV_CONFIG_PCI_NV_18                              0x00000048 /* RW-4R */
#define NV_CONFIG_PCI_NV_18__ALIAS_1              NV_PBUS_PCI_NV_18 /*       */

#define NV_PBUS_PCI_NV_18_AGP_STATUS_RQ                       31:24 /* C--VF */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RQ_32               0x0000001F /* C---V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_SBA                        9:9 /* R--VF */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_SBA_NONE            0x00000000 /* R---V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_SBA_CAPABLE         0x00000001 /* R---V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_FW                         4:4 /* R--VF */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_FW_NONE             0x00000000 /* R---V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_FW_CAPABLE          0x00000001 /* R---V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RATE                       2:0 /* R--VF */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RATE_1X             0x00000001 /* R---V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RATE_2X             0x00000002 /* ----V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RATE_1X_AND_2X      0x00000003 /* R---V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RATE_4X             0x00000004 /* R---V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RATE_1X_2X_4X       0x00000007 /* R---V */

#define NV_PBUS_PCI_NV_19                                0x0000184C /* RW-4R */
#define NV_PBUS_PCI_NV_19__ALIAS_1              NV_CONFIG_PCI_NV_19 /*       */
#define NV_CONFIG_PCI_NV_19                              0x0000004C /* RW-4R */
#define NV_CONFIG_PCI_NV_19__ALIAS_1              NV_PBUS_PCI_NV_19 /*       */

#define NV_PBUS_PCI_NV_19_AGP_COMMAND_RQ_DEPTH                28:24 /* RWIVF */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_RQ_DEPTH_0         0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE                9:9 /* RWIVF */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE_OFF     0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE_ON      0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE                8:8 /* RWIVF */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE_OFF     0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE_ON      0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_FW_ENABLE                 4:4 /* RWIVF */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_FW_ENABLE_OFF      0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_FW_ENABLE_ON       0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_DATA_RATE                 2:0 /* RWIVF */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_DATA_RATE_OFF      0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_DATA_RATE_1X       0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_DATA_RATE_2X       0x00000002 /* RW--V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_DATA_RATE_4X       0x00000004 /* RW--V */

//
//  NV4 PCI defines - These values should match those in NV4_REF.H
//
#define NV4_VENDOR_ID                   0x10DE
#define ST4_VENDOR_ID                   0x10DE
#define NV4_DEVICE_VGA_ID               0x0008
#define NV4_DEVICE_NV4_ID               0x0020
#define NV5_DEVICE_NV5_ID               0x0028
#define NV5ULTRA_DEVICE_NV5ULTRA_ID     0x0029
#define NV5VANTA_DEVICE_NV5VANTA_ID     0x002C
#define NV5MODEL64_DEVICE_NV5MODEL64_ID 0x002D
#define NV0A_DEVICE_NV0A_ID             0x00A0
#define NV10_DEVICE_NV10_ID             0x0100
#define NV10DDR_DEVICE_NV10DDR_ID       0x0101
#define NV10GL_DEVICE_NV10GL_ID         0x0103
#define NV11_DEVICE_NV11_ID             0x0110
#define NV11DDR_DEVICE_NV11DDR_ID       0x0111
#define NV11M_DEVICE_NV11M_ID           0x0112
#define NV11GL_DEVICE_NV11GL_ID         0x0113
#define NV15_DEVICE_NV15_ID             0x0150
#define NV15DDR_DEVICE_NV15DDR_ID       0x0151
#define NV15BR_DEVICE_NV15BR_ID         0x0152
#define NV15GL_DEVICE_NV15GL_ID         0x0153
#define NV20_DEVICE_NV20_ID             0x0200
#define NV20_DEVICE_NV20_1_ID           0x0201
#define NV20_DEVICE_NV20_2_ID           0x0202
#define NV20_DEVICE_NV20_3_ID           0x0203




#ifdef NV_PROFILE

/*
 * Locutus profiler section
 */

//////////////////////////////////////////////////////////////////////////////
// constants

#define BTFT_1              0x42EC5201  // version 1 file header
#define BTRT_EOF            0xff

#define BTAA_EVENT          0x00000000  // event
#define BTAA_TIME           0x00000001  // time
#define BTAA_COUNT          0x00000002  // count

#define CAP_SIZE            (65536*16)
#define CAP_MARK            (CAP_SIZE - 32)

//////////////////////////////////////////////////////////////////////////////
// structures
#pragma pack(push,1)

typedef __int64 CBTTime;
typedef int     CBTCount;

typedef struct {
    char  m_szName[16];                 // human readable description
    DWORD m_dwRecordSize;               // size of record
    DWORD m_dwAttributes;               // Record description
} CBTAlphabet;

typedef struct {
    DWORD dwFileType;
    DWORD dwClockSpeed;
    DWORD dwAlphabetCount;
} CBTHeader;
#pragma pack(pop)

//////////////////////////////////////////////////////////////////////////////
// locals
#ifndef WINNT
DWORD   nvDeviceBase;           // nv base address
#endif
__int64 nvpTime[256];           // stopwatch storage
#define nvp_time nvpTime        // alias
int     nvp_context_count = 1;  // we count contexi to generate unique file names
HANDLE  nvp_file          = 0;  // capture file
BYTE    nvp_buffer[CAP_SIZE];   // local capture buffer
DWORD   nvp_index;              // buffer index

CBTAlphabet nvp_alphabet[] = {
    { "BeginScene",         0,  BTAA_EVENT }, // #define NVP_E_BEGINSCENE            0
    { "Put",                0,  BTAA_EVENT }, // #define NVP_E_PUT                   1

    { "HDFlush",            8,  BTAA_TIME  }, // #define NVP_T_HDFLUSH               2
    { "SceneTime",          8,  BTAA_TIME  }, // #define NVP_T_SCENE                 3
    { "DrawPrim2Time",      8,  BTAA_TIME  }, // #define NVP_T_DP2                   4
#ifdef NV_PROFILE_CPULOCK
    { "lockVBDP2Exit",      8,  BTAA_TIME  }, // #define NVP_T_VBDP2_LOCK            5 // dp2 exit cpu lock
    { "lockVB",             8,  BTAA_TIME  }, // #define NVP_T_VB_LOCK               6 // D3DLockExecuteBuffer
    { "lockVBInline",       8,  BTAA_TIME  }, // #define NVP_T_VB_INLINE             7 // inline VB lock
    { "lockTexULS",         8,  BTAA_TIME  }, // #define NVP_T_TEX_ULS               8 // update linear surface
    { "lockTexUSS",         8,  BTAA_TIME  }, // #define NVP_T_TEX_USS               9 // update swizzle surface
    { "lockTexBlt",         8,  BTAA_TIME  }, // #define NVP_T_TEX_BLT              10 // nvTextureBlt
    { "lockTexLock",        8,  BTAA_TIME  }, // #define NVP_T_TEX_LOCK             11 // nvTextureLock
    { "float0",             8,  BTAA_TIME  }, // #define NVP_T_FLOAT0               12
    { "float1",             8,  BTAA_TIME  }, // #define NVP_T_FLOAT1               13
#endif
#ifdef NV_PROFILE_PUSHER
    { "WrapAround",         8,  BTAA_TIME  }, // #define NVP_T_WRAPAROUND            5
    { "MakeSpace",          8,  BTAA_TIME  }, // #define NVP_T_MAKESPACE             6
    { "Adjust",             8,  BTAA_TIME  }, // #define NVP_T_ADJUST                7
    { "FlushTime",          8,  BTAA_TIME  }, // #define NVP_T_FLUSH                 8 // time spend waiting in nvPusherFlush
    { "PendingSize",        4,  BTAA_COUNT }, // #define NVP_C_PENDINGSIZE           9 // size of pending pushe buffer (at put time)
    { "Put",                4,  BTAA_COUNT }, // #define NVP_C_PUT                  10
    { "Get",                4,  BTAA_COUNT }, // #define NVP_C_GET                  11
    { "Velocity",           4,  BTAA_COUNT }, // #define NVP_C_VELOCITY             12
#endif
#ifdef NV_PROFILE_CALLSTACK
    { "SetCelsiusState",    8,  BTAA_TIME  }, // #define NVP_T_SETCELSIUSSTATE       5
    { "SetKelvinState",     8,  BTAA_TIME  }, // #define NVP_T_SETKELVINSTATE        6
    { "IdxDispatch",        8,  BTAA_TIME  }, // #define NVP_T_IDXDISPATCH           7
    { "OrdDispatch",        8,  BTAA_TIME  }, // #define NVP_T_ORDDISPATCH           8
#endif
#ifdef NV_PROFILE_DEFVB
    { "put",                4,  BTAA_COUNT }, // #define NVP_C_PUT                   5
    { "get",                4,  BTAA_COUNT }, // #define NVP_C_GET                   6
    { "freeCount",          4,  BTAA_COUNT }, // #define NVP_C_FREECOUNT             7
    { "Primitive",          0,  BTAA_EVENT }, // #define NVP_E_PRIM                  8
#endif
#ifdef NV_PROFILE_COPIES
    { "renAutoCopy",        8,  BTAA_TIME  }, // #define NVP_T_RENAME_AUTO_COPY      5
    { "lin2swz2",           8,  BTAA_TIME  }, // #define NVP_T_LIN2SWZ2              6
    { "renForward",         8,  BTAA_TIME  }, // #define NVP_T_RENAME_FWD            7
#endif
};

//    { "BeginScene",         0,  BTAA_EVENT }, // 0          0x00000001  *
//    { "CSimpleSurface::cpuLock",  8,  BTAA_TIME  }, // 1
//


bool PusherProfilingEnabled = false;

void nvpSetLogPusher(bool log)
{
    PusherProfilingEnabled = log;
}

bool nvpGetLogPusher()
{
    return PusherProfilingEnabled;
}

void nvpCreate (void) {
    char  s[256];

#ifndef WINNT
    nvDeviceBase = (U032)NvDeviceBaseGet(NV_DEV_BASE,pDriverData->dwDeviceIDNum);
#endif

    nvSprintf (s,"\\captr%03d.btd",nvp_context_count);
    nvp_file=NvCreateFile(s,GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
    if (nvp_file==INVALID_HANDLE_VALUE) {
#ifndef WINNT
        MessageBeep (0);
#endif
        __asm int 3;
    }
    nvp_context_count ++;

// place header
    nvp_index = 0;
    *(DWORD*)(nvp_buffer + nvp_index) = BTFT_1;
    nvp_index += 4;
    *(DWORD*)(nvp_buffer + nvp_index) = pDriverData->nvD3DPerfData.dwProcessorSpeed;
    nvp_index += 4;
    *(DWORD*)(nvp_buffer + nvp_index) = sizeof(nvp_alphabet)/sizeof(nvp_alphabet[0]);
    nvp_index += 4;
    memcpy (nvp_buffer+nvp_index,nvp_alphabet,sizeof(nvp_alphabet));
    nvp_index += sizeof(nvp_alphabet);

    nvpSetLogPusher(true);
}



void nvpDestroy (void) {
    nvp_buffer[nvp_index++] = BTRT_EOF;
    nvpFlush();
    NvCloseHandle (nvp_file);
    nvpSetLogPusher(false);
}

void nvpFlush (void) {
    NVP_START (NVP_T_HDFLUSH);
    if (nvp_index) {
        DWORD dw;
        if (!NvWriteFile(nvp_file,nvp_buffer,nvp_index,&dw,0)) {
#ifdef WINNT
            __asm {
                int 3
            }
#else
          DWORD dw=GetLastError();
           __asm {
              mov eax,[dw]
              int 3
          }
#endif
        }
        FlushFileBuffers (nvp_file);
        nvp_index = 0;
    }
    NVP_STOP (NVP_T_HDFLUSH);
    nvpLogTime (NVP_T_HDFLUSH,nvpTime[NVP_T_HDFLUSH]);
}

void nvpLogEvent (DWORD id) {
    nvp_buffer[nvp_index++] = (BYTE)id;
    if (nvp_index>CAP_MARK) nvpFlush();
}

void nvpLogCount (DWORD id,int count) {
    BYTE *b = nvp_buffer + nvp_index;
    *((BYTE*)b)         = (BYTE)id;
    *((CBTCount*)(b+1)) = count;
    nvp_index += sizeof(BYTE)+sizeof(CBTCount);
    if (nvp_index>CAP_MARK) nvpFlush();
}

void nvpLogTime (DWORD id,__int64 time) {
/*
    if (id == NVP_T_VBDP2_LOCK)
    {
        double t = double(time) / double(global.dwProcessorSpeed);
        if (t >= 1000.0)
        {
            __asm int 3;
        }
    }
*/

    BYTE *b = nvp_buffer + nvp_index;
    *((BYTE*)b)        = (BYTE)id;
    *((CBTTime*)(b+1)) = time;
    nvp_index += sizeof(BYTE)+sizeof(CBTTime);
    if (nvp_index>CAP_MARK) nvpFlush();
}

#endif // NV_PROFILE

#if 0
//////////////////////////////////////////////////////////////////////////////
// Processor Speed
//
#define LATCH_VALUE(x,y)    if (fabs(((x)-(y))/(y)) < 0.05) return (DWORD)(y)

__int64 _clock_ticks;
DWORD nvGetCPUSpeed (void) {
    double      speed;
    DWORD       dwCaps;
    SYSTEM_INFO si;

    GetSystemInfo (&si);
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) return 1; // unknown
    if (si.dwProcessorType != PROCESSOR_INTEL_PENTIUM) return 1; // not pentium

    __asm
    {
        pushad
        mov eax,1
        // cpuid
        _emit 0x0f
        _emit 0xa2
        mov [dwCaps],edx
        popad
    }
    if (!(dwCaps & 0x00000010)) return 1; // does not have tsc


    SetPriorityClass  (GetCurrentProcess(),REALTIME_PRIORITY_CLASS);
    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
    GetTickCount(); // break in cache
    {
        DWORD start,stop;

        start = GetTickCount();
        __asm {
            pushad

            // rdtsc
            _emit 0x0f
            _emit 0x31
            mov ebp,eax
            mov ebx,edx
#ifdef NV_PROFILE
            mov ecx,8000000h
#else
            mov ecx,1000000h
#endif
        here:
            loop here

            // rdtsc
            _emit 0x0f
            _emit 0x31
            sub eax,ebp
            sbb edx,ebx

            mov [dword ptr _clock_ticks  ],eax
            mov [dword ptr _clock_ticks+4],edx

            popad
        }
        stop = GetTickCount();
        speed = ((double)_clock_ticks)/(1000.0*(double)(stop-start));
    }
    SetPriorityClass  (GetCurrentProcess(),NORMAL_PRIORITY_CLASS);
    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_NORMAL);

// normalize to known values
    LATCH_VALUE (speed, 90);
    LATCH_VALUE (speed,100);
    LATCH_VALUE (speed,166);
    LATCH_VALUE (speed,200);
    LATCH_VALUE (speed,233);
    LATCH_VALUE (speed,266);
    LATCH_VALUE (speed,300);
    LATCH_VALUE (speed,333);
    LATCH_VALUE (speed,400);
    LATCH_VALUE (speed,450);
    LATCH_VALUE (speed,500);
    LATCH_VALUE (speed,550);
    LATCH_VALUE (speed,600);
// did not latch - return unaltered (can be up to 10% off)
    return (DWORD)speed;
}

BOOL nvDetectMMX
(
    void
)
{
    DWORD       dwCaps;
    SYSTEM_INFO si;

    GetSystemInfo (&si);
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) return FALSE; // unknown
    if (si.dwProcessorType != PROCESSOR_INTEL_PENTIUM) return FALSE; // not pentium

    __asm
    {
        pushad
        mov eax,1
        // cpuid
        _emit 0x0f
        _emit 0xa2
        mov [dwCaps],edx
        popad
    }

    return (dwCaps & 0x00800000) ? TRUE : FALSE;
}

BOOL nvDetectKATMAI
(
    void
)
{
    DWORD         dwCaps;
    SYSTEM_INFO   si;
    OSVERSIONINFO osvi;
    BOOL          bIsWindows98orLater;

    GetSystemInfo (&si);
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) return FALSE; // unknown
    if (si.dwProcessorType != PROCESSOR_INTEL_PENTIUM) return FALSE; // not pentium

    __asm
    {
        pushad
        mov eax,1
        // cpuid
        _emit 0x0f
        _emit 0xa2
        mov [dwCaps],edx

/*
        //mov eax,cr4
        _emit 0x0f
        _emit 0x20
        _emit 0xe0
        mov [dwCR4],eax
*/
        popad
    }

    /*
     * detect at least win 98
     */
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx (&osvi);
    bIsWindows98orLater = (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
                       && ((osvi.dwMajorVersion > 4)
                        || ((osvi.dwMajorVersion == 4)
                         && (osvi.dwMinorVersion > 0)));

    return ((dwCaps & 0x02000000) && bIsWindows98orLater/*&& (dwCR4 & 0x200)*/) ? TRUE : FALSE;
}
#endif

#ifdef VTUNE_SUPPORT
/*****************************************************************************
 * support for vtuning inner loops
 *****************************************************************************/

#define DB(x)       __asm _emit ((x) & 255)
#define DW(x)       DB(x) DB((x) >> 8)
#define DD(x)       DW(x) DW((x) >> 16)

#define PAD1        __asm _emit 0x00
#define PAD8        PAD1    PAD1    PAD1    PAD1    PAD1    PAD1    PAD1    PAD1
#define PAD64       PAD8    PAD8    PAD8    PAD8    PAD8    PAD8    PAD8    PAD8
#define PAD4096     PAD64   PAD64   PAD64   PAD64   PAD64   PAD64   PAD64   PAD64
#define PAD32768    PAD4096 PAD4096 PAD4096 PAD4096 PAD4096 PAD4096 PAD4096 PAD4096

/*
 * memory object
 */
void __declspec(naked) nvVTuneMemoryImage
(
    void
)
{
    // signature
    DD(0x420352ec) DD(0xdeadbeef) DD(0x0badcafe) DD(0x0badbeef)
    DD(0x0badbeef) DD(0x0badcafe) DD(0xdeadbeef) DD(0x420352ec)
    // size
    DD(2*65536)
    // data goes here...
    PAD32768
    PAD32768
    PAD32768
    PAD32768
}

typedef struct
{
    DWORD dwAddr;       // +0
    DWORD dwSize;       // +4
} ring0params;

#define CR3Base     (0xffbfe000)
#define Alias       (0x100)
#define Addr        ((Alias << 22) | ((Alias + 1) << 12))

//
// NOTE: the logic here is broken - see r0SetPATIndices for the correct algorithm
void __declspec(naked) __cdecl ring0 (NvU32 a)
{
    __asm
    {
        jmp start

ord:  // or physical address (or [ebx],eax)
        push ebx
        push ecx
        push esi
        push edi

        //cli
        mov edi,ebx
        mov ebx,cr3
        mov esi,CR3Base + Alias * 4

        push dword ptr [esi]
        push dword ptr [esi + 4]

        mov ecx,ebx
        and ecx,~0x3ff
        or  ecx,7
        mov [esi],ecx

        mov ecx,edi
        and ecx,~0x3ff
        or  ecx,7
        mov [esi + 4],ecx
        mov cr3,ebx
        jmp n1
n1:

        mov ecx,edi
        and ecx,0x3ff
        add ecx,Addr
        or [ecx],eax

        pop dword ptr [esi + 4]
        pop dword ptr [esi]
        mov cr3,ebx
        jmp n2
n2:
        //sti

        pop edi
        pop esi
        pop ecx
        pop ebx
        ret

start:
        push ebp
        lea ebp,[esp + 8]
        pushad

        mov eax,[ebp + 0]   //rpm
        mov edx,[eax + 0]   // addr
        mov ecx,[eax + 4]   // size

nextpage:// get pde
         mov ebx,edx
         shr ebx,22
         mov eax,[CR3Base + ebx * 4]
         or  eax,2
         mov [CR3Base + ebx * 4],eax    // make writeable

         // get pte
         and eax,~0x3ff
         mov ebx,edx
         shr ebx,10
         and ebx,0x3fc
         or  ebx,eax
         mov eax,2
         call ord                       // make writeable

         // next
         sub ecx,4096
         add edx,4096
         cmp ecx,4096
        jge nextpage

        popad
        pop ebp
        xor eax,eax
        ret
    }
}

#undef Addr
#undef Alias
#undef CR3Base
void nvVTuneModifyAccessRights
(
    void
)
{
    DWORD dwBase;
    DWORD dwAddr;
    DWORD dwSize;
    DWORD i,j;

    /*
     * extract address & size of VTune block
     */
    dwBase = (DWORD)nvVTuneMemoryImage;
    dwSize = *(DWORD*)(dwBase + 32);
    dwAddr = dwBase + 36;

    /*
     * page in all pages (rely on a little luck and a lru paging meganism)
     */
    for (i = dwSize,j = dwAddr; !(i & 0x80000000); i -= 4096,j += 4096)
    {
        DWORD dwForceUse = *(volatile DWORD*)j;
    }

    /*
     * lock them down (dont want them paged out since the data is volatile)
     */
    if (!VirtualLock((void*)dwAddr,dwSize))
    {
        DPF ("*** FAILED to lock memory        ***");
        DPF ("*** GPF could happen at any time ***");
        __asm int 3;
    }

    /*
     * modify access rights to execute & r/w
     */
    {
        ring0params rpm =
        {
            dwAddr,
            dwSize
        };
        NvRmRing0Callback (0,0,(DWORD)ring0,(DWORD)&rpm.dwAddr,0);
    }
    /*
    if (!VirtualProtect((void*)dwAddr,dwSize,PAGE_EXECUTE_READWRITE,&i))
    {
        DPF ("*** FAILED to modify access rights ***");
        DPF ("*** GPF soon to follow...          ***");
        __asm int 3;
    }
    */
}

void nvVTuneFlushData
(
    void
)
{
    DWORD  dwBase;
    DWORD  dwAddr;
    DWORD  dwSize;
    HANDLE h;

    /*
     * extract address & size of VTune block
     */
    dwBase = (DWORD)nvVTuneMemoryImage;
    dwSize = *(DWORD*)(dwBase + 32);
    dwAddr = dwBase + 36;

    /*
     * write it to disk
     */
//     h = NvCreateFile("\\rawloops.bin",GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
//     NvWriteFile (h,(void*)dwAddr,dwSize,&dwSize,NULL);
//     NvCloseHandle (h);
}

#endif

//---------------------------------------------------------------------------

// search for a particular class in a list of classes
// return TRUE if found, FALSE if not
// (right now this is just a dumb linear search. it could be better...)

__inline BOOL nvClassListCheck
(
    NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS params,
    DWORD dwClass
)
{
    DWORD i=0;
    while (i < params.numClasses) {
        if (params.classBuffer[i] == dwClass) {
            return (TRUE);
        }
        i++;
    }
    return (FALSE);
}

//---------------------------------------------------------------------------

/*
 * nvDeterminePerformanceStrategy
 *
 * detects HW and use this info together with the CPU info to figure out the best
 *  performance strategy. pDriverData->dwDeviceIDNum must be initialized
 */
#pragma optimize("g",off)

#define INFINITY ~0
BOOL __stdcall nvDeterminePerformanceStrategy
(
#ifdef WINNT
    GLOBALDATA *pDriverData, PDEV* ppdev
#else
    GLOBALDATA *pDriverData
#endif
)
{
    DWORD dwRoot, dwDevID;
    BOOL  bOverride = FALSE;
    DWORD dwWidth;
    DWORD dwNVCLK;
    DWORD dwMCLK;
    DWORD dwGPUMemory;
    DWORD dwCpuClock;
    DWORD dwCpuType;
    DWORD dwFullspeedFW;
    DWORD dwFastWrite;
    DWORD dwBusCaps;
    DWORD dwStrapCaps;
    DWORD dwBase;
    DWORD dwBusType;
    DWORD dwPCIID;
    DWORD dwArchitecture;
    DWORD dwRevision;
    DWORD dwGraphicsCaps;

    pDriverData->nvD3DPerfData.dwNVClasses      = 0;
    pDriverData->nvD3DPerfData.dwCPUFeatureSet  = 0;
    pDriverData->nvD3DPerfData.dwProcessorSpeed = 0;

    //
    // determine amount of memory present
    //
    {
        MEMORYSTATUS ms;
        LPMEMORYSTATUS lpms = &ms;
        ms.dwLength = sizeof(ms);
        GlobalMemoryStatus (lpms);

        // roughly the number of MB of system memory on the machine
        pDriverData->nvD3DPerfData.dwSystemMemory = ms.dwTotalPhys >> 20;
        // round to the ceiling 8 MB
        pDriverData->nvD3DPerfData.dwSystemMemory = (pDriverData->nvD3DPerfData.dwSystemMemory + 7) & ~7;
    }

    /*
     * determine installed HW
     *
     * at this point ddraw has not been initialized yet so this code is
     *  opening a RM channel for itself to do the detection and then
     *  close it.
     */

#ifndef WINNT
    dwRoot  = pDriverData->dwRootHandle;
    dwDevID = pDriverData->dwDeviceHandle;
    NvRmOpen();
#else
    {
        DWORD res;
        /*
        * Under WINNT, must id the correct device in a  multimon
        * system.
        */

        union
        {
                ULONG osName;
                char devName[NV_DEVICE_NAME_LENGTH_MAX+1];
        } nameBuffer;
        nameBuffer.osName = ppdev->ulDeviceReference;
        #define name nameBuffer.devName

        dwDevID = 0xDEAD0001;

        NvRmOpen();

        res = NvRmAllocRoot (&dwRoot);
        if (res != NVOS01_STATUS_SUCCESS) return FALSE;

        res = NvRmAllocDevice (dwRoot, dwDevID, NV01_DEVICE_0, (BYTE*)name);
           if (res != NVOS06_STATUS_SUCCESS) return FALSE;
    }
#endif // WINNT

    // get general HW info

    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_DAC_INPUT_WIDTH,    &dwWidth);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_DAC_GRAPHICS_CLOCK, &dwNVCLK);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_DAC_MEMORY_CLOCK,   &dwMCLK);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_RAM_SIZE_MB,        &dwGPUMemory);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_PROCESSOR_SPEED,    &dwCpuClock);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_PROCESSOR_TYPE,     &dwCpuType);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_ADDRESS_NVADDR,     &dwBase);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_AGP_FULLSPEED_FW,   &dwFullspeedFW);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_AGP_FW_ENABLE,      &dwFastWrite);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_BUS_TYPE,           &dwBusType);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_PCI_ID,             &dwPCIID);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_ARCHITECTURE,       &dwArchitecture);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_REVISION,           &dwRevision);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_GRAPHICS_CAPS,      &dwGraphicsCaps);

    pDriverData->nvD3DPerfData.dwHaveVolumeTextures = dwGraphicsCaps & NV_CFG_GRAPHICS_CAPS_3D_TEXTURES;
    pDriverData->nvD3DPerfData.dwHaveAALines        = dwGraphicsCaps & NV_CFG_GRAPHICS_CAPS_AA_LINES;
    pDriverData->nvD3DPerfData.dwHaveAnisotropic    = dwGraphicsCaps & NV_CFG_GRAPHICS_CAPS_ANISOTROPIC;

#ifdef WINNT
    {
        // Ask miniport if AGP should be enabled.
        DWORD ulReturn = 0;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SHOULD_AGP_BE_ENABLED,
                               NULL, 0, NULL, 0, &ulReturn))
        {
            dwBusType = 1; // Force it to be PCI if miniport thinks otherwise.
        }
    }

    // get the AGP heap size
    NvWin2KGetAgpLimit(ppdev, dwRoot, dwDevID);
#endif

    // get the list of classes this HW supports
    NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS params;
    DWORD dwSuccess;

    params.numClasses  = 0;
    params.classBuffer = NULL;

    // call to get the number of supported classes
    dwSuccess = NvRmConfigGetEx (dwRoot, dwDevID, NV_CFGEX_GET_SUPPORTED_CLASSES, &params, sizeof(params));
    nvAssert (dwSuccess == NVOS_CGE_STATUS_SUCCESS);

    // allocate and call again to actually get the class list itself
    params.classBuffer = (DWORD *) AllocIPM (params.numClasses * sizeof(DWORD));
    dwSuccess = NvRmConfigGetEx (dwRoot, dwDevID, NV_CFGEX_GET_SUPPORTED_CLASSES, &params, sizeof(params));
    nvAssert (dwSuccess == NVOS_CGE_STATUS_SUCCESS);

    // parse the class list
    if (nvClassListCheck (params, 0x0055))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0055_DX6TRI;
    if (nvClassListCheck (params, 0x0095))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0095_DX6TRI;

    if (nvClassListCheck (params, 0x0054))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0054_DX5TRI;
    if (nvClassListCheck (params, 0x0094))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0094_DX5TRI;

    if (nvClassListCheck (params, 0x0056))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0056_CELSIUS;
    if (nvClassListCheck (params, 0x0096))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0096_CELSIUS;
    if (nvClassListCheck (params, 0x1196))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_1196_CELSIUS;

    if (nvClassListCheck (params, 0x0097))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0097_KELVIN;

    if (nvClassListCheck (params, 0x0046))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0046_DAC;
    if (nvClassListCheck (params, 0x0049))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0049_DAC;
    if (nvClassListCheck (params, 0x0067))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0067_DAC;
    if (nvClassListCheck (params, 0x007C))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_007C_DAC;

    if (nvClassListCheck (params, 0x0042))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0042_CTXSURF2D;
    if (nvClassListCheck (params, 0x0062))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0062_CTXSURF2D;

    if (nvClassListCheck (params, 0x0060))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0060_IDXIMAGE;
    if (nvClassListCheck (params, 0x0064))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0064_IDXIMAGE;

    if (nvClassListCheck (params, 0x0077))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0077_SCALEDIMG;
    if (nvClassListCheck (params, 0x0063))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0063_SCALEDIMG;
    if (nvClassListCheck (params, 0x0089))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0089_SCALEDIMG;

    if (nvClassListCheck (params, 0x0038))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0038_DVDPICT;
    if (nvClassListCheck (params, 0x0088))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0088_DVDPICT;

    if (nvClassListCheck (params, 0x007A))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_007A_OVERLAY;

    if (nvClassListCheck (params, 0x0053))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0053_CTXSURF3D;
    if (nvClassListCheck (params, 0x0093))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0093_CTXSURF3D;

    if (nvClassListCheck (params, 0x004A))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_004A_GDIRECT;
    if (nvClassListCheck (params, 0x005E))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_005E_SOLIDRECT;

    if (nvClassListCheck (params, 0x0052))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0052_CTXSURFSWZ;
    if (nvClassListCheck (params, 0x009E))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_009E_CTXSURFSWZ;

    if (nvClassListCheck (params, 0x0004))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0004_TIMER;

    if (nvClassListCheck (params, 0x006C))  pDriverData->nvD3DPerfData.dwNVClasses1 |= NVCLASS1_006C_CHANNELDMA;
    if (nvClassListCheck (params, 0x006E))  pDriverData->nvD3DPerfData.dwNVClasses1 |= NVCLASS1_006E_CHANNELDMA;
    if (nvClassListCheck (params, 0x206E))  pDriverData->nvD3DPerfData.dwNVClasses1 |= NVCLASS1_206E_CHANNELDMA;

    // free the dynamically allocated list
    FreeIPM (params.classBuffer);

    dwNVCLK = (dwNVCLK + 500000) / 1000000;
    dwMCLK  = (dwMCLK  + 500000) / 1000000;

    // disconnect
#ifdef WINNT
    {
        DWORD res;
        res = NvRmFree (dwRoot, NV01_NULL_OBJECT, dwRoot);
        if (res != NVOS00_STATUS_SUCCESS) return FALSE;
    }
#endif
    NvRmClose();

    dwStrapCaps = *(DWORD*)(dwBase + NV_PBUS_PCI_NV_18);
    dwBusCaps   = *(DWORD*)(dwBase + NV_PBUS_PCI_NV_19);

    //
    // override
    //
#ifdef FORCE_NV10_AS_NV5
    pDriverData->nvD3DPerfData.dwNVClasses &= ~(NVCLASS_0056_CELSIUS |
                                                NVCLASS_0096_CELSIUS |
                                                NVCLASS_1196_CELSIUS);
#endif

#ifdef SPOOF_KELVIN
    pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0097_KELVIN;
#endif

    //
    // map cpu onto feature flags
    //
    pDriverData->nvD3DPerfData.dwProcessorSpeed = dwCpuClock;
    if (dwCpuType & NV_CPU_FUNC_MMX)     pDriverData->nvD3DPerfData.dwCPUFeatureSet |= FS_MMX;
    if (dwCpuType & NV_CPU_FUNC_SSE)     pDriverData->nvD3DPerfData.dwCPUFeatureSet |= FS_KATMAI;
    if (dwCpuType & NV_CPU_FUNC_SSE2)    pDriverData->nvD3DPerfData.dwCPUFeatureSet |= FS_WILLAMETTE;
    if (dwCpuType & NV_CPU_FUNC_3DNOW)   pDriverData->nvD3DPerfData.dwCPUFeatureSet |= FS_3DNOW;
    if (dwCpuType & NV_CPU_FUNC_SFENCE)  pDriverData->nvD3DPerfData.dwCPUFeatureSet |= FS_SFENCE;
    if ((dwCpuType & 0xff) == NV_CPU_K7) pDriverData->nvD3DPerfData.dwCPUFeatureSet |= FS_ATHLON;

    if ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI) ||
        (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE) ||
        (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON))
    {
        pDriverData->nvD3DPerfData.dwCPUFeatureSet |= FS_PREFETCH;
    }

    // See if this is a PCI bus interface
    if (dwBusType == 1)
    {
        pDriverData->nvD3DPerfData.dwCPUFeatureSet |= FS_PCIBUS;
    }

    //
    // map misc flags
    //
    // fast writes
    if (dwFastWrite && dwFullspeedFW)   pDriverData->nvD3DPerfData.dwCPUFeatureSet |= FS_FULLFASTWRITE;
    if (dwFastWrite && !dwFullspeedFW)  pDriverData->nvD3DPerfData.dwCPUFeatureSet |= FS_HALFFASTWRITE;
    // detect low back end bus
    if (dwWidth == 64)                  pDriverData->nvD3DPerfData.dwCPUFeatureSet |= FS_64BIT;

    //
    // determine strategy...
    //
    DWORD dwPSOr  =  0;
    DWORD dwPSAnd = ~0;
    {
        BOOL bFastMachine      = pDriverData->nvD3DPerfData.dwProcessorSpeed >= 390;
        BOOL bRealFastMachine  = pDriverData->nvD3DPerfData.dwProcessorSpeed >= 650; //650
        BOOL bSuperFastBackEnd = dwMCLK >= 300;
        // bFastBackEnd should only be FALSE on VANTA
        BOOL bFastBackEnd      = !(pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_64BIT)
                               || (dwMCLK > 200);
        BOOL bHalfFastWrites   = pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_HALFFASTWRITE;
        BOOL bFullFastWrites   = pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_FULLFASTWRITE;
        BOOL bHasAGP           = dwBusCaps & (1 << (0 ? NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE));

        //
        // slow back end
        //
        if (!bFastBackEnd)
        {
            if (bFastMachine) pDriverData->nvD3DPerfData.dwPerformanceStrategy = PS_CONTROL_TRAFFIC_16 |
                                                                                 PS_CONTROL_TRAFFIC_32 |
                                                                                 PS_TEXTURE_RENAME     |
                                                                                 PS_TEXTURE_PREFER_AGP;
                         else pDriverData->nvD3DPerfData.dwPerformanceStrategy = PS_CONTROL_TRAFFIC_16 |
                                                                                 PS_CONTROL_TRAFFIC_32 |
                                                                                 PS_TEXTURE_USEHW;
        }
#if 0 // (NVARCH >= 0x020)
        else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
        {
            // put stuff here
        }
#endif
        else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS)
        {
            // decide who does what
            pDriverData->nvD3DPerfData.dwPerformanceStrategy = PS_TEXTURE_RENAME | PS_TEXTURE_USEHW;
            // decide where to put stuff
            switch ((bFullFastWrites   ? 4 : 0)
                  | (bHalfFastWrites   ? 2 : 0)
                  | (bSuperFastBackEnd ? 1 : 0))
            {
                case 0: // !FW, !SF   - bx, SDR
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
                case 1: // !FW,  SF   - bx, DDR
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
                case 2: //  1/2 FW, !SF   - camino, SDR
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
                case 3: //  1/2 FW,  SF   - camino, DDR
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
                case 6: //  FW, !SF   - camino, SDR
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
                case 7: //  FW,  SF   - camino, DDR (we have not experimentd with this one yet - be conservative)
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
            }

            if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_PCIBUS)
            {
                // PCI bus interface -- don't prefer AGP!
                pDriverData->nvD3DPerfData.dwPerformanceStrategy &=  ~PS_VB_PREFER_AGP;
            }

            // should we use auto-palettes?
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS)
            {
                pDriverData->nvD3DPerfData.dwPerformanceStrategy |= PS_AUTOPALETTE;
            }

            //camino (i.e. FW's) do 32 bit perf strategy.
            if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_1196_CELSIUS)
             || (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0096_CELSIUS)) {
                pDriverData->nvD3DPerfData.dwPerformanceStrategy |= PS_CONTROL_TRAFFIC_32;
                pDriverData->nvD3DPerfData.dwPerformanceStrategy |= PS_CONTROL_TRAFFIC_16;
            }

            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
            {
                // No CT for Kelvin
                pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~(PS_CONTROL_TRAFFIC_16 | PS_CONTROL_TRAFFIC_32);
            }

#ifdef ALTERNATE_STENCIL_MODE
            if ((dwArchitecture == 0x10) && (dwRevision == 0xB1)) {
                // Only NV11 B01 supports this
                pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~(PS_CONTROL_TRAFFIC_16 | PS_CONTROL_TRAFFIC_32);
                pDriverData->nvD3DPerfData.dwPerformanceStrategy |= PS_ALT_STENCIL;
            }
#endif


            //more control traffic for mobile NV11
            if ((pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_CONTROL_TRAFFIC_16))
            {
                if (dwPCIID == (NV11M_DEVICE_NV11M_ID << 16 | NV4_VENDOR_ID))
                {
                    pDriverData->nvD3DPerfData.dwPerformanceStrategy |= PS_CT_11M;
                }
            }

            // should we do super triangles?
#ifdef SUPERTRI
           if (bRealFastMachine
              && ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
                    || (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
                    || (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)))
            {
                pDriverData->nvD3DPerfData.dwPerformanceStrategy |= (PS_SUPERTRI | PS_ST_XFORMCLIP | PS_ST_MODEL);

                // TODO: Add transformation and clip code for Athlon
                if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
                    pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~PS_ST_XFORMCLIP;
            }
#endif
        }
        // ben BUGBUG
        // this is ugly. we infer nv4 vs. nv5 based on the DAC object. philosophically, this is illegal.
        else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0049_DAC)
        {
            if (bFastMachine) pDriverData->nvD3DPerfData.dwPerformanceStrategy = PS_CONTROL_TRAFFIC_32 | PS_TEXTURE_RENAME;
                         else pDriverData->nvD3DPerfData.dwPerformanceStrategy = PS_CONTROL_TRAFFIC_32 | PS_TEXTURE_USEHW;
        }
        else
        {
            if (bFastMachine) pDriverData->nvD3DPerfData.dwPerformanceStrategy = PS_CONTROL_TRAFFIC_16 |
                                                                                 PS_CONTROL_TRAFFIC_32 |
                                                                                 PS_TEXTURE_RENAME     |
                                                                                 PS_TEXTURE_PREFER_AGP;
                         else pDriverData->nvD3DPerfData.dwPerformanceStrategy = PS_CONTROL_TRAFFIC_16 |
                                                                                 PS_CONTROL_TRAFFIC_32 |
                                                                                 PS_TEXTURE_USEHW;
        }

#ifdef FORCE_CT
#if FORCE_CT
    pDriverData->nvD3DPerfData.dwPerformanceStrategy |= PS_CONTROL_TRAFFIC_32;
    pDriverData->nvD3DPerfData.dwPerformanceStrategy |= PS_CONTROL_TRAFFIC_16;
#else
    pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~PS_CONTROL_TRAFFIC_32;
    pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~PS_CONTROL_TRAFFIC_16;
#endif
#endif


        //
        // override from registry
        //
        {
            DWORD dwValue;

#ifdef WINNT
            PDEV *hKey = ppdev;
#else
            HKEY  hKey = OpenLocalD3DRegKey();
#endif

            if (hKey)
            {
                decryptRegistryKeys();
                if (nvReadRegistryDWORD(hKey,reg.szPerformanceStrategyOrString,&dwValue))
                {
                    dwPSOr    = dwValue;
                    bOverride = TRUE;
                }
                if (nvReadRegistryDWORD(hKey,reg.szPerformanceStrategyAndString,&dwValue))
                {
                    dwPSAnd    = dwValue;
                    bOverride = TRUE;
                }
#ifndef WINNT
                RegCloseKey(hKey);
#endif
                if (nvReadRegistryDWORD(hKey, "BUSCONTROL",&dwValue))
                {
                    if (((dwPCIID & 0xffff0000) == 0x00a00000) && (dwValue == 0xf0080001))
                    {
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy |= PS_MUSH;
                        global.fdClockPerTri          = double(dwNVCLK) / 3.0;
                        global.fdClockPerPixel        = double(dwNVCLK) / 125.0;
                    }
                    bOverride = TRUE;
                }
#ifndef WINNT
                RegCloseKey(hKey);
#endif
            }
            pDriverData->nvD3DPerfData.dwPerformanceStrategy &= dwPSAnd;
            pDriverData->nvD3DPerfData.dwPerformanceStrategy |= dwPSOr;
        }
    }

    // always enable vertex buffer renaming
    pDriverData->nvD3DPerfData.dwPerformanceStrategy |=  PS_VB_RENAME;

/*
    pDriverData->nvD3DPerfData.dwPerformanceStrategy = (1 ? PS_TEXTURE_RENAME     : 0)
                                 | (0 ? PS_TEXTURE_USEHW      : 0)
                                 | (1 ? PS_TEXTURE_PREFER_AGP : 0)
                                 | (1 ? PS_CONTROL_TRAFFIC_16 : 0)
                                 | (1 ? PS_CONTROL_TRAFFIC_32 : 0);
//*/

#define SIZE_VIDMEM_PUSH_BUFFER         (1.0f /  32.0f)     // of total vid mem
#define SIZE_VIDMEM_STAGE_BUFFER        (2.0f /  32.0f)     // of total vid mem


#define SIZE_SYSMEM_PUSH_BUFFER         (2.5f / 32.0f)      // of total sys mem (buffer lives in PCI or AGP)
#define SIZE_SYSMEM_STAGE_BUFFER        (3.0f / 32.0f)      // of total sys mem (buffer lives in PCI or AGP)

    DWORD dwPBSize, dwSBSize;

    if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_PUSH_VID) // buffers in video memory
    {
        dwPBSize = DWORD(1024.0f * 1024.0f * dwGPUMemory * SIZE_VIDMEM_PUSH_BUFFER);
        dwSBSize = DWORD(1024.0f * 1024.0f * dwGPUMemory * SIZE_VIDMEM_STAGE_BUFFER);
    }
    else // buffers in AGP or PCI memory
    {
        // base AGP buffer sizes on aperture or memory size, depending on their relative sizes
        DWORD dwMem = pDriverData->nvD3DPerfData.dwSystemMemory;
        if (dwBusType == 4) { // limit by aperture size if system has AGP bus
            dwMem = min(dwMem, (pDriverData->regMaxAGPLimit + 1) / 1024 / 1024);
        }
        dwPBSize = DWORD(1024.0f * 1024.0f * dwMem * SIZE_SYSMEM_PUSH_BUFFER);
        dwSBSize = DWORD(1024.0f * 1024.0f * dwMem * SIZE_SYSMEM_STAGE_BUFFER);
    }

    dwPBSize = max(dwPBSize, 128 * 1024); // must be at least 128K

    dwPBSize = (dwPBSize + 4095) & ~4095; // 4K align

    if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) ||
        (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN))
    {
        dwSBSize = max(dwSBSize, 128 * 1024); // must be at least 128K
        dwSBSize = (dwSBSize + 4095) & ~4095; // 4K align
    }
    else
    {
        dwSBSize = 0;
    }

    // limit maximum size of push buffer & staging buffer
    dwPBSize = min(dwPBSize, 4 * 1024 * 1024); // 4MB max
    dwSBSize = min(dwSBSize, 4 * 1024 * 1024); // 4MB max

    pDriverData->nvD3DPerfData.dwRecommendedStageBufferSize = dwSBSize;
    pDriverData->nvD3DPerfData.dwRecommendedPushBufferSize  = dwPBSize;

    //
    // determine maximum texture and recommended pci texture heap sizes
    //

    // give them two MB per 16 MB of system memory
    pDriverData->nvD3DPerfData.dwRecommendedPCITexHeapSize = (pDriverData->nvD3DPerfData.dwSystemMemory >> 4) << 1;
    // give them at least 2
    pDriverData->nvD3DPerfData.dwRecommendedPCITexHeapSize = max (pDriverData->nvD3DPerfData.dwRecommendedPCITexHeapSize, 2);

    // convert MB to bytes
    if(pDriverData->nvD3DPerfData.dwRecommendedPCITexHeapSize > 32) pDriverData->nvD3DPerfData.dwRecommendedPCITexHeapSize = 32;
    pDriverData->nvD3DPerfData.dwRecommendedPCITexHeapSize <<= 20;


    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            pDriverData->nvD3DPerfData.dwMaxTextureSize = 4096;
            pDriverData->nvD3DPerfData.dwMaxVolumeTextureSize = pDriverData->nvD3DPerfData.dwHaveVolumeTextures ? 512 : 0;
    } else {
            pDriverData->nvD3DPerfData.dwMaxTextureSize = 2048;
            pDriverData->nvD3DPerfData.dwMaxVolumeTextureSize = 0;
    }

    if (dwGPUMemory < 32) {
        // Reset dwMaxTextureSize for cards with less memory
        pDriverData->nvD3DPerfData.dwMaxTextureSize = (pDriverData->nvD3DPerfData.dwSystemMemory >= 48) ? 2048 : 1024;
    }

#define PRINT
#if defined(DEBUG) || defined(PRINT)
    {
        static BOOL bPrintedThisBefore = FALSE;

        if (!bPrintedThisBefore)
        {
            char szString[128];

            PF (" NV: classes=%08x %d/%d RAM=%dMB bus=%d", pDriverData->nvD3DPerfData.dwNVClasses,dwNVCLK,dwMCLK,dwGPUMemory,dwWidth);
            PF ("CPU: FS=%08x %dMHz", pDriverData->nvD3DPerfData.dwCPUFeatureSet, pDriverData->nvD3DPerfData.dwProcessorSpeed);

            {
                BOOL  bAGP   = dwBusCaps & (1 << (0 ? NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE));
                DWORD dwRate = dwBusCaps ? (dwBusCaps & 7) : 0;
                BOOL  bSBA   = dwBusCaps & (1 << (0 ? NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE));
                BOOL  bFW    = dwBusCaps & (1 << (0 ? NV_PBUS_PCI_NV_19_AGP_COMMAND_FW_ENABLE));

                PF (" BC: AGP=%dx, SBA=%d, HFW=%d, SSFW=%d, SFFW=%d",
                     bAGP ? dwRate : 0,
                     bSBA ? 1 : 0,
                     bFW ? 1 : 0,
                     (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_HALFFASTWRITE) ? 1 : 0,
                     (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_FULLFASTWRITE) ? 1 : 0);
            }
            {
                DWORD dwRate = dwStrapCaps ? (dwStrapCaps & 7) : 0;
                BOOL  bSBA   = dwStrapCaps & (1 << (0 ? NV_PBUS_PCI_NV_18_AGP_STATUS_SBA));
                BOOL  bFW    = dwStrapCaps & (1 << (0 ? NV_PBUS_PCI_NV_18_AGP_STATUS_FW));

                PF (" SC: AGP=%s%s%s%s, SBA=%d, FW=%d",
                     (dwRate & 4) ? "4" : "",
                     (dwRate & 2) ? "2" : "",
                     (dwRate & 1) ? "1" : "",
                     (dwRate & 7) ? "x" : "n/a",
                     bSBA ? 1 : 0,
                     bFW ? 1 : 0);
            }

            PF (" PS: %08x", pDriverData->nvD3DPerfData.dwPerformanceStrategy);

            nvStrCpy (szString, "     ");
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_TEXTURE_RENAME)     nvStrCat (szString, "texRn ");
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_TEXTURE_USEHW)      nvStrCat (szString, "texHW ");
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_TEXTURE_PREFER_AGP) nvStrCat (szString, "texAGP ");
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_CONTROL_TRAFFIC_16) nvStrCat (szString, "ct16 ");
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_CONTROL_TRAFFIC_32) nvStrCat (szString, "ct32 ");
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_VB_RENAME)          nvStrCat (szString, "vbRn ");
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_VB_PREFER_AGP)      nvStrCat (szString, "vbAGP ");
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_PUSH_VID)           nvStrCat (szString, "pushVID ");
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_SUPERTRI)           nvStrCat (szString, "supTri ");
            PF (szString);

            if (bOverride) {
                PF ("     * PS set from registry");
            }

            bPrintedThisBefore = TRUE;
        }
    }
#endif

    // calibrate delay loop
    DWORD dwCaps;
    __asm
    {
        push    eax
        push    ebx
        push    ecx
        push    edx

        mov eax,1
        cpuid          // assume cpuid capable
        mov [dwCaps],edx

        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
    }
    if (dwCaps & 0x10) // rdtsc capable
    {
        __int64 qwStart,qwStop;

        global.dwDelayCount = 10000;
        nvDelay();
        nvDelay();
        __asm
        {
            push    eax
            push    edx

            rdtsc
            mov DWORD PTR [qwStart + 0],eax
            mov DWORD PTR [qwStart + 4],edx

            pop     edx
            pop     eax
        }
        nvDelay();
        __asm
        {
            push    eax
            push    edx

            rdtsc
            mov DWORD PTR [qwStop + 0],eax
            mov DWORD PTR [qwStop + 4],edx

            pop     edx
            pop     eax

            // 3DMark 2000 leaves the floating point stack full of garbage
            // which causes the 3rd FILD below to fail resulting in a global.dwDelayCount of 0 and
            // ultimately causing the driver to hang
            // (perhaps they use MMX instructions)
            // clearing the MMX state here solves the problem
        }
        // this used to cause a fault on non-MMX machines.  Have to check for MMX before using
        // EMMS
        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_MMX)
        {
            __asm
            {
                emms
            }
        }

        // set delay to 10us
        double time = double(qwStop - qwStart) / 10000.0;
        time /= (double) pDriverData->nvD3DPerfData.dwProcessorSpeed;
        global.dwDelayCount = (unsigned long) (10.0 / time);
    }
    else
    {
        // for non tsc machines we just assign a hard value for the delay loop
        global.dwDelayCount = pDriverData->nvD3DPerfData.dwProcessorSpeed * 4;
    }

    // Copy the spin count to the performance data struct
    pDriverData->nvD3DPerfData.dwSpinLoopCount = global.dwDelayCount;

    return TRUE;
}
#pragma optimize("g",on)
#endif  // NVARCH >= 0x04


void nvDetermineEarlyCopyStrategy(PNVD3DCONTEXT pContext)
{
    static DWORD magicValues[16][2] = {
        {0x3f800000, 0x44f27550},
        {0x40e00000, 0x45023056},
        {0x3ffa0000, 0x440ca46b},
        {0x3d3fbdf2, 0x42d094f4},
        {0x3f800000, 0x44c3ae90},
        {0x3e4ccccd, 0x421c1da7},
        {0x3e62eec8, 0x431ff939},
        {0x3dccccce, 0x433d085a},
        {0x3dcccccd, 0x4168c963},
        {0x00000000, 0x00000000},
        {0x41400000, 0x43fa0094},
        {0x41400000, 0x4415ffd4},
        {0x41400000, 0x442effe6},
        {0x3f100000, 0x43aeff84},
        {0x3e801000, 0x43af0117},
        {0x3f000100, 0x43aeff84}};

    static DWORD magicValues2[16][2] = {
        {0x3e62eec8, 0x431ff939},
        {0x3dccccce, 0x433d085a},
        {0x3dccccce, 0x433d085a},
        {0x3dcccccd, 0x4168c963},
        {0x3e4ccccd, 0x421c1da7},
        {0x3e4ccccd, 0x421c1da7},
        {0x3e62eec8, 0x431ff939},
        {0x3e4ccccd, 0x421c1da7},
        {0x3e62eec8, 0x431ff939},
        {0x3f800000, 0x44e24e63},
        {0x3f800000, 0x44c3ae90},
        {0x3dccccce, 0x433d085a},
        {0x3d3fbdf2, 0x42d094f4},
        {0x3ffa0000, 0x440ca46b},
        {0x3ffa0000, 0x440ca46b},
        {0x3f800000, 0x44e24e63}};

    static DWORD magicValues3[16][2] = {
        {0x40400000, 0x43fa0094},
        {0x40400000, 0x4415ffd4},
        {0x40400000, 0x442effe6},
        {0x3f000000, 0x43aeff84},
        {0x3e800000, 0x43af0117},
        {0x3e800000, 0x43af0117},
        {0x3e62eec8, 0x431ff939},
        {0x3dccccce, 0x433d085a},
        {0x3dccccce, 0x433d085a},
        {0x3dcccccd, 0x4168c963},
        {0x3e4ccccd, 0x421c1da7},
        {0x3e4ccccd, 0x421c1da7},
        {0x3e62eec8, 0x431ff939},
        {0x3e4ccccd, 0x421c1da7},
        {0x3e62eec8, 0x431ff939},
        {0x3f800000, 0x44e24e63}};

    DWORD i;
    if (pContext->dwDXAppVersion >= 0x0700) {
        for (i=0; i<15; i++) {
            if ((*(DWORD *)&pContext->surfaceViewport.dvWNear == magicValues[i][0]) &&
                (*(DWORD *)&pContext->surfaceViewport.dvWFar  == magicValues[i][1])) {
                pContext->dwEarlyCopyStrategy = i + 1;
                return;
            }

            if ((*(DWORD *)&pContext->surfaceViewport.dvWNear == magicValues3[i][0]) &&
                (*(DWORD *)&pContext->surfaceViewport.dvWFar  == magicValues3[i][1])) {
                pContext->dwEarlyCopyStrategy = 0x30 + i + 1;
                return;
            }
        }
    }
    else
    {
         for (i=0; i<15; i++) {
             if ((*(DWORD *)&pContext->surfaceViewport.dvWNear == magicValues2[i][0]) &&
                 (*(DWORD *)&pContext->surfaceViewport.dvWFar  == magicValues2[i][1])) {
                 pContext->dwEarlyCopyStrategy = 0x20 + i + 1;
                 return;
             }
         }
    }
    pContext->dwEarlyCopyStrategy = 0;

    //bHintVBRename = pContext->dwEarlyCopyStrategy >= 11;
}


#ifdef DEBUG_SURFACE_PLACEMENT
CSurfaceDebug               csd;
#endif //DEBUG_SURFACE_PLACEMENT

#ifdef PROFILE_INDEX

#define INDEX_FILE_NAME "\\idxprof.txt"

HANDLE  idx_file          = 0;  // index data file handle
DWORD   idx_buf_cnt       = 0;

void nvCreateIndexProfile()
{
    idx_file=NvCreateFile(INDEX_FILE_NAME,GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
    if (idx_file == INVALID_HANDLE_VALUE) {
        MessageBeep (0);
        __asm int 3;
    }
    idx_buf_cnt = 0;

}


void nvLogIndexData(DWORD primtype, DWORD count, WORD *idx)
{
    int i, j;
    DWORD bytes_written;

    static char outbuf[1024];
    switch (primtype)
    {
    case D3DDP2OP_INDEXEDTRIANGLELIST2:
        wsprintf(outbuf, "\n\n Buffer: %i, Primtype: Indexed Triangle List2, count: %i\n", idx_buf_cnt++, count);
        NvWriteFile(idx_file, outbuf, strlen(outbuf), &bytes_written, 0);
        for (i = 0; i < count; i++)
        {
            wsprintf(outbuf, "%04i: %04x %04x %04x\n", i, idx[0], idx[1], idx[2]);
            NvWriteFile(idx_file, outbuf, strlen(outbuf), &bytes_written, 0);
            idx+=3;
        }
        break;

    default:
        break;

    }


}

void nvDestroyIndexProfile()
{
    NvCloseHandle (idx_file);
}

#endif //PROFILE_INDEX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvPusher_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPusher_link.cpp
//      a pointer to a shared file
//
// **************************************************************************
#include "nvprecomp.h"
#include "..\..\..\common\src\nvPusher.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvPriv_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPriv_link.cpp
//      a pointer to a shared file
//
// **************************************************************************
#include "nvprecomp.h"
#include "..\..\..\common\src\nvPriv.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvprocman_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvProcMan_link.cpp
//      a pointer to a shared file
//
// **************************************************************************
#include "nvprecomp.h"

#include "..\..\..\common\src\nvProcMan.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvPrim2.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvPrim2.cpp                                                       *
*   NV4 DX6 DrawPrimitives2 routines.                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       04/18/98 - created                      *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

PFND3DPARSEUNKNOWNCOMMAND fnD3DParseUnknownCommandCallback;

//-------------------------------------------------------------------------

DWORD __stdcall nvDrawPrimitives2
(
    LPD3DHAL_DRAWPRIMITIVES2DATA pdp2d
)
{
    PNVD3DCONTEXT       pContext;
    LPD3DHAL_DP2COMMAND lpCommands, lpResumeCommands;
    LPBYTE              lpCommandBufferStart;
    LPBYTE              lpCommandBufferEnd;
    BOOL                bVBFlushOnExit = FALSE;
    BOOL                bWriteOffset   = FALSE;
    BOOL                bSuccess       = FALSE;
    DWORD               dwReturnValue  = DD_OK;
    CVertexBuffer      *pVertexBuffer  = NULL;
    CCommandBuffer     *pCommandBuffer = NULL;
    HRESULT             ddrval;
    LPDWORD             lpdwDP2RStates;
    DWORD               dwDP2Flags;

    dbgTracePush ("nvDrawPrimitives2 (%08x)", pdp2d);

    NV_SET_CONTEXT (pContext, pdp2d);
    nvSetDriverDataPtrFromContext (pContext);

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        pdp2d->ddrval = DD_OK;
        NvReleaseSemaphore (pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

#ifdef  STEREO_SUPPORT
    NvSetStereoDataPtrFromDriverData;
#endif  //STEREO_SUPPORT

    nvSetD3DSurfaceState (pContext);

    if (global.dwDXRuntimeVersion < 0x700) {
        nvPusherSignalWaitForFlip (pContext->pRenderTarget->getfpVidMem(), DDSCAPS_PRIMARYSURFACE);
    }
    pContext->dwHWUnlockAllPending=FALSE; //  unneeded cleanup HMH
    // clear this bit (since MS does not by themselves)
    pdp2d->dwFlags &= ~D3DHALDP2_VIDMEMVERTEXBUF;

#ifdef NV_NULL_DRIVER
    goto normalExit;
#endif //NV_NULL_DRIVER
#ifdef NV_PROFILE
    NVP_START (NVP_T_DP2);
#endif

    // get the context
    pContext->dwTickLastUsed = GetTickCount();

    // Need to make sure that an unfriendly mode switch didn't sneak and not cause
    // us to get re-enabled properly.
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvD3DRecover();
        }
        else {
#ifdef NV_PROFILE
            NVP_STOP (NVP_T_DP2);
            nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif
            goto normalExit;
        }
    }

    // locutus 2
    if (g_dwPMTrigger == PM_REG_PMTRIGGER_1MS)
    {
        static DWORD dwLast = 0;
        if (!dwLast) dwLast = GetTickCount();
        DWORD dwNow = GetTickCount();
        if (dwNow != dwLast)
        {
            PM_SIGNAL (PM_REG_PMTRIGGER_1MS);
            dwLast = dwNow;
        }
    }

    /*******************************************************************
     * COMMAND BUFFER SETUP
     *******************************************************************/

    CNvObject *pNvObject;

    // get command buffer
    pNvObject = GET_PNVOBJ(pdp2d->lpDDCommands);
    pCommandBuffer = pNvObject ? pNvObject->getCommandBuffer() : NULL;

    // Get address of command buffer.
    lpCommandBufferStart = (LPBYTE)(pdp2d->lpDDCommands->lpGbl->fpVidMem);

    if (!lpCommandBufferStart)
    {
#ifdef NV_PROFILE
        NVP_STOP (NVP_T_DP2);
        nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif
        dwReturnValue = DDERR_CANTLOCKSURFACE;
        goto normalExit;
    }

    // Calculate pointer to the first command to be processed and the end of the buffer.
    lpCommands         = (LPD3DHAL_DP2COMMAND)(lpCommandBufferStart + pdp2d->dwCommandOffset);
    lpCommandBufferEnd = (LPBYTE)((DWORD)lpCommands + pdp2d->dwCommandLength);

    /*******************************************************************
     * FVF DATA MUNGING
     *******************************************************************/

    if (pContext->dwDXAppVersion < 0x800) {
        // create a DX8-style shader from the FVF format
        pContext->pCurrentVShader->create (pContext, pdp2d->dwVertexType, CVertexShader::getHandleFromFvf( pdp2d->dwVertexType ) );

#if (NVARCH >= 0x020)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
        {
            DWORD dwPTFlag;
            if (NV_VERTEX_TRANSFORMED(pContext->pCurrentVShader))
                dwPTFlag = KELVIN_FLAG_PASSTHROUGHMODE;
            else
            {
                dwPTFlag = 0;
#ifdef  STEREO_SUPPORT
                if (STEREO_ENABLED)
                    pStereoData->dwHWTnL++;
#endif  //STEREO_SUPPORT
            }
            if ((pContext->hwState.dwStateFlags & KELVIN_FLAG_PASSTHROUGHMODE) != dwPTFlag) {
                pContext->hwState.dwStateFlags &= ~KELVIN_FLAG_PASSTHROUGHMODE;
                pContext->hwState.dwStateFlags |= dwPTFlag;
                pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_COMBINERS_SPECFOG
                                               |  KELVIN_DIRTY_VERTEX_SHADER
                                               |  KELVIN_DIRTY_LIGHTS
                                               |  KELVIN_DIRTY_TRANSFORM
                                               |  KELVIN_DIRTY_MISC_STATE;
            }
        }
        else
#endif
#if (NVARCH >= 0x010)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
            DWORD dwPTFlag;
            if (NV_VERTEX_TRANSFORMED(pContext->pCurrentVShader))
                dwPTFlag = CELSIUS_FLAG_PASSTHROUGHMODE;
            else
            {
                dwPTFlag = 0;
#ifdef  STEREO_SUPPORT
                if (STEREO_ENABLED)
                    pStereoData->dwHWTnL++;
#endif  //STEREO_SUPPORT
            }
            if ((pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE) != dwPTFlag) {
                pContext->hwState.dwStateFlags &= ~CELSIUS_FLAG_PASSTHROUGHMODE;
                pContext->hwState.dwStateFlags |= dwPTFlag;
                pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TL_MODE
                                               |  CELSIUS_DIRTY_FVF
                                               |  CELSIUS_DIRTY_TRANSFORM
                                               |  CELSIUS_DIRTY_CONTROL0
                                               |  CELSIUS_DIRTY_SPECFOG_COMBINER;
            }
        }
#endif
    }
#ifdef  STEREO_SUPPORT
    else
        if (STEREO_ENABLED && !NV_VERTEX_TRANSFORMED(pContext->pCurrentVShader))
            pStereoData->dwHWTnL++;
#endif  //STEREO_SUPPORT

    /*******************************************************************
     * VERTEX BUFFER DETERMINATION
     *******************************************************************/

    // Get address of vertex buffer.
    BOOL        bVBRename;
    LPBYTE      pVertexData;

    DWORD       dwVertexBufferOffset;     // offset within the buffer
    DWORD       dwVertexBufferLength;     // length in bytes, not including the offset

    bVBRename = FALSE;

    pVertexBuffer = NULL;
    pVertexData   = NULL;

    if (pdp2d->dwFlags & D3DHALDP2_USERMEMVERTICES ) {

        if (pContext->dwDXAppVersion >= 0x800) {
            // need to update hardware if streams have been renamed...
            for (DWORD i=0;i<NV_CAPS_MAX_STREAMS;i++) {
                if (pContext->ppDX8Streams[i] != NULL) {
                    if (pContext->ppDX8Streams[i]->isModified()) {
#if (NVARCH >= 0x010)
                        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
                        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
#endif
                        pContext->ppDX8Streams[i]->tagNotModified();
                    }
                    else {
                        pContext->dwFlags |= CONTEXT_NEEDS_VTX_CACHE_FLUSH;
                    }
                }
            }
        }
        else
        {
            //user mode verts, set the dirty bits
#if (NVARCH >= 0x010)
            pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
#endif
        }
        pVertexData = (LPBYTE)pdp2d->lpVertices;

    }

    else {

        // must be a vertex buffer, get it
        pVertexBuffer = (GET_PNVOBJ(pdp2d->lpDDVertex))->getVertexBuffer();

        if (!pVertexBuffer) {
            // the vertex buffer must have been created by MS rather than us. get theirs.
            pVertexData = (LPBYTE)(pdp2d->lpDDVertex->lpGbl->fpVidMem);
        }

        else {

            pVertexBuffer->prefetchSurface();

            if (pVertexBuffer->cachedhwCanRead()) {

                // decide on Vb renaming policy
                if ((pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_VB_RENAME) &&
                    (pContext->dwDXAppVersion < 0x0800)) // dx8 apps should never have to rename -or- flush!
                {
                    // determine how to handle this locked buffer
                    if (pVertexBuffer->isD3DLocked())
                    {
                        // capture
#ifdef CAPTURE
                        if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                            CAPTURE_MEMORY_WRITE memwr;
                            memwr.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                            memwr.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                            memwr.dwExtensionID        = CAPTURE_XID_MEMORY_WRITE;
                            memwr.dwCtxDMAHandle       = (pVertexBuffer->getHeapLocation() == CSimpleSurface::HEAP_VID)
                                                       ? NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY
                                                       : D3D_CONTEXT_DMA_HOST_MEMORY;
                            memwr.dwOffset             = pVertexBuffer->getOffset();
                            memwr.dwSize               = pVertexBuffer->getSize();
                            captureLog (&memwr,sizeof(memwr));
                            captureLog ((void*)pVertexBuffer->getAddress(),memwr.dwSize);
                        }
#endif
                        if( global.dwDXRuntimeVersion > 0x800 ) {
                            if (pdp2d->dwFlags & D3DHALDP2_SWAPVERTEXBUFFER) {
                                // d3d says we should rename, tag here & do so at exit
                                bVBRename = TRUE;
                            }
                            else if( !pVertexBuffer->isD3DImplicit() ) {
                                // We only need to stall on explicit VBs.
                                bVBFlushOnExit = TRUE;
                            }
                        }
                        else {
                            if (pdp2d->dwFlags & D3DHALDP2_SWAPVERTEXBUFFER) {
                                // d3d says we should rename, tag here & do so at exit
                                bVBRename = TRUE;
                            }
                            else if( (!pCommandBuffer) || (!(pdp2d->dwFlags & D3DHALDP2_REQCOMMANDBUFSIZE)) ) {
                                 // Workaround for runtime bugs in DX8 and before
                                bVBFlushOnExit = TRUE;
                            }
                        }


                    }
                }
                else {
                    // vertex buffer renaming disabled in nvPerformanceStrategy
                    // this should only get hit on DX8 or if renaming is forced off due to a registry override
                    if (pVertexBuffer->isD3DLocked()) {
                        bVBFlushOnExit = TRUE;
                    }
                }

                // program HW (we have to force a VC flush since VB contents may have changed)
                if (pVertexBuffer->isD3DLocked() || pVertexBuffer->isModified()) {
#if (NVARCH >= 0x020)
                    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
                    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
#endif
                }
            }
        }
    }

    // The vertex size and the shader stride must match for DX6 and DX7 apps.
    // pdp2d->dwVertexSize is not reliable an ALL DP2 calls for apps prior to DX6.
    nvAssert ( (pContext->dwDXAppVersion >= 0x0800) ||
               (pContext->dwDXAppVersion < 0x0600) ||
               (pContext->pCurrentVShader->getStride() == pdp2d->dwVertexSize) );

    dwVertexBufferOffset = pdp2d->dwVertexOffset;
    dwVertexBufferLength = pContext->pCurrentVShader->getStride() * pdp2d->dwVertexLength;

    // we should have a VB or some other data source, but not both
    nvAssert ((pVertexBuffer != NULL) ^ (pVertexData != NULL));

    if (pContext->dwDXAppVersion >= 0x0800) {

        // save these off for DP2SetStreamSourceUM
        pContext->pVertexDataUM        = pVertexData;
        pContext->dwVertexDataLengthUM = dwVertexBufferLength;

    }

    else {

        // cast plain vertex data into a vertex buffer
        if (pVertexData) {

            pVertexBuffer = getDC()->defaultSysVB.getVB();
            pVertexBuffer->own ((DWORD)(pVertexData), dwVertexBufferLength, CSimpleSurface::HEAP_SYS);

        }

        // update the stride and cast vertex buffer into DX8-style streams
        if (pVertexBuffer) {

            pVertexBuffer->setVertexStride (pContext->pCurrentVShader->getStride());

            if (pVertexBuffer->isModified() && !pVertexBuffer->isDynamic()
             && (pVertexBuffer->getLockCount() == 1) && !pVertexBuffer->getSuperTriLookAsideBuffer())
            {
                // check more supertri criteria...
#ifndef MCFD
                if ((pVertexBuffer->getSurface()->hwCanRead())) {
#else
                if ((pVertexBuffer->hwCanRead())) {
#endif
                    pVertexBuffer->prepareSuperTriLookAsideBuffer();
                }
            }
            //um we're in DX7, no need to set all of the streams, just stream zero
            if (pContext->ppDX8Streams[0] != pVertexBuffer)
            {
                pContext->ppDX8Streams[0] = pVertexBuffer;
                //don't forget to set dirty bits
#if (NVARCH >= 0x010)
                pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
                pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
#endif
            }

            pContext->dwStreamDMACount = nvCountStreamDMAs (pContext, 1);

        }

    }

    if ((pVertexBuffer) && (pVertexBuffer->isModified())) {
        pVertexBuffer->tagNotModified();
    }

#ifdef WINNT
    // for win2k range checking, we need to specify the length of the valid vertex buffer
    global.dwMaxVertexOffset = dwVertexBufferOffset + dwVertexBufferLength;
#endif

#if (NVARCH >= 0x020)
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN)))
#elif (NVARCH >= 0x010)
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS))
#endif
    {
        // If state has changed or the spare subchannel does not contain
        // the correct triangle object, force an object state load.
        if (!pContext->bUseDX6Class)
        {
            if ((pContext->bStateChange || pDriverData->TwoDRenderingOccurred)
             || (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE))
                NV_FORCE_TRI_SETUP(pContext);
        }
        else
        {
            if ((pContext->bStateChange || pDriverData->TwoDRenderingOccurred)
             || (pDriverData->dDrawSpareSubchannelObject != D3D_DX6_MULTI_TEXTURE_TRIANGLE))
                NV_FORCE_TRI_SETUP(pContext);
        }
    }
 
    lpdwDP2RStates = pdp2d ? pdp2d->lpdwRStates : NULL;
    dwDP2Flags     = pdp2d ? pdp2d->dwFlags : 0;

    pContext->sysvb.bWriteOffset = false;
    pContext->dp2.dwVertexBufferOffset = dwVertexBufferOffset;
    pContext->dp2.dwVStart = 0;
    pContext->dp2.dwTotalOffset = 0;
    pContext->dp2.dwVertexLength = pdp2d->dwVertexLength;
    pContext->sysvb.pSysMemVB = 0;

    //flag celsius and kelvin as dirty if the vertex buffer offset has changed.
    if (pContext->hwState.dwVertexOffset != pContext->dp2.dwVertexBufferOffset)
    {
#if (NVARCH >= 0x020)
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
#endif
#if (NVARCH >= 0x010)
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
#endif
    }
    /*******************************************************************
     * COMMAND BUFFER PARSING
     *******************************************************************/

    while ((dwReturnValue == DD_OK) && ((LPBYTE)lpCommands < lpCommandBufferEnd)) {

        dbgDisplayDrawPrimitives2Info (lpCommands->bCommand, lpCommands->wPrimitiveCount);

        // make sure our table index is OK
        nvAssert (lpCommands->bCommand <= D3D_DP2OP_MAX);

        if ((*(pContext->pDP2FunctionTable))[lpCommands->bCommand] != NULL) {

#ifdef NV_PROFILE_DP2OPS
            if (pDriverData->pBenchmark == NULL) {
                pDriverData->pBenchmark = new CBenchmark;
                pDriverData->pBenchmark->resetData();
            }
            pDriverData->pBenchmark->logData(lpCommands->bCommand, lpCommands->wPrimitiveCount);  
#endif

#ifdef LPC_OPT
            pDriverData->dwThisDP2 = lpCommands->bCommand;
#endif 
            dwReturnValue = ((*(pContext->pDP2FunctionTable))[lpCommands->bCommand]) (pContext,
                                                                                      &lpCommands,
                                                                                      lpCommandBufferEnd,
                                                                                      lpdwDP2RStates,
                                                                                      dwDP2Flags);
             
#ifdef LPC_OPT
            pDriverData->dwLastDP2 = pDriverData->dwThisDP2;
#endif 
            nvAssert (dwReturnValue == DD_OK);
        }

        else {
            // Unknown command.  Pass it to the Unknown Command Callback for handling.
            if (fnD3DParseUnknownCommandCallback) {
                DPF_LEVEL (NVDBG_LEVEL_INFO,
                           "nvDrawPrimitives2: Sending command %d to unknown command parser",
                           lpCommands->bCommand);
                ddrval = fnD3DParseUnknownCommandCallback((void**)lpCommands, (void**)&lpResumeCommands);

                if (ddrval != DD_OK) {
                    nvPusherStart (FALSE);
                    dwReturnValue        = ddrval;
                    pdp2d->dwErrorOffset = (DWORD)((LPBYTE)lpCommands - lpCommandBufferStart);
#ifdef NV_PROFILE
                    NVP_STOP (NVP_T_DP2);
                    nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif
                    //check to see if the current streams/rendertarget/Z/textures need to be unlocked
                    if(pContext->dwHWUnlockAllPending){ //HMH
                        nvHWUnlockTextures (pContext);
                        // need to mark all streams as in use by hardware...
                        nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
                        pContext->dwHWUnlockAllPending=FALSE;
                    }
                    goto normalExit;
                }

                // Set the resume address.
                lpCommands = lpResumeCommands;
            }
            else {
                nvPusherStart (FALSE);
                dwReturnValue        = D3DERR_COMMAND_UNPARSED;
                pdp2d->dwErrorOffset = (DWORD)((LPBYTE)lpCommands - lpCommandBufferStart);
#ifdef NV_PROFILE
                NVP_STOP (NVP_T_DP2);
                nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif
                //check to see if the current streams/rendertarget/Z/textures need to be unlocked
                if(pContext->dwHWUnlockAllPending){ //HMH
                    nvHWUnlockTextures (pContext);
                    // need to mark all streams as in use by hardware...
                    nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
                    pContext->dwHWUnlockAllPending=FALSE;
                }
                goto normalExit;
            }
        }
    }  // while...
    //check to see if the current streams/rendertarget/Z/textures need to be unlocked
    if(pContext->dwHWUnlockAllPending){ //HMH
        nvHWUnlockTextures (pContext);
        // need to mark all streams as in use by hardware...
        nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
        pContext->dwHWUnlockAllPending=FALSE;
    }
    /*******************************************************************
     * VB renaming
     *******************************************************************/

    /*
            note for future rel
            -------------------
            if a VB was passed in and mustRenameToSystem() returns true on it, we need to
            move it to system memory and tell d3d about it using its renamer
    */

#ifndef MCFD   //take care of that later
    // renaming requested?
    if ((dwReturnValue == DD_OK)    // dont bother renaming when an error occurred
     && bVBRename)                  // we can rename
    {

        // rename
        #ifdef NV_PROFILE_CPULOCK
        NVP_START (NVP_T_VBDP2_LOCK);
        #endif

        DDLOCKINDEX(NVSTAT_LOCK_VB);
        pVertexBuffer->cpuLock (CSimpleSurface::LOCK_RENAME);

        #ifdef NV_PROFILE_CPULOCK
        NVP_STOP (NVP_T_VBDP2_LOCK);
        nvpLogTime (NVP_T_VBDP2_LOCK,nvpTime[NVP_T_VBDP2_LOCK]);
        #endif

        // grow if we should
        DWORD dwNewSize = (pdp2d->dwFlags & D3DHALDP2_REQVERTEXBUFSIZE) ? pdp2d->dwReqVertexBufSize
                                                                        : 0;
        if (dwNewSize > pVertexBuffer->getSize())
        {
            DWORD dwOriginalSize = pVertexBuffer->getSurface()->getSize();
            DWORD dwHeap         = pVertexBuffer->getSurface()->getHeapLocation();

            pVertexBuffer->getSurface()->destroy();

            if (!pVertexBuffer->getSurface()->create (dwNewSize, 1, 1, 0,
                                                      dwHeap, dwHeap,
                                                      CSimpleSurface::ALLOCATE_SIMPLE
#ifdef CAPTURE
                                                     ,CAPTURE_SURFACE_KIND_VERTEX
#endif
                                                      ))
            {
                // oops, cannot grow. try to revert to original size
                if (!pVertexBuffer->getSurface()->create (dwOriginalSize, 1, 1, 0,
                                                          dwHeap, dwHeap,
                                                          CSimpleSurface::ALLOCATE_SIMPLE
#ifdef CAPTURE
                                                         ,CAPTURE_SURFACE_KIND_VERTEX
#endif
                                                          ))
                {
                    // cannot do that either. fail
                    DPF ("nvDrawPrimitives2: cannot grow or re-establish VB.");
                    dbgD3DError();
                    dwReturnValue = DDERR_CANTLOCKSURFACE;
                    goto normalExit;
                }

                dwNewSize = dwOriginalSize;
            }
        }

        // update D3D
        pdp2d->dwFlags                     |= D3DHALDP2_VIDMEMVERTEXBUF | D3DHALDP2_REQVERTEXBUFSIZE;
//            pdp2d->lpDDVertex->lpGbl->fpVidMem  = pVertexBuffer->getfpVidMem();
        if (pVertexBuffer->getHeapLocation() == CSimpleSurface::HEAP_SYS)
        {
            pdp2d->lpDDVertex->lpGbl->fpVidMem = pVertexBuffer->getAddress();
        }
#ifdef WINNT
        else if (pVertexBuffer->getHeapLocation() == CSimpleSurface::HEAP_AGP)
        {
#ifdef NV_AGP
            pdp2d->lpDDVertex->lpGbl->fpVidMem = nvAGPGetUserAddr(pVertexBuffer->getAddress());
#else
            FLATPTR fpAgpBase = pdp2d->lpDDVertex->lpGbl->fpVidMem - pdp2d->lpDDVertex->lpGbl->fpHeapOffset;

            pdp2d->lpDDVertex->lpGbl->fpHeapOffset  = pVertexBuffer->getfpVidMem() + pDriverData->GARTLinearHeapOffset;
            pdp2d->lpDDVertex->lpGbl->fpVidMem = fpAgpBase + pdp2d->lpDDVertex->lpGbl->fpHeapOffset;
#endif
        }
        else // video
        {
            FLATPTR fpVidBase = pdp2d->lpDDVertex->lpGbl->fpVidMem - pdp2d->lpDDVertex->lpGbl->fpHeapOffset;

            pdp2d->lpDDVertex->lpGbl->fpHeapOffset = pVertexBuffer->getfpVidMem();
            pdp2d->lpDDVertex->lpGbl->fpVidMem = fpVidBase + pVertexBuffer->getfpVidMem();
        }
#else
        else // video
        {
            pdp2d->lpDDVertex->lpGbl->fpVidMem = pVertexBuffer->getAddress();
        }
#endif

        pdp2d->dwReqVertexBufSize           = dwNewSize;
    }
#endif

    // grow command buffer
    if (pCommandBuffer && (pdp2d->dwFlags & D3DHALDP2_REQCOMMANDBUFSIZE) && pCommandBuffer->isOwner())
    {
        pCommandBuffer->growBy(pdp2d->dwReqCommandBufSize, FALSE);
        pdp2d->lpDDCommands->lpGbl->fpVidMem      = pCommandBuffer->getAddress();
        pdp2d->lpDDCommands->lpGbl->dwLinearSize  = pCommandBuffer->getSize();
        pdp2d->dwFlags                           |= D3DHALDP2_SWAPCOMMANDBUFFER /*| D3DHALDP2_VIDMEMCOMMANDBUF*/;
        pdp2d->dwFlags                           &= ~D3DHALDP2_REQCOMMANDBUFSIZE;
    }

    pDriverData->TwoDRenderingOccurred   = 0;
    pDriverData->ThreeDRenderingOccurred = TRUE;

    nvPusherStart (FALSE);

#ifdef NV_PROFILE
    NVP_STOP (NVP_T_DP2);
    nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif

normalExit:
    if (bVBFlushOnExit) {
        DDLOCKINDEX(NVSTAT_LOCK_VB_FLUSH);
#ifdef MCFD
        pVertexBuffer->LockForCPU(CSimpleSurface::LOCK_READ);
#else
        pVertexBuffer->cpuLock(CSimpleSurface::LOCK_NORMAL);
#endif
    }

    if (pContext->sysvb.pSysMemVB) {
        if (pContext->sysvb.bWriteOffset)
            getDC()->defaultVB.updateMap();
        pContext->sysvb.pSysMemVB = NULL;
    }

    pdp2d->ddrval = dwReturnValue;

    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvRefCount.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#include "nvprecomp.h"
#pragma hdrstop

/*
 * this is bad and it will fail inspection. dont know where to put them though
 */
void nvReset2DSurfaceFormat (void);

/*****************************************************************************
 *****************************************************************************
 *****************************************************************************
 ***  CReferenceCount  *******************************************************
 *****************************************************************************
 *****************************************************************************
 *****************************************************************************/

/*****************************************************************************
 * CReferenceCount::nv4WriteCount
 *
 * writes refcount for NV4. we emulate by filling a single 32bpp pixel at a
 *  known location
 */
void CReferenceCount::nv4WriteCount
(
    void
)
{
    PNVD3DCONTEXT pContext;

    // Set proper surface info
    nvglSet2DSurfacesDestination (NV_DD_SURFACES, m_dwNV4SurfaceOffset);
    nvglSet2DSurfacesColorFormat (NV_DD_SURFACES, NV042_SET_COLOR_FORMAT_LE_Y32);
    //nvglSet2DSurfacesPitch       (NV_DD_SURFACES, 0x20,0x20);

    // Do solid rect fill (with argument as color)
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_005E_SOLIDRECT)) {
        nvglSetObject                   (NV_DD_SPARE, D3D_GDI_RECTANGLE_TEXT_2);
        nvglDrawRopRectAndTextColor1A   (NV_DD_SPARE, m_dwRefCount);
        nvglDrawRopRectAndTextPointSize (NV_DD_SPARE, 0, 0, 1, 1);
        pDriverData->dDrawSpareSubchannelObject = D3D_GDI_RECTANGLE_TEXT_2;
    }
    else {
        nvglSetObject      (NV_DD_SPARE,   D3D_RENDER_SOLID_RECTANGLE_2);
        nvglSetStartMethod (0,NV_DD_SPARE, NV05E_COLOR,1);
        nvglSetData        (1,             m_dwRefCount);
        nvglSetStartMethod (2,NV_DD_SPARE, NV05E_RECTANGLE(0),2);
        nvglSetData        (3,             0);
        nvglSetData        (4,             0x00010001);
        nvglAdjust         (5);
        pDriverData->dDrawSpareSubchannelObject = D3D_RENDER_SOLID_RECTANGLE_2;
    }

    // We can't rely on pContext here.
    pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
    while (pContext)
    {
        NV_FORCE_TRI_SETUP(pContext);
        pContext = pContext->pContextNext;
    }

    // reset when we are done
    nvReset2DSurfaceFormat();
}

/*****************************************************************************
 * CReferenceCount::create
 *
 * creates the infrastructure to support a reference count. for NV4/5 we emulate
 *  this behavior. NV10 supports this in HW.
 */
BOOL CReferenceCount::create
(
    DWORD dwTimeOut
)
{
#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        m_pSem = getDC()->nvSemaphoreManager.allocate (0);
    }

    else
#endif
    if ((!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)) &&
        (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS))) {
        // We need to allocate a 16 byte chunk of memory that is guaranteed
        // to be 512 byte aligned. It doesn't matter too much where it is,
        // but don't let it fragment the heap. I specify TYPE_CURSOR because
        // that will place it at the end of the heap.
        DWORD dwStatus;
        NVHEAP_ALLOC (dwStatus, m_dwNV4SurfaceMemory, 511 + 16, TYPE_CURSOR);
        nvAssert (dwStatus == 0);
        DWORD dwMem = (m_dwNV4SurfaceMemory + 511) & (~511);
        m_dwNV4SurfaceOffset = dwMem - pDriverData->BaseAddress;
    }

    // init
    m_dwRefCount = m_dwHWRefCount = 0;
    if (getDC()->nvPusher.isValid()) {
        writeRefCount();
    }
#if (NVARCH >= 0x020)
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN))) {
#else
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS)) {
#endif
        *(DWORD*) (VIDMEM_ADDR(m_dwNV4SurfaceOffset + pDriverData->BaseAddress)) = 0;
    }

    // set timeout state
    m_dwTimeOutValue = m_dwTimeOutReload = dwTimeOut;

    return TRUE;
}

/*****************************************************************************
 * CReferenceCount::destroy
 *
 * destroys refcount related data
 */
void CReferenceCount::destroy
(
    void
)
{
#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
    if (m_pSem == 0xffffffff) return;   // create() was not called

    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        getDC()->nvSemaphoreManager.free (m_pSem);
    }

    else
#endif
    if (m_dwNV4SurfaceMemory == 0xffffffff) return;   // create() was not called

    // for now kelvin and nv4 behave the same
    if ( !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) ||
        (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS))) {
        NVHEAP_FREE (m_dwNV4SurfaceMemory);
        m_dwNV4SurfaceMemory = 0xffffffff;
        m_dwNV4SurfaceOffset = 0;
    }
}

/*****************************************************************************
 *****************************************************************************
 *****************************************************************************
 ***  CReferenceCountMap  ****************************************************
 *****************************************************************************
 *****************************************************************************
 *****************************************************************************/

/*****************************************************************************
 * CReferenceCountMap::put
 *
 * writes a value into the map
 */
template <int cdwLogMax>
void CReferenceCountMap<cdwLogMax>::put
(
    DWORD dwNumber
)
{
    m_dwLastPut = dwNumber;

#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        nvAssert (m_pSem);
        m_pSem->release (dwNumber, &(getDC()->nvPusher), NV_DD_KELVIN, CSemaphore::SEMAPHORE_RELEASE_KELVIN_BACKEND);
    }

    else
#endif
    {
        // next head position
        DWORD dwNewHead = (m_dwHead + 1) & ((1 << cdwLogMax) - 1);
        if (dwNewHead == m_dwTail)
        {
            /*
             * 'get' the latest value. even though we do not use this value, we rely on ::get's
             *  side effect that it advances the tail pointer to the last know HW position
             */
            get();

            /*
             * if we are still out of space, block HW until we do
             *  bad case - we really want to avoid doing this by increasing cdwLogMax
             */
            if (dwNewHead == m_dwTail)
            {
                // start pusher
                nvPusherStart (TRUE);

                // spin until we have space
                do
                {
                    nvDelay();
                    get();
                }
                while (dwNewHead == m_dwTail);
            }
        }

        // write record
        m_adwRefCount[m_dwHead] = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);
        m_adwNumber  [m_dwHead] = dwNumber;
        m_dwHead                = dwNewHead;
    }
}

/*****************************************************************************
 * CReferenceCountMap::get
 *
 * reads the last value HW has reached
 */
template <int cdwLogMax>
DWORD CReferenceCountMap<cdwLogMax>::get
(
    void
)
{
#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        nvAssert (m_pSem);
        m_dwLast = m_pSem->read();
        return (m_dwLast);
    }

    else
#endif
    {
        // read ref count
        DWORD dwRefCount = getDC()->pRefCount->read();

        BOOL bLast = TRUE;
        // find its location in the map
        for (; m_dwTail != m_dwHead; m_dwTail = (m_dwTail + 1) & ((1 << cdwLogMax) - 1))
        {
            bLast = FALSE;

            // compare tail against latest date
            if (dwRefCount < m_adwRefCount[m_dwTail])
            {
                // reached a date the HW has not done with yet
                return m_dwLast;
            }

            // get number
            if (m_bConservative)
            {
                m_dwLast  = m_dwLast2;
                m_dwLast2 = m_adwNumber[m_dwTail];
            }
            else
            {
                m_dwLast  = m_adwNumber[m_dwTail];
            }
        }

        if (m_bConservative && bLast && (m_dwLast != m_dwLast2))
        {
            m_dwLast = m_dwLast2;
        }

        // list is empty, return the last number we had
        return (m_dwLast);
    }
}

/*****************************************************************************
 * CReferenceCountMap::isBusy
 */
template <int cdwLogMax>
BOOL CReferenceCountMap<cdwLogMax>::isBusy
(
    void
)
{
#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        return (m_pSem->read() < m_dwLastPut);
    }

    else
#endif
    {
        get();
        return (m_dwHead != m_dwTail);
    }
}

/*****************************************************************************
 * CReferenceCountMap::create
 */
template <int cdwLogMax>
void CReferenceCountMap<cdwLogMax>::create
(
    DWORD dwInitialNumber, BOOL bConservative
)
{
#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        nvAssert (!m_pSem);
        m_pSem = getDC()->nvSemaphoreManager.allocate (dwInitialNumber);
    }

    else
#endif
    {
        // init
        m_bConservative = bConservative;
        m_dwHead  = m_dwTail = 0;
        m_dwLast2 = m_dwLast = dwInitialNumber;
        m_adwNumber[(1 << cdwLogMax) - 1] = dwInitialNumber;
    }
}

/*****************************************************************************
 * CReferenceCountMap::destroy
 */
template <int cdwLogMax>
void CReferenceCountMap<cdwLogMax>::destroy
(
    void
)
{
#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        nvAssert (m_pSem);
        getDC()->nvSemaphoreManager.free (m_pSem);
    }
#endif
}

#pragma warning (push, 1)
// NOTE: The following warning is issued incorrectly by the MS compiler. Ignore it.  <bdw>
template CReferenceCountMap<5>;
template CReferenceCountMap<10>;
#pragma warning (pop)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvPShad.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvPShad.cpp
//
// **************************************************************************
//
//  History:
//      Hadden Hoppert?            May00            DX8 development
//
// **************************************************************************

#include "nvprecomp.h"
#include <stdio.h> // For sprintf
 
/*****************************************************************************
 ***  CPixelShader  **********************************************************
 *****************************************************************************/

// Lots of lookup tables

const DWORD CPixelShader::PSD3DModToNVMap[] = {
    NV_MAPPING_SIGNED_IDENTITY,   // D3DSPSM_NONE
    NV_MAPPING_SIGNED_NEGATE,     // D3DSPSM_NEG
    NV_MAPPING_HALF_BIAS_NORMAL,  // D3DSPSM_BIAS
    NV_MAPPING_HALF_BIAS_NEGATE,  // D3DSPSM_BIASNEG
    NV_MAPPING_EXPAND_NORMAL,     // D3DSPSM_SIGN
    NV_MAPPING_EXPAND_NEGATE,     // D3DSPSM_SIGNNEG
    NV_MAPPING_UNSIGNED_INVERT,   // D3DSPSM_COMP
    ~0,
    ~0,
    ~0,
    ~0,
    ~0,
    ~0,
    ~0
};

// Take the complement of our mapping mode.
const DWORD CPixelShader::NVMapToNVMapInvert[] = {
    NV_MAPPING_UNSIGNED_INVERT,   // NV_MAPPING_UNSIGNED_IDENTITY
    NV_MAPPING_UNSIGNED_IDENTITY, // NV_MAPPING_UNSIGNED_INVERT
    ~0,                           // NV_MAPPING_EXPAND_NORMAL
    ~0,                           // NV_MAPPING_EXPAND_NEGATE
    ~0,                           // NV_MAPPING_HALF_BIAS_NORMAL
    ~0,                           // NV_MAPPING_HALF_BIAS_NEGATE
    NV_MAPPING_UNSIGNED_INVERT,   // NV_MAPPING_SIGNED_IDENTITY
    ~0,                           // NV_MAPPING_SIGNED_NEGATE
};

// We only support up to 4 of each register type.  This will probably change in NV30.
const DWORD CPixelShader::PSTypeOffsetToCombinerReg[][4] = {
    {0xC, 0xD, 0x0, 0x0}, // D3DSPR_TEMP
    {0x4, 0x5, 0x0, 0x0}, // D3DSPR_INPUT
    {0x1, 0x2, 0x0, 0x0}, // D3DSPR_CONST
    {0x8, 0x9, 0xA, 0xB}, // D3DSPR_TEXTURE
    {0x0, 0x0, 0x0, 0x0}, // Unused type for pixel shaders
    {0x0, 0x0, 0x0, 0x0}  // Unused type for pixel shaders
};

// Virtually all of these are ordinary instructions--only DEF is different.
// I would just make this a case statement, but a table makes for future
// expandability and easier debugging.
const DWORD CPixelShader::PSInstructionType[] = {
    PSHAD_INS, // D3DSIO_NOP
    PSHAD_INS, // D3DSIO_MOV
    PSHAD_INS, // D3DSIO_ADD
    PSHAD_INS, // D3DSIO_SUB
    PSHAD_INS, // D3DSIO_MAD
    PSHAD_INS, // D3DSIO_MUL
    ~0, ~0,
    PSHAD_INS, // D3DSIO_DP3
    ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0,
    PSHAD_INS, // D3DSIO_LRP
    ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0,
    ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0,
    ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0,
    ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0,
    ~0, ~0, ~0, ~0,
    PSHAD_INS, // D3DSIO_NV_MMA
    PSHAD_INS, // D3DSIO_NV_DD
    PSHAD_INS, // D3DSIO_NV_MD
    PSHAD_INS, // D3DSIO_NV_MM
    PSHAD_INS, // D3DSIO_NV_SPF
    PSHAD_TEX, // D3DSIO_TEXCOORD
    PSHAD_TEX, // D3DSIO_TEXKILL
    PSHAD_TEX, // D3DSIO_TEX
    PSHAD_TEX, // D3DSIO_TEXBEM
    PSHAD_TEX, // D3DSIO_TEXBEML
    PSHAD_TEX, // D3DSIO_TEXREG2AR
    PSHAD_TEX, // D3DSIO_TEXREG2GB
    PSHAD_TEX, // D3DSIO_TEXM3x2PAD
    PSHAD_TEX, // D3DSIO_TEXM3x2TEX
    PSHAD_TEX, // D3DSIO_TEXM3x3PAD
    PSHAD_TEX, // D3DSIO_TEXM3x3TEX
    PSHAD_TEX, // D3DSIO_TEXM3x3DIFF
    PSHAD_TEX, // D3DSIO_TEXM3x3SPEC
    PSHAD_TEX, // D3DSIO_TEXM3x3VSPEC
    ~0, ~0,
    PSHAD_INS, // D3DSIO_CND
    PSHAD_DEF, // D3DSIO_DEF
};


#ifdef DEBUG

// Just some debugging strings

const char * CPixelShader::PSInstructionStrings[] = {
    "nop",
    "mov",
    "add",
    "sub",
    "mad",
    "mul",
    0, 0,
    "dp3",
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    "lrp",
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0,
    "nv_mma",
    "nv_dd",
    "nv_md",
    "nv_mm",
    "nv_spf",
    "texcoord",
    "texkill",
    "tex",
    "texbem",
    "texbeml",
    "texreg2ar",
    "texreg2gb",
    "texm3x2pad",
    "texm3x2tex",
    "texm3x3pad",
    "texm3x3tex",
    "texm3x3diff",
    "texm3x3spec",
    "texm3x3vspec",
    0, 0,
    "cnd",
    "def",
};

const char * CPixelShader::PSRegTypeToPrefix[] = {"r", "v", "c", "t"};
const char * CPixelShader::PSWriteMask[] = {
      ".",   ".b",   ".g",   ".gb",
     ".r",  ".rb",  ".rg",  ".rgb",
     ".a",  ".ab",  ".ag",  ".agb",
    ".ar", ".arb", ".arg",      ""};

const char * CPixelShader::PSProgramNames[] = { 
    "PROGRAM_NONE", 
    "2D_PROJECTIVE", 
    "3D_PROJECTIVE", 
    "CUBE_MAP",
    "PASS_THROUGH",
    "CLIP_PLANE",
    "BUMPENVMAP",
    "BUMPENVMAP_LUMINANCE",
    "BRDF",
    "DOT_ST",
    "DOT_ZW",
    "DOT_REFLECT_DIFFUSE",
    "DOT_REFLECT_SPECULAR",
    "DOT_STR_3D",
    "DOT_STR_CUBE",
    "DEPENDENT_AR",
    "DEPENDENT_GB",
    "DOT_PRODUCT",
    "DOT_REFLECT_SPECULAR_CONST",
    "<invalid>",
    "<invalid>",
    "<invalid>",
    "<invalid>",
    "<invalid>",
    "<invalid>",
    "<invalid>",
    "<invalid>",
    "<invalid>",
    "<invalid>",
    "<invalid>",
    "<invalid>",
    "<invalid>"
};

#endif


// Does this shader type require a texture bound at this
// stage?  
const bool CPixelShader::PSShaderUsesTexture[] = {
    FALSE,   // D3DSIO_TEXCOORD
    FALSE,   // D3DSIO_TEXKILL
    TRUE,    // D3DSIO_TEX
    TRUE,    // D3DSIO_TEXBEM
    TRUE,    // D3DSIO_TEXBEML
    TRUE,    // D3DSIO_TEXREG2AR
    TRUE,    // D3DSIO_TEXREG2GB
    FALSE,   // D3DSIO_TEXM3x2PAD
    TRUE,    // D3DSIO_TEXM3x2TEX
    FALSE,   // D3DSIO_TEXM3x3PAD
    TRUE,    // D3DSIO_TEXM3x3TEX
    TRUE,    // D3DSIO_TEXM3x3DIFF
    TRUE,    // D3DSIO_TEXM3x3SPEC
    TRUE     // D3DSIO_TEXM3x3VSPEC
};

const bool CPixelShader::PSIsProjective[] = {
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PROGRAM_NONE
    TRUE,  // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_2D_PROJECTIVE
    TRUE,  // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_3D_PROJECTIVE
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CUBE_MAP
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PASS_THROUGH
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CLIP_PLANE
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BUMPENVMAP
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BUMPENVMAP_LUMINANCE
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BRDF
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_ST
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_ZW
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_REFLECT_DIFFUSE
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_REFLECT_SPECULAR
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_STR_3D
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_STR_CUBE
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DEPENDENT_AR
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DEPENDENT_GB
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_PRODUCT
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_REFLECT_SPECULAR_CONST
};

// Kelvin shaders are a function of both the type of shader and
// the texture bound at that stage.  For example, the ordinary "tex"
// shader has different constants for null, 2D, 3D, and cube map textures.  
// Other shaders are similar, but some combinations don't make sense
// (like BEM into a cube map)
const int CPixelShader::PSD3DTexToNVShader[][4] = {
    {
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PASS_THROUGH,               // D3DSIO_TEXCOORD
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PASS_THROUGH,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PASS_THROUGH,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PASS_THROUGH
    }, {
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CLIP_PLANE,                 // D3DSIO_TEXKILL
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CLIP_PLANE,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CLIP_PLANE,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CLIP_PLANE
    }, {
        ~0,                                                               // D3DSIO_TEX
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_2D_PROJECTIVE,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_3D_PROJECTIVE,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CUBE_MAP,
    }, {
        ~0,                                                               // D3DSIO_TEXBEM
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BUMPENVMAP,
        ~0,
        ~0
    }, {
        ~0,                                                               // D3DSIO_TEXBEML
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BUMPENVMAP_LUMINANCE,
        ~0,
        ~0
    }, {
        ~0,                                                               // D3DSIO_TEXREG2AR
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DEPENDENT_AR,
        ~0,
        ~0
    }, {
        ~0,                                                               // D3DSIO_TEXREG2GB
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DEPENDENT_GB,
        ~0,
        ~0
    }, {
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT,                // D3DSIO_TEXM3x2PAD
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT
    }, {
        ~0,                                                               // D3DSIO_TEXM3x2TEX
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_ST,
        ~0,
        ~0
    }, {
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT,                // D3DSIO_TEXM3x3PAD:
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT
    }, {
        ~0,                                                               // D3DSIO_TEXM3x3TEX
        ~0,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_STR_3D,                 
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_STR_CUBE
    }, {
        ~0,                                                               // D3DSIO_TEXM3x3DIFF
        ~0,
        ~0,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_REFLECT_DIFFUSE
    }, {
        ~0,                                                               // D3DSIO_TEXM3x3SPEC
        ~0,
        ~0,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_REFLECT_SPECULAR_CONST
    }, {
        ~0,                                                               // D3DSIO_TEXM3x3VSPEC
        ~0,
        ~0,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_REFLECT_SPECULAR
    }
};

const DWORD CPixelShader::PSNumSrcRegs[] = {
     0,                                 // D3DSIO_NOP
     1,                                 // D3DSIO_MOV
     2,                                 // D3DSIO_ADD
     2,                                 // D3DSIO_SUB
     3,                                 // D3DSIO_MAD
     2,                                 // D3DSIO_MUL
    -1, -1,                             // Undefined for pixel shaders
     2,                                 // D3DSIO_DP3
    -1, -1, -1, -1, -1, -1, -1, -1, -1, // Undefined for pixel shaders
     3,                                 // D3DSIO_LRP
    -1, -1, -1, -1, -1, -1, -1, -1, -1, // Undefined for pixel shaders
    -1, -1, -1, -1, -1, -1, -1, -1, -1, // Undefined for pixel shaders
    -1, -1, -1, -1, -1, -1, -1, -1, -1, // Undefined for pixel shaders
    -1, -1, -1, -1, -1, -1, -1, -1, -1, // Undefined for pixel shaders
    -1, -1, -1, -1,                     // Undefined for pixel shaders
     4,                                 // D3DSIO_NV_MMA
     4,                                 // D3DSIO_NV_DD  
     4,                                 // D3DSIO_NV_MD  
     4,                                 // D3DSIO_NV_MM  
     7,                                 // D3DSIO_NV_SPF 
     0,                                 // D3DSIO_TEXCOORD:
     0,                                 // D3DSIO_TEXKILL:
     0,                                 // D3DSIO_TEX:
     1,                                 // D3DSIO_TEXBEM:
     1,                                 // D3DSIO_TEXBEML:
     0,                                 // D3DSIO_TEXREG2GR:
     0,                                 // D3DSIO_TEXREG2AB:
     1,                                 // D3DSIO_TEXM3x2PAD:
     1,                                 // D3DSIO_TEXM3x2TEX:
     1,                                 // D3DSIO_TEXM3x3PAD:
     1,                                 // D3DSIO_TEXM3x3TEX:
     1,                                 // D3DSIO_TEXM3x3DIFF:
     2,                                 // D3DSIO_TEXM3x3SPEC:
     1,                                 // D3DSIO_TEXM3x3VSPEC:
     -1, -1,                            // Undefined for pixel shaders
     3,                                 // D3DSIO_CND
};


const DWORD CPixelShader::PSNumDstRegs[] = {
     0,                                 // D3DSIO_NOP
     1,                                 // D3DSIO_MOV
     1,                                 // D3DSIO_ADD
     1,                                 // D3DSIO_SUB
     1,                                 // D3DSIO_MAD
     1,                                 // D3DSIO_MUL
    -1, -1,                             // Undefined for pixel shaders
     1,                                 // D3DSIO_DP3
    -1, -1, -1, -1, -1, -1, -1, -1, -1, // Undefined for pixel shaders
     1,                                 // D3DSIO_LRP
    -1, -1, -1, -1, -1, -1, -1, -1, -1, // Undefined for pixel shaders
    -1, -1, -1, -1, -1, -1, -1, -1, -1, // Undefined for pixel shaders
    -1, -1, -1, -1, -1, -1, -1, -1, -1, // Undefined for pixel shaders
    -1, -1, -1, -1, -1, -1, -1, -1, -1, // Undefined for pixel shaders
    -1, -1, -1, -1,                     // Undefined for pixel shaders
     1,                                 // D3DSIO_NV_MMA
     2,                                 // D3DSIO_NV_DD  
     2,                                 // D3DSIO_NV_MD  
     2,                                 // D3DSIO_NV_MM  
     1,                                 // D3DSIO_NV_SPF 
     1,                                 // D3DSIO_TEXCOORD:
     1,                                 // D3DSIO_TEXKILL:
     1,                                 // D3DSIO_TEX:
     1,                                 // D3DSIO_TEXBEM:
     1,                                 // D3DSIO_TEXBEML:
     1,                                 // D3DSIO_TEXREG2GR:
     1,                                 // D3DSIO_TEXREG2AB:
     1,                                 // D3DSIO_TEXM3x2PAD:
     1,                                 // D3DSIO_TEXM3x2TEX:
     1,                                 // D3DSIO_TEXM3x3PAD:
     1,                                 // D3DSIO_TEXM3x3TEX:
     1,                                 // D3DSIO_TEXM3x3DIFF:
     1,                                 // D3DSIO_TEXM3x3SPEC:
     1,                                 // D3DSIO_TEXM3x3VSPEC:
    -1, -1,                             // Undefined for pixel shaders
     1,                                 // D3DSIO_CND
};

void (CPixelShader::* const CPixelShader::PSInstructionLUT[])(PSHAD_INSTRUCTION_ARGS) = {
    0,                               // D3DSIO_NOP
    CPixelShader::InstructionMOV,    // D3DSIO_MOV
    CPixelShader::InstructionADD,    // D3DSIO_ADD
    CPixelShader::InstructionSUB,    // D3DSIO_SUB
    CPixelShader::InstructionMAD,    // D3DSIO_MAD
    CPixelShader::InstructionMUL,    // D3DSIO_MUL
    0, 0,                            // Undefined for pixel shaders
    CPixelShader::InstructionDP3,    // D3DSIO_DP3
    0, 0, 0, 0, 0, 0, 0, 0, 0,       // Undefined for pixel shaders
    CPixelShader::InstructionLRP,    // D3DSIO_LRP
    0, 0, 0, 0, 0, 0, 0, 0, 0,       // Undefined for pixel shaders
    0, 0, 0, 0, 0, 0, 0, 0, 0,       // Undefined for pixel shaders
    0, 0, 0, 0, 0, 0, 0, 0, 0,       // Undefined for pixel shaders
    0, 0, 0, 0, 0, 0, 0, 0, 0,       // Undefined for pixel shaders
    0, 0, 0, 0,                      // Undefined for pixel shaders
    CPixelShader::InstructionNV_MMA, // D3DSIO_NV_MMA
    CPixelShader::InstructionNV_DD,  // D3DSIO_NV_DD
    CPixelShader::InstructionNV_MD,  // D3DSIO_NV_MD
    CPixelShader::InstructionNV_MM,  // D3DSIO_NV_MM
    CPixelShader::InstructionNV_SPF, // D3DSIO_NV_SPF
    0, 0, 0, 0, 0, 0, 0, 0, 0,       // Undefined for pixel shaders
    0, 0, 0, 0, 0, 0, 0,             // Undefined for pixel shaders
    CPixelShader::InstructionCND,    // D3DSIO_CND
};

////////////////////////////////////////////////////////////////

#define SetCombinerInput(stage, color, var, mapping, alpha, src) \
    do { \
        m_cw[stage][color][PSHAD_ICW] &= ~DRF_SHIFTMASK(NV097_SET_COMBINER_COLOR_ICW_##var##_MAP); \
        m_cw[stage][color][PSHAD_ICW] &= ~DRF_SHIFTMASK(NV097_SET_COMBINER_COLOR_ICW_##var##_ALPHA); \
        m_cw[stage][color][PSHAD_ICW] &= ~DRF_SHIFTMASK(NV097_SET_COMBINER_COLOR_ICW_##var##_SOURCE); \
        m_cw[stage][color][PSHAD_ICW] |= DRF_NUM(097, _SET_COMBINER_COLOR_ICW, _##var##_MAP,    mapping) \
                                      |  DRF_NUM(097, _SET_COMBINER_COLOR_ICW, _##var##_ALPHA,  alpha ? 1 : 0) \
                                      |  DRF_NUM(097, _SET_COMBINER_COLOR_ICW, _##var##_SOURCE, src); \
    } while (0);

// Partial OCW setup for the multiply terms.  Inputs are side (AB or CD), destination register, and
// whether a dot product is performed
#define SetCombinerOutput(stage, color, side, dst, dot, bluetoalpha) \
    do { \
        m_cw[stage][color][PSHAD_OCW] &= ~DRF_SHIFTMASK(NV097_SET_COMBINER_COLOR_OCW_##side##_DST); \
        m_cw[stage][color][PSHAD_OCW] &= ~DRF_SHIFTMASK(NV097_SET_COMBINER_COLOR_OCW_##side##_DOT_ENABLE); \
        m_cw[stage][color][PSHAD_OCW] &= ~DRF_SHIFTMASK(NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_##side##); \
        m_cw[stage][color][PSHAD_OCW] |= DRF_NUM(097, _SET_COMBINER_COLOR_OCW, _##side##_DST, dst); \
        m_cw[stage][color][PSHAD_OCW] |= DRF_NUM(097, _SET_COMBINER_COLOR_OCW, _##side##_DOT_ENABLE, dot ? 1 : 0); \
        m_cw[stage][color][PSHAD_OCW] |= DRF_NUM(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_##side##, bluetoalpha ? 1 : 0); \
    } while (0);


// Sets the global shift/bias settings in the OCW for this stage
#define SetCombinerOutputShiftSat(stage, color, shift, sat) \
    do { \
        m_cw[stage][color][PSHAD_OCW] &= ~DRF_SHIFTMASK(NV097_SET_COMBINER_COLOR_OCW_OP); \
        m_cw[stage][color][PSHAD_OCW] |= DRF_NUM(097, _SET_COMBINER_COLOR_OCW, _OP, (shift << 1)); /* need saturation support */\
    } while (0);


#define SetCombinerSumOutput(stage, color, dst, mux) \
    do { \
        m_cw[stage][color][PSHAD_OCW] &= ~DRF_SHIFTMASK(NV097_SET_COMBINER_COLOR_OCW_MUX_ENABLE); \
        m_cw[stage][color][PSHAD_OCW] &= ~DRF_SHIFTMASK(NV097_SET_COMBINER_COLOR_OCW_SUM_DST); \
        m_cw[stage][color][PSHAD_OCW] |= DRF_NUM(097, _SET_COMBINER_COLOR_OCW, _MUX_ENABLE, mux ? 1 : 0); \
        m_cw[stage][color][PSHAD_OCW] |= DRF_NUM(097, _SET_COMBINER_COLOR_OCW, _SUM_DST, dst); \
    } while (0);

///////////////////////////////////////////////////////////

void CPixelShader::InstructionNOP(PSHAD_INSTRUCTION_ARGS) {
    SetCombinerInput(stage, color, A, NV_MAPPING_SIGNED_IDENTITY, FALSE, NV_REG_ZERO);
    SetCombinerInput(stage, color, B, NV_MAPPING_SIGNED_IDENTITY, FALSE, NV_REG_ZERO);
    SetCombinerInput(stage, color, C, NV_MAPPING_SIGNED_IDENTITY, FALSE, NV_REG_ZERO);
    SetCombinerInput(stage, color, D, NV_MAPPING_SIGNED_IDENTITY, FALSE, NV_REG_ZERO);

    SetCombinerOutput(stage, color, AB, NV_REG_ZERO, FALSE, FALSE);
    SetCombinerOutput(stage, color, CD, NV_REG_ZERO, FALSE, FALSE);
    SetCombinerSumOutput(stage, color, NV_REG_ZERO, FALSE);

    SetCombinerOutputShiftSat(stage, color, 0, 0);
}

void CPixelShader::InstructionMOV(PSHAD_INSTRUCTION_ARGS) {
    // O = A*1
    SetCombinerInput(stage, color, A, map[0],                     alpha[0], src[0]);
    SetCombinerInput(stage, color, B, NV_MAPPING_UNSIGNED_INVERT, FALSE,    NV_REG_ZERO);
    SetCombinerOutput(stage, color, AB, dst[0], FALSE, FALSE);

    SetCombinerOutputShiftSat(stage, color, shift, sat);
}

void CPixelShader::InstructionMUL(PSHAD_INSTRUCTION_ARGS) {
    // O = A*B
    SetCombinerInput(stage, color, A, map[0], alpha[0], src[0]);
    SetCombinerInput(stage, color, B, map[1], alpha[1], src[1]);
    SetCombinerOutput(stage, color, AB, dst[0], FALSE, FALSE);

    SetCombinerOutputShiftSat(stage, color, shift, sat);
}

void CPixelShader::InstructionDP3(PSHAD_INSTRUCTION_ARGS) {
    if (color == PSHAD_COLOR) {
        // O = dot(A, B)

        // DP3 only works on the color side.  We make sure to replicate alpha later
        SetCombinerInput(stage, color, A, map[0], alpha[0], src[0]);
        SetCombinerInput(stage, color, B, map[1], alpha[1], src[1]);
        SetCombinerOutput(stage, color, AB, dst[0], TRUE, FALSE);

        SetCombinerOutputShiftSat(stage, color, shift, sat);
    } else {
        // Here, we replicate blue to alpha on the color side if the program requests the DP3
        // to go to rgba.  It's something of a hack, but it's the only instruction where we
        // have to do this.
        m_cw[stage][PSHAD_COLOR][PSHAD_OCW] |= DRF_NUM(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_AB, TRUE);
        
        // We don't care about what actually happens on the alpha side, since the alpha
        // replication overwrites it anyway.
        InstructionNOP(stage, color, shift, sat, dst, src, alpha, map);
    }
}

void CPixelShader::InstructionADD(PSHAD_INSTRUCTION_ARGS) {
    // O = A*1 + C*1
    SetCombinerInput(stage, color, A, map[0],                     alpha[0], src[0]);
    SetCombinerInput(stage, color, B, NV_MAPPING_UNSIGNED_INVERT, FALSE,    NV_REG_ZERO);
    SetCombinerInput(stage, color, C, map[1],                     alpha[1], src[1]);
    SetCombinerInput(stage, color, D, NV_MAPPING_UNSIGNED_INVERT, FALSE,    NV_REG_ZERO);

    SetCombinerSumOutput(stage, color, dst[0], FALSE);

    SetCombinerOutputShiftSat(stage, color, shift, sat);
}

void CPixelShader::InstructionSUB(PSHAD_INSTRUCTION_ARGS) {
    // O = A*1 + C*-1
    SetCombinerInput(stage, color, A, map[0],                     alpha[0], src[0]);
    SetCombinerInput(stage, color, B, NV_MAPPING_UNSIGNED_INVERT, FALSE,    NV_REG_ZERO); // map zero to 1
    SetCombinerInput(stage, color, C, map[1],                     alpha[1], src[1]);
    SetCombinerInput(stage, color, D, NV_MAPPING_EXPAND_NORMAL,   FALSE,    NV_REG_ZERO); // map zero to -1

    SetCombinerSumOutput(stage, color, dst[0], FALSE);

    SetCombinerOutputShiftSat(stage, color, shift, sat);
}

void CPixelShader::InstructionMAD(PSHAD_INSTRUCTION_ARGS) {
    // O = A*B + C*1
    SetCombinerInput(stage, color, A, map[0],                     alpha[0], src[0]);
    SetCombinerInput(stage, color, B, map[1],                     alpha[1], src[1]);
    SetCombinerInput(stage, color, C, map[2],                     alpha[2], src[2]);
    SetCombinerInput(stage, color, D, NV_MAPPING_UNSIGNED_INVERT, FALSE,    NV_REG_ZERO);

    SetCombinerSumOutput(stage, color, dst[0], FALSE);

    SetCombinerOutputShiftSat(stage, color, shift, sat);
}

void CPixelShader::InstructionLRP(PSHAD_INSTRUCTION_ARGS) {
    // O = A*B + (1-C)*D
    SetCombinerInput(stage, color, A, map[0],                     alpha[0], src[0]);
    SetCombinerInput(stage, color, B, map[1],                     alpha[1], src[1]);
    SetCombinerInput(stage, color, C, NVMapToNVMapInvert[map[0]], alpha[0], src[0]);
    SetCombinerInput(stage, color, D, map[2],                     alpha[2], src[2]);

    SetCombinerSumOutput(stage, color, dst[0], FALSE);

    SetCombinerOutputShiftSat(stage, color, shift, sat);
}

void CPixelShader::InstructionCND(PSHAD_INSTRUCTION_ARGS) {
    // O = r0 ? A*1 : C*1
    SetCombinerInput(stage, color, A, map[2],                     alpha[2], src[2]);
    SetCombinerInput(stage, color, B, NV_MAPPING_UNSIGNED_INVERT, FALSE,    NV_REG_ZERO);
    SetCombinerInput(stage, color, C, map[1],                     alpha[1], src[1]);
    SetCombinerInput(stage, color, D, NV_MAPPING_UNSIGNED_INVERT, FALSE,    NV_REG_ZERO);

    SetCombinerSumOutput(stage, color, dst[0], TRUE);

    SetCombinerOutputShiftSat(stage, color, shift, sat);
}

void CPixelShader::InstructionNV_MMA(PSHAD_INSTRUCTION_ARGS) {
	// O = A*B + C*D
    SetCombinerInput(stage, color, A, map[0], alpha[0], src[0]);
    SetCombinerInput(stage, color, B, map[1], alpha[1], src[1]);
    SetCombinerInput(stage, color, C, map[2], alpha[2], src[2]);
    SetCombinerInput(stage, color, D, map[3], alpha[3], src[3]);

    SetCombinerSumOutput(stage, color, dst[0], FALSE);

    SetCombinerOutputShiftSat(stage, color, shift, sat);
}

void CPixelShader::InstructionNV_DD (PSHAD_INSTRUCTION_ARGS) {
	// O0 = dot(A, B)
	// O1 = dot(C, D)
	// see DP3 instruction comments for more details
    if (color == PSHAD_COLOR) {
        SetCombinerInput(stage, color, A, map[0], alpha[0], src[0]);
        SetCombinerInput(stage, color, B, map[1], alpha[1], src[1]);
        SetCombinerInput(stage, color, C, map[2], alpha[2], src[2]);
        SetCombinerInput(stage, color, D, map[3], alpha[3], src[3]);

        SetCombinerOutput(stage, color, AB, dst[0], TRUE, FALSE);
        SetCombinerOutput(stage, color, CD, dst[1], TRUE, FALSE);
    } else {
        m_cw[stage][PSHAD_COLOR][PSHAD_OCW] |= DRF_NUM(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_AB, TRUE);
        m_cw[stage][PSHAD_COLOR][PSHAD_OCW] |= DRF_NUM(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_CD, TRUE);
    }
}

void CPixelShader::InstructionNV_MD (PSHAD_INSTRUCTION_ARGS) {
	// O0 = A*B
	// O1 = dot(C, D)
    SetCombinerInput(stage, color, A, map[0], alpha[0], src[0]);
    SetCombinerInput(stage, color, B, map[1], alpha[1], src[1]);

    SetCombinerOutput(stage, color, AB, dst[0], FALSE, FALSE);

    if (color == PSHAD_COLOR) {
        SetCombinerInput(stage, color, C, map[2], alpha[2], src[2]);
        SetCombinerInput(stage, color, D, map[3], alpha[3], src[3]);
        SetCombinerOutput(stage, color, CD, dst[1], TRUE, FALSE);
    } else {
        m_cw[stage][PSHAD_COLOR][PSHAD_OCW] |= DRF_NUM(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_CD, TRUE);
    }
}

void CPixelShader::InstructionNV_MM (PSHAD_INSTRUCTION_ARGS) {
	// O0 = A*B
	// O1 = C*D
    SetCombinerInput(stage, color, A, map[0], alpha[0], src[0]);
    SetCombinerInput(stage, color, B, map[1], alpha[1], src[1]);
    SetCombinerInput(stage, color, C, map[2], alpha[2], src[2]);
    SetCombinerInput(stage, color, D, map[3], alpha[3], src[3]);

    SetCombinerOutput(stage, color, AB, dst[0], TRUE, FALSE);
    SetCombinerOutput(stage, color, CD, dst[1], TRUE, FALSE);
}

void CPixelShader::InstructionNV_SPF(PSHAD_INSTRUCTION_ARGS) {
	// r4 = E*F
	// O.rgb = A*B + (1-A)*C + D
	// O.a = G
}




/////////////////////////////////////////////////////////////

// In Celsius, we remap the texture registers, such that programs can access the
// textures defined in any stage, and to fight the stage compaction that Celsius
// devices perform.
// We don't do this in Kelvin, because the stages (and the shader programs) map
// directly to the hardware, so it would be very difficult to perform the remapping.
// There is also no problem with stage compaction.
void CPixelShader::GetTextureRegMapping(DWORD *newoffset, DWORD offset) {
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        *newoffset = offset;
    } else {
        if (m_celsiusTexStageMapping[offset] == PSHAD_UNUSED) {
            m_celsiusTexStageMapping[offset] = m_texturesUsed;
            m_texturesUsed++;
        }
        *newoffset = m_texturesUsed - 1;
    }
}

// Decode the destination register token
DWORD CPixelShader::DSTdecode(
    DWORD *dst,
    DWORD *shift,
    DWORD *sat,
    DWORD *mask,
    DWORD op
)
{
    DWORD type = (op & D3DSP_REGTYPE_MASK) >> D3DSP_REGTYPE_SHIFT;
    DWORD offset = op & D3DSP_REGNUM_MASK;

    if ((op & D3DSP_REGTYPE_MASK) == D3DSPR_TEXTURE) {
        GetTextureRegMapping(&offset, offset);
    }

    *dst = PSTypeOffsetToCombinerReg[type][offset];
    *shift = ((op & D3DSP_DSTSHIFT_MASK) >> D3DSP_DSTSHIFT_SHIFT) & 0x3;
    *sat = (op & D3DSP_DSTMOD_MASK) == D3DSPDM_SATURATE;
    *mask = op & D3DSP_WRITEMASK_ALL;

    return TRUE;
}

// Decode the source register token
DWORD CPixelShader::SRCdecode(
    DWORD *src,
    DWORD *rgbAlpha,
    DWORD *alphaAlpha,
    DWORD *map,
    DWORD op,
    DWORD mask,
    BOOL  bSignedConst
)
{
    DWORD type = (op & D3DSP_REGTYPE_MASK) >> D3DSP_REGTYPE_SHIFT; // const reg, texture reg, etc
    DWORD regnum = op & D3DSP_REGNUM_MASK;   // which reg number within a type set is it?
    DWORD offset = regnum;                   // save this, we may have to remap it later
    DWORD conststage = (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) ? m_dwStage : 0;
    DWORD swiz = (op & D3DSP_SWIZZLE_MASK) >> D3DSP_SWIZZLE_SHIFT;

    *map = PSD3DModToNVMap[(op & D3DSP_SRCMOD_MASK) >> D3DSP_SRCMOD_SHIFT];
    nvAssert(*map != ~0);

    if ((op & D3DSP_REGTYPE_MASK) == D3DSPR_CONST) {
        if (regnum >= PSHAD_MAX_CONSTANTS) {
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "Constant number too high (c%d)", regnum);
            return FALSE;
        }

        offset = AllocateConstRegister(m_dwStage, regnum, bSignedConst, *map);

        // We don't apply normal source mapping to const values, since the const registers can only
        // hold unsigned values, and we can't perform a double remapping when we need to hold
        // signed values.  Hence, we perform the remapping offline, and always use one of two
        // mapping modes, depending on whether the final result holds signed values.  
        // Two things to note:
        // - Sometimes we *can't* store signed values, such as when a constant is used as the first
        // argument to LRP (where we need to perform a complement operation).  Fortunately, the runtime
        // makes this case illegal (or at least it's supposed to).
        // - This mapping value may be changed later
        *map = bSignedConst ? NV_MAPPING_EXPAND_NORMAL : NV_MAPPING_UNSIGNED_IDENTITY;


    } else if ((op & D3DSP_REGTYPE_MASK) == D3DSPR_TEXTURE) {
        GetTextureRegMapping(&offset, offset);
    }

    *src = PSTypeOffsetToCombinerReg[type][offset];

    swiz = ((mask & D3DSP_WRITEMASK_RGB) ? (swiz & 0x3f) : 0x24) | ((mask & D3DSP_WRITEMASK_A) ? (swiz & 0xc0) : 0xc0);

    switch (swiz) {
    case 0xff:   // aaaa
        *rgbAlpha = 1;
        *alphaAlpha = 1;
        break;
    case 0xa4:   // rgbb
        *rgbAlpha = 0;
        *alphaAlpha = 0;
        break;
    case 0xbf:   // aaab
        *rgbAlpha = 1;
        *alphaAlpha = 0;
        break;
    default:
        // should always have one of these 4 cases
        nvAssert(0);
    case 0xe4:   // rgba
        *rgbAlpha = 0;
        *alphaAlpha = 1;
        break;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////

#ifdef DEBUG

void CPixelShader::DBGPrintInstruction(DWORD op, DWORD dstop, DWORD *srcop) {
    char str[256], str2[256];
    DWORD opcode;
    DWORD comma = 0;
    DWORD mod, neg, bias, scale;

    opcode = op & D3DSI_OPCODE_MASK;
    strcpy(str, (op & D3DSI_COISSUE) ? "+" : "");
    strcat(str, PSInstructionStrings[opcode]);


    if (PSNumDstRegs[opcode]) {
        switch ((dstop & D3DSP_DSTSHIFT_MASK) >> D3DSP_DSTSHIFT_SHIFT) {
        case 0x0:
            break;
        case 0x1:
            strcat(str, "_x2");
            break;
        case 0x2:
            strcat(str, "_x4");
            break;
        case 0xf:
            strcat(str, "_d2");
            break;
        default:
            // Bad program!
            nvAssert(0);
        }

        if ((dstop & D3DSP_DSTMOD_MASK) == D3DSPDM_SATURATE) strcat(str, "_sat");

        sprintf(str2, " %s%d%s", 
            PSRegTypeToPrefix[(dstop & D3DSP_REGTYPE_MASK) >> D3DSP_REGTYPE_SHIFT],
            dstop & D3DSP_REGNUM_MASK,
            PSWriteMask[(dstop & D3DSP_WRITEMASK_ALL) >> D3DSP_WRITEMASK_SHIFT]);
        strcat(str, str2);

        comma = 1;
    }

    for (DWORD i=0; i<PSNumSrcRegs[opcode]; i++) {
        mod = srcop[i] & D3DSP_SRCMOD_MASK;
        neg = (mod == D3DSPSM_NEG) || (mod == D3DSPSM_BIASNEG) || (mod == D3DSPSM_SIGNNEG) || (mod == D3DSPSM_COMP);
        bias = (mod == D3DSPSM_BIAS) || (mod == D3DSPSM_BIASNEG);
        scale = (mod == D3DSPSM_SIGN) || (mod == D3DSPSM_SIGNNEG);

        sprintf(str2, "%s %s%s%s%d%s%s",
            comma ? "," : "",
            (mod == D3DSPSM_COMP) ? "1" : "",
            neg ? "-" : "",
            PSRegTypeToPrefix[(srcop[i] & D3DSP_REGTYPE_MASK) >> D3DSP_REGTYPE_SHIFT],
            srcop[i] & D3DSP_REGNUM_MASK,
            bias ? "_bias" : "",
            scale ? "_bx2" : "");
        strcat(str, str2);

        comma = 1;
    }

    DPF_LEVEL(NVDBG_LEVEL_PIXEL_SHADER, str);
}
#endif

///////////////////////////////////////////////////////////////////////

CPixelShader::create
(
    PNVD3DCONTEXT pContext,
    DWORD dwHandle,
    DWORD dwCodeSize,
    DWORD *lpCode
)
{
    DWORD i;
    DWORD dstop, srcop[3];

    // An instruction wants it's output saturated on this register.  
    // Unfortunately, we can only saturate on input
    bool bSaturateOutput[NV_REG_MAX][2]; 
                              
#ifdef DEBUG
    char str[256];
#endif

    m_dwCodeData = (DWORD *)AllocIPM (dwCodeSize);
    m_dwCodeSize = dwCodeSize;
    m_dwHandle = dwHandle;
    memcpy (m_dwCodeData,lpCode,dwCodeSize); //not really needed, but nice for debug

    DWORD maxcombiners = (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) ? 8 : 2;

    for (i=0; i<PSHAD_MAX_COMBINER_STAGES; i++) {
        m_cw[i][0][0] = 0;
        m_cw[i][0][1] = 0;
        m_cw[i][1][0] = 0;
        m_cw[i][1][1] = 0;
    }

    for (i=0; i<PSHAD_MAX_CONSTANTS; i++) {
        m_dwPixelShaderConstFlags[i] = 0;
    }

    for (i=0; i<PSHAD_MAX_SHADER_STAGES; i++) {
        m_celsiusTexStageMapping[i] = PSHAD_UNUSED;
        m_shaderStageInput[i] = PSHAD_UNUSED;
        m_shaderStageInputInverse[i] = PSHAD_UNUSED;
        m_shaderStageProgram[i] = PSHAD_UNUSED;
    }

    for (i=0; i<NV_REG_MAX; i++) {
        bSaturateOutput[i][PSHAD_COLOR] = false;
        bSaturateOutput[i][PSHAD_ALPHA] = false;
    }

    m_texturesUsed = 0;
    m_textureStageSwap = 0;

    DWORD op, lastMask;
    DWORD opcode, shift, sat, mask;

    DWORD dst[PSHAD_MAX_DST_ARGS_PER_INSTRUCTION];
    DWORD lastDst[PSHAD_MAX_DST_ARGS_PER_INSTRUCTION];

    DWORD src[PSHAD_MAX_SRC_ARGS_PER_INSTRUCTION];
    DWORD rgbAlpha[PSHAD_MAX_SRC_ARGS_PER_INSTRUCTION];
    DWORD alphaAlpha[PSHAD_MAX_SRC_ARGS_PER_INSTRUCTION];
    DWORD map[PSHAD_MAX_SRC_ARGS_PER_INSTRUCTION];

    DWORD size, dstoffset, srcoffset, srcmap;

    DWORD version = *lpCode++;
    nvAssert((version & 0xffff0000) == 0xffff0000);

    m_dwStage = 0;
    m_dwTextureStage = 0;

    DPF_LEVEL(NVDBG_LEVEL_PIXEL_SHADER, "Pixel shader creation: handle=%d", dwHandle);
    DPF_LEVEL(NVDBG_LEVEL_PIXEL_SHADER, "ps. %d.%d", (version & 0xff00) >> 8, version & 0xff);

    for (i=0; i<dwCodeSize; i+=sizeof(DWORD)) {
        op = *lpCode++;
        opcode = op & D3DSI_OPCODE_MASK;

        if (m_dwStage >= maxcombiners) break; // too many instructions

        if (opcode == D3DSIO_END) {
            // End of tokens
            DPF_LEVEL(NVDBG_LEVEL_PIXEL_SHADER, "end");
            break;
        } else if (opcode == D3DSIO_NOP) {
            // Nothing
            DPF_LEVEL(NVDBG_LEVEL_PIXEL_SHADER, "nop");
        } else if (opcode == D3DSIO_COMMENT) {
            // Comment instruction...  or unconditional jump forward...
            size = (op & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT;
            if ((*lpCode == MAKEFOURCC('N', 'V', 'D', 'A')) &&
                (size == 49)) {
                // Load raw combiner state
            }
#ifdef DEBUG
            memset(str, 0, 256);
            strncpy(str, (const char *)lpCode, 4*size);
            DPF_LEVEL(NVDBG_LEVEL_PIXEL_SHADER, "comment: %s", str);
#endif
            lpCode += size; // Skip past comment DWORDS.  There's sometimes a message string in here.
        } else if (PSInstructionType[opcode] == PSHAD_INS) {
            // It's a standard instruction

            if (op & D3DSI_COISSUE) {
                // They are issuing a color op and an alpha op in parallel.
                // Decrease stage count to match last instruction and check consistency.
                m_dwStage--; 
            }

            dstop = *lpCode++;
            for (i=0; i<PSNumDstRegs[opcode]; i++) {
	            if (!DSTdecode(&dst[i], &shift, &sat, &mask, dstop)) {
					nvAssert(0);
					return FALSE;
				}
			}

            nvAssert(PSNumSrcRegs[opcode] >= 0);
            for (i=0; i<PSNumSrcRegs[opcode]; i++) {
                srcop[i] = *lpCode++;
                DWORD signedconst = !((opcode == D3DSIO_LRP) && (i == 0));
                if (!SRCdecode(&src[i], &rgbAlpha[i], &alphaAlpha[i], &map[i], srcop[i], mask, signedconst)) {
                    nvAssert(0);
                    return FALSE;
                }

                bool bSatSrc;

                if (mask & D3DSP_WRITEMASK_RGB) {
                    bSatSrc = bSaturateOutput[src[i]][PSHAD_COLOR];
                } else if (mask & D3DSP_WRITEMASK_A) {
                    bSatSrc = bSaturateOutput[src[i]][PSHAD_ALPHA];
                }

                if (bSatSrc) {
                    if (map[i] == NV_MAPPING_SIGNED_IDENTITY) {
                        // Clamp input
                        map[i] = NV_MAPPING_UNSIGNED_IDENTITY;
                    } else if ((map[i] == NV_MAPPING_UNSIGNED_IDENTITY) ||
                               (map[i] == NV_MAPPING_UNSIGNED_INVERT)) {
                        // Do nothing; these are already clamped
                    } else {
                        // The runtime chouldn't allow these cases, but just in case, assert...
                        nvAssert(0);
                    }
                }
            }

            nvAssert(PSInstructionLUT[opcode] != 0);

            if ((op & D3DSI_COISSUE) && ((lastMask ^ mask) != D3DSP_WRITEMASK_RGBA)) {
                // They tried one of the following combinations: rgba/rgba, rgba/rgb, rgba/a, rgb/rgb, a/a
                // The only combo we support is rgb/a
                nvAssert(0);
                return FALSE;
            }

            if (mask & D3DSP_WRITEMASK_RGB) {
                bSaturateOutput[dst[0]][PSHAD_COLOR] = sat ? true : false;
                (this->*PSInstructionLUT[opcode])(m_dwStage, PSHAD_COLOR, shift, sat, dst, src, rgbAlpha, map);
            }
            if (mask & D3DSP_WRITEMASK_A) {
                bSaturateOutput[dst[0]][PSHAD_ALPHA] = sat ? true : false;
                (this->*PSInstructionLUT[opcode])(m_dwStage, PSHAD_ALPHA, shift, sat, dst, src, alphaAlpha, map);
            }

#ifdef DEBUG
            DBGPrintInstruction(op, dstop, srcop);
#endif

            m_dwStage++;
        } else if (PSInstructionType[opcode] == PSHAD_TEX) {
            nvAssert(opcode >= D3DSIO_TEXCOORD);
            nvAssert(opcode <= D3DSIO_TEXM3x3VSPEC);

            // Get destination register offset
            if (PSNumDstRegs[opcode] == 1) {
                dstop = *lpCode++;
                dstoffset = dstop & D3DSP_REGNUM_MASK;
            }

            // Grab texture input stage
            if (PSNumSrcRegs[opcode] >= 1) {
                srcop[0] = *lpCode++;
                srcoffset = srcop[0] & D3DSP_REGNUM_MASK;
                srcmap = srcop[0] & D3DSP_SRCMOD_MASK;
            } else {
                srcoffset = PSHAD_UNUSED;
                srcmap = D3DSPSM_NONE;
            }

            nvAssert((srcmap == D3DSPSM_NONE) || (srcmap == D3DSPSM_SIGN));

            // Skip rest of src arguments, they are useless to us
            for (i=1; (int)i<PSNumSrcRegs[opcode]; i++) {
                srcop[i] = *lpCode++;
            }


            if (dstoffset >= PSHAD_MAX_SHADER_STAGES) {
                // Oops, they've exceeeded the max number of texture stages.  Break so they know they screwed up.
                break;
            }

            // In Kelvin, there's a pretty direct mapping between D3D texture shader stages
            // and the hardware stages.
            // In Celsius, we only support a single texture addressing operation, which is a
            // simple 2D/cube map sampling.  Because of this, we actually ignore all addressing
            // instructions, because they can't give us any additional information.  Maybe we
            // should check these anyway, simply for debugging purposes.

            // At some point, we should at least put in some quick error checking on the stage state, since currently,
            // we save setting up the stage state until later on (in setKelvinState).
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                m_shaderStageProgram[dstoffset] = opcode - D3DSIO_TEXCOORD;
                m_shaderStageInput[dstoffset] = srcoffset;
                m_shaderStageInputMapping[dstoffset] = srcmap;
                m_dwTextureStage++;
            }

#ifdef DEBUG
            srcoffset = (srcoffset == PSHAD_UNUSED) ? 0 : srcoffset; // Fix up srcoffset after the fact, so it doesn't page fault things
            DBGPrintInstruction(op, dstop, srcop);
#endif
        } else if (PSInstructionType[opcode] == PSHAD_DEF) {
            // Accept a constant color definition
            DWORD dwIndex = (*lpCode++) & 0xffff;

            m_dwPixelShaderConstFlags[dwIndex] |= PSHAD_CONST_LOCAL;

            D3DCOLORVALUE c;
            c.r = *(D3DVALUE *)&(*lpCode++);
            c.g = *(D3DVALUE *)&(*lpCode++);
            c.b = *(D3DVALUE *)&(*lpCode++);
            c.a = *(D3DVALUE *)&(*lpCode++);

            m_pixelShaderConsts[dwIndex] = c;

            DPF_LEVEL(NVDBG_LEVEL_PIXEL_SHADER, "def c%d, %f, %f, %f, %f", dwIndex, c.a, c.r, c.g, c.b);
        } else {
            // Invalid opcode
            nvAssert(0);
        }

        lastMask = mask; // save for checking coissue ops
		for (i=0; i<PSHAD_MAX_DST_ARGS_PER_INSTRUCTION; i++) lastDst[i] = dst[i]; // for dependency checking
    }

    if (m_dwStage == 0) {
        // Make sure we have a valid combiner setup
        InstructionNOP(0, PSHAD_COLOR, 0, 0, 0, 0, 0, 0);
        InstructionNOP(0, PSHAD_ALPHA, 0, 0, 0, 0, 0, 0);
        m_dwStage = 1;
    }

    for (i=0; i<PSHAD_MAX_SHADER_STAGES; i++) {
        if (m_shaderStageInput[i] != PSHAD_UNUSED) {
            m_shaderStageInputInverse[m_shaderStageInput[i]] = i;
        } else {
            m_shaderStageInput[i] = 0;
        }
    }

    // Missing end opcode
    if (opcode != D3DSIO_END) {
        nvAssert(0);
        return FALSE;
    }


    return TRUE;
}

CPixelShader::~CPixelShader() {
    if (m_dwCodeData) FreeIPM(m_dwCodeData);
}

//////////////////////////////////////////////////////////////////////////

DWORD CPixelShader::AllocateConstRegister(DWORD dwStage, DWORD dwRegNum, BOOL bSigned, DWORD dwMap) {
    if ((m_dwConstMapping[dwStage][0].dwRegNum == dwRegNum) &&
        (m_dwConstMapping[dwStage][0].dwMap == dwMap) &&
        (m_dwConstMapping[dwStage][0].bSigned == bSigned)) {
        return 0;
    } else if ((m_dwConstMapping[dwStage][1].dwRegNum == dwRegNum) &&
               (m_dwConstMapping[dwStage][1].dwMap == dwMap) &&
               (m_dwConstMapping[dwStage][1].bSigned == bSigned)) {
        return 1;
    } else if (m_dwConstMapping[dwStage][0].dwRegNum == PSHAD_UNUSED) {
        m_dwConstMapping[dwStage][0].dwRegNum = dwRegNum;
        m_dwConstMapping[dwStage][0].dwMap = dwMap;
        m_dwConstMapping[dwStage][0].bSigned = bSigned;
        return 0;
    } else if (m_dwConstMapping[dwStage][1].dwRegNum == PSHAD_UNUSED) {
        m_dwConstMapping[dwStage][1].dwRegNum = dwRegNum;
        m_dwConstMapping[dwStage][1].dwMap = dwMap;
        m_dwConstMapping[dwStage][1].bSigned = bSigned;
        return 1;
    } else {
        // Return error code
        return 0xffffffff;
    }
}

#define Repeat4(f, a, r, g, b) do { f(a); f(r); f(g); f(b); } while(0)

__inline void Clamp0to1(D3DVALUE &x)    { x = (x < 0) ? 0 : (x > 1) ? 1 : x; }
__inline void ClampNeg1to1(D3DVALUE &x) { x = (x < -1) ? -1 : (x > 1) ? 1 : x; }
__inline void Complement(D3DVALUE &x)   { x = 1 - x; }
__inline void Expand(D3DVALUE &x)       { x = (x - 0.5f) * 2; }
__inline void Negate(D3DVALUE &x)       { x = -x; }
__inline void Bias(D3DVALUE &x)         { x = x - 0.5f; }

DWORD CPixelShader::ColorConvertWithMapping(D3DCOLORVALUE c, DWORD dwMod, BOOL *bSigned) {
    Repeat4(ClampNeg1to1, c.a, c.r, c.g, c.b);

    switch (dwMod) {
    case NV_MAPPING_UNSIGNED_IDENTITY:
        Repeat4(Clamp0to1, c.a, c.r, c.g, c.b);
        break;
    case NV_MAPPING_UNSIGNED_INVERT:
        Repeat4(Complement, c.a, c.r, c.g, c.b);
        Repeat4(Clamp0to1, c.a, c.r, c.g, c.b);
        break;
    case NV_MAPPING_EXPAND_NORMAL:
        Repeat4(Expand, c.a, c.r, c.g, c.b);
        Repeat4(ClampNeg1to1, c.a, c.r, c.g, c.b);
        break;
    case NV_MAPPING_EXPAND_NEGATE:
        Repeat4(Expand, c.a, c.r, c.g, c.b);
        Repeat4(Negate, c.a, c.r, c.g, c.b);
        Repeat4(ClampNeg1to1, c.a, c.r, c.g, c.b);
        break;
    case NV_MAPPING_HALF_BIAS_NORMAL:
        Repeat4(Bias, c.a, c.r, c.g, c.b);
        Repeat4(ClampNeg1to1, c.a, c.r, c.g, c.b);
        break;
    case NV_MAPPING_HALF_BIAS_NEGATE:
        Repeat4(Bias, c.a, c.r, c.g, c.b);
        Repeat4(Negate, c.a, c.r, c.g, c.b);
        Repeat4(ClampNeg1to1, c.a, c.r, c.g, c.b);
        break;
    case NV_MAPPING_SIGNED_IDENTITY:
        Repeat4(ClampNeg1to1, c.a, c.r, c.g, c.b);
        break;
    case NV_MAPPING_SIGNED_NEGATE:
        Repeat4(ClampNeg1to1, c.a, c.r, c.g, c.b);
        Repeat4(Negate, c.a, c.r, c.g, c.b);
        break;
    default:
        // Invalid mapping mode!
        nvAssert(0);
    }

    if (*bSigned) {
        return D3DCOLOR_ARGB(
            DWORD(c.a*127.0f + 128.0f),
            DWORD(c.r*127.0f + 128.0f),
            DWORD(c.g*127.0f + 128.0f),
            DWORD(c.b*127.0f + 128.0f));
    } else {
        return D3DCOLOR_ARGB(
            DWORD(c.a*255.0f),
            DWORD(c.r*255.0f),
            DWORD(c.g*255.0f),
            DWORD(c.b*255.0f));
    }
}

///////////////////////////////////////////////////////////////////////
static const char * PSTextureTypes[] = {"<null>", "2D", "3D", "cube map"};

DWORD CPixelShader::GetShaderProgram(PNVD3DCONTEXT pContext, DWORD dwStage) {
    DWORD dwType, dwProgram;

    DWORD dwTexture = pContext->tssState[dwStage].dwValue[D3DTSS_TEXTUREMAP];
    CTexture *pTexture = dwTexture ? ((CNvObject *)dwTexture)->getTexture() : 0;

    dwType = (!pTexture) ? 0 : (pTexture->isCubeMap()) ? 3 : (pTexture->isVolumeMap()) ? 2 : 1;

    dwProgram = (m_shaderStageProgram[dwStage] == PSHAD_UNUSED) ? 
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PROGRAM_NONE : 
        PSD3DTexToNVShader[m_shaderStageProgram[dwStage]][dwType];

    if (dwProgram == ~0) {
        DPF("Using program '%s', but texture is of type '%s' on stage %d", PSInstructionStrings[m_shaderStageProgram[dwStage]+D3DSIO_TEXCOORD], PSTextureTypes[dwType], dwStage);
        dbgD3DError();
        dwProgram = NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PASS_THROUGH;
    }

    return dwProgram;
}


#if (NVARCH >= 0x020)
void CPixelShader::setKelvinState(PNVD3DCONTEXT pContext) {
    DWORD i, j;

    DWORD dwCombinerControl = 0;
    dwCombinerControl |= DRF_NUM(097, _SET_COMBINER_CONTROL, _ITERATION_COUNT, m_dwStage);
    dwCombinerControl |= DRF_DEF(097, _SET_COMBINER_CONTROL, _FACTOR0, _EACH_STAGE);
    dwCombinerControl |= DRF_DEF(097, _SET_COMBINER_CONTROL, _FACTOR1, _EACH_STAGE);
    dwCombinerControl |= DRF_DEF(097, _SET_COMBINER_CONTROL, _MUX_SELECT, _MSB);

    pContext->hwState.kelvin.set1(NV097_SET_COMBINER_CONTROL, dwCombinerControl);


    DWORD dwShaderProgram = 0;

    // Set up the shader programs based on the currently set textures
    // Unfortunately, there are different programs for different types of textures
    dwShaderProgram |= DRF_NUM(097, _SET_SHADER_STAGE_PROGRAM, _STAGE0, GetShaderProgram(pContext, 0));
    dwShaderProgram |= DRF_NUM(097, _SET_SHADER_STAGE_PROGRAM, _STAGE1, GetShaderProgram(pContext, 1));
    dwShaderProgram |= DRF_NUM(097, _SET_SHADER_STAGE_PROGRAM, _STAGE2, GetShaderProgram(pContext, 2));
    dwShaderProgram |= DRF_NUM(097, _SET_SHADER_STAGE_PROGRAM, _STAGE3, GetShaderProgram(pContext, 3));

    pContext->hwState.kelvin.set1(NV097_SET_SHADER_STAGE_PROGRAM, dwShaderProgram);

    // The RGB mapping for each stage is a function of the stage it uses as input, and the texture assigned to the unit.
    DWORD dwRGBMapping = 0;
    DWORD pTextureHandle;
    CTexture *pTexture;

    for (i=1; i<PSHAD_MAX_SHADER_STAGES; i++) {
        nvAssert(m_shaderStageInput[i] < PSHAD_MAX_SHADER_STAGES);

        pTextureHandle = pContext->tssState[m_shaderStageInput[i]].dwValue[D3DTSS_TEXTUREMAP];
        pTexture = pTextureHandle ? (((CNvObject *)pTextureHandle)->getTexture()) : 0;

//        nvAssert(!pTexture || (GetRGBMapping(pTexture) == NV097_SET_DOT_RGBMAPPING_STAGE1_ZERO_TO_1) || (m_shaderStageInputMapping[i] == D3DSPSM_NONE));

        dwRGBMapping |= (m_shaderStageInputMapping[i] == D3DSPSM_SIGN) ?
            (DRF_DEF(097, _SET_DOT_RGBMAPPING, _STAGE1, _MINUS_1_TO_1_MS) << (4*(i-1))) :
            pTexture ? 
                (DRF_NUM(097, _SET_DOT_RGBMAPPING, _STAGE1, GetRGBMapping(pTexture)) << (4*(i-1))) : 
                0;
    }

    pContext->hwState.kelvin.set1 (NV097_SET_DOT_RGBMAPPING, dwRGBMapping);


    // Set input stages
    pContext->hwState.kelvin.set1(NV097_SET_SHADER_OTHER_STAGE_INPUT,
                                 (DRF_NUM(097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE1, m_shaderStageInput[1]) |
                                  DRF_NUM(097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE2, m_shaderStageInput[2]) |
                                  DRF_NUM(097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE3, m_shaderStageInput[3])));

#define NV097_SET_COMBINER_FACTOR(stage, num) (NV097_SET_COMBINER_FACTOR0(stage) + ((NV097_SET_COMBINER_FACTOR1(0) - NV097_SET_COMBINER_FACTOR0(0)) * num))

    // Program the constants, based on the mapping table we generated
    for (i=0; i<PSHAD_MAX_COMBINER_STAGES; i++) {
        for (j=0; j<2; j++) {
            DWORD dwRegNum = m_dwConstMapping[i][j].dwRegNum;
            if (dwRegNum != PSHAD_UNUSED) {
                DWORD dwMap = m_dwConstMapping[i][j].dwMap;
                BOOL bSigned = m_dwConstMapping[i][j].bSigned;
                DWORD dwColor;

                if (m_dwPixelShaderConstFlags[dwRegNum] & PSHAD_CONST_LOCAL) {
                    dwColor = ColorConvertWithMapping(m_pixelShaderConsts[dwRegNum], dwMap, &bSigned);
                } else {
                    dwColor = ColorConvertWithMapping(pContext->pixelShaderConsts[dwRegNum], dwMap, &bSigned);
                }

                pContext->hwState.kelvin.set1(NV097_SET_COMBINER_FACTOR(i, j), dwColor);
            }
        }
    }


    // Set eye vector, which happens to be hard-coded to c0 in D3D
    D3DCOLORVALUE eye = 
        (m_dwPixelShaderConstFlags[0] & PSHAD_CONST_LOCAL) ?
        m_pixelShaderConsts[0] :
        pContext->pixelShaderConsts[0];

    pContext->hwState.kelvin.set3f(NV097_SET_EYE_VECTOR(0), eye.r, eye.g, eye.b);

    // Program up the combiners
    for (i=0; i<m_dwStage; i++) {
        pContext->hwState.kelvin.set1(NV097_SET_COMBINER_COLOR_ICW(i), m_cw[i][PSHAD_COLOR][PSHAD_ICW]);
        pContext->hwState.kelvin.set1(NV097_SET_COMBINER_COLOR_OCW(i), m_cw[i][PSHAD_COLOR][PSHAD_OCW]);
        pContext->hwState.kelvin.set1(NV097_SET_COMBINER_ALPHA_ICW(i), m_cw[i][PSHAD_ALPHA][PSHAD_ICW]);
        pContext->hwState.kelvin.set1(NV097_SET_COMBINER_ALPHA_OCW(i), m_cw[i][PSHAD_ALPHA][PSHAD_OCW]);
    }

    for (i=0; i<PSHAD_MAX_SHADER_STAGES; i++) {
        if (m_shaderStageProgram[i] == PSHAD_UNUSED) {
            pContext->hwState.dwStateFlags &= ~KELVIN_FLAG_USERTEXCOORDSNEEDED(i);
            pContext->hwState.dwTexUnitToTexStageMapping[i] = KELVIN_UNUSED;
            pContext->hwState.dwTextureUnitStatus[i] = KELVIN_TEXUNITSTATUS_IDLE;
            pContext->hwState.pTextureInUse[i]     = NULL;
        } else {
            pContext->hwState.dwStateFlags |= KELVIN_FLAG_USERTEXCOORDSNEEDED(i);
            pContext->hwState.dwTexUnitToTexStageMapping[i] = i;
            pContext->hwState.dwTextureUnitStatus[i] = KELVIN_TEXUNITSTATUS_USER;

            if (!PSShaderUsesTexture[m_shaderStageProgram[i]]) {
                pContext->hwState.pTextureInUse[i]     = NULL;
            }
        }
    }

    // Optimize this later
    pContext->hwState.dwStateFlags |= KELVIN_FLAG_COMBINERSNEEDSPECULAR;
}
#endif


#if (NVARCH >= 0x010)
void CPixelShader::setCelsiusState(PNVD3DCONTEXT pContext) {

    pContext->hwState.celsius.set (NV056_SET_COMBINER_COLOR_ICW(0), m_cw[0][PSHAD_COLOR][PSHAD_ICW]);
    pContext->hwState.celsius.set (NV056_SET_COMBINER0_COLOR_OCW,   m_cw[0][PSHAD_COLOR][PSHAD_OCW]);
    pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_ICW(0), m_cw[0][PSHAD_ALPHA][PSHAD_ICW]);
    pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_OCW(0), m_cw[0][PSHAD_ALPHA][PSHAD_OCW]);

    pContext->hwState.celsius.set (NV056_SET_COMBINER_COLOR_ICW(1), m_cw[1][PSHAD_COLOR][PSHAD_ICW]);
    pContext->hwState.celsius.set (NV056_SET_COMBINER1_COLOR_OCW,   m_cw[1][PSHAD_COLOR][PSHAD_OCW] | DRF_NUM(056, _SET_COMBINER1_COLOR, _OCW_ITERATION_COUNT, m_dwStage));
    pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_ICW(1), m_cw[1][PSHAD_ALPHA][PSHAD_ICW]);
    pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_OCW(1), m_cw[1][PSHAD_ALPHA][PSHAD_OCW]);

    // We use the specular color in the general sense, as a simple secondary color.
    pContext->hwState.celsius.set (NV056_SET_SPECULAR_ENABLE, DRF_NUM(056, _SET_SPECULAR_ENABLE, _V, TRUE));
    pContext->hwState.dwStateFlags |= CELSIUS_FLAG_COMBINERSNEEDSPECULAR;

    // Change the texture stage mapping
    DWORD unit = 0;
    for (DWORD i = 0; i < 2; i++) {
        pContext->hwState.dwTexUnitToTexStageMapping[i] = CELSIUS_UNUSED;

        for (DWORD j=0; j<PSHAD_MAX_SHADER_STAGES; j++) {
            if (i == m_celsiusTexStageMapping[j]) {
                pContext->hwState.dwTexUnitToTexStageMapping[i] = j;
            }
        }
    }

    // Program the constants, based on the mapping table we generated
    // Note that Celsius combiners have a common constant table, so we only use the
    // '0' row of the table.
    for (i=0; i<2; i++) {
        DWORD dwRegNum = m_dwConstMapping[0][i].dwRegNum;
        if (dwRegNum != PSHAD_UNUSED) {
            DWORD dwMap = m_dwConstMapping[0][i].dwMap;
            BOOL bSigned = m_dwConstMapping[0][i].bSigned;
            DWORD dwColor;

            if (m_dwPixelShaderConstFlags[dwRegNum] & PSHAD_CONST_LOCAL) {
                dwColor = ColorConvertWithMapping(m_pixelShaderConsts[dwRegNum], dwMap, &bSigned);
            } else {
                dwColor = ColorConvertWithMapping(pContext->pixelShaderConsts[dwRegNum], dwMap, &bSigned);
            }

            pContext->hwState.kelvin.set1(NV056_SET_COMBINE_FACTOR(i), dwColor);
        }
    }
}
#endif

///////////////////////////////////////////////////////////////////////

DWORD CPixelShader::isBEM(DWORD dwStage) {
    nvAssert(dwStage < PSHAD_MAX_SHADER_STAGES);

    DWORD dwInput = m_shaderStageInputInverse[dwStage];

    return (dwInput == PSHAD_UNUSED) ?
        FALSE :
        ((m_shaderStageProgram[dwInput] == (D3DSIO_TEXBEM-D3DSIO_TEXCOORD)) ||
         (m_shaderStageProgram[dwInput] == (D3DSIO_TEXBEML-D3DSIO_TEXCOORD)));
}

DWORD CPixelShader::isBEML(DWORD dwStage) {
    nvAssert(dwStage < PSHAD_MAX_SHADER_STAGES);

    DWORD dwInput = m_shaderStageInputInverse[dwStage];

    return (dwInput == PSHAD_UNUSED) ?
        FALSE :
        (m_shaderStageProgram[dwInput] == (D3DSIO_TEXBEML-D3DSIO_TEXCOORD));
}

DWORD CPixelShader::GetRGBMapping(const CTexture *pTexture) {
    return (pTexture->getFormat() == NV_SURFACE_FORMAT_HILO_HEMI_V16U16) ?
                NV097_SET_DOT_RGBMAPPING_STAGE1_HILO_HEMISPHERE_NV :
                (pTexture->getFormat() == NV_SURFACE_FORMAT_HILO_1_V16U16) ?
                    NV097_SET_DOT_RGBMAPPING_STAGE1_HILO_1 :
                    (pTexture->getFourCC() == D3DFMT_Q8W8V8U8) ?
                        NV097_SET_DOT_RGBMAPPING_STAGE1_MINUS_1_TO_1_NV :
                        NV097_SET_DOT_RGBMAPPING_STAGE1_ZERO_TO_1;
}

DWORD CPixelShader::getNumTexCoords(PNVD3DCONTEXT pContext, DWORD dwStage) {
    CTexture *pTexture = (pContext->tssState[dwStage].dwValue[D3DTSS_TEXTUREMAP]) ? 
        ((CNvObject *)(pContext->tssState[dwStage].dwValue[D3DTSS_TEXTUREMAP]))->getTexture() : 
        0;

    if (pTexture && PSIsProjective[GetShaderProgram(pContext, dwStage)]) {
        return pTexture->getNumTexCoords();
    } else {
        // we may need all 4 coords
        return 4;
    }
}

bool CPixelShader::stageUsesTexture(DWORD dwStage) {
    if (m_shaderStageProgram[dwStage] == PSHAD_UNUSED) {
        return false;
    } else {
        nvAssert(m_shaderStageProgram[dwStage] <= (D3DSIO_TEXM3x3VSPEC-D3DSIO_TEXCOORD));

        return PSShaderUsesTexture[m_shaderStageProgram[dwStage]];
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvStateSet.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvStateSet.cpp                                                    *
*   Functions called to manage DP2 statesets                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler         26Jan99           created                  *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"


#if (NVARCH >= 0x04)

//---------------------------------------------------------------------------

// grow the stateset to at least the size specified

HRESULT growStateSetData (PNVD3DCONTEXT pContext, DWORD dwHandle, DWORD desiredSize)
{
    STATESET *pss;
    DWORD newSize;
    LPBYTE pNewData;

    pss = pContext->pStateSets + dwHandle;

    newSize = pss->allocatedSize;
    while (newSize < desiredSize) newSize += INCREMENTAL_STATESET_SIZE;

    pNewData = (LPBYTE) new BYTE[newSize];
    if (pNewData == NULL) {
        DPF ("Could not allocate more memory for stateset data");
        return (DDERR_OUTOFMEMORY);
    }   

    // transfer data
    pss->allocatedSize = newSize;
    nvMemCopy (pNewData, pss->pData, pss->dataSize);
    delete []pss->pData;
    pss->pData = pNewData;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordState (PNVD3DCONTEXT pContext, LPBYTE pData, DWORD dwSize)
{
    DWORD     dwHandle;
    STATESET *pss;
    int       newSize;
    LPBYTE    pDest;
    HRESULT   ret;

    dwHandle = pContext->dwCurrentStateSet;
    pss      = pContext->pStateSets + dwHandle;
    assert (pss != NULL);

    newSize = pss->dataSize + dwSize;
    if (newSize > pss->allocatedSize) {
        ret = growStateSetData (pContext, dwHandle, newSize);
        if (ret != D3D_OK) return (ret);
    }

    // copy the data and update the ptr.
    pDest = pss->pData + pss->dataSize;
    nvMemCopy(pDest, pData, dwSize);
    pss->dataSize = newSize;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordLastStateOnly (PNVD3DCONTEXT pContext, LPD3DHAL_DP2COMMAND pCmd, DWORD dwUnitSize)
{
    WORD    wStateCount;
    LPBYTE  pSrc;
    HRESULT ret;

    wStateCount = pCmd->wStateCount;
    assert (wStateCount > 0);

    if (wStateCount == 1) {
        // record the command and the single state
        return (recordState (pContext, (LPBYTE)pCmd, sizeof(D3DHAL_DP2COMMAND)+dwUnitSize));
    }

    else {
        pCmd->wStateCount = 1;

        // record the command itself
        ret = recordState (pContext, (LPBYTE)pCmd, sizeof(D3DHAL_DP2COMMAND));
        if (ret != D3D_OK) return (ret);

        // get the last piece of state
        pSrc = (LPBYTE)(pCmd+1) + dwUnitSize*(wStateCount-1);
        ret = recordState (pContext, pSrc, dwUnitSize);
        if (ret != D3D_OK) return (ret);

        pCmd->wStateCount = wStateCount;
        return (D3D_OK);
    }
}

//---------------------------------------------------------------------------

#ifdef DEBUG
static DWORD dwStateSetSerial[2] = { 0xabcd1234, 0};
void recordDebugMarker (PNVD3DCONTEXT pContext)
{
    dwStateSetSerial[1]++;
    recordState (pContext, (BYTE*)dwStateSetSerial, sizeof(dwStateSetSerial));
    DPF_LEVEL (NVDBG_LEVEL_INFO,"Recording StateSet Serial %d",dwStateSetSerial[1]);
}
#endif

//---------------------------------------------------------------------------

HRESULT recordRenderStates (PNVD3DCONTEXT pContext, D3DRENDERSTATETYPE rstates[], DWORD dwNumStates)
{
    DWORD                  dwDataSize;
    DWORD                  i;
    LPBYTE                 pData;
    LPD3DHAL_DP2COMMAND    pCmd;
    D3DHAL_DP2RENDERSTATE* pRS;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + (sizeof(D3DHAL_DP2RENDERSTATE) * dwNumStates);
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = dwNumStates;
    pCmd->bCommand        = D3DDP2OP_RENDERSTATE;

    pRS = (D3DHAL_DP2RENDERSTATE*)(pCmd+1);
    for (i=0; i<dwNumStates; i++) {
        pRS->RenderState = rstates[i];
        pRS->dwState = pContext->dwRenderState[rstates[i]];
        pRS++;
    }

    recordState (pContext, pData, dwDataSize);
    recordDebugMarker (pContext);

    delete []pData;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordTextureStageStates (PNVD3DCONTEXT pContext, D3DTEXTURESTAGESTATETYPE tsstates[], DWORD dwNumStates)
{
    DWORD                        dwDataSize;
    DWORD                        i, j;
    LPBYTE                       pData;
    LPD3DHAL_DP2COMMAND          pCmd;
    D3DHAL_DP2TEXTURESTAGESTATE* pTSS;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + (sizeof(D3DHAL_DP2TEXTURESTAGESTATE) * dwNumStates * D3DHAL_TSS_MAXSTAGES);
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = dwNumStates * D3DHAL_TSS_MAXSTAGES;
    pCmd->bCommand        = D3DDP2OP_TEXTURESTAGESTATE;

    pTSS = (D3DHAL_DP2TEXTURESTAGESTATE*)(pCmd+1);
    for (i=0; i<D3DHAL_TSS_MAXSTAGES; i++) {
        for (j=0; j<dwNumStates; j++) {
            pTSS->wStage  = i;
            pTSS->TSState = tsstates[j];
            pTSS->dwValue = pContext->tssState[i].dwValue[tsstates[j]];
            pTSS++;
        }
    }

    recordState (pContext, pData, dwDataSize);
    recordDebugMarker (pContext);

    delete []pData;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordViewport (PNVD3DCONTEXT pContext)
{
    DWORD                   dwDataSize;
    LPBYTE                  pData;
    LPD3DHAL_DP2COMMAND     pCmd;
    D3DHAL_DP2VIEWPORTINFO* pVP;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2VIEWPORTINFO);
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_VIEWPORTINFO;

    pVP = (D3DHAL_DP2VIEWPORTINFO*)(pCmd+1);
    pVP->dwX      = pContext->surfaceViewport.clipHorizontal.wX;
    pVP->dwY      = pContext->surfaceViewport.clipVertical.wY;
    pVP->dwWidth  = pContext->surfaceViewport.clipHorizontal.wWidth;
    pVP->dwHeight = pContext->surfaceViewport.clipVertical.wHeight;

    recordState (pContext, pData, dwDataSize);
    recordDebugMarker (pContext);

    delete []pData;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2ZRANGE);
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_ZRANGE;

    D3DHAL_DP2ZRANGE* pZR = (D3DHAL_DP2ZRANGE*)(pCmd+1);
    pZR->dvMinZ = pContext->surfaceViewport.dvMinZ;
    pZR->dvMaxZ = pContext->surfaceViewport.dvMaxZ;

    recordState (pContext, pData, dwDataSize);
    recordDebugMarker (pContext);

    delete []pData;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordTransforms (PNVD3DCONTEXT pContext)
{
    DWORD                   dwDataSize;
    DWORD                   i;
    LPBYTE                  pData;
    LPD3DHAL_DP2COMMAND     pCmd;
    D3DHAL_DP2SETTRANSFORM* pST;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + (sizeof(D3DHAL_DP2SETTRANSFORM) * (NV_CAPS_MAX_MATRICES + D3DHAL_TSS_MAXSTAGES + 2));
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = NV_CAPS_MAX_MATRICES + D3DHAL_TSS_MAXSTAGES + 2;
    pCmd->bCommand        = D3DDP2OP_SETTRANSFORM;

    pST = (D3DHAL_DP2SETTRANSFORM*)(pCmd+1);
    // world
    for (i=0; i<NV_CAPS_MAX_MATRICES; i++) {
        pST->xfrmType = D3DTS_WORLDMATRIX(i);;
        pST->matrix = pContext->xfmWorld[i];
        pST++;
    }
    // view
    pST->xfrmType = D3DTRANSFORMSTATE_VIEW;
    pST->matrix = pContext->xfmView;
    pST++;
    // projection
    pST->xfrmType = D3DTRANSFORMSTATE_PROJECTION;
    pST->matrix = pContext->xfmProj;
    pST++;
    // texture
    for (i=0; i<D3DHAL_TSS_MAXSTAGES; i++) {
        pST->xfrmType = (D3DTRANSFORMSTATETYPE)(D3DTRANSFORMSTATE_TEXTURE0 + i);
        pST->matrix = pContext->tssState[i].mTexTransformMatrix;
        pST++;
    }

    recordState (pContext, pData, dwDataSize);
    recordDebugMarker (pContext);

    delete []pData;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordClipPlanes (PNVD3DCONTEXT pContext)
{
    DWORD                   dwDataSize;
    DWORD                   i, j;
    LPBYTE                  pData;
    LPD3DHAL_DP2COMMAND     pCmd;
    D3DHAL_DP2SETCLIPPLANE* pSCP;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETCLIPPLANE) * NV_CAPS_MAX_CLIPPLANES;
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = NV_CAPS_MAX_CLIPPLANES;
    pCmd->bCommand        = D3DDP2OP_SETCLIPPLANE;

    pSCP = (D3DHAL_DP2SETCLIPPLANE*)(pCmd+1);
    for (i=0; i<NV_CAPS_MAX_CLIPPLANES; i++) {
        pSCP->dwIndex = i;
        for (j=0; j<4; j++) {
            pSCP->plane[j] = pContext->ppClipPlane[i][j];
        }
        pSCP++;
    }

    recordState (pContext, pData, dwDataSize);
    recordDebugMarker (pContext);

    delete []pData;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordMaterial (PNVD3DCONTEXT pContext)
{
    DWORD                  dwDataSize;
    LPBYTE                 pData;
    LPD3DHAL_DP2COMMAND    pCmd;
    D3DHAL_DP2SETMATERIAL* pSM;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETMATERIAL);
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETMATERIAL;

    pSM = (D3DHAL_DP2SETMATERIAL*)(pCmd+1);
    *pSM = pContext->Material;

    recordState (pContext, pData, dwDataSize);
    recordDebugMarker (pContext);

    delete []pData;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordLights (PNVD3DCONTEXT pContext)
{
    DWORD               dwDataSize;
    DWORD               i;
    LPBYTE              pData;
    LPD3DHAL_DP2COMMAND pCmd;
    D3DHAL_DP2SETLIGHT* pSLEnable;
    D3DHAL_DP2SETLIGHT* pSLData;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DLIGHT7) + 2*sizeof(D3DHAL_DP2SETLIGHT);
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = 2;
    pCmd->bCommand = D3DDP2OP_SETLIGHT;

    pSLEnable = (D3DHAL_DP2SETLIGHT *)(pCmd + 1);
    pSLData   = pSLEnable + 1;
    pSLData->dwDataType = D3DHAL_SETLIGHT_DATA;

    for (i=0; i<pContext->dwLightArraySize; i++) {
        if (nvLightIsDefined(&(pContext->pLightArray[i]))) {
            pSLEnable->dwIndex = pSLData->dwIndex = i;
            pSLEnable->dwDataType = (nvLightIsEnabled(&(pContext->pLightArray[i]))) ?
                                    D3DHAL_SETLIGHT_ENABLE :
                                    D3DHAL_SETLIGHT_DISABLE;
            *((D3DLIGHT7*)(pSLData + 1)) = pContext->pLightArray[i].Light7;
            recordState (pContext, pData, dwDataSize);
            recordDebugMarker (pContext);
        }
    }

    delete []pData;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordVShader (PNVD3DCONTEXT pContext)
{
    DWORD                           dwDataSize;
    LPBYTE                          pData;
    LPD3DHAL_DP2COMMAND             pCmd;
    D3DHAL_DP2VERTEXSHADER*         pVS;
    D3DHAL_DP2SETVERTEXSHADERCONST* pVSC;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2VERTEXSHADER);
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETVERTEXSHADER;

    pVS = (D3DHAL_DP2VERTEXSHADER*)(pCmd+1);
    pVS->dwHandle = pContext->pCurrentVShader->isFvfShader() ?
        pContext->pCurrentVShader->getFVF():
        pContext->pCurrentVShader->getHandle();

    recordState (pContext, pData, dwDataSize);
    recordDebugMarker (pContext);

    delete []pData;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETVERTEXSHADERCONST) + (NV_CAPS_MAX_VSHADER_CONSTS << 4);
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETVERTEXSHADERCONST;

    pVSC = (D3DHAL_DP2SETVERTEXSHADERCONST*)(pCmd+1);
    pVSC->dwRegister = 0;
    pVSC->dwCount    = NV_CAPS_MAX_VSHADER_CONSTS;
    nvAssert(pContext->pVShaderConsts);
    nvMemCopy ((DWORD)(pVSC+1), (DWORD)(&(pContext->pVShaderConsts->vertexShaderConstants[0])), (NV_CAPS_MAX_VSHADER_CONSTS << 4));

    recordState (pContext, pData, dwDataSize);
    recordDebugMarker (pContext);

    delete []pData;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordPShader (PNVD3DCONTEXT pContext)
{
    DWORD                          dwDataSize;
    DWORD                          i;
    LPBYTE                         pData;
    LPD3DHAL_DP2COMMAND            pCmd;
    D3DHAL_DP2PIXELSHADER*         pPS;
    D3DHAL_DP2SETPIXELSHADERCONST* pPSC;
    D3DVALUE*                      pfData;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2PIXELSHADER);
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETPIXELSHADER;

    pPS = (D3DHAL_DP2PIXELSHADER*)(pCmd+1);
    pPS->dwHandle = pContext->pCurrentPShader ? pContext->pCurrentPShader->getHandle() : 0;

    recordState (pContext, pData, dwDataSize);
    recordDebugMarker (pContext);

    delete []pData;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETPIXELSHADERCONST) + (NV_CAPS_MAX_PSHADER_CONSTS << 4);
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETPIXELSHADERCONST;

    pPSC = (D3DHAL_DP2SETPIXELSHADERCONST*)(pCmd+1);
    pPSC->dwRegister = 0;
    pPSC->dwCount    = NV_CAPS_MAX_PSHADER_CONSTS;
    pfData = (D3DVALUE*)(pPSC+1);
    for (i=0; i<NV_CAPS_MAX_PSHADER_CONSTS; i++) {
        *(pfData+0) = pContext->pixelShaderConsts[i].dvA;
        *(pfData+1) = pContext->pixelShaderConsts[i].dvR;
        *(pfData+2) = pContext->pixelShaderConsts[i].dvG;
        *(pfData+3) = pContext->pixelShaderConsts[i].dvB;
        pfData += 4;
    }

    recordState (pContext, pData, dwDataSize);
    recordDebugMarker (pContext);

    delete []pData;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordAllState (PNVD3DCONTEXT pContext)
{
    static D3DRENDERSTATETYPE rstates[] =
    {
        D3DRENDERSTATE_SPECULARENABLE,
        D3DRENDERSTATE_ZENABLE,
        D3DRENDERSTATE_FILLMODE,
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_LINEPATTERN,
        D3DRENDERSTATE_ZWRITEENABLE,
        D3DRENDERSTATE_ALPHATESTENABLE,
        D3DRENDERSTATE_LASTPIXEL,
        D3DRENDERSTATE_SRCBLEND,
        D3DRENDERSTATE_DESTBLEND,
        D3DRENDERSTATE_CULLMODE,
        D3DRENDERSTATE_ZFUNC,
        D3DRENDERSTATE_ALPHAREF,
        D3DRENDERSTATE_ALPHAFUNC,
        D3DRENDERSTATE_DITHERENABLE,
        D3DRENDERSTATE_FOGENABLE,
        D3DRENDERSTATE_STIPPLEDALPHA,
        D3DRENDERSTATE_FOGCOLOR,
        D3DRENDERSTATE_FOGTABLEMODE,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_EDGEANTIALIAS,
        D3DRENDERSTATE_ALPHABLENDENABLE,
        D3DRENDERSTATE_ZBIAS,
        D3DRENDERSTATE_RANGEFOGENABLE,
        D3DRENDERSTATE_STENCILENABLE,
        D3DRENDERSTATE_STENCILFAIL,
        D3DRENDERSTATE_STENCILZFAIL,
        D3DRENDERSTATE_STENCILPASS,
        D3DRENDERSTATE_STENCILFUNC,
        D3DRENDERSTATE_STENCILREF,
        D3DRENDERSTATE_STENCILMASK,
        D3DRENDERSTATE_STENCILWRITEMASK,
        D3DRENDERSTATE_TEXTUREFACTOR,
        D3DRENDERSTATE_WRAP0,
        D3DRENDERSTATE_WRAP1,
        D3DRENDERSTATE_WRAP2,
        D3DRENDERSTATE_WRAP3,
        D3DRENDERSTATE_WRAP4,
        D3DRENDERSTATE_WRAP5,
        D3DRENDERSTATE_WRAP6,
        D3DRENDERSTATE_WRAP7,
        D3DRENDERSTATE_AMBIENT,
        D3DRENDERSTATE_COLORVERTEX,
        D3DRENDERSTATE_FOGVERTEXMODE,
        D3DRENDERSTATE_CLIPPING,
        D3DRENDERSTATE_LIGHTING,
        D3DRENDERSTATE_NORMALIZENORMALS,
        D3DRENDERSTATE_LOCALVIEWER,
        D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
        D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
        D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
        D3DRENDERSTATE_SPECULARMATERIALSOURCE,
        D3DRENDERSTATE_VERTEXBLEND,
        D3DRENDERSTATE_CLIPPLANEENABLE,
        D3DRS_SOFTWAREVERTEXPROCESSING,
        D3DRS_POINTSIZE,
        D3DRS_POINTSIZE_MIN,
        D3DRS_POINTSPRITEENABLE,
        D3DRS_POINTSCALEENABLE,
        D3DRS_POINTSCALE_A,
        D3DRS_POINTSCALE_B,
        D3DRS_POINTSCALE_C,
        D3DRS_MULTISAMPLEANTIALIAS,
        D3DRS_MULTISAMPLEMASK,
        D3DRS_PATCHEDGESTYLE,
        D3DRS_PATCHSEGMENTS,
        D3DRS_POINTSIZE_MAX,
        D3DRS_INDEXEDVERTEXBLENDENABLE,
        D3DRS_COLORWRITEENABLE,
        D3DRS_TWEENFACTOR,
        D3DRS_BLENDOP,
    };
    static D3DTEXTURESTAGESTATETYPE tsstates[] =
    {
        D3DTSS_COLOROP,
        D3DTSS_COLORARG1,
        D3DTSS_COLORARG2,
        D3DTSS_ALPHAOP,
        D3DTSS_ALPHAARG1,
        D3DTSS_ALPHAARG2,
        D3DTSS_BUMPENVMAT00,
        D3DTSS_BUMPENVMAT01,
        D3DTSS_BUMPENVMAT10,
        D3DTSS_BUMPENVMAT11,
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_ADDRESSU,
        D3DTSS_ADDRESSV,
        D3DTSS_BORDERCOLOR,
        D3DTSS_MAGFILTER,
        D3DTSS_MINFILTER,
        D3DTSS_MIPFILTER,
        D3DTSS_MIPMAPLODBIAS,
        D3DTSS_MAXMIPLEVEL,
        D3DTSS_MAXANISOTROPY,
        D3DTSS_BUMPENVLSCALE,
        D3DTSS_BUMPENVLOFFSET,
        D3DTSS_TEXTURETRANSFORMFLAGS,
        D3DTSS_ADDRESSW,
        D3DTSS_COLORARG0,
        D3DTSS_ALPHAARG0,
        D3DTSS_RESULTARG,
    };

    recordRenderStates       (pContext, rstates, sizeof(rstates) / sizeof(D3DRENDERSTATETYPE));
    recordTextureStageStates (pContext, tsstates, sizeof(tsstates) / sizeof(D3DTEXTURESTAGESTATETYPE));
    recordViewport           (pContext);
    recordTransforms         (pContext);
    recordClipPlanes         (pContext);
    recordMaterial           (pContext);
    recordLights             (pContext);
    recordVShader            (pContext);
    recordPShader            (pContext);

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordPixelState (PNVD3DCONTEXT pContext)
{
    static D3DRENDERSTATETYPE rstates[] =
    {
        D3DRENDERSTATE_ZENABLE,
        D3DRENDERSTATE_FILLMODE,
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_LINEPATTERN,
        D3DRENDERSTATE_ZWRITEENABLE,
        D3DRENDERSTATE_ALPHATESTENABLE,
        D3DRENDERSTATE_LASTPIXEL,
        D3DRENDERSTATE_SRCBLEND,
        D3DRENDERSTATE_DESTBLEND,
        D3DRENDERSTATE_ZFUNC,
        D3DRENDERSTATE_ALPHAREF,
        D3DRENDERSTATE_ALPHAFUNC,
        D3DRENDERSTATE_DITHERENABLE,
        D3DRENDERSTATE_STIPPLEDALPHA,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_EDGEANTIALIAS,
        D3DRENDERSTATE_ALPHABLENDENABLE,
        D3DRENDERSTATE_ZBIAS,
        D3DRENDERSTATE_STENCILENABLE,
        D3DRENDERSTATE_STENCILFAIL,
        D3DRENDERSTATE_STENCILZFAIL,
        D3DRENDERSTATE_STENCILPASS,
        D3DRENDERSTATE_STENCILFUNC,
        D3DRENDERSTATE_STENCILREF,
        D3DRENDERSTATE_STENCILMASK,
        D3DRENDERSTATE_STENCILWRITEMASK,
        D3DRENDERSTATE_TEXTUREFACTOR,
        D3DRENDERSTATE_WRAP0,
        D3DRENDERSTATE_WRAP1,
        D3DRENDERSTATE_WRAP2,
        D3DRENDERSTATE_WRAP3,
        D3DRENDERSTATE_WRAP4,
        D3DRENDERSTATE_WRAP5,
        D3DRENDERSTATE_WRAP6,
        D3DRENDERSTATE_WRAP7,
        D3DRS_COLORWRITEENABLE,
        D3DRS_BLENDOP,
    };
    static D3DTEXTURESTAGESTATETYPE tsstates[] =
    {
        D3DTSS_COLOROP,
        D3DTSS_COLORARG1,
        D3DTSS_COLORARG2,
        D3DTSS_ALPHAOP,
        D3DTSS_ALPHAARG1,
        D3DTSS_ALPHAARG2,
        D3DTSS_BUMPENVMAT00,
        D3DTSS_BUMPENVMAT01,
        D3DTSS_BUMPENVMAT10,
        D3DTSS_BUMPENVMAT11,
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_ADDRESSU,
        D3DTSS_ADDRESSV,
        D3DTSS_BORDERCOLOR,
        D3DTSS_MAGFILTER,
        D3DTSS_MINFILTER,
        D3DTSS_MIPFILTER,
        D3DTSS_MIPMAPLODBIAS,
        D3DTSS_MAXMIPLEVEL,
        D3DTSS_MAXANISOTROPY,
        D3DTSS_BUMPENVLSCALE,
        D3DTSS_BUMPENVLOFFSET,
        D3DTSS_TEXTURETRANSFORMFLAGS,
        D3DTSS_ADDRESSW,
        D3DTSS_COLORARG0,
        D3DTSS_ALPHAARG0,
        D3DTSS_RESULTARG,
    };

    recordRenderStates       (pContext, rstates, sizeof(rstates) / sizeof(D3DRENDERSTATETYPE));
    recordTextureStageStates (pContext, tsstates, sizeof(tsstates) / sizeof(D3DTEXTURESTAGESTATETYPE));
    recordPShader            (pContext);

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordVertexState (PNVD3DCONTEXT pContext)
{
    static D3DRENDERSTATETYPE rstates[] =
    {
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_SPECULARENABLE,
        D3DRENDERSTATE_CULLMODE,
        D3DRENDERSTATE_FOGENABLE,
        D3DRENDERSTATE_FOGCOLOR,
        D3DRENDERSTATE_FOGTABLEMODE,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_RANGEFOGENABLE,
        D3DRENDERSTATE_AMBIENT,
        D3DRENDERSTATE_COLORVERTEX,
        D3DRENDERSTATE_FOGVERTEXMODE,
        D3DRENDERSTATE_CLIPPING,
        D3DRENDERSTATE_LIGHTING,
        D3DRENDERSTATE_NORMALIZENORMALS,
        D3DRENDERSTATE_LOCALVIEWER,
        D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
        D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
        D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
        D3DRENDERSTATE_SPECULARMATERIALSOURCE,
        D3DRENDERSTATE_VERTEXBLEND,
        D3DRENDERSTATE_CLIPPLANEENABLE,
        D3DRS_SOFTWAREVERTEXPROCESSING,
        D3DRS_POINTSIZE,
        D3DRS_POINTSIZE_MIN,
        D3DRS_POINTSPRITEENABLE,
        D3DRS_POINTSCALEENABLE,
        D3DRS_POINTSCALE_A,
        D3DRS_POINTSCALE_B,
        D3DRS_POINTSCALE_C,
        D3DRS_MULTISAMPLEANTIALIAS,
        D3DRS_MULTISAMPLEMASK,
        D3DRS_PATCHEDGESTYLE,
        D3DRS_PATCHSEGMENTS,
        D3DRS_POINTSIZE_MAX,
        D3DRS_INDEXEDVERTEXBLENDENABLE,
        D3DRS_TWEENFACTOR,
    };
    static D3DTEXTURESTAGESTATETYPE tsstates[] =
    {
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_TEXTURETRANSFORMFLAGS
    };

    recordRenderStates       (pContext, rstates, sizeof(rstates) / sizeof(D3DRENDERSTATETYPE));
    recordTextureStageStates (pContext, tsstates, sizeof(tsstates) / sizeof(D3DTEXTURESTAGESTATETYPE));
    recordLights             (pContext);
    recordVShader            (pContext);

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT stateSetBegin (PNVD3DCONTEXT pContext, DWORD dwHandle)
{
    STATESET *pss;

    // grow state set handle list if the given one exceeds our maximum
    if (dwHandle >= pContext->dwMaxStateSetHandles)
    {
        // grow
        DWORD     dwCount = (dwHandle + 1 + 15) & ~15;
        STATESET *pNew    = (STATESET*)AllocIPM(sizeof(STATESET) * dwCount);
        if (!pNew) {
            DPF ("stateSetBegin: out of memory to allow more handles");
            dbgD3DError();
            return (DDERR_GENERIC);
        }
        if (pContext->pStateSets) {
            nvMemCopy (pNew,pContext->pStateSets,sizeof(STATESET) * pContext->dwMaxStateSetHandles);
        }
        memset (pNew + pContext->dwMaxStateSetHandles, 0,sizeof(STATESET) * (dwCount - pContext->dwMaxStateSetHandles));
        if (pContext->pStateSets) {
            FreeIPM (pContext->pStateSets);
        }
        pContext->pStateSets           = pNew;
        pContext->dwMaxStateSetHandles = dwCount;
    }

    // get the pointer to the stateset
    pss = pContext->pStateSets + dwHandle;
    if (pss == NULL) {
        DPF ("Could not allocate memory for stateset");
        return (DDERR_OUTOFMEMORY);
    }

    // allocate memory for the data
    pss->pData = (LPBYTE) new BYTE[DEFAULT_STATESET_SIZE];
    if (pss->pData == NULL) {
        DPF ("Could not allocate memory for stateset data");
        return (DDERR_OUTOFMEMORY);
    }

    // initialize contents
    pss->allocatedSize = DEFAULT_STATESET_SIZE;
    pss->dataSize = 0;

    // store current stateset
    pContext->dwCurrentStateSet = dwHandle;

    // switch to record mode
    pContext->pDP2FunctionTable = &nvDP2RecordFuncs;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT stateSetEnd (PNVD3DCONTEXT pContext)
{
    // switch to execute mode
    pContext->pDP2FunctionTable = &nvDP2SetFuncs;
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT stateSetExecute (PNVD3DCONTEXT pContext, DWORD dwHandle)
{

    LPD3DHAL_DP2COMMAND pCommands;
    STATESET *pss;
    LPBYTE    pCommandBufferEnd;

    if (dwHandle >= pContext->dwMaxStateSetHandles) {
        DPF ("Stateset index exceeded MAXSTATESETS");
        dbgD3DError();
        return (DDERR_GENERIC);
    }

    pss = pContext->pStateSets + dwHandle;
    pCommands = (LPD3DHAL_DP2COMMAND)(pss->pData);
    pCommandBufferEnd = (LPBYTE)pCommands + pss->dataSize;

    // parse the commands
    while ((LPBYTE)pCommands < pCommandBufferEnd) {

        dbgDisplayDrawPrimitives2Info(pCommands->bCommand, pCommands->wPrimitiveCount);

        if (nvDP2SetFuncs[pCommands->bCommand] != NULL) {
            (nvDP2SetFuncs[pCommands->bCommand]) (pContext,
                                                  &pCommands,
                                                  pCommandBufferEnd,
                                                  NULL,
                                                  0);
#ifdef DEBUG
            DWORD *p = (DWORD*)pCommands;
            if (p[0] == 0xabcd1234)
            {
                DPF_LEVEL (NVDBG_LEVEL_INFO,"StateSet<stateSetExecute> Serial %d parsed succesfully",p[1]);
                pCommands = (LPD3DHAL_DP2COMMAND)(p + 2);
            }
            else
            {
                DPF ("StateSet debug marker not found");
                dbgD3DError();
            }
#endif
        }
        else {
            DPF ("got unhandled command in stateset (%d)",pCommands->bCommand);
            dbgD3DError();
            break;
        }

    }  // while

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT stateSetCapture (PNVD3DCONTEXT pContext, DWORD dwHandle)
{
    LPD3DHAL_DP2COMMAND pCommands;
    STATESET *pss;
    LPBYTE    pCommandBufferEnd;

    if (dwHandle >= pContext->dwMaxStateSetHandles) {
        DPF ("Stateset index exceeded MAXSTATESETS");
        dbgD3DError();
        return (DDERR_GENERIC);
    }

    pss = pContext->pStateSets + dwHandle;
    pCommands = (LPD3DHAL_DP2COMMAND)(pss->pData);
    pCommandBufferEnd = (LPBYTE)pCommands + pss->dataSize;

    // parse the commands
    while ((LPBYTE)pCommands < pCommandBufferEnd) {

        dbgDisplayDrawPrimitives2Info(pCommands->bCommand, pCommands->wPrimitiveCount);

        if (nvDP2CaptureFuncs[pCommands->bCommand] != NULL) {
            (nvDP2CaptureFuncs[pCommands->bCommand]) (pContext,
                                                      &pCommands,
                                                      pCommandBufferEnd,
                                                      NULL,
                                                      0);
#ifdef DEBUG
            DWORD *p = (DWORD*)pCommands;
            if (p[0] == 0xabcd1234)
            {
                DPF_LEVEL (NVDBG_LEVEL_INFO,"StateSet<stateSetCapture> Serial %d parsed succesfully",p[1]);
                pCommands = (LPD3DHAL_DP2COMMAND)(p + 2);
            }
            else
            {
                DPF ("StateSet debug marker not found");
                dbgD3DError();
            }
#endif
        }
        else {
            DPF ("got unhandled command in stateset (%d)",pCommands->bCommand);
            dbgD3DError();
            break;
        }

    }  // while

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT stateSetCreate (PNVD3DCONTEXT pContext, DWORD dwHandle, D3DSTATEBLOCKTYPE sbType)
{
    HRESULT hr;

    stateSetBegin (pContext, dwHandle);

    switch (sbType) {
        case D3DSBT_ALL:
            hr = recordAllState (pContext);
            break;
        case D3DSBT_PIXELSTATE:
            hr = recordPixelState (pContext);
            break;
        case D3DSBT_VERTEXSTATE:
            hr = recordVertexState (pContext);
            break;
        default:
            DPF ("unknown stateset type");
            hr = DDERR_GENERIC;
            break;
    }  // switch

    stateSetEnd (pContext);

    return (hr);
}

//---------------------------------------------------------------------------

HRESULT stateSetDelete (PNVD3DCONTEXT pContext, DWORD dwHandle)
{
    STATESET *pss;

    if (dwHandle >= pContext->dwMaxStateSetHandles) {
        DPF ("Stateset index exceeded MAXSTATESETS");
        dbgD3DError();
        return (DDERR_GENERIC);
    }

    pss = pContext->pStateSets + dwHandle;

    if (pss != NULL) {
        if (pss->pData)
        {
            delete []pss->pData;
        }
#ifdef DEBUG
        memset (pss,0,sizeof(STATESET));
#else
        pss->pData = NULL;
#endif
    }

    return (D3D_OK);
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvRegTool_link.cpp ===
// **************************************************************************
//
//       Copyright 2001-2001 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvRegTool_link.cpp
//      a pointer to a shared file
//
// **************************************************************************
#include "nvprecomp.h"
#include "..\..\..\common\src\nvRegTool.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvsupertri.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvSuperTri.h
//      SuperTri state header file
//
// **************************************************************************
//
//  History:
//      Scott Kephart           08Nov00             Kelvin Development
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

bool ST_Strat_Orig(CSuperTri *st, DWORD dwDP2Operation, DWORD PrimCount, CVertexBuffer *pVertexBufferInUse)
{
    BOOL bDoSuperTri = false;
    BOOL bModelCull = false;
    BOOL bBandWidth = false;
    DWORD STflags = 0;
    DWORD nFrames = CURRENT_FLIP - COMPLETED_FLIP - 1;
    PNVD3DCONTEXT pContext = st->pContext;

    if (dwDP2Operation == D3DDP2OP_INDEXEDTRIANGLELIST2)
    {

        if (nFrames == 3)
        {
            bBandWidth = true;

            if (pContext->dwEarlyCopyStrategy == 6)
            {
                st->dwSuperTriThrottle++;
                st->dwSuperTriThrottle &= st->dwSuperTriMask;
                bDoSuperTri = !st->dwSuperTriThrottle;
            }
            else
            {
                if (!pContext->dwRenderState[D3DRENDERSTATE_CLIPPING])
                    bModelCull = true;
                bDoSuperTri = true;

            }
        }
        else if (nFrames == 2)
        {
            if (pContext->dwEarlyCopyStrategy == 6)
            {
                st->dwSuperTriThrottle++;
                st->dwSuperTriThrottle &= st->dwSuperTriMask;
                bDoSuperTri = !st->dwSuperTriThrottle;
            }
            else
            {
                bDoSuperTri = true;
                bModelCull = true;
            }

        }
        else if (nFrames == 1)
        {
            if (pContext->dwEarlyCopyStrategy != 6)
            {
                st->dwSuperTriThrottle++;
                st->dwSuperTriThrottle &= st->dwSuperTriMask;
                bDoSuperTri = !st->dwSuperTriThrottle;
                bModelCull = true;
            }
        }

        // SK - need to make this more realistic, temporary hack
        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
        {
            if ((pContext->dwEarlyCopyStrategy != 0) && (pContext->dwEarlyCopyStrategy < 3))
            {
                bModelCull = true;
                bBandWidth = true;
            }
        }

        if (st->isSuperTri())
            STflags = pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_ST_MASK;

        if (!st->isModelCullOK())
        {
            bModelCull = false;
            STflags &= ~PS_ST_MODEL;
        }

    //***********************************************************
    // SuperTri test code -- uncomment the following to debug the super-tri code
    //          Always uncomment the following two lines
    //          Setting STflags = 0 or bDoSuperTri to false will cause super tri code to NEVER be executed.
    //        STflags = PS_ST_MASK;
//            bDoSuperTri = true;
    //
    //          This causes every triangle to pass thru the culling test. By default only 1 in 4 is cull-checked.
//         bBandWidth = true;
    //          Set bModelCull to FALSE to force transform and clip check culling
    //          Set bModelCull to TRUE to force model space culling
//         bModelCull = true;
    //***********************************************************

        if (STflags
         && (PrimCount >= 8)
         && (dwDP2Operation == D3DDP2OP_INDEXEDTRIANGLELIST2)
         && (!NV_VERTEX_TRANSFORMED(pContext->hwState.pVertexShader))
         && (!GET_VERTEXBLEND_STATE(pContext))
         && pVertexBufferInUse->getSuperTriLookAsideBuffer()
         && bDoSuperTri)
        {
            if (pVertexBufferInUse == getDC()->defaultVB.getVB())
                st->setVarLBStride();
            else
                st->setFixedLBStride();

            if (bBandWidth)
                st->setCheckAll();
            else
                st->clrCheckAll();

            if (bModelCull)
                st->setModelCull();
            else
                st->setXformCull();

            st->setSTLBStride();
            return true;

        }
    }

    return false;

}

bool ST_Strat_P3(CSuperTri *st, DWORD dwDP2Operation, DWORD PrimCount, CVertexShader *pVertexShader)
{
    BOOL bDoSuperTri = false;
    BOOL bModelCull = false;
    BOOL bBandWidth = false;
    DWORD STflags = 0;
    DWORD nFrames = CURRENT_FLIP - COMPLETED_FLIP;
    PNVD3DCONTEXT pContext = st->pContext;
    CVertexBuffer *pVertexBufferInUse;

    // no super tri for vertex shader programs
    if (pVertexShader->hasProgram())
        return FALSE;

    pVertexBufferInUse = pContext->ppDX8Streams[pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])];

    // check for invalid stream
    if (!pVertexBufferInUse)
        return FALSE;

    if (dwDP2Operation == D3DDP2OP_INDEXEDTRIANGLELIST2)
    {

        if (nFrames == 3)
            bBandWidth = true;
        if (nFrames >= 2)
        {
            bModelCull = true;
            if (pContext->dwEarlyCopyStrategy == 6)
            {
                st->dwSuperTriThrottle++;
                st->dwSuperTriThrottle &= st->dwSuperTriMask;
                bDoSuperTri = !st->dwSuperTriThrottle;
            }
            else            
                bDoSuperTri = true;
        }
        
        // SK - need to make this more realistic, temporary hack
        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
        {
            if ((pContext->dwEarlyCopyStrategy != 0) && (pContext->dwEarlyCopyStrategy < 3))
            {
                bModelCull = true;
                bBandWidth = true;
            }
        }

        if (st->isSuperTri())
            STflags = pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_ST_MASK;

        if (!st->isModelCullOK())
        {
            bModelCull = false;
            STflags &= ~PS_ST_MODEL;
        }

    //***********************************************************
    // SuperTri test code -- uncomment the following to debug the super-tri code
    //          Always uncomment the following two lines
    //          Setting STflags = 0 or bDoSuperTri to false will cause super tri code to NEVER be executed.
    //        STflags = PS_ST_MASK;
//            bDoSuperTri = true;
    //
    //          This causes every triangle to pass thru the culling test. By default only 1 in 4 is cull-checked.
//         bBandWidth = true;
    //          Set bModelCull to FALSE to force transform and clip check culling
    //          Set bModelCull to TRUE to force model space culling
//         bModelCull = true;
    //***********************************************************


        st->clrCullILFlags();

        if (STflags
         && (PrimCount >= 8)
         && (dwDP2Operation == D3DDP2OP_INDEXEDTRIANGLELIST2)
         && (!NV_VERTEX_TRANSFORMED(pContext->hwState.pVertexShader))
         && (!GET_VERTEXBLEND_STATE(pContext))
         && pVertexBufferInUse->getSuperTriLookAsideBuffer()
         && bDoSuperTri)
        {
            if (pVertexBufferInUse == getDC()->defaultVB.getVB())
                st->setVarLBStride();
            else
                st->setFixedLBStride();

            if (bBandWidth)
                st->setCheckAll();
            else
                st->clrCheckAll();

            if (bModelCull)
                st->setModelCull();
            else
                st->setXformCull();

            st->setSTLBStride();
            return true;

        }
    }
    return false;
}

bool ST_Strat_P4(CSuperTri *st, DWORD dwDP2Operation, DWORD PrimCount, CVertexShader *pVertexShader)
{
    BOOL bDoSuperTri = false;
    BOOL bModelCull = false;
    BOOL bBandWidth = false;
    DWORD STflags = 0;
    DWORD nFrames = CURRENT_FLIP - COMPLETED_FLIP - 1;
    PNVD3DCONTEXT pContext = st->pContext;
    CVertexBuffer *pVertexBufferInUse;

    // no super tri for vertex shader programs
    if (pVertexShader->hasProgram())
        return FALSE;

    pVertexBufferInUse = pContext->ppDX8Streams[pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])];

    // check for invalid stream
    if (!pVertexBufferInUse)
        return FALSE;

    if (dwDP2Operation == D3DDP2OP_INDEXEDTRIANGLELIST2)
    {

        if (nFrames >= 1)
        {
            bBandWidth = true;
            bModelCull = true;
            bDoSuperTri = true;

        }

        if (!st->isModelCullOK())
        {
            bModelCull = false;
        }

    //***********************************************************
    // SuperTri test code -- uncomment the following to debug the super-tri code
    //          Always uncomment the following two lines
    //          Setting STflags = 0 or bDoSuperTri to false will cause super tri code to NEVER be executed.
    //        STflags = PS_ST_MASK;
//            bDoSuperTri = true;
    //
    //          This causes every triangle to pass thru the culling test. By default only 1 in 4 is cull-checked.
//         bBandWidth = true;
    //          Set bModelCull to FALSE to force transform and clip check culling
    //          Set bModelCull to TRUE to force model space culling
//         bModelCull = true;
    //***********************************************************
        st->clrCullILFlags();

        if ((PrimCount >= 8)
         && (dwDP2Operation == D3DDP2OP_INDEXEDTRIANGLELIST2)
         && (!NV_VERTEX_TRANSFORMED(pContext->hwState.pVertexShader))
         && (!GET_VERTEXBLEND_STATE(pContext))
         && pVertexBufferInUse->getSuperTriLookAsideBuffer()
         && bDoSuperTri)
        {
            if (pVertexBufferInUse == getDC()->defaultVB.getVB())
                st->setVarLBStride();
            else
                st->setFixedLBStride();

            if (pContext->dwEarlyCopyStrategy != 6 && bBandWidth)
                st->setCheckAll();
            else
                st->clrCheckAll();

            if (bModelCull)
                st->setModelCull();
            else
                st->setXformCull();

            st->setSTLBStride();
            return true;

        }
    }

    return false;

}

bool ST_Strat_Null(CSuperTri *st, DWORD dwDP2Operation, DWORD PrimCount, CVertexShader *pVertexShader)
{
    return false;
}

void CSuperTri::SuperTriInit(PNVD3DCONTEXT Context)
{
    dwSuperTriPendingFlips = 0;
    pContext = Context;
    dwSuperTriThrottle = 0;
    dwSuperTriMask = 0;
    dwNumLights = 0;
    cullsign = 0;
    eye.dvX = 0.0;
    eye.dvY = 0.0;
    eye.dvZ = 0.0;
    eye.dvW = 0.0;
    dwCullFlags = 0;
    dwSTILFlags = 0;
    dwSTLBStride = 0;

    if ((pContext->dwDXAppVersion >= 0x700) && (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_SUPERTRI))
    {
        setSuperTri();
        setModelCullOK();
    }
    pContext->hwState.SuperTri.setStrategy();
}

void CSuperTri::setSTLBStride() {
    dwSTLBStride = (dwSTILFlags & NV_STILFLAG_STDEFVB) ? pContext->hwState.pVertexShader->getStride() : sizeof(CVertexBuffer::STVERTEX);
}

void CSuperTri::setEye(D3DMATRIX *MV)
{

    static D3DVECTOR4 eye_in_eye = {0.0f, 0.0f, 0.0f, 1.0f};
    static D3DVECTOR4 p0 = {0.5f, 0.5f, 0.5f, 1.0f };
    static D3DVECTOR4 p1 = {0.75f, 0.25f, 0.25f, 1.0f };
    static D3DVECTOR4 p2 = {0.75f, 0.75f, 0.25f, 1.0f };
    D3DVECTOR4 norm, mp1, mp2, mp0, eyevec, v1, v2;
    float cw2;
    D3DMATRIX InvMV;
    DWORD cullconv = (pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW) ? 0x1 : 0x0 ;
    DWORD cull;

    if (isSuperTri() && isModelCullOK())
    {
        // Invert the eye vector to model space
        //
        // Instead of culling in screen space, which requires that each vertex be transformed,
        // we'll cull in model space. To accomplish this, we inverse transform the eye point from it's '
        // fixed position in eye-space (it's the origin) back to model space by the inverse of the
        // model-view matrix. (inverse of the view matrix takes us back to world space.) Inverse of
        // the world matrix takes us back to model space.

        DWORD ret = STInverse4x4 (&InvMV, MV);
        {

            static float TOL = 0.001f;
            static D3DMATRIX mTest;
            MatrixProduct4x4 (&mTest, MV, &InvMV);
            if ((ret == -1)                     ||
                (fabs(fabs(mTest._11) - 1.0) > TOL) ||
                ((fabs(mTest._12) - 0.0) > TOL) ||
                ((fabs(mTest._13) - 0.0) > TOL) ||
                ((fabs(mTest._21) - 0.0) > TOL) ||
                (fabs(fabs(mTest._22) - 1.0) > TOL) ||
                ((fabs(mTest._23) - 0.0) > TOL) ||
                ((fabs(mTest._31) - 0.0) > TOL) ||
                ((fabs(mTest._32) - 0.0) > TOL) ||
                (fabs(fabs(mTest._33) - 1.0) > TOL)) {
#ifdef DEBUG
                    DPF ("matrix inversion failed");
#endif
                    // It's really, really hard to always detect non-invertable matrices. So if we ever
                    // find one,  parties over.
                    clrModelCullOK();
                }
        }

        XformVector4((float *)&eye, (float *)&eye_in_eye, &InvMV);

        // Discover what culling convention is being used.
        //
        // There's a complication with this scheme, however, and it's significant. D3D defines
        // D3DCULL_CW and D3DCULL_CCW. These are defined in screen space. This convention is *not*
        // always the same transformed back to model space! The World Matrix can contain rotations
        // that essentially reverse the handedness of our coordinate system. The following
        // takes a triangle that faces towards the eye in camera space, and inverse transforms
        // it to model space. It then performs a culling calculation with the eye, and checks to
        // see if it's still front facing. If not, then the transformation matrices reverse the sense
        // of culling and so we note this.

        XformVector4((float *) &mp1, (float *) &p1, &InvMV);
        XformVector4((float *) &mp2, (float *) &p2, &InvMV);
        XformVector4((float *) &mp0, (float *) &p0, &InvMV);
        // form vectors
        v1.dvX = mp1.dvX - mp0.dvX;
        v1.dvY = mp1.dvY - mp0.dvY;
        v1.dvZ = mp1.dvZ - mp0.dvZ;
        v2.dvX = mp2.dvX - mp0.dvX;
        v2.dvY = mp2.dvY - mp0.dvY;
        v2.dvZ = mp2.dvZ - mp0.dvZ;
        // create eyevector
        eyevec.dvX =  eye.dvX - mp0.dvX;
        eyevec.dvY =  eye.dvY - mp0.dvY;
        eyevec.dvZ =  eye.dvZ - mp0.dvZ;
        // create a normal in model space
        norm.dvX = v1.dvY*v2.dvZ - v1.dvZ*v2.dvY;
        norm.dvY = v1.dvZ*v2.dvX - v1.dvX*v2.dvZ;
        norm.dvZ = v1.dvX*v2.dvY - v1.dvY*v2.dvX;
        // cull
        cw2 = eyevec.dvX * norm.dvX + eyevec.dvY * norm.dvY + eyevec.dvZ * norm.dvZ;
        cull = (cw2 < 0.0f) ? 0 : 1;
        setCullsign(cull ^ cullconv);

    }
}


void CSuperTri::setStrategy()
{
    dwSuperTriThrottle = 0;
    if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_CT_11M)
    {
        if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_1196_CELSIUS) && (pContext->dwEarlyCopyStrategy == 0x32))
            dwSuperTriMask = 1;
        else
            dwSuperTriMask = 0;
    
    }
    else
        dwSuperTriMask = 0;

    pStrategy = ST_Strat_Null;

    if (isSuperTri())
    {
        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
        {
            pStrategy = ST_Strat_P3;

        }

        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
        {
            pStrategy = ST_Strat_P4;

        }

        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
        {
            pStrategy = ST_Strat_P3;

        }

    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvState.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvState.cpp                                                       *
*   NV4 state management routines.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman               04/18/98 - NV4 development.             *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#include "nvdblnd.h"

inline void nvFailMultiTextureSetup( PNVD3DCONTEXT pContext, HRESULT failureCode);

DWORD dwCTTable[] =
{
    0,
    D3DCMP_NEVER,
    D3DCMP_GREATER,
    D3DCMP_EQUAL,
    D3DCMP_GREATEREQUAL,
    D3DCMP_LESS,
    D3DCMP_NOTEQUAL,
    D3DCMP_LESSEQUAL,
    D3DCMP_ALWAYS,
};

DWORD CTFunc
(
    PNVD3DCONTEXT pContext,
    DWORD         dw
)
{
    CNvObject *pNvObj = pContext->pZetaBuffer ? pContext->pZetaBuffer->getWrapper() : NULL;
    if (pNvObj
     && pNvObj->hasCTEnabledNotFront())
    {
        return dwCTTable[dw];
    }
    else
    {
        return dw;
    }
}

//-------------------------------------------------------------------------------------

// convert a D3D LOD bias into the value used by the hardware.

DWORD nvTranslateLODBias (DWORD dwValue)
{
    D3DVALUE dvLODBias;
    DWORD    dwLODBias;
    int      iLODBias;

    dbgTracePush ("nvTranslateLODBias");

    // add biases from the user and registry
    dvLODBias = FLOAT_FROM_DWORD (dwValue) +
                (float (*(int*)&(getDC()->nvD3DRegistryData.regLODBiasAdjust)) / 8.0f);  // registry contributes in 8ths

    if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN)) {
        // convert to 24.8 twos-complement fixed-point
        iLODBias = int (256.0f*dvLODBias + ((dvLODBias>0) ? 0.5f:-0.5f));
        // clamp to -2^12...2^12-1 (5.8 twos-complement fixed-point)
        iLODBias = max (iLODBias, int(-4096));
        iLODBias = min (iLODBias, int(4095));
        // return the last 13 bits
        dwLODBias = iLODBias & 0x00001fff;
    }

    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_DXTRI) {
        // convert to 29.3 twos-complement fixed-point
        iLODBias = int (8.0f*dvLODBias + ((dvLODBias>0) ? 0.5f:-0.5f));
        // clamp to -2^7...2^7-1 (5.3 twos-complement fixed-point)
        iLODBias = max (iLODBias, int(-128));
        iLODBias = min (iLODBias, int(127));
        // return the last 8 bits
        dwLODBias = iLODBias & 0x000000ff;
    }

    else {
        DPF ("unknown hardware type");
        dbgD3DError();
        dwLODBias = 0;
    }

    dbgTracePop();
    return (dwLODBias);
}

//-------------------------------------------------------------------------------------

/*
 * Send suface setup to the hardware.
 */
void nvSetD3DSurfaceState
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvSetD3DSurfaceState");

    if (pContext->dwRTHandle)
    {
        CNvObject *pRTObj = nvGetObjectFromHandle(pContext->dwDDLclID, pContext->dwRTHandle, &global.pNvSurfaceLists);
        if (pRTObj && pRTObj->isDirty())
        {
            // reset the render target after a mode switch
            nvSetRenderTargetDX7(pContext, pContext->dwRTHandle, pContext->dwZBHandle);
#if (NVARCH >= 0x010)
            // make sure the AA info is also updated
            if (pContext->aa.isEnabled()) nvCelsiusAADestroy(pContext);
#endif  // NVARCH >= 0x010

#if (NVARCH >= 0x020)
            pContext->kelvinAA.Refresh();
#endif  // NVARCH >= 0x020
        }
    }

    /*
     * Only need to update the surface if it has changed since the last render call
     * or the global clip state has changed or zeta buffer changed
     */

    // on DX6, they may have moved pointers around without explicitly telling us.
    // make sure our copies are up-to-date.
    if (global.dwDXRuntimeVersion < 0x700) {
        nvRefreshSurfaceInfo (pContext);
    }

    nvAssert (pContext->pRenderTarget);

    CSimpleSurface *pRenderTarget = pContext->pRenderTarget;
    CSimpleSurface *pZetaBuffer   = pContext->pZetaBuffer;

        if (!(pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN))) {

            // if ddraw has sullied the celsius object or if we last programmed
            // the celsius object for a different context, start from scratch
            if ((getDC()->dwLastHWContext != (DWORD)pContext))
            {
                getDC()->dwLastHWContext    = (DWORD)pContext;
                getDC()->bDirtyRenderTarget = TRUE;
            }

            if (pDriverData->bDirtyRenderTarget || pDriverData->TwoDRenderingOccurred) {

            // Send to hardware
            nvglSetObject(NV_DD_SURFACES, D3D_CONTEXT_SURFACES_ARGB_ZS);
            nvglSetRenderTargetContexts(NV_DD_SURFACES,
                                        NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

            // Normal case
            DWORD dwFormat = nv053SurfaceFormat[pRenderTarget->getFormat()];
            if (pRenderTarget->isSwizzled())
            {
                CTexture* pTexture = pRenderTarget->getWrapper()->getTexture();
                nvAssert(pTexture);
                dwFormat |= DRF_DEF(053, _SET_FORMAT, _TYPE, _SWIZZLE);
                dwFormat |= DRF_NUM(053, _SET_FORMAT, _WIDTH, pTexture->getLogWidth());
                dwFormat |= DRF_NUM(053, _SET_FORMAT, _HEIGHT, pTexture->getLogHeight());
            }
            else
            {
                dwFormat |= DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH);
            }

#ifndef STEREO_SUPPORT
            DWORD dwZOffset = pZetaBuffer ? pZetaBuffer->getOffset() : 0;
            DWORD dwTargetOffset = pRenderTarget->getOffset();
#else   //STEREO_SUPPORT==1
            DWORD dwZOffset = pZetaBuffer ? GetStereoOffset(pZetaBuffer) : 0;
            DWORD dwTargetOffset = GetStereoOffset(pRenderTarget);
#endif  //STEREO_SUPPORT
            if (!(pContext->surfaceViewport.clipHorizontal.wX)
             && !(pContext->surfaceViewport.clipVertical.wY))
            {
                DWORD dwClip = (((DWORD)pContext->surfaceViewport.clipVertical.wHeight) << 16) |
                               (pContext->surfaceViewport.clipHorizontal.wWidth);
                DWORD dwZPitch  = pZetaBuffer ? pZetaBuffer->getPitch()  : 32;
                DWORD dwPitch   = (DRF_NUM(053, _SET_PITCH, _COLOR, pRenderTarget->getPitch())) |
                                  (DRF_NUM(053, _SET_PITCH, _ZETA,  dwZPitch));
                nvglSetRenderTarget2(NV_DD_SURFACES,
                                     dwFormat,
                                     dwClip,
                                     dwPitch,
                                     dwTargetOffset,
                                     dwZOffset);
            }
            else
            {
                DWORD dwClip = (((DWORD)pContext->surfaceViewport.clipVertical.wHeight) << 16) |
                               (pContext->surfaceViewport.clipHorizontal.wWidth);
                DWORD dwZPitch  = pZetaBuffer ? pZetaBuffer->getPitch()  : 32;
                DWORD dwPitch   = (DRF_NUM(053, _SET_PITCH, _COLOR, pRenderTarget->getPitch())) |
                                  (DRF_NUM(053, _SET_PITCH, _ZETA,  dwZPitch));
                nvglSetRenderTarget2(NV_DD_SURFACES,
                                     dwFormat,
                                     dwClip,
                                     dwPitch,
                                     dwTargetOffset,
                                     dwZOffset);

                // Set the image black rectangle to the clip region.
                nvglSetObject(NV_DD_SURFACES, NV_DD_IMAGE_BLACK_RECTANGLE);
                nvglSetClip(NV_DD_SURFACES,
                            pContext->surfaceViewport.clipHorizontal.wX, pContext->surfaceViewport.clipVertical.wY,
                            pContext->surfaceViewport.clipHorizontal.wWidth, pContext->surfaceViewport.clipVertical.wHeight);
            }

            nvglSetObject(NV_DD_SURFACES, NV_DD_SURFACES_2D);
            pDriverData->TwoDRenderingOccurred = 0;
            pDriverData->ThreeDRenderingOccurred = TRUE;
            pDriverData->dDrawSpareSubchannelObject = 0; // force a reload.
            pDriverData->bDirtyRenderTarget = FALSE;
            pDriverData->ddClipUpdate = TRUE;
            pDriverData->dwSharedClipChangeCount++;

            NV_FORCE_TRI_SETUP(pContext);

        }  // ! (CELSIUS | KELVIN)
    }

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------------------

void nvSetD3DSurfaceViewport
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvSetD3DSurfaceViewport");

    // Set the image black rectangle to the clip region.
    nvglSetObject(NV_DD_SURFACES, NV_DD_IMAGE_BLACK_RECTANGLE);
    nvglSetClip(NV_DD_SURFACES,
                pContext->surfaceViewport.clipHorizontal.wX, pContext->surfaceViewport.clipVertical.wY,
                pContext->surfaceViewport.clipHorizontal.wWidth, pContext->surfaceViewport.clipVertical.wHeight);

    nvglSetObject(NV_DD_SURFACES, NV_DD_SURFACES_2D);

    pDriverData->TwoDRenderingOccurred      = 0;
    pDriverData->ThreeDRenderingOccurred    = TRUE;
    pDriverData->dDrawSpareSubchannelObject = 0; // force a reload.
    pDriverData->ddClipUpdate = TRUE;
    pDriverData->dwSharedClipChangeCount++;
    NV_FORCE_TRI_SETUP(pContext);

    dbgTracePop();
}

//-------------------------------------------------------------------------------------

/*
 * Send DX5 Triangle class state to the hardware.
 */
void nvSetDx5TriangleState
(
    PNVD3DCONTEXT   pContext
)
{
    DWORD  *pTriangleState;
    DWORD  *pTriangleStateShadow;

    dbgTracePush ("nvSetDx5TriangleState");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    /*
     * Validate the inner loop hardware control registers.
     */
    dbgValidateControlRegisters(pContext);

#if 0
    /*
     * Send down the triangle state.
     */
    pTriangleState = (DWORD *)&pContext->ctxInnerLoop;
    /*
     * Only write channel if it is not selected - avoids texture cache invalidates
     */
    if (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE)
    {
        nvglSetObject(NV_DD_SPARE, D3D_DX5_TEXTURED_TRIANGLE);
    }
    nvglDx5TriangleState(NV_DD_SPARE,
                         *(pTriangleState++), *(pTriangleState++), *(pTriangleState++),
                         *(pTriangleState++), *(pTriangleState++), *(pTriangleState++),
                         *(pTriangleState));
    pDriverData->dDrawSpareSubchannelObject = D3D_DX5_TEXTURED_TRIANGLE;
#else
    /*
     * prep variables
     */
    pTriangleState       = (DWORD*)&pContext->ctxInnerLoop;
    PREFETCH (pTriangleState);
    pTriangleStateShadow = (DWORD*)&pContext->ctxInnerLoopShadow;
    PREFETCH (pTriangleStateShadow);

    /*
     * set object if needed
     */
    if (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE)
    {
        nvglSetObject(NV_DD_SPARE, D3D_DX5_TEXTURED_TRIANGLE);
        pDriverData->dDrawSpareSubchannelObject = D3D_DX5_TEXTURED_TRIANGLE;

        /*
         * force state load
         */
        pTriangleStateShadow[0] = ~pTriangleState[0];
        pTriangleStateShadow[1] = ~pTriangleState[1];
    }

    /*
     * wait-for-fe-idle methods
     */
    if ((pTriangleState[1] != pTriangleStateShadow[1])  // offset
     || (pTriangleState[2] != pTriangleStateShadow[2])) // format
    {
        nvglSetStartMethod (0,NV_DD_SPARE,NV054_OFFSET,2);
        nvglSetData        (1,            pTriangleState[1]);
        nvglSetData        (2,            pTriangleState[2]);
        nvglAdjust         (3);
        pTriangleStateShadow[1] = pTriangleState[1];
        pTriangleStateShadow[2] = pTriangleState[2];
    }

    /*
     * wait-for-idle methods
     */
    if ((pTriangleState[0] != pTriangleStateShadow[0])  // colorKey
     || (pTriangleState[3] != pTriangleStateShadow[3])  // filter
     || (pTriangleState[4] != pTriangleStateShadow[4])  // blend
     || (pTriangleState[5] != pTriangleStateShadow[5])  // control
     || (pTriangleState[6] != pTriangleStateShadow[6])) // fogColor
    {
        nvglSetStartMethod (0,NV_DD_SPARE,NV054_COLOR_KEY,1);
        nvglSetData        (1,            pTriangleState[0]);
        nvglSetStartMethod (2,NV_DD_SPARE,NV054_FILTER,4);
        nvglSetData        (3,            pTriangleState[3]);
        nvglSetData        (4,            pTriangleState[4]);
        nvglSetData        (5,            pTriangleState[5]);
        nvglSetData        (6,            pTriangleState[6]);
        nvglAdjust         (7);
        pTriangleStateShadow[0] = pTriangleState[0];
        pTriangleStateShadow[3] = pTriangleState[3];
        pTriangleStateShadow[4] = pTriangleState[4];
        pTriangleStateShadow[5] = pTriangleState[5];
        pTriangleStateShadow[6] = pTriangleState[6];
    }
#endif

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------------------

/*
 * Context and hardware state set routines.
 */

DWORD nvSetContextState
(
    PNVD3DCONTEXT pContext,
    DWORD         dwStateType,
    DWORD         dwStateValue,
    HRESULT      *pddrval
)
{
    DWORD dwTextureHandle = 0;

    dbgTracePush ("nvSetContextState");

    /*
     * Make sure the state being set is within the range the driver is handling.
     */
    if (dwStateType <= D3D_RENDERSTATE_MAX)
    {

        // if we're getting a texture handle, translate it to the
        // form we store before checking for a change in the value
        if ((dwStateType == D3DRENDERSTATE_TEXTUREHANDLE) && (dwStateValue)) {
            if (global.dwDXRuntimeVersion >= 0x0700) {
                dwTextureHandle = dwStateValue;
                dwStateValue = (DWORD) nvGetObjectFromHandle (pContext->dwDDLclID, dwStateValue, &global.pNvSurfaceLists);
            }
            else {
                dwStateValue |= 0x80000000;
            }
        }

#ifdef TEX_MANAGE
        //Don't treat this like a normal renderstate we need to honor it EVERY time its called
        //not just when its value changes -- i.e. ms should have defined this as a dp2 not a rs.
        //case D3DRENDERSTATE_EVICTMANAGEDTEXTURES: // 61
        if(dwStateType == D3DRENDERSTATE_EVICTMANAGEDTEXTURES){
                DPF ("warning: hideously expensive call. under what circumstances do they do this??");
                nvTexManageEvictAll (pContext);
        }
#endif
        /*
         * Only update the state if it's different.
         */
        if (pContext->dwRenderState[dwStateType] != dwStateValue)
        {

            dbgShowRenderStateChange (TRUE, dwStateType, dwStateValue);

            // force boolean states to 0 or 1

            switch (dwStateType) {
                case D3DRENDERSTATE_WRAPU:             // 5
                case D3DRENDERSTATE_WRAPV:             // 6
                case D3DRENDERSTATE_ZWRITEENABLE:      // 14
                case D3DRENDERSTATE_ALPHATESTENABLE:   // 15
                case D3DRENDERSTATE_LASTPIXEL:         // 16
                case D3DRENDERSTATE_DITHERENABLE:      // 26
                case D3DRENDERSTATE_ALPHABLENDENABLE:  // 27
                case D3DRENDERSTATE_FOGENABLE:         // 28
                case D3DRENDERSTATE_SPECULARENABLE:    // 29
                case D3DRENDERSTATE_ZVISIBLE:          // 30
                case D3DRENDERSTATE_STIPPLEDALPHA:     // 33
                case D3DRENDERSTATE_EDGEANTIALIAS:     // 40
                case D3DRENDERSTATE_COLORKEYENABLE:    // 41
                case D3DRENDERSTATE_STENCILENABLE:     // 52
                case D3DRS_POINTSPRITEENABLE:
                case D3DRS_POINTSCALEENABLE:
                    dwStateValue = dwStateValue != 0;
                    break;
            }

            // handle some special cases and validate parameters

            switch (dwStateType) {

                case D3DRENDERSTATE_TEXTUREHANDLE: // 1
                    pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] = dwStateValue;
                    pContext->tssState[0].dwHandle = dwTextureHandle;
                    break;

                case D3DRENDERSTATE_ANTIALIAS: // 2
                    // app must be DX7 or later and we must be running with a celsius or better
#if (NVARCH >= 0x010)
                    if (pContext->dwDXAppVersion >= 0x0700) {
#if (NVARCH >= 0x020)
                        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                            // we'll check it later
                        } else
#endif
                        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                            switch (dwStateValue)
                            {
                                case D3DANTIALIAS_SORTINDEPENDENT:
                                case D3DANTIALIAS_SORTDEPENDENT:
                                {
                                    // We used to create AA buffers here, but
                                    // now we do it later on, in flip, blit, and some other places.
                                    break;
                                }
                                default:
                                {
                                    dwStateValue = D3DANTIALIAS_NONE;
                                    nvCelsiusAADestroy (pContext);
                                    break;
                                }
                            }
                        }
                    } else
#endif  // NVARCH >= 0x010
                    {
                        // setting ignored
                        dwStateValue = D3DANTIALIAS_NONE;
                    }
                    break;

                case D3DRENDERSTATE_TEXTUREADDRESS: // 3
                    pContext->tssState[0].dwValue[D3DTSS_ADDRESSU] = dwStateValue;
                    pContext->tssState[0].dwValue[D3DTSS_ADDRESSV] = dwStateValue;
                    break;

#ifdef WINNT  // validate this parameter since we later use it to index a table
                case D3DRENDERSTATE_FILLMODE: // 8
                    if (dwStateValue > D3DFILL_SOLID) {
                        dwStateValue = D3DFILL_SOLID;
                    }
                    break;
#endif  // WINNT

                case D3DRENDERSTATE_TEXTUREMAG: // 17
                    switch (dwStateValue)
                    {
                        case D3DFILTER_NEAREST:
                            pContext->tssState[0].dwValue[D3DTSS_MAGFILTER] = D3DTFG_POINT;
                            break;
                        case D3DFILTER_LINEAR:
                            pContext->tssState[0].dwValue[D3DTSS_MAGFILTER] = D3DTFG_LINEAR;
                            break;
                        default:
                            DPF ("stupid app (ahem. turok) sent a bogus TEXTUREMAG. defaulting to linear");
                            pContext->tssState[0].dwValue[D3DTSS_MAGFILTER] = D3DTFG_LINEAR;
                            break;
                    }
                    break;

                case D3DRENDERSTATE_TEXTUREMIN: // 18
                    switch (dwStateValue)
                    {
                        case D3DFILTER_NEAREST:
                            pContext->tssState[0].dwValue[D3DTSS_MINFILTER] = D3DTFN_POINT;
                            pContext->tssState[0].dwValue[D3DTSS_MIPFILTER] = D3DTFP_NONE;
                            break;
                        case D3DFILTER_LINEAR:
                            pContext->tssState[0].dwValue[D3DTSS_MINFILTER] = D3DTFN_LINEAR;
                            pContext->tssState[0].dwValue[D3DTSS_MIPFILTER] = D3DTFP_NONE;
                            break;
                        case D3DFILTER_MIPNEAREST:
                            pContext->tssState[0].dwValue[D3DTSS_MINFILTER] = D3DTFN_POINT;
                            pContext->tssState[0].dwValue[D3DTSS_MIPFILTER] = D3DTFP_POINT;
                            break;
                        case D3DFILTER_MIPLINEAR:
                            pContext->tssState[0].dwValue[D3DTSS_MINFILTER] = D3DTFN_LINEAR;
                            pContext->tssState[0].dwValue[D3DTSS_MIPFILTER] = D3DTFP_POINT;
                            break;
                        case D3DFILTER_LINEARMIPNEAREST:
                            pContext->tssState[0].dwValue[D3DTSS_MINFILTER] = D3DTFN_POINT;
                            pContext->tssState[0].dwValue[D3DTSS_MIPFILTER] = D3DTFP_LINEAR;
                            break;
                        case D3DFILTER_LINEARMIPLINEAR:
                            pContext->tssState[0].dwValue[D3DTSS_MINFILTER] = D3DTFN_LINEAR;
                            pContext->tssState[0].dwValue[D3DTSS_MIPFILTER] = D3DTFP_LINEAR;
                            break;
                        default:
                            pContext->tssState[0].dwValue[D3DTSS_MINFILTER] = D3DTFN_POINT;
                            pContext->tssState[0].dwValue[D3DTSS_MIPFILTER] = D3DTFP_NONE;
                            break;
                    }
                    break;

                case D3DRENDERSTATE_FOGTABLEMODE: // 35
                    // if fog table is disabled in the registry, don't allow it to be set
                    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_FOGTABLEENABLE_MASK) == D3D_REG_FOGTABLEENABLE_DISABLE) {
                        dwStateValue = D3DFOG_NONE;
                    }
                    break;

                case D3DRENDERSTATE_BORDERCOLOR: // 43
                    pContext->tssState[0].dwValue[D3DTSS_BORDERCOLOR] = dwStateValue;
                    break;

                case D3DRENDERSTATE_TEXTUREADDRESSU: // 44
                    pContext->tssState[0].dwValue[D3DTSS_ADDRESSU] = dwStateValue;
                    break;

                case D3DRENDERSTATE_TEXTUREADDRESSV: // 45
                    pContext->tssState[0].dwValue[D3DTSS_ADDRESSV] = dwStateValue;
                    break;

                case D3DRENDERSTATE_MIPMAPLODBIAS: // 46
                    pContext->tssState[0].dwValue[D3DTSS_MIPMAPLODBIAS] = dwStateValue;
                    pContext->tssState[0].dwLODBias = nvTranslateLODBias (dwStateValue);
                    break;

                case D3DRENDERSTATE_ANISOTROPY:
                    pContext->tssState[0].dwValue[D3DTSS_MAXANISOTROPY] = dwStateValue;
                    break;

                case D3DRENDERSTATE_SCENECAPTURE: // 62
                {
                    D3DHAL_SCENECAPTUREDATA scd;
                    scd.dwhContext = (DWORD) pContext;
                    if (dwStateValue)
                        scd.dwFlag = D3DHAL_SCENE_CAPTURE_START;
                    else
                        scd.dwFlag = D3DHAL_SCENE_CAPTURE_END;
                    nvSceneCapture (&scd);
                    break;
                }

                case D3DRENDERSTATE_AMBIENT: // 139
                    pContext->lighting.dcvAmbient.dvR = D3DVAL(RGBA_GETRED(dwStateValue))   / D3DVAL(255);
                    pContext->lighting.dcvAmbient.dvG = D3DVAL(RGBA_GETGREEN(dwStateValue)) / D3DVAL(255);
                    pContext->lighting.dcvAmbient.dvB = D3DVAL(RGBA_GETBLUE(dwStateValue))  / D3DVAL(255);
                    break;

                case D3DRS_POINTSIZE_MIN: // 155
                {
                    float fSizeMin = FLOAT_FROM_DWORD (dwStateValue);
                    fSizeMin = max (fSizeMin, 0.0001f);  // watch out for divide by zero....
                    fSizeMin = min (fSizeMin, 63.869f);
                    dwStateValue = DWORD_FROM_FLOAT (fSizeMin);
                    break;
                }

                case D3DRS_POINTSIZE_MAX: // 166
                {
                    float fSizeMax = FLOAT_FROM_DWORD (dwStateValue);
                    fSizeMax = max (fSizeMax, 0.0f);
                    fSizeMax = min (fSizeMax, 63.870f);
                    dwStateValue = DWORD_FROM_FLOAT (fSizeMax);
                    break;
                }

                case D3DRS_DELETERTPATCH: // 169
                {
                    CNvObject *pObj = NULL;
                    pObj = nvGetObjectFromHandle(pContext->dwDDLclID, dwStateValue, &global.pNvPatchLists);
                    if(pObj){
                        nvClearObjectListEntry(pObj, &global.pNvPatchLists);
                        pObj->release();
                        DPF_LEVEL(NVDBG_LEVEL_HOS_INFO,"Deleting patch #%d", dwStateValue);
                    }
#ifdef DEBUG
                    else{
                        DPF_LEVEL(NVDBG_LEVEL_ERROR,"Unable to delete patch #%d", dwStateValue);
                    }
#endif
                    break;
                }

                default:
                    // nada
                    break;

            }  // switch (dwstatetype)

            // now that we've sanitized things, store the value
            pContext->dwRenderState[dwStateType] = dwStateValue;
            pContext->bStateChange = TRUE;

            nvAssert (dwStateType <= D3D_RENDERSTATE_MAX);  // make sure we're in the table
#if (NVARCH >= 0x010)
            pContext->hwState.dwDirtyFlags |= celsiusDirtyBitsFromRenderState[dwStateType];

#ifdef ALPHA_CULL
            if((dwStateType == D3DRENDERSTATE_SRCBLEND || dwStateType == D3DRENDERSTATE_DESTBLEND) &&
                pContext->hwState.alphacull_mode >= 2){
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0097_KELVIN)
                    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_COMBINERS_COLOR | KELVIN_DIRTY_COMBINERS_SPECFOG;
                else
                    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_COMBINERS | CELSIUS_DIRTY_SPECFOG_COMBINER;
            }
#endif

#endif  // NVARCH >= 0x010
#if (NVARCH >= 0x020)
            pContext->hwState.dwDirtyFlags |= kelvinDirtyBitsFromRenderState[dwStateType];
#endif  // NVARCH >= 0x020

        }

        else {
            // state value !changed
            dbgShowRenderStateChange (FALSE, dwStateType, dwStateValue);
        }

    }

    pContext->kelvinAA.TestCreation(pContext);

    /*
     * Force a reload of the global context state.
     */
    pDriverData->dwCurrentContextHandle = 0;
    *pddrval = DD_OK;
    dbgTracePop();
    DDTICKOFFSET(dwStateType, dwStateValue);
    return (DDHAL_DRIVER_HANDLED);
}

//-------------------------------------------------------------------------------------

void cacheFogValues
(
    PNVD3DCONTEXT pContext
)
{
    DWORD *pdwRenderState = (DWORD *)pContext->dwRenderState;

    dbgTracePush ("cacheFogValues");

    // Store fog table values as floats in the context structure
    // and pre-calculate the linear scale
    pContext->fogData.dwFogTableMode   = NV_FOG_MODE;
    pContext->fogData.fFogTableStart   = FLOAT_FROM_DWORD(pdwRenderState[D3DRENDERSTATE_FOGTABLESTART]);
    pContext->fogData.fFogTableEnd     = FLOAT_FROM_DWORD(pdwRenderState[D3DRENDERSTATE_FOGTABLEEND]);
    pContext->fogData.fFogTableDensity = FLOAT_FROM_DWORD(pdwRenderState[D3DRENDERSTATE_FOGTABLEDENSITY]);

    if (pContext->fogData.dwFogTableMode == D3DFOG_LINEAR) {
        if (pContext->fogData.fFogTableEnd != pContext->fogData.fFogTableStart) {
            pContext->fogData.fFogTableLinearScale = 1.0f / (pContext->fogData.fFogTableEnd - pContext->fogData.fFogTableStart);
        }
        else {
#if (NVARCH >= 0x020)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                pContext->fogData.fFogTableLinearScale = KELVIN_MAX_FOG_SCALE;
            }
            else
#endif // NVARCH >= 0x020
#if (NVARCH >= 0x010)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                pContext->fogData.fFogTableLinearScale = CELSIUS_MAX_FOG_SCALE;
            }
            else
#endif // NVARCH >= 0x010
            {
                pContext->fogData.fFogTableLinearScale = 0.0f;
            }
        }
    }

    dbgTracePop();
}

//-------------------------------------------------------------------------------------

/*
 * Calculate the hardware state register based on the D3D context state settings.
 */
void nvCalculateHardwareStateDX5
(
    PNVD3DCONTEXT pContext,
    DWORD         dwTBlendState,
    DWORD         dwMinFilter,
    DWORD         dwMagFilter,
    BOOL          bDx6ToDx5Conversion
)
{
    BOOL            bAlphaTexture = FALSE;
    DWORD           dwMMDE;
    DWORD           dwAlphaRef;
    DWORD           dwAlphaFunc       = 0;  // Will get initialized before being used.
    DWORD           dwTextureColorFormat;
    DWORD           dwZOHMode, dwFOHMode, dwTexelOrigin;
    DWORD           dwTexturePerspective;
    DWORD           dwSrcBlend;
    DWORD           dwDstBlend;
    DWORD           dwAlphaBlendEnable;
    DWORD           dwColorKey        = 0;
    DWORD           dwOffset          = 0;
    DWORD           dwFormat          = 0;
    DWORD           dwFilter          = 0;
    DWORD           dwBlend           = 0;
    DWORD           dwControl         = 0;
    DWORD           dwFogColor        = 0;
    DWORD          *pdwRenderState    = 0;
    CNvObject      *pNvObj;
    CTexture       *pTexture;

    dbgTracePush ("nvCalculateHardwareStateDX5");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    pdwRenderState = (DWORD *)pContext->dwRenderState;

    dwZOHMode     = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_ZOH_MASK) == D3D_REG_TEXELALIGNMENT_ZOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
    dwFOHMode     = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_FOH_MASK) == D3D_REG_TEXELALIGNMENT_FOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;
    dwTexelOrigin = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_TEXEL_MASK) == D3D_REG_TEXELALIGNMENT_TEXEL_CENTER)
                  ? NV054_CONTROL_ORIGIN_CENTER : NV054_CONTROL_ORIGIN_CORNER;

    /*
     * Maximize 2 pixels per clock.
     */
    switch (getDC()->nvD3DRegistryData.regMipMapDitherMode)
    {
        case D3D_REG_MIPMAPDITHERMODE_DISABLE:
        {
            //turn on trilinear dither when src and destination blends are one?
            dwMMDE = (pdwRenderState[D3DRENDERSTATE_SRCBLEND]  == D3DBLEND_ONE)
                  && (pdwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_ONE);
            break;
        }
        case D3D_REG_MIPMAPDITHERMODE_ENABLE:
        {
            if((dwMinFilter == D3DFILTER_LINEARMIPLINEAR) || (dwMinFilter == D3DFILTER_LINEARMIPNEAREST))
                dwMMDE = TRUE;
            else
                dwMMDE = FALSE;
            break;
        }
        case D3D_REG_MIPMAPDITHERMODE_SMART:
        {
            if((dwMinFilter == D3DFILTER_LINEARMIPLINEAR) || (dwMinFilter == D3DFILTER_LINEARMIPNEAREST))
                //performance adjustment -- if we are at a screen resolution bigger than 1024 don't use
                //true trilinear but approximate with dithered trilinear.
                dwMMDE = GET_MODE_WIDTH() >= 1024;
            else
                dwMMDE = FALSE;
            break;
        }
    }

    // binding of texture handles set with D3DRENDERSTATE_TEXTUREHANDLE
    DWORD dwTextureHandle = pContext->tssState[0].dwHandle;
    if (dwTextureHandle) {
        pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] = (DWORD) nvGetObjectFromHandle (pContext->dwDDLclID, dwTextureHandle, &global.pNvSurfaceLists);
        pContext->tssState[0].dwHandle = 0;
    }

    /*
     * Set up the texture format register.
     */
    pNvObj   = (CNvObject *)(pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP]);
    pTexture = pNvObj ? pNvObj->getTexture() : NULL;

    if (pTexture) {
        /*
         * Display the new texture to the current visible buffer.
         */
        dbgTextureDisplay (pTexture);

        /*
         * Grab the color key from the texture.
         */
        dwTextureColorFormat = nv054TextureFormat[pTexture->getFormat()];
        if (pTexture->hasColorKey()) {
            dwColorKey = pTexture->getColorKey();
            dwFormat |= DRF_NUM(054, _FORMAT, _COLORKEYENABLE, pdwRenderState[D3DRENDERSTATE_COLORKEYENABLE]);
        }
        else {
            dwFormat |= DRF_DEF(054, _FORMAT, _COLORKEYENABLE, _FALSE);
        }

        /*
         * Get the texture format and offset.
         */
        DWORD dwTCIndex = pContext->tssState[0].dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff;
        BOOL  bWrapU, bWrapV, bWrapP, bWrapQ;
        NV_EVAL_CYLINDRICAL_WRAP (pContext, dwTCIndex, bWrapU, bWrapV, bWrapP, bWrapQ);

        dwOffset  = pTexture->getSwizzled()->getOffset();
        dwFormat |= DRF_NUM(054, _FORMAT, _CONTEXT_DMA,     nv054TextureContextDma[pTexture->getSwizzled()->getContextDMA()])
                 |  DRF_NUM(054, _FORMAT, _COLOR,           dwTextureColorFormat)
                 |  DRF_NUM(054, _FORMAT, _BASE_SIZE_U,     pTexture->getLogWidth())
                 |  DRF_NUM(054, _FORMAT, _BASE_SIZE_V,     pTexture->getLogHeight())
                 |  DRF_NUM(054, _FORMAT, _TEXTUREADDRESSU, pContext->tssState[0].dwValue[D3DTSS_ADDRESSU])
                 |  DRF_NUM(054, _FORMAT, _WRAPU,           bWrapU)
                 |  DRF_NUM(054, _FORMAT, _TEXTUREADDRESSV, pContext->tssState[0].dwValue[D3DTSS_ADDRESSV])
                 |  DRF_NUM(054, _FORMAT, _WRAPV,           bWrapV);
        dwFormat |= DRF_NUM(054, _FORMAT, _ORIGIN_ZOH,      dwZOHMode)
                 |  DRF_NUM(054, _FORMAT, _ORIGIN_FOH,      dwFOHMode);

        /*
         * When there is a texture, use the texture map blend set by the user.
         * One exception.  For textures that do not have an alpha component, set MODULATEALPHA
         * instead of MODULATE.
         *
         * NOTE: For some reason, this does not work when SRCBLEND == DESTBLEND == D3DBLEND_ONE
         *       WHY? (Incoming)
         *
         * NOTE: I'm going to use the fact that the hardware doesn't implement MODULATE exactly
         *       as specified in order to get two pixels per clock out of the following DX6
         *       single texture stage 0 setup: COLOROP = MODULATE, COLORARG1 = TEXTURE,
         *       COLORARG2 = CURRENT/DIFFUSE ALPHAOP = SELECTARG1, ALPHAARG1 = TEXTURE.
         *       When useing TBLEND=MODULATE and a non-alpha texture, the alpha should come from the
         *       Diffuse color component, however when using texture stages, we should not do this.
         *       On entry, if we are converting from a texture stage setup, the bUseDX6Class flag will
         *       still be set, and under this condition, we should not modify the passed in TBLEND value.
         */
        if ((!bDx6ToDx5Conversion)
         && (dwTBlendState == D3DTBLEND_MODULATE)
         && (pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE])
         && !((pdwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_ONE)
          &&  (pdwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_ONE))
         && ((dwTextureColorFormat == NV054_FORMAT_COLOR_LE_X1R5G5B5)
          || (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_R5G6B5)
          || (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_X8R8G8B8)))
        {
            dwTBlendState = D3DTBLEND_MODULATEALPHA;
            dwBlend  |= DRF_DEF(054, _BLEND, _TEXTUREMAPBLEND, _MODULATEALPHA);
        }
        else
            dwBlend  |= DRF_NUM(054, _BLEND, _TEXTUREMAPBLEND, dwTBlendState);

        /*
         * When this is a user supplied mipmap chain
         * OR the number of mipmap levels is 1 (i.e. no mipmaps, only base texture)
         * set the MIN/MAG filters as specified by the render states.
         */
        dwFilter |= DRF_NUM(054, _FILTER, _MIPMAP_DITHER_ENABLE, dwMMDE)
                 |  DRF_NUM(054, _FILTER, _TEXTUREMIN,    dwMinFilter)
                 |  DRF_NUM(054, _FILTER, _TEXTUREMAG,    dwMagFilter);

        /*
         * The only way to guarantee that mipmapping is disabled is to set MIPMAP_LEVELS to 1.
         * In cases where there are the user has supplied mipmaps but the minification filter is
         * set to D3DFILTER_NEAREST or D3DFILTER_LINEAR, force the mipmap levels field to be a 1.
         */
        if ((dwMinFilter == D3DFILTER_NEAREST) || (dwMinFilter == D3DFILTER_LINEAR)) {
            dwFormat |= DRF_NUM(054, _FORMAT, _MIPMAP_LEVELS, 1);
        }
        else {
            dwFormat |= DRF_NUM(054, _FORMAT, _MIPMAP_LEVELS, pTexture->getMipMapCount());
        }

         /*
         * Set the Mipmap LOD BIAS based on registery setting and render state setting.
         */
        if ((dwMinFilter == D3DFILTER_MIPNEAREST) || (dwMinFilter == D3DFILTER_MIPLINEAR))
            dwFilter |= DRF_NUM(054, _FILTER, _MIPMAPLODBIAS, pContext->tssState[0].dwLODBias + 0x04);
        else
            dwFilter |= DRF_NUM(054, _FILTER, _MIPMAPLODBIAS, pContext->tssState[0].dwLODBias);

        /*
         * When texturing, always select the proper TexturePerspective render state value.
         */
        dwTexturePerspective = pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE];
    }
    else    //no texture
    {
        /*
         * There is no texture set the default texture format and offset.
         */
        dwTextureColorFormat = getDC()->pDefaultTexture->getFormat();
        dwOffset  = getDC()->pDefaultTexture->getSwizzled()->getOffset();
        dwFormat |= DRF_NUM(054, _FORMAT, _CONTEXT_DMA,     nv054TextureContextDma[getDC()->pDefaultTexture->getSwizzled()->getContextDMA()])
                 |  DRF_DEF(054, _FORMAT, _COLORKEYENABLE,  _FALSE)
                 |  DRF_NUM(054, _FORMAT, _COLOR,           dwTextureColorFormat)
                 |  DRF_NUM(054, _FORMAT, _MIPMAP_LEVELS,    1)
                 |  DRF_DEF(054, _FORMAT, _BASE_SIZE_U,     _1)
                 |  DRF_DEF(054, _FORMAT, _BASE_SIZE_V,     _1)
                 |  DRF_DEF(054, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                 |  DRF_DEF(054, _FORMAT, _WRAPU,           _FALSE)
                 |  DRF_DEF(054, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                 |  DRF_DEF(054, _FORMAT, _WRAPV,           _FALSE);
        dwFormat |= DRF_NUM(054, _FORMAT, _ORIGIN_ZOH,      dwZOHMode)
                 |  DRF_NUM(054, _FORMAT, _ORIGIN_FOH,      dwFOHMode);

        /*
         * When there is no texture,
         *  - always set texture map blend to be MODULATEALPHA when
         *    a) alphablend is enabled or
         *    b) alphatest is enabled
         *  - otherwise just go for modulate. (bdw: why do we want this ever?)
         */
        if (pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]
         || pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE])
            dwBlend  |= DRF_DEF(054, _BLEND, _TEXTUREMAPBLEND, _MODULATEALPHA);
        else
            dwBlend  |= DRF_DEF(054, _BLEND, _TEXTUREMAPBLEND, _MODULATE);

        /*
         * When there's no texture, always set for nearest (point sample) filtering.
         */
        dwFilter |= DRF_DEF(054, _FILTER, _MIPMAP_DITHER_ENABLE, _FALSE)
                 |  DRF_DEF(054, _FILTER, _TEXTUREMIN,    _NEAREST)
                 |  DRF_DEF(054, _FILTER, _TEXTUREMAG,    _NEAREST);

        /*
         * When there is no texture, set texture perspective to false to insure that no 0 RHW values
         * screw up the hardware.
         * But this isn't a good hack.  So it's gone.
         */
//        dwTexturePerspective = FALSE;
        dwTexturePerspective = pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE];

        /*
         * Set the Mipmap LOD BIAS based on registery setting and render state setting.
         */
        dwFilter |= DRF_NUM(054, _FILTER, _MIPMAPLODBIAS, 0);

    }


    /*
     * dwMaxAnisotropy defines 1 as no anisotropy.
     * The following if statement is based on the reference rasterizer.
     */

    if((pContext->tssState[0].dwValue[D3DTSS_MAGFILTER] == D3DTFG_ANISOTROPIC ||
        pContext->tssState[0].dwValue[D3DTSS_MINFILTER] == D3DTFN_ANISOTROPIC) &&
        pContext->tssState[0].dwValue[D3DTSS_MAXANISOTROPY] > 1){
            dwFilter |= DRF_NUM(054, _FILTER, _KERNEL_SIZE_X,              0x1F)
                     |  DRF_NUM(054, _FILTER, _KERNEL_SIZE_Y,              0x1F)
                     |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE,  _TRUE)
                     |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, _TRUE);
    }
    else
    {
        dwFilter |= DRF_DEF(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE,  _FALSE)
                 |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, _FALSE);
    }

    /*
     * Set up the control register.
     */
    dwControl |= DRF_NUM(054, _CONTROL, _ORIGIN,               dwTexelOrigin)
              |  DRF_NUM(054, _CONTROL, _ZFUNC,                CTFunc(pContext,pdwRenderState[D3DRENDERSTATE_ZFUNC]))
              |  DRF_NUM(054, _CONTROL, _CULLMODE,             pdwRenderState[D3DRENDERSTATE_CULLMODE])
              |  DRF_NUM(054, _CONTROL, _DITHERENABLE,         pdwRenderState[D3DRENDERSTATE_DITHERENABLE]);

    /*
     * Get the Src/Dest blending state
     */
    dwAlphaBlendEnable = pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE];
    dwSrcBlend         = pdwRenderState[D3DRENDERSTATE_SRCBLEND];
    dwDstBlend         = pdwRenderState[D3DRENDERSTATE_DESTBLEND];

    /*
     * Colorkey setup.
     */
    if ((pdwRenderState[D3DRENDERSTATE_COLORKEYENABLE])
     && ((dwFormat >> DRF_SHIFT(NV054_FORMAT_COLORKEYENABLE)) & DRF_MASK(NV054_FORMAT_COLORKEYENABLE)))
    {
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "D3D:nvCalculateHardwareStateDX5 - ColorKey Enabled");
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    ColorKey Color     = %08x", dwColorKey);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    AlphaTestEnable    = %08x", pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    AlphaRef           = %08x", pdwRenderState[D3DRENDERSTATE_ALPHAREF]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    AlphaFunc          = %08x", pdwRenderState[D3DRENDERSTATE_ALPHAFUNC]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    AlphaBlendEnable   = %08x", pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    SrcBlend           = %08x", pdwRenderState[D3DRENDERSTATE_SRCBLEND]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    DstBlend           = %08x", pdwRenderState[D3DRENDERSTATE_DESTBLEND]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    TextureMapBlend    = %08x", dwTBlendState);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    TextureColorFormat = %08x", dwTextureColorFormat);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    MagFliter          = %08x", dwMagFilter);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    MinFliter          = %08x", dwMinFilter);

        bAlphaTexture = ((dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A1R5G5B5)
                      || (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A4R4G4B4)
                      || (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A8R8G8B8));

        if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_CKCOMPATABILITYENABLE_MASK) == D3D_REG_CKCOMPATABILITYENABLE_DISABLE)
        {
            DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "ColorKey Compatability Disabled");
            goto    labelColorKeySetupNoAlphaTest;
        }

        /*
         * Check the texture format and alpha blending operation.
         * for 8888 and 1555 textures, if (alpha blending is disabled) OR
         * (alpha blending is enabled and neither srcblend and destblend use the source
         * alpha) then change the format sent to hardware to be the complimentery non-alpha
         * texture format.
         */
        if ((dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A1R5G5B5)
         || (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A8R8G8B8))
        {
            DWORD dwNewFormat;
            dwNewFormat = (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A1R5G5B5) ? NV054_FORMAT_COLOR_LE_X1R5G5B5 : NV054_FORMAT_COLOR_LE_X8R8G8B8;

            if (!dwAlphaBlendEnable)
            {
                /*
                 * When alpha blending is disabled, force 1555 and 8888 textures to be x555 and x888
                 * repectively so that non-colorkey 0 alpha texels don't get alpha tested away.
                 */
                dwFormat &= ~(DRF_MASK(NV054_FORMAT_COLOR) << DRF_SHIFT(NV054_FORMAT_COLOR));
                dwFormat |= DRF_NUM(054, _FORMAT, _COLOR, dwNewFormat);
            }
            else
            {
                if ((dwSrcBlend != D3DBLEND_SRCALPHA)
                 && (dwSrcBlend != D3DBLEND_INVSRCALPHA)
                 && (dwSrcBlend != D3DBLEND_SRCALPHASAT)
                 && (dwSrcBlend != D3DBLEND_BOTHSRCALPHA)
                 && (dwSrcBlend != D3DBLEND_BOTHINVSRCALPHA)
                 && (dwDstBlend != D3DBLEND_SRCALPHA)
                 && (dwDstBlend != D3DBLEND_INVSRCALPHA)
                 && (dwDstBlend != D3DBLEND_SRCALPHASAT)
                 && (dwDstBlend != D3DBLEND_BOTHSRCALPHA)
                 && (dwDstBlend != D3DBLEND_BOTHINVSRCALPHA))
                {
                    /*
                     * When alpha blending is enabled but the srcalpha is not being used, force 1555
                     * and 8888 textures to be x555 and x888 repectively so that non-colorkey 0 alpha
                     * texels don't get alpha tested away.
                     */
                    dwFormat &= ~(DRF_MASK(NV054_FORMAT_COLOR) << DRF_SHIFT(NV054_FORMAT_COLOR));
                    dwFormat |= DRF_NUM(054, _FORMAT, _COLOR,            dwNewFormat);
                }
            }
        }

        /*
         * Change color key implementation to always use alpha test
         */
        if (!pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE])
        {
            DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "ColorKey with registry alphatest");

            // if the blend uses the diffuse color and the diffuse color happens to have alpha=0,
            // the resultant pixel will also have alpha=0 and will always get alpha tested away.
            // we need to prevent this when possible by changing the blend mode to something
            // that will NOT squash all alphas to 0. of course we can only do this if we don't
            // care about the value of alpha for other reasons...

            BOOL bTBlendUsesDiffuse = (dwTBlendState == D3DTBLEND_MODULATEALPHA) ||
                                      (dwTBlendState == D3DTBLEND_DECALALPHA)    ||
                                      (dwTBlendState == D3DTBLEND_DECALMASK)     ||
                                      (dwTBlendState == D3DTBLEND_MODULATEMASK);

            if (bTBlendUsesDiffuse) {

                if ((!dwAlphaBlendEnable)
                    ||
                    ((dwSrcBlend == D3DBLEND_ONE)          &&
                     (dwDstBlend != D3DBLEND_SRCALPHA)     &&
                     (dwDstBlend != D3DBLEND_INVSRCALPHA)  &&
                     (dwDstBlend != D3DBLEND_SRCALPHASAT)  &&
                     (dwDstBlend != D3DBLEND_BOTHSRCALPHA) &&
                     (dwDstBlend != D3DBLEND_BOTHINVSRCALPHA)
                    )
                   )
                {
                    dwBlend &= ~DRF_MASK(NV054_BLEND_TEXTUREMAPBLEND);
                    dwBlend |= DRF_DEF(054, _BLEND, _TEXTUREMAPBLEND, _MODULATE);
                }

            }

            /*
             * Set the colorkey alphatest mode.
             */
            dwAlphaRef = getDC()->nvD3DRegistryData.regColorkeyRef;
            dwControl |= DRF_NUM(054, _CONTROL, _ALPHAREF,        dwAlphaRef)
                      |  DRF_DEF(054, _CONTROL, _ALPHAFUNC,       _GREATER)
                      |  DRF_DEF(054, _CONTROL, _ALPHATESTENABLE, _TRUE);
        }
        else
        {
            DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "ColorKey with app alphatest");

            /*
             * Calculate the hardware alpha test reference value.
             */
            dwAlphaRef = pdwRenderState[D3DRENDERSTATE_ALPHAREF];
            if (dwAlphaRef == 0x00010000)
                dwAlphaRef = 0xFF;
            else if (dwAlphaRef & 0xFF00)
                dwAlphaRef >>= 8;

            /*
             * Get the application specified alpha test comparison function.
             */
            dwAlphaFunc = pdwRenderState[D3DRENDERSTATE_ALPHAFUNC];

            /*
             * There is a very specialized case where we want to actually modify the alphatest setup
             * from what is passed in by the application.  This is for Motoracer2 which does something
             * very strange...but not all the time.  This is most likely an application bug, but I'm
             * working around it here...yuck.
             *
             * The situation is this, occasionally, Motoracer2 will set the following alphatest state:
             * AlphaTestEnable = 1
             * AlphaRef = 0x00
             * AlphaFunc = 7 (GREATEREQUAL)
             * AlphaBlendEnable = 1
             * SrcBlend = 5 (SRCALPHA)
             * DstBlend = 2 (ONE)
             * TextureMapBlend = 4 (MODULATEALPHA)
             * TextureColorFormat = 5 (R5G6B5)
             * However, in this situation, with the alpharef of 0 and the alphafunc set to GREATEREQUAL,
             * the colorkey (which has it's alpha forced to 0) will still show up since the alphatest
             * comparison will always be TRUE.
             * So, I'll make a general case where if the I see this combination when colorkeying is enabled,
             * I'll just change the alphafunc to be GREATER.
             */
            if ((dwAlphaRef == 0x00)
             && (dwAlphaFunc == D3DCMP_GREATEREQUAL ||
                 dwAlphaFunc == D3DCMP_ALWAYS))
            {
                DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "Modify application alphafunc");
                dwAlphaFunc = D3DCMP_GREATER;
            }

            /*
             * Set the hardware alpha test state.
             */
            dwControl |= DRF_NUM(054, _CONTROL, _ALPHAREF,        dwAlphaRef)
                      |  DRF_NUM(054, _CONTROL, _ALPHAFUNC,       dwAlphaFunc)
                      |  DRF_NUM(054, _CONTROL, _ALPHATESTENABLE, pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]);
        }
    }
    else
    {
#if 0   // VR POWERBOAT RACING HACK - NEED SOMETHING EXTREMELY SPECIFIC TO VR POWERBOAT RACING HERE.
        if ((!pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE])
         && (pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE])
         && (dwSrcBlend != D3DBLEND_ONE))
        {
            /*
             * Alpha test away zero alpha pixels to repress z-writes when alpha test
             * is not enabled and alpha blending is enabled.  This is a HACK to work
             * around an application bug in VR Powerboat Racing.
             */
            dwControl |= DRF_NUM(054, _CONTROL, _ALPHAREF,        0x00)
                      |  DRF_NUM(054, _CONTROL, _ALPHAFUNC,       D3DCMP_GREATER)
                      |  DRF_NUM(054, _CONTROL, _ALPHATESTENABLE, TRUE);
        }
        else
#endif  // VR POWERBOAT RACING HACK
        {
labelColorKeySetupNoAlphaTest:
            dwAlphaRef = pdwRenderState[D3DRENDERSTATE_ALPHAREF];
            if (dwAlphaRef == 0x00010000)
                dwAlphaRef = 0xFF;
            else if (dwAlphaRef & 0xFF00)
                dwAlphaRef >>= 8;
            dwControl |= DRF_NUM(054, _CONTROL, _ALPHAREF,        dwAlphaRef)
                      |  DRF_NUM(054, _CONTROL, _ALPHAFUNC,       pdwRenderState[D3DRENDERSTATE_ALPHAFUNC])
                      |  DRF_NUM(054, _CONTROL, _ALPHATESTENABLE, pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]);
        }
    }

    /*
     * Set up the texture map blending control register.
     * Not sure about the MASK_BIT.
     */
    dwBlend |= DRF_DEF(054, _BLEND, _MASK_BIT,           _MSB)
            |  DRF_NUM(054, _BLEND, _SHADEMODE,          D3DSHADE_GOURAUD/*pdwRenderState[D3DRENDERSTATE_SHADEMODE]*/) // inner loop takes care of flat shading
            |  DRF_NUM(054, _BLEND, _TEXTUREPERSPECTIVE, dwTexturePerspective)
            |  DRF_NUM(054, _BLEND, _SPECULARENABLE,     pdwRenderState[D3DRENDERSTATE_SPECULARENABLE])
            |  DRF_NUM(054, _BLEND, _FOGENABLE,          pdwRenderState[D3DRENDERSTATE_FOGENABLE])
            |  DRF_NUM(054, _BLEND, _ALPHABLENDENABLE,   dwAlphaBlendEnable);
    if ((pdwRenderState[D3DRENDERSTATE_SRCBLEND]) == D3DBLEND_BOTHSRCALPHA)
        dwBlend |= DRF_DEF(054, _BLEND, _SRCBLEND,  _SRCALPHA)
                |  DRF_DEF(054, _BLEND, _DESTBLEND, _INVSRCALPHA);
    else if ((pdwRenderState[D3DRENDERSTATE_SRCBLEND]) == D3DBLEND_BOTHINVSRCALPHA)
        dwBlend |= DRF_DEF(054, _BLEND, _SRCBLEND,  _INVSRCALPHA)
                |  DRF_DEF(054, _BLEND, _DESTBLEND, _SRCALPHA);
    else if ((pdwRenderState[D3DRENDERSTATE_DESTBLEND]) == D3DBLEND_BOTHSRCALPHA)
        dwBlend |= DRF_DEF(054, _BLEND, _SRCBLEND,  _SRCALPHA)
                |  DRF_DEF(054, _BLEND, _DESTBLEND, _INVSRCALPHA);
    else if ((pdwRenderState[D3DRENDERSTATE_DESTBLEND]) == D3DBLEND_BOTHINVSRCALPHA)
        dwBlend |= DRF_DEF(054, _BLEND, _SRCBLEND,  _INVSRCALPHA)
                |  DRF_DEF(054, _BLEND, _DESTBLEND, _SRCALPHA);
    else
        dwBlend |= DRF_NUM(054, _BLEND, _SRCBLEND,  dwSrcBlend)
                |  DRF_NUM(054, _BLEND, _DESTBLEND, dwDstBlend);

    if ((pContext->pZetaBuffer)
     && (pdwRenderState[D3DRENDERSTATE_ZENABLE]))
    {
        if ((pdwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_TRUE)
         || ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_WBUFFERENABLE_MASK) == D3D_REG_WBUFFERENABLE_DISABLE))
        {
            /*
             * Plain Z-Buffer.
             */
            dwControl |= DRF_DEF(054, _CONTROL, _ZENABLE,              _TRUE)
                      |  DRF_NUM(054, _CONTROL, _ZWRITEENABLE,         pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                      |  DRF_DEF(054, _CONTROL, _Z_PERSPECTIVE_ENABLE, _FALSE)
                      |  DRF_DEF(054, _CONTROL, _Z_FORMAT,             _FIXED);
        }
        else
        {
            /*
             * W-Buffer.
             */
            nvAssert (pContext->pRenderTarget);
            if (pContext->pRenderTarget->getBPP() == 2)
            {
                // Fixed point w-buffer requires scaling of RHW but gives more precision in 16bit w-buffers.
                dwControl |= DRF_DEF(054, _CONTROL,  _ZENABLE,              _TRUE)
                          |  DRF_NUM(054, _CONTROL,  _ZWRITEENABLE,         pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                          |  DRF_DEF(054, _CONTROL,  _Z_PERSPECTIVE_ENABLE, _TRUE)
                          |  DRF_NUM(054, _CONTROL,  _Z_FORMAT,             getDC()->nvD3DRegistryData.regW16Format);
            }
            else
            {
                // Floating point w-buffer gives more precision for 32-bit (also removes a HW rounding bug with fixed)
                dwControl |= DRF_DEF(054, _CONTROL,  _ZENABLE,              _TRUE)
                          |  DRF_NUM(054, _CONTROL,  _ZWRITEENABLE,         pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                          |  DRF_DEF(054, _CONTROL,  _Z_PERSPECTIVE_ENABLE, _TRUE)
                          |  DRF_NUM(054, _CONTROL,  _Z_FORMAT,             getDC()->nvD3DRegistryData.regW32Format);
            }
        }
    }
    else
    {
        dwControl |= DRF_DEF(054, _CONTROL, _ZENABLE,              _FALSE)
                  |  DRF_DEF(054, _CONTROL, _ZWRITEENABLE,         _FALSE)
                  |  DRF_DEF(054, _CONTROL, _Z_PERSPECTIVE_ENABLE, _FALSE)
                  |  DRF_DEF(054, _CONTROL, _Z_FORMAT,             _FIXED);

    }

    /*
     * Set the fog color.
     */
    dwFogColor = pdwRenderState[D3DRENDERSTATE_FOGCOLOR];

    cacheFogValues (pContext);

    /*
     * handle textures that are unaligned
     *
     * this happens when a mipmap chain is created and the app selects one
     *  of the unaligned lower level mipmaps as the base texture
     * aka HW alignment limitation
     */
    if (dwOffset & 0xff)
    {
        DWORD         dwSize;
        DWORD         dwAddr;

        /*
         * get source address
         */
        dwAddr = pTexture->getSwizzled()->getAddress();

        /*
         * determine how many bytes to move
         */
        dwSize = pTexture->getBaseTexture()->getSwizzled()->getSize()
               - (dwOffset - pTexture->getBaseTexture()->getSwizzled()->getOffset());

        /*
         * move them to spare texture 0
         */
        nvMemCopy (getDC()->dwSpareTextureOffset[0] + VIDMEM_ADDR(pDriverData->BaseAddress),dwAddr,dwSize);

        /*
         * modify texture source
         */
        dwOffset  = getDC()->dwSpareTextureOffset[0];
        dwFormat &= ~0x3;
        dwFormat |= nv054TextureContextDma[NV_CONTEXT_DMA_VID];
    }

    /*
     * Store the register values.
     */
    pContext->ctxInnerLoop.dwColorKey      = dwColorKey;
    pContext->ctxInnerLoop.dwTextureOffset = dwOffset;
    pContext->ctxInnerLoop.dwFormat        = dwFormat;
    pContext->ctxInnerLoop.dwFilter        = dwFilter;
    pContext->ctxInnerLoop.dwBlend         = dwBlend;
    pContext->ctxInnerLoop.dwControl       = dwControl;
    pContext->ctxInnerLoop.dwFogColor      = dwFogColor;
    pContext->bStateChange                 = FALSE;

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------------------

BOOL nvSetHardwareState
(
    PNVD3DCONTEXT pContext
)
{
    DWORD   dwTBlend;
    DWORD   dwMinFilter, dwMagFilter;

    dbgTracePush ("nvSetHardwareState");

    // This code is only enabled in the DEBUG build.
    // Display the DX5 render state to be calculated.
    dbgDisplayContextState (NVDBG_SHOW_RENDER_STATE, pContext);

    // Get state to be passed to the hardware setup routine.
    dwTBlend = pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND];

    // Calculate equivalent TEXTUREMIN and TEXTUREMAG bits from
    // MINFILTER, MAGFILTER and MIPFILTER.
    switch (pContext->tssState[0].dwValue[D3DTSS_MAGFILTER]) {
        case D3DTFG_POINT:
            dwMagFilter = D3DFILTER_NEAREST;
            break;
        case D3DTFG_LINEAR:
            dwMagFilter = D3DFILTER_LINEAR;
            break;
        default:
            dwMagFilter = D3DFILTER_LINEAR;
            break;
    }

    if (pContext->tssState[0].dwValue[D3DTSS_MIPFILTER] == D3DTFP_NONE) {
        switch (pContext->tssState[0].dwValue[D3DTSS_MINFILTER]) {
            case D3DTFN_POINT:
                dwMinFilter = D3DFILTER_NEAREST;
                break;
            case D3DTFN_LINEAR:
                dwMinFilter = D3DFILTER_LINEAR;
                break;
            default:
                dwMinFilter = D3DFILTER_LINEAR;
                break;
        }
    }
    else if (pContext->tssState[0].dwValue[D3DTSS_MIPFILTER] == D3DTFP_POINT) {
        switch (pContext->tssState[0].dwValue[D3DTSS_MINFILTER]) {
            case D3DTFN_POINT:
                dwMinFilter = D3DFILTER_MIPNEAREST;
                break;
            case D3DTFN_LINEAR:
                dwMinFilter = D3DFILTER_MIPLINEAR;
                break;
            default:
                dwMinFilter = D3DFILTER_MIPLINEAR;
                break;
        }
    }
    else {
        switch (pContext->tssState[0].dwValue[D3DTSS_MINFILTER]) {
            case D3DTFN_POINT:
                dwMinFilter = D3DFILTER_LINEARMIPNEAREST;
                break;
            case D3DTFN_LINEAR:
                dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                break;
            default:
                dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                break;
        }
    }

    // Build up the DX5 control state.
    nvCalculateHardwareStateDX5 (pContext, dwTBlend, dwMinFilter, dwMagFilter, FALSE);

    // This code is only enabled in the DEBUG build.
    // Validate the inner loop hardware control registers.
    dbgValidateControlRegisters (pContext);

    // This code is only enabled in the DEBUG build.
    // Display the hardware registers that were calculated.
    dbgDisplayContextState (NVDBG_SHOW_DX5_CLASS_STATE, pContext);

    dbgTracePop();
    return (TRUE);
}

//-------------------------------------------------------------------------------------

/*
 * Format of the cobine data is:
 * Bits 31-24  23-16  15-8  7 - 0
 *       00     op    arg2  arg1
 */

/*
 * DX5 D3DTBLEND_DECAL equivalent texture stage state.
 */
#define DX5_TSSCOLOR_DECAL_MASK_1      0x00FF00FF
#define DX5_TSSCOLOR_DECAL_1           ((D3DTA_TEXTURE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSCOLOR_DECAL_MASK_2      0x00FFFF00
#define DX5_TSSCOLOR_DECAL_2           ((D3DTA_TEXTURE << 8) | (D3DTOP_SELECTARG2 << 16))

#define DX5_TSSALPHA_DECAL_MASK_1      0x00FF00FF
#define DX5_TSSALPHA_DECAL_1           ((D3DTA_TEXTURE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_DECAL_MASK_2      0x00FFFF00
#define DX5_TSSALPHA_DECAL_2           ((D3DTA_TEXTURE << 8) | (D3DTOP_SELECTARG2 << 16))

/*
 * DX5 D3DTBLEND_DECALALPHA equivalent texture stage state.
 */
#define DX5_TSSCOLOR_DECALALPHA_MASK    0x00FFFFFF
#define DX5_TSSCOLOR_DECALALPHA_1       ((D3DTA_TEXTURE << 0) | (D3DTA_DIFFUSE << 8) | (D3DTOP_BLENDTEXTUREALPHA << 16))
#define DX5_TSSCOLOR_DECALALPHA_2       ((D3DTA_TEXTURE << 0) | (D3DTA_CURRENT << 8) | (D3DTOP_BLENDTEXTUREALPHA << 16))
#define DX5_TSSCOLOR_DECALALPHA_3       ((D3DTA_DIFFUSE << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_BLENDTEXTUREALPHA << 16))
#define DX5_TSSCOLOR_DECALALPHA_4       ((D3DTA_CURRENT << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_BLENDTEXTUREALPHA << 16))

#define DX5_TSSALPHA_DECALALPHA_MASK_12 0x00FF00FF
#define DX5_TSSALPHA_DECALALPHA_1       ((D3DTA_DIFFUSE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_DECALALPHA_2       ((D3DTA_CURRENT << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_DECALALPHA_MASK_34 0x00FFFF00
#define DX5_TSSALPHA_DECALALPHA_3       ((D3DTA_DIFFUSE << 8) | (D3DTOP_SELECTARG2 << 16))
#define DX5_TSSALPHA_DECALALPHA_4       ((D3DTA_CURRENT << 8) | (D3DTOP_SELECTARG2 << 16))

/*
 * DX5 D3DTBLEND_MODULATE equivalent texture stage state.
 */
#define DX5_TSSCOLOR_MODULATE_MASK      0x00FFFFFF
#define DX5_TSSCOLOR_MODULATE_1         ((D3DTA_TEXTURE << 0) | (D3DTA_DIFFUSE << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSCOLOR_MODULATE_2         ((D3DTA_TEXTURE << 0) | (D3DTA_CURRENT << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSCOLOR_MODULATE_3         ((D3DTA_DIFFUSE << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSCOLOR_MODULATE_4         ((D3DTA_CURRENT << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_MODULATE << 16))


#define DX5_TSSALPHA_MODULATE_MASK_1    0x00FF00FF
#define DX5_TSSALPHA_MODULATE_1         ((D3DTA_TEXTURE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_MODULATE_MASK_2    0x00FFFF00
#define DX5_TSSALPHA_MODULATE_2         ((D3DTA_TEXTURE << 8) | (D3DTOP_SELECTARG2 << 16))

#define DX5_TSSALPHA_MODULATE_MASK_34   0x00FFFF00
#define DX5_TSSALPHA_MODULATE_3         ((D3DTA_DIFFUSE << 8) | (D3DTOP_SELECTARG2 << 16))
#define DX5_TSSALPHA_MODULATE_4         ((D3DTA_CURRENT << 8) | (D3DTOP_SELECTARG2 << 16))

#define DX5_TSSALPHA_MODULATE_MASK_56   0x00FF00FF
#define DX5_TSSALPHA_MODULATE_5         ((D3DTA_DIFFUSE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_MODULATE_6         ((D3DTA_CURRENT << 0) | (D3DTOP_SELECTARG1 << 16))

/*
 * DX5 D3DTBLEND_MODULATEALPHA equivalent texture stage state.
 */
#define DX5_TSSALPHA_MODULATEALPHA_MASK 0x00FFFFFF
#define DX5_TSSALPHA_MODULATEALPHA_1    ((D3DTA_TEXTURE << 0) | (D3DTA_DIFFUSE << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSALPHA_MODULATEALPHA_2    ((D3DTA_TEXTURE << 0) | (D3DTA_CURRENT << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSALPHA_MODULATEALPHA_3    ((D3DTA_DIFFUSE << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSALPHA_MODULATEALPHA_4    ((D3DTA_CURRENT << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_MODULATE << 16))

/*
 * DX5 D3DTBLEND_ADD equivalent texture stage state.
 */
#define DX5_TSSCOLOR_ADD_MASK           0x00FFFFFF
#define DX5_TSSCOLOR_ADD_1              ((D3DTA_TEXTURE << 0) | (D3DTA_DIFFUSE << 8) | (D3DTOP_ADD << 16))
#define DX5_TSSCOLOR_ADD_2              ((D3DTA_TEXTURE << 0) | (D3DTA_CURRENT << 8) | (D3DTOP_ADD << 16))
#define DX5_TSSCOLOR_ADD_3              ((D3DTA_DIFFUSE << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_ADD << 16))
#define DX5_TSSCOLOR_ADD_4              ((D3DTA_CURRENT << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_ADD << 16))

#define DX5_TSSALPHA_ADD_MASK_12        0x00FF00FF
#define DX5_TSSALPHA_ADD_1              ((D3DTA_DIFFUSE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_ADD_2              ((D3DTA_CURRENT << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_ADD_MASK_34        0x00FFFF00
#define DX5_TSSALPHA_ADD_3              ((D3DTA_DIFFUSE << 8) | (D3DTOP_SELECTARG2 << 16))
#define DX5_TSSALPHA_ADD_4              ((D3DTA_CURRENT << 8) | (D3DTOP_SELECTARG2 << 16))

/*
 * DX5 D3DTBLEND_MODULATE equivalent texture stage state
 *  because AlphaOp is DISABLED (works only for textures without alpha)
 */
#define DX5_TSSCOLOR_0AOP1_MASK_1234    0x00FFFFFF
#define DX5_TSSCOLOR_0AOP1_1            ((D3DTA_DIFFUSE << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSCOLOR_0AOP1_2            ((D3DTA_CURRENT << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSCOLOR_0AOP1_3            ((D3DTA_DIFFUSE << 8) | (D3DTA_TEXTURE << 0) | (D3DTOP_MODULATE << 16))
#define DX5_TSSCOLOR_0AOP1_4            ((D3DTA_CURRENT << 8) | (D3DTA_TEXTURE << 0) | (D3DTOP_MODULATE << 16))

#define DX5_TSSALPHA_0AOP1_MASK_1       0x00FF0000
#define DX5_TSSALPHA_0AOP1_1            (D3DTOP_DISABLE << 16)

/*
 * DX5 D3DTBLEND_COPY equivalent texture stage state
 *  because AlphaOp is DISABLED (works only for textures without alpha)
 */
#define DX5_TSSCOLOR_0AOP2_MASK_1       0x00FF00FF
#define DX5_TSSCOLOR_0AOP2_1            ((D3DTA_TEXTURE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSCOLOR_0AOP2_MASK_2       0x00FFFF00
#define DX5_TSSCOLOR_0AOP2_2            ((D3DTA_TEXTURE << 8) | (D3DTOP_SELECTARG2 << 16))

#define DX5_TSSALPHA_0AOP2_MASK_1        0x00FF0000
#define DX5_TSSALPHA_0AOP2_1             (D3DTOP_DISABLE << 16)

//-------------------------------------------------------------------------------------

BOOL nvConvertTextureStageToDX5Class
(
    PNVD3DCONTEXT pContext
)
{
    BOOL                    bAlphaTexture;
    DWORD                   tssAlphaBlend, tssColorBlend;
    DWORD                   dwMinFilter, dwMagFilter;
    DWORD                   dwTBlend;
    DWORD                   dwTexture;
    CTexture               *pTexture;
    PNVD3DTEXSTAGESTATE     ptssState0;
    PNVD3DMULTITEXTURESTATE pmtsState;

    dbgTracePush ("nvConvertTextureStageToDX5Class");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    ptssState0 = &pContext->tssState[0];
    pmtsState  = &pContext->mtsState;

    tssAlphaBlend = ((ptssState0->dwValue[D3DTSS_ALPHAARG1] & 0x000000FF) << 0)
                  | ((ptssState0->dwValue[D3DTSS_ALPHAARG2] & 0x000000FF) << 8)
                  | ((ptssState0->dwValue[D3DTSS_ALPHAOP]   & 0x000000FF) << 16);
    tssColorBlend = ((ptssState0->dwValue[D3DTSS_COLORARG1] & 0x000000FF) << 0)
                  | ((ptssState0->dwValue[D3DTSS_COLORARG2] & 0x000000FF) << 8)
                  | ((ptssState0->dwValue[D3DTSS_COLOROP]   & 0x000000FF) << 16);

    /*
     * Save off the current texture handle.  This may be changed under some circumstances.
     * MUST BE RESTORED BEFORE EXITING ROUTINE.
     */
    dwTexture = pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP];
    pTexture  = dwTexture ? ((CNvObject *)dwTexture)->getTexture() : NULL;
    if (pTexture) {
        bAlphaTexture = pTexture->hasAlpha();
    }
    else {
        if(dwTexture){ //the pnvObj is valid but the texture deref isn't -- probably a sysmem texture
            //this is HACKY -- I'm borrowing a routine from elsewhere dcr
            nvFailMultiTextureSetup(pContext, D3DERR_CONFLICTINGRENDERSTATE);
            return TRUE;
        }
        bAlphaTexture = FALSE;
    }

    /*
     * Determine if the single texture stage can be converted to a DX5 TEXTUREMAPBLEND state.
     */
    if (ptssState0->dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE)
    {
        if ((((tssColorBlend & DX5_TSSCOLOR_DECAL_MASK_1) == DX5_TSSCOLOR_DECAL_1) ||
             ((tssColorBlend & DX5_TSSCOLOR_DECAL_MASK_2) == DX5_TSSCOLOR_DECAL_2))
         && (((tssAlphaBlend & DX5_TSSALPHA_DECAL_MASK_1) == DX5_TSSALPHA_DECAL_1) ||
             ((tssAlphaBlend & DX5_TSSALPHA_DECAL_MASK_2) == DX5_TSSALPHA_DECAL_2)))
        {
            /*
             * TEXTUREMAPBLEND equivalent is DECAL.
             */
            dwTBlend = D3DTBLEND_DECAL;
        }
        else if ((((tssColorBlend & DX5_TSSCOLOR_DECALALPHA_MASK) == DX5_TSSCOLOR_DECALALPHA_1) ||
                  ((tssColorBlend & DX5_TSSCOLOR_DECALALPHA_MASK) == DX5_TSSCOLOR_DECALALPHA_2) ||
                  ((tssColorBlend & DX5_TSSCOLOR_DECALALPHA_MASK) == DX5_TSSCOLOR_DECALALPHA_3) ||
                  ((tssColorBlend & DX5_TSSCOLOR_DECALALPHA_MASK) == DX5_TSSCOLOR_DECALALPHA_4))
              && (((tssAlphaBlend & DX5_TSSALPHA_DECALALPHA_MASK_12) == DX5_TSSALPHA_DECALALPHA_1) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_DECALALPHA_MASK_12) == DX5_TSSALPHA_DECALALPHA_2) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_DECALALPHA_MASK_34) == DX5_TSSALPHA_DECALALPHA_3) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_DECALALPHA_MASK_34) == DX5_TSSALPHA_DECALALPHA_4)))
        {
            /*
             * TEXTUREMAPBLEND equivalent is DECALALPHA.
             */
            dwTBlend = D3DTBLEND_DECALALPHA;
        }
        else if ((((tssColorBlend & DX5_TSSCOLOR_ADD_MASK) == DX5_TSSCOLOR_ADD_1) ||
                  ((tssColorBlend & DX5_TSSCOLOR_ADD_MASK) == DX5_TSSCOLOR_ADD_2) ||
                  ((tssColorBlend & DX5_TSSCOLOR_ADD_MASK) == DX5_TSSCOLOR_ADD_3) ||
                  ((tssColorBlend & DX5_TSSCOLOR_ADD_MASK) == DX5_TSSCOLOR_ADD_4))
              && (((tssAlphaBlend & DX5_TSSALPHA_ADD_MASK_12) == DX5_TSSALPHA_ADD_1) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_ADD_MASK_12) == DX5_TSSALPHA_ADD_2) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_ADD_MASK_34) == DX5_TSSALPHA_ADD_3) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_ADD_MASK_34) == DX5_TSSALPHA_ADD_4)))
        {
            /*
             * TEXTUREMAPBLEND equivalent is ADD.
             */
            dwTBlend = D3DTBLEND_ADD;
        }
        else if (((tssColorBlend & DX5_TSSCOLOR_MODULATE_MASK) == DX5_TSSCOLOR_MODULATE_1) ||
                 ((tssColorBlend & DX5_TSSCOLOR_MODULATE_MASK) == DX5_TSSCOLOR_MODULATE_2) ||
                 ((tssColorBlend & DX5_TSSCOLOR_MODULATE_MASK) == DX5_TSSCOLOR_MODULATE_3) ||
                 ((tssColorBlend & DX5_TSSCOLOR_MODULATE_MASK) == DX5_TSSCOLOR_MODULATE_4))
        {
            if (((tssAlphaBlend & DX5_TSSALPHA_MODULATEALPHA_MASK) == DX5_TSSALPHA_MODULATEALPHA_1) ||
                ((tssAlphaBlend & DX5_TSSALPHA_MODULATEALPHA_MASK) == DX5_TSSALPHA_MODULATEALPHA_2) ||
                ((tssAlphaBlend & DX5_TSSALPHA_MODULATEALPHA_MASK) == DX5_TSSALPHA_MODULATEALPHA_3) ||
                ((tssAlphaBlend & DX5_TSSALPHA_MODULATEALPHA_MASK) == DX5_TSSALPHA_MODULATEALPHA_4))
            {
                /*
                 * TEXTUREMAPBLEND equivalent is MODULATEALPHA.
                 */
                dwTBlend = D3DTBLEND_MODULATEALPHA;
            }
            else if (((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_1) == DX5_TSSALPHA_MODULATE_1) ||
                     ((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_2) == DX5_TSSALPHA_MODULATE_2))
            {
                /*
                 * TEXTUREMAPBLEND is equivalent to the HW's MODULATE (not exactly the same as D3D's MODULATE)
                 * unless there is no texture in which case we want to pull the alpha component from diffuse.
                 */
                if (pTexture) {
                    dwTBlend = D3DTBLEND_MODULATE;
                }
                else {
                    dwTBlend = D3DTBLEND_MODULATEALPHA;
                }
            }
            else if (((!bAlphaTexture) || (!pTexture))
                  && (((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_34) == DX5_TSSALPHA_MODULATE_3) ||
                      ((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_34) == DX5_TSSALPHA_MODULATE_4) ||
                      ((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_56) == DX5_TSSALPHA_MODULATE_5) ||
                      ((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_56) == DX5_TSSALPHA_MODULATE_6)))
            {
                /*
                 * When the TEXTUREMAPBLEND equivalent is MODULATE but the texture format does
                 * not have an alpha component, need to program the DX5 class as MODULATEALPHA.
                 */
                dwTBlend = D3DTBLEND_MODULATEALPHA;
            }
            else if (pTexture && !bAlphaTexture
                  && ((tssAlphaBlend & DX5_TSSALPHA_0AOP1_MASK_1) == DX5_TSSALPHA_0AOP1_1)
                  && (((tssColorBlend & DX5_TSSCOLOR_0AOP1_MASK_1234) == DX5_TSSCOLOR_0AOP1_1)
                   || ((tssColorBlend & DX5_TSSCOLOR_0AOP1_MASK_1234) == DX5_TSSCOLOR_0AOP1_2)
                   || ((tssColorBlend & DX5_TSSCOLOR_0AOP1_MASK_1234) == DX5_TSSCOLOR_0AOP1_3)
                   || ((tssColorBlend & DX5_TSSCOLOR_0AOP1_MASK_1234) == DX5_TSSCOLOR_0AOP1_4)))
            {
                /*
                 * when we have a non-alpha texture, alpha op is disabled and colorop is modulate
                 */
                dwTBlend = D3DTBLEND_MODULATE;
            }
            else {
                dbgTracePop();
                return (FALSE);
            }
        }
        else if (pTexture && !bAlphaTexture
              && ((tssAlphaBlend & DX5_TSSALPHA_0AOP2_MASK_1) == DX5_TSSALPHA_0AOP2_1)
              && (((tssColorBlend & DX5_TSSCOLOR_0AOP2_MASK_1) == DX5_TSSCOLOR_0AOP2_1)
               || ((tssColorBlend & DX5_TSSCOLOR_0AOP2_MASK_2) == DX5_TSSCOLOR_0AOP2_2)))
        {
            /*
             * when we have a non-alpha texture, alpha op is disabled and colorop is only texture
             */
            dwTBlend = D3DTBLEND_COPY;
        }
        else {
            dbgTracePop();
            return (FALSE);
        }
    }
    else
    {
        /*
         * When stage 0 is disabled, force DX5 setup with no texture.
         */
        pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] = 0;
        nvCalculateHardwareStateDX5 (pContext, D3DTBLEND_MODULATEALPHA, D3DFILTER_NEAREST, D3DFILTER_NEAREST, TRUE);
        pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] = dwTexture;
        dbgTracePop();
        return (TRUE);
    }

    /*
     * Calculate the MIN and MAG filters from the texture stage state.
     */
    /*
     * Need to calculate the MIN and MAG filters.
     */
    switch (ptssState0->dwValue[D3DTSS_MAGFILTER])
    {
        case D3DTFG_POINT:
            dwMagFilter = D3DFILTER_NEAREST;
            break;
        case D3DTFG_LINEAR:
            dwMagFilter = D3DFILTER_LINEAR;
            break;
        default:
            dwMagFilter = D3DFILTER_LINEAR;
            break;
    }
    if (ptssState0->dwValue[D3DTSS_MIPFILTER] == D3DTFP_NONE)
    {
        switch (ptssState0->dwValue[D3DTSS_MINFILTER])
        {
            case D3DTFN_POINT:
                dwMinFilter = D3DFILTER_NEAREST;
                break;
            case D3DTFN_LINEAR:
                dwMinFilter = D3DFILTER_LINEAR;
                break;
            default:
                dwMinFilter = D3DFILTER_LINEAR;
                break;
        }
    }
    else if (ptssState0->dwValue[D3DTSS_MIPFILTER] == D3DTFP_POINT)
    {
        switch (ptssState0->dwValue[D3DTSS_MINFILTER])
        {
            case D3DTFN_POINT:
                dwMinFilter = D3DFILTER_MIPNEAREST;
                break;
            case D3DTFN_LINEAR:
                dwMinFilter = D3DFILTER_MIPLINEAR;
                break;
            default:
                dwMinFilter = D3DFILTER_MIPLINEAR;
                break;
        }
    }
    else
    {
        switch (ptssState0->dwValue[D3DTSS_MINFILTER])
        {
            case D3DTFN_POINT:
                dwMinFilter = D3DFILTER_LINEARMIPNEAREST;
                break;
            case D3DTFN_LINEAR:
                dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                break;
            default:
                dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                break;
        }
    }

    /*
     * Need to track down the mipmap level that the application wants to start from.
     */
    if ((pTexture)
     && (pTexture->getMipMapCount() > 1)
     && (ptssState0->dwValue[D3DTSS_MAXMIPLEVEL]))
    {
        DWORD dwMaxLevel;

        // Mipmap levels are numbered from 0 through (pTexture->MipMapLevels - 1).
        // If the application is asking us to start at a level beyond this range,
        // we must limit it to be within this range.
        dwMaxLevel = ptssState0->dwValue[D3DTSS_MAXMIPLEVEL];
        if (dwMaxLevel >= pTexture->getMipMapCount()) {
            dwMaxLevel = pTexture->getMipMapCount() - 1;
        }

        for (DWORD i=0; i<dwMaxLevel; i++) {
            pTexture = pTexture->getWrapper()->getAttachedA()->getTexture();
        }

        // Update the render state handle for the starting mipmap level.
        pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] = (DWORD)(pTexture->getWrapper());
    }

    /*
     * All other state comes directly from the renderstate.
     * Build up the DX5 control state.
     */
    nvCalculateHardwareStateDX5 (pContext, dwTBlend, dwMinFilter, dwMagFilter, TRUE);

    /*
     * Restore the original texture handle.
     */
    pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] = dwTexture;

    /*
     * Validate the inner loop hardware control registers.
     */
    dbgValidateControlRegisters(pContext);

    /*
     * This code is only enabled in the DEBUG build.
     * Display the hardware registers that were calculated.
     */
    dbgDisplayContextState(NVDBG_SHOW_DX5_CLASS_STATE, pContext);

    /*
     * Determine the UV coordinate offset for the first stage.
     */
    pmtsState->dwUVOffset[0] = (2 * sizeof(D3DVALUE)) * (ptssState0->dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff);

    dbgTracePop();
    return (TRUE);
}

//-------------------------------------------------------------------------------------

void nvSetDx6MultiTextureState
(
    PNVD3DCONTEXT   pContext
)
{
    NVD3DMULTITEXTURESTATE *pState;
    NVD3DMULTITEXTURESTATE *pShadowState;

    dbgTracePush ("nvSetDx6MultiTextureState");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    /*
     * setup locals
     */
    pState       = &pContext->mtsState;
    pShadowState = &pContext->mtsShadowState;

    /*
     * Only write channel if it is not selected - avoids texture cache invalidates
     */
    if (pDriverData->dDrawSpareSubchannelObject != D3D_DX6_MULTI_TEXTURE_TRIANGLE)
    {
        /*
         * select object
         */
        nvglSetObject(NV_DD_SPARE, D3D_DX6_MULTI_TEXTURE_TRIANGLE);

        /*
         * program everything
         */
        nvglDx6TriangleOffset(NV_DD_SPARE,
                              pState->dwTextureOffset[0], 0);
        nvglDx6TriangleOffset(NV_DD_SPARE,
                              pState->dwTextureOffset[1], 1);
        nvglDx6TriangleFormat(NV_DD_SPARE,
                              pState->dwTextureFormat[0], 0);
        nvglDx6TriangleFormat(NV_DD_SPARE,
                              pState->dwTextureFormat[1], 1);
        nvglDx6TriangleFilter(NV_DD_SPARE,
                              pState->dwTextureFilter[0], 0);
        nvglDx6TriangleFilter(NV_DD_SPARE,
                              pState->dwTextureFilter[1], 1);
        nvglDx6TriangleStageState(NV_DD_SPARE,
                                  pState->dwCombine0Alpha, pState->dwCombine0Color,
                                  pState->dwCombine1Alpha, pState->dwCombine1Color,
                                  pState->dwCombineFactor, pState->dwBlend,
                                  pState->dwControl0,      pState->dwControl1,
                                  pState->dwControl2,      pState->dwFogColor);

        pDriverData->dDrawSpareSubchannelObject = D3D_DX6_MULTI_TEXTURE_TRIANGLE;

        /*
         * cache everything
         */
        *pShadowState = *pState;
    }
    else
    {
        if (pShadowState->dwTextureOffset[0] != pState->dwTextureOffset[0])
        {
            nvglDx6TriangleOffset(NV_DD_SPARE,
                                  pState->dwTextureOffset[0], 0);

            pShadowState->dwTextureOffset[0] = pState->dwTextureOffset[0];
        }

        if (pShadowState->dwTextureOffset[1] != pState->dwTextureOffset[1])
        {
            nvglDx6TriangleOffset(NV_DD_SPARE,
                                  pState->dwTextureOffset[1], 1);

            pShadowState->dwTextureOffset[1] = pState->dwTextureOffset[1];
        }

        if (pShadowState->dwTextureFormat[0] != pState->dwTextureFormat[0])
        {
            nvglDx6TriangleFormat(NV_DD_SPARE,
                                  pState->dwTextureFormat[0], 0);

            pShadowState->dwTextureFormat[0] = pState->dwTextureFormat[0];
        }

        if (pShadowState->dwTextureFormat[1] != pState->dwTextureFormat[1])
        {
            nvglDx6TriangleFormat(NV_DD_SPARE,
                                  pState->dwTextureFormat[1], 1);

            pShadowState->dwTextureFormat[1] = pState->dwTextureFormat[1];
        }

        if (pShadowState->dwTextureFilter[0] != pState->dwTextureFilter[0])
        {
            nvglDx6TriangleFilter(NV_DD_SPARE,
                                  pState->dwTextureFilter[0], 0);

            pShadowState->dwTextureFilter[0] = pState->dwTextureFilter[0];
        }

        if (pShadowState->dwTextureFilter[1] != pState->dwTextureFilter[1])
        {
            nvglDx6TriangleFilter(NV_DD_SPARE,
                                  pState->dwTextureFilter[1], 1);

            pShadowState->dwTextureFilter[1] = pState->dwTextureFilter[1];
        }

        /*
         * must be evaluated last
         */
        if ((pShadowState->dwCombine0Alpha != pState->dwCombine0Alpha)
         || (pShadowState->dwCombine0Color != pState->dwCombine0Color)
         || (pShadowState->dwCombine1Alpha != pState->dwCombine1Alpha)
         || (pShadowState->dwCombine1Color != pState->dwCombine1Color)
         || (pShadowState->dwCombineFactor != pState->dwCombineFactor)
         || (pShadowState->dwBlend         != pState->dwBlend        )
         || (pShadowState->dwControl0      != pState->dwControl0     )
         || (pShadowState->dwControl1      != pState->dwControl1     )
         || (pShadowState->dwControl2      != pState->dwControl2     )
         || (pShadowState->dwFogColor      != pState->dwFogColor     ))
        {
            nvglDx6TriangleStageState(NV_DD_SPARE,
                                      pState->dwCombine0Alpha, pState->dwCombine0Color,
                                      pState->dwCombine1Alpha, pState->dwCombine1Color,
                                      pState->dwCombineFactor, pState->dwBlend,
                                      pState->dwControl0,      pState->dwControl1,
                                      pState->dwControl2,      pState->dwFogColor);

            /*
             * cache everything - this is why this part is last
             */
            *pShadowState = *pState;
        }
    }

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------------------

DWORD nv4ValidateTextureStageState
(
    LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pvtssd
)
{
    dbgTracePush ("nv4ValidateTextureStageState");

   // get the context
   PNVD3DCONTEXT pContext;
   NV_SET_CONTEXT (pContext, pvtssd);

   //initialize this to DD_OK so I know if a subroutine failed when it doesn't match
   pContext->mtsState.ddrval = DD_OK;

   nvSetMultiTextureHardwareState (pContext);
   pvtssd->ddrval = pContext->mtsState.ddrval;

   DWORD dwStageCount = 0;
   PNVD3DTEXSTAGESTATE     ptssState0= &pContext->tssState[dwStageCount];
    while ((dwStageCount < 8)
        && (ptssState0->dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE))
    {
        dwStageCount++;
        if (dwStageCount < 8)
            ptssState0 = &pContext->tssState[dwStageCount];
    }

    /*
     * If returning DD_OK, then we can do this operation in 1 pass.
     * If returning an error, then who the heck knows.  Return an obnoxious number.
     */
    if (pvtssd->ddrval == DD_OK)
    {
        /*
         * Hardware setup didn't catch any problems, but there may be some things that we don't support that
         * hardware setup doesn't catch.  Check for them now.
         */
        for (DWORD i=0; i<dwStageCount; i++)
        {
            if ((pContext->tssState[i].dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE)
             && ((pContext->tssState[i].dwValue[D3DTSS_ADDRESSU] == D3DTADDRESS_BORDER)
              || (pContext->tssState[i].dwValue[D3DTSS_ADDRESSV] == D3DTADDRESS_BORDER)))
            {
                pvtssd->ddrval      = D3DERR_CONFLICTINGRENDERSTATE;
                pvtssd->dwNumPasses = 0xFFFFFFFF;
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            }
        }
        /*
         * If the DX6 class is being used and colorkey is enabled, return an error.
         */
        if ((pContext->bUseDX6Class)
         && (pContext->dwRenderState[D3DRENDERSTATE_COLORKEYENABLE]))
        {
            pvtssd->ddrval      = D3DERR_CONFLICTINGRENDERSTATE;
            pvtssd->dwNumPasses = 0xFFFFFFFF;
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }


        if ((pContext->bUseDX6Class) && (pContext->dwDXAppVersion >= 0x0700) &&
            (getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ENFORCESTRICTTRILINEAR_MASK)
            &&(dwStageCount>1))
        {
            // if we are multitexturing and trilinear filtering we've chosen to use a dither
            // approximation for performance reasons.  Invalidate this texture state operation
            // on dx7 apps so winbench2k doesn't complain.
            DWORD j,textureUsed;
            BOOL triLinear;
            triLinear=FALSE;

            for (j=0, textureUsed=0; j<(dwStageCount); j++){
                if (pContext->tssState[j].dwValue[D3DTSS_MIPFILTER] == D3DTFP_LINEAR)
                {
                    triLinear=TRUE;
                }
                if((((pContext->tssState[j].dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)== D3DTA_TEXTURE)
                    &&(pContext->tssState[j].dwValue[D3DTSS_COLOROP]!=D3DTOP_SELECTARG2))
                    ||(((pContext->tssState[j].dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)== D3DTA_TEXTURE)
                    &&(pContext->tssState[j].dwValue[D3DTSS_COLOROP]!=D3DTOP_SELECTARG1)))
                {
                    textureUsed++;
                }
            }
            if((textureUsed>1)&&triLinear)
            {
                pvtssd->ddrval      = D3DERR_UNSUPPORTEDTEXTUREFILTER;
                pvtssd->dwNumPasses = 0xFFFFFFFF;
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            }
        }

        pvtssd->dwNumPasses = 1;
    }

    else {
        pvtssd->dwNumPasses = 0xFFFFFFFF;
    }

    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

//-------------------------------------------------------------------------------------

/*
 * Validate the multi-texture rendering state.
 */
DWORD FAR PASCAL nvValidateTextureStageState
(
    LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pvtssd
)
{
    DWORD dwRetVal;

    dbgTracePush ("nvValidateTextureStageState");

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pvtssd);
    nvSetDriverDataPtrFromContext (pContext);

    // lock textures since the validate code programs the HW with them
    // and we need to make sure they're in HW-readable memory
    nvHWLockTextures (pContext);

    CNvObject *pRTObj = nvGetObjectFromHandle(pContext->dwDDLclID, pContext->dwRTHandle, &global.pNvSurfaceLists);
    if (pRTObj && pRTObj->isDirty())
    {
        // reset the render target
        nvSetRenderTargetDX7(pContext, pContext->dwRTHandle, pContext->dwZBHandle);
        // make sure the AA info is also updated
#if (NVARCH >= 0x010)
        if (pContext->aa.isEnabled()) nvCelsiusAADestroy(pContext);
#endif  // NVARCH >= 0x010

#if (NVARCH >= 0x020)
        pContext->kelvinAA.Refresh();
#endif  // NVARCH >= 0x020

    }

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        dwRetVal = nvKelvinValidateTextureStageState (pvtssd);
    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        dwRetVal = nvCelsiusValidateTextureStageState (pvtssd);
    }
    else
#endif
    {
        dwRetVal = nv4ValidateTextureStageState (pvtssd);
    }

    nvHWUnlockTextures (pContext);


    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (dwRetVal);
}

/**************************** DX6 Multi Texture Setup************************\
*
* In all cases we can use one combiner for each TSS (when they map).
* So we can advertise that we handle 2 textures and 2 stages.
*
* At some point we may want to consider setup of the hardware to support
* 3 stages and sometimes even 4 stages into our 2 combiners.
*
* D3DTA_FACTOR    factor
* D3DTA_DIFFUSE   diffuse
* D3DTA_SPECULAR  ** error not supported **
* D3DTA_CURRENT   diffuse
* D3DTA_TEXTURE   Texture 0
*
* DX6 arg in stage 1 & ~(D3DTA_ALPHA | D3DTA_INV) NV4 arg for combiner 1
*
* D3DTA_FACTOR    factor
* D3DTA_DIFFUSE   diffuse
* D3DTA_SPECULAR  ** error not supported **
* D3DTA_CURRENT   input
* D3DTA_TEXTURE   Texture 1
*
* If (DX6arg & D3DTA_ALPHA) NV4arg |= alpha
* If (DX6arg & D3DTA_INV) NV4arg |= inv
*
* Map the DX6 Arguments and operations as follows:
*
* DX6op                     | NV4op         | NV4arg1            | NV4arg2          | NV4arg3      | NV4arg4
* ==========================+===============+====================+==================+==============+===============
* Selectarg1                | Add           | Arg1               | Inv | zero       | Zero         | Zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Selectarg2                | Add           | Arg2               | Inv | zero       | Zero         | Zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Modulate                  | Add           | Arg1               | Arg2             | Zero         | Zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Modulate2x                | Add           | Arg1               | Arg2             | Arg1         | Arg2
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Modulate4x                | Add2          | Arg1               | Arg2             | Arg1         | Arg2
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Add                       | Add           | Arg1               | Inv | zero       | Arg2         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Addsigned                 | Addsigned     | Arg1               | Inv | zero       | Arg2         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Addsigned2x               | Addsigned2    | Arg1               | Inv | zero       | Arg2         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Addsmoth                  | Add           | Arg1               | Inv | zero       | Inv | Arg1   | Arg2
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Subtract                  | addcomplement | Arg1 | inv         | Inv | zero       | Arg2         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* blenddiffusealpha         | Add           | Arg1               | Alpha | diffuse  | Arg2         | Inv | alpha |
*                           |               |                    |                  |              | diffuse
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Blendtexturealpha         | Add           | Arg1               | Alpha | tex<0|1> | Arg2         | Inv | alpha |
*                           |               |                    |                  |              | tex<0|1>
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Blendfactoralpha          | Add           | Arg1               | Alpha | factor   | Arg2         | Inv | alpha |
*                           |               |                    |                  |              | factor
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Blendtexturealphapm       | Add           | Arg1               | Inv | zero       | Arg2         | Inv | alpha |
*                           |               |                    |                  |              | texture
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Blendcurrentalpha         | Add           | Arg1               | Alpha | input    | Arg2         | Inv | alpha |
*                           |               |                    |                  |              | diffuse
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* premodulate               | ** error **   |                    |                  |              |
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* MODULATEALPHA_ADDCOLOR    | Add           | Arg1 | alpha       | Arg2             | Arg1         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* MODULATECOLOR_ADDALPHA    | Add           | Arg1               | Arg2             | Arg1 | alpha | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* MODULATEINVALPHA_ADDCOLOR | Add           | Arg1 | alpha | inv | Arg2             | Arg1         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* MODULATEINVCOLOR_ADDALPHA | Add           | Arg1 | inv         | Arg2             | Arg1 | alpha | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* BUMPENVMAP                | ** error **   |                    |                  |              |
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* BUMPENVMAPLUMINANCE       | ** error **   |                    |                  |              |
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* BUMPMAPLIGHT              | ** error **   |                    |                  |              |
* ==========================+===============+====================+==================+==============+===============
*
\****************************************************************************/

BOOL nvStencilBufferExists
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvStencilBufferExists");

    // on pre-kelvin HW, there can't be a stencil buffer if the render target is only 16bpp
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)) {
        nvAssert (pContext->pRenderTarget);
        if (pContext->pRenderTarget->getBPP() == 2) {
            dbgTracePop();
            return (FALSE);
        }
    }

    // if there is no Z-Buffer, then there can't be a stencil buffer.
    if (!pContext->pZetaBuffer) {
        dbgTracePop();
        return (FALSE);
    }

    BOOL bRV = pContext->pZetaBuffer->hasStencil();
    dbgTracePop();
    return (bRV);
}

//-------------------------------------------------------------------------------------

// returns true is a stencil buffer exists and is enabled

BOOL nvStencilBufferInUse (PNVD3DCONTEXT pContext)
{
    dbgTracePush ("nvStencilBufferInUse");
    BOOL bRV = (pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE] &&
                nvStencilBufferExists(pContext));
    dbgTracePop();
    return (bRV);
}

//-------------------------------------------------------------------------------------

void nvSetDX6TextureState
(
    PNVD3DCONTEXT           pContext,
    DWORD                   dwTextureNum,
    PNVD3DTEXSTAGESTATE     ptssState,
    PNVD3DMULTITEXTURESTATE pmtsState
)
{
    DWORD           dwMagFilter;
    DWORD           dwMinFilter;
    DWORD           dwZOHMode, dwFOHMode;
    CNvObject      *pNvObj;
    CTexture       *pTexture;

    dbgTracePush ("nvSetDX6TextureState");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    /*
     * setup state
     */
    dwZOHMode = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_ZOH_MASK) == D3D_REG_TEXELALIGNMENT_ZOH_CENTER)
              ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
    dwFOHMode = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_FOH_MASK) == D3D_REG_TEXELALIGNMENT_FOH_CENTER)
              ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;

    pNvObj    = (CNvObject *)(ptssState->dwValue[D3DTSS_TEXTUREMAP]);
    pTexture  = pNvObj ? pNvObj->getTexture() : NULL;

    if (!pTexture){
        //if the texture is undefined -- its probably a sysmem texture bail
        nvFailMultiTextureSetup(pContext, D3DERR_CONFLICTINGRENDERSTATE);
        return;
    }

    if (pTexture)
    {
        if ((pTexture->getMipMapCount() > 1) && (ptssState->dwValue[D3DTSS_MAXMIPLEVEL]))
        {
            DWORD dwMaxLevel;

            // Mipmap levels are numbered from 0 through (pTexture->MipMapLevels - 1).
            // If the application is asking us to start at a level beyond this range,
            // we must limit it to be within this range.
            dwMaxLevel = ptssState->dwValue[D3DTSS_MAXMIPLEVEL];
            if (dwMaxLevel >= pTexture->getMipMapCount()) {
                dwMaxLevel = pTexture->getMipMapCount() - 1;
            }

            for (DWORD i=0; i<dwMaxLevel; i++) {
                pTexture = pTexture->getWrapper()->getAttachedA()->getTexture();
            }

            // Update the render state handle for the starting mipmap level.
            ptssState->dwValue[D3DTSS_TEXTUREMAP] = (DWORD)(pTexture->getWrapper());
        }

        DWORD dwTCIndex = ptssState->dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff;
        BOOL  bWrapU, bWrapV, bWrapP, bWrapQ;
        NV_EVAL_CYLINDRICAL_WRAP (pContext, dwTCIndex, bWrapU, bWrapV, bWrapP, bWrapQ);

        pmtsState->dwTextureOffset[dwTextureNum] = pTexture->getSwizzled()->getOffset();
        pmtsState->dwTextureFormat[dwTextureNum] = DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     nv055TextureContextDma[pTexture->getSwizzled()->getContextDMA()])
                                                 | DRF_NUM(055, _FORMAT, _COLOR,           nv055TextureFormat[pTexture->getFormat()])
                                                 | DRF_NUM(055, _FORMAT, _BASE_SIZE_U,     pTexture->getLogWidth())
                                                 | DRF_NUM(055, _FORMAT, _BASE_SIZE_V,     pTexture->getLogHeight())
                                                 | DRF_NUM(055, _FORMAT, _TEXTUREADDRESSU, ptssState->dwValue[D3DTSS_ADDRESSU])
                                                 | DRF_NUM(055, _FORMAT, _WRAPU,           bWrapU)
                                                 | DRF_NUM(055, _FORMAT, _TEXTUREADDRESSV, ptssState->dwValue[D3DTSS_ADDRESSV])
                                                 | DRF_NUM(055, _FORMAT, _WRAPV,           bWrapV);
        pmtsState->dwTextureFormat[dwTextureNum] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,     dwZOHMode)
                                                 |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,     dwFOHMode);

        /*
         * Need to calculate the MIN and MAG filters.
         */
        pmtsState->dwTextureFilter[dwTextureNum] = 0;  // initialize

        switch (ptssState->dwValue[D3DTSS_MAGFILTER])
        {
            case D3DTFG_POINT:
                dwMagFilter = D3DFILTER_NEAREST;
                break;
            case D3DTFG_LINEAR:
                dwMagFilter = D3DFILTER_LINEAR;
                break;
            case D3DTFG_ANISOTROPIC:
                dwMagFilter = D3DFILTER_LINEAR;
                pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(054, _FILTER, _KERNEL_SIZE_X,              0x1F)
                                                         |  DRF_NUM(054, _FILTER, _KERNEL_SIZE_Y,              0x1F)
                                                         |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, _TRUE);
                break;
            default:
                dwMagFilter = D3DFILTER_LINEAR;
                break;
        }

        if (ptssState->dwValue[D3DTSS_MIPFILTER] == D3DTFP_NONE)
        {
            switch (ptssState->dwValue[D3DTSS_MINFILTER])
            {
                case D3DTFN_POINT:
                    dwMinFilter = D3DFILTER_NEAREST;
                    break;
                case D3DTFN_LINEAR:
                    dwMinFilter = D3DFILTER_LINEAR;
                    break;
                case D3DTFN_ANISOTROPIC:
                    dwMinFilter = D3DFILTER_LINEAR;
                    pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(054, _FILTER, _KERNEL_SIZE_X,              0x1F)
                                                             |  DRF_NUM(054, _FILTER, _KERNEL_SIZE_Y,              0x1F)
                                                             |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE,  _TRUE);
                    break;
                default:
                    dwMinFilter = D3DFILTER_LINEAR;
                    break;
            }
            pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, (DWORD)ptssState->dwLODBias);
        }
        else if (ptssState->dwValue[D3DTSS_MIPFILTER] == D3DTFP_POINT)
        {
            switch (ptssState->dwValue[D3DTSS_MINFILTER])
            {
                case D3DTFN_POINT:
                    dwMinFilter = D3DFILTER_MIPNEAREST;
                    break;
                case D3DTFN_LINEAR:
                    dwMinFilter = D3DFILTER_MIPLINEAR;
                    break;
                case D3DTFN_ANISOTROPIC:
                    dwMinFilter = D3DFILTER_MIPLINEAR;
                    pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(054, _FILTER, _KERNEL_SIZE_X,              0x1F)
                                                             |  DRF_NUM(054, _FILTER, _KERNEL_SIZE_Y,              0x1F)
                                                             |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE,  _TRUE);
                    break;
                default:
                    dwMinFilter = D3DFILTER_MIPLINEAR;
                    break;
            }
            pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, (DWORD)ptssState->dwLODBias + 0x04);
        }
        else
        {
            switch (ptssState->dwValue[D3DTSS_MINFILTER])
            {
                case D3DTFN_POINT:
                    dwMinFilter = D3DFILTER_LINEARMIPNEAREST;
                    break;
                case D3DTFN_LINEAR:
                    dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                    break;
                case D3DTFN_ANISOTROPIC:
                    dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                    pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(054, _FILTER, _KERNEL_SIZE_X,              0x1F)
                                                             |  DRF_NUM(054, _FILTER, _KERNEL_SIZE_Y,              0x1F)
                                                             |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE,  _TRUE);
                    break;
                default:
                    dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                    break;
            }
            pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, (DWORD)ptssState->dwLODBias + 0x04);
        }

        /*
         * When this is a user supplied mipmap chain
         * OR the number of mipmap levels is 1 (i.e. no mipmaps, only base texture)
         * set the MIN/MAG filters as specified by the render states.
         */

        if((dwMinFilter == D3DFILTER_LINEARMIPLINEAR) || (dwMinFilter == D3DFILTER_LINEARMIPNEAREST))
            pmtsState->dwTextureFilter[dwTextureNum] |= DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE);
        else
            pmtsState->dwTextureFilter[dwTextureNum] |= DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _FALSE);

        pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(055, _FILTER, _TEXTUREMIN, dwMinFilter)
                                                 |  DRF_NUM(055, _FILTER, _TEXTUREMAG, dwMagFilter);

        /*
         * The only way to guarantee that mipmapping is disabled is to set MIPMAP_LEVELS to 1.
         * In cases where there are the user has supplied mipmaps but the minification filter is
         * set to D3DFILTER_NEAREST or D3DFILTER_LINEAR, force the mipmap levels field to be a 1.
         */
        if ((dwMinFilter == D3DFILTER_NEAREST) || (dwMinFilter == D3DFILTER_LINEAR)) {
            pmtsState->dwTextureFormat[dwTextureNum] |= DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS, 1);
        }
        else {
            pmtsState->dwTextureFormat[dwTextureNum] |= DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS, pTexture->getMipMapCount());
        }

        dbgTextureDisplay (pTexture);
    }
    else
    {
        /*
         * There is no texture set the default texture format and offset.
         */
        pmtsState->dwTextureOffset[dwTextureNum] = getDC()->pDefaultTexture->getSwizzled()->getOffset();
        pmtsState->dwTextureFormat[dwTextureNum] = DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     nv055TextureContextDma[getDC()->pDefaultTexture->getSwizzled()->getContextDMA()])
                                                 | DRF_NUM(055, _FORMAT, _COLOR,           nv055TextureFormat[getDC()->pDefaultTexture->getFormat()])
                                                 | DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,   1)
                                                 | DRF_DEF(055, _FORMAT, _BASE_SIZE_U,     _1)
                                                 | DRF_DEF(055, _FORMAT, _BASE_SIZE_V,     _1)
                                                 | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                                 | DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                                 | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                                 | DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
        pmtsState->dwTextureFormat[dwTextureNum] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,     dwZOHMode)
                                                 |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,     dwFOHMode);



        /*
         * When there's no texture, always set for nearest (point sample) filtering.
         */
        pmtsState->dwTextureFilter[dwTextureNum] = DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _FALSE)
                                                 | DRF_DEF(055, _FILTER, _TEXTUREMIN,           _NEAREST)
                                                 | DRF_DEF(055, _FILTER, _TEXTUREMAG,           _NEAREST);

        pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, (DWORD)0);

    }


    /*
     * Determine the UV coordinate offset for this texture stage.
     */
    pmtsState->dwUVOffset[dwTextureNum] = (2 * sizeof(D3DVALUE)) * (ptssState->dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff);

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------------------

void nvSetDX6State
(
    PNVD3DCONTEXT            pContext,
    DWORD                   *pdwRenderState,
    PNVD3DMULTITEXTURESTATE  pmtsState
)
{
    DWORD   dwAlphaRef;
    DWORD   dwTexelOrigin;

    dbgTracePush ("nvSetDX6State");

    dwTexelOrigin = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_TEXEL_MASK) == D3D_REG_TEXELALIGNMENT_TEXEL_CENTER)
                  ? NV054_CONTROL_ORIGIN_CENTER : NV054_CONTROL_ORIGIN_CORNER;

    /*
     * Set the Combine Factor.
     */
    pmtsState->dwCombineFactor = pdwRenderState[D3DRENDERSTATE_TEXTUREFACTOR];

    /*
     * Setup Blend control.
     */
    pmtsState->dwBlend = DRF_DEF(055, _BLEND, _MASK_BIT,           _MSB)
                       | DRF_NUM(055, _BLEND, _SHADEMODE,          D3DSHADE_GOURAUD/*pdwRenderState[D3DRENDERSTATE_SHADEMODE]*/) // inner loop takes care of flat shading
                       | DRF_NUM(055, _BLEND, _TEXTUREPERSPECTIVE, pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE])
                       | DRF_NUM(055, _BLEND, _SPECULARENABLE,     pdwRenderState[D3DRENDERSTATE_SPECULARENABLE])
                       | DRF_NUM(055, _BLEND, _FOGENABLE,          pdwRenderState[D3DRENDERSTATE_FOGENABLE])
                       | DRF_NUM(055, _BLEND, _ALPHABLENDENABLE,   pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]);

    if ((pdwRenderState[D3DRENDERSTATE_SRCBLEND]) == D3DBLEND_BOTHSRCALPHA)
        pmtsState->dwBlend |= DRF_DEF(055, _BLEND, _SRCBLEND,  _SRCALPHA)
                           |  DRF_DEF(055, _BLEND, _DESTBLEND, _INVSRCALPHA);
    else if ((pdwRenderState[D3DRENDERSTATE_SRCBLEND]) == D3DBLEND_BOTHINVSRCALPHA)
        pmtsState->dwBlend |= DRF_DEF(055, _BLEND, _SRCBLEND,  _INVSRCALPHA)
                           |  DRF_DEF(055, _BLEND, _DESTBLEND, _SRCALPHA);
    else
        pmtsState->dwBlend |= DRF_NUM(055, _BLEND, _SRCBLEND,  pdwRenderState[D3DRENDERSTATE_SRCBLEND])
                           |  DRF_NUM(055, _BLEND, _DESTBLEND, pdwRenderState[D3DRENDERSTATE_DESTBLEND]);

    /*
     * Setup Control0.
     */
    if (pdwRenderState[D3DRENDERSTATE_ALPHAREF] == 0x00010000)
        dwAlphaRef = 0xFF;
    else
        dwAlphaRef = (pdwRenderState[D3DRENDERSTATE_ALPHAREF] & 0x0000FF00)
                   ? (pdwRenderState[D3DRENDERSTATE_ALPHAREF] >> 8)
                   : (pdwRenderState[D3DRENDERSTATE_ALPHAREF] & 0x000000FF);
    pmtsState->dwControl0 = DRF_NUM(055, _CONTROL0, _ALPHAREF,             dwAlphaRef)
                          | DRF_NUM(055, _CONTROL0, _ALPHAFUNC,            pdwRenderState[D3DRENDERSTATE_ALPHAFUNC])
                          | DRF_NUM(055, _CONTROL0, _ALPHATESTENABLE,      pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE])
                          | DRF_NUM(055, _CONTROL0, _ORIGIN,               dwTexelOrigin)
                          | DRF_NUM(055, _CONTROL0, _ZFUNC,                CTFunc(pContext,pdwRenderState[D3DRENDERSTATE_ZFUNC]))
                          | DRF_NUM(055, _CONTROL0, _CULLMODE,             pdwRenderState[D3DRENDERSTATE_CULLMODE])
                          | DRF_NUM(055, _CONTROL0, _DITHERENABLE,         pdwRenderState[D3DRENDERSTATE_DITHERENABLE]);

    /*
     * Set Control0 z-buffer enable bits.
     */
    if ((pContext->pZetaBuffer) && (pdwRenderState[D3DRENDERSTATE_ZENABLE]))
    {
        if ((pdwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_TRUE)
         || ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_WBUFFERENABLE_MASK) == D3D_REG_WBUFFERENABLE_DISABLE))
        {
            /*
             * Plain Z-Buffer.
             */
            pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,              _TRUE)
                                  |  DRF_NUM(055, _CONTROL0, _ZWRITEENABLE,         pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                                  |  DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _FALSE)
                                  |  DRF_DEF(055, _CONTROL0, _Z_FORMAT,             _FIXED);
        }
        else
        {
            /*
             * W-Buffer.
             */
            nvAssert (pContext->pRenderTarget);
            if (pContext->pRenderTarget->getBPP() == 2)
            {
                // Fixed point w-buffer reqires scaling of RHW but gives more precision in 16bit w-buffers.
                pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,              _TRUE)
                                      |  DRF_NUM(055, _CONTROL0, _ZWRITEENABLE,         pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                                      |  DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _TRUE)
                                      |  DRF_NUM(055, _CONTROL0, _Z_FORMAT,             getDC()->nvD3DRegistryData.regW16Format);
            }
            else
            {
                // Floating point w-buffer gives more precision for 32-bit (also removes a HW rounding bug with fixed)
                pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,              _TRUE)
                                      |  DRF_NUM(055, _CONTROL0, _ZWRITEENABLE,         pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                                      |  DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _TRUE)
                                      |  DRF_NUM(055, _CONTROL0, _Z_FORMAT,             getDC()->nvD3DRegistryData.regW32Format);
            }
        }
    }
    else
    {
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,              _FALSE)
                              |  DRF_DEF(055, _CONTROL0, _ZWRITEENABLE,         _FALSE)
                              |  DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _FALSE)
                              |  DRF_DEF(055, _CONTROL0, _Z_FORMAT,             _FIXED);
    }
    /*
     * Set Control0 stencil buffer enable bits.
     */
    if (nvStencilBufferInUse(pContext))
    {
        pContext->bStencilEnabled = TRUE;
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _STENCIL_WRITE_ENABLE, _TRUE);
        /*
         * Setup Control1.
         * Stencil buffer control bits.
         */
        pmtsState->dwControl1 = DRF_NUM(055, _CONTROL1, _STENCIL_TEST_ENABLE, pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_FUNC,        pContext->dwRenderState[D3DRENDERSTATE_STENCILFUNC])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_REF,         pContext->dwRenderState[D3DRENDERSTATE_STENCILREF])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_READ,   pContext->dwRenderState[D3DRENDERSTATE_STENCILMASK])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_WRITE,  pContext->dwRenderState[D3DRENDERSTATE_STENCILWRITEMASK]);

        /*
         * Setup Control2.
         * More stencil buffer control bits.
         */
        pmtsState->dwControl2 = DRF_NUM(055, _CONTROL2, _STENCIL_OP_FAIL,  pContext->dwRenderState[D3DRENDERSTATE_STENCILFAIL])
                              | DRF_NUM(055, _CONTROL2, _STENCIL_OP_ZFAIL, pContext->dwRenderState[D3DRENDERSTATE_STENCILZFAIL])
                              | DRF_NUM(055, _CONTROL2, _STENCIL_OP_ZPASS, pContext->dwRenderState[D3DRENDERSTATE_STENCILPASS]);
    }
    else
    {
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _STENCIL_WRITE_ENABLE, _FALSE);
        /*
         * Setup Control1.
         * Stencil buffer control bits.
         */
        pmtsState->dwControl1 = DRF_DEF(055, _CONTROL1, _STENCIL_TEST_ENABLE, _FALSE)
                              | DRF_DEF(055, _CONTROL1, _STENCIL_FUNC,        _NEVER)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_REF,         0)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_READ,   0)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_WRITE,  0);

        /*
         * Setup Control2.
         * More stencil buffer control bits.
         */
        pmtsState->dwControl2 = DRF_DEF(055, _CONTROL2, _STENCIL_OP_FAIL,  _KEEP)
                              | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZFAIL, _KEEP)
                              | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZPASS, _KEEP);
    }
    /*
     * Set ARGB write enbles.
     * Always enable RGB only enable Alpha for alpha frame buffers.
     */
//    if
//    else
    {
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ALPHA_WRITE_ENABLE, _FALSE);
    }
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _RED_WRITE_ENABLE,   _TRUE);
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _GREEN_WRITE_ENABLE, _TRUE);
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _BLUE_WRITE_ENABLE,  _TRUE);

    /*
     * Set the Fog color.
     */
    pmtsState->dwFogColor = pdwRenderState[D3DRENDERSTATE_FOGCOLOR];

    cacheFogValues(pContext);

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------------------

void nvSetDefaultMultiTextureHardwareState
(
    PNVD3DCONTEXT pContext
)
{
    DWORD                   dwZOHMode, dwFOHMode, dwTexelOrigin;
    DWORD                   dwTextureOffset;
    DWORD                   dwTextureContextDma;
    DWORD                   dwTextureColorFormat;
    DWORD                   dwMipMapLevels;
    DWORD                   dwLogWidth;
    DWORD                   dwLogHeight;
    CNvObject              *pNvObj;
    CTexture               *pTexture0;
    PNVD3DMULTITEXTURESTATE pmtsState;

    dbgTracePush ("nvSetDefaultMultiTextureHardwareState");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    dwZOHMode     = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_ZOH_MASK) == D3D_REG_TEXELALIGNMENT_ZOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
    dwFOHMode     = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_FOH_MASK) == D3D_REG_TEXELALIGNMENT_FOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;
    dwTexelOrigin = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_TEXEL_MASK) == D3D_REG_TEXELALIGNMENT_TEXEL_CENTER)
                  ? NV054_CONTROL_ORIGIN_CENTER : NV054_CONTROL_ORIGIN_CORNER;

    /*
     * Grab texture from the render state array. This is guaranteed to always have the
     * correct texture no matter if it was set using the render state method or the texture
     * stage 0 method.
     */
    pNvObj    = (CNvObject *)(pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP]);
    pTexture0 = pNvObj ? pNvObj->getTexture() : getDC()->pDefaultTexture; // substitute default texture if none selected
    if(!pTexture0) pTexture0 = getDC()->pDefaultTexture;

    dwTextureOffset      = pTexture0->getSwizzled()->getOffset();
    dwTextureContextDma  = pTexture0->getSwizzled()->getContextDMA();
    dwTextureColorFormat = pTexture0->getFormat();
    dwLogWidth           = pTexture0->getLogWidth();
    dwLogHeight          = pTexture0->getLogHeight();
    dwMipMapLevels       = pTexture0->getMipMapCount();

    pmtsState  = &pContext->mtsState;
    pmtsState->dwTextureOffset[0] =  dwTextureOffset;
    pmtsState->dwTextureFormat[0] =  DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     nv055TextureContextDma[dwTextureContextDma])
                                  |  DRF_NUM(055, _FORMAT, _COLOR,           nv055TextureFormat[dwTextureColorFormat])
                                  |  DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,   dwMipMapLevels)
                                  |  DRF_NUM(055, _FORMAT, _BASE_SIZE_U,     dwLogWidth)
                                  |  DRF_NUM(055, _FORMAT, _BASE_SIZE_V,     dwLogHeight)
                                  |  DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                  |  DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                  |  DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                  |  DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
    pmtsState->dwTextureFormat[0] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,      dwZOHMode)
                                  |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,      dwFOHMode);
    pmtsState->dwTextureFilter[0] =  DRF_NUM(055, _FILTER, _KERNEL_SIZE_X, 0)
                                  |  DRF_NUM(055, _FILTER, _KERNEL_SIZE_Y, 0)
                                  |  DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _FALSE)
                                  |  DRF_DEF(055, _FILTER, _TEXTUREMIN,    _NEAREST)
                                  |  DRF_DEF(055, _FILTER, _ANISOTROPIC_MINIFY_ENABLE, _FALSE)
                                  |  DRF_DEF(055, _FILTER, _TEXTUREMAG,    _NEAREST)
                                  |  DRF_DEF(055, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, _FALSE);

    pmtsState->dwTextureFilter[0] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, getDC()->nvD3DRegistryData.regLODBiasAdjust);

    pmtsState->dwTextureOffset[1] =  getDC()->pDefaultTexture->getSwizzled()->getOffset();
    pmtsState->dwTextureFormat[1] =  DRF_NUM(055, _FORMAT, _CONTEXT_DMA,      nv055TextureContextDma[getDC()->pDefaultTexture->getSwizzled()->getContextDMA()])
                                  |  DRF_NUM(055, _FORMAT, _COLOR,            nv055TextureFormat[getDC()->pDefaultTexture->getFormat()])
                                  |  DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,    1)
                                  |  DRF_DEF(055, _FORMAT, _BASE_SIZE_U,     _1)
                                  |  DRF_DEF(055, _FORMAT, _BASE_SIZE_V,     _1)
                                  |  DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                  |  DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                  |  DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                  |  DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
    pmtsState->dwTextureFormat[1] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,      dwZOHMode)
                                  |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,      dwFOHMode);
    pmtsState->dwTextureFilter[1] =  DRF_NUM(055, _FILTER, _KERNEL_SIZE_X, 0)
                                  |  DRF_NUM(055, _FILTER, _KERNEL_SIZE_Y, 0)
//                                  |  DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE)
                                  |  DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _FALSE)
                                  |  DRF_DEF(055, _FILTER, _TEXTUREMIN,    _NEAREST)
                                  |  DRF_DEF(055, _FILTER, _ANISOTROPIC_MINIFY_ENABLE, _FALSE)
                                  |  DRF_DEF(055, _FILTER, _TEXTUREMAG,    _NEAREST)
                                  |  DRF_DEF(055, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, _FALSE);

    pmtsState->dwTextureFilter[1] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, getDC()->nvD3DRegistryData.regLODBiasAdjust);

    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_DEFAULT;
    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_DEFAULT;
    pmtsState->dwCombine1Alpha = DX6TRI_COMBINE0ALPHA_DEFAULT;;
    pmtsState->dwCombine1Color = DX6TRI_COMBINE0COLOR_DEFAULT;;

    pmtsState->dwCombineFactor = 0;
    pmtsState->dwBlend         = DRF_DEF(055, _BLEND, _MASK_BIT,           _MSB)
                               | DRF_NUM(055, _BLEND, _SHADEMODE,          D3DSHADE_GOURAUD/*pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE]*/) // inner loop takes care of flat shading
                               | DRF_NUM(055, _BLEND, _TEXTUREPERSPECTIVE, pContext->dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE])
                               | DRF_NUM(055, _BLEND, _SPECULARENABLE,     pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE])
                               | DRF_NUM(055, _BLEND, _FOGENABLE,          pContext->dwRenderState[D3DRENDERSTATE_FOGENABLE])
                               | DRF_NUM(055, _BLEND, _ALPHABLENDENABLE,   pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]);

    if (pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_BOTHSRCALPHA)
        pmtsState->dwBlend |= DRF_DEF(055, _BLEND, _SRCBLEND,  _SRCALPHA)
                           |  DRF_DEF(055, _BLEND, _DESTBLEND, _INVSRCALPHA);
    else if (pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_BOTHINVSRCALPHA)
        pmtsState->dwBlend |= DRF_DEF(055, _BLEND, _SRCBLEND,  _INVSRCALPHA)
                           |  DRF_DEF(055, _BLEND, _DESTBLEND, _SRCALPHA);
    else
        pmtsState->dwBlend |= DRF_NUM(055, _BLEND, _SRCBLEND,  pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND])
                           |  DRF_NUM(055, _BLEND, _DESTBLEND, pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND]);

    pmtsState->dwControl0      = DRF_NUM(055, _CONTROL0, _ALPHAREF,             0)
                               | DRF_DEF(055, _CONTROL0, _ALPHAFUNC,            _ALWAYS)
                               | DRF_DEF(055, _CONTROL0, _ALPHATESTENABLE,      _FALSE)
                               | DRF_NUM(055, _CONTROL0, _ORIGIN,               dwTexelOrigin)
                               | DRF_NUM(055, _CONTROL0, _ZFUNC,                CTFunc(pContext,pContext->dwRenderState[D3DRENDERSTATE_ZFUNC]))
                               | DRF_NUM(055, _CONTROL0, _CULLMODE,             pContext->dwRenderState[D3DRENDERSTATE_CULLMODE])
                               | DRF_NUM(055, _CONTROL0, _DITHERENABLE,         pContext->dwRenderState[D3DRENDERSTATE_DITHERENABLE]);

    if ((pContext->pZetaBuffer) && (pContext->dwRenderState[D3DRENDERSTATE_ZENABLE]))
    {
        if ((pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_TRUE)
         || ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_WBUFFERENABLE_MASK) == D3D_REG_WBUFFERENABLE_DISABLE))
        {
            /*
             * Plain Z-Buffer.
             */
            pmtsState->dwControl0 |= DRF_NUM(055, _CONTROL0, _ZENABLE,              pContext->dwRenderState[D3DRENDERSTATE_ZENABLE])
                                  |  DRF_NUM(055, _CONTROL0, _ZWRITEENABLE,         pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                                  |  DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _FALSE)
                                  |  DRF_DEF(055, _CONTROL0, _Z_FORMAT,             _FIXED);
        }
        else
        {
            /*
             * W-Buffer.
             */
            nvAssert (pContext->pRenderTarget);
            if (pContext->pRenderTarget->getBPP() == 2)
            {
                // Fixed point w-buffer reqires scaling of RHW but gives more precision in 16bit w-buffers.
                pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,              _TRUE)
                                      |  DRF_NUM(055, _CONTROL0, _ZWRITEENABLE,         pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                                      |  DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _TRUE)
                                      |  DRF_NUM(055, _CONTROL0, _Z_FORMAT,             getDC()->nvD3DRegistryData.regW16Format);
            }
            else
            {
                // Floating point w-buffer gives more precision for 32-bit (also removes a HW rounding bug with fixed)
                pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,              _TRUE)
                                      |  DRF_NUM(055, _CONTROL0, _ZWRITEENABLE,         pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                                      |  DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _TRUE)
                                      |  DRF_NUM(055, _CONTROL0, _Z_FORMAT,             getDC()->nvD3DRegistryData.regW32Format);
            }
        }
    }
    else
    {
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,      _FALSE)
                              |  DRF_DEF(055, _CONTROL0, _ZWRITEENABLE, _FALSE);
    }
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ALPHA_WRITE_ENABLE,   _FALSE);
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _RED_WRITE_ENABLE,     _TRUE);
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _GREEN_WRITE_ENABLE,   _TRUE);
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _BLUE_WRITE_ENABLE,    _TRUE);
    if (nvStencilBufferInUse(pContext))
    {
        pContext->bStencilEnabled = TRUE;
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _STENCIL_WRITE_ENABLE, _TRUE);
        /*
         * Setup Control1.
         * Stencil buffer control bits.
         */
        pmtsState->dwControl1 = DRF_NUM(055, _CONTROL1, _STENCIL_TEST_ENABLE, pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_FUNC,        pContext->dwRenderState[D3DRENDERSTATE_STENCILFUNC])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_REF,         pContext->dwRenderState[D3DRENDERSTATE_STENCILREF])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_READ,   pContext->dwRenderState[D3DRENDERSTATE_STENCILMASK])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_WRITE,  pContext->dwRenderState[D3DRENDERSTATE_STENCILWRITEMASK]);

        /*
         * Setup Control2.
         * More stencil buffer control bits.
         */
        pmtsState->dwControl2 = DRF_NUM(055, _CONTROL2, _STENCIL_OP_FAIL,  pContext->dwRenderState[D3DRENDERSTATE_STENCILFAIL])
                              | DRF_NUM(055, _CONTROL2, _STENCIL_OP_ZFAIL, pContext->dwRenderState[D3DRENDERSTATE_STENCILZFAIL])
                              | DRF_NUM(055, _CONTROL2, _STENCIL_OP_ZPASS, pContext->dwRenderState[D3DRENDERSTATE_STENCILPASS]);
    }
    else
    {
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _STENCIL_WRITE_ENABLE, _FALSE);

        /*
         * Setup Control1.
         * Stencil buffer control bits.
         */
        pmtsState->dwControl1 = DRF_DEF(055, _CONTROL1, _STENCIL_TEST_ENABLE, _FALSE)
                              | DRF_DEF(055, _CONTROL1, _STENCIL_FUNC,        _NEVER)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_REF,         0)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_READ,   0)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_WRITE,  0);

        /*
         * Setup Control2.
         * More stencil buffer control bits.
         */
        pmtsState->dwControl2 = DRF_DEF(055, _CONTROL2, _STENCIL_OP_FAIL,  _KEEP)
                              | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZFAIL, _KEEP)
                              | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZPASS, _KEEP);
    }
    pmtsState->dwFogColor = pContext->dwRenderState[D3DRENDERSTATE_FOGCOLOR];

    cacheFogValues(pContext);

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------------------

/*
 * The NVIDIA bump mapping algorithm is done in a single pass with four texture stages being specified.
 * This is the only four stage operation that we are supporting. Look for it now and reject any
 * other 4 stage operations.
 */
void nvCalculateBumpMapState
(
    PNVD3DCONTEXT pContext
)
{
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1, ptssState2, ptssState3;
    PNVD3DMULTITEXTURESTATE pmtsState;

    dbgTracePush ("nvCalculateBumpMapState");

    /*
     * Set up some pointers to the individual texture stages.
     */
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];
    ptssState2 = &pContext->tssState[2];
    ptssState3 = &pContext->tssState[3];
    pmtsState  = &pContext->mtsState;

    /*
     * Make specific check for our version of bump mapping.
     *
     * THIS IS A VERY SPECIFIC CHECK FOR OUR BUMP MAPPING ALGORITHM.  ALL CONDITIONS MUST BE
     * TRUE OR WE WILL FAIL VALIDATION AND NOT RENDER ANYTHING PREDICTABLE.
     *
     * Even though D3D specifies that Arg2 cannot be a texture, since we used to do this for
     * our bump mapping algorithm, I'm going to continue to allow it so that we don't break
     * anything.
     */
    if ((ptssState0->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG1)
     || (ptssState0->dwValue[D3DTSS_ALPHAARG1] != (D3DTA_TEXTURE | D3DTA_COMPLEMENT))
     || (ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_DISABLE)
     || (ptssState0->dwValue[D3DTSS_TEXCOORDINDEX] != 0)
     || (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADDSIGNED)
     || (!((ptssState1->dwValue[D3DTSS_ALPHAARG1] == D3DTA_TEXTURE)
        && (ptssState1->dwValue[D3DTSS_ALPHAARG2] == D3DTA_CURRENT))
      && !((ptssState1->dwValue[D3DTSS_ALPHAARG1] == D3DTA_CURRENT)
        && (ptssState1->dwValue[D3DTSS_ALPHAARG2] == D3DTA_TEXTURE)))
     || (ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_DISABLE)
     || (ptssState1->dwValue[D3DTSS_TEXCOORDINDEX] != 1)
     || (ptssState2->dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE)
     || (ptssState2->dwValue[D3DTSS_COLOROP] != D3DTOP_ADDSIGNED2X)
     || (ptssState2->dwValue[D3DTSS_COLORARG1] != (D3DTA_CURRENT | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE))
     || (ptssState2->dwValue[D3DTSS_COLORARG2] != D3DTA_DIFFUSE)
     || (ptssState3->dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE)
     || (ptssState3->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE)
     || (ptssState3->dwValue[D3DTSS_COLORARG1] != D3DTA_TEXTURE)
     || (ptssState3->dwValue[D3DTSS_TEXCOORDINDEX] != 0))
    {
        nvSetDefaultMultiTextureHardwareState (pContext);
        pContext->mtsState.bTSSValid = FALSE;
        pContext->mtsState.ddrval    = D3DERR_TOOMANYOPERATIONS;
        pContext->dwStageCount       = 1;
        pContext->bUseDX6Class       = FALSE;
        /*
         * Note that the state has changed and needs to be sent to the hardware.
         */
        NV_FORCE_TRI_SETUP(pContext);
        dbgTracePop();
        return;
    }
    /*
     * Set up Bump Mapping State.
     *
     * Texture0 and Texture1 comes from stage 0, 1 or 3 (always same texture).
     * Texture0 is used for stages with TEXCOORDINDEX = 0
     * Texture1 is used for stages with TEXCOORDINDEX = 1
     */
    nvSetDX6TextureState (pContext, 0, ptssState0, pmtsState);
    nvSetDX6TextureState (pContext, 1, ptssState1, pmtsState);
    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_BUMP;
    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_BUMP;
    pmtsState->dwCombine1Alpha = DX6TRI_COMBINE1ALPHA_BUMP;
    pmtsState->dwCombine1Color = DX6TRI_COMBINE1COLOR_BUMP;
    nvSetDX6State (pContext, (DWORD *)pContext->dwRenderState, pmtsState);
    /*
     *
     */
    pContext->mtsState.bTSSValid = TRUE;
//    pContext->mtsState.ddrval    = DD_OK; this was set on entry of validate

    /*
     * Enable use of multi-texture triangle class if there is more than one texture
     * stage or if the stencil buffer is enabled.
     */
    pContext->dwStageCount  = 4;
    pContext->bUseDX6Class  = TRUE;
    pContext->bStateChange  = FALSE;

    /*
     * This code is only enabled in the DEBUG build.
     * Display the hardware registers that were calculated.
     */
    dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pContext);

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------------------

void nvCalculateDirectHardwareState
(
    PNVD3DCONTEXT pContext
)
{
    DWORD                   opSelect;
    DWORD                   arg0Select, arg0Invert, arg0AlphaRep;
    DWORD                   arg1Select, arg1Invert, arg1AlphaRep;
    DWORD                   arg2Select, arg2Invert, arg2AlphaRep;
    DWORD                   arg3Select, arg3Invert, arg3AlphaRep;
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1, ptssState2, ptssState3, ptssState4, ptssState5, ptssState6, ptssState7;
    PNVD3DTEXSTAGESTATE     ptssTexture0, ptssTexture1;
    PNVD3DMULTITEXTURESTATE pmtsState;

    dbgTracePush ("nvCalculateDirectHardwareState");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    /*
     * Set up some pointers to the individual texture stages.
     */
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];
    ptssState2 = &pContext->tssState[2];
    ptssState3 = &pContext->tssState[3];
    ptssState4 = &pContext->tssState[4];
    ptssState5 = &pContext->tssState[5];
    ptssState6 = &pContext->tssState[6];
    ptssState7 = &pContext->tssState[7];
    pmtsState  = &pContext->mtsState;

    /*
     * Check the alphaops and colorops.
     *
     * Stages 0, 2, 4, and 6 should all be set as D3DTOP_MODULATE.
     */
    if ((ptssState0->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE)
     || (ptssState0->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE)
     || (ptssState2->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE)
     || (ptssState2->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE)
     || (ptssState4->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE)
     || (ptssState4->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE)
     || (ptssState6->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE)
     || (ptssState6->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE))
        goto invalidDirectHardwareState;

    /*
     * Stages 3 and and 7 should all be set as D3DTOP_SELECTARG1
     */
    if ((ptssState3->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG1)
     || (ptssState3->dwValue[D3DTSS_COLOROP] != D3DTOP_SELECTARG1)
     || (ptssState7->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG1)
     || (ptssState7->dwValue[D3DTSS_COLOROP] != D3DTOP_SELECTARG1))
        goto invalidDirectHardwareState;

    /*
     * Stages 1 and 5 should be one of the following:
     * D3DTOP_ADD, D3DTOP_ADDSIGNED, D3DTOP_ADDSIGNED2X or D3DTOP_SUBTRACT.
     * We also allow D3DTOP_MODULATE2X and D3DTOP_MODULATE4X to be specified
     * but these operations are translated to ADD2 and ADD4 respectively.
     */
    if ((ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADD)
     && (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADDSIGNED)
     && (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADDSIGNED2X)
     && (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SUBTRACT)
     && (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE2X)
     && (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE4X))
        goto invalidDirectHardwareState;

    if ((ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_ADD)
     && (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_ADDSIGNED)
     && (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_ADDSIGNED2X)
     && (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_SUBTRACT)
     && (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE2X)
     && (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE4X))
        goto invalidDirectHardwareState;

    if ((ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADD)
     && (ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADDSIGNED)
     && (ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADDSIGNED2X)
     && (ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SUBTRACT)
     && (ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE2X)
     && (ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE4X))
        goto invalidDirectHardwareState;

    if ((ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_ADD)
     && (ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_ADDSIGNED)
     && (ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_ADDSIGNED2X)
     && (ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_SUBTRACT)
     && (ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE2X)
     && (ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE4X))
        goto invalidDirectHardwareState;

    /*
     * Next track down all the textures being used.
     * The method for selecting the textures is simple:
     *   Map Stage 0 Texture/TextureCoordIndex to TEXTURE0.
     *   Map Stage 1 Texture/TextureCoordIndex to TEXTURE1.
     */
    ptssTexture0 = ptssTexture1 = NULL;
    if (pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP])
        ptssTexture0 = &pContext->tssState[0];
    if (pContext->tssState[1].dwValue[D3DTSS_TEXTUREMAP])
        ptssTexture1 = &pContext->tssState[1];

    /*
     * Set up the textures being used.
     */
    if (ptssTexture0) {
        nvSetDX6TextureState (pContext, 0, ptssTexture0, pmtsState);
    }
    else
    {
        DWORD   dwZOHMode, dwFOHMode;
        dwZOHMode = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_ZOH_MASK) == D3D_REG_TEXELALIGNMENT_ZOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
        dwFOHMode = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_FOH_MASK) == D3D_REG_TEXELALIGNMENT_FOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;

        /*
         * Set the default texture format and offset.
         */
        pmtsState->dwTextureOffset[0] = getDC()->pDefaultTexture->getSwizzled()->getOffset();
        pmtsState->dwTextureFormat[0] = DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     nv055TextureContextDma[getDC()->pDefaultTexture->getSwizzled()->getContextDMA()])
                                      | DRF_NUM(055, _FORMAT, _COLOR,           nv055TextureFormat[getDC()->pDefaultTexture->getFormat()])
                                      | DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,   1)
                                      | DRF_DEF(055, _FORMAT, _BASE_SIZE_U,     _1)
                                      | DRF_DEF(055, _FORMAT, _BASE_SIZE_V,     _1)
                                      | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                      | DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                      | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                      | DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
        pmtsState->dwTextureFormat[0] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,     dwZOHMode)
                                      |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,     dwFOHMode);

        /*
         * Setup stage texture filter
         */
        pmtsState->dwTextureFilter[0] = DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE)
                                      | DRF_NUM(055, _FILTER, _TEXTUREMIN, D3DFILTER_NEAREST)
                                      | DRF_NUM(055, _FILTER, _TEXTUREMAG, D3DFILTER_NEAREST);

        pmtsState->dwTextureFilter[0] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, getDC()->nvD3DRegistryData.regLODBiasAdjust);

        /*
         * Use the first set of texture coordinates when disabled.
         */
        pmtsState->dwUVOffset[0] = 0;
    }
    if (ptssTexture1) {
        nvSetDX6TextureState (pContext, 1, ptssTexture1, pmtsState);
    }
    else
    {
        DWORD   dwZOHMode, dwFOHMode;
        dwZOHMode = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_ZOH_MASK) == D3D_REG_TEXELALIGNMENT_ZOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
        dwFOHMode = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_FOH_MASK) == D3D_REG_TEXELALIGNMENT_FOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;

        /*
         * Set the default texture format and offset.
         */
        pmtsState->dwTextureOffset[1] = getDC()->pDefaultTexture->getSwizzled()->getOffset();
        pmtsState->dwTextureFormat[1] = DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     nv055TextureContextDma[getDC()->pDefaultTexture->getSwizzled()->getContextDMA()])
                                      | DRF_NUM(055, _FORMAT, _COLOR,           nv055TextureFormat[getDC()->pDefaultTexture->getFormat()])
                                      | DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,   1)
                                      | DRF_DEF(055, _FORMAT, _BASE_SIZE_U,     _1)
                                      | DRF_DEF(055, _FORMAT, _BASE_SIZE_V,     _1)
                                      | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                      | DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                      | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                      | DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
        pmtsState->dwTextureFormat[1] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,     dwZOHMode)
                                      |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,     dwFOHMode);

        /*
         * Setup stage texture filter
         */
        pmtsState->dwTextureFilter[1] = DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE)
                                      | DRF_NUM(055, _FILTER, _TEXTUREMIN, D3DFILTER_NEAREST)
                                      | DRF_NUM(055, _FILTER, _TEXTUREMAG, D3DFILTER_NEAREST);

        pmtsState->dwTextureFilter[1] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, getDC()->nvD3DRegistryData.regLODBiasAdjust);

        /*
         * Use the first set of texture coordinates when disabled.
         */
        pmtsState->dwUVOffset[1] = 0;
    }

    /*
     * Setup hardware texture combiner 0 alpha components based on texture stages 0-3.
     * Operation comes from AlphaOp of stage 1.
     * Arguments come from AlphaArg1 of stages 0-3.
     */
    switch (ptssState1->dwValue[D3DTSS_ALPHAOP])
    {
        case D3DTOP_ADD:
            opSelect = NV055_COMBINE_0_ALPHA_OPERATION_ADD;
            break;
        case D3DTOP_ADDSIGNED:
            opSelect = NV055_COMBINE_0_ALPHA_OPERATION_ADDSIGNED;
            break;
        case D3DTOP_ADDSIGNED2X:
            opSelect = NV055_COMBINE_0_ALPHA_OPERATION_ADDSIGNED2;
            break;
        case D3DTOP_SUBTRACT:
            opSelect = NV055_COMBINE_0_ALPHA_OPERATION_ADDCOMPLEMENT;
            break;
        case D3DTOP_MODULATE2X:
            opSelect = NV055_COMBINE_0_ALPHA_OPERATION_ADD2;
            break;
        case D3DTOP_MODULATE4X:
            opSelect = NV055_COMBINE_0_ALPHA_OPERATION_ADD4;
            break;
    }

    /*
     * Select Alpha Argument 0 Combiner 0.
     */
    switch (ptssState0->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg0Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg0Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState0->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg0Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE0;
            else if (ptssTexture1 && ((ptssState0->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg0Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE1;
            else
                arg0Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState0->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg0Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_FACTOR;
            else
                arg0Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_ZERO;
            break;
    }
    arg0Invert = !((ptssState0->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
     * Select Alpha Argument 1 Combiner 0.
     */
    switch (ptssState1->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_1_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_1_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState1->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURE0;
            else if (ptssTexture1 && ((ptssState1->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURE1;
            else
                arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_1_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState1->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_1_FACTOR;
            else
                arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_1_ZERO;
            break;
    }
    arg1Invert = !((ptssState1->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
     * Select Alpha Argument 2 Combiner 0.
     */
    switch (ptssState2->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_2_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_2_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState2->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURE0;
            else if (ptssTexture1 && ((ptssState2->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURE1;
            else
                arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_2_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState2->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_2_FACTOR;
            else
                arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_2_ZERO;
            break;
    }
    arg2Invert = !((ptssState2->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
     * Select Alpha Argument 3 Combiner 0.
     */
    switch (ptssState3->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg3Select = NV055_COMBINE_0_ALPHA_ARGUMENT_3_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg3Select = NV055_COMBINE_0_ALPHA_ARGUMENT_3_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState3->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg3Select = NV055_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURE0;
            else if (ptssTexture1 && ((ptssState3->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg3Select = NV055_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURE1;
            else
                arg3Select = NV055_COMBINE_0_ALPHA_ARGUMENT_3_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState3->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg3Select = NV055_COMBINE_0_ALPHA_ARGUMENT_3_FACTOR;
            else
                arg3Select = NV055_COMBINE_0_ALPHA_ARGUMENT_3_ZERO;
            break;
    }
    arg3Invert = !((ptssState3->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
     * Program Texture Combine 0 Alpha Stage.
     */
    pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg0Invert)
                               |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg0Select)
                               |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_1,  arg1Invert)
                               |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_1, arg1Select)
                               |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                               |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                               |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_3,  arg3Invert)
                               |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_3, arg3Select)
                               |  DRF_NUM(055, _COMBINE_0_ALPHA, _OPERATION,  opSelect);

    /*
     * Setup hardware texture combiner 0 color components based on texture stages 0-3.
     * Operation comes from ColorOp of stage 1.
     * Arguments come from ColorArg1 of stages 0-3.
     */
    switch (ptssState1->dwValue[D3DTSS_COLOROP])
    {
        case D3DTOP_ADD:
            opSelect = NV055_COMBINE_0_COLOR_OPERATION_ADD;
            break;
        case D3DTOP_ADDSIGNED:
            opSelect = NV055_COMBINE_0_COLOR_OPERATION_ADDSIGNED;
            break;
        case D3DTOP_ADDSIGNED2X:
            opSelect = NV055_COMBINE_0_COLOR_OPERATION_ADDSIGNED2;
            break;
        case D3DTOP_SUBTRACT:
            opSelect = NV055_COMBINE_0_COLOR_OPERATION_ADDCOMPLEMENT;
            break;
        case D3DTOP_MODULATE2X:
            opSelect = NV055_COMBINE_0_COLOR_OPERATION_ADD2;
            break;
        case D3DTOP_MODULATE4X:
            opSelect = NV055_COMBINE_0_COLOR_OPERATION_ADD4;
            break;
    }

    /*
     * Select Color Argument 0 Combiner 0.
     */
    switch (ptssState0->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg0Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg0Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState0->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg0Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE0;
            else if (ptssTexture1 && ((ptssState0->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg0Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE1;
            else
                arg0Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState0->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg0Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_FACTOR;
            else
                arg0Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_ZERO;
            break;
    }
    arg0Invert = !((ptssState0->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    arg0AlphaRep = !((ptssState0->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Select Color Argument 1 Combiner 0.
     */
    switch (ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_1_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_1_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_1_TEXTURE0;
            else if (ptssTexture1 && ((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_1_TEXTURE1;
            else
                arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_1_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_1_FACTOR;
            else
                arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_1_ZERO;
            break;
    }
    arg1Invert   = !((ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    arg1AlphaRep = !((ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Select Color Argument 2 Combiner 0.
     */
    switch (ptssState2->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_2_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_2_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState2->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_2_TEXTURE0;
            else if (ptssTexture1 && ((ptssState2->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_2_TEXTURE1;
            else
                arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_2_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState2->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_2_FACTOR;
            else
                arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_2_ZERO;
            break;
    }
    arg2Invert   = !((ptssState2->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    arg2AlphaRep = !((ptssState2->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Select Color Argument 3 Combiner 0.
     */
    switch (ptssState3->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg3Select = NV055_COMBINE_0_COLOR_ARGUMENT_3_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg3Select = NV055_COMBINE_0_COLOR_ARGUMENT_3_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState3->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg3Select = NV055_COMBINE_0_COLOR_ARGUMENT_3_TEXTURE0;
            else if (ptssTexture1 && ((ptssState3->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg3Select = NV055_COMBINE_0_COLOR_ARGUMENT_3_TEXTURE1;
            else
                arg3Select = NV055_COMBINE_0_COLOR_ARGUMENT_3_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState3->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg3Select = NV055_COMBINE_0_COLOR_ARGUMENT_3_FACTOR;
            else
                arg3Select = NV055_COMBINE_0_COLOR_ARGUMENT_3_ZERO;
            break;
    }
    arg3Invert   = !((ptssState3->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    arg3AlphaRep = !((ptssState3->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Program Texture Combine 0 Color Stage.
     */
    pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg0Invert)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg0AlphaRep)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg0Select)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg1Invert)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg1AlphaRep)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg1Select)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_3,  arg3Invert)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_3,    arg3AlphaRep)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_3, arg3Select)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _OPERATION,  opSelect);

    /*
     * Setup hardware texture combiner 1 alpha components based on texture stages 4-7.
     * Operation comes from AlphaOp of stage 5.
     * Arguments come from AlphaArg1 of stages 4-7.
     */
    switch (ptssState5->dwValue[D3DTSS_ALPHAOP])
    {
        case D3DTOP_ADD:
            opSelect = NV055_COMBINE_1_ALPHA_OPERATION_ADD;
            break;
        case D3DTOP_ADDSIGNED:
            opSelect = NV055_COMBINE_1_ALPHA_OPERATION_ADDSIGNED;
            break;
        case D3DTOP_ADDSIGNED2X:
            opSelect = NV055_COMBINE_1_ALPHA_OPERATION_ADDSIGNED2;
            break;
        case D3DTOP_SUBTRACT:
            opSelect = NV055_COMBINE_1_ALPHA_OPERATION_ADDCOMPLEMENT;
            break;
        case D3DTOP_MODULATE2X:
            opSelect = NV055_COMBINE_1_ALPHA_OPERATION_ADD2;
            break;
        case D3DTOP_MODULATE4X:
            opSelect = NV055_COMBINE_1_ALPHA_OPERATION_ADD4;
            break;
    }

    /*
     * Select Alpha Argument 0 Combiner 1.
     */
    switch (ptssState4->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg0Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg0Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState4->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg0Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE0;
            else if (ptssTexture1 && ((ptssState4->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg0Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1;
            else
                arg0Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState4->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg0Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_FACTOR;
            else
                arg0Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_ZERO;
            break;
    }
    arg0Invert = !((ptssState4->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
     * Select Alpha Argument 1 Combiner 1.
     */
    switch (ptssState5->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_1_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_1_INPUT;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState5->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURE0;
            else if (ptssTexture1 && ((ptssState5->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURE1;
            else
                arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_1_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState5->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_1_FACTOR;
            else
                arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_1_ZERO;
            break;
    }
    arg1Invert = !((ptssState5->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
     * Select Alpha Argument 2 Combiner 1.
     */
    switch (ptssState6->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_2_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_2_INPUT;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState6->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURE0;
            else if (ptssTexture1 && ((ptssState6->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURE1;
            else
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_2_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState6->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_2_FACTOR;
            else
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_2_ZERO;
            break;
    }
    arg2Invert = !((ptssState6->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
     * Select Alpha Argument 3 Combiner 1.
     */
    switch (ptssState7->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg3Select = NV055_COMBINE_1_ALPHA_ARGUMENT_3_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg3Select = NV055_COMBINE_1_ALPHA_ARGUMENT_3_INPUT;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState7->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg3Select = NV055_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURE0;
            else if (ptssTexture1 && ((ptssState7->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg3Select = NV055_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURE1;
            else
                arg3Select = NV055_COMBINE_1_ALPHA_ARGUMENT_3_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState7->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg3Select = NV055_COMBINE_1_ALPHA_ARGUMENT_3_FACTOR;
            else
                arg3Select = NV055_COMBINE_1_ALPHA_ARGUMENT_3_ZERO;
            break;
    }
    arg3Invert = !((ptssState7->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
     * Program Texture Combine 1 Alpha Stage.
     */
    pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg0Invert)
                               |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg0Select)
                               |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_1,  arg1Invert)
                               |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_1, arg1Select)
                               |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                               |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                               |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_3,  arg3Invert)
                               |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_3, arg3Select)
                               |  DRF_NUM(055, _COMBINE_1_ALPHA, _OPERATION,  opSelect);

    /*
     * Setup hardware texture combiner 1 color components based on texture stages 4-7.
     * Operation comes from ColorOp of stage 5.
     * Arguments come from ColorArg1 of stages 4-7.
     */
    switch (ptssState5->dwValue[D3DTSS_COLOROP])
    {
        case D3DTOP_ADD:
            opSelect = NV055_COMBINE_1_COLOR_OPERATION_ADD;
            break;
        case D3DTOP_ADDSIGNED:
            opSelect = NV055_COMBINE_1_COLOR_OPERATION_ADDSIGNED;
            break;
        case D3DTOP_ADDSIGNED2X:
            opSelect = NV055_COMBINE_1_COLOR_OPERATION_ADDSIGNED2;
            break;
        case D3DTOP_SUBTRACT:
            opSelect = NV055_COMBINE_1_COLOR_OPERATION_ADDCOMPLEMENT;
            break;
        case D3DTOP_MODULATE2X:
            opSelect = NV055_COMBINE_1_COLOR_OPERATION_ADD2;
            break;
        case D3DTOP_MODULATE4X:
            opSelect = NV055_COMBINE_1_COLOR_OPERATION_ADD4;
            break;
    }

    /*
     * Select Color Argument 0 Combiner 1.
     */
    switch (ptssState4->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg0Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg0Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_INPUT;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState4->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg0Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE0;
            else if (ptssTexture1 && ((ptssState4->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg0Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1;
            else
                arg0Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState4->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg0Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_FACTOR;
            else
                arg0Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_ZERO;
            break;
    }
    arg0Invert = !((ptssState4->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    arg0AlphaRep = !((ptssState4->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Select Color Argument 1 Combiner 1.
     */
    switch (ptssState5->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_1_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_1_INPUT;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState5->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_1_TEXTURE0;
            else if (ptssTexture1 && ((ptssState5->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_1_TEXTURE1;
            else
                arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_1_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState5->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_1_FACTOR;
            else
                arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_1_ZERO;
            break;
    }
    arg1Invert   = !((ptssState5->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    arg1AlphaRep = !((ptssState5->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Select Color Argument 2 Combiner 1.
     */
    switch (ptssState6->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_2_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_2_INPUT;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState6->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_2_TEXTURE0;
            else if (ptssTexture1 && ((ptssState6->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_2_TEXTURE1;
            else
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_2_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState6->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_2_FACTOR;
            else
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_2_ZERO;
            break;
    }
    arg2Invert   = !((ptssState6->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    arg2AlphaRep = !((ptssState6->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Select Color Argument 3 Combiner 1.
     */
    switch (ptssState7->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg3Select = NV055_COMBINE_1_COLOR_ARGUMENT_3_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg3Select = NV055_COMBINE_1_COLOR_ARGUMENT_3_INPUT;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState7->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg3Select = NV055_COMBINE_1_COLOR_ARGUMENT_3_TEXTURE0;
            else if (ptssTexture1 && ((ptssState7->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg3Select = NV055_COMBINE_1_COLOR_ARGUMENT_3_TEXTURE1;
            else
                arg3Select = NV055_COMBINE_1_COLOR_ARGUMENT_3_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState7->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg3Select = NV055_COMBINE_1_COLOR_ARGUMENT_3_FACTOR;
            else
                arg3Select = NV055_COMBINE_1_COLOR_ARGUMENT_3_ZERO;
            break;
    }
    arg3Invert   = !((ptssState7->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    arg3AlphaRep = !((ptssState7->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Program Texture Combine 1 Color Stage.
     */
    pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg0Invert)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg0AlphaRep)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg0Select)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg1Invert)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg1AlphaRep)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg1Select)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_3,  arg3Invert)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_3,    arg3AlphaRep)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_3, arg3Select)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _OPERATION,  opSelect);

    nvSetDX6State (pContext, (DWORD *)pContext->dwRenderState, pmtsState);

    /*
     * Show that the texture stage state is valid.
     */
    pContext->mtsState.bTSSValid = TRUE;
    // pContext->mtsState.ddrval    = DD_OK;

    /*
     * Enable use of multi-texture triangle class if there is more than one texture
     * stage or if the stencil buffer is enabled.
     */
    pContext->dwStageCount  = 8;
    pContext->bUseDX6Class  = TRUE;
    pContext->bStateChange  = FALSE;

    dbgTracePop();
    return;

    /*
     * The texture stage state does not meet the NVIDIA Direct Hardware Mapping requirements.
     * Set the default hardware state and return.
     */
invalidDirectHardwareState:
    nvSetDefaultMultiTextureHardwareState (pContext);
    pContext->mtsState.bTSSValid = FALSE;
    pContext->mtsState.ddrval    = D3DERR_TOOMANYOPERATIONS;
    pContext->dwStageCount       = 1;
    pContext->bUseDX6Class       = FALSE;
    /*
     * Note that the state has changed and needs to be sent to the hardware.
     */
    NV_FORCE_TRI_SETUP(pContext);
    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------------------

inline void nvFailMultiTextureSetup
(
    PNVD3DCONTEXT pContext,
    HRESULT       failureCode
)
{
    nvSetDefaultMultiTextureHardwareState (pContext);
    pContext->mtsState.bTSSValid = FALSE;
    pContext->mtsState.ddrval    = failureCode;
    pContext->dwStageCount       = 1;
    if (!nvStencilBufferInUse (pContext)) {
        pContext->bUseDX6Class = FALSE;
    }
    else {
        pContext->bUseDX6Class = TRUE;
    }

    // Display the hardware registers that were calculated.
    dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pContext);

    // Note that the state has changed and needs to be sent to the hardware.
    NV_FORCE_TRI_SETUP(pContext);
}

//-------------------------------------------------------------------------------------

void nvSetMultiTextureHardwareState
(
    PNVD3DCONTEXT pContext
)
{
#ifdef  DEBUG
    BOOL                    bStage0UsesTexture = FALSE;
    BOOL                    bStage1UsesTexture = FALSE;
#endif  // DEBUG
    DWORD                   dwStageCount;
    DWORD                   dwStageOp;
    DWORD                   arg1Select, arg1Invert, arg1AlphaRep;
    DWORD                   arg2Select, arg2Invert, arg2AlphaRep;
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1;
    PNVD3DMULTITEXTURESTATE pmtsState;
    DWORD                  *pdwRenderState = 0;

    dbgTracePush ("nvSetMultiTextureHardwareState");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    /*
     * This code is only enabled in the DEBUG build.
     * Display the DX5/DX6 render state to be calculated.
     */
    dbgDisplayContextState ((NVDBG_SHOW_RENDER_STATE | NVDBG_SHOW_MTS_STATE), pContext);

    /*
     * Do a quick count of the number of enabled texture stages to be used to determine if
     * special handling is required.
     */
    dwStageCount = 0;
    ptssState0   = &pContext->tssState[dwStageCount];
    while ((dwStageCount < 8)
        && (ptssState0->dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE))
    {
        dwStageCount++;
        if (dwStageCount < 8)
            ptssState0 = &pContext->tssState[dwStageCount];
    }

    /*
     * The hardware cannot handle more than two texture stages being enabled.  However,
     * there are a couple of special cases for 4 and 8 enabled texture stages.  Check if
     * special handling is required now.
     *
     * NVIDIA BUMP MAPPING HANDLING (4 Stages Enabled)
     * If there are four texture stages enabled, this could be the NVIDIA style of bump mapping.
     * Determine if it is.  If it's not, the default hardware state will be set.
     */
    if (dwStageCount == 4)
    {
        nvCalculateBumpMapState (pContext);
        dbgTracePop();
        return;
    }
    /*
     * NVIDIA DIRECT HARDWARE PROGRAMMING
     * When eight texture stages are enabled, this can signify an NVIDIA specific method of programming
     * the texture combiners directly.
     * Determine if this is the special case and program it accordingly.  If it's not, the default hardware
     * state will be set.
     */
    if (((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_DIRECTMAPENABLE_MASK) == D3D_REG_DIRECTMAPENABLE_ENABLE)
     && (dwStageCount == 8))
    {
        nvCalculateDirectHardwareState (pContext);
        dbgTracePop();
        return;
    }


    /*
     * Perform normal processing of the texture stage state setup.
     */
    pdwRenderState = (DWORD *)pContext->dwRenderState;
    pContext->dwStageCount   = 0;
    ptssState0     = &pContext->tssState[0];
    ptssState1     = &pContext->tssState[1];
    pmtsState      = &pContext->mtsState;

    /*
     * Clear out the current state.
     */
    pmtsState->dwTextureOffset[0] = 0;
    pmtsState->dwTextureOffset[1] = 0;
    pmtsState->dwTextureFormat[0] = 0;
    pmtsState->dwTextureFormat[1] = 0;
    pmtsState->dwTextureFilter[0] = 0;
    pmtsState->dwTextureFilter[1] = 0;
    pmtsState->dwCombine0Alpha    = 0;
    pmtsState->dwCombine0Color    = 0;
    pmtsState->dwCombine1Alpha    = 0;
    pmtsState->dwCombine1Color    = 0;
    pmtsState->dwBlend            = 0;
    pmtsState->dwControl0         = 0;
    pmtsState->dwControl1         = 0;
    pmtsState->dwControl2         = 0;
    pmtsState->dwFogColor         = 0;

    /*
     * If D3DRENDERSTATE_TEXTUREMAPBLEND was invoked more recently than TEXTURESTAGESTATE,
     * then use the current TEXTUREMAPBLEND setting.
     */
    if (pContext->bUseTBlendSettings)
    {
        if (!nvStencilBufferInUse (pContext))
        {
            /*
             * When using TEXTUREMAPBLEND settings, as long as there is no stencil buffer we
             * can use the faster DX5 class.
             */
            nvSetHardwareState (pContext);
            pContext->bUseDX6Class       = FALSE;
            pContext->mtsState.bTSSValid = FALSE;
            pContext->bStateChange       = FALSE;
        }
        else
        {
            DWORD   dwZOHMode, dwFOHMode;
            dwZOHMode = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_ZOH_MASK) == D3D_REG_TEXELALIGNMENT_ZOH_CENTER)
                      ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
            dwFOHMode = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_FOH_MASK) == D3D_REG_TEXELALIGNMENT_FOH_CENTER)
                      ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;

            /*
             * Setup stage 0 texture offset
             * Setup stage 0 texture format
             */
            nvSetDX6TextureState (pContext, 0, ptssState0, pmtsState);

            /*
             * Setup combine0 based on the TEXTUREMAPBLEND setting.
             */
            switch (pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND])
            {
                case D3DTBLEND_DECAL:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_DECAL;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_DECAL;
                    break;

                case D3DTBLEND_MODULATE:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_MODULATE;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_MODULATE;
                    break;

                case D3DTBLEND_DECALALPHA:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_DECALALPHA;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_DECALALPHA;
                    break;

                case D3DTBLEND_MODULATEALPHA:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEALPHA;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_MODULATEALPHA;
                    break;

                case D3DTBLEND_DECALMASK:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_DECALMASK;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_DECALMASK;
                    break;

                case D3DTBLEND_MODULATEMASK:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEMASK;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_MODULATEMASK;
                    break;

                case D3DTBLEND_COPY:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_COPY;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_COPY;
                    break;

                case D3DTBLEND_ADD:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_ADD;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_ADD;
                    break;
            }

            /*
             * If there is no texture specified, then set to modulatealpha.
             */
            if (!pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP])
            {
                pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEALPHA;
                pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_MODULATEALPHA;
            }

            /*
             * Set the default texture format and offset.
             */
            pmtsState->dwTextureOffset[1] = getDC()->pDefaultTexture->getSwizzled()->getOffset();
            pmtsState->dwTextureFormat[1] = DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     nv055TextureContextDma[getDC()->pDefaultTexture->getSwizzled()->getContextDMA()])
                                          | DRF_NUM(055, _FORMAT, _COLOR,           nv055TextureFormat[getDC()->pDefaultTexture->getFormat()])
                                          | DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,   1)
                                          | DRF_DEF(055, _FORMAT, _BASE_SIZE_U,     _1)
                                          | DRF_DEF(055, _FORMAT, _BASE_SIZE_V,     _1)
                                          | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                          | DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                          | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                          | DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
            pmtsState->dwTextureFormat[1] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,     dwZOHMode)
                                          |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,     dwFOHMode);

            /*
             * Setup stage texture filter
             */
            pmtsState->dwTextureFilter[1] = DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE)
                                          | DRF_NUM(055, _FILTER, _TEXTUREMIN, D3DFILTER_NEAREST)
                                          | DRF_NUM(055, _FILTER, _TEXTUREMAG, D3DFILTER_NEAREST);

            pmtsState->dwTextureFilter[1] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, getDC()->nvD3DRegistryData.regLODBiasAdjust);

            /*
             * Always set combine1 to pass through.
             */
            pmtsState->dwCombine1Alpha = DX6TRI_COMBINE1ALPHA_PASS_THRU;
            pmtsState->dwCombine1Color = DX6TRI_COMBINE1COLOR_PASS_THRU;

            /*
             * Use the first set of texture coordinates when disabled.
             */
            pmtsState->dwUVOffset[1] = 0;

            /*
             * Setup the rest of the DX6 triangle state.
             */
            nvSetDX6State (pContext, pdwRenderState, pmtsState);

            /*
             * Need to use the DX6 triangle class here.
             */
            pContext->bUseDX6Class       = TRUE;
            pContext->mtsState.bTSSValid = TRUE;
            pContext->bStateChange       = FALSE;

            /*
             * This code is only enabled in the DEBUG build.
             * Display the hardware registers that were calculated.
             */
            dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pContext);
        }

        // pContext->mtsState.ddrval    = DD_OK;
        pContext->dwStageCount       = 1;
        /*
         * Note that the state has changed and needs to be sent to the hardware.
         */
        NV_FORCE_TRI_SETUP(pContext);
        dbgTracePop();
        return;
    }


    /*
     * Compile the hardware state for each texture stage.
     * Any errors during compile will result in disabling multi-textureing.
     *
     * Stage 0.
     */
    if (ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_DISABLE)
    {
        /*
         * No texturing at all!
         */
        if (!nvStencilBufferInUse (pContext))
        {
            nvConvertTextureStageToDX5Class (pContext);
            pContext->bUseDX6Class       = FALSE;
            pContext->mtsState.bTSSValid = FALSE;
            pContext->bStateChange       = FALSE;
        }
        else
        {
            nvSetDefaultMultiTextureHardwareState (pContext);
            pContext->bUseDX6Class       = TRUE;
            pContext->mtsState.bTSSValid = TRUE;
        }
        // pContext->mtsState.ddrval    = DD_OK;
        pContext->dwStageCount       = 1;

        /*
         * This code is only enabled in the DEBUG build.
         * Display the hardware registers that were calculated.
         */
        dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pContext);

        /*
         * Note that the state has changed and needs to be sent to the hardware.
         */
        NV_FORCE_TRI_SETUP(pContext);
        dbgTracePop();
        return;
    }

    /*
     * Check for a texture stage state that can be handled by the DX5 class.
     */
    if ((ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_DISABLE)
     && (!nvStencilBufferInUse (pContext)))
    {
        /*
         * If there's only one texture stage, and no stencil buffer.
         * There's an opportunity to use the DX5 class for this
         * operation and get 2 Pixels per clock.
         */
        if (nvConvertTextureStageToDX5Class (pContext))
        {
            /*
             * Single texture stage was converted to DX5 class.
             * Use it instead.
             */
            pContext->bUseDX6Class  = FALSE;
            pContext->bStateChange  = FALSE;

            /*
             * Show that the DX6 class state is not calculated.
             */
            pContext->mtsState.bTSSValid = FALSE;
            // pContext->mtsState.ddrval    = DD_OK;
            dbgTracePop();
            return;
        }
        if (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE)
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "D3D:nvSetMultiTextureHardwareState - Single Texture Stage Using DX6 Class!!!");
    }

    /*
     * Setup stage 0 texture offset
     * Setup stage 0 texture format
     */
    nvSetDX6TextureState (pContext, 0, ptssState0, pmtsState);

    /*
     * Setup stage 0 Alpha Combiner.
     */
    dwStageOp = ptssState0->dwValue[D3DTSS_ALPHAOP];
    if((dwStageOp!=D3DTOP_SELECTARG2)&&(dwStageOp!=D3DTOP_DISABLE))
    {

        switch (ptssState0->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
        {
        case D3DTA_DIFFUSE:
            arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssState0->dwValue[D3DTSS_TEXTUREMAP]) {
                arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE0;
            }
            else {
                // Disable Arg1 if there is no texture handle selected.
                arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
                dwStageOp  = D3DTOP_SELECTARG1;
            }
            break;
        case D3DTA_TFACTOR:
            arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_FACTOR;
            break;

        default:   // (including D3DTA_SPECULAR in DX7)
            nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDALPHAARG);
            dbgTracePop();
            return;
        }
        arg1Invert = !((ptssState0->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);
    }

    if((dwStageOp!=D3DTOP_SELECTARG1)&&(dwStageOp!=D3DTOP_DISABLE))
    {

        switch (ptssState0->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK)
        {
        case D3DTA_DIFFUSE:
            arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            // D3DTA_TEXTURE isn't really a valid argument for Arg2.
            if (ptssState0->dwValue[D3DTSS_TEXTUREMAP])
                arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE0;
            else
                arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_FACTOR;
            break;

        default:   // (including D3DTA_SPECULAR in DX7)
            nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDALPHAARG);
            dbgTracePop();
            return;
        }
        arg2Invert = !((ptssState0->dwValue[D3DTSS_ALPHAARG2] & D3DTA_COMPLEMENT) == 0);
    }

#ifdef  DEBUG
    if ((arg1Select == NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE0)
     && (ptssState0->dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE)
     && (ptssState0->dwValue[D3DTSS_TEXTUREMAP]))
        bStage0UsesTexture = TRUE;
#endif  // DEBUG

    switch (dwStageOp)
    {
        case D3DTOP_DISABLE:
            pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_DISABLE;
            break;
        case D3DTOP_SELECTARG1:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_SELECTARG2:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_1, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE2X:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE4X:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD2);
            break;
        case D3DTOP_ADD:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_ADDSIGNED:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADDSIGNED);
            break;
        case D3DTOP_ADDSIGNED2X:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADDSIGNED2);
            break;
        case D3DTOP_SUBTRACT:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADDCOMPLEMENT);
            break;
        case D3DTOP_ADDSMOOTH:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  (arg1Invert ^ NV055_COMBINE_0_ALPHA_INVERSE_2_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDDIFFUSEALPHA:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _DIFFUSE)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _DIFFUSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDTEXTUREALPHA:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _TEXTURE0)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _TEXTURE0)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDFACTORALPHA:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _FACTOR)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _FACTOR)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDTEXTUREALPHAPM:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _TEXTURE0)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDCURRENTALPHA:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _DIFFUSE)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _DIFFUSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_PREMODULATE:
            if (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE)
            {
                DWORD   arg1InvertStage1;
                DWORD   arg1SelectStage1;

                if (ptssState1->dwValue[D3DTSS_TEXTUREMAP])
                    arg1SelectStage1 = NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE1;
                else
                    arg1SelectStage1 = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
                arg1InvertStage1 = NV055_COMBINE_0_ALPHA_INVERSE_1_NORMAL;

                pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_1,  arg1InvertStage1)
                                           |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_1, arg1SelectStage1)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            }
            else
            {
                /*
                 * When second texture stage is disabled, this is the same as SELECTARG1.
                 */
                pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            }
            break;
        default:
            nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDALPHAOPERATION);
            dbgTracePop();
            return;
    }

    /*
     * Setup stage 0 Color Combiner.
     */
    dwStageOp = ptssState0->dwValue[D3DTSS_COLOROP];

    if((dwStageOp!=D3DTOP_SELECTARG2)&&(dwStageOp!=D3DTOP_DISABLE))
    {
        switch (ptssState0->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
        {
        case D3DTA_DIFFUSE:
            arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssState0->dwValue[D3DTSS_TEXTUREMAP]) {
                arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE0;
            }
            else {
                // Disable Arg1 if there is no texture handle selected.
                arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
                dwStageOp  = D3DTOP_SELECTARG1;
            }
            break;
        case D3DTA_TFACTOR:
            arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_FACTOR;
            break;

        default:   // (including D3DTA_SPECULAR in DX7)
            nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDCOLORARG);
            dbgTracePop();
            return;
        }
        arg1Invert   = !((ptssState0->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
        arg1AlphaRep = !((ptssState0->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);
    }

    if((dwStageOp!=D3DTOP_SELECTARG1)&&(dwStageOp!=D3DTOP_DISABLE))
    {
        switch (ptssState0->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK)
        {
        case D3DTA_DIFFUSE:
            arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            // D3DTA_TEXTURE isn't really a valid argument for Arg2.
            if (ptssState0->dwValue[D3DTSS_TEXTUREMAP])
                arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE0;
            else
                arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_FACTOR;
            break;

        default:   // (including D3DTA_SPECULAR in DX7)
            nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDCOLORARG);
            dbgTracePop();
            return;
        }
        arg2Invert   = !((ptssState0->dwValue[D3DTSS_COLORARG2] & D3DTA_COMPLEMENT) == 0);
        arg2AlphaRep = !((ptssState0->dwValue[D3DTSS_COLORARG2] & D3DTA_ALPHAREPLICATE) == 0);
    }

#ifdef  DEBUG
    if ((arg1Select == NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE0)
     && (ptssState0->dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE)
     && (ptssState0->dwValue[D3DTSS_TEXTUREMAP]))
        bStage0UsesTexture = TRUE;
#endif  // DEBUG

    switch (dwStageOp)
    {
        case D3DTOP_DISABLE:
            pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_DISABLE;
            break;
        case D3DTOP_SELECTARG1:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_SELECTARG2:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE2X:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_3,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE4X:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_3,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD2);
            break;
        case D3DTOP_ADD:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_ADDSIGNED:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADDSIGNED);
            break;
        case D3DTOP_ADDSIGNED2X:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADDSIGNED2);
            break;
        case D3DTOP_SUBTRACT:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADDCOMPLEMENT);
            break;
        case D3DTOP_ADDSMOOTH:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_2_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_3,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDDIFFUSEALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _DIFFUSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDTEXTUREALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _TEXTURE0)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _TEXTURE0)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDFACTORALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _FACTOR)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _FACTOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDTEXTUREALPHAPM:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _TEXTURE0)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDCURRENTALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _DIFFUSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_PREMODULATE:
            if (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE)
            {
                DWORD   arg1InvertStage1;
                DWORD   arg1AlphaRepStage1;
                DWORD   arg1SelectStage1;

                if (ptssState1->dwValue[D3DTSS_TEXTUREMAP])
                    arg1SelectStage1 = NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE1;
                else
                    arg1SelectStage1 = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
                arg1InvertStage1   = NV055_COMBINE_0_COLOR_INVERSE_1_NORMAL;
                arg1AlphaRepStage1 = NV055_COMBINE_0_COLOR_ALPHA_1_COLOR;

                pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg1InvertStage1)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg1AlphaRepStage1)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg1SelectStage1)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            }
            else
            {
                /*
                 * When second texture stage is disabled, this is the same as SELECTARG1.
                 */
                pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            }
            break;

        case D3DTOP_MODULATEALPHA_ADDCOLOR:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    _ALPHA)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATECOLOR_ADDALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    _ALPHA)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    _ALPHA)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    _ALPHA)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        default:
            nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDCOLOROPERATION);
            dbgTracePop();
            return;
    }
    pContext->dwStageCount++;

    /*
     * Stage 1.
     */
    if (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE)
    {
        nvSetDX6TextureState (pContext, 1, ptssState1, pmtsState);

        /*
         * Setup stage 1 Alpha Combiner.
         */
        dwStageOp = ptssState1->dwValue[D3DTSS_ALPHAOP];

        if((dwStageOp!=D3DTOP_SELECTARG2)&&(dwStageOp!=D3DTOP_DISABLE))
        {
            switch (ptssState1->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
            {
            case D3DTA_DIFFUSE:
                arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_DIFFUSE;
                break;
            case D3DTA_CURRENT:
                arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT;
                break;
            case D3DTA_TEXTURE:
                if (ptssState1->dwValue[D3DTSS_TEXTUREMAP]) {
                    arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1;
                }
                else {
                    // Disable Arg1 if there is no texture handle selected.
                    arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT;
                    // dwStageOp  = D3DTOP_SELECTARG1;
                }
                break;
            case D3DTA_TFACTOR:
                arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_FACTOR;
                break;
            default:
                nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDALPHAARG);
                dbgTracePop();
                return;
            }
            arg1Invert = !((ptssState1->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);
        }

        if((dwStageOp!=D3DTOP_SELECTARG1)&&(dwStageOp!=D3DTOP_DISABLE))
        {
            switch (ptssState1->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK)
            {
            case D3DTA_DIFFUSE:
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_DIFFUSE;
                break;
            case D3DTA_CURRENT:
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT;
                break;
            case D3DTA_TEXTURE:
                // D3DTA_TEXTURE isn't really a valid argument for Arg2.
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1;
                break;
            case D3DTA_TFACTOR:
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_FACTOR;
                break;
            default:
                nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDALPHAARG);
                dbgTracePop();
                return;
            }
            arg2Invert = !((ptssState1->dwValue[D3DTSS_ALPHAARG2] & D3DTA_COMPLEMENT) == 0);
        }

#ifdef  DEBUG
        if ((arg1Select == NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1)
         && (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE)
         && (ptssState1->dwValue[D3DTSS_TEXTUREMAP]))
            bStage1UsesTexture = TRUE;
#endif  // DEBUG

        switch (dwStageOp)
        {
            case D3DTOP_DISABLE:
                pmtsState->dwCombine1Alpha = DX6TRI_COMBINE1ALPHA_PASS_THRU;//DX6TRI_COMBINE1ALPHA_DISABLE;
                break;
            case D3DTOP_SELECTARG1:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_SELECTARG2:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_1, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE2X:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE4X:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD2);
                break;
            case D3DTOP_ADD:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_ADDSIGNED:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADDSIGNED);
                break;
            case D3DTOP_ADDSIGNED2X:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADDSIGNED2);
                break;
            case D3DTOP_SUBTRACT:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADDCOMPLEMENT);
                break;
            case D3DTOP_ADDSMOOTH:

                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  (arg1Invert ^ NV055_COMBINE_1_ALPHA_INVERSE_2_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDDIFFUSEALPHA:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _DIFFUSE)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _DIFFUSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDTEXTUREALPHA:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _TEXTURE1)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _TEXTURE1)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDFACTORALPHA:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _FACTOR)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _FACTOR)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDTEXTUREALPHAPM:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _TEXTURE1)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDCURRENTALPHA:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _INPUT)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _INPUT)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_PREMODULATE:
                /*
                 * When premodulate is set on stage 1, this is the same as just a selctarg1 since we
                 * don't support more than 2 texture stages.
                 * It would seem rather silly to do this on stage 1 anyway because you lose whatever was
                 * set on stage 0.
                 */
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            default:
                nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDALPHAOPERATION);
                dbgTracePop();
                return;
        }

        /*
         * Setup stage 1 Color Combiner.
         */
        dwStageOp = ptssState1->dwValue[D3DTSS_COLOROP];

        if((dwStageOp!=D3DTOP_SELECTARG2)&&(dwStageOp!=D3DTOP_DISABLE))
        {
        switch (ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
        {
            case D3DTA_DIFFUSE:
                arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_DIFFUSE;
                break;
            case D3DTA_CURRENT:
                arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_INPUT;
                break;
            case D3DTA_TEXTURE:
                if (ptssState1->dwValue[D3DTSS_TEXTUREMAP]) {
                    arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1;
                }
                else {
                    // Disable Arg1 if there is no texture handle selected.
                    arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT;
                    // dwStageOp  = D3DTOP_SELECTARG1;
                }
                break;
            case D3DTA_TFACTOR:
                arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_FACTOR;
                break;

            default:
                nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDCOLORARG);
                dbgTracePop();
                return;
        }
        arg1Invert   = !((ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
        arg1AlphaRep = !((ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);
        }

        if((dwStageOp!=D3DTOP_SELECTARG1)&&(dwStageOp!=D3DTOP_DISABLE))
        {
            switch (ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK)
            {
            case D3DTA_DIFFUSE:
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_DIFFUSE;
                break;
            case D3DTA_CURRENT:
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_INPUT;
                break;
            case D3DTA_TEXTURE:
                // D3DTA_TEXTURE isn't really a valid argument for Arg2.
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1;
                break;
            case D3DTA_TFACTOR:
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_FACTOR;
                break;

            default:
                nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDCOLORARG);
                dbgTracePop();
                return;
            }
            arg2Invert   = !((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_COMPLEMENT) == 0);
            arg2AlphaRep = !((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_ALPHAREPLICATE) == 0);
        }

#ifdef  DEBUG
        if ((arg1Select == NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1)
         && (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE)
         && (ptssState1->dwValue[D3DTSS_TEXTUREMAP]))
            bStage1UsesTexture = TRUE;
#endif  // DEBUG

        switch (dwStageOp)
        {
            case D3DTOP_DISABLE:
                pmtsState->dwCombine1Color = DX6TRI_COMBINE1COLOR_DISABLE;
                break;
            case D3DTOP_SELECTARG1:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_SELECTARG2:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE2X:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_3,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE4X:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_3,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD2);
                break;
            case D3DTOP_ADD:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_ADDSIGNED:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADDSIGNED);
                break;
            case D3DTOP_ADDSIGNED2X:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADDSIGNED2);
                break;
            case D3DTOP_SUBTRACT:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADDCOMPLEMENT);
                break;
            case D3DTOP_ADDSMOOTH:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  (arg1Invert ^ NV055_COMBINE_1_COLOR_INVERSE_2_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_3,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDDIFFUSEALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _DIFFUSE)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _DIFFUSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDTEXTUREALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _TEXTURE1)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _TEXTURE1)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDFACTORALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _FACTOR)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _FACTOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDTEXTUREALPHAPM:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _TEXTURE1)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDCURRENTALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _INPUT)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _INPUT)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_PREMODULATE:
                /*
                 * When premodulate is set on stage 1, this is the same as just a selctarg1 since we
                 * don't support more than 2 texture stages.
                 * It would seem rather silly to do this on stage 1 anyway because you lose whatever was
                 * set on stage 0.
                 */
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATEALPHA_ADDCOLOR:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    _ALPHA)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATECOLOR_ADDALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    _ALPHA)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_1_COLOR_INVERSE_0_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    _ALPHA)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_1_COLOR_INVERSE_0_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    _ALPHA)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            default:
                nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDCOLOROPERATION);
                dbgTracePop();
                return;
        }

        pContext->dwStageCount++;

#ifdef  DEBUG
        if (bStage0UsesTexture && bStage1UsesTexture)
        {
            CTexture *pTexture0, *pTexture1;
            pTexture0 = ((CNvObject *)(ptssState0->dwValue[D3DTSS_TEXTUREMAP]))->getTexture();
            pTexture1 = ((CNvObject *)(ptssState1->dwValue[D3DTSS_TEXTUREMAP]))->getTexture();
            
            if(!pTexture0 || !pTexture1){
                DPF("D3D:nvSetMultiTextureHardwareState - Multi-Textures Memory Space Error!!");
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "        pTexture0Obj = %08x,  Texture = %08x", ptssState0->dwValue[D3DTSS_TEXTUREMAP], pTexture0);
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "        pTexture1Obj = %08x,  Texture = %08x", ptssState1->dwValue[D3DTSS_TEXTUREMAP], pTexture1);
            }
            else {

                if (pTexture0->getSwizzled()->getContextDMA() != pTexture1->getSwizzled()->getContextDMA())
                {
                    DPF("D3D:nvSetMultiTextureHardwareState - Multi-Textures Memory Space Error!!");
                    DPF_LEVEL(NVDBG_LEVEL_ERROR, "        pTexture0 = %08x,  Context = %08x", ptssState0->dwValue[D3DTSS_TEXTUREMAP], pTexture0->getSwizzled()->getContextDMA());
                    DPF_LEVEL(NVDBG_LEVEL_ERROR, "        pTexture1 = %08x,  Context = %08x", ptssState1->dwValue[D3DTSS_TEXTUREMAP], pTexture1->getSwizzled()->getContextDMA());
                }
                else
                {
                    DPF_LEVEL(NVDBG_LEVEL_ERROR, "D3D:nvSetMultiTextureHardwareState - YEAH! Multi-Textures Memory Space OK!!");
                    DPF_LEVEL(NVDBG_LEVEL_ERROR, "        pTexture0 = %08x,  Context = %08x", ptssState0->dwValue[D3DTSS_TEXTUREMAP], pTexture0->getSwizzled()->getContextDMA());
                    DPF_LEVEL(NVDBG_LEVEL_ERROR, "        pTexture1 = %08x,  Context = %08x", ptssState1->dwValue[D3DTSS_TEXTUREMAP], pTexture1->getSwizzled()->getContextDMA());
                }
            }
        }
#endif  // DEBUG

    }

    else
    {
        DWORD   dwZOHMode, dwFOHMode;
        dwZOHMode = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_ZOH_MASK) == D3D_REG_TEXELALIGNMENT_ZOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
        dwFOHMode = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_FOH_MASK) == D3D_REG_TEXELALIGNMENT_FOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;

        /*
         * Set the default texture format and offset.
         */
        pmtsState->dwTextureOffset[1] = getDC()->pDefaultTexture->getSwizzled()->getOffset();
        pmtsState->dwTextureFormat[1] = DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     nv055TextureContextDma[getDC()->pDefaultTexture->getSwizzled()->getContextDMA()])
                                      | DRF_NUM(055, _FORMAT, _COLOR,           nv055TextureFormat[getDC()->pDefaultTexture->getFormat()])
                                      | DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,   1)
                                      | DRF_DEF(055, _FORMAT, _BASE_SIZE_U,     _1)
                                      | DRF_DEF(055, _FORMAT, _BASE_SIZE_V,     _1)
                                      | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                      | DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                      | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                      | DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
        pmtsState->dwTextureFormat[1] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,     dwZOHMode)
                                      |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,     dwFOHMode);

        /*
         * Setup stage texture filter
         */
        pmtsState->dwTextureFilter[1] = DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE)
                                      | DRF_NUM(055, _FILTER, _TEXTUREMIN, D3DFILTER_NEAREST)
                                      | DRF_NUM(055, _FILTER, _TEXTUREMAG, D3DFILTER_NEAREST);

        pmtsState->dwTextureFilter[1] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, getDC()->nvD3DRegistryData.regLODBiasAdjust);

        /*
         * No stage 1 texture blending.
         * Set the stage 1 combiners to something sane.
         */
        pmtsState->dwCombine1Alpha = DX6TRI_COMBINE1ALPHA_PASS_THRU;
        pmtsState->dwCombine1Color = DX6TRI_COMBINE1COLOR_PASS_THRU;

        /*
         * Use the first set of texture coordinates when disabled.
         */
        pmtsState->dwUVOffset[1] = 0;

    }

    /*
     * handle textures that are unaligned
     *
     * this happens when a mipmap chain is created and the app selects one
     *  of the unaligned lower level mipmaps as the base texture
     * aka HW alignment limitation
     */
    if (pmtsState->dwTextureOffset[0] & 0xff)
    {
        CTexture *pTexture;
        DWORD     dwSize;
        DWORD     dwAddr;

        /*
         * get the texture that is involved
         */
        pTexture = ((CNvObject *)(ptssState0->dwValue[D3DTSS_TEXTUREMAP]))->getTexture();
        if (!pTexture){
            pTexture = getDC()->pDefaultTexture;
        }

        /*
         * get source address
         */
        dwAddr = pTexture->getSwizzled()->getAddress();

        /*
         * determine how many bytes to move
         */
        dwSize = pTexture->getBaseTexture()->getSwizzled()->getSize()
               - (pTexture->getSwizzled()->getOffset() - pTexture->getBaseTexture()->getSwizzled()->getOffset());

        /*
         * move them to spare texture 0
         */
        nvMemCopy (getDC()->dwSpareTextureOffset[0] + VIDMEM_ADDR(pDriverData->BaseAddress),dwAddr,dwSize);

        /*
         * modify texture source
         */
        pmtsState->dwTextureOffset[0]  = getDC()->dwSpareTextureOffset[0];
        pmtsState->dwTextureFormat[0] &= ~0xf;
        pmtsState->dwTextureFormat[0] |= nv055TextureContextDma[NV_CONTEXT_DMA_VID];
    }

    if (pmtsState->dwTextureOffset[1] & 0xff)
    {
        CTexture *pTexture;
        DWORD         dwSize;
        DWORD         dwAddr;

        /*
         * get the texture that is involved
         */
        pTexture = ((CNvObject *)(ptssState1->dwValue[D3DTSS_TEXTUREMAP]))->getTexture();
        if (!pTexture){
            pTexture = getDC()->pDefaultTexture;
        }

        /*
         * get source address
         */
        dwAddr = pTexture->getSwizzled()->getAddress();

        /*
         * determine how many bytes to move
         */
        dwSize = pTexture->getBaseTexture()->getSwizzled()->getSize()
               - (pTexture->getSwizzled()->getOffset() - pTexture->getBaseTexture()->getSwizzled()->getOffset());

        /*
         * move them to spare texture 1
         */
        nvMemCopy (getDC()->dwSpareTextureOffset[1] + VIDMEM_ADDR(pDriverData->BaseAddress),dwAddr,dwSize);

        /*
         * modify texture source
         */
        pmtsState->dwTextureOffset[1]  = getDC()->dwSpareTextureOffset[1];
        pmtsState->dwTextureFormat[1] &= ~0xf;
        pmtsState->dwTextureFormat[1] |= nv055TextureContextDma[NV_CONTEXT_DMA_VID];
    }

    nvSetDX6State (pContext, pdwRenderState, pmtsState);

    /*
     * At this point, only stages 0 and 1 should be enabled at most.  If both are
     * enabled and stage 2 is enabled also, then this is an error.  Flag it but the
     * hardware will still use the first two stages of setup.
     */
    if ((pContext->tssState[0].dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE)
     && (pContext->tssState[1].dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE)
     && (pContext->tssState[2].dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE))
    {
        pContext->mtsState.bTSSValid = FALSE;
        pContext->mtsState.ddrval    = D3DERR_TOOMANYOPERATIONS;
        pContext->bUseDX6Class       = TRUE;

        /*
         * This code is only enabled in the DEBUG build.
         * Display the hardware registers that were calculated.
         */
        dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pContext);

        dbgTracePop();
        return;
    }

    pContext->mtsState.bTSSValid = TRUE;
//    pContext->mtsState.ddrval    = DD_OK;

    /*
     * Assume that the DX6 class is going to be used for rendering.
     * stage or if the stencil buffer is enabled.
     */
    pContext->bUseDX6Class = TRUE;
    pContext->bStateChange = FALSE;

    /*
     * This code is only enabled in the DEBUG build.
     * Display the hardware registers that were calculated.
     */
    dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pContext);
    dbgTracePop();
    return;
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvSemaphore.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvSemaphore.cpp
//      a semaphore class, for use with kelvin-style semaphores
//      handles allocation and management
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        13Sep2000         created, NV20 development
//
// **************************************************************************

#include "nvprecomp.h"
#pragma hdrstop

#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES

//---------------------------------------------------------------------------

// acquire a sempahore

BOOL CSemaphore::acquire (DWORD dwValue, CPushBuffer *pPusher)
{
    pPusher->push (0, (0x00040000 | NV206E_SEMAPHORE_OFFSET));
    pPusher->push (1, m_dwOffset);
    pPusher->push (2, (0x00040000 | NV206E_SEMAPHORE_ACQUIRE));
    pPusher->push (3, dwValue);
    pPusher->adjust (4);
    return (TRUE);
}

//---------------------------------------------------------------------------

// release a semaphore via the channel

BOOL CSemaphore::release (DWORD dwValue, CPushBuffer *pPusher)
{
    pPusher->push (0, (0x00040000 | NV206E_SEMAPHORE_OFFSET));
    pPusher->push (1, m_dwOffset);
    pPusher->push (2, (0x00040000 | NV206E_SEMAPHORE_RELEASE));
    pPusher->push (3, dwValue);
    pPusher->adjust (4);
    return (TRUE);
}

//---------------------------------------------------------------------------

// release a semaphore through a class interface

BOOL CSemaphore::release (DWORD dwValue, CPushBuffer *pPusher, DWORD dwSubCh, DWORD dwType)
{
    switch (dwType) {
        case SEMAPHORE_RELEASE_KELVIN_BACKEND:
            pPusher->push (0, (0x00040000 | (dwSubCh << 13) | NV097_SET_SEMAPHORE_OFFSET));
            pPusher->push (1, m_dwOffset);
            pPusher->push (2, (0x00040000 | (dwSubCh << 13) | NV097_BACK_END_WRITE_SEMAPHORE_RELEASE));
            pPusher->push (3, dwValue);
            pPusher->adjust (4);
            break;
        case SEMAPHORE_RELEASE_KELVIN_TEXTURE:
            pPusher->push (0, (0x00040000 | (dwSubCh << 13) | NV097_SET_SEMAPHORE_OFFSET));
            pPusher->push (1, m_dwOffset);
            pPusher->push (2, (0x00040000 | (dwSubCh << 13) | NV097_TEXTURE_READ_SEMAPHORE_RELEASE));
            pPusher->push (3, dwValue);
            pPusher->adjust (4);
            break;
        case SEMAPHORE_RELEASE_DAC:
            pPusher->push (0, (0x00040000 | (dwSubCh << 13) | NV07C_SET_SEMAPHORE_OFFSET));
            pPusher->push (1, m_dwOffset);
            pPusher->push (2, (0x00040000 | (dwSubCh << 13) | NV07C_SET_SEMAPHORE_RELEASE));
            pPusher->push (3, dwValue);
            pPusher->adjust (4);
            break;
        default:
            DPF ("unknown semaphore release type");
            dbgD3DError();
            break;
    } // switch
    return (TRUE);
}

//---------------------------------------------------------------------------

// create a manager for a page of semaphores

BOOL CSemaphoreManager::create (void)
{
    DWORD dwSize = 2*PAGE_SIZE;  // allocate two pages to insure successful alignment

    // allocate the surface
    m_pSemaphoreSurface = new CSimpleSurface;
    if (!m_pSemaphoreSurface) {
        return (FALSE);
    }

    // create the semaphores
    if (!m_pSemaphoreSurface->create (dwSize, 1, 1, 0,
                                      CSimpleSurface::HEAP_VID,
                                      CSimpleSurface::HEAP_VID,
                                      CSimpleSurface::ALLOCATE_SIMPLE
                                      #ifdef CAPTURE
                                      ,CAPTURE_SURFACE_KIND_UNKNOWN
                                      #endif
                                     )) {
        return (FALSE);
    }

    // align to the beginning of the first page contained in our allocated memory
    m_pSemaphoreMemory = (BYTE*)((m_pSemaphoreSurface->getAddress() + PAGE_SIZE - 1) & PAGE_MASK);

    // map a context dma to the page of semaphores
    if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                             SEMAPHORE_CONTEXT_DMA_IN_MEMORY,
                             NV01_CONTEXT_DMA,
                             DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                             DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
                             (PVOID) m_pSemaphoreMemory,
                             PAGE_SIZE-1)) {
        return (FALSE);
    }
    if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                             SEMAPHORE_CONTEXT_DMA_FROM_MEMORY,
                             NV01_CONTEXT_DMA,
                             DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_ONLY) |
                             DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
                             (PVOID) m_pSemaphoreMemory,
                             PAGE_SIZE-1)) {
        return (FALSE);
    }

    // initialize the semaphores (in particular, the bInUse field)
    memset (m_pSemaphoreMemory, FALSE, PAGE_SIZE);

    // success
    return (TRUE);
}

//---------------------------------------------------------------------------

// destroy the semaphore manager

BOOL CSemaphoreManager::destroy (void)
{
    // free the context dmas
    NvRmFree (pDriverData->dwRootHandle, pDriverData->dwRootHandle, SEMAPHORE_CONTEXT_DMA_IN_MEMORY);
    NvRmFree (pDriverData->dwRootHandle, pDriverData->dwRootHandle, SEMAPHORE_CONTEXT_DMA_FROM_MEMORY);
    // free the semaphores and delete the surface
    if (m_pSemaphoreSurface) {
        m_pSemaphoreSurface->destroy();
        delete m_pSemaphoreSurface;
    }
    m_pSemaphoreSurface = (CSimpleSurface *)NULL;
    m_pSemaphoreMemory  = NULL;
    return (TRUE);
}

//---------------------------------------------------------------------------

// allocate a new semaphore

CSemaphore *CSemaphoreManager::allocate (DWORD dwInitialValue)
{
    CSemaphore *pSem = (CSemaphore *)m_pSemaphoreMemory;

    while (((PBYTE)pSem) < ((PBYTE)(m_pSemaphoreMemory + PAGE_SIZE))) {
        if (!pSem->m_bInUse) {
            pSem->m_dwValue = dwInitialValue;
            pSem->m_dwOffset = (DWORD)pSem - (DWORD)m_pSemaphoreMemory;
            pSem->m_bInUse = TRUE;
            return (pSem);
        }
        pSem ++;
    }

    return (NULL);
}

//---------------------------------------------------------------------------

// free a semaphore

BOOL CSemaphoreManager::free (CSemaphore *pSem)
{
    pSem->m_bInUse = FALSE;
    return (TRUE);
}

#endif  // KELVIN_SEMAPHORES
#endif  // NVARCH >= 0x020
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvScene.cpp ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvScene.cpp                                                       *
*   The Direct3D HAL scene capture routines is implemented in this module.  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       03/24/97 - wrote and cleaned up.        *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#ifdef NV_MARKER
DWORD dwMarkerCount = 0;
#endif

/*
 * Scene Capture start and end points
 */
DWORD __stdcall nvSceneCapture
(
    LPD3DHAL_SCENECAPTUREDATA pscd
)
{
    NvNotification *pPusherSyncNotifier;

    dbgTracePush ("nvSceneCapture");

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pscd);

    // Get pointer to global driver. data structure.
    nvSetDriverDataPtrFromContext(pContext);

    // Need to make sure that an unfriendly mode switch didn't sneak and not cause
    // us to get re-enabled properly.
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvD3DRecover();
        }
        else {
            NvReleaseSemaphore(pDriverData);
            pscd->ddrval = DD_OK;
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

    pPusherSyncNotifier = pDriverData->pDmaPusherSyncNotifierFlat;

    switch (pscd->dwFlag) {

        // BeginScene -----------------------------------------------------------------

        case D3DHAL_SCENE_CAPTURE_START:

#ifdef NV_PROFILE
            // Scene Timer Start & log
            //nvpLogEvent (NVP_T_CLOCK);
            nvpLogEvent (NVP_E_BEGINSCENE);
            NVP_START(NVP_T_SCENE);
#endif
#ifdef NV_MARKER
            if (1) {
                extern DWORD dwMarkerCount;
                dwMarkerCount ++;
                *(DWORD*)(pDriverData->BaseAddress) = (dwMarkerCount << 16) | dwMarkerCount;
            }
            else {
                *(DWORD*)(pDriverData->BaseAddress) = 0xaaaaaaaa;
            }
#endif
#ifdef CAPTURE
            if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                CAPTURE_SCENE scene;
                scene.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                scene.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                scene.dwExtensionID        = CAPTURE_XID_SCENE;
                captureLog (&scene,sizeof(scene));
            }
#endif

            pContext->dwClearCount = 0; // number of full clears this frame, used to check for bad CT semantics

            // clear the area behind the logo if enabled in the registry
            if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_LOGOENABLE_MASK) == D3D_REG_LOGOENABLE_ENABLE)
            {
                nvDrawLogo(pContext, TRUE);
            }

            if (pContext->dwRTHandle)
            {
                CNvObject *pRTObj = nvGetObjectFromHandle(pContext->dwDDLclID, pContext->dwRTHandle, &global.pNvSurfaceLists);
                if (pRTObj && pRTObj->isDirty())
                {
                    // reset the render target
                    nvSetRenderTargetDX7(pContext, pContext->dwRTHandle, pContext->dwZBHandle);
#if (NVARCH >= 0x010)
                    // make sure the AA info is also updated
                    if (pContext->aa.isEnabled()) nvCelsiusAADestroy(pContext);
#endif  // NVARCH >= 0x010
                }
            }

#if (NVARCH >= 0x010)
            // Let AASTATE know that we have a BeginScene
            pContext->aa.BeginScene(pContext);
#endif  // NVARCH >= 0x010
            pContext->kelvinAA.TagSeen3D();

            if (dbgFrontRender) pDriverData->bDirtyRenderTarget = TRUE;

            break;

        // EndScene -------------------------------------------------------------------

        case D3DHAL_SCENE_CAPTURE_END:

            DDFLIPTICKS(FEBEGINEND);

#ifdef CAPTURE
            if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_PLAY) {
                getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
                capturePlay ((void *)(pContext->pRenderTarget->getAddress()),
                             pContext->pRenderTarget->getPitch(),
                             pContext->pRenderTarget->getWidth(),
                             pContext->pRenderTarget->getHeight());
                capturePlayFileInc();
            }
#endif

            // draw the NVIDIA logo if it is enabled in the registry
            if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_LOGOENABLE_MASK) == D3D_REG_LOGOENABLE_ENABLE)
            {
                nvDrawLogo(pContext, 0);
            }


#ifdef  STEREO_SUPPORT
            StereoAdjustmentMonitor(pContext);
#endif  //STEREO_SUPPORT

#if (NVARCH >= 0x010)
            // Let AASTATE know that we have a BeginScene
            pContext->aa.EndScene(pContext);
#endif  // NVARCH >= 0x010

#if (NVARCH >= 0x020)
            pContext->kelvinAA.EndScene();
#endif  // NVARCH >= 0x020

            // Start pushing buffer.
            nvPusherStart (TRUE);

#ifdef NV_MARKER
            *(DWORD*)(pDriverData->BaseAddress) = 0xbbbbbbbb;
#endif
#ifdef NV_PROFILE
            // Scene Timer Stop and log
            NVP_STOP(NVP_T_SCENE);
            nvpLogTime (NVP_T_SCENE,nvpTime[NVP_T_SCENE]);
#endif

            /*
             * This is a major hack to work around input lag in stupid applications that
             * want to use blits instead of flips to do their screen updates but then don't
             * make any getblitstatus calls to see if the blit has completed before beginning
             * to render the next frame.
             * This is not something that you want to have enabled unless you absolutely need
             * to have it enabled.
             */
            if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_SSYNCENABLE_MASK) == D3D_REG_SSYNCENABLE_ENABLE)
            {
                getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
            }

#ifdef TEX_MANAGE
            // shuffle texture eviction lists around...
            nvTexManageSceneEnd (pContext);
#endif
            /*
             * signal pm
             */
            PM_SIGNAL (PM_REG_PMTRIGGER_ENDSCENE);

#if 0 // DO NOT REMOVE - bdw
            {
                DWORD dwBase = (U032)NvDeviceBaseGet (NV_DEV_BASE, pDriverData->dwDeviceIDNum);

                static int j = -1;
                if (j == -1)
                {
                    DWORD dwData = *(volatile DWORD*)(dwBase + 0x400084);
                          dwData |= 0x02000000;
                    *(volatile DWORD*)(dwBase + 0x400084) = dwData;
                    j = 100;
                }
                else
                {
                    j--;
                    if (!j)
                    {
                        j = 100;

                        getDC()->nvPusher.flush (1, CPushBuffer::FLUSH_WITH_DELAY);

                        PF ("------------------------------- %d",GetTickCount());
                        *(volatile DWORD*)(dwBase + 0x400728)  = 0x01000000;

                        float afData[256];
                        for (DWORD i = 0x20; i <= 0x31; i++)
                        {
                            *(volatile DWORD*)(dwBase + 0x400728) = i << 24;
                            afData[i] = float(*(volatile DWORD*)(dwBase + 0x40072c));
                            PF ("%02x = %11d",i,int(afData[i]));
                        }

                    #define FPF(str,y) { float x = (y); PF (str,int(x),int((x) * 1000000) % 1000000); }

                        PF ("");
                        FPF ("  pipe util: %8d.%06d%%",100.0f * (afData[0x22] / 4.0f) / afData[0x20]);
                        FPF ("       idle: %8d.%06d%%",100.0f * afData[0x21] / afData[0x20]);
                        FPF ("  l2t stall: %8d.%06d%%",100.0f * afData[0x28] / afData[0x20]);
                    }
                }
            }
#endif

            break;

        default:
            DPF ("unknown scenecapture token");
            dbgD3DError();
            break;

    }  // switch

    NvReleaseSemaphore(pDriverData);
    pscd->ddrval = DD_OK;

    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvSurf.cpp ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvSurf.cpp                                                        *
*   Routines for management of surface lists added in DX7                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler (bertrem)   16Dec98    created                     *
*       Craig Duttweiler (bertrem)   05Aug99    major rework for G.U.D.     *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

//--------------------------------------------------------------------------

DWORD nvCreateSystemMemorySurface (LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl)
{
    dbgTracePush ("nvCreateSystemMemorySurface");

    // create the basic objects
#ifndef WINNT
    CNvObject *pNvObj = new CNvObject (pDDSLcl->dwProcessId);
#else
    CNvObject *pNvObj = new CNvObject (0);
#endif // WINNT

    if (!pNvObj) {
        DPF ("nvCreateSystemMemorySurface: failed allocation of CNvObject");
        dbgD3DError();
        dbgTracePop();
        return DDERR_OUTOFMEMORY;
    }

    if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
    {
        if (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_COMMANDBUFFER)
        {
            CCommandBuffer *pCommandBuffer = new CCommandBuffer (pNvObj, pDDSLcl);
            
            if (!pCommandBuffer) {
                pNvObj->release();
                DPF ("nvCreateSystemMemorySurface: failed to create CCommandBuffer");
                dbgD3DError();
                dbgTracePop();
                return DDERR_OUTOFMEMORY;
            }

            pNvObj->setObject (CNvObject::NVOBJ_COMMANDBUFFER, pCommandBuffer);
            pCommandBuffer->own(pDDSLcl->lpGbl->fpVidMem, pDDSLcl->lpGbl->dwLinearSize, CSimpleSurface::HEAP_SYS);
        }
        else
        {
            // assume everything else is a vertex buffer
            CVertexBuffer *pVertexBuffer = new CVertexBuffer (pNvObj);

            if (!pVertexBuffer) {
                pNvObj->release();
                DPF ("nvCreateSystemMemorySurface: failed to create CVertexBuffer");
                dbgD3DError();
                dbgTracePop();
                return DDERR_OUTOFMEMORY;
            }

            pNvObj->setObject (CNvObject::NVOBJ_VERTEXBUFFER, pVertexBuffer);
            pVertexBuffer->own(pDDSLcl->lpGbl->fpVidMem, pDDSLcl->lpGbl->dwLinearSize, CSimpleSurface::HEAP_SYS);
            pVertexBuffer->setVertexStride (0);
        }
    }

    else {

        CSimpleSurface *pSurf  = new CSimpleSurface;

        if (!pSurf) {
            pNvObj->release();
            DPF ("nvCreateSystemMemorySurface: failed allocation of CSimpleSurface");
            dbgD3DError();
            dbgTracePop();
            return DDERR_OUTOFMEMORY;
        }

        pNvObj->setObject (CNvObject::NVOBJ_SIMPLESURFACE, pSurf);

#ifdef WINNT
        // workaround for Win2K DX7 runtime bug - DXT surface size is set incorrectly
        if (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_FOURCC) {
            switch(pDDSLcl->lpGbl->ddpfSurface.dwFourCC) {
            case FOURCC_DXT1:
                pDDSLcl->lpGbl->wHeight <<= 2;
                pDDSLcl->lpGbl->wWidth  >>= 1;
                break;
            case FOURCC_DXT2:
            case FOURCC_DXT3:
            case FOURCC_DXT4:
            case FOURCC_DXT5:
                pDDSLcl->lpGbl->wHeight <<= 2;
                pDDSLcl->lpGbl->wWidth  >>= 2;
                break;
            }
        }
#endif // WINNT

        // determine common surface parameters
        DWORD dwFormat, dwWidth, dwHeight, dwDepth, dwBPPRequested, dwBPPGranted, dwPitch, dwSlicePitch, dwMultiSampleBits;
        BOOL  bFourCC;
        DWORD dwRV = nvCalculateSurfaceParams (pDDSLcl, &dwFormat, &bFourCC, &dwWidth, &dwHeight, &dwDepth, &dwMultiSampleBits,
                                               &dwBPPRequested, &dwBPPGranted, &dwPitch, &dwSlicePitch, FALSE);

        if (dwRV == DDERR_INVALIDPIXELFORMAT) {
            // allow invalid (ie. unknown) pixel formats. just trust the surface
            dwFormat     = NV_SURFACE_FORMAT_UNKNOWN;
            dwPitch      = pDDSLcl->lpGbl->lPitch;
            dwSlicePitch = pDDSLcl->lpGbl->lSlicePitch;
            dwHeight     = pDDSLcl->lpGbl->wHeight;
            dwWidth      = pDDSLcl->lpGbl->wWidth;
            dwDepth      = pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps4 & 0xffff;
            dwBPPGranted = dwBPPRequested = pDDSLcl->lpGbl->ddpfSurface.dwRGBBitCount/8;
        }
        else if (dwRV != DD_OK) {
            delete pSurf;
            pNvObj->release();
            dbgTracePop();
            return dwRV;
        }

#ifdef WINNT
        // MPR - MS runtime bug. pDDSLcl->lpGbl->lSlicePitch is not filled out for
        // system memory volume textures. Fortunately it is easily calculated
        if (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME) {
            dwSlicePitch = dwPitch * dwHeight;
        }
#endif

        pSurf->own (pDDSLcl->lpGbl->fpVidMem, dwPitch, dwHeight, CSimpleSurface::HEAP_SYS, FALSE);
        pSurf->setWrapper (pNvObj);
        pSurf->setFormat (dwFormat);
        pSurf->setWidth (dwWidth);
        pSurf->setDepth(dwDepth);
        pSurf->setSlicePitch (dwSlicePitch);
        pSurf->setBPP (dwBPPGranted);
        pSurf->setBPPRequested (dwBPPRequested);
        if (bFourCC) {
            pSurf->setFourCC (pDDSLcl->lpGbl->ddpfSurface.dwFourCC);
        }

    }

    SET_PNVOBJ (pDDSLcl, pNvObj);

    dbgTracePop();
    return DD_OK;
}

//--------------------------------------------------------------------------

// return a pointer to the given surface's mipmap or flip chain. this is
// straightforward for regular textures and other chains but totally convoluted
// for cubemaps because MS is dumb

LPDDRAWI_DDRAWSURFACE_LCL nvFindSurfaceChain
(
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl,
    LPATTACHLIST *ppAttachList
)
{
    DWORD dwRootFace, dwAttachedFace;

    dbgTracePush ("nvFindSurfaceChain");

    nvAssert (pDDSLcl);

    if (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP) {
        // cubemap. seek out the proper mipmap chain
        dwRootFace = pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_ALLFACES;
        *ppAttachList = pDDSLcl->lpAttachList;
        while (*ppAttachList) {
            dwAttachedFace = (*ppAttachList)->lpAttached->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_ALLFACES;
            if (dwAttachedFace == dwRootFace) {
                dbgTracePop();
                return (*ppAttachList)->lpAttached;
            }
            *ppAttachList = (*ppAttachList)->lpLink;
        }
    }

    else {
        // not a cubemap. just return the first thing attached
        *ppAttachList = pDDSLcl->lpAttachList;
        if (*ppAttachList) {
            dbgTracePop();
            return pDDSLcl->lpAttachList->lpAttached;
        }
    }

    dbgTracePop();
    return NULL;
}

//--------------------------------------------------------------------------

// return a pointer to the next face of the cubemap. this is convoluted
// because MS is annoying. we sort it all out here and store it internally
// in a more sane manner.

LPDDRAWI_DDRAWSURFACE_LCL nvFindNextCubemapFace
(
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLclRoot,   // the root of the whole ratnest
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl        // the surface whose next face we want to find
)
{
    LPATTACHLIST pAttachList;
    DWORD        dwThisFace, dwNextFace;

    dbgTracePush ("nvFindNextCubemapFace");

    nvAssert (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP);
    nvAssert ((pDDSLclRoot->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_ALLFACES) == DDSCAPS2_CUBEMAP_POSITIVEX);

    // we rely on these definitions. if MS changes them, we'll have to fix
    nvAssert ((DDSCAPS2_CUBEMAP_POSITIVEX == 0x00000400L) &&
              (DDSCAPS2_CUBEMAP_NEGATIVEX == 0x00000800L) &&
              (DDSCAPS2_CUBEMAP_POSITIVEY == 0x00001000L) &&
              (DDSCAPS2_CUBEMAP_NEGATIVEY == 0x00002000L) &&
              (DDSCAPS2_CUBEMAP_POSITIVEZ == 0x00004000L) &&
              (DDSCAPS2_CUBEMAP_NEGATIVEZ == 0x00008000L));

    dwThisFace = pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_ALLFACES;
    dwNextFace = dwThisFace << 1;

    if (dwThisFace == DDSCAPS2_CUBEMAP_NEGATIVEZ) {
        dbgTracePop();
        return NULL;
    }

    if (pDDSLclRoot->lpAttachList == NULL) {
        dbgTracePop();
        return NULL;
    }

    pAttachList = pDDSLclRoot->lpAttachList;

    while (pAttachList) {
        dwThisFace = pAttachList->lpAttached->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_ALLFACES;
        if (dwThisFace == dwNextFace) {
            dbgTracePop();
            return (pAttachList->lpAttached);
        }
        pAttachList = pAttachList->lpLink;
    }

    dbgTracePop();
    return NULL;
}

//--------------------------------------------------------------------------

DWORD nvCheckSystemMemorySurface
(
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl
)
{
    dbgTracePush ("nvCheckSystemMemorySurface");

    nvAssert (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY);

    CNvObject *pNvObj = GET_PNVOBJ (pDDSLcl);

    if (!IS_VALID_PNVOBJ(pNvObj)) {
        // if this is a system memory surface, we may not have ever seen it before.
        // CreateSurfaceEx (and its subsidiaries) have to play the part of CreateSurface32.
        DWORD dwRV = nvCreateSystemMemorySurface (pDDSLcl);
        dbgTracePop();
        return dwRV;
    }

    else {
        // we've seen this surface before and have created an nvObject, but MS may have
        // moved it since we last saw it, so make sure that our pointer is up to date.
        //  (bdw) - actually, it seems that anything about it may have changed - check dimentions also
        //        - bugbug: we do not check format (although I have seen this change also)
        nvAssert (pNvObj->getClass() == CNvObject::NVOBJ_SIMPLESURFACE);
        CSimpleSurface *pSurf = pNvObj->getSimpleSurface();
        if ((pSurf->getAddress() != pDDSLcl->lpGbl->fpVidMem)
         || (pSurf->getWidth()   != pDDSLcl->lpGbl->wWidth)
         || (pSurf->getHeight()  != pDDSLcl->lpGbl->wHeight))
        {
            DWORD dwFormat, dwWidth, dwHeight, dwDepth, dwMultiSampleBits, dwBPPRequested, dwBPPGranted, dwPitch, dwSlicePitch, dwRV;
            BOOL  bFourCC;
            dwRV = nvCalculateSurfaceParams (pDDSLcl, &dwFormat, &bFourCC, &dwWidth, &dwHeight, &dwDepth, &dwMultiSampleBits,
                                             &dwBPPRequested, &dwBPPGranted, &dwPitch, &dwSlicePitch, FALSE);
            nvAssert (dwRV == DD_OK);  // really?  what about UNKNOWN formats?
            pSurf->disown();
            pSurf->own (pDDSLcl->lpGbl->fpVidMem, dwPitch, dwHeight, CSimpleSurface::HEAP_SYS, FALSE);
            pSurf->setFormat (dwFormat);
            pSurf->setWidth (dwWidth);
            pSurf->setBPP (dwBPPGranted);
            pSurf->setBPPRequested (dwBPPRequested);
        }
        dbgTracePop();
        return DD_OK;
    }

}

//--------------------------------------------------------------------------

DWORD nvAddSurfaceChainToList
(
    PNV_OBJECT_LIST           pNvObjectList,
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl
)
{
    CNvObject                *pNvObj;
    DWORD                     dwHandle;
    LPDDRAWI_DDRAWSURFACE_LCL pChain;

    dbgTracePush ("nvAddSurfaceChainToList");

    if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) {
        DWORD dwRV = nvCheckSystemMemorySurface (pDDSLcl);
        if (dwRV != DD_OK) {
            dbgTracePop();
            return dwRV;
        }
    }

    // at creation time, we will have cached the NvObject pointer in the
    // dwReserved field. retrieve it now and associate it with dwHandle

    pNvObj = GET_PNVOBJ (pDDSLcl);
    if (pNvObj) {
        dwHandle = pDDSLcl->lpSurfMore->dwSurfaceHandle;
        DWORD dwRV = nvAddObjectToList (pNvObjectList, pNvObj, dwHandle);
        if (dwRV != DD_OK) {
            dbgTracePop();
            return dwRV;
        }
    }
    else {
        nvAssert (pDDSLcl->lpGbl->fpVidMem == NULL);
        DPF ("runtime called CSEx on a surface that's already been destroyed (or was never created)");
        dbgD3DError();
    }

#ifdef DEBUG
    if (pNvObj && (pNvObj->getClass() == CNvObject::NVOBJ_SIMPLESURFACE)) {
        CSimpleSurface *pSurf = pNvObj->getSimpleSurface();
        nvAssert (pSurf->getfpVidMem() == pDDSLcl->lpGbl->fpVidMem);
        if ( pSurf->getFormat() != NV_SURFACE_FORMAT_UNKNOWN ) {
            DWORD dwPitch, dwSlicePitch, dwFormat, dwWidth, dwHeight, dwDepth, dwMultiSampleBits, dwBPPRequested, dwBPPGranted, dwRV;
            BOOL  bFourCC;
            dwRV = nvCalculateSurfaceParams (pDDSLcl, &dwFormat, &bFourCC, &dwWidth, &dwHeight, &dwDepth, &dwMultiSampleBits,
                                             &dwBPPRequested, &dwBPPGranted, &dwPitch, &dwSlicePitch, FALSE);
            nvAssert (dwRV     == DD_OK);
            nvAssert (dwFormat == pSurf->getFormat());
    #ifndef CAPTURE  // not when capturing b/c we may be spoofing allocation sizes
            if (!pSurf->isDXT()) {
                nvAssert (dwWidth  == pSurf->getWidth());
                nvAssert (dwHeight == pSurf->getHeight());
            }
    #endif
            nvAssert (dwBPPGranted == pSurf->getBPP());
        }
    }
#endif

    // get this surface's mipmap or flip chain, if any
    LPATTACHLIST lpAttachList;
    pChain = nvFindSurfaceChain (pDDSLcl, &lpAttachList);

    while (pChain) {

        // check if we are back at the beginning - this happens with flip chains
        if (pChain == pDDSLcl) break;

#ifndef WINNT
        BOOL bImplicit = lpAttachList->dwFlags & DDAL_IMPLICIT;
#else
        // simulate the implicit flag by checking for a NULL dwReserved1
        // this is only needed for flip chains with attached z-buffers, so it should
        // always be true for textures
        BOOL bImplicit = (GET_PNVOBJ(pChain) != NULL) | (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE);
#endif // !WINNT

        // assign handle for implicitly attached surfaces only
        if (bImplicit) {
            // create an NvObject etc if necessary
            if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) {
                DWORD dwRV = nvCheckSystemMemorySurface (pChain);
                if (dwRV != DD_OK) {
                    dbgTracePop();
                    return dwRV;
                }
            }

            if (pNvObj) {
                // attach the last one to this one
                pNvObj->setAttachedA (GET_PNVOBJ (pChain));
            }

            // add the new one to the list
            pNvObj = GET_PNVOBJ (pChain);
            if (pNvObj) {
                dwHandle = pChain->lpSurfMore->dwSurfaceHandle;
                DWORD dwRV = nvAddObjectToList (pNvObjectList, pNvObj, dwHandle);
                if (dwRV != DD_OK) {
                    dbgTracePop();
                    return dwRV;
                }
            }
            else {
                nvAssert (pChain->lpGbl->fpVidMem == NULL);
                DPF ("runtime called CSEx on a surface that's already been destroyed (or was never created)");
                dbgD3DError();
            }

#ifdef DEBUG
            if (pNvObj && (pNvObj->getClass() == CNvObject::NVOBJ_SIMPLESURFACE)) {
                CSimpleSurface *pSurf = pNvObj->getSimpleSurface();
                nvAssert (pSurf->getfpVidMem() == pChain->lpGbl->fpVidMem);
                if (pSurf->getFormat() != NV_SURFACE_FORMAT_UNKNOWN) {
                    DWORD dwPitch, dwSlicePitch, dwFormat, dwWidth, dwHeight, dwDepth, dwMultiSampleBits, dwBPPRequested, dwBPPGranted, dwRV;
                    BOOL  bFourCC;
                    dwRV = nvCalculateSurfaceParams (pChain, &dwFormat, &bFourCC, &dwWidth, &dwHeight, &dwDepth, &dwMultiSampleBits,
                                                     &dwBPPRequested, &dwBPPGranted, &dwPitch, &dwSlicePitch, FALSE);
                    nvAssert (dwRV     == DD_OK);
                    nvAssert (dwFormat == pSurf->getFormat());
                    if (!pSurf->isDXT()) {  // what if CAPTURE is on?
                        nvAssert (dwWidth  == pSurf->getWidth());
                        nvAssert (dwHeight == pSurf->getHeight());
                    }
                    nvAssert (dwBPPGranted == pSurf->getBPP());
                }
            }
#endif
            // get the next attach list
            lpAttachList = pChain->lpAttachList;
        }
        else { // !bImplicit
            lpAttachList = lpAttachList->lpLink;
        }

        // get the next surface
        pChain = lpAttachList ? lpAttachList->lpAttached : NULL;

    }  // while (pChain)

    dbgTracePop();
    return DD_OK;
}

//--------------------------------------------------------------------------

DWORD nvDeleteSystemMemorySurface (LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl)
{
    dbgTracePush ("nvDeleteSystemMemorySurface");

    // retrieve the basic objects
    CNvObject *pNvObj = GET_PNVOBJ (pDDSLcl);

    if (IS_VALID_PNVOBJ(pNvObj)) {
        nvClearObjectListEntry (pNvObj, &global.pNvSurfaceLists);
        pNvObj->release();
        SET_PNVOBJ (pDDSLcl, NULL);
    }
    else if (pNvObj) {
        // this is likely a contextdma
        NvRmFree (pDriverData->dwRootHandle, pDriverData->dwRootHandle, (DWORD)pNvObj);
    }

    dbgTracePop();
    return DD_OK;
}

//--------------------------------------------------------------------------

// DX7 callback to let the driver know the value of the handle with
// which a newly created surface (an NvObject) will be associated

DWORD __stdcall nvCreateSurfaceEx
(
    LPDDHAL_CREATESURFACEEXDATA lpcsed
)
{
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl;
    PNV_OBJECT_LIST           pNvObjectList;
    CNvObject                *pLastFace;
    DWORD                     dwDDLclID;

    dbgTracePush ("nvCreateSurfaceEx");

    nvSetDriverDataPtrFromDDGbl (lpcsed->lpDDLcl->lpGbl);

    // get ourselves a surface list
    dwDDLclID = (DWORD)(lpcsed->lpDDLcl);
    pNvObjectList = nvFindObjectList (dwDDLclID, &global.pNvSurfaceLists);
    if (pNvObjectList == NULL) {
        // find will create a list if it doesn't already exist
        // a return value of NULL indicates that a new list could not be created
        NvReleaseSemaphore(pDriverData);
        lpcsed->ddRVal = DDERR_OUTOFMEMORY;
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    }

    pDDSLcl = lpcsed->lpDDSLcl;

    if ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) && (!pDDSLcl->lpGbl->fpVidMem)) {
        // Microsoft's way of letting us know that a system memory surface is being destroyed.
        DPF_LEVEL(NVDBG_LEVEL_SURFACE_ACTIVITY, "CSEx: destroy system surface, handle = %02x",
            pDDSLcl->lpSurfMore->dwSurfaceHandle);
        nvDeleteSystemMemorySurface (pDDSLcl);
        NvReleaseSemaphore(pDriverData);
        lpcsed->ddRVal = DD_OK;
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    }

    DPF_LEVEL(NVDBG_LEVEL_SURFACE_ACTIVITY, "CreateSurfaceEx: pDDSLcl = 0x%08x, fpVidMem = 0x%08x, handle = %02x",
        pDDSLcl, pDDSLcl->lpGbl->fpVidMem, pDDSLcl->lpSurfMore->dwSurfaceHandle);
    // handle the first chain of surfaces (flip chain, mipmap chain, etc)
    DWORD dwRV = nvAddSurfaceChainToList (pNvObjectList, pDDSLcl);
    if (dwRV != DD_OK)
    {
        NvReleaseSemaphore(pDriverData);
        lpcsed->ddRVal = dwRV;
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    }

    // iterate through linked attach lists to handle cube maps
    if (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP) {

        // cache a pointer to the current face then get the next one
        pLastFace = GET_PNVOBJ (pDDSLcl);
        pDDSLcl = nvFindNextCubemapFace (lpcsed->lpDDSLcl, pDDSLcl);

        while (pDDSLcl) {
            // add this face's chain to out list
            dwRV = nvAddSurfaceChainToList (pNvObjectList, pDDSLcl);
            if (dwRV != DD_OK)
            {
                NvReleaseSemaphore(pDriverData);
                lpcsed->ddRVal = dwRV;
                dbgTracePop();
                return DDHAL_DRIVER_HANDLED;
            }

            // make the last face point to this one
            pLastFace->setAttachedB (GET_PNVOBJ (pDDSLcl));

            // advance
            pLastFace = GET_PNVOBJ (pDDSLcl);
            pDDSLcl = nvFindNextCubemapFace (lpcsed->lpDDSLcl, pDDSLcl);
        }

    }

    NvReleaseSemaphore(pDriverData);
    lpcsed->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

//-------------------------------------------------------------------------

// lock all textures referenced in the current combiner setup for use by the HW

void nvHWLockTextures
(
    PNVD3DCONTEXT pContext
)
{
    // late binding of texture handles set with D3DRENDERSTATE_TEXTUREHANDLE (accomodates retained mode junk)
    DWORD dwTextureHandle = pContext->tssState[0].dwHandle;
    if (dwTextureHandle) {
        pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] = (DWORD) nvGetObjectFromHandle (pContext->dwDDLclID, dwTextureHandle, &global.pNvSurfaceLists);
        pContext->tssState[0].dwHandle = 0;
    }

    for (DWORD i = 0; i < 8; i++) {
        CNvObject *pNvObj = (CNvObject *)(pContext->tssState[i].dwValue[D3DTSS_TEXTUREMAP]);
        if (pNvObj) {
            CTexture *pTexture = pNvObj->getTexture();
            // we have to check that the 'textures' that are loaded really are
            // textures. some apps (like lego island) will pass in normal surfaces
            // as textures and cause us to fault
            if (pTexture && 
               (pTexture->getLinear() != pContext->pRenderTarget) &&
               (pTexture->getSwizzled() != pContext->pRenderTarget)) {
                // lock the texture
                pTexture->hwLock (pContext, CSimpleSurface::LOCK_NORMAL);
                // lock the palette
                CNvObject *pPaletteObj = pNvObj->getPalette();
                if (pPaletteObj) {
                    pPaletteObj->getPaletteSurface()->hwLock(CSimpleSurface::LOCK_NORMAL);
                }
            } else {
//              pContext->tssState[i].dwValue[D3DTSS_TEXTUREMAP] = NULL;
                //don't set this to NULL-- it should be failed in validate instead
                //set to a default texture at last second if they really insist
            }
        }
    }

    //lock the zbuffer and render targets as well for synchronizations with Locks of RT or ZB.
    // -/- could optimize this a bit if the 'ZBuffer' writes have been turned off -/-
#if (NVARCH >= 0x020)
    CSimpleSurface *pRenderTarget = pContext->kelvinAA.GetCurrentRT(pContext);
    CSimpleSurface *pZetaBuffer = pContext->kelvinAA.GetCurrentZB(pContext);
#else
    CSimpleSurface *pRenderTarget = pContext->pRenderTarget;
    CSimpleSurface *pZetaBuffer = pContext->pZetaBuffer;
#endif

    pRenderTarget->hwLock(CSimpleSurface::LOCK_NORMAL);
    if (pZetaBuffer) pZetaBuffer->hwLock(CSimpleSurface::LOCK_NORMAL);
}

//-------------------------------------------------------------------------

// unlock all textures referenced in the current combiner setup for use by the HW

void nvHWUnlockTextures
(
    PNVD3DCONTEXT pContext
)
{
    nvAssert(pContext);

    for (DWORD i = 0; i < 8; i++) {
        CNvObject *pNvObj = (CNvObject *)(pContext->tssState[i].dwValue[D3DTSS_TEXTUREMAP]);
        if (pNvObj) {
            CTexture  *pTexture = pNvObj->getTexture();
            
            if (pTexture &&
               (pTexture->getLinear() != pContext->pRenderTarget) &&
               (pTexture->getSwizzled() != pContext->pRenderTarget)) {
                // unlock the texture
                pNvObj->getTexture()->hwUnlock();
                // unlock the palette
                CNvObject *pPaletteObj = pNvObj->getPalette();
                if (pPaletteObj) {
                    pPaletteObj->getPaletteSurface()->hwUnlock();
                }
            }
        }
    }

    //unlock rendertarget and zbuffer
#if (NVARCH >= 0x020)
    CSimpleSurface *pRenderTarget = pContext->kelvinAA.GetCurrentRT(pContext);
    CSimpleSurface *pZetaBuffer = pContext->kelvinAA.GetCurrentZB(pContext);
#else
    CSimpleSurface *pRenderTarget = pContext->pRenderTarget;
    CSimpleSurface *pZetaBuffer = pContext->pZetaBuffer;
#endif

    nvAssert(pRenderTarget);
    pRenderTarget->hwUnlock();
    if (pZetaBuffer) pZetaBuffer->hwUnlock();
}

//-------------------------------------------------------------------------

// lock the first dwCount vertex streams for use by HW

void nvHWLockStreams
(
    PNVD3DCONTEXT pContext,
    DWORD         dwCount
)
{
    if(pContext->dwFlags & CONTEXT_NEEDS_VTX_CACHE_FLUSH)
    {
#if (NVARCH >= 0x020)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            nvglSetNv20KelvinInvalidateVertexCache (NV_DD_KELVIN);
        }
        else
#endif
#if (NVARCH >= 0x010)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
            nvglSetNv10CelsiusInvalidateVertexCache (NV_DD_CELSIUS);
        }
#endif
        pContext->dwFlags &= ~CONTEXT_NEEDS_VTX_CACHE_FLUSH;
    }

    for (DWORD i=0; i<dwCount; i++) {
        if (pContext->ppDX8Streams[i] != NULL) {
#ifdef MCFD
            pContext->ppDX8Streams[i]->LockForGPU (CSimpleSurface::LOCK_READ);
#else
            pContext->ppDX8Streams[i]->hwLock (CSimpleSurface::LOCK_NORMAL);
#endif
        }
    }
}

//-------------------------------------------------------------------------

// release the HW lock on the first dwCount vertex streams

void nvHWUnlockStreams
(
    PNVD3DCONTEXT pContext,
    DWORD         dwCount
)
{
    for (DWORD i=0; i<dwCount; i++) {
        if (pContext->ppDX8Streams[i] != NULL) {
#ifdef MCFD
            pContext->ppDX8Streams[i]->UnlockForGPU ();
#else
            pContext->ppDX8Streams[i]->hwUnlock ();
#endif
        }
    }
}

#endif // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvStereo.cpp ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.*
*                                                                           *
* Module: Stereo.cpp                                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Andrei Osnovich    02/08/00  Created                                *
*                                                                           *
\***************************************************************************/
// NB: This file is 'opted out' of pre-compiled headers
//#pragma optimize ("", off)

#define DEFINE_HOTKEY_INTERFACES

#include "nvprecomp.h"
#include "nvPopupList.h"

#ifdef  STEREO_SUPPORT

#include "nvreg.h"

LPSTEREODATA                pStereoData;
float                       MAX_STEREO_SEPARATION; //We won't allow to go beyond this value.
extern DWORD                ActivateStereo(PNVD3DCONTEXT pContext);
extern DWORD                DeactivateStereo(PNVD3DCONTEXT pContext);
extern void                 ResetStereoParameters(void);
extern DWORD __stdcall      SetExclusiveMode32(LPDDHAL_SETEXCLUSIVEMODEDATA lpSetExclusiveMode);

#define VeryBrightGrey16    0xF7DE
#define VeryBrightGrey32    0xFEFEFE
#define COLOR_KEY  ((pDriverData->ModeList[pDXShare->dwModeNumber].dwBPP == 16) ? VeryBrightGrey16 : VeryBrightGrey32)

#ifdef  STEREO_DEBUG
//Private options for debugging purpose
//#define FLAT_STAT
//#define MEMORY_TEST
//#define ONE_EYE
//#define NULL_RIGHT_EYE
//#define LEFT_ALWAYS_FIRST
//#define SHOW_EYES
//#define LASERSTATECHANGE
//#define PARTIALRENDERING
//#define DELAYED_HOTKEY_INIT

#ifdef  PARTIALRENDERING
#ifndef LEFT_ALWAYS_FIRST
#define LEFT_ALWAYS_FIRST
#endif
#endif
#endif  //STEREO_DEBUG

#ifdef  DELAYED_HOTKEY_INIT
DWORD   FirstHotKeyInit;
#endif  //DELAYED_HOTKEY_INIT

//use this to control compilation of a popup agents list
#define USE_POPUP_LIST

DWORD  nFlips; 

typedef struct _bmp_common_header_s
{
    DWORD dwMagic;
    DWORD dwPad1;
    WORD  wPad2;
    DWORD dwBfOffBits;
} BMPCOMMONHEADER, *LPBMPCOMMONHEADER;

typedef struct _bmp_win_header_s
{
    DWORD dwHeaderSize;
    DWORD dwWidth;
    DWORD dwHeight;
    WORD  wPlanes;
    WORD  dwBitsPerPixel;
    DWORD dwCompression;
    DWORD dwPad3;
    DWORD dwXPelsPerMeter;
    DWORD dwYPelsPerMeter;
    DWORD dwColorUsed;
    DWORD dwPad4;
} BMPWINHEADER, *LPBMPWINHEADER;

typedef struct _bmp_header_s
{
    BMPCOMMONHEADER CommonHeader;
    BMPWINHEADER    WinHeader;
} BMPHEADER, *LPBMPHEADER;

#define BMP_MAGIC       0x30364D42  //BM60
#define BMP_HEADER_SIZE (sizeof(BMPHEADER))
#define BMP_WIN_HEADER_SIZE (sizeof(BMPWINHEADER))

#ifdef	SHOW_EYES
CSimpleSurface *pFrontSurf;

void ShowEyes(void)
{
    // make sure we get access to all of video memory
    bltUpdateClip(pDriverData);
    pDriverData->blitCalled = TRUE;
    pDriverData->TwoDRenderingOccurred = 1;
    // make sure we sync with other channels before writing put
    getDC()->nvPusher.setSyncChannelFlag();

    if (pDriverData->bltData.dwLastRop != SRCCOPYINDEX) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_ROP) | SET_ROP_OFFSET | 0x40000);
        nvPushData(1, SRCCOPYINDEX);
        nvPusherAdjust(2);
        pDriverData->bltData.dwLastRop = SRCCOPYINDEX;
    }
    if (pDriverData->bltData.dwLastColourKey != 0xFFFFFFFF) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData(1, NV_DD_CONTEXT_COLOR_KEY);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | SET_TRANSCOLOR_OFFSET | 0x40000);
        nvPushData(3, 0);
        nvPusherAdjust(4);
        pDriverData->bltData.dwLastColourKey = 0xFFFFFFFF;
        pDriverData->dDrawSpareSubchannelObject = NV_DD_CONTEXT_COLOR_KEY;
    }
    CSimpleSurface *pSurf = ((PNVD3DCONTEXT)(pStereoData->dwContext))->pRenderTarget;
    DWORD dwSrcSize, dwDstSize, dwCombinedPitch, dwSrcOffset, dwDstOffset, dwFormat, dwColourFormat; 
	DWORD dwDeltaX, dwDeltaY, dwControlPointIn, dwControlPointOut;
    dwSrcOffset = pSurf->getOffset();
    dwDstOffset = pFrontSurf->getOffset();
    dwCombinedPitch = (pFrontSurf->getPitch() << 16) | pSurf->getPitch();
	dwSrcSize = (pSurf->getHeight() << 16) | pSurf->getWidth();
	dwControlPointIn = 0;
	dwDstSize = (pFrontSurf->getHeight() >> 1 << 16) | pFrontSurf->getWidth();
	dwControlPointOut = 0;
	dwFormat = pFrontSurf->getFormat();
	dwColourFormat = nv062SurfaceFormat[dwFormat];
    if (pDriverData->bltData.dwLastColourFormat != dwColourFormat ||
        pDriverData->bltData.dwLastCombinedPitch != dwCombinedPitch ||
        pDriverData->bltData.dwLastSrcOffset != dwSrcOffset ||
        pDriverData->bltData.dwLastDstOffset != dwDstOffset) {

        nvPushData(0, dDrawSubchannelOffset(NV_DD_SURFACES) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
        nvPushData(1, dwColourFormat);                  // SetColorFormat
        nvPushData(2, dwCombinedPitch);                 // SetPitch
        nvPushData(3, dwSrcOffset);                        // SetSrcOffset
        nvPushData(4, dwDstOffset);                        // SetDstOffset
        nvPusherAdjust(5);

        pDriverData->bltData.dwLastColourFormat = dwColourFormat;
        pDriverData->bltData.dwLastCombinedPitch = dwCombinedPitch;
        pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
        pDriverData->bltData.dwLastDstOffset = dwDstOffset;
    }

    dwDeltaX = ((pSurf->getWidth() - 1) << 20)  / (pFrontSurf->getWidth() - 1);    // 12.20 fixed point
    dwDeltaY = ((pSurf->getHeight() - 1) << 20) / ((pFrontSurf->getHeight() >> 1) - 1);   // 12.20 fixed point
    nvPushData ( 0, dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000);
    nvPushData ( 1, NV_DD_SCALED_IMAGE_IID);
    nvPushData ( 2, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000);
    nvPushData ( 3, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY); // SetContextDmaImage
    nvPushData ( 4, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_SET_COLOR_FORMAT | 0x40000);
    nvPushData ( 5, nv089SurfaceFormat[dwFormat]); // SetColorFormat
    nvPushData ( 6, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CLIPPOINT_OFFSET | 0x180000);
    nvPushData ( 7, dwControlPointOut);             // ClipPoint
    nvPushData ( 8, dwDstSize);              // ClipSize
    nvPushData ( 9, dwControlPointOut);             // ImageOutPoint
    nvPushData (10, dwDstSize);              // ImageOutSize
    nvPushData (11, dwDeltaX);                 // DsDx
    nvPushData (12, dwDeltaY);                 // DtDy
    nvPushData (13, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0x100000);
    nvPushData (14, dwSrcSize);              // ImageInSize
    nvPushData (15, (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |     // ImageInFormat
                   (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                   pSurf->getPitch());
    nvPushData (16, dwSrcOffset);         // ImageInOffset
    nvPushData (17, dwControlPointIn);             // ImageInPoint

    nvPushData (18, dDrawSubchannelOffset(NV_DD_STRETCH) | NV089_SET_COLOR_CONVERSION | 0x40000);
    nvPushData (19, NV089_SET_COLOR_CONVERSION_DITHER); // SetColorFormat
    nvPusherAdjust (20);

	dwSrcOffset = pSurf->getOffsetRight();
	dwDstOffset += (pFrontSurf->getHeight() >> 1) * pFrontSurf->getPitch();

    nvPushData(0, dDrawSubchannelOffset(NV_DD_SURFACES) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
    nvPushData(1, dwColourFormat);                  // SetColorFormat
    nvPushData(2, dwCombinedPitch);                 // SetPitch
    nvPushData(3, dwSrcOffset);                        // SetSrcOffset
    nvPushData(4, dwDstOffset);                        // SetDstOffset
    nvPusherAdjust(5);

    pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
    pDriverData->bltData.dwLastDstOffset = dwDstOffset;

    nvPushData ( 0, dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000);
    nvPushData ( 1, NV_DD_SCALED_IMAGE_IID);
    nvPushData ( 2, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000);
    nvPushData ( 3, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY); // SetContextDmaImage
    nvPushData ( 4, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_SET_COLOR_FORMAT | 0x40000);
    nvPushData ( 5, nv089SurfaceFormat[dwFormat]); // SetColorFormat
    nvPushData ( 6, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CLIPPOINT_OFFSET | 0x180000);
    nvPushData ( 7, dwControlPointOut);             // ClipPoint
    nvPushData ( 8, dwDstSize);              // ClipSize
    nvPushData ( 9, dwControlPointOut);             // ImageOutPoint
    nvPushData (10, dwDstSize);              // ImageOutSize
    nvPushData (11, dwDeltaX);                 // DsDx
    nvPushData (12, dwDeltaY);                 // DtDy
    nvPushData (13, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0x100000);
    nvPushData (14, dwSrcSize);              // ImageInSize
    nvPushData (15, (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |     // ImageInFormat
                   (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                   pSurf->getPitch());
    nvPushData (16, dwSrcOffset);         // ImageInOffset
    nvPushData (17, dwControlPointIn);             // ImageInPoint

    nvPushData (18, dDrawSubchannelOffset(NV_DD_STRETCH) | NV089_SET_COLOR_CONVERSION | 0x40000);
    nvPushData (19, NV089_SET_COLOR_CONVERSION_DITHER); // SetColorFormat
    nvPusherAdjust (20);

	//And finally copy the left front to the right front
	dwSrcOffset = pFrontSurf->getOffset();
	dwDstOffset = pFrontSurf->getOffsetRight();
    dwCombinedPitch = (pFrontSurf->getPitch() << 16) | pFrontSurf->getPitch();
	dwDstSize = (pFrontSurf->getHeight() << 16) | pFrontSurf->getWidth();
    nvPushData(0, dDrawSubchannelOffset(NV_DD_SURFACES) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
    nvPushData(1, dwColourFormat);                  // SetColorFormat
    nvPushData(2, dwCombinedPitch);                 // SetPitch
    nvPushData(3, dwSrcOffset);                        // SetSrcOffset
    nvPushData(4, dwDstOffset);                        // SetDstOffset
    nvPusherAdjust(5);
    pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
    pDriverData->bltData.dwLastDstOffset = dwDstOffset;
    pDriverData->bltData.dwLastCombinedPitch = dwCombinedPitch;

	nvPushData (0, dDrawSubchannelOffset(NV_DD_BLIT) | BLIT_POINT_IN_OFFSET | 0xC0000);
	nvPushData (1, dwControlPointOut); 
	nvPushData (2, dwControlPointOut); 
	nvPushData (3, dwDstSize);     
	nvPusherAdjust(4);

    nvPusherStart(TRUE);
}

#endif	//SHOW_EYES

#ifdef  LASER_SIGHT
//*********************************************************
//Spot laser sight stuff

typedef struct RHWBasics_S
{
    float fLaserSZBase;
    float fLaserRHWBase;
    float fLaserRHWScale;
} RHWBASICS;

RHWBASICS RHWBasics;

#define LaserSZBase     RHWBasics.fLaserSZBase
#define LaserRHWBase    RHWBasics.fLaserRHWBase
#define LaserRHWScale   RHWBasics.fLaserRHWScale

float LaserMaxSizeDivider = 75.f;
float LaserMinSizeDivider = 450.f;
DWORD Transparency = 0x80000000;

// dwProperty structure:
//   [31:24] = MSB of Transparency
//   [23:12] = LaserMaxSizeDivider
//   [11:00] = LaserMinSizeDivider

void  ProcessLaserSightProperty(DWORD dwProperty)
{
    if (dwProperty)
    {
        LaserMinSizeDivider = (float)(dwProperty & 0xFFF);
        LaserMaxSizeDivider = (float)((dwProperty >> 12) & 0xFFF);
        if (LaserMinSizeDivider <= 0.0f)
            LaserMinSizeDivider = 1.0f;
        if (LaserMaxSizeDivider <= 0.0f)
            LaserMaxSizeDivider = 1.0f;
        Transparency = dwProperty & 0xFF000000;
    }
}

float LaserMaxSize;
float LaserMinSize;

#define LASER_WIDTH     64
#define LASER_HEIGHT    64
#define LASER_BMP_SIZE  LASER_WIDTH*LASER_HEIGHT*3

typedef struct _ClearDP2Command_S
{
    D3DHAL_DP2COMMAND Command;
    D3DHAL_DP2CLEAR   Clear;
} CLEARDP2COMMAND, *LPCLEARDP2COMMAND;

CLEARDP2COMMAND LaserDP2ClearCommand =
{
    {D3DDP2OP_CLEAR, 0, 1},
    {D3DCLEAR_TARGET, 0, 0, 0, 0, 0, 0, 0}
};

D3DHAL_DRAWPRIMITIVES2DATA LaserDP2ClearData =
{
    0,                                          //dwhContext.
    D3DHALDP2_USERMEMVERTICES,
    D3DFVF_TLVERTEX,
    NULL,                                       //lpDDCommands.
    0,                                          //dwCommandOffset
    sizeof (CLEARDP2COMMAND),                   //dwCommandLength
    NULL,                                       //lpVertices
    0,                                          //dwVertexOffset
    0,                                          //dwVertexLength
    0,                                          //dwReqVertexBufSize
    0,                                          //dwReqCommandBufSize
    NULL,                                       //lpdwRStates
    0,                                          //ddrval
    0                                           //dwErrorOffset
};

typedef struct _PopupDP2Command_S
{
    D3DHAL_DP2COMMAND Command;
    D3DHAL_DP2TRIANGLESTRIP LaserFan[1];
} POPUPDP2COMMAND, *LPPOPUPDP2COMMAND;

POPUPDP2COMMAND LaserDP2Command =
{
    {D3DDP2OP_TRIANGLESTRIP, 0, 2},
    {0}
};

D3DTLVERTEX LaserVertices[] =
{
    {0.0f, 0.0f, 0.0f, 0.0f, RGB(255, 255, 255), RGB(0, 0, 0), 0.0f, 0.0f},
    {0.0f, 0.0f, 0.0f, 0.0f, RGB(255, 255, 255), RGB(0, 0, 0), 1.0f, 0.0f},
    {0.0f, 0.0f, 0.0f, 0.0f, RGB(255, 255, 255), RGB(0, 0, 0), 0.0f, 1.0f},
    {0.0f, 0.0f, 0.0f, 0.0f, RGB(255, 255, 255), RGB(0, 0, 0), 1.0f, 1.0f},
};

CNvObject                  *pLaser_Obj;
CTexture                   *pLaser_Texture;

D3DHAL_DRAWPRIMITIVES2DATA LaserDP2Data =
{
    0,                                          //dwhContext.
    D3DHALDP2_USERMEMVERTICES,
    D3DFVF_TLVERTEX,
    NULL,                                       //lpDDCommands.
    0,                                          //dwCommandOffset
    sizeof (POPUPDP2COMMAND),                   //dwCommandLength
    (LPDDRAWI_DDRAWSURFACE_LCL)LaserVertices,   //lpVertices
    0,                                          //dwVertexOffset
    4,                                          //dwVertexLength
    0,                                          //dwReqVertexBufSize
    0,                                          //dwReqCommandBufSize
    NULL,                                       //lpdwRStates
    sizeof (D3DTLVERTEX),                       //dwVertexSize
    0                                           //dwErrorOffset
};

typedef struct _dwLaserStateSet
{
    DWORD dwState;
    DWORD dwValue;
} STATESETDATA;

#define NUM_STATES 14

STATESETDATA dwLaserStateSet[NUM_STATES] =
{
    { D3DRENDERSTATE_CULLMODE,         D3DCULL_NONE             },
    { D3DRENDERSTATE_ZFUNC,            D3DCMP_ALWAYS            },
    { D3DRENDERSTATE_ALPHAFUNC,        D3DCMP_ALWAYS            },
    { D3DRENDERSTATE_ALPHABLENDENABLE, TRUE                     },
    { D3DRENDERSTATE_SRCBLEND,         D3DBLEND_SRCALPHA        },
    { D3DRENDERSTATE_DESTBLEND,        D3DBLEND_INVSRCALPHA     },
    { D3DRENDERSTATE_WRAP0,            0                        },
    { D3DRENDERSTATE_STENCILENABLE,    FALSE                    },
    { D3DRENDERSTATE_FILLMODE,         D3DFILL_SOLID            },
    { D3DRENDERSTATE_FOGENABLE,        FALSE                    },
    { D3DRENDERSTATE_WRAPU,            0                        },
    { D3DRENDERSTATE_WRAPV,            0                        },
    { D3DRENDERSTATE_TEXTUREMAPBLEND,  D3DPTBLENDCAPS_MODULATE  },
    { D3DRENDERSTATE_SPECULARENABLE,   FALSE                    }
};
///////////////// File logging //////////////////////////////////////////////
static BOOL logToFile=TRUE;								//file-wide flag
static char nvStereoLog[256];							//log file name
//--------------------------------------------------------------------------
#define DEFAULT_LOG_NAME		"nvStereoLog.txt"

#if (IS_WINNT5 || IS_WIN9X)
    #define HAVE_NV_FILE_FACILITY
#endif  // (IS_WINNT5 || IS_WIN9X)
////////////////////////////////////////////////////////////////////////////
void __cdecl LOG(char * szFormat, ...)
{
	//check whether we can use file IO (w2k, w9x -- yes; NT4 -- no)
#ifdef HAVE_NV_FILE_FACILITY
    static BOOL first = TRUE;
    char   str[256];

	nvSprintfVAL (str, szFormat, (va_list)(&szFormat+1));
	nvStrCat(str,"\n");

    if (logToFile) 
	{
        HANDLE h;
        if (first) 
		{
            nvSprintf (nvStereoLog,"%s\\%s", STEREO_LOG_DIRECTORY, DEFAULT_LOG_NAME);
            CreateDirectory(STEREO_LOG_DIRECTORY, NULL);
            h = NvCreateFile(nvStereoLog, GENERIC_WRITE, 0,0, CREATE_ALWAYS,0,0);
            first = FALSE;
            NvCloseHandle (h); 
        }
        h = NvCreateFile(nvStereoLog, GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);
        if (h != INVALID_HANDLE_VALUE) 
		{
            NvU32 dw;
            SetFilePointer (h,0,NULL,FILE_END); //appending
            NvWriteFile (h,str,nvStrLen(str),&dw,NULL);
            NvCloseHandle (h);
        }
    }
#endif
}
////////////////////////////////////////////////////////////////////////////


NVD3DTEXSTAGESTATE tssPrevState[2];
DWORD dwPreLaserState[NUM_STATES];

#ifdef LASERSTATECHANGE
DWORD dwSaveRenderState[D3D_RENDERSTATE_MAX+1];
BOOL  StatesWereSaved;
#endif  //LASERSTATECHANGE

void SetupLaserStates(PNVD3DCONTEXT pContext)
{
    HRESULT rval;

#ifdef LASERSTATECHANGE
    DWORD          dbgShowStateSave;
    if (StatesWereSaved)
    {
        //Check if anything changed.
        dbgShowStateSave = dbgShowState;
        dbgShowState |= NVDBG_SHOW_RENDER_STATE;
        for (DWORD i=0; i<D3D_RENDERSTATE_MAX+1; i++)
        {
            if (dwSaveRenderState[i] != pContext->dwRenderState[i])
            {
                // state value !changed
                dbgShowRenderStateChange (TRUE, i, pContext->dwRenderState[i]);
            }
        }
        dbgShowState = dbgShowStateSave;
    }
    StatesWereSaved = TRUE;
    nvMemCopy(dwSaveRenderState, pContext->dwRenderState, sizeof(dwSaveRenderState));
#endif  //LASERSTATECHANGE

    // set up state
    for (DWORD i = 0; i < NUM_STATES; i++)
    {
        dwPreLaserState[i] = pContext->dwRenderState[dwLaserStateSet[i].dwState];
        nvSetContextState(pContext, dwLaserStateSet[i].dwState, dwLaserStateSet[i].dwValue, &rval);
    }

    // set the logo texture
    nvMemCopy(tssPrevState, pContext->tssState, sizeof(tssPrevState));
    memset(&pContext->tssState[0], 0, sizeof(tssPrevState));
    pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP    ] = (DWORD)pLaser_Obj;
    pContext->tssState[0].dwValue[D3DTSS_COLOROP       ] = D3DTOP_SELECTARG1;
    pContext->tssState[0].dwValue[D3DTSS_COLORARG1     ] = D3DTA_TEXTURE;
    pContext->tssState[0].dwValue[D3DTSS_ALPHAOP       ] = D3DTOP_SELECTARG1;
    pContext->tssState[0].dwValue[D3DTSS_ALPHAARG1     ] = D3DTA_TEXTURE;
    pContext->tssState[0].dwValue[D3DTSS_ADDRESSU      ] = D3DTADDRESS_WRAP;
    pContext->tssState[0].dwValue[D3DTSS_ADDRESSV      ] = D3DTADDRESS_WRAP;
    pContext->tssState[0].dwValue[D3DTSS_MAGFILTER     ] = D3DTFG_LINEAR;
    pContext->tssState[0].dwValue[D3DTSS_MINFILTER     ] = D3DTFN_LINEAR;
    pContext->tssState[0].dwValue[D3DTSS_MIPFILTER     ] = D3DTFP_NONE;
    pContext->tssState[0].dwValue[D3DTSS_MAXANISOTROPY ] = 1;
    pContext->tssState[1].dwValue[D3DTSS_COLOROP       ] = D3DTOP_DISABLE;

    // make sure everything gets updated
#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= celsiusDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
    pContext->hwState.dwDirtyFlags |= kelvinDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
#endif
    NV_FORCE_TRI_SETUP(pContext);
}

void RestorePreLaserStates(PNVD3DCONTEXT pContext)
{
    HRESULT rval;

    // restore state
    for (DWORD i = 0; i < NUM_STATES; i++)
    {
        nvSetContextState(pContext, dwLaserStateSet[i].dwState, dwPreLaserState[i], &rval);
    }

    // restore texture stage state
    nvMemCopy(pContext->tssState, tssPrevState, sizeof(tssPrevState));

    // make sure everything gets updated
#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= celsiusDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
    pContext->hwState.dwDirtyFlags |= kelvinDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
#endif
    NV_FORCE_TRI_SETUP(pContext);
}

void  CreateLaserTextureContent(void)
{
    if (!pLaser_Texture)
        return;

    HMODULE hMod = LoadLibrary("nvstres.dll");

    if (hMod)
    {
        DWORD           i,j;
        DWORD           dwWidth, dwHeight, dwColorKey;
        DWORD           *pMem;
        WORD            *pLaserImage, *pLaser, wColorKey;
        DWORD           lPitch;
        LPDDHALMODEINFO lpModeInfo;
        float           fWidth;

        GetLaserSight pGetSightFn = (GetLaserSight) GetProcAddress(hMod, "GetLaserSight");

        if(pGetSightFn) {
            if((pLaserImage = pGetSightFn(dwWidth, dwHeight, dwColorKey)) != NULL) {
                // We assume that the Laser Sight image is 64x64x16 and if the color is 0xFFDF
                //than it is transparent.
                nvAssert(dwWidth == LASER_WIDTH && dwHeight == LASER_HEIGHT);
                wColorKey = (WORD)(((dwColorKey & 0xF80000) >> 8) | ((dwColorKey & 0xFC00) >> 5) | ((dwColorKey & 0xF8) >> 3));
                pLaser = pLaserImage;
                lPitch = pLaser_Texture->getPitch() >> 2;
                lpModeInfo = &pDriverData->ModeList[pDXShare->dwModeNumber];
                fWidth = (D3DVALUE)(lpModeInfo->dwWidth);
                LaserMaxSize = fWidth/LaserMaxSizeDivider;
                LaserMinSize = fWidth/LaserMinSizeDivider;
                pLaser_Texture->updateLinearSurface();
                pMem = (DWORD *)pLaser_Texture->getLinear()->getAddress();
                for (i = 0; i < LASER_HEIGHT; i++)
                {
                    for (j = 0; j < LASER_WIDTH; j++)
                    {
                        if (pLaser[j] == wColorKey)
                            pMem[j] = 0;
                        else
                            pMem[j] = (((DWORD)pLaser[j] & 0xF800) << 8) | (((DWORD)pLaser[j] & 0x07E0) << 5) | (((DWORD)pLaser[j] & 0x001F) << 2) | Transparency;
                    }
                    pMem += lPitch;
                    pLaser += LASER_WIDTH;
                }
                pLaser_Texture->getLinear()->tagUpToDate();
                pLaser_Texture->getSwizzled()->tagOutOfDate();
                ReleaseLaserSight pReleaseSightFn = (ReleaseLaserSight) GetProcAddress(hMod, "ReleaseLaserSight");
                if(pReleaseSightFn)
                    pReleaseSightFn(pLaserImage);
            }
        }
        FreeLibrary(hMod);
    }
    return;
}

#if 0
void  ClearLaserSight(PNVD3DCONTEXT pContext)
{
    return;
    if (!STEREO_ACTIVATED)
        return;
    if (pStereoData->StereoSettings.dwFlags & STEREO_CLEAROCCURED)
    {
        pStereoData->StereoSettings.dwFlags &= ~STEREO_CLEAROCCURED;
        return;
    }
    //We need to clear the area underneath the laser sigth.
    if(pLaserDP2Command_Lcl)
    {
        nvAssert(0);
        FLATPTR SaveCommandBuf = pLaserDP2Command_Lcl->lpGbl->fpVidMem;
        pLaserDP2Command_Lcl->lpGbl->fpVidMem = (FLATPTR)&LaserDP2ClearCommand;

        LPDDHALMODEINFO lpModeInfo = &pDriverData->ModeList[pDXShare->dwModeNumber];
        LaserDP2ClearData.dwhContext = (DWORD)pContext;
        LaserDP2ClearCommand.Clear.Rects[0].left   = 0;
        LaserDP2ClearCommand.Clear.Rects[0].top    = 0;
        LaserDP2ClearCommand.Clear.Rects[0].bottom = lpModeInfo->dwHeight;
        LaserDP2ClearCommand.Clear.Rects[0].right  = lpModeInfo->dwWidth;
        LaserDP2ClearCommand.Clear.dwFillColor     = pContext->dwLastFillColor;
        nvDrawPrimitives2(&LaserDP2ClearData);
        pLaserDP2Command_Lcl->lpGbl->fpVidMem = SaveCommandBuf;
    } else
        nvAssert(0);
}
#endif
#endif  //LASER_SIGHT

#ifdef  FLAT_STAT
#define FLATARRAYSIZE 256
typedef struct
{
    D3DVALUE RHW;
    DWORD    dwCount;
} FLATOBJECTSTAT, *LPFLATOBJECTSTAT;

FLATOBJECTSTAT FlatObjects[FLATARRAYSIZE];
DWORD dwNFlatObjects;

void RegisterFlatObject(D3DVALUE RHW, DWORD dwCount)
{
    if (dwNFlatObjects < FLATARRAYSIZE)
    {
        FlatObjects[dwNFlatObjects].RHW     = RHW;
        FlatObjects[dwNFlatObjects].dwCount = dwCount;
        dwNFlatObjects++;
    } else
        nvAssert(0);
}
#endif  //FLAT_STAT

#ifdef  SNAP_SHOT

#include "NvImage.h"

#define NVSTEREO_IMAGE_SIGNATURE 0x4433564e //NV3D
typedef struct  _Nv_Stereo_Image_Header
{
    DWORD   dwSignature;
    DWORD   dwWidth;
    DWORD   dwHeight;
    DWORD   dwBPP;
    DWORD   dwSwapEyes;
} NVSTEREOIMAGEHEADER, *LPNVSTEREOIMAGEHEADER;

HOTKEY SaveStereoImage;
DWORD  JPEGCompressQuality;

void ConvertTo24(LPBYTE Dst, LPVOID Src, LPVOID SrcRight, DWORD nPixels, DWORD dwBPP)
{
    DWORD SrcCopy[3200];
    DWORD dwBytes = nPixels * dwBPP;
    DWORD dwTotalPixels = nPixels * 2;
    DWORD i;
    memcpy ((LPVOID)SrcCopy, SrcRight, dwBytes); //For faster access later
    memcpy ((LPVOID)((LPBYTE)SrcCopy + dwBytes), Src, dwBytes); //For faster access later
    switch (dwBPP)
    {
    case 2:
        //16 bit
        for (i = 0; i < dwTotalPixels; i++)
        {
            WORD Pixel = ((WORD *)&SrcCopy)[i];
            BYTE r,g,b;
            r = (Pixel >> 8) & 0xF8;
            g = (Pixel >> 3) & 0xFC;
            b = (Pixel << 3) & 0xF8;
            Dst[0] = r;
            Dst[1] = g;
            Dst[2] = b;
            Dst += 3;
        }
        break;

    case 4:
        //32 bit
        for (i = 0; i < dwTotalPixels; i++)
        {
            DWORD Pixel = ((DWORD *)&SrcCopy)[i];
            BYTE r,g,b;
            r = (Pixel >> 16) & 0xFF;
            g = (Pixel >> 8) & 0xFF;
            b = Pixel & 0xFF;
            Dst[0] = r;
            Dst[1] = g;
            Dst[2] = b;
            Dst += 3;
        }
        break;

    default:
        nvAssert(0);
    }
}

void SaveStereoImageFile(LPDDHAL_FLIPDATA pfd)
{
    char        FileName[256];
    DWORD       i;
    CreateDirectory(STEREO_IMG_DIRECTORY, NULL);
    nvSprintf (FileName,"%s\\%s*.jps", STEREO_IMG_DIRECTORY, pStereoData->bAppRealName);
    CNvObject* pNvObj = GET_PNVOBJ(pfd->lpSurfCurr);
    if (!pNvObj)
    {
        //Doesn't have a valid nvObj - bail out.
        LOG("SaveStereoImageFile: Surface doesn't have a valid nvObj");
		nvAssert(0);
        return;
    }

    WaitForIdle (TRUE,FALSE);

    CSimpleSurface *pSurf = pNvObj->getSimpleSurface();
    DWORD dwPitch = pSurf->getPitch();
    DWORD dwWidth = pSurf->getWidth();
    DWORD dwHeight = pSurf->getHeight();

    LPBYTE pBuf, pBufPtr;
    DWORD Scan24Size = dwWidth * 2 * 3;
    pBuf = pBufPtr = (LPBYTE)GlobalAlloc(GPTR, Scan24Size * dwHeight);
    LPVOID pAddr, pAddrRight;
    pAddr = (LPVOID)pSurf->getAddress(); //Left eye
    pAddrRight = (LPVOID)pSurf->getAddressRight(); //Right eye
    //We will write out one scanline at a time
    for (i = 0; i < dwHeight; i++)
    {
        ConvertTo24(pBufPtr, pAddr, pAddrRight, dwWidth, pSurf->getBPP());
        pBufPtr += Scan24Size;
        pAddr = (LPVOID)((LPBYTE)pAddr + dwPitch);
        pAddrRight = (LPVOID)((LPBYTE)pAddrRight + dwPitch);
    }
    LPCIMAGEOBJECT          pImageObject;
    HINSTANCE hImageDLL = LoadLibrary("nvImage.dll");
    if (hImageDLL)
    {
        CREATEIMAGEOBJECT CreateImageObject = (CREATEIMAGEOBJECT)GetProcAddress(hImageDLL, "CreateImageObject");
        if (!CreateImageObject(pImageObject))
        {
            pImageObject->SetJPEGParameters(JPEG_WRITE_QUALITY, JPEGCompressQuality);
            pImageObject->CompressJPEG((LPVOID)pBuf, dwWidth * 2, dwHeight, FileName);
            pImageObject->DestroyImageObject();
        }
        FreeLibrary(hImageDLL);
    }
    GlobalFree(pBuf);
}
#endif  //SNAP_SHOT

//ConfigAssistInfo.dwFlags fields
#define _2DSUSPECT                      0x00000002

#ifdef  STEREO_CONFIG_ASSIST

extern BOOL                 WriteRegistry(char *pSubKey, DWORD dwValue, BOOL DefaultFolder);
#define DeleteConfigInfo()          \
    WriteRegistry(NULL, 0, FALSE);  \
    ResetStereoParameters();

CONFIG_ASSIST_INFO ConfigAssistInfo;

void SuggestOptimalStereoSettings(void)
{
    DWORD dwFlags = pStereoData->StereoSettings.dwFlags;
    pStereoData->StereoSettings.dwFlags &= ~STEREO_CUSTOMSETTINGSMASK; //Erase all old flags
    float Divider = ConfigAssistInfo.rhwMax * pStereoData->StereoSettings.fStereoConvergence;
    if (Divider != 0)
        pStereoData->StereoSettings.fConvergenceMultiplier = 1.f/Divider;
    else
        pStereoData->StereoSettings.fConvergenceMultiplier = 0.0f;
    pStereoData->StereoSettings.dwFlags |= STEREO_CONVERGENCEMULTIPLIER;
    if (dwFlags & STEREO_FAVORSZOVERRHW)
    {
        pStereoData->StereoSettings.dwFlags |= STEREO_FAVORSZOVERRHW;
        if (ConfigAssistInfo.szMax2D != -9999.f)
        {
            if (!(dwFlags & STEREO_RHWGREATERATSCREEN))
            {
                pStereoData->StereoSettings.fRHWGreaterAtScreen = ConfigAssistInfo.szMax2D;
            }
            pStereoData->StereoSettings.dwFlags |= STEREO_RHWGREATERATSCREEN;
        }

        if (dwFlags & STEREO_RHWLESSATSCREEN)
        {
            pStereoData->StereoSettings.dwFlags |= STEREO_RHWLESSATSCREEN;
        } else
        {
            if (ConfigAssistInfo.szMin2D != 9999.f)
            {
                pStereoData->StereoSettings.dwFlags |= STEREO_RHWLESSATSCREEN;
                pStereoData->StereoSettings.fRHWLessAtScreen = ConfigAssistInfo.szMin2D;
            }
        }
    } else
    {
        if (ConfigAssistInfo.rhwMin2D != 9999.f)
        {
            if (!(dwFlags & STEREO_RHWGREATERATSCREEN))
            {
                pStereoData->StereoSettings.fRHWGreaterAtScreen = ConfigAssistInfo.rhwMin2D;
            }
            pStereoData->StereoSettings.dwFlags |= STEREO_RHWGREATERATSCREEN;
        }

        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN)
        {
            pStereoData->StereoSettings.dwFlags |= STEREO_RHWLESSATSCREEN;
        } else
        {
#if 1
            if (ConfigAssistInfo.rhwMax2D != -9999.f)
            {
                pStereoData->StereoSettings.dwFlags |= STEREO_RHWLESSATSCREEN;
                pStereoData->StereoSettings.fRHWLessAtScreen = ConfigAssistInfo.rhwMax2D;
            }
#endif
        }
    }
    ConfigAssistInfo.rhwMin     = 9999.f;
    ConfigAssistInfo.rhwMin2D   = 9999.f;
    ConfigAssistInfo.rhwMax     = -9999.f;
    ConfigAssistInfo.rhwMax2D   = -9999.f;
    ConfigAssistInfo.szMin      = 9999.f;
    ConfigAssistInfo.szMin2D    = 9999.f;
    ConfigAssistInfo.szMax      = -9999.f;
    ConfigAssistInfo.szMax2D    = -9999.f;
}

struct _StereoSettingsStack {
    BOOL            Valid;
    STEREOSETTINGS  StereoSettings;
} StereoSettingsStack;

BOOL PushStereoSettings(void)
{
    if (StereoSettingsStack.Valid)
        //No room to save
        return FALSE;
    StereoSettingsStack.StereoSettings  = pStereoData->StereoSettings;
    StereoSettingsStack.Valid           = TRUE;
    return TRUE;
}

BOOL PopStereoSettings(void)
{
    if (!StereoSettingsStack.Valid)
        //No valid stack
        return FALSE;
    pStereoData->StereoSettings = StereoSettingsStack.StereoSettings;
    StereoSettingsStack.Valid   = FALSE;
    return TRUE;
}

void SuggestStereoSettings(void)
{
    if (PushStereoSettings())
    {
        SuggestOptimalStereoSettings();
    }
}

void UnsuggestStereoSettings(void)
{
    PopStereoSettings();
}

void ConfigFlush()
{
    DWORD dw;
    DWORD nBytes = nvStrLen(ConfigAssistInfo.Buf);
    if (!WriteFile(ConfigAssistInfo.FileHandle,ConfigAssistInfo.Buf,nBytes,&dw,0)) {
        LOG("ConfigFlush: can't write to file");
        DWORD dw=GetLastError();
        __asm {
            mov eax,[dw]
            int 3
        }

    }
    FlushFileBuffers (ConfigAssistInfo.FileHandle);
    ConfigAssistInfo.Buf[0] = 0;
}

#include <time.h>

void DumpConfigInfo(void)
{
    char TmpBuf[1024];
    CreateDirectory(STEREO_LOG_DIRECTORY, NULL);
    nvSprintf (TmpBuf,"%s\\%s", STEREO_LOG_DIRECTORY, pStereoData->bAppRealName);
    ConfigAssistInfo.FileHandle=CreateFile(TmpBuf,GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
    if (ConfigAssistInfo.FileHandle==INVALID_HANDLE_VALUE) {
        LOG("DumpConfigInfo: invalid file handle, file %s", TmpBuf);
        MessageBeep (0);
		__asm int 3;
        return;
    }

    if (!(pStereoData->StereoSettings.dwFlags & STEREO_CUSTOMSETTINGSMASK))
    {
        //Nothing has been customized yet. We will do the automatic setting calculation
        //and then procede with saving it.
        SuggestOptimalStereoSettings();
    }

    if (pStereoData->dwHWTnL)
        nvStrCpy(TmpBuf,"HW TnL");
    else
        nvStrCpy(TmpBuf,"SW TnL");
    nvSprintf (ConfigAssistInfo.Buf,"AppName=%s (%s)\n",pStereoData->bAppName, TmpBuf);
    nvSprintf (ConfigAssistInfo.Buf,"AppRealName=%s (%s)\n",pStereoData->bAppRealName, TmpBuf);

    nvSprintf (TmpBuf,"StereoConvergenceMultiplier=%f\n",pStereoData->StereoSettings.fConvergenceMultiplier);
    nvStrCat (ConfigAssistInfo.Buf, TmpBuf);

    ConfigFlush();

    if (pStereoData->StereoSettings.fStereoSeparation != DEFAULT_STEREO_SEPARATION)
    {
        nvSprintf (ConfigAssistInfo.Buf,"StereoSeparation=%f\n",pStereoData->StereoSettings.fStereoSeparation);
        WriteRegistry(NV_REG_STEREO_SEPARATION, *(DWORD *)&pStereoData->StereoSettings.fStereoSeparation, TRUE);
        ConfigFlush();
    }

    if (STEREODATA(StereoSettings.dwFlags) & STEREO_GAMMACORRECTION && 
		pStereoData->StereoSettings.fStereoGamma != 1.0f)
    {
        nvSprintf (ConfigAssistInfo.Buf,"StereoGamma=%f\n",pStereoData->StereoSettings.fStereoGamma);
        WriteRegistry("StereoGamma", *(DWORD *)&pStereoData->StereoSettings.fStereoGamma, TRUE);
        ConfigFlush();
    }

    if (pStereoData->StereoSettings.fStereoConvergence != DEFAULT_STEREO_CONVERGENCE)
    {
        nvSprintf (ConfigAssistInfo.Buf,"StereoConvergence=%f\n",pStereoData->StereoSettings.fStereoConvergence);
        nvSprintf (TmpBuf,"MinRHW=%f (farthest)\n",ConfigAssistInfo.rhwMin);
        nvStrCat (ConfigAssistInfo.Buf, TmpBuf);
        nvSprintf (TmpBuf,"MaxRHW=%f (closest)\n",ConfigAssistInfo.rhwMax);
        nvStrCat (ConfigAssistInfo.Buf, TmpBuf);
        WriteRegistry(NV_REG_STEREO_CONVERGENCE, *(DWORD *)&pStereoData->StereoSettings.fStereoConvergence, FALSE);

        ConfigFlush();
    }

    float fConvergenceMultiplier = pStereoData->StereoSettings.fConvergenceMultiplier;
    nvSprintf (ConfigAssistInfo.Buf,"Suggested StereoConvergenceMultiplier=%f\n",fConvergenceMultiplier);

    ConfigFlush();

    D3DVALUE fSuggestedPostStereoConvergence = pStereoData->StereoSettings.fStereoConvergence
                                             * fConvergenceMultiplier;
    D3DVALUE fRHWInfinity = 0.245f/(pStereoData->StereoSettings.fScreenStereoSeparation*fSuggestedPostStereoConvergence);
    nvSprintf (ConfigAssistInfo.Buf,"Suggested Infinity RHW=%f\n",fRHWInfinity);

    if (fRHWInfinity > ConfigAssistInfo.rhwMin)
    {
        //Part of Z range is at infinity and beyond!!!
        D3DVALUE fPercent = (fRHWInfinity - ConfigAssistInfo.rhwMin)/(ConfigAssistInfo.rhwMax - ConfigAssistInfo.rhwMin);
        nvSprintf (TmpBuf,"Warning!!! %f of Z range is at infinity and beyond!!!\n", fPercent);
        nvStrCat (ConfigAssistInfo.Buf, TmpBuf);
    }

    if (pStereoData->StereoSettings.dwFlags & STEREO_FAVORSZOVERRHW)
    {
        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN)
        {
            nvSprintf (TmpBuf,"RHWGreaterAtScreen=%f\n", pStereoData->StereoSettings.fRHWGreaterAtScreen);
            nvStrCat (ConfigAssistInfo.Buf, TmpBuf);
            WriteRegistry(NV_REG_STEREO_RHWGREATERATSCREEN, *(DWORD *)&pStereoData->StereoSettings.fRHWGreaterAtScreen, FALSE);
            ConfigFlush();
        }

        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN)
        {
            WriteRegistry(NV_REG_STEREO_RHWLESSATSCREEN, *(DWORD *)&pStereoData->StereoSettings.fRHWLessAtScreen, FALSE);
        }
    } else
    {
        if (ConfigAssistInfo.rhwMin2D != 9999.f)
        {
            nvSprintf (TmpBuf,"Farthest object with equal RHW is at %f\n", ConfigAssistInfo.rhwMin2D);
            nvStrCat (ConfigAssistInfo.Buf, TmpBuf);
        }
        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN)
        {
            nvSprintf (TmpBuf,"RHWGreaterAtScreen=%f\n", pStereoData->StereoSettings.fRHWGreaterAtScreen);
            nvStrCat (ConfigAssistInfo.Buf, TmpBuf);
            WriteRegistry(NV_REG_STEREO_RHWGREATERATSCREEN, *(DWORD *)&pStereoData->StereoSettings.fRHWGreaterAtScreen, FALSE);
        }

        ConfigFlush();

        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN)
        {
            WriteRegistry(NV_REG_STEREO_RHWLESSATSCREEN, *(DWORD *)&pStereoData->StereoSettings.fRHWLessAtScreen, FALSE);
        }
    }

    ConfigFlush();

    if (pStereoData->StereoSettings.dwFlags & STEREO_AUTOCONVERGENCE)
    {
        WriteRegistry(NV_REG_STEREO_AUTOCONVERGENCE, 1, FALSE);
        WriteRegistry(NV_REG_STEREO_CONVERGENCEADJUSTPACE, *(DWORD *)&(pStereoData->StereoSettings.AutoConvergenceAdjustPace), FALSE);
    } else
        WriteRegistry(NV_REG_STEREO_AUTOCONVERGENCE, 0, FALSE);

    WriteRegistry(NV_REG_STEREO_FRUSTUMADJUSTMODE, pStereoData->StereoSettings.FrustumAdjustMode, FALSE);

#ifdef  LASER_SIGHT
    if (pStereoData->StereoSettings.dwFlags & STEREO_LASERSIGHT)
    {
        WriteRegistry(NV_REG_STEREO_LASERXADJUST, *(DWORD *)&pStereoData->StereoSettings.fLaserXAdjust, FALSE);
        WriteRegistry(NV_REG_STEREO_LASERYADJUST, *(DWORD *)&pStereoData->StereoSettings.fLaserYAdjust, FALSE);
    }
#endif  //LASER_SIGHT

    time_t CurrentTime;
    time(&CurrentTime);
    WriteRegistry("Time", CurrentTime, FALSE);
    CLOSE_HANDLE(ConfigAssistInfo.FileHandle);

    ResetStereoParameters();
}

#endif  //STEREO_CONFIG_ASSIST

BOOL WriteRegistry(char *pSubKey, DWORD dwValue, BOOL DefaultFolder)
{
    BOOL RVal = FALSE;
    HKEY hKey;
    HKEY hKeyApp;
    char StereoKey[256];

    nvStrCpy(StereoKey, NV4_REG_GLOBAL_BASE_PATH);
    nvStrCat(StereoKey, "\\");
    nvStrCat(StereoKey, NV4_REG_STEREO_SUBKEY);

    if (DefaultFolder)
    {
        RegOpenKeyEx(NV4_REG_GLOBAL_BASE_KEY, StereoKey, 0, KEY_ALL_ACCESS, &hKey);
        if (RegSetValueEx(hKey, pSubKey, NULL, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD)) == ERROR_SUCCESS)
            RVal = TRUE;
        RegCloseKey(hKey);
        return RVal;
    }

    nvStrCat(StereoKey, "\\GameConfigs");

    if (RegOpenKeyEx(NV4_REG_GLOBAL_BASE_KEY, StereoKey, 0, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
    {
        LOG("WriteRegistry: can't open %s", NV4_REG_GLOBAL_BASE_KEY);
		nvAssert(0);
        return RVal;
    }
    if (pSubKey == NULL)
    {
        //Request to delete the game config entry. We will make it empty by deleting and then creating empty
        RegDeleteKey(hKey, pStereoData->bAppRealName);
    }
    if (RegCreateKeyEx(hKey, pStereoData->bAppRealName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeyApp, NULL) != ERROR_SUCCESS)
    {
        LOG("WriteRegistry: can't create key %s", pStereoData->bAppRealName);
        nvAssert(0);
        RegCloseKey(hKey);
        return RVal;
    }
    RegCloseKey(hKey);
    if (pSubKey)
    {
        if (RegSetValueEx(hKeyApp, pSubKey, NULL, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD)) == ERROR_SUCCESS)
            RVal = TRUE;
    }
    RegCloseKey(hKeyApp);
    return RVal;
}

void StereoRightEyeSurfaceCopy(CSimpleSurface *pSurf)
{
    DWORD pSrc = (DWORD)pSurf->getAddress();
    DWORD pDst = (DWORD)pSurf->getAddressRight();
    if (!(pSrc | pDst))
        return;
    DWORD dwPitch = pSurf->getPitch();
    DWORD dwHeight = pSurf->getHeight();
    DWORD dwWidthBytes = pSurf->getWidth() * pSurf->getBPP();
    for (DWORD i = 0; i <= dwHeight; i++, pSrc += dwPitch, pDst += dwPitch)
        nvMemCopy(pDst, pSrc, dwWidthBytes);
}

void StereoRightEyeInit()
{
    CSimpleSurface *pSurf;
    for (DWORD i=0; i<3; i++)
    {
        pSurf = pStereoData->pRenderTargets[i];
        if (pSurf)
            StereoRightEyeSurfaceCopy(pSurf);
    }
    pSurf = ((PNVD3DCONTEXT)(pStereoData->dwContext))->pZetaBuffer;
    if (pSurf)
        StereoRightEyeSurfaceCopy(pSurf);
}

DWORD __stdcall StereoSetExclusiveMode32(LPDDHAL_SETEXCLUSIVEMODEDATA lpSetExclusiveMode)
{
    nvSetDriverDataPtrFromDDGbl (lpSetExclusiveMode->lpDD);
    if (STEREO_ENABLED)
    {
        if (lpSetExclusiveMode->dwEnterExcl)
        {
            pStereoData->StereoSettings.dwFlags &= ~STEREO_DISALLOWED_NOT_FULL_SCREEN;
#if 0
            if (pStereoData->StereoSettings.dwFlags & STEREO_FORCEDTOGDI)
            {
                nvAssert(0);
                pStereoData->StereoSettings.dwFlags &= ~STEREO_FORCEDTOGDI;
                ActivateStereo((PNVD3DCONTEXT)pStereoData->dwContext);
            }
#endif
        }
        else
        {
            if (pStereoData->dwContext)
            {
#if 0
                //Shouldn't be at this point. It happens on Kawasaki ATV Demo when
                //DX7 runtime fails to call our nvContextDestroy and then everything
                //goes wrong. We don't know what this game does to cause such a behaviour
                //but will try our best to minimize the negative effect.
                D3DHAL_CONTEXTDESTROYDATA ContextDestroyData;
                ContextDestroyData.dwhContext = pStereoData->dwContext;
                ContextDestroyData.ddrval     = 0;
                nvContextDestroy(&ContextDestroyData);
#else
                //nvAssert(0);
                //Potentially dangerous situation. At least we want to make sure that
                //stereo is turned off for time being.
                if (STEREO_ACTIVATED)
                {
                    //We need to turn stereo off
                    pStereoData->StereoSettings.dwFlags |= STEREO_FORCEDTOGDI;
                    DeactivateStereo((PNVD3DCONTEXT)pStereoData->dwContext);
                }
#endif
            }
            pStereoData->StereoSettings.dwFlags |= STEREO_DISALLOWED_NOT_FULL_SCREEN;
        }
    }
    lpSetExclusiveMode->ddRVal = DD_OK;
    NvReleaseSemaphore(pDriverData);

    // call the original handler
    SetExclusiveMode32(lpSetExclusiveMode);

    return DDHAL_DRIVER_HANDLED;
}

//---------------------------------------------------------------------------

/*
 * StereoFlipToGDISurface32 DDHAL callback
 */
DWORD __stdcall StereoFlipToGDISurface32 (LPDDHAL_FLIPTOGDISURFACEDATA lpFlipToGDISurface)
{
    lpFlipToGDISurface->ddRVal = DD_OK;
    nvSetDriverDataPtrFromDDGbl (lpFlipToGDISurface->lpDD);
    if (lpFlipToGDISurface->dwToGDI)
    {
        //Flip to GDI
        if (STEREO_ACTIVATED)
        {
            //We need to turn stereo off
            pStereoData->StereoSettings.dwFlags |= STEREO_FORCEDTOGDI;
            DeactivateStereo((PNVD3DCONTEXT)pStereoData->dwContext);
        }
    } else
    {
        //Flip from GDI
        //We need to turn stereo on if previously was forced to GDI
        if (pStereoData->StereoSettings.dwFlags & STEREO_FORCEDTOGDI)
        {
            pStereoData->StereoSettings.dwFlags &= ~STEREO_FORCEDTOGDI;
            ActivateStereo((PNVD3DCONTEXT)pStereoData->dwContext);
        }
    }

    NvReleaseSemaphore(pDriverData);

    // call the original handler
    return DDHAL_DRIVER_NOTHANDLED;
}

void StereoModeSetProcessing(void)
{
#if 0
    //********************************************************************************
    //* Would be nice to do something like below. But we can't manipulate stereo since
    //* this function gets called from 16 bit environment. At least we will keep an eye
    //* on it. Maybe some subset of stereo manipulation functionality can and has to be
    //* done here.
    //********************************************************************************
    NvSetStereoDataPtrFromDriverData;
    if (!STEREO_ENABLED || !pStereoData->StereoModeNumber)
    {
        //Nothing to be worried about.
        return;
    }
    //Mode switch while stereo is active causes a lot of problems, so we want to make
    //sure that stereo is on only when the mode that has been set matches that one
    //in which stereo had been initially activated. This logic doesn't imply any serious
    //restrictions because usually games switch video mode when they go into a stage like
    //introductory screens, advertisement videos and so on. We don't need stereo for those
    //stages anyways. It yet remains to be seen if this logic is flawed.
    if (STEREO_ACTIVATED)
    {
        if (pStereoData->StereoModeNumber != pDXShare->dwModeNumber)
        {
            //Turn stereo off
			LOG("StereoModeSetProcessing: video mode has changed, deactivating stereo");
            nvAssert(0);
            DeactivateStereo((PNVD3DCONTEXT)pStereoData->dwContext);
        }
    } else
    {
        if (pStereoData->StereoModeNumber == pDXShare->dwModeNumber
            && !(pStereoData->StereoSettings.dwFlags & (STEREO_FORCEDOFF|STEREO_FORCEDTOGDI|STEREO_DISALLOWED)))
        {
			LOG("StereoModeSetProcessing: going back to stereo");
            //Turn stereo back on
            nvAssert(0);
            ActivateStereo((PNVD3DCONTEXT)pStereoData->dwContext);
        }
    }
#endif
}

#ifdef  STEREO_VIEWER_DRV
DWORD CreateStereoViewer(LPBYTE pStereoViewerDrvName)
{
    LPCREATESTEREOVIEWER  pCreateStereoViewer;
    STEREOCAPS            StereoCaps;
    DWORD                 dwStereoFormatBits;

    pStereoData->dwStereoFormat = SVF_NONE;
    if (!(pStereoData->hStereoDrv = LoadLibrary((const char *)pStereoViewerDrvName)))
        return 1;
    if (!(pCreateStereoViewer = (LPCREATESTEREOVIEWER)GetProcAddress(pStereoData->hStereoDrv, "CreateStereoViewer")))
        goto ErrorExitFreeLib;
    if ((*pCreateStereoViewer)(&pStereoData->pStereoViewer) != STEREO_OK)
        goto ErrorExitFreeLib;
    StereoCaps.dwSize = sizeof (STEREOCAPS);
    StereoCaps.dwFlags = STEREOCAPS_SUPPORTEDFORMATS;
    StereoCaps.dwSupportedFormats = UPTODATE_STEREO_SUPPORT;
    if (pStereoData->pStereoViewer->GetCaps(&StereoCaps) != STEREO_OK)
        goto ErrorExitFreeViewer;
    if (StereoCaps.dwSize != sizeof (STEREOCAPS))
        goto ErrorExitFreeViewer;
    if (!(StereoCaps.dwSupportedFormats & UPTODATE_STEREO_SUPPORT))
        goto ErrorExitFreeViewer;
    if (StereoCaps.dwPreferredFormat & UPTODATE_STEREO_SUPPORT)
        dwStereoFormatBits = StereoCaps.dwPreferredFormat;
    else
        dwStereoFormatBits = StereoCaps.dwSupportedFormats & UPTODATE_STEREO_SUPPORT;
    //Parse the bits in some priority order to avoid the case when we have multiple bits.
    if (dwStereoFormatBits & SVF_OVERANDUNDER)
        pStereoData->dwStereoFormat = SVF_OVERANDUNDER;
    else
    {
        if (dwStereoFormatBits & SVF_FRAMESEQUENTIAL)
            pStereoData->dwStereoFormat = SVF_FRAMESEQUENTIAL;
    }
#if 0
    __asm int 3
    //To force Over and Under for debugging
    pStereoData->dwStereoFormat = SVF_OVERANDUNDER;
#endif
    pStereoData->StereoViewerCaps = StereoCaps;

    return 0;

ErrorExitFreeViewer:
    pStereoData->pStereoViewer->DestroyStereoViewer();

ErrorExitFreeLib:
    FreeLibrary(pStereoData->hStereoDrv);
    pStereoData->hStereoDrv = NULL;
    return 1;
}
#endif  //STEREO_VIEWER_DRV

void StereoModifyDDHALInfo(void)
{
    if (!STEREO_ENABLED)
        return;
    pDriverData->DDCallbacks.FlipToGDISurface      = (LPDDHAL_FLIPTOGDISURFACE)StereoFlipToGDISurface32;
    pDriverData->DDCallbacks.SetExclusiveMode      = StereoSetExclusiveMode32;
    pDriverData->DDCallbacks.dwFlags              |= DDHAL_CB32_FLIPTOGDISURFACE | DDHAL_CB32_SETEXCLUSIVEMODE;
}

void LoadStereoRegistry(void)
{
    HKEY hKey;
    char StereoKey[256];
    DWORD   dwNameSize;
    DWORD   dwNameType;
    float fMonitorSize;

    nvStrCpy(StereoKey, NV4_REG_GLOBAL_BASE_PATH);
    nvStrCat(StereoKey, "\\");
    nvStrCat(StereoKey, NV4_REG_STEREO_SUBKEY);

    if (RegOpenKeyEx(NV4_REG_GLOBAL_BASE_KEY, StereoKey, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS) {
        DWORD   dwSize = sizeof(long);
        DWORD   dwType = REG_DWORD;
        long    lValue;

        if (RegQueryValueEx(hKey, NV_REG_STEREO_ENABLED, NULL, &dwType, (LPBYTE)&lValue, &dwSize) != ERROR_SUCCESS)
        {
            //Don't even look further.
            goto LSR_ExitWithClose;
        }
        if (lValue == 1)
        {
            if (STEREO_ENABLED)
            {
                //The registry settings might have changed since the last run. We have to reload them.
                pStereoData->dwLastEye = EYE_NONE;
                pStereoData->dwHWTnL = 0;
                pStereoData->StereoSettings.dwFlags = 0;
                pStereoData->StereoModeNumber = 0;
                pDriverData->pStereoData = 0;
                goto LSR_ReloadRegistry;
            }
        } else
        {
            if (STEREO_ENABLED)
            {
                //We don't want stereo any more but we had it before.
                DestroyStereo();
            }
            goto LSR_ExitWithClose;
        }
        if (!(pStereoData = (LPSTEREODATA)AllocIPM(sizeof(STEREODATA))))
        {
            goto LSR_ExitWithClose;
        }
        memset(pStereoData, 0, sizeof(STEREODATA));
LSR_ReloadRegistry:
#ifdef  STEREO_CONFIG_ASSIST
        ConfigAssistInfo.dwFlags = 0;
#endif  //STEREO_CONFIG_ASSIST
        //Next setting is default. We expect to get call to SetExclusiveMode callback and only if an
        //application goes full screen we will allow to use stereo;
        pStereoData->StereoSettings.dwFlags |= STEREO_DISALLOWED_NOT_FULL_SCREEN;
#ifdef  STEREO_VIEWER_DRV
        //Look for the stereo viewer driver first.
        dwNameSize = sizeof(pStereoData->StereoViewerName);
        dwNameType = REG_SZ;
        if (RegQueryValueEx(hKey, NV_REG_STEREO_STEREOVIEWER, NULL, &dwNameType, (LPBYTE)pStereoData->StereoViewerName, &dwNameSize) != ERROR_SUCCESS)
        {
            FreeIPM(pStereoData);
            goto LSR_ExitWithClose;
        }
        if (CreateStereoViewer(pStereoData->StereoViewerName))
        {
            FreeIPM(pStereoData);
            goto LSR_ExitWithClose;
        }
#else   //STEREO_VIEWER_DRV==0
        pStereoData->dwStereoHWType = STEREOCFG_ELSADDC; //Default type.
        if (RegQueryValueEx(hKey, NV_REG_STEREO_STEREOVIEWERTYPE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (lValue & 0x80000000)
            {
                pStereoData->StereoSettings.dwFlags |= STEREO_ANAGLYPH;
                lValue &= 0x7FFFFFFF;
            }
            pStereoData->dwStereoHWType = lValue;   //Stereo Viewer HW type.
        }
        pStereoData->dwLineCodeColor = RGB(255, 0, 0); //Blue by default
        if (RegQueryValueEx(hKey, "LineCodeColor", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->dwLineCodeColor = lValue;   //Stereo Viewer HW type.
        }
		if (pStereoData->StereoSettings.dwFlags & STEREO_ANAGLYPH)
		{
			STEREODATA(dwLeftAnaglyphFilter)  = 0xFFFF0000;	//Red
			STEREODATA(dwRightAnaglyphFilter) = 0xFF00FFFF;	//Cyan
			//Get the filter masks for the eyes
			if (RegQueryValueEx(hKey, "LeftAnaglyphFilter", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
			{
				STEREODATA(dwLeftAnaglyphFilter) = lValue;   //Stereo Viewer HW type.
			}
			if (RegQueryValueEx(hKey, "RightAnaglyphFilter", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
			{
				STEREODATA(dwRightAnaglyphFilter) = lValue;   //Stereo Viewer HW type.
			}
		}
#endif  //STEREO_VIEWER_DRV
        pDriverData->pStereoData = (DWORD)pStereoData; //From now on STEREO_ENABLED is set.
        pStereoData->bStereoActivated = FALSE;
        DWORD dwDummy;
        NvRmConfigSet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                   NV_CFG_STEREO_CONFIG, 0, &dwDummy);
        pStereoData->RmStereoParams.Flags = 0;
        pStereoData->RmStereoParams.FlipOffsets[0][0] =
        pStereoData->RmStereoParams.FlipOffsets[1][0] =
        pStereoData->RmStereoParams.FlipOffsets[2][0] =
        pStereoData->RmStereoParams.FlipOffsets[3][0] = 0xFFFFFFFF;

        NvRmConfigSet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
               NV_CFG_STEREO_CONFIG, (DWORD)&pStereoData->RmStereoParams, &dwDummy);
        //Now we can handle the remaining registry stuff like hotkeys and adjustments.
        if (RegQueryValueEx(hKey, NV_REG_STEREO_DEFAULTON, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (lValue)
                pStereoData->StereoSettings.dwFlags |= STEREO_DEFAULTON;
        }
        pStereoData->StereoSettings.fStereoSeparation  = DEFAULT_STEREO_SEPARATION;
        if (RegQueryValueEx(hKey, NV_REG_STEREO_SEPARATION, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoSettings.fStereoSeparation = *(float *)&lValue;
            pStereoData->StereoSettings.dwFlags |= STEREO_SEPARATION;
        }

        pStereoData->StereoSettings.fStereoGamma = 1.0f;
        if (RegQueryValueEx(hKey, "StereoGamma", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoSettings.fStereoGamma = *(float *)&lValue;
			STEREODATA(StereoSettings.dwFlags) |= STEREO_GAMMACORRECTION;
        }

        pStereoData->StereoSettings.fStereoConvergence = DEFAULT_STEREO_CONVERGENCE;
        if (RegQueryValueEx(hKey, NV_REG_STEREO_DISABLE_TnL, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (lValue)
            {
                pStereoData->StereoSettings.dwFlags |= STEREO_DISABLETnL;
                getDC()->nvD3DDevCaps.dd1Caps.dwDevCaps                   &= ~D3DDEVCAPS_HWTRANSFORMANDLIGHT;
                getDC()->nvD3DDevCaps.dd1Caps.dtcTransformCaps.dwSize      = 0;
                getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwSize       = 0;
            }
        }

        pStereoData->StereoSettings.fConvergenceMultiplier = DEFAULT_STEREO_CONVERGENCE_MULTIPLIER;
        if (RegQueryValueEx(hKey, NV_REG_STEREO_CONVERGENCEMULTIPLIER, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoSettings.fConvergenceMultiplier = *(float *)&lValue;
            pStereoData->StereoSettings.dwFlags |= STEREO_CONVERGENCEMULTIPLIER;
        }

        fMonitorSize = 16.f;  //17" is default and we assume 16" - viewable area
        if (RegQueryValueEx(hKey, NV_REG_STEREO_MONITORSIZE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            fMonitorSize = ((float)lValue) * 0.5f - 1.f; //Assume that viewable = diagonal - 1
        }
        //Now we'll calculate the MAX_STEREO_SEPARATION based on the following assumptions:
        // 1) The monitor aspect ratio is 4x3. So the horizontal size is fMonitorSize * 0.8.
        // 2) The average distance between eyes is 62.4 mm.
        //MAX_STEREO_SEPARATION - is percentage of the horizontal representing the distance
        //between eyes. Here we go:
        MAX_STEREO_SEPARATION = (62.4f / (0.8f * 25.4f)) / fMonitorSize;

#ifdef  LASER_SIGHT
        if (RegQueryValueEx(hKey, NV_REG_STEREO_LASERSIGHTENABLED, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (lValue)
            {
                pStereoData->StereoSettings.dwFlags |= STEREO_LASERSIGHTENABLED;
                dwNameSize = sizeof(pStereoData->LaserSightFile);
                dwNameType = REG_SZ;
                if (RegQueryValueEx(hKey, NV_REG_STEREO_LASERSIGHTFILE, NULL, &dwNameType, (LPBYTE)pStereoData->LaserSightFile, &dwNameSize) != ERROR_SUCCESS)
                {
                    DWORD i;
                    i = GetSystemDirectory((char *)pStereoData->LaserSightFile, sizeof (pStereoData->LaserSightFile));
                    pStereoData->LaserSightFile[i] = 0;
                    nvStrCat((char *)pStereoData->LaserSightFile, "\\Laser.bmp");
                }
                if (RegQueryValueEx(hKey, NV_REG_STEREO_LASERSIGHTPROPERTY, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
                    ProcessLaserSightProperty(lValue);
#ifdef  STEREO_CONFIG_ASSIST
                if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_LASER_X_PLUS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
                {
                    ConfigAssistInfo.LaserXPlusKey.dwValue = lValue;   //The hot key to increase the laser sight X position
                }
                if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_LASER_X_MINUS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
                {
                    ConfigAssistInfo.LaserXMinusKey.dwValue = lValue;   //The hot key to decrease the laser sight X position
                }
                if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_LASER_Y_PLUS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
                {
                    ConfigAssistInfo.LaserYPlusKey.dwValue = lValue;   //The hot key to increase the laser sight Y position
                }
                if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_LASER_Y_MINUS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
                {
                    ConfigAssistInfo.LaserYMinusKey.dwValue = lValue;   //The hot key to decrease the laser sight Y position
                }
#endif  //STEREO_CONFIG_ASSIST
            }
        }
#endif  //LASER_SIGHT

#ifdef  USE_POPUP_LIST  
		
        //check global flag, whether pop-ups enabled at all
	    if (RegQueryValueEx(hKey, NV_REG_STEREO_POPUP_ENABLED, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (lValue)
            {
                popupAgents.enabled() = true;
                //read options, e.g. enable/disable/params for pop-ups like FPS, lasersight, nvLogo, chat etc.
                popupAgents.getOptions();
            }
        }

#endif  //USE_POPUP_LIST

        pStereoData->StereoSettings.AutoConvergenceAdjustPace = 0.05f; //Default
        if (RegQueryValueEx(hKey, NV_REG_STEREO_AUTOCONVERGENCE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (lValue)
            {
                pStereoData->StereoSettings.dwFlags |= STEREO_AUTOCONVERGENCE;
                if (RegQueryValueEx(hKey, NV_REG_STEREO_CONVERGENCEADJUSTPACE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
                {
                    pStereoData->StereoSettings.AutoConvergenceAdjustPace = *(float *)&lValue;
                }
            }
        }

        if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_TOGGLE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoKeys.StereoToggle.dwValue = lValue;   // The hot key to toggle stereo.
        }

#ifdef  STEREO_CONFIG_ASSIST
        if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_SUGGESTSETTINGS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.SuggestKey.dwValue = lValue;   //The hot key to automatically set suggested stereo settings.
        }
        if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_UNSUGGESTSETTINGS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.UnsuggestKey.dwValue = lValue;   //The hot key to restore stereo settings before suggestion.
        }
        if (RegQueryValueEx(hKey, "WriteConfig", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.WriteKey.dwValue = lValue;   // The hot key to dump stereo config info.
        }
        if (RegQueryValueEx(hKey, "DeleteConfig", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.DeleteKey.dwValue = lValue;   // The hot key to remove stereo config info.
        }
        if (RegQueryValueEx(hKey, "ToggleAutoConvergence", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.ToggleAutoConvergence.dwValue = lValue;   // The hot key to dump stereo config info.
        }
        if (RegQueryValueEx(hKey, "ToggleAutoConvergenceRestore", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.ToggleAutoConvergenceRestore.dwValue = lValue;   // The hot key to dump stereo config info.
        }
        if (RegQueryValueEx(hKey, "RHWAtScreenLess", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.RHWAtScreenLess.dwValue = lValue;   // The hot key to dump stereo config info.
        }
        if (RegQueryValueEx(hKey, "RHWAtScreenMore", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.RHWAtScreenMore.dwValue = lValue;   // The hot key to dump stereo config info.
        }
        if (RegQueryValueEx(hKey, "RHWLessAtScreenLess", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.RHWLessAtScreenLess.dwValue = lValue;   // The hot key to dump stereo config info.
        }
        if (RegQueryValueEx(hKey, "RHWLessAtScreenMore", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.RHWLessAtScreenMore.dwValue = lValue;   // The hot key to dump stereo config info.
        }
        if (RegQueryValueEx(hKey, "CycleFrustumAdjust", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.FrustumAdjust.dwValue = lValue;  // The hot key to remove stereo config info.
        }
        if (RegQueryValueEx(hKey, "GammaAdjustMore", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.GammaAdjustMore.dwValue = lValue;  // The hot key to increase gamms.
        }
        if (RegQueryValueEx(hKey, "GammaAdjustLess", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.GammaAdjustLess.dwValue = lValue;  // The hot key to decrease gamms.
        }
#endif  //STEREO_CONFIG_ASSIST
#ifdef  SNAP_SHOT
        if (RegQueryValueEx(hKey, "SaveStereoImage", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            SaveStereoImage.dwValue = lValue;   // The hot key to save stereo image file
        }
        JPEGCompressQuality = 75;
        if (RegQueryValueEx(hKey, "SnapShotQuality", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            JPEGCompressQuality = lValue;   // Quality of JPEG compression. 0-100, 100 being the best.
        }
#endif  //SNAP_SHOT
        if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_SEPARATIONADJUST_MORE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoKeys.StereoSeparationAdjustMore.dwValue = lValue;   // The hot key to increase the horizontal separation.
        } else
        {
            //Should be eventually removed.
            if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_HORIZONTALADJUST_MORE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
            {
                pStereoData->StereoKeys.StereoSeparationAdjustMore.dwValue = lValue;   // The hot key to increase the horizontal separation.
            }
        }
        if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_SEPARATIONADJUST_LESS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoKeys.StereoSeparationAdjustLess.dwValue = lValue;   // The hot key to reduce the horizontal separation.
        } else
        {
            //Should be eventually removed.
            if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_HORIZONTALADJUST_LESS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
            {
                pStereoData->StereoKeys.StereoSeparationAdjustLess.dwValue = lValue;   // The hot key to reduce the horizontal separation.
            }
        }
        if (RegQueryValueEx(hKey, NV_REG_STEREO_ADJUSTENABLED, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            // Allow stereo adjustments by hot keys.
            if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_CONVERGENCEADJUST_MORE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
            {
                pStereoData->StereoKeys.StereoConvergenceAdjustMore.dwValue = lValue;   // The hot key to increase the convergence degree.
            }
            if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_CONVERGENCEADJUST_LESS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
            {
                pStereoData->StereoKeys.StereoConvergenceAdjustLess.dwValue = lValue;   // The hot key to reduce the convergence degree.
            }
        }

LSR_ExitWithClose:
        RegCloseKey(hKey);
    }
}

void DestroyStereo(void)
{
    NvSetStereoDataPtrFromDriverData;
#ifdef  STEREO_VIEWER_DRV
    if (pDriverData && STEREO_ENABLED && pStereoData->hStereoDrv)
#else   //STEREO_VIEWER_DRV==0
    if (pDriverData && STEREO_ENABLED)
#endif  //STEREO_VIEWER_DRV
    {
        if (pStereoData->pVertexRegister)
        {
            delete pStereoData->pVertexRegister;
            pStereoData->pVertexRegister = NULL;
        }
        if (pStereoData->pLockSubstituteLcl)
        {
            CNvObject *pNvObj = GET_PNVOBJ(pStereoData->pLockSubstituteLcl);
            nvAssert(pNvObj);
            pNvObj->release();
            FreeIPM(pStereoData->pLockSubstituteLcl);
            pStereoData->pLockSubstituteLcl = NULL;
        }
        if (global.dwDXRuntimeVersion >= 0x0700)
        {
            if (pStereoData->pLockTargetLcl)
            {
                FreeIPM(pStereoData->pLockTargetLcl);
            }
        }
        pStereoData->pLockTargetLcl = NULL;
        DWORD dwDummy;
        pStereoData->RmStereoParams.FlipOffsets[3][0] = 0xFFFFFFFF;
        NvRmConfigSet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                   NV_CFG_STEREO_CONFIG, 0, &dwDummy);
#ifdef  STEREO_VIEWER_DRV
        pStereoData->pStereoViewer->DestroyStereoViewer();
        FreeLibrary(pStereoData->hStereoDrv);
#endif  //STEREO_VIEWER_DRV
        FreeIPM(pStereoData);
        pStereoData = NULL;
        pDriverData->pStereoData = (DWORD)pStereoData;
    }

}

DWORD CalculateStereoParameters(void)
{
    LPDDHALMODEINFO lpModeInfo = &pDriverData->ModeList[pDXShare->dwModeNumber];
    DWORD dwStereoWidth = lpModeInfo->dwWidth;
    DWORD dwStereoHeight = lpModeInfo->dwHeight;
    DWORD dwStereoRefresh = (DWORD)lpModeInfo->wRefreshRate;
    float fHalfStereoSeparation = pStereoData->StereoSettings.fStereoSeparation * 0.5f;
    pStereoData->StereoSettings.fScreenStereoSeparation = fHalfStereoSeparation * dwStereoWidth;
    pStereoData->StereoSettings.fPostStereoConvergence = pStereoData->StereoSettings.fStereoConvergence;
    pStereoData->StereoSettings.fPostStereoXStretch = 1.f + pStereoData->StereoSettings.fStereoSeparation;
    pStereoData->StereoSettings.fPostStereoXShift   = dwStereoWidth * fHalfStereoSeparation;
    if (pDriverData->dwUseRefreshRate)
        dwStereoRefresh = pDriverData->dwUseRefreshRate;
    return 0;
}

LPD3DMATRIX SetStereoProjection(LPD3DMATRIX pMat, PNVD3DCONTEXT pContext)
{
    if (!STEREO_R_US(pContext))
        return pMat;

    float fDirection = 1.0f;
    ORIG_PROJECTION = *pMat; //Saved the original projection matrix.
    pStereoData->Eye[EYE_LEFT ].ProjMatrix =
    pStereoData->Eye[EYE_RIGHT].ProjMatrix = *pMat;
#if 0
    //Works for demolition raser but doesn't for watchmaker
    if (pStereoData->Eye[EYE_LEFT ].ProjMatrix._43 != 0.0f
     && pStereoData->Eye[EYE_LEFT ].ProjMatrix._44 != 1.0f)
#else
    if (pStereoData->Eye[EYE_LEFT ].ProjMatrix._43 != 0.0f)
#endif
    {
        if (pStereoData->Eye[EYE_LEFT ].ProjMatrix._33 < 0)
            fDirection = -1.0f;
        float fStereoSeparation = pStereoData->StereoSettings.fStereoSeparation * fDirection;
        if (pStereoData->StereoSettings.FrustumAdjustMode == FRUSTUM_STRETCH)
        {
            float fConvergenceBySeparation = pStereoData->StereoSettings.fStereoConvergence * pStereoData->StereoSettings.fStereoSeparation
                                             * fDirection;
            pStereoData->Eye[EYE_LEFT ].ProjMatrix._11 *= (1.f + pStereoData->StereoSettings.fStereoSeparation);
            pStereoData->Eye[EYE_RIGHT].ProjMatrix._11  = pStereoData->Eye[EYE_LEFT ].ProjMatrix._11;
            pStereoData->Eye[EYE_LEFT ].ProjMatrix._31 -= fStereoSeparation;
            pStereoData->Eye[EYE_LEFT ].ProjMatrix._41 += fConvergenceBySeparation;
            pStereoData->Eye[EYE_RIGHT].ProjMatrix._31 += fStereoSeparation;
            pStereoData->Eye[EYE_RIGHT].ProjMatrix._41 -= fConvergenceBySeparation;
        } else
        {
            float fConvergenceBySeparation = pStereoData->StereoSettings.fStereoConvergence * pStereoData->StereoSettings.fStereoSeparation
                                             * fDirection;
            pStereoData->Eye[EYE_LEFT ].ProjMatrix._31 -= fStereoSeparation;
            pStereoData->Eye[EYE_LEFT ].ProjMatrix._41 += fConvergenceBySeparation;
            pStereoData->Eye[EYE_RIGHT].ProjMatrix._31 += fStereoSeparation;
            pStereoData->Eye[EYE_RIGHT].ProjMatrix._41 -= fConvergenceBySeparation;
        }
    }
    pStereoData->StereoSettings.dwFlags |= STEREO_PROJECTIONMATRIXVALID;
    return &pStereoData->Eye[pStereoData->dwLastEye ].ProjMatrix;
}

void SetStereoProjectionInternal (PNVD3DCONTEXT pContext, LPD3DMATRIX pProjMatrix)
{
    nvMemCopy (&(pContext->xfmProj), pProjMatrix, sizeof(D3DMATRIX));
#if (NVARCH >= 0x020)
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM;
#endif
#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TRANSFORM;
#endif
}

#if (NVARCH >= 0x010)

void SetStereoRenderTargetInternalTNT (PNVD3DCONTEXT pContext, DWORD dwEye)
{
    DWORD dwRenderTargetOffset;
    DWORD dwZOffset = 0;

    if (!(pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN))) {

        if (dwEye == EYE_RIGHT)
        {
            dwRenderTargetOffset = pContext->pRenderTarget->getOffsetRight();
            if (pContext->pZetaBuffer)
                dwZOffset = pContext->pZetaBuffer->getOffsetRight();
        } else
        {
            dwRenderTargetOffset = pContext->pRenderTarget->getOffset();
            if (pContext->pZetaBuffer)
                dwZOffset = pContext->pZetaBuffer->getOffset();
        }

        nvglSetObject(NV_DD_SURFACES, D3D_CONTEXT_SURFACES_ARGB_ZS);
        nvglSetRenderTargetContexts(NV_DD_SURFACES,
                                    NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

        DWORD dwFormat = nv053SurfaceFormat[pContext->pRenderTarget->getFormat()];
        dwFormat |= DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH);

        if (!(pContext->surfaceViewport.clipHorizontal.wX) && !(pContext->surfaceViewport.clipVertical.wY)) {

            DWORD dwClip = (((DWORD)pContext->surfaceViewport.clipVertical.wHeight) << 16) |
                           (pContext->surfaceViewport.clipHorizontal.wWidth);
            DWORD dwZPitch  = pContext->pZetaBuffer ? pContext->pZetaBuffer->getPitch()  : 32;
            DWORD dwPitch   = (DRF_NUM(053, _SET_PITCH, _COLOR, pContext->pRenderTarget->getPitch())) |
                              (DRF_NUM(053, _SET_PITCH, _ZETA,  dwZPitch));
            nvglSetRenderTarget2(NV_DD_SURFACES,
                                 dwFormat,
                                 dwClip,
                                 dwPitch,
                                 dwRenderTargetOffset,
                                 dwZOffset);
        }
        else {
            DWORD dwClip = (((DWORD)pContext->surfaceViewport.clipVertical.wHeight) << 16) |
                           (pContext->surfaceViewport.clipHorizontal.wWidth);
            DWORD dwZPitch  = pContext->pZetaBuffer ? pContext->pZetaBuffer->getPitch()  : 32;
            DWORD dwPitch   = (DRF_NUM(053, _SET_PITCH, _COLOR, pContext->pRenderTarget->getPitch())) |
                              (DRF_NUM(053, _SET_PITCH, _ZETA,  dwZPitch));
            nvglSetRenderTarget2(NV_DD_SURFACES,
                                 dwFormat,
                                 dwClip,
                                 dwPitch,
                                 dwRenderTargetOffset,
                                 dwZOffset);

            // Set the image black rectangle to the clip region.
            nvglSetObject(NV_DD_SURFACES, NV_DD_IMAGE_BLACK_RECTANGLE);
            nvglSetClip(NV_DD_SURFACES,
                        pContext->surfaceViewport.clipHorizontal.wX, pContext->surfaceViewport.clipVertical.wY,
                        pContext->surfaceViewport.clipHorizontal.wWidth, pContext->surfaceViewport.clipVertical.wHeight);
        }

    }  // ! (CELSIUS | KELVIN)

    nvglSetObject(NV_DD_SURFACES, NV_DD_SURFACES_2D);
    pDriverData->TwoDRenderingOccurred = 0;
    pDriverData->ThreeDRenderingOccurred = TRUE;
    pDriverData->dDrawSpareSubchannelObject = 0; // force a reload.
    pDriverData->ddClipUpdate = TRUE;
    //NV_FORCE_TRI_SETUP(pContext);
    return;
}

#if (NVARCH >= 0x020)
void  SetStereoRenderTargetInternal(PNVD3DCONTEXT pContext, DWORD dwEye) 
{
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN)))   
        SetStereoRenderTargetInternalTNT (pContext,dwEye);                                              
    else                                                                                                    
        pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_SURFACE | KELVIN_DIRTY_SURFACE);
}
#else
void  SetStereoRenderTargetInternal(PNVD3DCONTEXT pContext, DWORD dwEye) 
{
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN)))   
        SetStereoRenderTargetInternalTNT (pContext,dwEye);                                              
    else                                                                                                    
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_SURFACE;
}
#endif

#else   //NVARCH < 0x010)

void SetStereoRenderTargetInternal (PNVD3DCONTEXT pContext, DWORD dwEye)
{
    DWORD dwRenderTargetOffset;
    DWORD dwZOffset = 0;

    if (!(pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN))) {

        if (dwEye == EYE_LEFT)
        {
            dwRenderTargetOffset = pContext->pRenderTarget->getOffset();
            if (pContext->pZetaBuffer)
                dwZOffset = pContext->pZetaBuffer->getOffset();
        } else
        {
            dwRenderTargetOffset = pContext->pRenderTarget->getOffsetRight();
            if (pContext->pZetaBuffer)
                dwZOffset = pContext->pZetaBuffer->getOffsetRight();
        }

        nvglSetObject(NV_DD_SURFACES, D3D_CONTEXT_SURFACES_ARGB_ZS);
        nvglSetRenderTargetContexts(NV_DD_SURFACES,
                                    NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

        DWORD dwFormat = nv053SurfaceFormat[pContext->pRenderTarget->getFormat()];
        dwFormat |= DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH);

        if (!(pContext->surfaceViewport.clipHorizontal.wX) && !(pContext->surfaceViewport.clipVertical.wY)) {

            DWORD dwClip = (((DWORD)pContext->surfaceViewport.clipVertical.wHeight) << 16) |
                           (pContext->surfaceViewport.clipHorizontal.wWidth);
            DWORD dwZPitch  = pContext->pZetaBuffer ? pContext->pZetaBuffer->getPitch()  : 32;
            DWORD dwPitch   = (DRF_NUM(053, _SET_PITCH, _COLOR, pContext->pRenderTarget->getPitch())) |
                              (DRF_NUM(053, _SET_PITCH, _ZETA,  dwZPitch));
            nvglSetRenderTarget2(NV_DD_SURFACES,
                                 dwFormat,
                                 dwClip,
                                 dwPitch,
                                 dwRenderTargetOffset,
                                 dwZOffset);
        }
        else {
            DWORD dwClip = (((DWORD)pContext->surfaceViewport.clipVertical.wHeight) << 16) |
                           (pContext->surfaceViewport.clipHorizontal.wWidth);
            DWORD dwZPitch  = pContext->pZetaBuffer ? pContext->pZetaBuffer->getPitch()  : 32;
            DWORD dwPitch   = (DRF_NUM(053, _SET_PITCH, _COLOR, pContext->pRenderTarget->getPitch())) |
                              (DRF_NUM(053, _SET_PITCH, _ZETA,  dwZPitch));
            nvglSetRenderTarget2(NV_DD_SURFACES,
                                 dwFormat,
                                 dwClip,
                                 dwPitch,
                                 dwRenderTargetOffset,
                                 dwZOffset);

            // Set the image black rectangle to the clip region.
            nvglSetObject(NV_DD_SURFACES, NV_DD_IMAGE_BLACK_RECTANGLE);
            nvglSetClip(NV_DD_SURFACES,
                        pContext->surfaceViewport.clipHorizontal.wX, pContext->surfaceViewport.clipVertical.wY,
                        pContext->surfaceViewport.clipHorizontal.wWidth, pContext->surfaceViewport.clipVertical.wHeight);
        }

    }  // ! (CELSIUS | KELVIN)

    nvglSetObject(NV_DD_SURFACES, NV_DD_SURFACES_2D);
    pDriverData->TwoDRenderingOccurred = 0;
    pDriverData->ThreeDRenderingOccurred = TRUE;
    pDriverData->dDrawSpareSubchannelObject = 0; // force a reload.
    pDriverData->ddClipUpdate = TRUE;
    //NV_FORCE_TRI_SETUP(pContext);
    return;
}

#endif  //NVARCH >= 0x010)

void AdjustStereoParameters(PNVD3DCONTEXT pContext)
{
    pStereoData->dwLastEye = EYE_NONE;
    CalculateStereoParameters();
    if (pStereoData->StereoSettings.dwFlags & STEREO_PROJECTIONMATRIXVALID)
        SetStereoProjection(&ORIG_PROJECTION, pContext);
}

void SetupStereoContext(PNVD3DCONTEXT pContext)
{
#ifdef  LEFT_ALWAYS_FIRST
    pStereoData->dwLastEye = EYE_NONE;
#else   //LEFT_ALWAYS_FIRST
#ifdef  NULL_RIGHT_EYE
    pStereoData->dwLastEye = EYE_NONE;
#endif  //NULL_RIGHT_EYE
#endif  //LEFT_ALWAYS_FIRST
    if (pStereoData->dwLastEye == EYE_NONE)
    {
        //Has not been set yet
        SetStereoRenderTargetInternal (pContext, EYE_LEFT);
        if (pStereoData->StereoSettings.dwFlags & STEREO_PROJECTIONMATRIXVALID)
            SetStereoProjectionInternal (pContext, &pStereoData->Eye[EYE_LEFT ].ProjMatrix);
        pStereoData->dwLastEye = EYE_LEFT;
    }
}

void AlternateStereoContext(PNVD3DCONTEXT pContext)
{
    if (pStereoData->dwLastEye == EYE_LEFT)
    {
        SetStereoRenderTargetInternal (pContext, EYE_RIGHT);
        if (pStereoData->StereoSettings.dwFlags & STEREO_PROJECTIONMATRIXVALID)
            SetStereoProjectionInternal (pContext, &pStereoData->Eye[EYE_RIGHT ].ProjMatrix);
        pStereoData->dwLastEye = EYE_RIGHT;
    } else
    {
        SetStereoRenderTargetInternal (pContext, EYE_LEFT);
        if (pStereoData->StereoSettings.dwFlags & STEREO_PROJECTIONMATRIXVALID)
            SetStereoProjectionInternal (pContext, &pStereoData->Eye[EYE_LEFT ].ProjMatrix);
        pStereoData->dwLastEye = EYE_LEFT;
    }
}

void CaptureDP2Entries(PNVD3DCONTEXT pContext, nvDP2FunctionTable *pDP2functionTable)
{
    DWORD i;

    // Sanity check against infinite loop
    nvAssert ((*pContext->pDP2FunctionTable)[D3DDP2OP_CLEAR] != (*pDP2functionTable)[D3DDP2OP_CLEAR]);

    for (i = 0; i <= D3D_DP2OP_MAX; i++)
    {
        if ((*pDP2functionTable)[i])
        {
            //We can handle it
            nvDP2SetFuncs_Orig[i] = (*pContext->pDP2FunctionTable)[i];     //Saved the original entry.
            (*pContext->pDP2FunctionTable)[i] = (*pDP2functionTable)[i];   //Put ours.
        }
    }
}

void RestoreDP2Entries(PNVD3DCONTEXT pContext, nvDP2FunctionTable *pDP2FunctionTable)
{
    DWORD i;

    for (i = 0; i <= D3D_DP2OP_MAX; i++)
    {
        if (nvDP2SetFuncs_Orig[i])
        {
            //We saved it before
            (*pContext->pDP2FunctionTable)[i] = nvDP2SetFuncs_Orig[i];     //Restored the original entry.
            nvDP2SetFuncs_Orig[i] = NULL;
        }
    }
}

#include <math.h>

int ComputeGammaColor (int i, float fGamma)
{
   float   fBase, fVal, fI;
   int     iVal;

   fI = (float)i;

// Compute gamma

   fBase = fI / 255.0f; 
   fVal = (float)pow(fBase, 1.0f / fGamma);
   iVal = (int)(255.0f * fVal);

#if 0
// *********************************************
// Compensate for brightness
   
   iVal += (int)fBrightness;

   if (iVal > 255) 
     iVal = 255;

   if (iVal < 0) 
     iVal = 0;

// ***********************************************
#endif
   return iVal;
}

DWORD ActivateStereo(PNVD3DCONTEXT pContext)
{
    if (pStereoData->StereoSettings.dwFlags & STEREO_DISALLOWED)
        return 1;

#ifdef  STEREO_VIEWER_DRV
    switch (pStereoData->StereoViewerCaps.dwActivationMethod)
    {
    case SAM_VRAMPATTERN:
        pStereoData->pStereoViewer->ActivateStereo(&pDriverData->ModeList[pDXShare->dwModeNumber],
                                                    NULL,
                                                    0);
        CaptureDP2Entries(pContext, &nvDP2SetFuncs_Stereo_Flip);
        if (pStereoData->StereoSettings.dwFlags & STEREO_PROJECTIONMATRIXVALID)
            SetStereoProjectionInternal (pContext, &pStereoData->Eye[EYE_LEFT ].ProjMatrix);
        pStereoData->dwLastEye = EYE_LEFT;
        if (!pStereoData->pVertexRegister)
        {
            CVertexRegister *pVertexRegister  = new CVertexRegister(pStereoData->dwVertexRegisterSize);
            pStereoData->pVertexRegister = pVertexRegister;
        }
        break;

    default:
        nvAssert (0 == 1);
    }
#else   //STEREO_VIEWER_DRV==0
    CaptureDP2Entries(pContext, &nvDP2SetFuncs_Stereo_Flip);
    if (pStereoData->StereoSettings.dwFlags & STEREO_PROJECTIONMATRIXVALID)
        SetStereoProjectionInternal (pContext, &pStereoData->Eye[EYE_LEFT ].ProjMatrix);
    pStereoData->dwLastEye = EYE_LEFT;
    if (!pStereoData->pVertexRegister)
    {
        CVertexRegister *pVertexRegister  = new CVertexRegister(pStereoData->dwVertexRegisterSize);
        pStereoData->pVertexRegister = pVertexRegister;
    }
#endif  //STEREO_VIEWER_DRV
    if (pStereoData->StereoSettings.dwFlags & STEREO_RIGHTEYEINIT)
    {
        //Right eye has not been rendered yet. Make sure that its initial
        //image is at least the same as the left eye.
        //Make sure the accelerator is free.
        WaitForIdle (TRUE,FALSE);

        StereoRightEyeInit();
        pStereoData->StereoSettings.dwFlags &= ~STEREO_RIGHTEYEINIT;
    }
#if 0
    DWORD dwDummy;
    NvRmConfigSet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
               NV_CFG_STEREO_CONFIG, (DWORD)&pStereoData->RmStereoParams, &dwDummy);
    //The following setting will force resman to start with the left eye at VBLANK. This is very
    //important for GPIO type of connection because first time we send the triggering bit the
    //glasses block the right eye.
    pStereoData->RmStereoParams.EyeDisplayed = 0;
#ifdef  STEREO_VIEWER_DRV
    pStereoData->RmStereoParams.Flags |= (STEREOCFG_STEREOACTIVATED | STEREOCFG_ELSADDC);
#else   //STEREO_VIEWER_DRV==0
    pStereoData->RmStereoParams.Flags |= (STEREOCFG_STEREOACTIVATED | pStereoData->dwStereoHWType);
#endif  //STEREO_VIEWER_DRV
#else
    DWORD dwDummy;
    //The following setting will force resman to start with the left eye at VBLANK. This is very
    //important for GPIO type of connection because first time we send the triggering bit the
    //glasses block the right eye.
    pStereoData->RmStereoParams.EyeDisplayed = 0;
    pStereoData->RmStereoParams.Flags |= (STEREOCFG_STEREO_INITIALIZE | pStereoData->dwStereoHWType);
    NvRmConfigSet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
               NV_CFG_STEREO_CONFIG, (DWORD)&pStereoData->RmStereoParams, &dwDummy);
#endif
    pStereoData->bStereoActivated = TRUE;

    if (STEREODATA(StereoSettings.dwFlags) & STEREO_GAMMACORRECTION)
	{
		//Gamma adjustment for stereo.
		WORD    NewGamma[256 * 3];
		DWORD   i;
		HDC hDC = GetDC(NULL);
		if (hDC)
		{
			if (GetDeviceGammaRamp(hDC, pStereoData->SaveCurrentGamma))
			{
				WORD  NewVal;
				for (i = 0; i < 256; i++)
				{

					NewVal = (WORD)(ComputeGammaColor (i, pStereoData->StereoSettings.fStereoGamma) << 8); 
					NewGamma[i] = NewVal;
					NewGamma[i+256] = NewVal;
					NewGamma[i+512] = NewVal;
				}
				SetDeviceGammaRamp(hDC, NewGamma); 
			}
			ReleaseDC(NULL,hDC);
		}
    }

	/////////// create a list of PopupAgents
#ifdef USE_POPUP_LIST
	if(popupAgents.enabled()) //in registry
    {
        popupAgents.create();
    }
#endif //USE_POPUP_LIST

    return 0;
}

DWORD DeactivateStereo(PNVD3DCONTEXT pContext)
{
#ifdef  STEREO_VIEWER_DRV
    switch (pStereoData->StereoViewerCaps.dwActivationMethod)
    {
    case SAM_VRAMPATTERN:
        RestoreDP2Entries(pContext, &nvDP2SetFuncs_Stereo_Flip);
        SetStereoRenderTargetInternal (pContext, EYE_LEFT);
        if (pStereoData->StereoSettings.dwFlags & STEREO_PROJECTIONMATRIXVALID)
            SetStereoProjectionInternal (pContext, &ORIG_PROJECTION);
        pStereoData->pStereoViewer->DeactivateStereo(&pDriverData->ModeList[pDXShare->dwModeNumber],
                                                    NULL,
                                                    0);
        pStereoData->dwLastEye = EYE_NONE;
        if (pStereoData->pVertexRegister)
        {
            delete pStereoData->pVertexRegister;
            pStereoData->pVertexRegister = NULL;
        }
        break;

    default:
        nvAssert (0 == 1);
    }
#else   //STEREO_VIEWER_DRV==0
    RestoreDP2Entries(pContext, &nvDP2SetFuncs_Stereo_Flip);
    SetStereoRenderTargetInternal (pContext, EYE_LEFT);
    if (pStereoData->StereoSettings.dwFlags & STEREO_PROJECTIONMATRIXVALID)
        SetStereoProjectionInternal (pContext, &ORIG_PROJECTION);
    pStereoData->dwLastEye = EYE_NONE;
    if (pStereoData->pVertexRegister)
    {
        delete pStereoData->pVertexRegister;
        pStereoData->pVertexRegister = NULL;
    }
#endif  //STEREO_VIEWER_DRV
    DWORD dwDummy;
#if 0
    pStereoData->RmStereoParams.Flags &= ~STEREOCFG_STEREOACTIVATED;
#else
    pStereoData->RmStereoParams.Flags |= STEREOCFG_STEREO_DISABLE;
#endif
    NvRmConfigSet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
           NV_CFG_STEREO_CONFIG, (DWORD)&pStereoData->RmStereoParams, &dwDummy);
    pStereoData->bStereoActivated = 0;
    
    if (STEREODATA(StereoSettings.dwFlags) & STEREO_GAMMACORRECTION)
	{
		//Gamma adjustment for stereo.
		HDC hDC = GetDC(NULL);
		if (hDC)
		{
			//Restore original gamma.
			SetDeviceGammaRamp(hDC, pStereoData->SaveCurrentGamma); 
			ReleaseDC(NULL,hDC);
		}
    }

	/////////// destroy a list of PopupAgent 
#ifdef USE_POPUP_LIST
	//we're always destroying it, it's safe	
	//destroyPopupList();
	popupAgents.destroy();
#endif //USE_POPUP_LIST

	return 0;
}

void GenerateBasicRegEntries(char *StereoKey)
{
    HKEY    hConfigKey, hKeyApp;
    char    *pCommandLine;

    if (RegOpenKeyEx(NV4_REG_GLOBAL_BASE_KEY, StereoKey, 0, KEY_QUERY_VALUE, &hConfigKey) != ERROR_SUCCESS)
    {
        //Can't really happen
        LOG("GenerateBasicRegEntries: can't open key %s", StereoKey);
		nvAssert(0);
        return;
    }
    if (RegCreateKeyEx(hConfigKey, pStereoData->bAppRealName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeyApp, NULL) != ERROR_SUCCESS)
    {
        LOG("GenerateBasicRegEntries: can't create key %s", pStereoData->bAppRealName);
        nvAssert(0);
        return;
    }
    RegSetValueEx(hKeyApp, "RunTimeName", NULL, REG_SZ, (LPBYTE)pStereoData->bAppName, sizeof (pStereoData->bAppName));
    pCommandLine = GetCommandLine();
    RegSetValueEx(hKeyApp, "CommandLine", NULL, REG_SZ, (LPBYTE)pCommandLine, nvStrLen(pCommandLine));
    RegCloseKey(hConfigKey);
    RegCloseKey(hKeyApp);
}

BOOL CheckAndMapSymbolicLink(HKEY hKey)
{
    char    LinkBuf[32];
    char    StereoKey[256];
    DWORD   dwNameSize;
    DWORD   dwNameType;
    BOOL    isSymbolicLink = FALSE;

    nvStrCpy(StereoKey, NV4_REG_GLOBAL_BASE_PATH);
    nvStrCat(StereoKey, "\\");
    nvStrCat(StereoKey, NV4_REG_STEREO_SUBKEY);
    nvStrCat(StereoKey, "\\GameConfigs\\");

    for (DWORD i = 1; ; i++)
    {
        nvSprintf (LinkBuf,"Link%0d", i);
        //Look for the stereo viewer driver first.
        dwNameSize = sizeof(pStereoData->bAppRealName);
        dwNameType = REG_SZ;
        if (RegQueryValueEx(hKey, LinkBuf, NULL, &dwNameType, (LPBYTE)pStereoData->bAppRealName, &dwNameSize) != ERROR_SUCCESS)
        {
            if (isSymbolicLink)
            {
                //The application has the same name as an existing symbolic link but can not be recognized among
                //existing links. We assume that this is new candidate to be linked now. We will create some
                //fake link name "_NewFakeLink" that is to be resolved manually later.
                nvStrCpy(pStereoData->bAppRealName, "_NewFakeLink");
                GenerateBasicRegEntries(StereoKey);
                RegSetValueEx(hKey, LinkBuf, NULL, REG_SZ, (LPBYTE)pStereoData->bAppRealName, sizeof (pStereoData->bAppRealName));
            }
            return isSymbolicLink;
        }
        isSymbolicLink = TRUE;
        //Found some link. Let's see if it is ours.
        if (GetFileAttributes(pStereoData->bAppRealName) != -1)
        {
            //It is ours. We just need to remove the extension part if any.
            char *pExt = nvStrChr(pStereoData->bAppRealName, '.');
            if (pExt)
                pExt[0] = 0;
            GenerateBasicRegEntries(StereoKey);
            return TRUE;
        }
    }
    //Should never get here.
    LOG("CheckAndMapSymbolicLink: Should never get here");
    nvAssert(0);
    return FALSE;
}

void ResetStereoParameters(void)
{
#ifdef  STEREO_CONFIG_ASSIST
    ConfigAssistInfo.rhwMin     = 9999.f;
    ConfigAssistInfo.rhwMin2D   = 9999.f;
    ConfigAssistInfo.rhwMax     = -9999.f;
    ConfigAssistInfo.rhwMax2D   = -9999.f;
    ConfigAssistInfo.szMin      = 9999.f;
    ConfigAssistInfo.szMin2D    = 9999.f;
    ConfigAssistInfo.szMax      = -9999.f;
    ConfigAssistInfo.szMax2D    = -9999.f;
    StereoSettingsStack.Valid   = FALSE;
#endif  //STEREO_CONFIG_ASSIST

    HKEY hKey;
    char StereoKey[256];
    BOOL bFirstTime = TRUE;

    nvStrCpy(StereoKey, NV4_REG_GLOBAL_BASE_PATH);
    nvStrCat(StereoKey, "\\");
    nvStrCat(StereoKey, NV4_REG_STEREO_SUBKEY);
    if (pStereoData->bAppName)
    {
        nvStrCat(StereoKey, "\\GameConfigs\\");
        nvStrCat(StereoKey, pStereoData->bAppName);
    }

    //First of all restore all game specific defaults
    //pStereoData->StereoSettings.dwFlags &= ~(STEREO_CUSTOMSETTINGSMASK | STEREO_DEFAULTON | STEREO_LASERSIGHT);
    pStereoData->StereoSettings.dwFlags &= ~(STEREO_CUSTOMSETTINGSMASK |STEREO_LASERSIGHT);
    pStereoData->StereoSettings.fStereoConvergence = DEFAULT_STEREO_CONVERGENCE;
    pStereoData->StereoSettings.fConvergenceMultiplier = DEFAULT_STEREO_CONVERGENCE_MULTIPLIER;
    pStereoData->fRHW2DDetectionMin = -9999.f;
    nvStrCpy(pStereoData->bAppRealName, pStereoData->bAppName);
SecondPass:
    if (RegOpenKeyEx(NV4_REG_GLOBAL_BASE_KEY, StereoKey, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS) {
        DWORD   dwSize = sizeof(long);
        DWORD   dwType = REG_DWORD;
        long    lValue;

        if (bFirstTime && CheckAndMapSymbolicLink(hKey))
        {
            //The application name has been mapped to a new one. We need to a second pass.
            RegCloseKey(hKey);
            nvStrCpy(StereoKey, NV4_REG_GLOBAL_BASE_PATH);
            nvStrCat(StereoKey, "\\");
            nvStrCat(StereoKey, NV4_REG_STEREO_SUBKEY);
            nvStrCat(StereoKey, "\\GameConfigs\\");
            nvStrCat(StereoKey, pStereoData->bAppRealName);
            bFirstTime = FALSE;
            goto SecondPass;
        }

        if (RegQueryValueEx(hKey, "AllowNonExclusiveStereo", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (lValue)
                pStereoData->StereoSettings.dwFlags &= ~STEREO_DISALLOWED_NOT_FULL_SCREEN;
        }

        if (RegQueryValueEx(hKey, NV_REG_STEREO_CONVERGENCE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoSettings.fStereoConvergence = *(float *)&lValue;
            if (pStereoData->StereoSettings.fStereoConvergence == 0)
            {
                //Make it whatever but not 0. Exponential doesnt work on 0
                pStereoData->StereoSettings.fStereoConvergence = CONVERGENCE_THRESHOLD;
            }
            pStereoData->StereoSettings.dwFlags |= STEREO_CONVERGENCE;
        }

#ifdef  LASER_SIGHT
        if (pStereoData->StereoSettings.dwFlags & STEREO_LASERSIGHTENABLED)
        {
            pStereoData->StereoSettings.fLaserXAdjust = 1.0f;
            pStereoData->StereoSettings.fLaserYAdjust = 1.0f;
            if (RegQueryValueEx(hKey, NV_REG_STEREO_LASERSIGHT, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
            {
                if (lValue)
                {
                    pStereoData->StereoSettings.dwFlags |= STEREO_LASERSIGHT;
                    CreateLaserTextureContent();
                    //Turn this off. Otherwise it will mess up the Z buffer content.
                    pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~(PS_CONTROL_TRAFFIC_16|PS_CONTROL_TRAFFIC_32);
                    if (RegQueryValueEx(hKey, NV_REG_STEREO_LASERXADJUST, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
                    {
                        pStereoData->StereoSettings.fLaserXAdjust = *(float *)&lValue;
                    }
                    if (RegQueryValueEx(hKey, NV_REG_STEREO_LASERYADJUST, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
                    {
                        pStereoData->StereoSettings.fLaserYAdjust = *(float *)&lValue;
                    }
                }
            }
        }
#endif  //LASER_SIGHT

        if (RegQueryValueEx(hKey, NV_REG_STEREO_CONVERGENCEMULTIPLIER, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoSettings.fConvergenceMultiplier = *(float *)&lValue;
            pStereoData->StereoSettings.dwFlags |= STEREO_CONVERGENCEMULTIPLIER;
        }

        pStereoData->StereoSettings.FrustumAdjustMode = NO_FRUSTUM_ADJUST;
        if (RegQueryValueEx(hKey, NV_REG_STEREO_FRUSTUMADJUSTMODE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoSettings.FrustumAdjustMode = lValue;
        }

        pStereoData->StereoSettings.PartialClearMode = DO_AS_REQUESTED;
        if (RegQueryValueEx(hKey, NV_REG_STEREO_PARTIALCLEARMODE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoSettings.PartialClearMode = lValue;
        }

        if (RegQueryValueEx(hKey, NV_REG_STEREO_AUTOCONVERGENCE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (lValue)
            {
                pStereoData->StereoSettings.dwFlags |= STEREO_AUTOCONVERGENCE;
                if (RegQueryValueEx(hKey, NV_REG_STEREO_CONVERGENCEADJUSTPACE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
                {
                    pStereoData->StereoSettings.AutoConvergenceAdjustPace = *(float *)&lValue;
                }
            }
        }

        if (RegQueryValueEx(hKey, NV_REG_STEREO_RHWGREATERATSCREEN, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoSettings.dwFlags |= STEREO_RHWGREATERATSCREEN;
            pStereoData->StereoSettings.fRHWGreaterAtScreen = *(float *)&lValue;
        }

        if (RegQueryValueEx(hKey, NV_REG_STEREO_RHWEQUALATSCREEN, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (lValue)
                pStereoData->StereoSettings.dwFlags |= STEREO_RHWEQUALATSCREEN;
        }

        if (RegQueryValueEx(hKey, NV_REG_STEREO_FAVORSZ, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (lValue)
                pStereoData->StereoSettings.dwFlags |= STEREO_FAVORSZOVERRHW;
        }

        if (RegQueryValueEx(hKey, NV_REG_STEREO_RHWLESSATSCREEN, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoSettings.dwFlags |= STEREO_RHWLESSATSCREEN;
            pStereoData->StereoSettings.fRHWLessAtScreen = *(float *)&lValue;
        }

        pStereoData->fRHW2DDetectionMin = -9999.f;
        if (RegQueryValueEx(hKey, NV_REG_STEREO_RHW2DDETECTIONMIN, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
            pStereoData->fRHW2DDetectionMin = *(float *)&lValue;

        if (RegQueryValueEx(hKey, NV_REG_STEREO_MAXVERTEXCOUNT, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
            pStereoData->dwVertexRegisterSize = lValue;

        if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_TOGGLE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoKeys.StereoToggle.dwValue = lValue;   // The hot key to toggle stereo.
        }

        if (RegQueryValueEx(hKey, NV_REG_STEREO_DEFAULTON, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (lValue)
                pStereoData->StereoSettings.dwFlags |= STEREO_DEFAULTON;
        }

        if (RegQueryValueEx(hKey, NV_REG_STEREO_ADJUSTENABLED, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            // Allow stereo adjustments by hot keys.
            if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_SEPARATIONADJUST_MORE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
            {
                pStereoData->StereoKeys.StereoSeparationAdjustMore.dwValue = lValue;   // The hot key to increase the horizontal separation.
            } else
            {
                //Should be eventually removed.
                if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_HORIZONTALADJUST_MORE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
                {
                    pStereoData->StereoKeys.StereoSeparationAdjustMore.dwValue = lValue;   // The hot key to increase the horizontal separation.
                }
            }
            if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_SEPARATIONADJUST_LESS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
            {
                pStereoData->StereoKeys.StereoSeparationAdjustLess.dwValue = lValue;   // The hot key to reduce the horizontal separation.
            } else
            {
                //Should be eventually removed.
                if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_HORIZONTALADJUST_LESS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
                {
                    pStereoData->StereoKeys.StereoSeparationAdjustLess.dwValue = lValue;   // The hot key to reduce the horizontal separation.
                }
            }
            if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_CONVERGENCEADJUST_MORE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
            {
                pStereoData->StereoKeys.StereoConvergenceAdjustMore.dwValue = lValue;   // The hot key to increase the convergence degree.
            }
            if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_CONVERGENCEADJUST_LESS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
            {
                pStereoData->StereoKeys.StereoConvergenceAdjustLess.dwValue = lValue;   // The hot key to reduce the convergence degree.
            }
        }
        RegCloseKey(hKey);
    }

    pStereoData->dwLastEye        = EYE_NONE;
    pStereoData->fFrameRHWMax     = -9999.f;
    CalculateStereoParameters();
}

void StereoContextCreate(void)
{
    char FirstContextOwner[128];
    
    if (!STEREO_ENABLED)
        return;

    FirstContextOwner[0] = 0;
    if (pStereoData->dwContext)
    {
        //We don't allow more than 1 application at a time in stereo mode but we allow more than
        //one context in applications.
        nvStrCpy(FirstContextOwner, pStereoData->bAppRealName);
    }

    char AppFullName[1024];
    //Let's see if we need to override the stereo settings for this particular application.
    char *pAppFullName, *pAppName;
    nvStrCpy(AppFullName, GetCommandLine());
    pAppFullName = AppFullName;
    if (pAppFullName[0] == '"')
    {
        pAppFullName++;
        pAppName = nvStrChr(pAppFullName, '"');
        pAppName[0] = 0;
    } else
    {
        if (pAppName = nvStrChr(pAppFullName, ' '))
            pAppName[0] = 0;
    }
    if (pAppName = nvStrRChr(pAppFullName, '\\'))
        pAppName++;
    else
        pAppName = pAppFullName;
    if (pAppFullName = nvStrChr(pAppName, '.'))
        *pAppFullName = 0;
    //The last sanity check
    if (pAppName[0] == 0)
    {
        //Eliminated everything
        pAppName = "NoName";
    }
    nvStrCpy(pStereoData->bAppName, pAppName);
    if (!(pStereoData->dwVertexRegisterSize = getDC()->nvD3DDevCaps.dd1Caps.dwMaxVertexCount))
		pStereoData->dwVertexRegisterSize = (32 * 2048) / sizeof(D3DTLVERTEX);
    ResetStereoParameters();
    if (FirstContextOwner[0])
    {
        //It might be another context in the same application
        if (!nvStrCmp(FirstContextOwner, pStereoData->bAppRealName))
        {
            //The same application, another context
            pStereoData->dwContext = getDC()->dwContextListHead;
        } else
        {
            nvAssert(0);
		    LOG("StereoContextCreate: more than 1 application in stereo is not allowed");
        }        
        return;
    }
    pStereoData->bStereoActivated = FALSE;

#ifdef  LASER_SIGHT
    if (pStereoData->StereoSettings.dwFlags & STEREO_LASERSIGHT)
    {
        nvAssert (pLaser_Texture == NULL);

        pLaser_Texture = new CTexture;
        if (pLaser_Texture)
        {
            pLaser_Obj = new CNvObject(0);
            if (pLaser_Obj)
            {
                BOOL bRes = pLaser_Texture->create (pLaser_Obj, LASER_WIDTH, LASER_HEIGHT, 1, 4, 4, 1, NV_SURFACE_FORMAT_A8R8G8B8,
                                                  CSimpleSurface::HEAP_VID, CSimpleSurface::HEAP_VID);

                if (bRes)
                {
                    if (pStereoData->StereoSettings.dwFlags & STEREO_LASERSIGHT)
                        CreateLaserTextureContent();
                    pLaser_Obj->setObject(CNvObject::NVOBJ_TEXTURE, pLaser_Texture);
                }
                else
                {
                    // allocation failed
                    DPF("Couldn't allocate video memory for logo\n");
                    pLaser_Obj->release();
                    delete pLaser_Texture;
                    pLaser_Obj     = NULL;
                    pLaser_Texture = NULL;
                }
            } else
            {
                delete pLaser_Texture;
                pLaser_Texture = NULL;
                DPF("Unable to create laser object");
            }
        } else
            DPF("Unable to create laser texture");
    }
#endif  //LASER_SIGHT

#ifndef  DELAYED_HOTKEY_INIT
    if (!(pStereoData->StereoKeys.pHotKeyI = new CHOTKEYINTERFACE))
    {
        //Hot key support creation failed. We won't do anything special at this point like releasing the
        //StereoViewer. So all that previously done stuff will be standing by untill the driver gets unloaded.
        //It shouldn't cause any troubles because a game won't be able to activate stereo anyway. It would be
        //nice to somehow report the situation by putting message on the screen or generating some LogError
        //file. We'll figure it out later.
		LOG("StereoContextCreate: can't create hot key interface");
        return;
    }

    CREATESTEREOHOTKEY(pStereoData->StereoKeys.StereoToggle);
    CREATESTEREOHOTKEY(pStereoData->StereoKeys.StereoSeparationAdjustMore);
    CREATESTEREOHOTKEY(pStereoData->StereoKeys.StereoSeparationAdjustLess);
    CREATESTEREOHOTKEY(pStereoData->StereoKeys.StereoConvergenceAdjustMore);
    CREATESTEREOHOTKEY(pStereoData->StereoKeys.StereoConvergenceAdjustLess);
#ifdef  STEREO_CONFIG_ASSIST
    CREATESTEREOHOTKEY(ConfigAssistInfo.SuggestKey);
    CREATESTEREOHOTKEY(ConfigAssistInfo.UnsuggestKey);
    CREATESTEREOHOTKEY(ConfigAssistInfo.WriteKey);
    CREATESTEREOHOTKEY(ConfigAssistInfo.DeleteKey);
    CREATESTEREOHOTKEY(ConfigAssistInfo.FrustumAdjust);
    CREATESTEREOHOTKEY(ConfigAssistInfo.ToggleAutoConvergence);
    CREATESTEREOHOTKEY(ConfigAssistInfo.ToggleAutoConvergenceRestore);
    CREATESTEREOHOTKEY(ConfigAssistInfo.RHWAtScreenMore);
    CREATESTEREOHOTKEY(ConfigAssistInfo.RHWAtScreenLess);
    CREATESTEREOHOTKEY(ConfigAssistInfo.RHWLessAtScreenMore);
    CREATESTEREOHOTKEY(ConfigAssistInfo.RHWLessAtScreenLess);
    if (STEREODATA(StereoSettings.dwFlags) & STEREO_GAMMACORRECTION)
	{
		CREATESTEREOHOTKEY(ConfigAssistInfo.GammaAdjustMore);
		CREATESTEREOHOTKEY(ConfigAssistInfo.GammaAdjustLess);
	}
#ifdef  LASER_SIGHT
    CREATESTEREOHOTKEY(ConfigAssistInfo.LaserXPlusKey);
    CREATESTEREOHOTKEY(ConfigAssistInfo.LaserXMinusKey);
    CREATESTEREOHOTKEY(ConfigAssistInfo.LaserYPlusKey);
    CREATESTEREOHOTKEY(ConfigAssistInfo.LaserYMinusKey);
#endif  //LASER_SIGHT

#ifdef  USE_POPUP_LIST
    popupAgents.initHotKeys();
#endif  //USE_POPUP_LIST


#endif  //STEREO_CONFIG_ASSIST
#ifdef  SNAP_SHOT
    CREATESTEREOHOTKEY(SaveStereoImage);
#endif  //SNAP_SHOT
    nFlips = 0;
#else   //DELAYED_HOTKEY_INIT
    FirstHotKeyInit = 1;
#endif  //DELAYED_HOTKEY_INIT

    pStereoData->dwContext = getDC()->dwContextListHead;
  //LOG("StereoContextCreate: context created");

#if 0
    switch (pStereoData->dwStereoFormat)
    {
    case SVF_OVERANDUNDER:
        CalculateStereoParameters();
        break;

    case SVF_FRAMESEQUENTIAL:
        CalculateStereoParameters();
        break;

    case SVF_NONE:
        nvAssert (0 == 1);
        break;

    default:
        nvAssert (0 == 1);
        break;
    }
#endif
    if (pStereoData->StereoSettings.dwFlags & STEREO_FORCEDOFF)
    {
        //if (pStereoData->StereoModeNumber == pDXShare->dwModeNumber)
        {
            pStereoData->StereoSettings.dwFlags &= ~STEREO_FORCEDOFF;
            ActivateStereo((PNVD3DCONTEXT)pStereoData->dwContext);
        }
    } else
    {
        pStereoData->StereoSettings.dwFlags |= STEREO_RIGHTEYEINIT;
        if (pStereoData->StereoSettings.dwFlags & STEREO_DEFAULTON)
        {
            pStereoData->StereoModeNumber = pDXShare->dwModeNumber;
            pStereoData->StereoSettings.dwFlags &= ~STEREO_DEFAULTON;
            ActivateStereo((PNVD3DCONTEXT)pStereoData->dwContext);
        }
    }
}

#ifdef  MEMORY_TEST

#define MEM_SIZE 8192
#define __PUSH  __asm push eax __asm push edx __asm push ebx
#define __POP   __asm pop ebx __asm pop edx __asm pop eax
#define __SYNC  __asm xchg al,al __asm nop __asm nop
#define __RDTSC __SYNC __asm _emit 0x0f __asm _emit 0x31

#define _START(_t) { _Time[_t]=0; _RESTART(_t); }
#define _RESTART(_t) { __PUSH __asm mov eax,(_t) __asm lea ebx,[_Time+eax*8] __RDTSC __asm sub [ebx],eax __asm sbb [ebx+4],edx __POP }
#define _STOP(_t)  { __PUSH __asm mov eax,(_t) __asm lea ebx,[_Time+eax*8] __RDTSC __asm add [ebx],eax __asm adc [ebx+4],edx __POP }
__int64 _Time[256];

BOOL    PerformTest;
DWORD   NIterations = 1000000;
DWORD   MemSize = 32;

void ReadMemory(LPDWORD pAddr, DWORD TimeIndex)
{
    DWORD i = NIterations;
    DWORD dwNLoops = MemSize / sizeof(DWORD);
    nvAssert((((DWORD)pAddr) & 3) == 0);
    nvAssert(dwNLoops != 0);
    _START(TimeIndex);
    do
    {
        __asm {
            mov ecx, dwNLoops
            mov eax, pAddr
NextRead:
            mov edx, [eax+ecx*4-4]
            loop NextRead
        }
    } while (--i);
    _STOP(TimeIndex);
    _Time[TimeIndex] /= NIterations;
}

void WriteMemory(LPDWORD pAddr, DWORD TimeIndex)
{
    DWORD i = NIterations;
    DWORD dwNLoops = MemSize / sizeof(DWORD);
    nvAssert((((DWORD)pAddr) & 3) == 0);
    nvAssert(dwNLoops != 0);
    _START(TimeIndex);
    do
    {
        __asm {
            mov ecx, dwNLoops
            mov eax, pAddr
NextWrite:
            mov [eax+ecx*4-4], edx
            loop NextWrite
        }
    } while (--i);
    _STOP(TimeIndex);
    _Time[TimeIndex] /= NIterations;
}

void MemoryPerformanceTest(void)
{
    byte    TestSpace[MEM_SIZE];
    DWORD   *pAddr;
    DWORD   AGPAddr = 0;
#ifdef  TEST_VIDEO
    DWORD   VidMemAddr = 0;
    DWORD   dwStatus;
#endif  //TEST_VIDEO

    if (PerformTest)
    {
        AGPAddr = (DWORD)nvAGPAlloc(MEM_SIZE);
#ifdef  TEST_VIDEO
        NVHEAP_ALLOC (dwStatus, VidMemAddr, MEM_SIZE, TYPE_TEXTURE);
        if (dwStatus != 0)
        {
            //Failure
            VidMemAddr = 0;
        }
#endif  //TEST_VIDEO
    }
    while (PerformTest)
    {
        //System memory first
        pAddr = (DWORD *)(((DWORD)TestSpace + 3) & 0xFFFFFFFC);
        //ReadMemory(pAddr, 0);
        WriteMemory(pAddr, 1);
        if (AGPAddr)
        {
            pAddr = (DWORD *)(((DWORD)AGPAddr + 3) & 0xFFFFFFFC);
            //ReadMemory(pAddr, 2);
            WriteMemory(pAddr, 3);
        }
#ifdef  TEST_VIDEO
        if (VidMemAddr)
        {
            pAddr = (DWORD *)(((DWORD)VidMemAddr + 3) & 0xFFFFFFFC);
            //ReadMemory(pAddr, 4);
            WriteMemory(pAddr, 5);
        }
#endif  //TEST_VIDEO
        nvAssert(0);    //essentually the same as __asm int 3
    }
    if (AGPAddr) nvAGPFree((void*)AGPAddr);
#ifdef  TEST_VIDEO
    if (VidMemAddr) NVHEAP_FREE(VidMemAddr);
#endif  //TEST_VIDEO
}
#endif  //MEMORY_TEST

void StereoContextDestroy(PNVD3DCONTEXT pContext)
{
    if (!STEREO_ENABLED)
        return;
    NvSetStereoDataPtrFromDriverData;
    if (!STEREO_R_US(pContext))
        return;
    if (STEREO_ACTIVATED)
    {
        pStereoData->StereoSettings.dwFlags |= STEREO_FORCEDOFF;
        DeactivateStereo(pContext);
    }
#ifdef  LASER_SIGHT
    if (pLaser_Texture)
    {
        pLaser_Obj->release();
        pLaser_Obj  = NULL;
        pLaser_Texture = NULL;
    }
#endif  //LASER_SIGHT
    pStereoData->dwContext = 0;
    if (!pStereoData->StereoKeys.pHotKeyI)
        return;
    DESTROYSTEREOHOTKEY(pStereoData->StereoKeys.StereoToggle);
    DESTROYSTEREOHOTKEY(pStereoData->StereoKeys.StereoSeparationAdjustMore);
    DESTROYSTEREOHOTKEY(pStereoData->StereoKeys.StereoSeparationAdjustLess);
    DESTROYSTEREOHOTKEY(pStereoData->StereoKeys.StereoConvergenceAdjustMore);
    DESTROYSTEREOHOTKEY(pStereoData->StereoKeys.StereoConvergenceAdjustLess);
#ifdef  STEREO_CONFIG_ASSIST
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.SuggestKey);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.UnsuggestKey);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.WriteKey);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.DeleteKey);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.FrustumAdjust);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.ToggleAutoConvergence);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.ToggleAutoConvergenceRestore);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.RHWAtScreenMore);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.RHWAtScreenLess);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.RHWLessAtScreenMore);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.RHWLessAtScreenLess);
	if (STEREODATA(StereoSettings.dwFlags) & STEREO_GAMMACORRECTION)
	{
		DESTROYSTEREOHOTKEY(ConfigAssistInfo.GammaAdjustMore);
		DESTROYSTEREOHOTKEY(ConfigAssistInfo.GammaAdjustLess);
	}
#ifdef  LASER_SIGHT
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.LaserXPlusKey);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.LaserXMinusKey);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.LaserYPlusKey);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.LaserYMinusKey);
#endif  //LASER_SIGHT
#endif  //STEREO_CONFIG_ASSIST
#ifdef  SNAP_SHOT
    DESTROYSTEREOHOTKEY(SaveStereoImage);
#endif  //SNAP_SHOT

#ifdef USE_POPUP_LIST
        popupAgents.finiHotKeys();
#endif //USE_POPUP_LIST

    delete pStereoData->StereoKeys.pHotKeyI;
    pStereoData->StereoKeys.pHotKeyI = NULL;
}

#define	USE_PATTERN		1

typedef	struct Target_Conversion_Info_S 
{
	DWORD			dwFlags;
	CSimpleSurface *pTarget;
	DWORD			dwRop;
	DWORD			dwColorLeft;
	DWORD			dwColorRight;
	LPRECT			pRectLeft;
	LPRECT			pRectRight;
} TARGETCONVERSIONINFO, *PTARGETCONVERSIONINFO;
	
void TargetConversion(PTARGETCONVERSIONINFO pTargetConversionInfo)
{
    // make sure we get access to all of video memory
    bltUpdateClip(pDriverData);
    pDriverData->blitCalled = TRUE;
    pDriverData->TwoDRenderingOccurred = 1;
    // make sure we sync with other channels before writing put
    getDC()->nvPusher.setSyncChannelFlag();

    if (pDriverData->bltData.dwLastRop != pTargetConversionInfo->dwRop) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_ROP) | SET_ROP_OFFSET | 0x40000);
        nvPushData(1, pTargetConversionInfo->dwRop);
        nvPusherAdjust(2);
        pDriverData->bltData.dwLastRop = pTargetConversionInfo->dwRop;
    }
    if (pDriverData->bltData.dwLastColourKey != 0xFFFFFFFF) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData(1, NV_DD_CONTEXT_COLOR_KEY);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | SET_TRANSCOLOR_OFFSET | 0x40000);
        nvPushData(3, 0);
        nvPusherAdjust(4);
        pDriverData->bltData.dwLastColourKey = 0xFFFFFFFF;
        pDriverData->dDrawSpareSubchannelObject = NV_DD_CONTEXT_COLOR_KEY;
    }
    CSimpleSurface *pSurf = pTargetConversionInfo->pTarget;
    DWORD dwPitch, dwSize, dwCombinedPitch, dwOffset, dwColourFormat, dwControlPoint;
    dwPitch = pSurf->getPitch();
    dwOffset = pSurf->getOffset();
    dwCombinedPitch = (dwPitch << 16) | dwPitch;
	if (pTargetConversionInfo->pRectLeft)
	{
		DWORD dwWidth, dwHeight;
		dwWidth  = pTargetConversionInfo->pRectLeft->right  - pTargetConversionInfo->pRectLeft->left;
		dwHeight = pTargetConversionInfo->pRectLeft->bottom - pTargetConversionInfo->pRectLeft->top;
		dwControlPoint = (pTargetConversionInfo->pRectLeft->left << 16) | pTargetConversionInfo->pRectLeft->top;
		dwSize = (dwWidth << 16) | dwHeight;
	} else
	{
		dwSize = (pSurf->getHeight() << 16) | pSurf->getWidth();
		dwControlPoint = 0;
	}
    if (pSurf->getBPP() == 2)
        dwColourFormat = NV062_SET_COLOR_FORMAT_LE_R5G6B5;
    else
        dwColourFormat = NV062_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;
    if (pDriverData->bltData.dwLastColourFormat != dwColourFormat ||
        pDriverData->bltData.dwLastCombinedPitch != dwCombinedPitch ||
        pDriverData->bltData.dwLastSrcOffset != dwOffset ||
        pDriverData->bltData.dwLastDstOffset != dwOffset) {

        nvPushData(0, dDrawSubchannelOffset(NV_DD_SURFACES) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
        nvPushData(1, dwColourFormat);                  // SetColorFormat
        nvPushData(2, dwCombinedPitch);                 // SetPitch
        nvPushData(3, dwOffset);                        // SetSrcOffset
        nvPushData(4, dwOffset);                        // SetDstOffset
        nvPusherAdjust(5);

        pDriverData->bltData.dwLastColourFormat = dwColourFormat;
        pDriverData->bltData.dwLastCombinedPitch = dwCombinedPitch;
        pDriverData->bltData.dwLastSrcOffset = dwOffset;
        pDriverData->bltData.dwLastDstOffset = dwOffset;

    }

	if (pTargetConversionInfo->dwFlags & USE_PATTERN)
	{
		// also set mono pattern mask when pixel depth changes
		// scaled image and gdi_rect will silently fail unless we set the pattern (?)
		getDC()->nvPusher.push(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
		getDC()->nvPusher.push(1, NV_DD_CONTEXT_PATTERN);
		getDC()->nvPusher.push(2, dDrawSubchannelOffset(NV_DD_SPARE) + NV044_SET_PATTERN_SELECT | 0xC0000);
		getDC()->nvPusher.push(3, NV044_SET_PATTERN_SELECT_MONOCHROME);
		if (pSurf->getBPP() == 2)
		{
			getDC()->nvPusher.push(4,NV_ALPHA_1_016);
			getDC()->nvPusher.push(5,NV_ALPHA_1_016);
		}
		else
		{
			getDC()->nvPusher.push(4,NV_ALPHA_1_032);
			getDC()->nvPusher.push(5,NV_ALPHA_1_032);
		}
		getDC()->nvPusher.adjust(6);

		getDC()->nvPusher.push(0, dDrawSubchannelOffset(NV_DD_SPARE) + NV044_SET_MONOCHORME_COLOR0 | 0x80000);
		getDC()->nvPusher.push(1, pTargetConversionInfo->dwColorLeft);
		getDC()->nvPusher.push(2, pTargetConversionInfo->dwColorLeft);
		getDC()->nvPusher.adjust(3);

		nvPushData (0, dDrawSubchannelOffset(NV_DD_BLIT) | BLIT_POINT_IN_OFFSET | 0xC0000);
		nvPushData (1, dwControlPoint); 
		nvPushData (2, dwControlPoint); 
		nvPushData (3, dwSize);     
		nvPusherAdjust(4);

	} else
	{
		nvPushData (0, dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) | RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000);
		nvPushData (1, pTargetConversionInfo->dwColorLeft);
		nvPushData (2, dwControlPoint); 
		nvPushData (3, dwSize);     
        nvPusherAdjust(4);
	}

	if (pTargetConversionInfo->pRectRight)
	{
		DWORD dwWidth, dwHeight;
		dwWidth  = pTargetConversionInfo->pRectRight->right  - pTargetConversionInfo->pRectRight->left;
		dwHeight = pTargetConversionInfo->pRectRight->bottom - pTargetConversionInfo->pRectRight->top;
		dwControlPoint = (pTargetConversionInfo->pRectRight->left << 16) | pTargetConversionInfo->pRectRight->top;
		dwSize = (dwWidth << 16) | dwHeight;
	} else
	{
		dwSize = (pSurf->getHeight() << 16) | pSurf->getWidth();
		dwControlPoint = 0;
	}
    dwOffset = pSurf->getOffsetRight();
    nvPushData(0, dDrawSubchannelOffset(NV_DD_SURFACES) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
    nvPushData(1, dwColourFormat);                  // SetColorFormat
    nvPushData(2, dwCombinedPitch);                 // SetPitch
    nvPushData(3, dwOffset);                        // SetSrcOffset
    nvPushData(4, dwOffset);                        // SetDstOffset
    nvPusherAdjust(5);
	pDriverData->bltData.dwLastSrcOffset = dwOffset;
	pDriverData->bltData.dwLastDstOffset = dwOffset;

	if (pTargetConversionInfo->dwFlags & USE_PATTERN)
	{
		getDC()->nvPusher.push(0, dDrawSubchannelOffset(NV_DD_SPARE) + NV044_SET_MONOCHORME_COLOR0 | 0x80000);
		getDC()->nvPusher.push(1, pTargetConversionInfo->dwColorRight);
		getDC()->nvPusher.push(2, pTargetConversionInfo->dwColorRight);
		getDC()->nvPusher.adjust(3);

		nvPushData (0, dDrawSubchannelOffset(NV_DD_BLIT) | BLIT_POINT_IN_OFFSET | 0xC0000);
		nvPushData (1, dwControlPoint); 
		nvPushData (2, dwControlPoint); 
		nvPushData (3, dwSize);     
		nvPusherAdjust(4);
	} else
	{
		nvPushData (0, dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) | RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000);
		nvPushData (1, pTargetConversionInfo->dwColorRight);
		nvPushData (2, dwControlPoint); 
		nvPushData (3, dwSize);     
		nvPusherAdjust(4);
	}

    nvPusherStart(TRUE);
}

void StereoBackend(LPDDHAL_FLIPDATA pfd)
{
    if (STEREO_ACTIVATED)
    {
        if (STEREODATA(StereoSettings.dwFlags) & STEREO_ANAGLYPH == 0
		 && STEREODATA(dwStereoHWType) != STEREOCFG_LINECODE
		 && STEREODATA(StereoSettings.FrustumAdjustMode) != FRUSTUM_CLEAR_EDGES)
			//Nothing needs to be done
			return;

		CNvObject *pObj = GET_PNVOBJ(pfd->lpSurfTarg);
		if (!pObj) 
			return;
		TARGETCONVERSIONINFO TargetConversionInfo;
		memset(&TargetConversionInfo, 0, sizeof (TARGETCONVERSIONINFO));
		TargetConversionInfo.pTarget		= pObj->getSimpleSurface();

        if (STEREODATA(StereoSettings.dwFlags) & STEREO_ANAGLYPH)
        {
			//We need to do a color anaglyph conversion of the surface being flipped to
			CNvObject *pObj = GET_PNVOBJ(pfd->lpSurfTarg);
			if (!pObj) 
				return;
			TargetConversionInfo.dwFlags		= USE_PATTERN;
			TargetConversionInfo.dwRop			= MERGECOPY >> 16;
			TargetConversionInfo.dwColorLeft	= STEREODATA(dwLeftAnaglyphFilter);
			TargetConversionInfo.dwColorRight	= STEREODATA(dwRightAnaglyphFilter);
            TargetConversion(&TargetConversionInfo);
        }

		if (STEREODATA(StereoSettings.FrustumAdjustMode) == FRUSTUM_CLEAR_EDGES)
		{
			float   fFrustumScale = 1.f/(1.f - STEREODATA(StereoSettings.fStereoSeparation) * 0.5f);
			DWORD   dwWidth = TargetConversionInfo.pTarget->getWidth();
			RECT	RectLeft, RectRight;
			TargetConversionInfo.dwFlags		= 0;
			TargetConversionInfo.dwRop			= SRCCOPYINDEX;
			TargetConversionInfo.dwColorLeft	= 0;	//Black
			TargetConversionInfo.dwColorRight	= 0;	//Black	
			TargetConversionInfo.pRectLeft		= &RectLeft;
			TargetConversionInfo.pRectRight		= &RectRight;
			RectLeft.top		= 0;
			RectLeft.bottom		= TargetConversionInfo.pTarget->getHeight();
			RectLeft.right		= TargetConversionInfo.pTarget->getWidth();
			RectLeft.left		= ((DWORD)((float)(dwWidth)/fFrustumScale*1024.f+512.f))>>10;
			RectRight.top		= RectLeft.top;
			RectRight.bottom	= RectLeft.bottom;
			RectRight.left		= 0;
			RectRight.right		= RectLeft.right - RectLeft.left;
            TargetConversion(&TargetConversionInfo);
		}

		if (STEREODATA(dwStereoHWType) == STEREOCFG_LINECODE)
		{
			RECT	RectLeft, RectRight;
			TargetConversionInfo.dwFlags		= 0;
			TargetConversionInfo.dwRop			= SRCCOPYINDEX;
			TargetConversionInfo.dwColorLeft	= STEREODATA(dwLineCodeColor);
			TargetConversionInfo.dwColorRight	= STEREODATA(dwLineCodeColor);
			TargetConversionInfo.pRectLeft		= &RectLeft;
			TargetConversionInfo.pRectRight		= &RectRight;
			RectLeft.bottom		= TargetConversionInfo.pTarget->getHeight();
			RectLeft.top		= RectLeft.bottom - 1;
			RectLeft.left		= 0;
			RectLeft.right		= TargetConversionInfo.pTarget->getWidth() >> 2;
			RectRight.bottom	= RectLeft.bottom;
			RectRight.top		= RectLeft.top;
			RectRight.left		= 0;
			RectRight.right		= TargetConversionInfo.pTarget->getWidth() - RectLeft.right;
            TargetConversion(&TargetConversionInfo);
			TargetConversionInfo.dwColorLeft	= 0;	//Black
			TargetConversionInfo.dwColorRight	= 0;	//Black	
			RectLeft.left		= RectLeft.right;
			RectLeft.right		= TargetConversionInfo.pTarget->getWidth();
			RectRight.left		= RectRight.right;
			RectRight.right		= RectLeft.right;
            TargetConversion(&TargetConversionInfo);
		}
	}
}

void StereoAdjustmentMonitor(PNVD3DCONTEXT pContext)
{
    BOOL res_ = FALSE;
 
#ifdef  MEMORY_TEST
    MemoryPerformanceTest();
#endif  //MEMORY_TEST

    if (!STEREO_ENABLED)
        return;

#ifdef  DELAYED_HOTKEY_INIT
    if (FirstHotKeyInit)
    {
        if (!(pStereoData->StereoKeys.pHotKeyI = new CHOTKEYINTERFACE))
        {
            //Hot key support creation failed. We won't do anything special at this point like releasing the
            //StereoViewer. So all that previously done stuff will be standing by untill the driver gets unloaded.
            //It shouldn't cause any troubles because a game won't be able to activate stereo anyway. It would be
            //nice to somehow report the situation by putting message on the screen or generating some LogError
            //file. We'll figure it out later.
            return;
        }

        CREATESTEREOHOTKEY(pStereoData->StereoKeys.StereoToggle);
        CREATESTEREOHOTKEY(pStereoData->StereoKeys.StereoSeparationAdjustMore);
        CREATESTEREOHOTKEY(pStereoData->StereoKeys.StereoSeparationAdjustLess);
        CREATESTEREOHOTKEY(pStereoData->StereoKeys.StereoConvergenceAdjustMore);
        CREATESTEREOHOTKEY(pStereoData->StereoKeys.StereoConvergenceAdjustLess);
#ifdef  STEREO_CONFIG_ASSIST
        CREATESTEREOHOTKEY(ConfigAssistInfo.SuggestKey);
        CREATESTEREOHOTKEY(ConfigAssistInfo.UnsuggestKey);
        CREATESTEREOHOTKEY(ConfigAssistInfo.WriteKey);
        CREATESTEREOHOTKEY(ConfigAssistInfo.DeleteKey);
        CREATESTEREOHOTKEY(ConfigAssistInfo.FrustumAdjust);
        CREATESTEREOHOTKEY(ConfigAssistInfo.ToggleAutoConvergence);
        CREATESTEREOHOTKEY(ConfigAssistInfo.ToggleAutoConvergenceRestore);
        CREATESTEREOHOTKEY(ConfigAssistInfo.RHWAtScreenMore);
        CREATESTEREOHOTKEY(ConfigAssistInfo.RHWAtScreenLess);
        CREATESTEREOHOTKEY(ConfigAssistInfo.RHWLessAtScreenMore);
        CREATESTEREOHOTKEY(ConfigAssistInfo.RHWLessAtScreenLess);
		if (STEREODATA(StereoSettings.dwFlags) & STEREO_GAMMACORRECTION)
		{
			CREATESTEREOHOTKEY(ConfigAssistInfo.GammaAdjustMore);
			CREATESTEREOHOTKEY(ConfigAssistInfo.GammaAdjustLess);
		}
#ifdef  LASER_SIGHT
        CREATESTEREOHOTKEY(ConfigAssistInfo.LaserXPlusKey);
        CREATESTEREOHOTKEY(ConfigAssistInfo.LaserXMinusKey);
        CREATESTEREOHOTKEY(ConfigAssistInfo.LaserYPlusKey);
        CREATESTEREOHOTKEY(ConfigAssistInfo.LaserYMinusKey);
#endif  //LASER_SIGHT
#endif  //STEREO_CONFIG_ASSIST
#ifdef  SNAP_SHOT
        CREATESTEREOHOTKEY(SaveStereoImage);
#endif  //SNAP_SHOT

#ifdef  USE_POPUP_LIST
        popupAgents.initHotKeys();
#endif  //USE_POPUP_LIST

        FirstHotKeyInit = 0;
    }
#endif  //DELAYED_HOTKEY_INIT

#if 1
    if (++nFlips < 0x1000 && (nFlips & 0x7F) == 0)
        ENFORCEKEYBOARDFILTER();
#else
    if (++nFlips < 0x1000 && (nFlips & 0x7F) == 0)
    {
        ENFORCEKEYBOARDFILTER();
        if (res_)
        {
            //Start watching all over.
            nFlips = 0;
        }
    }
#endif
    //Keep an eye on the HW T&L use. Stereo works differently for HW and SW T&L!!!
    if(!NV_VERTEX_TRANSFORMED(pContext->pCurrentVShader))
        pStereoData->dwHWTnL++;

	//HW T&L has to prove itself as being used
    if ((nFlips & 0x1F) == 0)
		pStereoData->dwHWTnL = (pStereoData->dwHWTnL > 1) ? 1 : 0;

    //We need to turn stereo on if previously was forced to GDI
    if (pStereoData->StereoSettings.dwFlags & STEREO_FORCEDTOGDI)
    {
        pStereoData->StereoSettings.dwFlags &= ~STEREO_FORCEDTOGDI;
        if (!pStereoData->bStereoActivated)
            ActivateStereo(pContext);
    }

    POLLSTEREOHOTKEY(pStereoData->StereoKeys.StereoToggle)
    {
        if (pStereoData->bStereoActivated)
        {
            //Request to deactivate stereo.
            pStereoData->StereoModeNumber = 0;
            DeactivateStereo(pContext);
        } else
        {
            //Request to activate stereo.
            pStereoData->StereoModeNumber = pDXShare->dwModeNumber;
            ActivateStereo(pContext);
        }
    }

    if (!pStereoData->bStereoActivated)
    {
        //Nothing to do
        return;
    }

#ifdef  LASER_SIGHT
#ifdef  STEREO_CONFIG_ASSIST
    POLLSTEREOHOTKEY(ConfigAssistInfo.LaserXPlusKey)
    {
        pStereoData->StereoSettings.fLaserXAdjust += 0.001f;
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.LaserXMinusKey)
    {
        pStereoData->StereoSettings.fLaserXAdjust -= 0.001f;
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.LaserYPlusKey)
    {
        pStereoData->StereoSettings.fLaserYAdjust += 0.001f;
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.LaserYMinusKey)
    {
        pStereoData->StereoSettings.fLaserYAdjust -= 0.001f;
    }

#endif  //STEREO_CONFIG_ASSIST

    if (pStereoData->StereoSettings.dwFlags & STEREO_LASERSIGHT)
    {
        //We are going to use our proprietary laser site
#if (NVARCH >= 0x020)
        CSimpleSurface *pZetaBuffer = ((PNVD3DCONTEXT)(pStereoData->dwContext))->kelvinAA.GetCurrentZB(pContext);
#else
        CSimpleSurface *pZetaBuffer = ((PNVD3DCONTEXT)(pStereoData->dwContext))->pZetaBuffer;
        #error Not implemented yet (If ever will).
#endif
        //Instead of doing WaitForIdle (TRUE,FALSE) in order to get access to the Z buffer
        //we can do a cpuLock on Z buffer. It will be more efficient.
        if (pZetaBuffer)
        {
            DWORD   dwCenterValue;
            float SZ_Center = 0.0f;
            float RHW_Center;
            pZetaBuffer->cpuLock(CSimpleSurface::LOCK_NORMAL);
            float CenterX = (pZetaBuffer->getWidth() >> 1)  * pStereoData->StereoSettings.fLaserXAdjust;
            float CenterY = (pZetaBuffer->getHeight() >> 1) * pStereoData->StereoSettings.fLaserYAdjust;
            float CenterX_RT = (((PNVD3DCONTEXT)(pStereoData->dwContext))->pRenderTarget->getWidth() >> 1)  * pStereoData->StereoSettings.fLaserXAdjust;
            float CenterY_RT = (((PNVD3DCONTEXT)(pStereoData->dwContext))->pRenderTarget->getHeight() >> 1) * pStereoData->StereoSettings.fLaserYAdjust;
#ifdef  EXPERIMENT
            __asm int 3
#endif  //EXPERIMENT
            DWORD pLeftEyeCenter = (DWORD)pZetaBuffer->getAddress() + CenterY
                                          * pZetaBuffer->getPitch() + CenterX
                                          * pZetaBuffer->getBPP();
            if (pZetaBuffer->getBPP() == 2)
                dwCenterValue = (DWORD)*(WORD *)pLeftEyeCenter;
            else
                dwCenterValue = (*(DWORD *)pLeftEyeCenter) >> 8;
            //nvAssert(pContext->dwRenderState[D3DRENDERSTATE_ZBIAS] == 0);
#if 0
            float fZBias, fZScale;
            fZBias  = -(float)(pContext->dwRenderState[D3DRENDERSTATE_ZBIAS]);
            fZScale = 0.25f * fZBias;
            fZBias  *= pContext->hwState.celsius.dvInvZScale;
            fZScale *= pContext->hwState.celsius.dvInvZScale;
#endif
#ifdef  DEBUG
            //We need to process the Center Point based on the ZFUNC below
            DWORD CompFunc = pContext->dwRenderState[D3DRENDERSTATE_ZFUNC];
            switch (CompFunc)
            {
            case D3DCMP_NEVER:
                nvAssert(0);
                break;

            case D3DCMP_LESS:
                nvAssert(0);
                break;

            case D3DCMP_EQUAL:
                nvAssert(0);
                break;

            case D3DCMP_LESSEQUAL:
                //nvAssert(0);
                break;

            case D3DCMP_GREATER:
                nvAssert(0);
                break;

            case D3DCMP_NOTEQUAL:
                nvAssert(0);
                break;

            case D3DCMP_GREATEREQUAL:
                nvAssert(0);
                break;

            case D3DCMP_ALWAYS:
                nvAssert(0);
                break;
            }
#endif  //DEBUG
#if 1
            if (pStereoData->dwHWTnL)
            {
                //Calculating Sz & rhw values for HW T&L is a little bit tricky. Watch my hands.
                //First we're going to calculate the expected laser sight X offset for the central
                //point. The existing StereoConvergenceMultiplier is just a default value: it
                //can't be correct for dwHWTnL games. But we don't care because we're going
                //to do a reversed transform of expected stereo screen coordinates to appropriate
                //Sz & rhw in order for our general stereo mechanizm to produce those expected
                //stereo screen coordinates based on existing StereoConvergenceMultiplier.
                float SZOverRange, ZRange, WRange;
                float XCorrection;
                float fScreenHalfWidth;
                //__asm int 3
#if 1
                float rhwMax = 100.f;
                if (pContext->surfaceViewport.dvWNear != 0)
                    rhwMax = 1.f/pContext->surfaceViewport.dvWNear;
                float Divider = rhwMax * pStereoData->StereoSettings.fStereoConvergence;
                if (Divider != 0)
                    pStereoData->StereoSettings.fConvergenceMultiplier = 1.f/Divider;
                else
                    pStereoData->StereoSettings.fConvergenceMultiplier = 0.0f;
#if 0
                pStereoData->StereoSettings.fPostStereoConvergence = pStereoData->StereoSettings.fStereoConvergence
                                                      * pStereoData->StereoSettings.fConvergenceMultiplier;
#else
                pStereoData->StereoSettings.fPostStereoConvergence = pStereoData->StereoSettings.fStereoConvergence;
#endif
#endif
                fScreenHalfWidth = (float)(pZetaBuffer->getWidth() >> 1);
#if (NVARCH >= 0x010)
#if 0
                float fZBias, fZScale;
                fZBias  = -(float)(pContext->dwRenderState[D3DRENDERSTATE_ZBIAS]);
#endif
                if (pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW)
                {
                    WRange = pContext->surfaceViewport.dvWFar - pContext->surfaceViewport.dvWNear;
                    float W_Center = ((float)dwCenterValue) * (pContext->surfaceViewport.dvWFar * pContext->hwState.dvInvZScale);
                    RHW_Center = 1.0f/W_Center;
                    SZOverRange = (W_Center - pContext->surfaceViewport.dvWNear) / WRange;
                    XCorrection = (pStereoData->StereoSettings.fStereoSeparation * SZOverRange - pStereoData->StereoSettings.fStereoConvergence) * fScreenHalfWidth;
                    XCorrection = max(XCorrection,0.f); //If negative paralax show no separation
                } else
                {
                    pStereoData->StereoSettings.dwFlags |= STEREO_LASERGETRHWSCALE;
                    SZ_Center = ((float)dwCenterValue) * pContext->hwState.dvInvZScale;
                    RHW_Center = LaserRHWBase + (SZ_Center - LaserSZBase)*LaserRHWScale;
                    ZRange = pContext->surfaceViewport.dvMaxZ - pContext->surfaceViewport.dvMinZ;
                    SZOverRange = (SZ_Center - pContext->surfaceViewport.dvMinZ) / (pContext->surfaceViewport.dvMaxZ - pContext->surfaceViewport.dvMinZ);
                    XCorrection = (pStereoData->StereoSettings.fStereoSeparation * SZOverRange - pStereoData->StereoSettings.fStereoConvergence) * fScreenHalfWidth;
                    XCorrection = max(XCorrection,0.f); //If negative paralax show no separation
                }
#else
                #error Not implemented yet (If ever will).
#endif
            } else
            {
#if (NVARCH >= 0x010)
                if (pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW)
                {
                    float W_Center = ((float)dwCenterValue) * (pContext->surfaceViewport.dvWFar * pContext->hwState.dvInvZScale);
                    RHW_Center = 1.0f/W_Center;
                } else
                {
                    pStereoData->StereoSettings.dwFlags |= STEREO_LASERGETRHWSCALE;
                    SZ_Center = ((float)dwCenterValue) * pContext->hwState.dvInvZScale;
                    RHW_Center = LaserRHWBase + (SZ_Center - LaserSZBase)*LaserRHWScale;
                }
#else
                #error Not implemented yet (If ever will).
#endif
            }
#endif
#if 0
#if (NVARCH >= 0x010)
            if (pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW)
            {
                float W_Center = ((float)dwCenterValue) * (pContext->surfaceViewport.dvWFar * pContext->hwState.dvInvZScale);
                RHW_Center = 1.0f/W_Center;
            } else
            {
                pStereoData->StereoSettings.dwFlags |= STEREO_LASERGETRHWSCALE;
                SZ_Center = ((float)dwCenterValue) * pContext->hwState.dvInvZScale;
                RHW_Center = LaserRHWBase + (SZ_Center - LaserSZBase)*LaserRHWScale;
            }
#else
            #error Not implemented yet (If ever will).
#endif
#endif
            float fRealConvergence = pStereoData->dwHWTnL ? pStereoData->StereoSettings.fStereoConvergence : pStereoData->StereoSettings.fPostStereoConvergence;
            float LaserSize = LaserMinSize + (LaserMaxSize - LaserMinSize)*RHW_Center * fRealConvergence;
            if (LaserSize > LaserMaxSize)
            {
                //Popped up with negative paralax
                LaserSize = LaserMaxSize;
            }
            typedef struct {
                DDRAWI_DDRAWSURFACE_GBL_MORE ddGblMore;
                LPDWORD                      dwReserved1;
                DDRAWI_DDRAWSURFACE_GBL      ddGbl;
            } EXT_DDRAWI_DDRAWSURFACE_GBL;
            DDRAWI_DDRAWSURFACE_LCL     LaserDP2Command_Lcl;
            EXT_DDRAWI_DDRAWSURFACE_GBL eddGbl;
            eddGbl.ddGbl.fpVidMem = (FLATPTR)&LaserDP2Command;
            LaserDP2Data.lpDDCommands = &LaserDP2Command_Lcl;
            eddGbl.dwReserved1 = (LPDWORD)&eddGbl.ddGblMore;
            LaserDP2Command_Lcl.lpGbl = &eddGbl.ddGbl;
            SET_PNVOBJ (&LaserDP2Command_Lcl, NULL);
            LPDDHALMODEINFO lpModeInfo = &pDriverData->ModeList[pDXShare->dwModeNumber];
#ifndef EXPERIMENT
            LaserVertices[0].dvSX = LaserVertices[1].dvSX = LaserVertices[2].dvSX =
                                    LaserVertices[3].dvSX = CenterX_RT;
            LaserVertices[0].dvSY = LaserVertices[1].dvSY = LaserVertices[2].dvSY =
                                    LaserVertices[3].dvSY = CenterY_RT;
            LaserVertices[0].dvSX -= LaserSize;
            LaserVertices[0].dvSY -= LaserSize;
            LaserVertices[1].dvSX += LaserSize;
            LaserVertices[1].dvSY -= LaserSize;
            LaserVertices[2].dvSX -= LaserSize;
            LaserVertices[2].dvSY += LaserSize;
            LaserVertices[3].dvSX += LaserSize;
            LaserVertices[3].dvSY += LaserSize;
#else   //EXPERIMENT
            LaserSize = 4.f;
            LaserVertices[0].dvSX = LaserVertices[1].dvSX = LaserVertices[2].dvSX =
                                    LaserVertices[3].dvSX = LaserSize;
            LaserVertices[0].dvSY = LaserVertices[1].dvSY = LaserVertices[2].dvSY =
                                    LaserVertices[3].dvSY = LaserSize;
            LaserVertices[0].dvSX -= LaserSize;
            LaserVertices[0].dvSY -= LaserSize;
            LaserVertices[1].dvSX += LaserSize;
            LaserVertices[1].dvSY -= LaserSize;
            LaserVertices[2].dvSX -= LaserSize;
            LaserVertices[2].dvSY += LaserSize;
            LaserVertices[3].dvSX += LaserSize;
            LaserVertices[3].dvSY += LaserSize;
#endif  //EXPERIMENT
            SetupLaserStates(pContext);
            //Make it a little bit closer;
#ifndef EXPERIMENT
            SZ_Center *= 0.98f;
            RHW_Center *= 1.02f;
#else   //EXPERIMENT
            SZ_Center = 0.f;
            RHW_Center *= 1.02f;
#endif  //EXPERIMENT
            LaserVertices[0].dvSZ = LaserVertices[1].dvSZ = LaserVertices[2].dvSZ = LaserVertices[3].dvSZ = SZ_Center;
            LaserVertices[0].dvRHW = LaserVertices[1].dvRHW = LaserVertices[2].dvRHW = LaserVertices[3].dvRHW = RHW_Center;
            LaserDP2Data.dwhContext = (DWORD)pContext;
            LaserDP2Data.dwVertexSize = sizeof (D3DTLVERTEX);
            //To make the laser sight properly stereoized we need to clear the
            //pStereoData->dwHWTnL. Otherwise our algorithm considers D3DTLVERTEX
            //to be a sign of 2D object.
            DWORD dwHWTnL = pStereoData->dwHWTnL;  //Save it
#ifndef EXPERIMENT
            pStereoData->dwHWTnL = 0;
#else   //EXPERIMENT
            pStereoData->dwHWTnL = 1;
#endif  //EXPERIMENT
            DWORD dwDXAppVersion = pContext->dwDXAppVersion;
            pContext->dwDXAppVersion = 0x700;
            nvDrawPrimitives2(&LaserDP2Data);
            pContext->dwDXAppVersion = dwDXAppVersion;
            pStereoData->dwHWTnL = dwHWTnL;
			RestorePreLaserStates(pContext);
		}
    }
#endif  //LASER_SIGHT

	/////////// render a list of PopupAgent 

#ifdef USE_POPUP_LIST
    //we'll check inside whether we'd really render
	popupAgents.render(pContext);
#endif //USE_POPUP_LIST

    if (pStereoData->StereoSettings.dwFlags & STEREO_AUTOCONVERGENCE && pStereoData->fFrameRHWMax != -9999.f)
    {
        //We need to adjust the pStereoData->StereoSettings.fPostStereoConvergence value based on the depth
        //of the closest object in the current scene. This value will take effect in the next frame.
        //To make this adjustment smooth we want to do an inert transition not exceeding say 5% of the
        //difference between the current pStereoData->StereoSettings.fPostStereoConvergence and ideal value for that
        //being calculated below per frame.
        D3DVALUE fIdealMultiplier = 1.f/(pStereoData->fFrameRHWMax * pStereoData->StereoSettings.fStereoConvergence);
        pStereoData->StereoSettings.fConvergenceMultiplier += (fIdealMultiplier - pStereoData->StereoSettings.fConvergenceMultiplier)
                                              * pStereoData->StereoSettings.AutoConvergenceAdjustPace;
        pStereoData->StereoSettings.fPostStereoConvergence = pStereoData->StereoSettings.fStereoConvergence;
    }
#ifdef  STEREO_CONFIG_ASSIST
    if (ConfigAssistInfo.rhwMax < pStereoData->fFrameRHWMax)
        ConfigAssistInfo.rhwMax = pStereoData->fFrameRHWMax;
#endif  //STEREO_CONFIG_ASSIST
#ifdef  FLAT_STAT
    dwNFlatObjects = 0;
#endif  //FLAT_STAT
    pStereoData->fFrameRHWMax     = -9999.f;

    POLLSTEREOHOTKEY(pStereoData->StereoKeys.StereoSeparationAdjustMore)
    {
        pStereoData->StereoSettings.fStereoSeparation += 0.002f;
        //Clamp it.
        if (pStereoData->StereoSettings.fStereoSeparation > MAX_STEREO_SEPARATION)
            pStereoData->StereoSettings.fStereoSeparation = MAX_STEREO_SEPARATION;
        pStereoData->StereoSettings.dwFlags |= STEREO_SEPARATION;
        AdjustStereoParameters(pContext);
    }

    POLLSTEREOHOTKEY(pStereoData->StereoKeys.StereoSeparationAdjustLess)
    {
        pStereoData->StereoSettings.fStereoSeparation -= 0.002f;
        //Clamp it.
        if (pStereoData->StereoSettings.fStereoSeparation < 0.f)
            pStereoData->StereoSettings.fStereoSeparation = 0.f;
        pStereoData->StereoSettings.dwFlags |= STEREO_SEPARATION;
        AdjustStereoParameters(pContext);
    }

    //StereoConvergence adjustment is a little bit tricky. First of all we dont want it to be 
    //linear because in some games when an optimal value is really low smal increment makes big 
    //difference. On the other hand some games like Forsaken require a huge number (~1000+) and 
    //we don't want to hold the key for minutes in order to see some noticable change. So we'll
    //make a step size exponential. Disadvantage of exponential function is that it never flips 
    //the sigh of the convergence. So we're doomed to being able to adjust in one direction only
    //(bringing things out of the screen). If we need to go the other way we need to change the 
    //sign. Here is how we're going to do it. If the convergence gets within the range 
    //(-CONVERGENCE_THRESHOLD, CONVERGENCE_THRESHOLD) then every change that makes it closer to 
    //zero flips the sign. This way we can say that StereoConvergenceAdjustMore always brings 
    //objects out of the monitor and StereoConvergenceAdjustLess does the opposite.
    POLLSTEREOHOTKEY(pStereoData->StereoKeys.StereoConvergenceAdjustMore)
    {
        if (pStereoData->StereoSettings.fStereoConvergence > 0)
            pStereoData->StereoSettings.fStereoConvergence *= 1.02f;
        else
        {
            pStereoData->StereoSettings.fStereoConvergence *= (1.f/1.02f);
            if (pStereoData->StereoSettings.fStereoConvergence > -CONVERGENCE_THRESHOLD)
                pStereoData->StereoSettings.fStereoConvergence = -pStereoData->StereoSettings.fStereoConvergence;
        }
        pStereoData->StereoSettings.dwFlags |= STEREO_CONVERGENCE;
        AdjustStereoParameters(pContext);
    }

    POLLSTEREOHOTKEY(pStereoData->StereoKeys.StereoConvergenceAdjustLess)
    {
        if (pStereoData->StereoSettings.fStereoConvergence > 0)
        {
            pStereoData->StereoSettings.fStereoConvergence *= (1.f/1.02f);
            if (pStereoData->StereoSettings.fStereoConvergence < CONVERGENCE_THRESHOLD)
                pStereoData->StereoSettings.fStereoConvergence = -pStereoData->StereoSettings.fStereoConvergence;
        }
        else
            pStereoData->StereoSettings.fStereoConvergence *= 1.02f;
        pStereoData->StereoSettings.dwFlags |= STEREO_CONVERGENCE;
        AdjustStereoParameters(pContext);
    }

#ifdef  STEREO_CONFIG_ASSIST
    POLLSTEREOHOTKEY(ConfigAssistInfo.SuggestKey)
    {
        SuggestStereoSettings();
        AdjustStereoParameters(pContext);
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.UnsuggestKey)
    {
        UnsuggestStereoSettings();
        AdjustStereoParameters(pContext);
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.WriteKey)
    {
        DumpConfigInfo();
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.DeleteKey)
    {
        DeleteConfigInfo();
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.FrustumAdjust)
    {
        if (++pStereoData->StereoSettings.FrustumAdjustMode > FRUSTUM_CLEAR_EDGES)
            pStereoData->StereoSettings.FrustumAdjustMode = NO_FRUSTUM_ADJUST;
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.ToggleAutoConvergenceRestore)
    {
        if (pStereoData->StereoSettings.dwFlags & STEREO_AUTOCONVERGENCE)
        {
            //Going back to manual. Need to restore what was there before.
            pStereoData->StereoSettings.fConvergenceMultiplier = ConfigAssistInfo.fLastNonAutoConvergenceMultiplier;
            pStereoData->StereoSettings.fPostStereoConvergence = pStereoData->StereoSettings.fStereoConvergence;
        } else
        {
            //Going to auto. Need to save the manual convergence in order to be able
            //to restore if we're screwed up.
            ConfigAssistInfo.fLastNonAutoConvergenceMultiplier = pStereoData->StereoSettings.fConvergenceMultiplier;
        }
        pStereoData->StereoSettings.dwFlags ^= STEREO_AUTOCONVERGENCE;
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.ToggleAutoConvergence)
    {
        pStereoData->StereoSettings.dwFlags ^= STEREO_AUTOCONVERGENCE;
    }

    float fRHWAtScreenDelta;

    POLLSTEREOHOTKEY(ConfigAssistInfo.RHWAtScreenMore)
    {
        if (pStereoData->StereoSettings.dwFlags & STEREO_FAVORSZOVERRHW)
        {
            if (!(pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN))
            {
                //Has not been set yet
                pStereoData->StereoSettings.dwFlags |= STEREO_RHWGREATERATSCREEN;
                pStereoData->StereoSettings.fRHWGreaterAtScreen = ConfigAssistInfo.szMin;
            }
            fRHWAtScreenDelta = (ConfigAssistInfo.szMax - ConfigAssistInfo.szMin) / 100.f;
            pStereoData->StereoSettings.fRHWGreaterAtScreen += fRHWAtScreenDelta;
            ConfigAssistInfo.szMin += fRHWAtScreenDelta;
        } else
        {
            //More in reality means less. So farther objects are put at the screen plane.
            if (!(pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN))
            {
                //Has not been set yet
                pStereoData->StereoSettings.dwFlags |= STEREO_RHWGREATERATSCREEN;
                pStereoData->StereoSettings.fRHWGreaterAtScreen = ConfigAssistInfo.rhwMax;
            }
            fRHWAtScreenDelta = (ConfigAssistInfo.rhwMax - ConfigAssistInfo.rhwMin) / 100.f;
            pStereoData->StereoSettings.fRHWGreaterAtScreen -= fRHWAtScreenDelta;
            ConfigAssistInfo.rhwMax -= fRHWAtScreenDelta;
        }
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.RHWAtScreenLess)
    {
        if (pStereoData->StereoSettings.dwFlags & STEREO_FAVORSZOVERRHW)
        {
            if (!(pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN))
            {
                //Has not been set yet
                pStereoData->StereoSettings.dwFlags |= STEREO_RHWGREATERATSCREEN;
                pStereoData->StereoSettings.fRHWGreaterAtScreen = ConfigAssistInfo.szMin;
            }
            fRHWAtScreenDelta = (ConfigAssistInfo.szMax - ConfigAssistInfo.szMin) / 100.f;
            pStereoData->StereoSettings.fRHWGreaterAtScreen -= fRHWAtScreenDelta;
            ConfigAssistInfo.szMin -= fRHWAtScreenDelta;
        } else
        {
            //Less in reality means more. So closer objects are put at the screen plane.
            if (!(pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN))
            {
                //Has not been set yet
                pStereoData->StereoSettings.dwFlags |= STEREO_RHWGREATERATSCREEN;
                pStereoData->StereoSettings.fRHWGreaterAtScreen = ConfigAssistInfo.rhwMax;
            }
            fRHWAtScreenDelta = (ConfigAssistInfo.rhwMax - ConfigAssistInfo.rhwMin) / 100.f;
            pStereoData->StereoSettings.fRHWGreaterAtScreen += fRHWAtScreenDelta;
            ConfigAssistInfo.rhwMax += fRHWAtScreenDelta;
        }
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.RHWLessAtScreenMore)
    {
        if (pStereoData->StereoSettings.dwFlags & STEREO_FAVORSZOVERRHW)
        {
            if (!(pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN))
            {
                //Has not been set yet
                pStereoData->StereoSettings.dwFlags |= STEREO_RHWLESSATSCREEN;
                pStereoData->StereoSettings.fRHWLessAtScreen = ConfigAssistInfo.szMax;
            }
            fRHWAtScreenDelta = (ConfigAssistInfo.szMax - ConfigAssistInfo.szMin) / 100.f;
            pStereoData->StereoSettings.fRHWLessAtScreen -= fRHWAtScreenDelta;
            ConfigAssistInfo.szMax -= fRHWAtScreenDelta;
        } else
        {
            //More in reality means less. So farther objects are put at the screen plane.
            if (!(pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN))
            {
                //Has not been set yet
                pStereoData->StereoSettings.dwFlags |= STEREO_RHWLESSATSCREEN;
                pStereoData->StereoSettings.fRHWLessAtScreen = ConfigAssistInfo.rhwMin;
            }
            fRHWAtScreenDelta = (ConfigAssistInfo.rhwMax - ConfigAssistInfo.rhwMin) / 100.f;
            pStereoData->StereoSettings.fRHWLessAtScreen += fRHWAtScreenDelta;
            ConfigAssistInfo.rhwMin += fRHWAtScreenDelta;
        }
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.RHWLessAtScreenLess)
    {
        if (pStereoData->StereoSettings.dwFlags & STEREO_FAVORSZOVERRHW)
        {
            if (!(pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN))
            {
                //Has not been set yet
                pStereoData->StereoSettings.dwFlags |= STEREO_RHWLESSATSCREEN;
                pStereoData->StereoSettings.fRHWLessAtScreen = ConfigAssistInfo.szMax;
            }
            fRHWAtScreenDelta = (ConfigAssistInfo.szMax - ConfigAssistInfo.szMin) / 100.f;
            pStereoData->StereoSettings.fRHWLessAtScreen += fRHWAtScreenDelta;
            ConfigAssistInfo.szMax += fRHWAtScreenDelta;
        } else
        {
            //Less in reality means more. So closer objects are put at the screen plane.
            if (!(pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN))
            {
                //Has not been set yet
                pStereoData->StereoSettings.dwFlags |= STEREO_RHWLESSATSCREEN;
                pStereoData->StereoSettings.fRHWLessAtScreen = ConfigAssistInfo.rhwMin;
            }
            fRHWAtScreenDelta = (ConfigAssistInfo.rhwMax - ConfigAssistInfo.rhwMin) / 100.f;
            pStereoData->StereoSettings.fRHWLessAtScreen -= fRHWAtScreenDelta;
            ConfigAssistInfo.rhwMin -= fRHWAtScreenDelta;
        }
    }

    if (STEREODATA(StereoSettings.dwFlags) & STEREO_GAMMACORRECTION)
	{
		POLLSTEREOHOTKEY(ConfigAssistInfo.GammaAdjustMore)
		{
			//Gamma adjustment for stereo.
			if (pStereoData->StereoSettings.fStereoGamma < 6.f)
			{
				pStereoData->StereoSettings.fStereoGamma += 0.1f;
				WORD    NewGamma[256 * 3];
				DWORD   i;
				HDC hDC = GetDC(NULL);
				if (hDC)
				{
					WORD  NewVal;
					for (i = 0; i < 256; i++)
					{

						NewVal = (WORD)(ComputeGammaColor (i, pStereoData->StereoSettings.fStereoGamma) << 8); 
						NewGamma[i] = NewVal;
						NewGamma[i+256] = NewVal;
						NewGamma[i+512] = NewVal;
					}
					SetDeviceGammaRamp(hDC, NewGamma); 
					ReleaseDC(NULL,hDC);
				}
			}
		}

		POLLSTEREOHOTKEY(ConfigAssistInfo.GammaAdjustLess)
		{
			//Gamma adjustment for stereo.
			if (pStereoData->StereoSettings.fStereoGamma > 0.5f)
			{
				pStereoData->StereoSettings.fStereoGamma -= 0.1f;
				WORD    NewGamma[256 * 3];
				DWORD   i;
				HDC hDC = GetDC(NULL);
				if (hDC)
				{
					WORD  NewVal;
					for (i = 0; i < 256; i++)
					{

						NewVal = (WORD)(ComputeGammaColor (i, pStereoData->StereoSettings.fStereoGamma) << 8); 
						NewGamma[i] = NewVal;
						NewGamma[i+256] = NewVal;
						NewGamma[i+512] = NewVal;
					}
					SetDeviceGammaRamp(hDC, NewGamma); 
					ReleaseDC(NULL,hDC);
				}
			}
		}
    }

#endif  //STEREO_CONFIG_ASSIST
}

DWORD GetStereoOffset(CSimpleSurface *pSurf)
{
    if (!STEREO_ACTIVATED || !pSurf->isStereo() || pStereoData->dwLastEye != EYE_RIGHT)
        return pSurf->getOffset();
    return pSurf->getOffsetRight();
}

DWORD StereoBltAdjustParameters(SURFINFO &src, SURFINFO &dst, STEREOBLTPASSINFO &StereoBltPass)
{
    if (!STEREO_ACTIVATED)
        return 1;

    if (!dst.pObj)
    {
		//LOG("StereoBltAdjustParameters: destination surface has invalid nvObj");
        //Doesn't have a valid nvObj - bail out
        return 1;
    }
    CSimpleSurface *pDstSurf = dst.pObj->getSimpleSurface();
    if (!pDstSurf)
    {
        //The destination is not a simple surface (texture) - bail out.
        return 1;
    }
    if (!pDstSurf->isStereo())
    {
        //Surface is not stereo - bail out.
        return 1;
    }

    StereoLockSubstituteFlush(); //Will cause recursive blit

    if (src.pObj)
    {
        //Check if the source is a stereo surface
        CSimpleSurface *pSrcSurf = src.pObj->getSimpleSurface();
        if (pSrcSurf && pSrcSurf->isStereo())
        {
            //Some games like Half-life use blit istead of flip. So we don't want to apply stereo twice.
            //Warning!!! This is not going to look correct unless the blit involves full sizes of surfaces.
            //We will check for that even if it isn't clear what to do if this check fails.
            if (src.dwSubRectWidth != pSrcSurf->getWidth() || src.dwSubRectWidth != dst.dwSubRectWidth)
			{
				//LOG("StereoBltAdjustParameters: blt width mismatches");
				nvAssert(0);
			}
            if (src.dwSubRectHeight != pSrcSurf->getHeight() || src.dwSubRectHeight != dst.dwSubRectHeight)
			{
				//LOG("StereoBltAdjustParameters: blt height mismatches");
                nvAssert(0);
			}
            if (StereoBltPass.dwPass)
                src.dwOffset = StereoBltPass.dwSrcOffset;
            else
                StereoBltPass.dwSrcOffset = pSrcSurf->getOffsetRight();
        }
    }
#ifdef  SNAP_SHOT
    else
    {
        //Check for the stereo image display mode.
        if (StereoBltPass.dwPass && StereoBltPass.dwSrcY == NVSTEREO_IMAGE_SIGNATURE)
        {
            //Right eye of still stereo image.
            StereoBltPass.dwPass = 0;
            src.dwSubRectX = src.dwSubRectWidth;
            dst.dwOffset = StereoBltPass.dwDstOffset;
            src.dwOffset = 0;
            return 1;
        } else
        {
            if (StereoBltPass.dwPass && StereoBltPass.dwSrcY == NVSTEREO_IMAGE_SIGNATURE + 1)
            {
                //Right eye of still stereo image.
                StereoBltPass.dwPass = 0;
                src.dwSubRectX = 0;
                dst.dwOffset = StereoBltPass.dwDstOffset;
                src.dwOffset = 0;
                return 1;
            }
        }

        if (src.pLcl)
        {
            LPNVSTEREOIMAGEHEADER pStereoImageHeader = (LPNVSTEREOIMAGEHEADER)((LPBYTE)src.fpVidMem+(src.dwHeight-1)*src.dwPitch);
            if (pStereoImageHeader->dwSignature == NVSTEREO_IMAGE_SIGNATURE
                && pStereoImageHeader->dwHeight == src.dwSubRectHeight
                && pStereoImageHeader->dwWidth == src.dwSubRectWidth)
            {
                src.dwSubRectHeight -= 1;
                src.dwSubRectWidth >>= 1;
                StereoBltPass.dwSrcY = NVSTEREO_IMAGE_SIGNATURE;
                StereoBltPass.dwDstOffset = pDstSurf->getOffsetRight();
                StereoBltPass.dwPass = 1; //We expect the second pass later
                if (pStereoImageHeader->dwSwapEyes)
                {
                    src.dwSubRectX = src.dwSubRectWidth;
                    StereoBltPass.dwSrcY += 1;
                }
                return 2;
            }
        }
    }
#endif  //SNAP_SHOT
    if (StereoBltPass.dwPass)
    {
        StereoBltPass.dwPass = 0;
        dst.dwOffset = StereoBltPass.dwDstOffset;
        return 1;
    }
    StereoBltPass.dwDstOffset = pDstSurf->getOffsetRight();
    StereoBltPass.dwPass = 1; //We expect the second pass later
    return 2;
}

BOOL CreateLocalCopy(LPDDRAWI_DDRAWSURFACE_LCL pSrcLcl, LPDDRAWI_DDRAWSURFACE_LCL& pDstLcl)
{
    LPDDRAWI_DDRAWSURFACE_LCL  pDDSNewLcl;
    LPDDRAWI_DDRAWSURFACE_GBL  pDDSGbl;
    LPDDRAWI_DDRAWSURFACE_MORE pSurfMore;

    if (!(pDDSNewLcl = pDstLcl))
    {
        //Destination local doesn't exist yet.
        if (!(pDDSNewLcl = (LPDDRAWI_DDRAWSURFACE_LCL)AllocIPM( sizeof (DDRAWI_DDRAWSURFACE_LCL)  +
                                                                sizeof (DDRAWI_DDRAWSURFACE_MORE) +
                                                                sizeof (DDRAWI_DDRAWSURFACE_GBL)  +
                                                                sizeof (LPDWORD)                  +
                                                                sizeof (DDRAWI_DDRAWSURFACE_GBL_MORE))))
        {
	        //LOG("CreateLocalCopy");
            //__asm int 3
			nvAssert(0);
            return FALSE;
        }
        pDDSNewLcl->lpSurfMore = (LPDDRAWI_DDRAWSURFACE_MORE)((LPBYTE)pDDSNewLcl + sizeof (DDRAWI_DDRAWSURFACE_LCL));
        pDDSNewLcl->lpGbl = (LPDDRAWI_DDRAWSURFACE_GBL)((LPBYTE)pDDSNewLcl->lpSurfMore + sizeof (DDRAWI_DDRAWSURFACE_MORE)
                                                                                       + sizeof (LPDWORD));
        GET_LPDDRAWSURFACE_GBL_MORE(pDDSNewLcl->lpGbl) = (LPDDRAWI_DDRAWSURFACE_GBL_MORE)((LPBYTE)pDDSNewLcl->lpGbl
                                                                           + sizeof (DDRAWI_DDRAWSURFACE_GBL));
        pDstLcl = pDDSNewLcl;
    }
    pDDSGbl   = pDDSNewLcl->lpGbl;
    pSurfMore = pDDSNewLcl->lpSurfMore;
    //Copy the pDDSLcl content to the brand new allocated local struture.
    *pDDSNewLcl = *pSrcLcl;
    //Restore our pDDSGbl and pSurfMore
    pDDSNewLcl->lpGbl       = pDDSGbl;
    pDDSNewLcl->lpSurfMore  = pSurfMore;
    //Copy the pDDSLcl->lpGbl and pDDSLcl->lpSurfMore content to the brand new allocated local->global structure.
    *pDDSGbl    = *pSrcLcl->lpGbl;
#if 1
    nvAssert (pDDSGbl->lpDD->dwReserved3);
#endif
    *pSurfMore  = *pSrcLcl->lpSurfMore;
    //Copy the GblMore content to the brand new allocated GblMore struture.
    *(GET_LPDDRAWSURFACE_GBL_MORE(pDDSGbl)) = *(GET_LPDDRAWSURFACE_GBL_MORE(pSrcLcl->lpGbl));
    return TRUE;
}

BOOL CreateLockSubstitute(LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl)
{
    LPDDRAWI_DDRAWSURFACE_LCL  pDDSLockLcl;
    LPDDRAWI_DDRAWSURFACE_GBL  pDDSGbl;
    DDHAL_CREATESURFACEDATA CreateSurfaceData;
    DDHAL_DESTROYSURFACEDATA DestroySurfaceData;

    if (!STEREO_ENABLED)
        return FALSE;

    if (pStereoData->pLockSubstituteLcl)
    {
        memset(&DestroySurfaceData, 0, sizeof (DDHAL_DESTROYSURFACEDATA));
        DestroySurfaceData.lpDD = pDDSLcl->lpGbl->lpDD;
        DestroySurfaceData.lpDDSurface = pStereoData->pLockSubstituteLcl;
        DestroySurface32(&DestroySurfaceData);
    }
    if (CreateLocalCopy(pDDSLcl, pStereoData->pLockSubstituteLcl))
    {
        pDDSLockLcl = pStereoData->pLockSubstituteLcl;
        pDDSGbl = pDDSLockLcl->lpGbl;
        //Clean up some not needed stuff
        SET_PNVOBJ (pDDSLockLcl, NULL);
        pDDSGbl->fpVidMem    = 0;
        pDDSGbl->dwReserved1 = 0;
        pDDSLockLcl->ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM;
        //Make sure it won't be interpreted as stereo
        pDDSLockLcl->lpSurfMore->ddsCapsEx.dwCaps2 &= ~DDSCAPS2_STEREOSURFACELEFT;

        DWORD dwSuggestedPitch = pDDSGbl->wWidth * (GET_MODE_BPP() >> 3);
        DWORD dwSaveHeight = (DWORD)pDDSGbl->wHeight;
        if ((DWORD)pDDSGbl->lPitch > dwSuggestedPitch)
        {
            //We need to compensate the pitch difference by increasing the wHeight. Otherwise front buffer
            //locks may cause access to a memory beyond allocated
            pDDSGbl->wHeight = (WORD)((pDDSGbl->lPitch * dwSaveHeight + dwSuggestedPitch - 1)/dwSuggestedPitch);
        }
        memset(&CreateSurfaceData, 0, sizeof (DDHAL_CREATESURFACEDATA));
        CreateSurfaceData.lpDD      = pDDSLcl->lpGbl->lpDD;
        CreateSurfaceData.lplpSList = &pDDSLockLcl;
        CreateSurfaceData.dwSCnt    = 1;
		DWORD rc = CreateSurface32(&CreateSurfaceData);
        if (rc != DDHAL_DRIVER_HANDLED)
		{
	        //LOG("CreateSurface32: result=%x, not DDHAL_DRIVER_HANDLED=%x !",rc,DDHAL_DRIVER_HANDLED);
			__asm int 3
		}
        pDDSGbl->wHeight = (WORD)dwSaveHeight;
        return TRUE;
    } else
        return FALSE;
}

DWORD StereoBlt(LPDDRAWI_DDRAWSURFACE_LCL pSrcLcl, LPDDRAWI_DDRAWSURFACE_LCL pDstLcl, LPRECTL pSrcRect,
                LPRECTL pDstRect, DWORD dwFlags, DWORD dwColor)
{
    DDHAL_BLTDATA   BltData;
    RECTL           SrcRect, DstRect;

    memset(&BltData, 0, sizeof(BltData));
    BltData.lpDD = pDstLcl->lpGbl->lpDD;
#if 1
    nvAssert (pDstLcl->lpGbl->lpDD->dwReserved3);
#endif
    BltData.bltFX.dwSize = sizeof(DDBLTFX);
    BltData.dwFlags = dwFlags;

    if(dwFlags & DDBLT_ROP)
        BltData.bltFX.dwROP  = SRCCOPY;

    if(dwFlags & DDBLT_COLORFILL)
    {
        BltData.bltFX.dwFillColor = dwColor;
    }

    if(dwFlags & DDBLT_KEYSRCOVERRIDE)
    {
        BltData.bltFX.ddckSrcColorkey.dwColorSpaceLowValue =
        BltData.bltFX.ddckSrcColorkey.dwColorSpaceHighValue = dwColor;
    }

    BltData.lpDDSrcSurface = pSrcLcl;
    BltData.lpDDDestSurface = pDstLcl;

    if( pSrcLcl )
    {
        if (!pSrcRect)
        {
            pSrcRect = &SrcRect;
            SrcRect.top     = 0;
            SrcRect.left    = 0;
            SrcRect.bottom  = (LONG)pSrcLcl->lpGbl->wHeight;
            SrcRect.right   = (LONG)pSrcLcl->lpGbl->wWidth;
        }
        BltData.rSrc = *pSrcRect;
    }

    if (!pDstRect)
    {
        pDstRect = &DstRect;
        DstRect.top     = 0;
        DstRect.left    = 0;
        DstRect.bottom  = (LONG)pDstLcl->lpGbl->wHeight;
        DstRect.right   = (LONG)pDstLcl->lpGbl->wWidth;
    }
    BltData.rDest = *pDstRect;

    Blit32(&BltData);

    nvAssert (BltData.ddRVal == DD_OK);

    if(dwFlags & DDBLT_WAIT)
    {
        WaitForIdle (TRUE,FALSE);
    }
    return 0;
}

void InitLockSubstituteBuffer(void)
{
    StereoBlt(0, pStereoData->pLockSubstituteLcl, 0, NULL, DDBLT_COLORFILL | DDBLT_WAIT, COLOR_KEY);
    pStereoData->StereoSettings.dwFlags &= ~STEREO_LOCKINIT;
}

BOOL StereoLockSubstituteFlush(void)
{
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl;

    if (pStereoData->pLastLockedSurface)
    {
        pStereoData->pLastLockedSurface = NULL; //To guarantee it won't go through the same code again (from blit).
        nvAssert (pStereoData->pLockTargetLcl);

        pSurf_gbl = pStereoData->pLockTargetLcl->lpGbl;

        //Match surfaces' lPitches
        ULONG lPitch = pStereoData->pLockTargetLcl->lpGbl->lPitch;
        pStereoData->pLockSubstituteLcl->lpGbl->lPitch = pSurf_gbl->lPitch;
        StereoBlt(pStereoData->pLockSubstituteLcl, pStereoData->pLockTargetLcl,
                  NULL, NULL, DDBLT_ROP | DDBLT_KEYSRCOVERRIDE | DDBLT_WAIT, COLOR_KEY);
        pStereoData->pLockSubstituteLcl->lpGbl->lPitch = lPitch;
        pStereoData->StereoSettings.dwFlags |= STEREO_LOCKINIT;
        return TRUE;
    }
    return FALSE;
}

BOOL StereoLockSubstitute(LPDDHAL_LOCKDATA lpLockData)
{
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl;
    DWORD                       dwLockFlags;
    CNvObject                   *pNvObj;
    CSimpleSurface              *pSurf;

    if (!STEREO_ACTIVATED || !pStereoData->pLockSubstituteLcl)
        return FALSE;

    if (!(pNvObj = GET_PNVOBJ(lpLockData->lpDDSurface)))
        return FALSE;

    if (!(pSurf = pNvObj->getSimpleSurface()) || !pSurf->isStereo())
        return FALSE;

    if (pStereoData->StereoSettings.dwFlags & STEREO_LOCKACTIVE)
    {
        //multiple locks are not allowed
		//LOG("StereoLockSubstitute: multiple lock attempt");
        nvAssert(0);
        return FALSE;
    }

    dwLockFlags = lpLockData->dwFlags;

    if (dwLockFlags & DDLOCK_READONLY)
    {
        //Stereo buffers are shifted in X direction. So an app won't get what it expects.
        //But nothing we can do about it.
        return FALSE;
    }

    if (lpLockData->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_ZBUFFER)
    {
        //Don't handle this for now.
		//LOG("StereoLockSubstitute: can't handle surface with DDSCAPS_ZBUFFER");
        //nvAssert(0); Getting annoying
        return FALSE;
    }

    pSurf_gbl = lpLockData->lpDDSurface->lpGbl;

    if (pStereoData->pLastLockedSurface && (pStereoData->pLastLockedSurface != pSurf))
    {
        //Switching to another surface. We need to flush the previous one.
        nvAssert(0);
        StereoLockSubstituteFlush();
    }

    pStereoData->pLastLockedSurface = pSurf;

    if (global.dwDXRuntimeVersion < 0x0700)
    {
        pStereoData->pLockTargetLcl = (LPDDRAWI_DDRAWSURFACE_LCL)pNvObj->getHandle();
    } else
    {
        //For DX7 and above we have to have a persistent Lcl structure in order to handle
        //delayed lock emulation blits
        if (!CreateLocalCopy(lpLockData->lpDDSurface, pStereoData->pLockTargetLcl))
		{
			//LOG("StereoLockSubstitute: CreateLocalCopy failed");
			//__asm int 3
			nvAssert(0);
		}
    }
    pStereoData->StereoSettings.dwFlags |= STEREO_LOCKCACHEABLE;
    if (lpLockData->lpDDSurface->ddsCaps.dwCaps & (DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE))
    {
        pStereoData->StereoSettings.dwFlags &= ~STEREO_LOCKCACHEABLE;
    }

	if (getDC()->dwAAContextCount >= 1)
    {
        pStereoData->StereoSettings.dwFlags &= ~STEREO_LOCKCACHEABLE;
    }

    if (pSurf_gbl->lPitch != pStereoData->pLockSubstituteLcl->lpGbl->lPitch)
    {
        //Pitch has changed. We need to init surface again.
        //nvAssert(0);
        pStereoData->StereoSettings.dwFlags |= STEREO_LOCKINIT;
    }

    //Our pLockSubstituteLcl surface and the one is being locked might have different pitches
    //We need to adjust for that.

#if 0
	pStereoData->StereoSettings.dwFlags &= ~STEREO_LOCKINIT;
	pStereoData->StereoSettings.dwFlags &= ~STEREO_LOCKCACHEABLE;
    StereoBlt(lpLockData->lpDDSurface, pStereoData->pLockSubstituteLcl, 
		NULL, NULL, DDBLT_ROP | DDBLT_WAIT, 0);
#endif

    //Match surfaces' lPitches
    ULONG lPitch = pStereoData->pLockSubstituteLcl->lpGbl->lPitch;
    pStereoData->pLockSubstituteLcl->lpGbl->lPitch = pSurf_gbl->lPitch;

    if (pStereoData->StereoSettings.dwFlags & STEREO_LOCKINIT)
    {
        //Copy the entire buffer to the Substitute
        //or initialize the Substitute buffer
        //!!! SurfIndex == FRONT_BUFFER conclusion for Rainbow6
        //This application read from Front buffer directly although doing lock for write only.
        InitLockSubstituteBuffer();
    }

    //Swap surfaces' fpVidMems
    FLATPTR fpVidMem = pSurf_gbl->fpVidMem;
    pSurf_gbl->fpVidMem = pStereoData->pLockSubstituteLcl->lpGbl->fpVidMem;
    pStereoData->pLockSubstituteLcl->lpGbl->fpVidMem = fpVidMem;

    pStereoData->pLockSubstituteLcl->lpGbl->lPitch = lPitch;
    pStereoData->StereoSettings.dwFlags |= STEREO_LOCKACTIVE;

    return TRUE;
}

BOOL StereoLockSubstituteRestore(LPDDHAL_UNLOCKDATA lpUnlockData)
{
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl;
    CNvObject                   *pNvObj;
    CSimpleSurface              *pSurf;

    if (!STEREO_ENABLED || !(pStereoData->StereoSettings.dwFlags & STEREO_LOCKACTIVE))
    {
        //Has not been substituted
        return FALSE;
    }

    if (!(pNvObj = GET_PNVOBJ(lpUnlockData->lpDDSurface)))
        return FALSE;

    if (!(pSurf = pNvObj->getSimpleSurface()) || !pSurf->isStereo())
        return FALSE;

    nvAssert(pStereoData->pLastLockedSurface == pSurf);

    pStereoData->StereoSettings.dwFlags &= ~STEREO_LOCKACTIVE;

    pSurf_gbl = lpUnlockData->lpDDSurface->lpGbl;

    //Swap surfaces' fpVidMems back
    FLATPTR fpVidMem = pSurf_gbl->fpVidMem;
#if 0
    //Simple check if anything changed.
    DWORD dwSize = pSurf_gbl->wHeight * pSurf_gbl->lPitch/(sizeof (DWORD));
    DWORD i;
    if (pDriverData->ModeList[pDXShare->dwModeNumber].dwBPP == 16)
    {
        for (i = 0; i < dwSize; i++)
        {
            nvAssert (((DWORD *)fpVidMem)[i] == ((VeryBrightGrey16 << 16) | VeryBrightGrey16));
        }
    } else
    {
        for (i = 0; i < dwSize; i++)
        {
            nvAssert (((DWORD *)fpVidMem)[i] == VeryBrightGrey32);
        }
    }
#endif
    pSurf_gbl->fpVidMem = pStereoData->pLockSubstituteLcl->lpGbl->fpVidMem;
    pStereoData->pLockSubstituteLcl->lpGbl->fpVidMem = fpVidMem;

    if (!(pStereoData->StereoSettings.dwFlags & STEREO_LOCKCACHEABLE))
    {
        //Front buffer has to be flushed immediately
        //nvAssert(0);
        StereoLockSubstituteFlush();
    }

    return TRUE;
}

void StereoFlipNotify(LPDDHAL_FLIPDATA pfd)
{
    if (STEREO_ACTIVATED)
    {
        StereoLockSubstituteFlush();
        pfd->dwFlags &= ~DDFLIP_NOVSYNC;
        BOOL res_ = FALSE;
#ifdef  SNAP_SHOT
        POLLSTEREOHOTKEY(SaveStereoImage)
        {
            SaveStereoImageFile(pfd);
        }
#endif  //SNAP_SHOT
    }
#ifdef	SHOW_EYES
	CNvObject *pObj = GET_PNVOBJ(pfd->lpSurfTarg);
	if (!pObj) 
		return;
	pFrontSurf		= pObj->getSimpleSurface();
#endif	//SHOW_EYES
}

//**********************************************************************************************
/*
 * VertexRegister interfaces
 */

CVertexRegister::CVertexRegister(DWORD dwNumVertices)
{
    m_dwStage = FIRST_EYE;
    m_dwVertexCount = 0;
    m_dwInUseSize = (dwNumVertices + 7) >> 3;

    if (!(m_VertexStorage_Flip = (LPPERVERTEXSTORAGE_FLIP)AllocIPM(dwNumVertices*sizeof(PERVERTEXSTORAGE_FLIP)+m_dwInUseSize)))
    {
        return;
    }
    m_pInUse = (LPBYTE)(m_VertexStorage_Flip + dwNumVertices);
    return;
}

CVertexRegister::~CVertexRegister(void)
{
    FreeIPM(m_VertexStorage_Flip);
}

BOOL CVertexRegister::isInUse(DWORD dwVertex)
{
    DWORD Base = (DWORD)m_pInUse;
    BOOL  res;
    _asm {
        mov  edx, Base
        xor  eax, eax
        mov  ecx, dwVertex
        bt   [edx], ecx
        setc al
        mov  res, eax
    }
    return res;
}

BOOL CVertexRegister::isInUseTag(DWORD dwVertex)
{
    DWORD Base = (DWORD)m_pInUse;
    BOOL  res;
    _asm {
        mov  edx, Base
        xor  eax, eax
        mov  ecx, dwVertex
        bts  [edx], ecx
        setc al
        mov  res, eax
    }
    return res;
}

/************************************************************************************************************
 * Next function behaviour is based on the current stage. If stage is FIRST_EYE the function does nothing
 * and report that. The caller is responsible to fill out the m_VertexStorage_Flip and next time the DoAutomaticStage
 * will take care of everything automatically.
 ************************************************************************************************************/

DWORD CVertexRegister::DoAutomaticStage_Flip(void)
{
    DWORD                   RetVal = 0;
    DWORD                   i;
    LPPERVERTEXSTORAGE_FLIP pSrc;
    LPD3DVALUE              pDest;

    if (m_dwStage != FIRST_EYE)
    {
        //m_VertexStorage_Flip is valid. We can handle this case ourselves.
        RetVal = 1;
        pSrc = m_VertexStorage_Flip;
        if (m_dwStage == RESTORE)
        {
#ifdef  LASER_SIGHT
            if (pStereoData->StereoSettings.dwFlags & STEREO_LASERGETRHWSCALE)
            {
                if (m_dwVertexCount >= 2 && pSrc->pVertex[2] != (pSrc+1)->pVertex[2])
                {
                    LaserSZBase = pSrc->pVertex[2];
                    LaserRHWBase = pSrc->pVertex[3];
                    LaserRHWScale = (LaserRHWBase - (pSrc+1)->pVertex[3])/(LaserSZBase - (pSrc+1)->pVertex[2]);
                    pStereoData->StereoSettings.dwFlags &= ~STEREO_LASERGETRHWSCALE;
                }
            }
#endif  //LASER_SIGHT
            for (i = 0; i < m_dwVertexCount; i++, pSrc++)
            {
                pDest = pSrc->pVertex;
                pDest[0] = pSrc->OrigX;
            }
        } else
        {
            if (pStereoData->dwLastEye == EYE_LEFT)
            {
                //First eye was right
                for (i = 0; i < m_dwVertexCount; i++, pSrc++)
                {
                    pDest = pSrc->pVertex;
                    pDest[0] = pDest[0] - pSrc->XCorrection - pSrc->XCorrection;
                }
            } else
            {
                //First eye was left
                for (i = 0; i < m_dwVertexCount; i++, pSrc++)
                {
                    pDest = pSrc->pVertex;
                    pDest[0] = pDest[0] + pSrc->XCorrection + pSrc->XCorrection;
                }
            }
        }
    } else
        m_dwVertexCount = 0;
    UpdateStage();
    return RetVal;
}

#ifdef  PER_PRIMITIVE_SYNC
void StereoSync(void)
{
	if (!STEREO_ACTIVATED)
		return;

#ifdef	SHOW_EYES
	if (pFrontSurf)
	{
		ShowEyes();
	}
#endif	//SHOW_EYES

    WaitForIdle (TRUE,FALSE);

#ifdef	SHOW_EYES
	__asm int 3
#endif	//SHOW_EYES
}
#endif  //PER_PRIMITIVE_SYNC

#ifdef  PARTIALRENDERING
DWORD PrimitiveStat[5] = {0, 0, 0, 0x10000000, 0x10000000};
#endif  //PARTIALRENDERING

/*********************************************************************************
 * Below are the Stereo DP2 handlers and Stereo Eye Image calculation functions
 * for all possible cases. The all use the same template defined in the StereoFunc_i.cpp.
 * Particular implementation nuances are specified by the special defines.
 *********************************************************************************/

/*********************************************************************************
 * D3DDP2OP_POINTS
 *********************************************************************************/
#define POINT
#define STEREO_EYE_FUNCTION_FLIP    nvDP2Points_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2Points_Stereo_Flip

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_INDEXEDLINELIST
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2IndexedLineList_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2IndexedLineList_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2IndexedLineList_Check_RHW
#define INDEX
#define LINE

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_INDEXEDTRIANGLELIST
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2IndexedTriangleList_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2IndexedTriangleList_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2IndexedTriangleList_Check_RHW
#define INDEX

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_LINELIST
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2LineList_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2LineList_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2LineList_Check_RHW
#define LINE
#define START_VERTEX

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_LINESTRIP
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2LineStrip_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2LineStrip_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2LineStrip_Check_RHW
#define LINE
#define START_VERTEX
#define STRIP

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_INDEXEDLINESTRIP
 *********************************************************************************/
#define NOT_IMPLEMENTED
#define STEREO_EYE_FUNCTION_FLIP    nvDP2IndexedLineStrip_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2IndexedLineStrip_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2IndexedLineStrip_Check_RHW
#define INDEX

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_TRIANGLELIST
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2TriangleList_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2TriangleList_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2TriangleList_Check_RHW

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_TRIANGLESTRIP
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2TriangleStrip_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2TriangleStrip_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2TriangleStrip_Check_RHW
#define STRIP
#define START_VERTEX

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_INDEXEDTRIANGLESTRIP
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2IndexedTriangleStrip_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2IndexedTriangleStrip_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2IndexedTriangleStrip_Check_RHW
#define INDEX
#define START_VERTEX
#define STRIP

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_TRIANGLEFAN
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2TriangleFan_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2TriangleFan_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2TriangleFan_Check_RHW
#define FAN
#define START_VERTEX

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_INDEXEDTRIANGLEFAN
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2IndexedTriangleFan_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2IndexedTriangleFan_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2IndexedTriangleFan_Check_RHW
#define INDEX
#define START_VERTEX
#define FAN

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_TRIANGLEFAN_IMM
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2TriangleFanImm_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2TriangleFanImm_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2TriangleFanImm_Check_RHW
#define FAN
#define ADVANCE                 D3DHAL_DP2TRIANGLEFAN_IMM
#define ALIGN

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_LINELIST_IMM
 *********************************************************************************/
#define NOT_IMPLEMENTED
#define STEREO_EYE_FUNCTION_FLIP    nvDP2LineListImm_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2LineListImm_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2LineListImm_Check_RHW

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_INDEXEDTRIANGLELIST2
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2IndexedTriangleList2_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2IndexedTriangleList2_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2IndexedTriangleList2_Check_RHW
#define INDEX2
#define START_VERTEX

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_INDEXEDLINELIST2
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2IndexedLineList2_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2IndexedLineList2_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2IndexedLineList2_Check_RHW
#define INDEX
#define START_VERTEX
#define LINE

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_CLEAR
 *********************************************************************************/
HRESULT nvDP2Clear_Stereo_Flip (NV_DP2FUNCTION_ARGLIST)
{
    HRESULT RetVal;
    LPD3DHAL_DP2CLEAR   pDp2ClearData = (LPD3DHAL_DP2CLEAR)((*ppCommands)+1);
    LPD3DHAL_DP2COMMAND pSaveCommandsPtr = *ppCommands;

    StereoLockSubstituteFlush();

#ifdef  PARTIALRENDERING
    PrimitiveStat[0] = PrimitiveStat[1];
    PrimitiveStat[1] = 0;
    pDp2ClearData->dwFlags |= D3DCLEAR_TARGET;
    pDp2ClearData->dwFillColor = 0; //very very black
#endif  //PARTIALRENDERING

#ifdef  PER_PRIMITIVE_SYNC
    DWORD   dwFlags, dwFillColor;   //To save originals
    dwFlags = pDp2ClearData->dwFlags;
    pDp2ClearData->dwFlags |= D3DCLEAR_TARGET;
    dwFillColor = pDp2ClearData->dwFillColor;
    pDp2ClearData->dwFillColor = 0; //very very black
    SetupStereoContext(pContext);
    RetVal = (*(nvDP2SetFuncs_Orig[D3DDP2OP_CLEAR]))(pContext,
                                                     ppCommands,
                                                     pCommandBufferEnd,
                                                     pdwDP2RStates,
                                                     dwDP2Flags);
    StereoSync();
#ifndef ONE_EYE
    AlternateStereoContext(pContext);
#ifndef NULL_RIGHT_EYE_
    //Switch to the other eye and clear once again
    *ppCommands = pSaveCommandsPtr; //Restore it for the second pass.
    RetVal = (*(nvDP2SetFuncs_Orig[D3DDP2OP_CLEAR]))(pContext,
                                                     ppCommands,
                                                     pCommandBufferEnd,
                                                     pdwDP2RStates,
                                                     dwDP2Flags);
    StereoSync();
#endif  //NULL_RIGHT_EYE
#endif  //ONE_EYE
    pDp2ClearData->dwFlags = dwFlags;
    pDp2ClearData->dwFillColor = dwFillColor;
    return RetVal;
#else   //PER_PRIMITIVE_SYNC

    if (pStereoData->StereoSettings.PartialClearMode == DO_A_FULL_CLEAR)
    {
        LPRECT pRect = pDp2ClearData->Rects;
        LPDDHALMODEINFO lpModeInfo = &pDriverData->ModeList[pDXShare->dwModeNumber];
        pRect->top = 0;
        pRect->left = 0;
        pRect->right = lpModeInfo->dwWidth;
        pRect->bottom = lpModeInfo->dwHeight;
    }

#ifdef  DEBUG
#if 0
    nvAssert ((*ppCommands)->wPrimitiveCount == 1);
    LPRECT pRect = pDp2ClearData->Rects;
    LPDDHALMODEINFO lpModeInfo = &pDriverData->ModeList[pDXShare->dwModeNumber];
    if (pRect->top || pRect->left || (DWORD)pRect->bottom != lpModeInfo->dwHeight
       || (DWORD)pRect->right != lpModeInfo->dwWidth)
        nvAssert(0);
    {
        pRect->top = 0;
        pRect->left = 0;
        pRect->right = lpModeInfo->dwWidth;
        pRect->bottom = lpModeInfo->dwHeight;
    }
#endif
#endif  //DEBUG

    SetupStereoContext(pContext);
    RetVal = (*(nvDP2SetFuncs_Orig[D3DDP2OP_CLEAR]))(pContext,
                                                     ppCommands,
                                                     pCommandBufferEnd,
                                                     pdwDP2RStates,
                                                     dwDP2Flags);
    *ppCommands = pSaveCommandsPtr; //Restore it for the second pass.
    //Switch to the other eye and clear once again
    AlternateStereoContext(pContext);
    RetVal = (*(nvDP2SetFuncs_Orig[D3DDP2OP_CLEAR]))(pContext,
                                                     ppCommands,
                                                     pCommandBufferEnd,
                                                     pdwDP2RStates,
                                                     dwDP2Flags);
#if 0
    WaitForIdle (TRUE,FALSE);
#endif
    return RetVal;
#endif  //PER_PRIMITIVE_SYNC
}

typedef struct PrimTypeToStereoDP2_S 
{
	PSTEREOEYEFUNC      pStereoEyeFunc;
	PSTEREORHWFUNC      pStereoRHWFunc;
} PRIMTYPETOSTEREODP2, *LPPRIMTYPETOSTEREODP2;

typedef struct PrimTypeToStereoDP2Index_S 
{
	PSTEREOEYEFUNCINDEX pStereoEyeFuncIndex;
	PSTEREORHWFUNCINDEX pStereoRHWFuncIndex;
} PRIMTYPETOSTEREODP2INDEX, *LPPRIMTYPETOSTEREODP2INDEX;

PRIMTYPETOSTEREODP2 PrimTypeToStereoDP2[] = {
	{ NULL,											NULL },
	{ nvDP2Points_StereoEye_Flip,					NULL },
	{ nvDP2LineList_StereoEye_Flip,					nvDP2LineList_Check_RHW },
	{ nvDP2LineStrip_StereoEye_Flip,				nvDP2LineStrip_Check_RHW },
	{ nvDP2TriangleList_StereoEye_Flip,				nvDP2TriangleList_Check_RHW },
	{ nvDP2TriangleStrip_StereoEye_Flip,			nvDP2TriangleStrip_Check_RHW },
	{ nvDP2TriangleFan_StereoEye_Flip,				nvDP2TriangleFan_Check_RHW }
};

PRIMTYPETOSTEREODP2INDEX PrimTypeToStereoDP2Index[] = {
	{ NULL,											NULL },
	{ (PSTEREOEYEFUNCINDEX)nvDP2Points_StereoEye_Flip,					NULL },
	{ nvDP2IndexedLineList_StereoEye_Flip,			nvDP2IndexedLineList_Check_RHW },
	{ nvDP2IndexedLineStrip_StereoEye_Flip,			nvDP2IndexedLineStrip_Check_RHW },
	{ nvDP2IndexedTriangleList2_StereoEye_Flip,		nvDP2IndexedTriangleList2_Check_RHW },
	{ nvDP2IndexedTriangleStrip_StereoEye_Flip,		nvDP2IndexedTriangleStrip_Check_RHW },
	{ nvDP2IndexedTriangleFan_StereoEye_Flip,		nvDP2IndexedTriangleFan_Check_RHW }
};

/*********************************************************************************
 * D3DDP2OP_DRAWPRIMITIVE
 *********************************************************************************/
#define DRAWPRIMITIVE
#define STEREO_EYE_FUNCTION_FLIP    nvDP2DrawPrimitive_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2DrawPrimitive_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2DrawPrimitive_Check_RHW
#define START_VERTEX

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_DRAWINDEXEDPRIMITIVE
 *********************************************************************************/
#define DRAWPRIMITIVE
#define STEREO_EYE_FUNCTION_FLIP    nvDP2DrawIndexedPrimitive_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2DrawIndexedPrimitive_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2DrawIndexedPrimitive_Check_RHW
#define INDEX
#define START_VERTEX

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DNTDP2OP_CLIPPEDTRIANGLEFAN
 *********************************************************************************/
#define NOT_IMPLEMENTED
#define STEREO_EYE_FUNCTION_FLIP    nvDP2ClippedTriangleFan_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2ClippedTriangleFan_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2ClippedTriangleFan_Check_RHW
#define START_VERTEX

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_DRAWPRIMITIVE2
 *********************************************************************************/
#define DRAWPRIMITIVE
#define STEREO_EYE_FUNCTION_FLIP    nvDP2DrawPrimitive2_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2DrawPrimitive2_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2DrawPrimitive2_Check_RHW

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_DRAWINDEXEDPRIMITIVE2
 *********************************************************************************/
#define DRAWPRIMITIVE
#define STEREO_EYE_FUNCTION_FLIP    nvDP2DrawIndexedPrimitive2_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2DrawIndexedPrimitive2_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2DrawIndexedPrimitive2_Check_RHW
#define INDEX

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DNTDP2OP_DRAWRECTSURFACE
 *********************************************************************************/
#define NOT_IMPLEMENTED
#define STEREO_EYE_FUNCTION_FLIP    nvDP2DrawRectSurface_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2DrawRectSurface_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2DrawRectSurface_Check_RHW
#define START_VERTEX

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DNTDP2OP_DRAWTRISURFACE
 *********************************************************************************/
#define NOT_IMPLEMENTED
#define STEREO_EYE_FUNCTION_FLIP    nvDP2DrawTriSurface_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2DrawTriSurface_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2DrawTriSurface_Check_RHW
#define START_VERTEX

#include "StereoFunc_i.cpp"

nvDP2FunctionTable nvDP2SetFuncs_Stereo_Flip =
{
    NULL,                                   //   0  invalid
    nvDP2Points_Stereo_Flip,                //   1  D3DDP2OP_POINTS
    nvDP2IndexedLineList_Stereo_Flip,       //   2  D3DDP2OP_INDEXEDLINELIST
    nvDP2IndexedTriangleList_Stereo_Flip,   //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    NULL,                                   //   4  invalid
    NULL,                                   //   5  invalid
    NULL,                                   //   6  invalid
    NULL,                                   //   7  invalid
    NULL,                                   //   8  D3DDP2OP_RENDERSTATE
    NULL,                                   //   9  invalid
    NULL,                                   //  10  invalid
    NULL,                                   //  11  invalid
    NULL,                                   //  12  invalid
    NULL,                                   //  13  invalid
    NULL,                                   //  14  invalid
    nvDP2LineList_Stereo_Flip,              //  15  D3DDP2OP_LINELIST
    nvDP2LineStrip_Stereo_Flip,             //  16  D3DDP2OP_LINESTRIP
    nvDP2IndexedLineStrip_Stereo_Flip,      //  17  D3DDP2OP_INDEXEDLINESTRIP
    nvDP2TriangleList_Stereo_Flip,          //  18  D3DDP2OP_TRIANGLELIST
    nvDP2TriangleStrip_Stereo_Flip,         //  19  D3DDP2OP_TRIANGLESTRIP
    nvDP2IndexedTriangleStrip_Stereo_Flip,  //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    nvDP2TriangleFan_Stereo_Flip,           //  21  D3DDP2OP_TRIANGLEFAN
    nvDP2IndexedTriangleFan_Stereo_Flip,    //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    nvDP2TriangleFanImm_Stereo_Flip,        //  23  D3DDP2OP_TRIANGLEFAN_IMM
    nvDP2LineListImm_Stereo_Flip,           //  24  D3DDP2OP_LINELIST_IMM
    NULL,                                   //  25  D3DDP2OP_TEXTURESTAGESTATE
    nvDP2IndexedTriangleList2_Stereo_Flip,  //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    nvDP2IndexedLineList2_Stereo_Flip,      //  27  D3DDP2OP_INDEXEDLINELIST2
    NULL,                                   //  28  D3DDP2OP_VIEWPORTINFO
    NULL,                                   //  29  D3DDP2OP_WINFO
    NULL,                                   //  30  D3DDP2OP_SETPALETTE
    NULL,                                   //  31  D3DDP2OP_UPDATEPALETTE
    NULL,                                   //  32  D3DDP2OP_ZRANGE
    NULL,                                   //  33  D3DDP2OP_SETMATERIAL
    NULL,                                   //  34  D3DDP2OP_SETLIGHT
    NULL,                                   //  35  D3DDP2OP_CREATELIGHT
    NULL,                                   //  36  D3DDP2OP_SETTRANSFORM
    NULL,                                   //  37  D3DDP2OP_EXT
    NULL,                                   //  38  D3DDP2OP_TEXBLT
    NULL,                                   //  39  D3DDP2OP_STATESET
    NULL,                                   //  40  D3DDP2OP_SETPRIORITY
    NULL,                                   //  41  D3DDP2OP_SETRENDERTARGET
    nvDP2Clear_Stereo_Flip,                 //  42  D3DDP2OP_CLEAR
    NULL,                                   //  43  D3DDP2OP_SETTEXLOD
    NULL,                                   //  44  D3DDP2OP_SETCLIPPLANE
    NULL,                                   //  45  D3DDP2OP_CREATEVERTEXSHADER
    NULL,                                   //  46  D3DDP2OP_DELETEVERTEXSHADER
    NULL,                                   //  47  D3DDP2OP_SETVERTEXSHADER
    NULL,                                   //  48  D3DDP2OP_SETVERTEXSHADERCONST
    NULL,                                   //  49  D3DDP2OP_SETSTREAMSOURCE
    NULL,                                   //  50  D3DNTDP2OP_SETSTREAMSOURCEUM
    NULL,                                   //  51  D3DDP2OP_SETINDICES
    nvDP2DrawPrimitive_Stereo_Flip,         //  52  D3DDP2OP_DRAWPRIMITIVE
    nvDP2DrawIndexedPrimitive_Stereo_Flip,  //  53  D3DDP2OP_DRAWINDEXEDPRIMITIVE
    NULL,                                   //  54  D3DDP2OP_CREATEPIXELSHADER
    NULL,                                   //  55  D3DDP2OP_DELETEPIXELSHADER
    NULL,                                   //  56  D3DDP2OP_SETPIXELSHADER
    NULL,                                   //  57  D3DNTDP2OP_SETPIXELSHADERCONST
    nvDP2ClippedTriangleFan_Stereo_Flip,    //  58  D3DNTDP2OP_CLIPPEDTRIANGLEFAN
    nvDP2DrawPrimitive2_Stereo_Flip,        //  59  D3DNTDP2OP_DRAWPRIMITIVE2
    nvDP2DrawIndexedPrimitive2_Stereo_Flip, //  60  D3DNTDP2OP_DRAWINDEXEDPRIMITIVE2
    nvDP2DrawRectSurface_Stereo_Flip,       //  61  D3DNTDP2OP_DRAWRECTSURFACE
    nvDP2DrawTriSurface_Stereo_Flip,        //  62  D3DNTDP2OP_DRAWTRISURFACE
    NULL,                                   //  63  D3DDP2OP_VOLUMEBLT
    NULL,                                   //  64  D3DDP2OP_BUFFERBLT
    NULL
};

nvDP2FunctionTable nvDP2SetFuncs_Orig = {NULL};

#endif  //STEREO_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvSurface.cpp ===
//**************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
#include "nvprecomp.h"

//****************************************************************************
//****************************************************************************
//****************************************************************************
//**  CSimpleSurface *********************************************************
//****************************************************************************
//****************************************************************************
//****************************************************************************

// convert from heap location to context dma
DWORD g_adwSurfaceContextDMA[9] =
{
    /* undefined       */ 0,
    /* HEAP_VID = 0x01 */ NV_CONTEXT_DMA_VID,
    /* HEAP_AGP = 0x02 */ NV_CONTEXT_DMA_AGP_OR_PCI,
    /* undefined       */ 0,
    /* HEAP_PCI = 0x04 */ NV_CONTEXT_DMA_AGP_OR_PCI,
    /* undefined       */ 0,
    /* undefined       */ 0,
    /* undefined       */ 0,
    /* HEAP_SYS = 0x08 */ NV_CONTEXT_DMA_NONE
};

// helper function
inline DWORD nvGetOffsetFromLinear(DWORD dwLinearAddress)
{
    NV_CFGEX_GET_AGP_OFFSET_PARAMS addr;

    addr.linaddr = (void*)dwLinearAddress;
    NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_GET_AGP_OFFSET, &addr, sizeof(addr));
    return addr.offset;
}

//****************************************************************************
// CSimpleSurface::isBusy
//

BOOL CSimpleSurface::isBusy (void) const
{
    dbgTracePush ("CSimpleSurface::isBusy");

    // check shadow
    if (getDC()->pRefCount->readShadow() >= m_dwRetireDate) {
        dbgTracePop();
        return FALSE;
    }

    // read HW and recheck
    if (getDC()->pRefCount->read() >= m_dwRetireDate) {
        dbgTracePop();
        return FALSE;
    }

    // return that the surface is busy
    dbgTracePop();
    return TRUE;
}

//****************************************************************************
// CSimpleSurface::reset
//
// surface is lost - tag as such

void CSimpleSurface::reset
(
    void
)
{
    dbgTracePush ("CSimpleSurface[%08x]::reset()",this);
    // disown memory
    disown();
    dbgTracePop();
}

//****************************************************************************
// CSimpleSurface::own
//
// let surface own a piece of memory that is allocated by someone else
//  unless explicitly tagged as a non-owner, the surface will be freed
//  at destroy time.

void CSimpleSurface::own
(
    DWORD dwAddress,
    DWORD dwPitch,
    DWORD dwHeight,
    DWORD dwHeapLocation,
    BOOL  bOwnMemory
)
{
    // tell world
    dbgTracePush ("CSimpleSurface[%08x]::own(dwAddress=%08x,dwPitch=%08x,dwH=%08x,dwHeapLoc=%x,bOwnMem=%d)",
                  this,dwAddress,dwPitch,dwHeight,dwHeapLocation,bOwnMemory);

    // assign
    m_dwAddress    = dwAddress;
    m_dwPitch      = dwPitch;
    m_dwHeight     = dwHeight;
    m_dwFlags     &= ~HEAP_LOCATION_MASK;
    m_dwFlags     |= dwHeapLocation;
    m_dwRetireDate = 0;
    if (bOwnMemory) m_dwFlags &= ~FLAG_DONOTOWNMEMORY;
               else m_dwFlags |= FLAG_DONOTOWNMEMORY;

    switch (getHeapLocation())
    {
        case HEAP_VID:
            m_dwOffset = m_dwAddress - VIDMEM_ADDR(pDriverData->BaseAddress);
            break;
        case HEAP_AGP:
#ifdef NV_AGP
            m_dwOffset = nvGetOffsetFromLinear(m_dwAddress);
            DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "CSimpleSurface::Own: offset of AGP address %08x is %08x", m_dwAddress, m_dwOffset);
#else
            m_dwOffset = AGPMEM_OFFSET(m_dwAddress);
#endif
            break;
        case HEAP_PCI:
#ifdef WINNT // WINNT Temp Hack
        if (!getDC()->nvD3DTexHeapData.dwBase)
            m_dwOffset = m_dwAddress - getDC()->nvPusher.getBase();
        else
#endif // WINNT Temp Hack
            m_dwOffset = m_dwAddress - getDC()->nvD3DTexHeapData.dwBase;
            break;
        case HEAP_SYS:
            m_dwOffset = m_dwAddress;
            break;
        default:
            DPF ("unknown context");
            dbgD3DError();
            break;
    }

    dbgTracePop();
}

//****************************************************************************
// CSimpleSurface::disown
//
// remove surface ownership

void CSimpleSurface::disown
(
    void
)
{
    dbgTracePush ("CSimpleSurface[%08x]::disown()",this);
    // tag as invalid
    m_dwAddress = 0;
    m_dwFlags  &= ~HEAP_LOCATION_MASK;
    dbgTracePop();
}

//****************************************************************************
// CSimpleSurface::hwUnlock
//

void CSimpleSurface::hwUnlock
(
    void
)
{
    dbgTracePush ("CSimpleSurface::hwUnlock");
    // write reference count into push buffer and keep
    //  the value. HW has to reach this point before CPU can
    //  get lock access

    //added a check for surfaces that the HW could actually touch
    //should we actually check each surface instead of calling HWUnlock?
    //HMH

    if (hwCanRead() || hwCanWrite()) {
        m_dwRetireDate = getDC()->pRefCount->inc (CReferenceCount::INC_LAZY);
    }
    dbgTracePop();
}

//****************************************************************************
// CSimpleSurface::cpuLock
//

void CSimpleSurface::cpuLock
(
    DWORD //dwAccess
)
{
    DDSTARTTICK(SURF7_SPINLOCK);
    dbgTracePush ("CSimpleSurface::cpuLock");

    //The next check has been removed because looks like the only situation
    //we used it for was for a SystemMemorySurface artificially created in
    //CreateSurfaceEx. Ironically that is exactly the case where we need
    //synchronization now. Otherwise we pull a chair from under the blits
    //that are still in progress when the surface is being destroyed. Andrei O.
#if 1
    // if the surface is not touchable by HW, return immediately
    //
    //reenabled due to change in hwCanRead to reflect true value for Dynamic ContextDMAs
    //
    //note that hwCanWrite is currently redundant
    //
    //note also that this is simply an optimization.  surfaces that the HW can't touch
    //shouldn't be effected by HWLock/HWUnlock
    //
    // HMH
    if (!hwCanRead() && !hwCanWrite()) {
        DDENDTICK(SURF7_SPINLOCK);
        dbgTracePop();
        return;
    }
#endif

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        // if the channel's been destroyed, then everything is retired by definition
        DDENDTICK(SURF7_SPINLOCK);
        dbgTracePop();
        return;
    }

    // this is needed to prevent hangs when returning from a full-screen DOS box
    // waiting for a notifier with the FIFO in this state guarantees a hang
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        DPF("CSimpleSurface::cpuLock: Early exit due to DosOccurred flag");
        dbgTracePop();
        DDENDTICK(SURF7_SPINLOCK);
        return;
    }

    // spin until surface is unlocked by HW
    getDC()->pRefCount->wait (CReferenceCount::WAIT_PREEMPTIVE, m_dwRetireDate);

    dbgTracePop();
    DDENDTICK(SURF7_SPINLOCK);

 }

//****************************************************************************
// CSimpleSurface::swap
//
// swap surface pointers

void CSimpleSurface::swap
(
    CSimpleSurface* pSurface
)
{
    dbgTracePush ("CSimpleSurface[%08x]::swap(pSurface=%08x)",this,pSurface);

    // sanity check
    assert (this);
    assert (isValid());
    assert (pSurface);
    assert (pSurface->isValid());

    NV_SWAP_1 (m_dwAddress,      pSurface->m_dwAddress);
    NV_SWAP_1 (m_dwOffset,       pSurface->m_dwOffset);
    NV_SWAP_1 (m_dwFormat,       pSurface->m_dwFormat);
    NV_SWAP_1 (m_dwBPP,          pSurface->m_dwBPP);
    NV_SWAP_1 (m_dwBPPRequested, pSurface->m_dwBPPRequested);
    NV_SWAP_1 (m_dwWidth,        pSurface->m_dwWidth);
    NV_SWAP_1 (m_dwHeight,       pSurface->m_dwHeight);
    NV_SWAP_1 (m_dwDepth,        pSurface->m_dwDepth);
    NV_SWAP_1 (m_dwPitch,        pSurface->m_dwPitch);
    NV_SWAP_1 (m_dwFourCC,       pSurface->m_dwFourCC);
    NV_SWAP_1 (m_dwFlags,        pSurface->m_dwFlags);
    NV_SWAP_1 (m_dwRetireDate,   pSurface->m_dwRetireDate);

    dbgTracePop();
}

//****************************************************************************
// CSimpleSurface::create
//
// creates a surface in one of the the allowed heaps based on preference.

BOOL CSimpleSurface::create
(
    DWORD dwPitch,
    DWORD dwHeight,
    DWORD dwDepth,
    DWORD dwBPPGranted,
    DWORD dwAllowedHeaps,
    DWORD dwPreferredHeap,
    DWORD dwAllocFlags
#ifdef CAPTURE
   ,DWORD dwUsageKind  // CAPTURE_SURFACE_KIND_xxx
#endif
)
{
#ifdef DEBUG
    // just so we can see what was asked for when debugging
    DWORD dwOriginalAllowedHeaps  = dwAllowedHeaps;
    DWORD dwOriginalPreferredHeap = dwPreferredHeap;
#endif

    // tell world
    dbgTracePush ("CSimpleSurface[%08x]::create(dwPitch=%08x,dwHt=%08x,dwDp=%08x,dwAllHeaps=%x,dwPrefHeap=%x,dwFlags=%x)",
                 this, dwPitch, dwHeight, dwDepth, dwAllowedHeaps, dwPreferredHeap, dwAllocFlags);

    DWORD dwSize = dwPitch * dwHeight * dwDepth;

    // Allow for a possible ZERO sized surface
    if (!dwSize) {
        // complain
        DPF ("CSimpleSurface::create: dwSize == 0");
        dbgD3DError();
        // tag surface as invalid
        m_dwAddress = 0;
        dbgTracePop();
        return (FALSE);
    }

    // retire surface (since it is about to exist)
    m_dwRetireDate = 0;

    // no specific preference would start with video memory
    if (dwPreferredHeap == HEAP_NOWHERE) {
        dwPreferredHeap = HEAP_VID;
    }

    // if we require tiled memory - override to only allow vid heap
    if (dwAllocFlags & ALLOCATE_TILED) {
        dwAllowedHeaps  = HEAP_VID;
        dwPreferredHeap = HEAP_VID;
    }

    // suppress video memory allocation all together if it is overidden
    //  by the registy
    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_VIDEOTEXTUREENABLE_MASK) == D3D_REG_VIDEOTEXTUREENABLE_DISABLE)
    {
        dwAllowedHeaps &= ~HEAP_VID;
        if (!dwAllowedHeaps) dwAllowedHeaps = HEAP_AGP | HEAP_PCI;
    }
#if 0 // moved
    else
    {
        // override the preference to the AGP heap if
        //  - it would be faster
        //  - it is allowed
        //  - and the preference indicated the slower option
        if ((global.dwPerformanceStrategy & PS_TEXTURE_PREFER_AGP)
         && ((dwAllowedHeaps & (HEAP_VID | HEAP_AGP)) == (HEAP_VID | HEAP_AGP))
         && (dwPreferredHeap == HEAP_VID))
        {
            // override to agp
            dwPreferredHeap = HEAP_AGP;
        }
    }
#endif

    m_dwAllocFlags = dwAllocFlags;

    // try to allocate in all allowed memory heaps
    while (dwAllowedHeaps)
    {
        // video
        if (dwAllowedHeaps & dwPreferredHeap & HEAP_VID)
        {
            DWORD dwStatus, dwType;

            if (dwAllocFlags & ALLOCATE_TILED)
            {
                dwType = (dwAllocFlags & ALLOCATE_AS_ZBUFFER_UNC) ?
                             TYPE_DEPTH :
                             ((dwAllocFlags & ALLOCATE_AS_ZBUFFER_CMP) ?
                                 ((dwBPPGranted == 2) ?
                                     TYPE_DEPTH_COMPR16 :
                                     TYPE_DEPTH_COMPR32) :
                                 TYPE_IMAGE);
#ifdef WINNT
                NVHEAP_ALLOC_TILED (dwStatus, m_dwOffset, dwPitch, dwHeight, dwType);
                m_dwAddress = VIDMEM_ADDR(m_dwOffset);
#else  // !WINNT
                NVHEAP_ALLOC_TILED (dwStatus, m_dwAddress, dwPitch, dwHeight, dwType);
#endif // !WINNT
#ifdef DEBUG_SURFACE_PLACEMENT
                m_dwRMAllocFlags = dwType;
#endif
                nvAssert (dwStatus == 0);
            }

            else
            {
                dwType = (dwAllocFlags & ALLOCATE_AS_ZBUFFER_UNC) ?
                             TYPE_DEPTH :
                             ((dwAllocFlags & ALLOCATE_AS_ZBUFFER_CMP) ?
                                 ((dwBPPGranted == 2) ?
                                     TYPE_DEPTH_COMPR16 :
                                     TYPE_DEPTH_COMPR32) :
                                 TYPE_TEXTURE);
#ifdef WINNT
                NVHEAP_ALLOC (dwStatus, m_dwOffset, dwSize, dwType);
                m_dwAddress = VIDMEM_ADDR(m_dwOffset);
#else
                NVHEAP_ALLOC (dwStatus, m_dwAddress, dwSize, dwType);
#endif // WINNT
#ifdef DEBUG_SURFACE_PLACEMENT
                m_dwRMAllocFlags = dwType;
#endif
            }

            if (dwStatus == 0) {
                // increment count of video memory surfaces allocated.
                pDriverData->DDrawVideoSurfaceCount++;
                m_dwPitch     = dwPitch;
                m_dwHeight    = dwHeight;
                m_dwDepth     = dwDepth;
#ifndef WINNT
                m_dwOffset    = m_dwAddress - pDriverData->BaseAddress;
#endif // WINNT
                m_dwFlags    &= ~HEAP_LOCATION_MASK;
                m_dwFlags    |= HEAP_VID;
                m_dwFlags    &= ~FLAG_TILED;
                m_dwFlags    |= (dwAllocFlags & ALLOCATE_TILED)      ? FLAG_TILED   : 0;
                m_dwFlags    |= (dwAllocFlags & ALLOCATE_AS_ZBUFFER) ? FLAG_ZBUFFER : 0;

#ifdef DEBUG
                DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"Vid Surface Alloc: Address:%08x Size:%08x\n",m_dwAddress,dwSize);
#endif

#ifdef CAPTURE
                if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                    CAPTURE_SURFACE_ALLOC surf;
                    surf.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                    surf.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                    surf.dwExtensionID        = CAPTURE_XID_SURFACE_ALLOC;
                    surf.dwCtxDMAHandle       = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;
                    surf.dwOffset             = m_dwOffset;
                    surf.dwSize               = getSize();
                    surf.dwAlignment          = 0;
                    surf.dwType               = (dwAllocFlags & ALLOCATE_AS_ZBUFFER) ? CAPTURE_SURFACE_TYPE_ZETA : CAPTURE_SURFACE_TYPE_NORMAL;
                    surf.dwKind               = dwUsageKind;
                    surf.dwSurfaceType        = getFormat();
                    surf.dwIntendedPitch      = dwPitch;
                    surf.dwIntendedHeight     = dwHeight;
                    captureLog (&surf,sizeof(surf));
                }
#endif
                dbgTracePop();
                return (TRUE);
            }

#ifdef DEBUG
                DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"Vid Surface Alloc Failed: Size:%08x\n",dwSize);
#endif
            // fail - don't try again
            DPF_LEVEL(NVDBG_LEVEL_INFO,"CSimpleSurface::create: Surface in VID failed");
            dwAllowedHeaps &= ~HEAP_VID;
        }

        // agp
        if (dwAllowedHeaps & dwPreferredHeap & HEAP_AGP)
        {
            if (pDriverData->GARTLinearBase)
            {
                // On AGP, allocate call DDRAW to allocate the AGP memory.
                m_dwAddress = (DWORD)nvAGPAlloc(dwSize);
                if (m_dwAddress != ERR_DXALLOC_FAILED)
                {
#ifdef NV_AGP
                    m_dwOffset   = nvGetOffsetFromLinear(m_dwAddress);
                    DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "CSimpleSurface::Create: offset of AGP address %08x is %08x", m_dwAddress, m_dwOffset);
#else
                    // at this point m_dwAddress is actually an offset
                    m_dwAddress  = AGPMEM_ADDR(m_dwAddress);
                    m_dwOffset   = AGPMEM_OFFSET(m_dwAddress);
#endif
                    m_dwPitch    = dwPitch;
                    m_dwHeight   = dwHeight;
                    m_dwDepth    = dwDepth;
                    m_dwFlags   &= ~HEAP_LOCATION_MASK;
                    m_dwFlags   |= HEAP_AGP;
                    m_dwFlags   &= ~FLAG_TILED;
#ifdef DEBUG
                    DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"AGP Surface Alloc: Address:%08x Size:%08x\n",m_dwAddress,dwSize);
#endif

#ifdef CAPTURE
                    if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                        CAPTURE_SURFACE_ALLOC surf;
                        surf.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                        surf.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                        surf.dwExtensionID        = CAPTURE_XID_SURFACE_ALLOC;
                        surf.dwCtxDMAHandle       = D3D_CONTEXT_DMA_HOST_MEMORY;
                        surf.dwOffset             = m_dwOffset;
                        surf.dwSize               = getSize();
                        surf.dwAlignment          = 0;
                        surf.dwType               = CAPTURE_SURFACE_TYPE_NORMAL;
                        surf.dwKind               = dwUsageKind;
                        surf.dwSurfaceType        = getFormat();
                        surf.dwIntendedPitch      = dwPitch;
                        surf.dwIntendedHeight     = dwHeight;
                        captureLog (&surf,sizeof(surf));
                    }
#endif
                    dbgTracePop();
                    return (TRUE);
                }
            }
            // fail - don't try again
#ifdef DEBUG
                DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"AGP Surface Alloc Failed: Size:%08x\n",dwSize);
#endif
            DPF_LEVEL(NVDBG_LEVEL_INFO,"CSimpleSurface::create: Surface in AGP failed");
            dwAllowedHeaps &= ~HEAP_AGP;
        }

        // pci
        if (dwAllowedHeaps & dwPreferredHeap & HEAP_PCI)
        {
            DWORD dwOffset;

            // On PCI, allocate from our internal texture heap.
            dwOffset = nvPCIAlloc(dwSize);
            if (dwOffset)
            {
                m_dwPitch     = dwPitch;
                m_dwHeight    = dwHeight;
                m_dwDepth     = dwDepth;
                m_dwOffset    = dwOffset;
                m_dwAddress   = getDC()->nvD3DTexHeapData.dwBase + dwOffset;
                m_dwFlags    &= ~HEAP_LOCATION_MASK;
                m_dwFlags    |= HEAP_PCI;
                m_dwFlags    &= ~FLAG_TILED;

#ifdef DEBUG
                DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"PCI Surface Alloc: Address:%08x Size:%08x\n",m_dwAddress,dwSize);
#endif

#ifdef CAPTURE
                if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                    CAPTURE_SURFACE_ALLOC surf;
                    surf.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                    surf.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                    surf.dwExtensionID        = CAPTURE_XID_SURFACE_ALLOC;
                    surf.dwCtxDMAHandle       = D3D_CONTEXT_DMA_HOST_MEMORY;
                    surf.dwOffset             = m_dwOffset;
                    surf.dwSize               = getSize();
                    surf.dwAlignment          = 0;
                    surf.dwType               = CAPTURE_SURFACE_TYPE_NORMAL;
                    surf.dwKind               = dwUsageKind;
                    surf.dwSurfaceType        = getFormat();
                    surf.dwIntendedPitch      = dwPitch;
                    surf.dwIntendedHeight     = dwHeight;
                    captureLog (&surf,sizeof(surf));
                }
#endif
                dbgTracePop();
                return (TRUE);
            }

#ifdef DEBUG
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"PCI Surface Alloc Failed: Size:%08x\n",dwSize);
#endif

            // fail - don't try again
            DPF_LEVEL(NVDBG_LEVEL_INFO,"CSimpleSurface::create: Surface in PCI failed");
            dwAllowedHeaps &= ~HEAP_PCI;
        }

        // system memory
        if (dwAllowedHeaps & dwPreferredHeap & HEAP_SYS)
        {
            // For system memory, allocate from global heap.
            // m_dwOffset keeps the original ptr while
            // m_dwAddress keeps the aligned ptr
#ifdef WINNT
            PDD_SURFACE_LOCAL pDDSLcl = getWrapper() ? getWrapper()->getDDSLcl() : NULL;
            if (pDDSLcl)
            {
                m_dwOffset = (DWORD)EngAllocPrivateUserMem(pDDSLcl, dwSize + 31, 'x_VN');
//                getWrapper()->setDDSLcl(NULL);  We shouldn't keep Lcl around, but we have to for texture
                //management    HH
            }
            else
#endif // WINNT
            {
                m_dwOffset = (DWORD) AllocIPM (dwSize);
                nvAssert (((m_dwOffset + 31) & ~31) == m_dwOffset);
                //GlobalAlloc(GMEM_FIXED, dwSize + 31);
            }

            if (m_dwOffset)
            {
                m_dwPitch     = dwPitch;
                m_dwHeight    = dwHeight;
                m_dwDepth     = dwDepth;
                m_dwAddress   = (m_dwOffset + 31) & ~31;
                m_dwFlags    &= ~HEAP_LOCATION_MASK;
                m_dwFlags    |= HEAP_SYS;
                m_dwFlags    &= ~FLAG_TILED;

#ifdef DEBUG
                DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"SYS Surface Alloc: Address:%08x Size:%08x\n",m_dwAddress,dwSize);
#endif

                dbgTracePop();
                return (TRUE);
            }

            // fail - don't try again
#ifdef DEBUG
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"SYS Surface Alloc Failed: Size:%08x\n",dwSize);
#endif
            DPF_LEVEL(NVDBG_LEVEL_INFO,"CSimpleSurface::create: Surface in SYS failed");
            dwAllowedHeaps &= ~HEAP_SYS;
        }

        // next
        dwPreferredHeap = (dwPreferredHeap << 1) & HEAP_ANYWHERE;
        if (!dwPreferredHeap) dwPreferredHeap = HEAP_VID;
    }

    // not allocated
    //  tag as invalid and fail
    DPF_LEVEL(NVDBG_LEVEL_INFO,"CSimpleSurface::create: Surface Not allocated");
    m_dwAddress = 0;
    dbgTracePop();
    return (FALSE);
}

//****************************************************************************

BOOL CSimpleSurface::create
(
    const CSimpleSurface* pTemplateSurface
#ifdef CAPTURE
   ,DWORD dwUsageKind
#endif
)
{
    DWORD dwHeap, dwAllocFlags;
    BOOL  bRV;

    dbgTracePush ("CSimpleSurface[%08x]::create(pTemplateSurface=%08x)",this,pTemplateSurface);
    // create in same heap as original
    dwHeap = pTemplateSurface->getHeapLocation();
    dwAllocFlags  = CSimpleSurface::ALLOCATE_SIMPLE;
    dwAllocFlags |= pTemplateSurface->isZBuffer() ? CSimpleSurface::ALLOCATE_AS_ZBUFFER_CMP : 0;

    bRV = create (pTemplateSurface->getSize(),
                  1,
                  1,
                  pTemplateSurface->getBPP(),
                  dwHeap,
                  dwHeap,
                  dwAllocFlags
#ifdef CAPTURE
                 ,dwUsageKind
#endif
                  );
    dbgTracePop();
    return (bRV);
}

//****************************************************************************
// CSimpleSurface::create for formatted surfaces
//
// creates a surface with format information

BOOL CSimpleSurface::create (CNvObject *pWrapperObject,
                             DWORD      dwFormat,
                             DWORD      dwWidth,
                             DWORD      dwHeight,
                             DWORD      dwDepth,
                             DWORD      dwMultiSampleBits,
                             DWORD      dwBPPRequested,
                             DWORD      dwBPPGranted,
                             DWORD      dwPitch,
                             DWORD      dwAllowedHeaps,
                             DWORD      dwPreferredHeap,
                             DWORD      dwAllocFlags
#ifdef CAPTURE
                            ,DWORD      dwUsageKind
#endif
                             )
{
    dbgTracePush ("CSimpleSurface::create");

    setWrapper      (pWrapperObject);
    setFormat       (dwFormat);
    setWidth        (dwWidth);
    setHeight       (dwHeight);
    setDepth        (dwDepth);
    setMultiSampleBits(dwMultiSampleBits);
    setBPPRequested (dwBPPRequested);
    setBPP          (dwBPPGranted);

#ifdef  STEREO_SUPPORT
	if (dwAllocFlags & ALLOCATE_AS_STEREO && STEREODATA(dwStereoHWType) == STEREOCFG_INTERLACED) 
		dwPitch = GetModePitch(dwWidth, dwHeight, dwBPPGranted << 3) * 2;
#endif  //STEREO_SUPPORT

    BOOL bRV = create (dwPitch, dwHeight, dwDepth, dwBPPGranted, dwAllowedHeaps, dwPreferredHeap, dwAllocFlags
#ifdef CAPTURE
                                      ,dwUsageKind
#endif
                                       );
#ifdef  STEREO_SUPPORT
	if (bRV && dwAllocFlags & ALLOCATE_AS_STEREO) 
		bRV = createStereo ();
#endif  //STEREO_SUPPORT

    dbgTracePop();
    return (bRV);
}

//****************************************************************************
// CSimpleSurface::recreate for formatted surfaces
//
// recreate a surface with a different bit depth

BOOL CSimpleSurface::recreate (DWORD dwBPP)
{
    // cache off current info
    CNvObject *pNvObj   = getWrapper();
    DWORD      dwFormat = getFormat();
    DWORD      dwWidth  = getWidth();
    DWORD      dwHeight = getHeight();
    DWORD      dwMSBits = getMultiSampleBits();
    DWORD      dwBPPReq = getBPPRequested();
    DWORD      dwPitch  = dwBPP * dwWidth;
    DWORD      dwAFlags = getAllocFlags();
#ifdef  STEREO_SUPPORT
    BOOL       bStereo = isStereo();
    BOOL       bRetVal; 
    // destroy and reallocate
    destroy();
	if (bStereo && (m_dwFlags &  FLAG_NOTREAL) == 0 && STEREODATA(dwStereoHWType) == STEREOCFG_INTERLACED) 
		dwPitch = GetModePitch(dwWidth, dwHeight, dwBPP << 3) * 2;
    bRetVal = create (pNvObj, dwFormat, dwWidth, dwHeight, 1,
                    dwMSBits, dwBPPReq, dwBPP, dwPitch,
                    CSimpleSurface::HEAP_VID, CSimpleSurface::HEAP_VID, dwAFlags
            #ifdef CAPTURE
                   ,CAPTURE_SURFACE_KIND_ZETA
            #endif
                     );
    if (bStereo)
        createStereo();
    return bRetVal;
#else   //STEREO_SUPPORT
    // destroy and reallocate
    destroy();
    return (create (pNvObj, dwFormat, dwWidth, dwHeight, 1,
                    dwMSBits, dwBPPReq, dwBPP, dwPitch,
                    CSimpleSurface::HEAP_VID, CSimpleSurface::HEAP_VID, dwAFlags
            #ifdef CAPTURE
                   ,CAPTURE_SURFACE_KIND_ZETA
            #endif
                   )
           );
#endif  //STEREO_SUPPORT
}

//****************************************************************************
// CSimpleSurface::growTo
//
BOOL CSimpleSurface::growBy
(
    DWORD dwDelta,
    BOOL  bPreserveContents
)
{
    dbgTracePush ("CSimpleSurface::create");

    // currently we only grow sysmem surfaces (sorry)
    if (getHeapLocation() != HEAP_SYS)
    {
        nvAssert(0);
        dbgTracePop();
        return FALSE;
    }

    DWORD dwSize = getSize() + dwDelta + m_dwPitch - 1;
    dwSize /= m_dwPitch;
    dwSize *= m_dwPitch;

    // For system memory, allocate from global heap.
    // m_dwOffset keeps the original ptr while
    // m_dwAddress keeps the aligned ptr
#ifdef WINNT
    PDD_SURFACE_LOCAL pDDSLcl = getWrapper() ? getWrapper()->getDDSLcl() : NULL;
    if (pDDSLcl)
    {
        void *ptr = EngAllocPrivateUserMem(pDDSLcl, dwSize+31, 'x_VN');
        if (ptr)
        {
            if (bPreserveContents)
            {
                DWORD dw = (DWORD(ptr) + 31) & ~31;
                nvMemCopy (dw,m_dwAddress,getSize());
            }
            EngFreePrivateUserMem (pDDSLcl, (void*)m_dwOffset);
            m_dwOffset = (DWORD)ptr;
        }
        else
        {
            // fail safely
            dbgTracePop();
            return FALSE;
        }
    }
    else
#endif // WINNT
    {
        void *ptr = AllocIPM(dwSize);
        if (ptr)
        {
            if (bPreserveContents)
            {
                DWORD dw = (DWORD(ptr) + 31) & ~31;
                nvMemCopy (dw,m_dwAddress,getSize());
            }
            FreeIPM ((void*)m_dwOffset);
            m_dwOffset = (DWORD)ptr;
        }
        else
        {
            // fail safely
            dbgTracePop();
            return FALSE;
        }
    }

    // update state
    m_dwHeight  = dwSize / m_dwPitch;
    m_dwAddress = (m_dwOffset + 31) & ~31;

    DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"SYS Surface Realloc: Address:%08x Size:%08x\n",m_dwAddress,dwSize);

    dbgTracePop();
    return TRUE;
}

//****************************************************************************
// CSimpleSurface::destroy
//
// frees a surface

BOOL CSimpleSurface::destroy
(
    void
)
{
    dbgTracePush ("CSimpleSurface[%08x]::destroy()",this);

    // validate surface
    //  destroying a invalid surface is technically a bad thing, but unfortunately mode
    //  switches will disown memory that is still considered allocated. we just return.
    if (!isValid())
    {
        DPF ("CSimpleSurface::destroy: Attempting to free an invalid surface (may not be serious)");
        dbgTracePop();
        return TRUE;
    }

    // cannot free memory until it is actually not in use any more
    cpuLock (LOCK_NORMAL);

    // capture surface free
#ifdef CAPTURE
    if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
        CAPTURE_SURFACE_FREE surf;
        surf.dwJmpCommand         = CAPTURE_JMP_COMMAND;
        surf.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
        surf.dwExtensionID        = CAPTURE_XID_SURFACE_FREE;
        surf.dwCtxDMAHandle       = (getHeapLocation() == CSimpleSurface::HEAP_VID)
                                    ? NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY
                                    : D3D_CONTEXT_DMA_HOST_MEMORY;
        surf.dwOffset             = m_dwOffset;
        captureLog (&surf,sizeof(surf));
    }
#endif

    // do we own the memory?
    if (m_dwFlags & FLAG_DONOTOWNMEMORY)
    {
        // disown this surface
        disown();
        dbgTracePop();
        return TRUE;
    }

    // free memory
    switch (getHeapLocation())
    {
        // video
        case HEAP_VID:
        {
            // Call DDRAW to de-allocate memory from the video memory heap.
#ifdef WINNT
            NVHEAP_FREE (m_dwOffset);
#else
            // we should only be trying to free this memory from 16 bit land when a mode switch is about
            // to happen. in this case the free isn't required since the RM will destroy the heap
            if (!global.b16BitCode)
            {
                NVHEAP_FREE (m_dwAddress);
            }
#endif

            // Decrement count of video memory surfaces allocated.
            pDriverData->DDrawVideoSurfaceCount--;

#ifdef DEBUG
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"VID Surface Free: Address:%08x\n",m_dwAddress);
#endif

            // done
            m_dwAddress = 0;
            m_dwFlags  &= ~HEAP_LOCATION_MASK;

#ifdef  STEREO_SUPPORT
            destroyStereo();
#endif  //STEREO_SUPPORT

            dbgTracePop();
            return TRUE;
        }
        // agp
        case HEAP_AGP:
        {
            // de-allocate memory from AGP heap
#ifdef NV_AGP
            nvAGPFree((void*)m_dwAddress);
#else
#ifdef WINNT
            nvAGPFree((void*)m_dwOffset);
#else
            nvAGPFree((void*)m_dwAddress);
#endif
#endif

#ifdef DEBUG
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"AGP Surface Free: Address:%08x\n",m_dwAddress);
#endif

            // done
            m_dwAddress = 0;
            m_dwFlags  &= ~HEAP_LOCATION_MASK;
            dbgTracePop();
            return TRUE;
        }
        // pci
        case HEAP_PCI:
        {
            // On PCI, de-allocate from our internal texture heap.
            nvPCIFree(m_dwAddress - getDC()->nvD3DTexHeapData.dwBase);

#ifdef DEBUG
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"PCI Surface Free: Address:%08x\n",m_dwAddress);
#endif
            // done
            m_dwAddress = 0;
            m_dwFlags  &= ~HEAP_LOCATION_MASK;
            dbgTracePop();
            return TRUE;
        }
        // sys
        case HEAP_SYS:
        {
            //  m_dwOffset has the original unaligned ptr
#ifdef WINNT
            PDD_SURFACE_LOCAL pDDSLcl = getWrapper() ? getWrapper()->getDDSLcl() : NULL;
            if (pDDSLcl)
            {
                EngFreePrivateUserMem(pDDSLcl, (void*)m_dwOffset);
                getWrapper()->setDDSLcl(NULL);
            }
            else
#endif // WINNT
            {
                FreeIPM ((void*) m_dwOffset);
                // GlobalFree ((HGLOBAL)m_dwOffset);
            }

#ifdef DEBUG
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"SYS Surface Free: Address:%08x\n",m_dwAddress);
#endif

            // done
            m_dwAddress = 0;
            m_dwFlags  &= ~HEAP_LOCATION_MASK;
            dbgTracePop();
            return TRUE;
        }
    }

    // failed (may be default push buffer - not allowed to be destroyed)
    DPF ("CSimpleSurface::destroy: Invalid heap specified. this surface is probably corrupt.");
    dbgD3DError();
    dbgTracePop();
    return FALSE;
}

#ifdef  STEREO_SUPPORT

BOOL CSimpleSurface::createStereo ()
    {
        BOOL    bRetVal = TRUE;
        DWORD   dwAllocFlags = 0;
        if (!STEREO_ENABLED)
            return TRUE;
        nvAssert (m_dwAddressRight == 0);
        if (isZBuffer())
            dwAllocFlags |= ALLOCATE_AS_ZBUFFER_UNC;
        if (m_dwFlags & FLAG_TILED)
            dwAllocFlags |= ALLOCATE_TILED;
        if (STEREODATA(dwStereoHWType) != STEREOCFG_INTERLACED || m_dwFlags & FLAG_NOTREAL)
        {
            //Save what will be overwritten.
            DWORD   dwSaveAddress = m_dwAddress;
            DWORD   dwSaveOffset  = m_dwOffset;
            if (bRetVal = create(m_dwPitch, m_dwHeight, 1, m_dwBPP,
                                 m_dwFlags & HEAP_LOCATION_MASK,
                                 m_dwFlags & HEAP_LOCATION_MASK, dwAllocFlags
#ifdef CAPTURE
                                 ,CAPTURE_SURFACE_KIND_UNKNOWN
#endif
                                 ))
            {
                m_dwAddressRight = m_dwAddress;
                m_dwOffsetRight  = m_dwOffset;
            } else
	            LOG("Can't create a stereo rendering surface");
            m_dwAddress = dwSaveAddress;
            m_dwOffset  = dwSaveOffset; 
        } else           
        {
			DWORD dwRightEyeOffset;
			dwRightEyeOffset = m_dwPitch >> 1;
			m_dwAddressRight = m_dwAddress + dwRightEyeOffset;
			m_dwOffsetRight  = m_dwOffset + dwRightEyeOffset;
        }
        tagAsStereo();
        if (m_dwFlags & FLAG_NOTREAL)
            return bRetVal;
        if (!isZBuffer())
        {
            nvAssert (STEREODATA(dwSurfaceCount) < 3);
            for (DWORD i = 0; i < 3; i++)
            {
                if (STEREODATA(RmStereoParams.FlipOffsets[i][0]) == 0xFFFFFFFF)
                {
                    //It is a free element
                    STEREODATA(RmStereoParams.FlipOffsets[i][0]) = m_dwOffset;
                    STEREODATA(RmStereoParams.FlipOffsets[i][1]) = m_dwOffsetRight;
                    STEREODATA(pRenderTargets[i]) = this;
                    STEREODATA(dwSurfaceCount)++;
                    return bRetVal;
                }
            }
            nvAssert (0);
        }
        return bRetVal;
    }

BOOL CSimpleSurface::destroyStereo (void)
    {
        if (isStereo())
        {
            m_dwFlags  &= ~FLAG_STEREO;
            if (STEREODATA(dwStereoHWType) != STEREOCFG_INTERLACED)
            {
#ifdef WINNT
                NVHEAP_FREE (m_dwOffsetRight);
#else
                NVHEAP_FREE (m_dwAddressRight);
#endif
                pDriverData->DDrawVideoSurfaceCount--;
            }
            m_dwAddressRight = 0;
            m_dwOffsetRight  = 0;
            if (m_dwFlags & FLAG_NOTREAL)
                return TRUE;
            if (!STEREO_ENABLED)
                return TRUE;
            if (!isZBuffer())
            {
                nvAssert (STEREODATA(dwSurfaceCount) > 0);
                STEREODATA(dwSurfaceCount)--;
                for (DWORD i = 0; i < 3; i++)
                {
                    if (STEREODATA(pRenderTargets[i]) == this)
                    {
                        //Found itself. Now clean it up.
                        STEREODATA(RmStereoParams.FlipOffsets[i][0]) = 0xFFFFFFFF;
                        STEREODATA(pRenderTargets[i]) = NULL;
                        return TRUE;
                    }
                }
            }
        }
        return TRUE;
    }
#endif  //STEREO_SUPPORT

//****************************************************************************
//****************************************************************************
//****************************************************************************
//**  CComplexSurface ********************************************************
//****************************************************************************
//****************************************************************************
//****************************************************************************

//****************************************************************************
// CComplexSurface::tagRenameEnable
//
// enable renaming and the renaming strategy to follow
template <int cMax>
void CComplexSurface<cMax>::tagRenameEnable
(
    DWORD           dwRenameType,
    DWORD           dwPreAllocCount,
    PCANRENAMEPROC  pfnCanRenameProc,
    PRENAMEPROC     pfnRenameProc,
    void           *pContext
)
{
    dbgTracePush ("CComplexSurface::tagRenameEnable");

    // update flags
    m_dwFlags &= ~FLAG_RENAME_CALL;
    m_dwFlags |=  FLAG_RENAME;

    // set new policy
    if (dwRenameType == RENAME_EXTERNAL)
    {
        m_pfnCanRenameProc     = pfnCanRenameProc;
        m_pfnRenameProc        = pfnRenameProc;
        m_pRenameContext       = pContext;
        m_dwFlags             |= FLAG_RENAME_CALL;
    }

    // allocate some of the surfaces already
    while (dwPreAllocCount > 1)
    {
        // alloc a surface
        dwPreAllocCount--;
        if (!m_aSurface[dwPreAllocCount].create(&m_aSurface[0]
#ifdef CAPTURE
            ,CAPTURE_SURFACE_KIND_TEXTURE
#endif
            )){
            DPF("tagRenameEnable: Failed to pre allocate surfaces\n");
            break;
        }
        m_dwTotalSurfaces++;
    }

    dbgTracePop();
}

//****************************************************************************
// CComplexSurface::forceRename
//
// rename surface on external demand
template <int cMax>
void CComplexSurface<cMax>::forceRename
(
    DWORD dwNewSurface,
    DWORD dwNewAddress
)
{
    // new surface retain most of its attributes
    DWORD dwPitch  = m_aSurface[m_dwActiveSurface].getPitch();
    DWORD dwHeight = m_aSurface[m_dwActiveSurface].getHeight();
    DWORD dwHeap   = m_aSurface[m_dwActiveSurface].getHeapLocation();
    m_aSurface[dwNewSurface].own (dwNewAddress,dwPitch,dwHeight,dwHeap,TRUE);

    // update flags
    m_dwPreviousSurface = m_dwActiveSurface;
    m_dwActiveSurface   = dwNewSurface;
    m_dwTotalSurfaces   = max(m_dwTotalSurfaces, (dwNewSurface+1));
}

//****************************************************************************
// CComplexSurface::cpuLock
//
// rename busy textures on demand when enabled

template <int cMax>
void CComplexSurface<cMax>::cpuLock
(
    DWORD dwAccess
)
{
    dbgTracePush ("CComplexSurface::cpuLock");

                #ifdef NV_PROFILE_CPULOCK
                NVP_START (NVP_T_FLOAT0);
                #endif

    // get proper index
    CSimpleSurface *pActive = getActiveSurface();

    // if we are allowed to rename and the surface is busy...
    if ((dwAccess & CSimpleSurface::LOCK_RENAME)                                    // renaming was requested (or is allowed)
     && canRename()                                                                 // surface has renaming enabled
     && pActive->isBusy()                                                           // surface is busy
     && (!(m_dwFlags & FLAG_RENAME_CALL)                                            // internal rename policy always OK
      || ((m_dwFlags & FLAG_RENAME_CALL) && m_pfnCanRenameProc(m_pRenameContext)))) // external rename policy active & OK
    {
        // search through all remaining surfaces
        BOOL  bAvailable      = FALSE;
        DWORD dwOldestDate    = ~0;
        DWORD dwOldestSurface = m_dwActiveSurface;
        DWORD dwNew;
        for(DWORD i = 1; i < m_dwTotalSurfaces; i++)
        {
            dwNew = m_dwActiveSurface + i;
            if (dwNew >= m_dwTotalSurfaces)
                dwNew -= m_dwTotalSurfaces;

            // check if we have a surface that isn't busy
            if (!m_aSurface[dwNew].isBusy()) {
                bAvailable = TRUE;
                break;
            }

            // update oldest pointer to point to the olders guy in this list
            if (m_aSurface[dwNew].getRetireDate() < dwOldestDate)
            {
                dwOldestDate    = m_aSurface[dwNew].getRetireDate();
                dwOldestSurface = dwNew;
            }
        }

        if (bAvailable)
        {
            // adopt the new surface
            m_dwPreviousSurface = m_dwActiveSurface;
            m_dwActiveSurface   = dwNew;
            pActive = getActiveSurface();
            // signal external rename policy of state, if needed
            if (m_dwFlags & FLAG_RENAME_CALL)
            {
                 //this call should really be made, but causes thrashing on some system in WinBench 1024x768x16 (test 10)
                (m_pfnRenameProc)(m_pRenameContext, m_dwPreviousSurface,m_dwActiveSurface);
            }
            else if (dwAccess & (CSimpleSurface::LOCK_RENAME_COPY & ~CSimpleSurface::LOCK_RENAME))
            {
                        #ifdef NV_PROFILE_COPIES
                        NVP_START(NVP_T_RENAME_AUTO_COPY);
                        #endif
                nvMemCopy (getSurface(m_dwActiveSurface)->getAddress(),
                           getSurface(m_dwPreviousSurface)->getAddress(),
                           getSurface(m_dwPreviousSurface)->getSize());
                        #ifdef NV_PROFILE_COPIES
                        NVP_STOP(NVP_T_RENAME_AUTO_COPY);
                        nvpLogTime (NVP_T_RENAME_AUTO_COPY,nvpTime[NVP_T_RENAME_AUTO_COPY]);
                        #endif
            }
        }
        else if (m_dwTotalSurfaces < cMax)
        {
            // create a new surface if we can
            dwNew = m_dwTotalSurfaces;
            if (m_aSurface[dwNew].create(&m_aSurface[m_dwActiveSurface]
#ifdef CAPTURE
               ,((m_dwFlags & FLAG_RENAME_CALL) && m_pfnCanRenameProc(m_pRenameContext)) ? CAPTURE_SURFACE_KIND_TEXTURE : CAPTURE_SURFACE_KIND_VERTEX
#endif
                ))
            {
                // signal external rename policy of state, if needed
                if (m_dwFlags & FLAG_RENAME_CALL)
                {
                    (m_pfnRenameProc)(m_pRenameContext, m_dwActiveSurface, dwNew);
                }
                else if (dwAccess & (CSimpleSurface::LOCK_RENAME_COPY & ~CSimpleSurface::LOCK_RENAME))
                {
                        #ifdef NV_PROFILE_COPIES
                        NVP_START(NVP_T_RENAME_AUTO_COPY);
                        #endif
                    nvMemCopy (getSurface(dwNew)->getAddress(),
                               getSurface(m_dwActiveSurface)->getAddress(),
                               getSurface(m_dwActiveSurface)->getSize());
                        #ifdef NV_PROFILE_COPIES
                        NVP_STOP(NVP_T_RENAME_AUTO_COPY);
                        nvpLogTime (NVP_T_RENAME_AUTO_COPY,nvpTime[NVP_T_RENAME_AUTO_COPY]);
                        #endif
                }

                // bump total
                m_dwTotalSurfaces++;

                // we'll take it
                m_dwPreviousSurface = m_dwActiveSurface;
                m_dwActiveSurface   = dwNew;
                pActive = getActiveSurface();
            }
            else
            {
                // we are all out of memory and all surfaces are busy - wait on the one that will retire first
                m_dwPreviousSurface = m_dwActiveSurface;
                m_dwActiveSurface   = dwOldestSurface;
                pActive = getActiveSurface();
            }
        }
        else
        {
            // we are all out of surfaces and all are busy - wait on the one that will retire first
            m_dwPreviousSurface = m_dwActiveSurface;
            m_dwActiveSurface   = dwOldestSurface;
            pActive = getActiveSurface();
        }
    }

    //  lock this surface (which may still be a busy surface)
// NVP_START(255);
            #ifdef NV_PROFILE_CPULOCK
            NVP_STOP (NVP_T_FLOAT0);
            nvpLogTime (NVP_T_FLOAT0,nvpTime[NVP_T_FLOAT0]);
            #endif

            #ifdef NV_PROFILE_CPULOCK
            NVP_START (NVP_T_FLOAT1);
            #endif
    pActive->cpuLock (dwAccess);
            #ifdef NV_PROFILE_CPULOCK
            NVP_STOP (NVP_T_FLOAT1);
            nvpLogTime (NVP_T_FLOAT1,nvpTime[NVP_T_FLOAT1]);
            #endif
// NVP_STOP(255);
// if (dwAccess & CSimpleSurface::LOCK_RENAME)
// {
    // __int64 time = nvpTime[255] / global.dwProcessorSpeed;
    // if (time >= 1000)
    // {
        // DPF ("%dus", (DWORD)time);
    // }
// }

    dbgTracePop();
}

//****************************************************************************
// CComplexSurface::create
//
// creates a surface in one of the the allowed heaps based on preference.
template <int cMax>
BOOL CComplexSurface<cMax>::create
(
    CNvObject *pWrapper,
    DWORD dwSize,
    DWORD dwAllowedHeaps,
    DWORD dwPreferredHeap
#ifdef CAPTURE
   ,DWORD dwUsageKind
#endif
)
{
    DWORD i;

    dbgTracePush ("CComplexSurface[%08x]::create(dwSize=%08x,dwAllowedHeaps=%x,dwPreferredHeap=%x)",
                 this,dwSize,dwAllowedHeaps,dwPreferredHeap);

    // set surface values
    m_dwTotalSurfaces = 1;
    m_dwActiveSurface = m_dwPreviousSurface = 0;
    //run down the simple surface list and make sure they all have the wrapper set BEFORE create.
    for (i=0;i<cMax;i++) m_aSurface[i].setWrapper(pWrapper);

    // create the first surface and return
    BOOL bRV = m_aSurface[0].create (dwSize, 1, 1, 0, dwAllowedHeaps, dwPreferredHeap,
                                     CSimpleSurface::ALLOCATE_SIMPLE
#ifdef CAPTURE
                                    ,dwUsageKind
#endif
                                     );

    dbgTracePop();
    return (bRV);
}

//****************************************************************************
// CComplexSurface::own
//
// claim an already allocated surface
template <int cMax>
BOOL CComplexSurface<cMax>::own
(
    DWORD dwAddress,
    DWORD dwPitch,
    DWORD dwLogHeight,
    DWORD dwHeapLocation,
    BOOL  bOwnMemory
)
{
    dbgTracePush ("CComplexSurface[%08x]::own(dwAddress=%08x,dwPitch=%08x,dwLogH=%08x,dwHeapLoc=%x,bOwnMem=%d)",
                  this,dwAddress,dwPitch,dwLogHeight,dwHeapLocation,bOwnMemory);

    // set surface values
    m_dwTotalSurfaces = 1;
    m_dwActiveSurface = m_dwPreviousSurface
                      = 0;

    // claim the first surface
    m_aSurface[0].own (dwAddress,dwPitch,dwLogHeight,dwHeapLocation,bOwnMemory);

    // done
    dbgTracePop();
    return TRUE;
}

//****************************************************************************
// CComplexSurface::disown
//
// claim an already allocated surface
template <int cMax>
BOOL CComplexSurface<cMax>::disown
(
    void
)
{
    dbgTracePush ("CComplexSurface::disown()");

    m_aSurface[0].disown();

    dbgTracePop();
    return TRUE;
}

//****************************************************************************
// CComplexSurface::swap
//
// interchange two complex surfaces

template <int cMax>
BOOL CComplexSurface<cMax>::swap
(
    CComplexSurface *pCSurf
)
{
    dbgTracePush ("CComplexSurface[%08x]::swap()", this);

    // get number of component surfaces
    DWORD dwCount = max (pCSurf->getTotalSurfaces(), getTotalSurfaces());

    // swap each component surface
    for (DWORD i=0; i<dwCount; i++) {
        m_aSurface[i].swap (&(pCSurf->m_aSurface[i]));
    }

    // done
    dbgTracePop();
    return (TRUE);
}

//****************************************************************************
// CComplexSurface::destroy
//
// frees a surface

template <int cMax>
BOOL CComplexSurface<cMax>::destroy
(
    void
)
{
    dbgTracePush ("CComplexSurface[%08x]::destroy()",this);

    // destroy and destruct all surfaces
    DWORD dwCount = getTotalSurfaces();
    for (DWORD i = 0; i < dwCount; i++)
    {
        // destroy
        if (m_aSurface[i].isValid())
        {
            m_aSurface[i].destroy();
        }

        // destruct
        m_aSurface[i].~CSimpleSurface();
    }

    // kill state
    m_dwTotalSurfaces = m_dwFlags
                      = 0;

    // done
    dbgTracePop();
    return TRUE;
}

#pragma warning (push, 1)
// NOTE: The following warning is issued incorrectly by the MS compiler. Ignore it.  <bdw>
template CComplexSurface<TOTAL_TEX_RENAME>;
template CComplexSurface<TOTAL_VB_RENAME>;
#pragma warning (pop)


//****************************************************************************
//****************************************************************************
//****************************************************************************
//**  CNvObject     **********************************************************
//****************************************************************************
//****************************************************************************
//****************************************************************************


//****************************************************************************
// CNvObject::dbgTestIntegrity
//
// tests integrity of an object

#ifdef DEBUG
void CNvObject::dbgTestIntegrity
(
    void
)
{
    dbgTracePush ("CNvObject::dbgTestIntegrity");

    // test self
    if (!isValid())
    {
        DPF ("CNvObject::dbgTestIntegrity: instance contains invalid THIS object");
        __asm int 3;
        dbgTracePop();
        return;
    }

    // test next
    if (m_pNext && !m_pNext->isValid())
    {
        DPF ("CNvObject::dbgTestIntegrity: instance contains invalid NEXT object");
        __asm int 3;
        dbgTracePop();
        return;
    }

    // test prev
    if (m_pPrev && !m_pPrev->isValid())
    {
        DPF ("CNvObject::dbgTestIntegrity: instance contains invalid PREV object");
        __asm int 3;
        dbgTracePop();
        return;
    }

    dbgTracePop();
}
#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvTri.cpp ===
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvTri.cpp                                                         *
*   NV4 Old Execute Buffer Style RenderPrimitive DDI routines.              *
*   NOTE: Uses indexed primitive rendering routines in NV4INDEX.C           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/98 - created                      *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

PFNRENDERPRIMITIVEOP pfnRenderPrimitiveOperation[] =
{
    nvRenderNoOp,           // Op codes are 1 based, so 0 is a no op.
    nvRenderPoint,
    nvRenderLine,
    nvRenderTriangle,
    nvRenderNoOp,           // 4  - not supported.
    nvRenderNoOp,           // 5  - not supported.
    nvRenderNoOp,           // 6  - not supported.
    nvRenderNoOp,           // 7  - not supported.
    nvRenderNoOp,           // 8  - not supported.
    nvRenderNoOp,           // 9  - not supported.
    nvRenderNoOp,           // 10 - not supported.
    nvRenderNoOp,           // 11 - not supported.
    nvRenderNoOp,           // 12 - not supported.
    nvRenderNoOp,           // 13 - not supported.
    nvRenderNoOp            // 14 - not supported.
};

//---------------------------------------------------------------------------

DWORD nvRenderNoOp
(
    NV_INNERLOOP_ARGLIST
)
{
    DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvRenderNoOp - Unhandled instruction opcode");
    return (DD_OK);
}

//---------------------------------------------------------------------------

DWORD nvRenderTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    /*
     * Call the appropriate wrapper function.
     */
    switch (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE])
    {
        case D3DFILL_SOLID:
            nvTriangleDispatch (NV_INNERLOOP_ARGS);
            break;
        case D3DFILL_WIREFRAME:
            nvIndexedWireframeTriangle (NV_INNERLOOP_ARGS);
            break;
        case D3DFILL_POINT:
            nvIndexedPointTriangle (NV_INNERLOOP_ARGS);
            break;
    }
    return (DD_OK);
}

//---------------------------------------------------------------------------

#ifndef WINNT  // these calls are obsolete on NT (DX7)

// Old style execute buffer entry point.
// This callback is invoked when a primitive is to be rendered.
// All the data is known to be clipped.

DWORD __stdcall nvRenderPrimitive
(
    LPD3DHAL_RENDERPRIMITIVEDATA prd
)
{
    LPD3DINSTRUCTION    lpIns;
    LPBYTE              lpData;
    DWORD               dwPrimCount;
    LPWORD              lpPrim;
    LPBYTE              lpVertices;

#if (NVARCH >= 0x10)
    if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN)) {
        DPF ("ugh. need to implement nvRenderPrimitive for celsius / kelvin");
        dbgD3DError();
        prd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }
#endif

#ifdef NV_NULL_DRIVER
    prd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
#endif //NV_NULL_DRIVER

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, prd);

    // Get pointer to global driver. data structure.
    nvSetDriverDataPtrFromContext(pContext);

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED)
    {
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvRenderPrimitive - Bad Context");
        prd->ddrval = D3DHAL_CONTEXT_BAD;
        NvReleaseSemaphore(pDriverData);
        return (DDHAL_DRIVER_HANDLED);
    }

    // Check z-visibility test.
    if (pContext->dwRenderState[D3DRENDERSTATE_ZVISIBLE])
    {
        // If you don't implement Z visibility testing, just do this.
        prd->dwStatus &= ~D3DSTATUS_ZNOTVISIBLE;
        prd->ddrval    = DD_OK;
        NvReleaseSemaphore(pDriverData);
        return (DDHAL_DRIVER_HANDLED);
    }

    // Need to make sure that an unfriendly mode switch didn't sneak and not cause
    // us to get re-enabled properly.
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvD3DRecover();
        }
        else {
            prd->ddrval = DD_OK;
            NvReleaseSemaphore(pDriverData);
            return (DDHAL_DRIVER_HANDLED);
        }
    }

    if ((pContext->bStateChange || pDriverData->TwoDRenderingOccurred)
     || (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE))
        NV_FORCE_TRI_SETUP(pContext);

    pContext->pCurrentVShader->create (pContext, D3DFVF_TLVERTEX, CVertexShader::getHandleFromFvf(D3DFVF_TLVERTEX));

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TL_MODE |
                                      CELSIUS_DIRTY_FVF |
                                      CELSIUS_DIRTY_LIGHTS;
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF |
                                      KELVIN_DIRTY_LIGHTS;
#endif  // nv10

    // If the context has changed since the last render call, switch it now.
    nvSetD3DSurfaceState(pContext);

    // Prepare to parse the instructions.
    prd->ddrval = DD_OK;
    lpData      = (LPBYTE)(VIDMEM_ADDR(((LPDDRAWI_DDRAWSURFACE_INT)prd->lpExeBuf)->lpLcl->lpGbl->fpVidMem));
    lpIns       = &prd->diInstruction;
    dwPrimCount = lpIns->wCount;
    lpPrim      = (LPWORD)(lpData + prd->dwOffset);
    lpVertices  = (LPBYTE)(VIDMEM_ADDR((LPDDRAWI_DDRAWSURFACE_INT)prd->lpTLBuf)->lpLcl->lpGbl->fpVidMem + prd->dwTLOffset);

    switch (lpIns->bOpcode) {
        case 1:
            pContext->dp2.dwDP2Prim = D3DDP2OP_POINTS;
            break;
        case 2:
            pContext->dp2.dwDP2Prim = D3DDP2OP_INDEXEDLINELIST;
            break;
        case 3:
            pContext->dp2.dwDP2Prim = D3DDP2OP_INDEXEDTRIANGLELIST;
            break;
        default:
            DPF ("unsupported primitive type in nvRenderPrimitive");
            dbgD3DError();
            break;
    }

    pContext->dp2.dwIndices = (DWORD)(lpPrim);

    pfnRenderPrimitiveOperation[lpIns->bOpcode] (pContext, (WORD)dwPrimCount);

    // Update the put offset.
    nvPusherStart (FALSE);

    // The DEBUG driver has a flag that can be set to force a flush after every triangle
    // rendering call.  This is helpful for debugging when dbgFrontRender is enabled.
    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    // Tell DDRAW that thee global clip state has changed.
    // Probably don't need this, but I'd rather be safe.
    pDriverData->ddClipUpdate = TRUE;

    // Show that 3D rendering has occurred.
    pDriverData->TwoDRenderingOccurred   = 0;
    pDriverData->ThreeDRenderingOccurred = TRUE;

    // Return successfully.
    NvReleaseSemaphore(pDriverData);
    return (DDHAL_DRIVER_HANDLED);
}

#endif // !WINNT

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvTexManage.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvTexManage.cpp
//        texture management routines
//
//  History:
//        Craig Duttweiler      (bertrem)       3Dec99      created
//
// **************************************************************************
#include "nvprecomp.h"
#pragma hdrstop


#if (NVARCH >= 0x04)

#ifdef TEX_MANAGE

//---------------------------------------------------------------------------

BOOL nvTexManageInit
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvTexManageInit");

    pContext->texManData.dwTextureListInUse = NV_TEXMAN_DEFAULT_CLASS;

    for (DWORD i=0; i<NV_TEXMAN_NUM_CLASSES; i++) {
        pContext->texManData.pTextureLRU[i] = NULL;
        pContext->texManData.pTextureMRU[i] = NULL;
    }

    pContext->texManData.pTextureToEvict = NULL;

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

// add a managed texture to pContext's list for class dwClass

BOOL nvTexManageAddTexture
(
    PNVD3DCONTEXT pContext,
    CTexture     *pTexture,
    DWORD         dwClass
)
{
    dbgTracePush ("nvTexManageAddTexture");

    if (!pContext)
    {
        pContext = nvGetPreapprovedContext();
    }
    nvAssert (pContext);
    nvAssert (pTexture && pTexture->isManaged() && pTexture->isBaseTexture());

    CTexture *pListTail = pContext->texManData.pTextureMRU[dwClass];

    pTexture->setPrev (pListTail);
    pTexture->setNext (NULL);

    if (pListTail) {
        pListTail->setNext (pTexture);
    }

    pContext->texManData.pTextureMRU[dwClass] = pTexture;

    if (pContext->texManData.pTextureLRU[dwClass] == NULL) {
        pContext->texManData.pTextureLRU[dwClass] = pTexture;
    }

    pTexture->setContext (pContext);

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

// remove a texture from the class lists

BOOL nvTexManageRemoveTexture
(
    CTexture *pTexture
)
{
    dbgTracePush ("nvTexManageRemoveTexture");

    nvAssert (pTexture && pTexture->isManaged() && pTexture->isBaseTexture());

    PNVD3DCONTEXT pContext = pTexture->getContext();
    CTexture     *pNext    = pTexture->getNext();
    CTexture     *pPrev    = pTexture->getPrev();

    nvAssert (pContext);

    // if the eviction pointer was pointing to this texture, advance it
    if (pContext->texManData.pTextureToEvict == pTexture) {
        nvTexManageAdvancePtr (pContext);
    }

    if (pNext) {
        nvAssert (pNext->getPrev() == pTexture);  // sanity
        pNext->setPrev (pPrev);
    }
    else {
        // this was the end of the list. find the relevant list-end pointer and clean it up
        for (DWORD i=0; i<NV_TEXMAN_NUM_CLASSES; i++) {
            if (pContext->texManData.pTextureMRU[i] == pTexture) break;
        }
        nvAssert (i<NV_TEXMAN_NUM_CLASSES);
        pContext->texManData.pTextureMRU[i] = pPrev;
    }

    if (pPrev) {
        nvAssert (pPrev->getNext() == pTexture);  // sanity
        pPrev->setNext (pNext);
    }
    else {
        // this was the start of the list. find the relevant list-head pointer and clean it up
        for (DWORD i=0; i<NV_TEXMAN_NUM_CLASSES; i++) {
            if (pContext->texManData.pTextureLRU[i] == pTexture) break;
        }
        nvAssert (i<NV_TEXMAN_NUM_CLASSES);
        pContext->texManData.pTextureLRU[i] = pNext;
    }

    pTexture->setNext    (NULL);
    pTexture->setPrev    (NULL);
    pTexture->setContext (NULL);

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

// advance to the next non-null list, after (and _inclusive_ of dwList)

BOOL nvTexManageAdvanceList
(
    PNVD3DCONTEXT pContext,
    DWORD         dwList
)
{
    dbgTracePush ("nvTexManageAdvanceList");

    // try to find a non-empty list
    while (dwList < NV_TEXMAN_NUM_CLASSES) {
        if (pContext->texManData.pTextureLRU[dwList] != NULL) {
            pContext->texManData.dwTextureListInUse = dwList;
            pContext->texManData.pTextureToEvict = pContext->texManData.pTextureLRU[dwList];
            dbgTracePop();
            return (TRUE);
        }
        dwList++;
    }

    pContext->texManData.dwTextureListInUse = 0;
    pContext->texManData.pTextureToEvict = NULL;

    dbgTracePop();
    return (FALSE);
}

//---------------------------------------------------------------------------

// reset the eviction pointer

BOOL nvTexManageResetPtr
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvTexManageResetPtr");
    BOOL bRV = nvTexManageAdvanceList (pContext, 0);
    dbgTracePop();
    return (bRV);
}

//---------------------------------------------------------------------------

// advance the eviction pointer

BOOL nvTexManageAdvancePtr
(
    PNVD3DCONTEXT pContext
)
{
    BOOL bSuccess;

    dbgTracePush ("nvTexManageAdvancePtr");

    if (pContext->texManData.pTextureToEvict == NULL) {
        // reset everything
        bSuccess = nvTexManageResetPtr (pContext);
    }

    else {
        pContext->texManData.pTextureToEvict = (pContext->texManData.pTextureToEvict)->getNext();
        if (pContext->texManData.pTextureToEvict == NULL) {
            // we've fallen off the end of the list, advance to the next nonempty list
            bSuccess = nvTexManageAdvanceList (pContext, pContext->texManData.dwTextureListInUse+1);
        }
        else {
            bSuccess = TRUE;
        }
    }

    dbgTracePop();
    return (bSuccess);
}

//---------------------------------------------------------------------------

// nvTexManageEvict
//
// evicts a texture from pContext (or elsewhere, contingent on the protocol).
// see nvTexManage.h for possible values of dwProtocol.
//
// returns TRUE upon successful eviction, else FALSE

BOOL nvTexManageEvict
(
    PNVD3DCONTEXT pContext,
    DWORD         dwProtocol
)
{
    CTexture *pTexture;

    dbgTracePush ("nvTexManageEvict");

    switch (dwProtocol) {

        case NV_TEXMAN_EVICTION_PROTOCOL_ANY:
            // recurse on all protocols
            dwProtocol = NV_TEXMAN_EVICTION_PROTOCOL_PASSIVE;
            while (dwProtocol <= NV_TEXMAN_EVICTION_PROTOCOL_SEVERE) {
                if (nvTexManageEvict (pContext, dwProtocol)) {
                    dbgTracePop();
                    return (TRUE);
                }
                dwProtocol++;
            }
            break;

        case NV_TEXMAN_EVICTION_PROTOCOL_SEVERE:
            // recurse on all contexts, beginning with this one
            PNVD3DCONTEXT pCtxt;
            pCtxt = pContext;
            while (pCtxt) {
                if (nvTexManageEvict (pCtxt, NV_TEXMAN_EVICTION_PROTOCOL_AGGRESSIVE)) {
                    dbgTracePop();
                    return (TRUE);
                }
                pCtxt = pCtxt->pContextNext;
            }
            pCtxt = pContext->pContextPrev;
            while (pCtxt) {
                if (nvTexManageEvict (pCtxt, NV_TEXMAN_EVICTION_PROTOCOL_AGGRESSIVE)) {
                    dbgTracePop();
                    return (TRUE);
                }
                pCtxt = pCtxt->pContextPrev;
            }
            break;

        default:
            pTexture = pContext->texManData.pTextureToEvict;

            if (!pTexture) {
                nvTexManageResetPtr (pContext);
                pTexture = pContext->texManData.pTextureToEvict;
            }

            while (pTexture) {
                if (dwProtocol == NV_TEXMAN_EVICTION_PROTOCOL_AGGRESSIVE) {
                    // force the HW to give up this texture
					DDLOCKINDEX(NVSTAT_LOCK_TEXMAN_EVICT);
                    pTexture->cpuLockSwz (CSimpleSurface::LOCK_NORMAL);
                }
                if (pTexture->evict()) {
                    nvTexManageRemoveTexture (pTexture);
                    DPF_LEVEL (NVDBG_LEVEL_TEXMAN, "texman: evicted %08x at address %08x of size %08x, protocol=%d", pTexture, 
                                                pTexture->getSwizzled()->getAddress,pTexture->getSize(),dwProtocol);
                    dbgTracePop();
                    return (TRUE);
                }
                nvTexManageAdvancePtr (pContext);
                pTexture = pContext->texManData.pTextureToEvict;
            }
            break;

    }  // switch

    DPF_LEVEL (NVDBG_LEVEL_TEXMAN, "texman: eviction FAILED, protocol=%d", dwProtocol);

    dbgTracePop();
    return (FALSE);
}

//---------------------------------------------------------------------------

// nvTexManageEvictAll
//
// evict all managed textures associated with pContext.
// if pContext is NULL, evict all textures in all contexts

BOOL nvTexManageEvictAll
(
    PNVD3DCONTEXT pContext
)
{
    CTexture *pTexture;
    BOOL bSuccess = TRUE;

    dbgTracePush ("nvTexManageEvictAll: pContext=%08x", pContext);

    if (!pContext) {
        pContext = (PNVD3DCONTEXT) getDC()->dwContextListHead;
        while (pContext) {
            if (!nvTexManageEvictAll (pContext)) {
                bSuccess = FALSE;
            }
            pContext = pContext->pContextNext;
        }
        dbgTracePop();
        return (bSuccess);
    }

    nvTexManageResetPtr (pContext);
    pTexture = pContext->texManData.pTextureToEvict;

    while (pTexture) {
        // force the HW to give up this texture
		DDLOCKINDEX(NVSTAT_LOCK_TEXMAN_EVICT_ALL);
        pTexture->cpuLockSwz (CSimpleSurface::LOCK_NORMAL);
        if (pTexture->evict()) {
            nvTexManageRemoveTexture (pTexture);
            DPF_LEVEL (NVDBG_LEVEL_TEXMAN, "texman: evictAll evicted %08x at address %08x of size %08x from context %08x", 
                                            pTexture, pTexture->getSwizzled()->getAddress(),pTexture->getSize(),pContext);
        }
        else {
            bSuccess = FALSE;
            DPF ("texman: evictAll unable to evict %08x", pTexture);
            dbgD3DError();
            nvTexManageAdvancePtr (pContext);
        }
        pTexture->cpuUnlockSwz();
        pTexture = pContext->texManData.pTextureToEvict;
    }

    dbgTracePop();
    return (bSuccess);
}

//---------------------------------------------------------------------------

// nvTexManageFetch
//
// fetches a texture from system memory into video or AGP mempory.
// other textures are evicted from pContext as necessary.

BOOL nvTexManageFetch
(
    PNVD3DCONTEXT pContext,  // may be NULL!!
    CTexture     *pTexture
)
{
    BOOL bFetchSuccess, bEvictionSuccess;

    dbgTracePush ("nvTexManageFetch");

    DPF_LEVEL (NVDBG_LEVEL_TEXMAN, "texman: fetching %08x", pTexture);

    nvAssert (pTexture && pTexture->isManaged());

    if (!pContext) {
        // totally arbitrary. for lack of any context with which to
        // associate this texture, just stick it in the first
        pContext = (PNVD3DCONTEXT) getDC()->dwContextListHead;
    }

    bFetchSuccess = pTexture->fetch();

    if (!bFetchSuccess) {
        nvTexManageResetPtr (pContext);
        do {
            // evict something and try again
            bEvictionSuccess = nvTexManageEvict (pContext, NV_TEXMAN_EVICTION_PROTOCOL_ANY);
            if (bEvictionSuccess) {
                bFetchSuccess = pTexture->fetch();
            }
        } while (bEvictionSuccess && !bFetchSuccess);
    }

    if (bFetchSuccess) {
        nvAssert ((pTexture->getPrev() == NULL) &&
                  (pTexture->getNext() == NULL));
        nvTexManageAddTexture (pContext, pTexture, NV_TEXMAN_DEFAULT_CLASS);
    }

#ifdef DEBUG
    if (bFetchSuccess) {
        DWORD dwHeap = pTexture->getSwizzled()->getHeapLocation();
        DPF_LEVEL (NVDBG_LEVEL_TEXMAN, "texman: fetched %08x at address %08x of size %08x into %s memory",
                   pTexture,
                   pTexture->getSwizzled()->getAddress(),
                   pTexture->getSize(),
                   (dwHeap == CSimpleSurface::HEAP_VID) ? "video" :
                   (dwHeap == CSimpleSurface::HEAP_AGP) ? "agp"   :
                   (dwHeap == CSimpleSurface::HEAP_PCI) ? "pci"   : "unknown");
    }
    else {
        DPF_LEVEL (NVDBG_LEVEL_TEXMAN, "texman: fetch of %08x FAILED", pTexture);
    }
#endif

    dbgTracePop();
    return (bFetchSuccess);
}

//---------------------------------------------------------------------------

// nvTexManageTouch
//
// "touches" a texture. texture is moved from its current location in the
// eviction lists to the MRU slot.

BOOL nvTexManageTouch
(
    PNVD3DCONTEXT pContext,  // may be NULL!
    CTexture     *pTexture
)
{
    dbgTracePush ("nvTexManageTouch");

    nvAssert (pTexture && pTexture->isManaged() && pTexture->isBaseTexture());

    if (!nvTexManageRemoveTexture (pTexture)) {
        DPF ("failed to remove a managed texture from the LRU lists");
        dbgTracePop();
        return (FALSE);
    }

    if (!pContext) {
        // totally arbitray. for lack of any context with which to
        // associate this texture, just stick it in the first
        pContext = (PNVD3DCONTEXT) getDC()->dwContextListHead;
    }

    if (!nvTexManageAddTexture (pContext, pTexture, NV_TEXMAN_DEFAULT_CLASS)) {
        DPF ("failed to add a managed texture to the LRU lists");
        dbgTracePop();
        return (FALSE);
    }

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

// nvTexManageSceneEnd
//
// texture management done whenever scene end is called.
// under current scheme, we basically just shuffle some eviction lists around

BOOL nvTexManageSceneEnd
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvTexManageSceneEnd");

    // list 2 (previous frame) goes onto the end of list 0 (old frames)
    CTexture *pList0Tail = pContext->texManData.pTextureMRU[0];
    CTexture *pList2Head = pContext->texManData.pTextureLRU[2];

    if (pList2Head) {
        if (pList0Tail) {
            // list0 exists. attach list2 at the end
            pList0Tail->setNext (pList2Head);
            pList2Head->setPrev (pList0Tail);
        }
        else {
            // there is no list0. list0 <= list2
            pContext->texManData.pTextureLRU[0] = pList2Head;
        }
        pContext->texManData.pTextureMRU[0] = pContext->texManData.pTextureMRU[2];
    }

    // list 1 (most recent frame) becomes list 2 (previous frame)
    pContext->texManData.pTextureLRU[2] = pContext->texManData.pTextureLRU[1];
    pContext->texManData.pTextureMRU[2] = pContext->texManData.pTextureMRU[1];

    // list 1 (most recent frame) is now empty
    pContext->texManData.pTextureLRU[1] = NULL;
    pContext->texManData.pTextureMRU[1] = NULL;

    dbgTracePop();
    return (TRUE);
}

#endif

#endif // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvTranslate.cpp ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvTranslate.cpp                                                   *
*   definitions of tables used to translate from generic (D3D or NV)        *
*   constants to HW-specific constants                                      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*   Craig Duttweiler    bertrem     03May99     created                     *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

//--------------------------------------------------------------------------
// surface formats
//--------------------------------------------------------------------------

const DWORD nvSurfaceFormatToBPP[NV_SURFACE_FORMAT_COUNT] =
{
    1,                                                          // NV_SURFACE_FORMAT_Y8
    1,                                                          // NV_SURFACE_FORMAT_AY8
    2,                                                          // NV_SURFACE_FORMAT_A1R5G5B5
    2,                                                          // NV_SURFACE_FORMAT_X1R5G5B5
    2,                                                          // NV_SURFACE_FORMAT_A4R4G4B4
    2,                                                          // NV_SURFACE_FORMAT_R5G6B5
    4,                                                          // NV_SURFACE_FORMAT_A8R8G8B8
    4,                                                          // NV_SURFACE_FORMAT_X1A7R8G8B8
    4,                                                          // NV_SURFACE_FORMAT_X8R8G8B8
    1,                                                          // NV_SURFACE_FORMAT_I8_A1R5G5B5
    1,                                                          // NV_SURFACE_FORMAT_I8_R5G6B5
    1,                                                          // NV_SURFACE_FORMAT_I8_A4R4G4B4
    1,                                                          // NV_SURFACE_FORMAT_I8_A8R8G8B8
    8,                                                          // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    16,                                                         // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    16,                                                         // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    2,                                                          // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    2,                                                          // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    4,                                                          // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    1,                                                          // NV_SURFACE_FORMAT_IMAGE_Y8
    1,                                                          // NV_SURFACE_FORMAT_IMAGE_SY8
    2,                                                          // NV_SURFACE_FORMAT_IMAGE_X7SY9
    2,                                                          // NV_SURFACE_FORMAT_IMAGE_R8B8
    2,                                                          // NV_SURFACE_FORMAT_IMAGE_G8B8
    2,                                                          // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    2,                                                          // NV_SURFACE_FORMAT_Z16
    4,                                                          // NV_SURFACE_FORMAT_Z24S8
    4,                                                          // NV_SURFACE_FORMAT_Z24X8
    2,                                                          // NV_SURFACE_FORMAT_DV8DU8
    2,                                                          // NV_SURFACE_FORMAT_L6DV5DU5
    4,                                                          // NV_SURFACE_FORMAT_X8L8DV8DU8
    4,                                                          // NV_SURFACE_FORMAT_HILO_1_V16U16
    4,                                                          // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    4,                                                          // NV_SURFACE_FORMAT_A8B8G8R8
    0                                                           // NV_SURFACE_FORMAT_UNKNOWN
};

const DWORD nv052SurfaceFormat[NV_SURFACE_FORMAT_COUNT] = // for swizzling
{
    NV052_SET_FORMAT_COLOR_LE_Y8,                               // NV_SURFACE_FORMAT_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_AY8
    ~0,                                                         // NV_SURFACE_FORMAT_A1R5G5B5
    NV052_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5,                // NV_SURFACE_FORMAT_X1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_A4R4G4B4
    NV052_SET_FORMAT_COLOR_LE_R5G6B5,                           // NV_SURFACE_FORMAT_R5G6B5
    NV052_SET_FORMAT_COLOR_LE_A8R8G8B8,                         // NV_SURFACE_FORMAT_A8R8G8B8
    NV052_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8,            // NV_SURFACE_FORMAT_X1A7R8G8B8
    NV052_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8,                // NV_SURFACE_FORMAT_X8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A4R4G4B4
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SY8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_X7SY9
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    ~0,                                                         // NV_SURFACE_FORMAT_Z16
    ~0,                                                         // NV_SURFACE_FORMAT_Z24S8
    ~0,                                                         // NV_SURFACE_FORMAT_Z24X8
    ~0,                                                         // NV_SURFACE_FORMAT_DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_L6DV5DU5
    ~0,                                                         // NV_SURFACE_FORMAT_X8L8DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_1_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_A8B8G8R8
    ~0                                                          // NV_SURFACE_FORMAT_UNKNOWN

};

const DWORD nv053SurfaceFormat[NV_SURFACE_FORMAT_COUNT] =
{
    ~0,                                                         // NV_SURFACE_FORMAT_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_AY8
    ~0,                                                         // NV_SURFACE_FORMAT_A1R5G5B5
    NV053_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5,                // NV_SURFACE_FORMAT_X1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_A4R4G4B4
    NV053_SET_FORMAT_COLOR_LE_R5G6B5,                           // NV_SURFACE_FORMAT_R5G6B5
    NV053_SET_FORMAT_COLOR_LE_A8R8G8B8,                         // NV_SURFACE_FORMAT_A8R8G8B8
    NV053_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8,            // NV_SURFACE_FORMAT_X1A7R8G8B8
    NV053_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8,                // NV_SURFACE_FORMAT_X8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A4R4G4B4
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SY8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_X7SY9
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    ~0,                                                         // NV_SURFACE_FORMAT_Z16
    ~0,                                                         // NV_SURFACE_FORMAT_Z24S8
    ~0,                                                         // NV_SURFACE_FORMAT_Z24X8
    ~0,                                                         // NV_SURFACE_FORMAT_DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_L6DV5DU5
    ~0,                                                         // NV_SURFACE_FORMAT_X8L8DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_1_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_A8B8G8R8
    ~0                                                          // NV_SURFACE_FORMAT_UNKNOWN
};

#if (NVARCH >= 0x010)
const DWORD nv056SurfaceFormat[NV_SURFACE_FORMAT_COUNT] =
{
    ~0,                                                         // NV_SURFACE_FORMAT_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_AY8
    ~0,                                                         // NV_SURFACE_FORMAT_A1R5G5B5
    NV056_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5,        // NV_SURFACE_FORMAT_X1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_A4R4G4B4
    NV056_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5,                   // NV_SURFACE_FORMAT_R5G6B5
    NV056_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8,                 // NV_SURFACE_FORMAT_A8R8G8B8
    NV056_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8,    // NV_SURFACE_FORMAT_X1A7R8G8B8
    NV056_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8,        // NV_SURFACE_FORMAT_X8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A4R4G4B4
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_I8_A8R8G8B8,              // NV_SURFACE_FORMAT_I8_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SY8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_X7SY9
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    ~0,                                                         // NV_SURFACE_FORMAT_Z16
    ~0,                                                         // NV_SURFACE_FORMAT_Z24S8
    ~0,                                                         // NV_SURFACE_FORMAT_Z24X8
    ~0,                                                         // NV_SURFACE_FORMAT_DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_L6DV5DU5
    ~0,                                                         // NV_SURFACE_FORMAT_X8L8DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_1_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_A8B8G8R8
    ~0                                                          // NV_SURFACE_FORMAT_UNKNOWN
};

const DWORD nv062SurfaceFormat[NV_SURFACE_FORMAT_COUNT] =
{
    NV062_SET_COLOR_FORMAT_LE_Y8,                               // NV_SURFACE_FORMAT_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_AY8
    ~0,                                                         // NV_SURFACE_FORMAT_A1R5G5B5
    NV062_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5,                // NV_SURFACE_FORMAT_X1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_A4R4G4B4
    NV062_SET_COLOR_FORMAT_LE_R5G6B5,                           // NV_SURFACE_FORMAT_R5G6B5
    NV062_SET_COLOR_FORMAT_LE_A8R8G8B8,                         // NV_SURFACE_FORMAT_A8R8G8B8
    NV062_SET_COLOR_FORMAT_LE_X1A7R8G8B8_Z1A7R8G8B8,            // NV_SURFACE_FORMAT_X1A7R8G8B8
    NV062_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8,                // NV_SURFACE_FORMAT_X8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A4R4G4B4
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SY8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_X7SY9
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    ~0,                                                         // NV_SURFACE_FORMAT_Z16
    ~0,                                                         // NV_SURFACE_FORMAT_Z24S8
    ~0,                                                         // NV_SURFACE_FORMAT_Z24X8
    ~0,                                                         // NV_SURFACE_FORMAT_DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_L6DV5DU5
    ~0,                                                         // NV_SURFACE_FORMAT_X8L8DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_1_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_A8B8G8R8
    ~0                                                          // NV_SURFACE_FORMAT_UNKNOWN
};
#endif

const DWORD nv077SurfaceFormat[NV_SURFACE_FORMAT_COUNT] = // for swizzling
{
    ~0,                                                         // NV_SURFACE_FORMAT_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_AY8
    NV077_SET_COLOR_FORMAT_LE_R5G6B5,                           // NV_SURFACE_FORMAT_A1R5G5B5
    NV077_SET_COLOR_FORMAT_LE_R5G6B5,                           // NV_SURFACE_FORMAT_X1R5G5B5
    NV077_SET_COLOR_FORMAT_LE_R5G6B5,                           // NV_SURFACE_FORMAT_A4R4G4B4
    NV077_SET_COLOR_FORMAT_LE_R5G6B5,                           // NV_SURFACE_FORMAT_R5G6B5
    NV077_SET_COLOR_FORMAT_LE_A8R8G8B8,                         // NV_SURFACE_FORMAT_A8R8G8B8
    NV077_SET_COLOR_FORMAT_LE_A8R8G8B8,                         // NV_SURFACE_FORMAT_X1A7R8G8B8
    NV077_SET_COLOR_FORMAT_LE_A8R8G8B8,                         // NV_SURFACE_FORMAT_X8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A4R4G4B4
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SY8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_X7SY9
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    NV077_SET_COLOR_FORMAT_LE_R5G6B5,                           // NV_SURFACE_FORMAT_Z16
    NV077_SET_COLOR_FORMAT_LE_A8R8G8B8,                         // NV_SURFACE_FORMAT_Z24S8
    NV077_SET_COLOR_FORMAT_LE_A8R8G8B8,                         // NV_SURFACE_FORMAT_Z24X8
    ~0,                                                         // NV_SURFACE_FORMAT_DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_L6DV5DU5
    ~0,                                                         // NV_SURFACE_FORMAT_X8L8DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_1_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_A8B8G8R8
    ~0                                                          // NV_SURFACE_FORMAT_UNKNOWN
};

#if (NVARCH >= 0x010)
const DWORD nv089SurfaceFormat[NV_SURFACE_FORMAT_COUNT] =
{
    NV089_SET_COLOR_FORMAT_LE_Y8,                               // NV_SURFACE_FORMAT_Y8
    NV089_SET_COLOR_FORMAT_LE_AY8,                              // NV_SURFACE_FORMAT_AY8
    NV089_SET_COLOR_FORMAT_LE_A1R5G5B5,                         // NV_SURFACE_FORMAT_A1R5G5B5
    NV089_SET_COLOR_FORMAT_LE_X1R5G5B5,                         // NV_SURFACE_FORMAT_X1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_A4R4G4B4
    NV089_SET_COLOR_FORMAT_LE_R5G6B5,                           // NV_SURFACE_FORMAT_R5G6B5
    NV089_SET_COLOR_FORMAT_LE_A8R8G8B8,                         // NV_SURFACE_FORMAT_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_X1A7R8G8B8
    NV089_SET_COLOR_FORMAT_LE_X8R8G8B8,                         // NV_SURFACE_FORMAT_X8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A4R4G4B4
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SY8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_X7SY9
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    ~0,                                                         // NV_SURFACE_FORMAT_Z16
    ~0,                                                         // NV_SURFACE_FORMAT_Z24S8
    ~0,                                                         // NV_SURFACE_FORMAT_Z24X8
    ~0,                                                         // NV_SURFACE_FORMAT_DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_L6DV5DU5
    ~0,                                                         // NV_SURFACE_FORMAT_X8L8DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_1_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_A8B8G8R8
    ~0                                                          // NV_SURFACE_FORMAT_UNKNOWN
};
#endif

#if (NVARCH >= 0x020)
const DWORD nv097SurfaceFormat[NV_SURFACE_FORMAT_COUNT] =
{
    ~0,                                                         // NV_SURFACE_FORMAT_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_AY8
    ~0,                                                         // NV_SURFACE_FORMAT_A1R5G5B5
    NV097_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5,        // NV_SURFACE_FORMAT_X1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_A4R4G4B4
    NV097_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5,                   // NV_SURFACE_FORMAT_R5G6B5
    NV097_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8,                 // NV_SURFACE_FORMAT_A8R8G8B8
    NV097_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8,    // NV_SURFACE_FORMAT_X1A7R8G8B8
    NV097_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8,        // NV_SURFACE_FORMAT_X8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A4R4G4B4
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SY8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_X7SY9
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    NV097_SET_SURFACE_FORMAT_ZETA_Z16,                          // NV_SURFACE_FORMAT_Z16
    NV097_SET_SURFACE_FORMAT_ZETA_Z24S8,                        // NV_SURFACE_FORMAT_Z24S8
    NV097_SET_SURFACE_FORMAT_ZETA_Z24S8,                        // NV_SURFACE_FORMAT_Z24X8
    ~0,                                                         // NV_SURFACE_FORMAT_DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_L6DV5DU5
    ~0,                                                         // NV_SURFACE_FORMAT_X8L8DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_1_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_A8B8G8R8
    ~0                                                          // NV_SURFACE_FORMAT_UNKNOWN
};
#endif

//--------------------------------------------------------------------------
// texture formats
//--------------------------------------------------------------------------

const DWORD nv054TextureFormat[NV_SURFACE_FORMAT_COUNT] =
{
    NV054_FORMAT_COLOR_LE_Y8,                                   // NV_SURFACE_FORMAT_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_AY8
    NV054_FORMAT_COLOR_LE_A1R5G5B5,                             // NV_SURFACE_FORMAT_A1R5G5B5
    NV054_FORMAT_COLOR_LE_X1R5G5B5,                             // NV_SURFACE_FORMAT_X1R5G5B5
    NV054_FORMAT_COLOR_LE_A4R4G4B4,                             // NV_SURFACE_FORMAT_A4R4G4B4
    NV054_FORMAT_COLOR_LE_R5G6B5,                               // NV_SURFACE_FORMAT_R5G6B5
    NV054_FORMAT_COLOR_LE_A8R8G8B8,                             // NV_SURFACE_FORMAT_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_X1A7R8G8B8
    NV054_FORMAT_COLOR_LE_X8R8G8B8,                             // NV_SURFACE_FORMAT_X8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A4R4G4B4
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SY8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_X7SY9
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    ~0,                                                         // NV_SURFACE_FORMAT_Z16
    ~0,                                                         // NV_SURFACE_FORMAT_Z24S8
    ~0,                                                         // NV_SURFACE_FORMAT_Z24X8
    ~0,                                                         // NV_SURFACE_FORMAT_DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_L6DV5DU5
    ~0,                                                         // NV_SURFACE_FORMAT_X8L8DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_1_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_A8B8G8R8
    ~0                                                          // NV_SURFACE_FORMAT_UNKNOWN
};

const DWORD nv055TextureFormat[NV_SURFACE_FORMAT_COUNT] =
{
    ~0,                                                         // NV_SURFACE_FORMAT_Y8
    NV055_FORMAT_COLOR_LE_AY8,                                  // NV_SURFACE_FORMAT_AY8
    NV055_FORMAT_COLOR_LE_A1R5G5B5,                             // NV_SURFACE_FORMAT_A1R5G5B5
    NV055_FORMAT_COLOR_LE_X1R5G5B5,                             // NV_SURFACE_FORMAT_X1R5G5B5
    NV055_FORMAT_COLOR_LE_A4R4G4B4,                             // NV_SURFACE_FORMAT_A4R4G4B4
    NV055_FORMAT_COLOR_LE_R5G6B5,                               // NV_SURFACE_FORMAT_R5G6B5
    NV055_FORMAT_COLOR_LE_A8R8G8B8,                             // NV_SURFACE_FORMAT_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_X1A7R8G8B8
    NV055_FORMAT_COLOR_LE_X8R8G8B8,                             // NV_SURFACE_FORMAT_X8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A4R4G4B4
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SY8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_X7SY9
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    ~0,                                                         // NV_SURFACE_FORMAT_Z16
    ~0,                                                         // NV_SURFACE_FORMAT_Z24S8
    ~0,                                                         // NV_SURFACE_FORMAT_Z24X8
    ~0,                                                         // NV_SURFACE_FORMAT_DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_L6DV5DU5
    ~0,                                                         // NV_SURFACE_FORMAT_X8L8DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_1_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_A8B8G8R8
    ~0                                                          // NV_SURFACE_FORMAT_UNKNOWN
};

#if (NVARCH >= 0x010)
const DWORD nv056TextureFormat[NV_SURFACE_FORMAT_COUNT] =
{
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_Y8,                       // NV_SURFACE_FORMAT_Y8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_AY8,                      // NV_SURFACE_FORMAT_AY8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_A1R5G5B5,                 // NV_SURFACE_FORMAT_A1R5G5B5
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_X1R5G5B5,                 // NV_SURFACE_FORMAT_X1R5G5B5
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_A4R4G4B4,                 // NV_SURFACE_FORMAT_A4R4G4B4
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_R5G6B5,                   // NV_SURFACE_FORMAT_R5G6B5
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_A8R8G8B8,                 // NV_SURFACE_FORMAT_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_X1A7R8G8B8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_X8R8G8B8,                 // NV_SURFACE_FORMAT_X8R8G8B8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_I8_A1R5G5B5,              // NV_SURFACE_FORMAT_I8_A1R5G5B5
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_I8_R5G6B5,                // NV_SURFACE_FORMAT_I8_R5G6B5
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_I8_A4R4G4B4,              // NV_SURFACE_FORMAT_I8_A4R4G4B4
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_I8_A8R8G8B8,              // NV_SURFACE_FORMAT_I8_A8R8G8B8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_DXT1_A1R5G5B5,            // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_DXT23_A8R8G8B8,           // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_DXT45_A8R8G8B8,           // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A1R5G5B5,           // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R5G6B5,             // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A8R8G8B8,           // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8,                 // NV_SURFACE_FORMAT_IMAGE_Y8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SY8,                // NV_SURFACE_FORMAT_IMAGE_SY8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_X7SY9,              // NV_SURFACE_FORMAT_IMAGE_X7SY9
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R8B8,               // NV_SURFACE_FORMAT_IMAGE_R8B8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_G8B8,               // NV_SURFACE_FORMAT_IMAGE_G8B8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SG8SB8,             // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    ~0,                                                         // NV_SURFACE_FORMAT_Z16
    ~0,                                                         // NV_SURFACE_FORMAT_Z24S8
    ~0,                                                         // NV_SURFACE_FORMAT_Z24X8
    ~0,                                                         // NV_SURFACE_FORMAT_DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_L6DV5DU5
    ~0,                                                         // NV_SURFACE_FORMAT_X8L8DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_1_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_A8B8G8R8
    ~0                                                          // NV_SURFACE_FORMAT_UNKNOWN
};
#endif

#if (NVARCH >= 0x020)
const DWORD nv097TextureFormat[NV_SURFACE_FORMAT_COUNT] =
{
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_Y8,                       // NV_SURFACE_FORMAT_Y8
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_AY8,                      // NV_SURFACE_FORMAT_AY8
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A1R5G5B5,                 // NV_SURFACE_FORMAT_A1R5G5B5
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_X1R5G5B5,                 // NV_SURFACE_FORMAT_X1R5G5B5
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A4R4G4B4,                 // NV_SURFACE_FORMAT_A4R4G4B4
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R5G6B5,                   // NV_SURFACE_FORMAT_R5G6B5
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A8R8G8B8,                 // NV_SURFACE_FORMAT_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_X1A7R8G8B8
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_X8R8G8B8,                 // NV_SURFACE_FORMAT_X8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A4R4G4B4
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_I8_A8R8G8B8,              // NV_SURFACE_FORMAT_I8_A8R8G8B8
    NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT1_A1R5G5B5,             // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT23_A8R8G8B8,            // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT45_A8R8G8B8,            // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A1R5G5B5,           // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G6B5,             // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8,           // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8,                 // NV_SURFACE_FORMAT_IMAGE_Y8
    NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SY8,                // NV_SURFACE_FORMAT_IMAGE_SY8
    NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X7SY9,              // NV_SURFACE_FORMAT_IMAGE_X7SY9
    NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8B8,               // NV_SURFACE_FORMAT_IMAGE_R8B8
    NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8,               // NV_SURFACE_FORMAT_IMAGE_G8B8
    NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SG8SB8,             // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    ~0,                                                         // NV_SURFACE_FORMAT_Z16
    ~0,                                                         // NV_SURFACE_FORMAT_Z24S8
    ~0,                                                         // NV_SURFACE_FORMAT_Z24X8
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_G8B8,                     // NV_SURFACE_FORMAT_DV8DU8
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R6G5B5,                   // NV_SURFACE_FORMAT_L6DV5DU5
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_X8R8G8B8,                 // NV_SURFACE_FORMAT_X8L8DV8DU8
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_YB_16_YA_16,              // NV_SURFACE_FORMAT_HILO_1_V16U16
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_YB_16_YA_16,              // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A8B8G8R8,                 // NV_SURFACE_FORMAT_A8B8G8R8
    ~0                                                          // NV_SURFACE_FORMAT_UNKNOWN

};
#endif

//--------------------------------------------------------------------------
// context DMAs
//--------------------------------------------------------------------------

const DWORD nv054TextureContextDma[NV_CONTEXT_DMA_COUNT] =
{
    ~0,
    NV054_FORMAT_CONTEXT_DMA_A,
    NV054_FORMAT_CONTEXT_DMA_B
};

const DWORD nv055TextureContextDma[NV_CONTEXT_DMA_COUNT] =
{
    ~0,
    NV055_FORMAT_CONTEXT_DMA_A,
    NV055_FORMAT_CONTEXT_DMA_B
};

#if (NVARCH >= 0x010)
const DWORD nv056TextureContextDma[NV_CONTEXT_DMA_COUNT] =
{
    ~0,
    NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A,
    NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_B
};
#endif

#if (NVARCH >= 0x020)
const DWORD nv097TextureContextDma[NV_CONTEXT_DMA_COUNT] =
{
    ~0,
    NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A,
    NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_B
};
#endif

#if (NVARCH >= 0x010)
const DWORD nv056PaletteContextDma[NV_CONTEXT_DMA_COUNT] =
{
    ~0,
    NV056_SET_TEXTURE_PALETTE_CONTEXT_DMA_A,
    NV056_SET_TEXTURE_PALETTE_CONTEXT_DMA_B
};
#endif

#if (NVARCH >= 0x020)
const DWORD nv097PaletteContextDma[NV_CONTEXT_DMA_COUNT] =
{
    ~0,
    NV097_SET_TEXTURE_PALETTE_CONTEXT_DMA_A,
    NV097_SET_TEXTURE_PALETTE_CONTEXT_DMA_B
};

const DWORD nv097VertexContextDma[NV_CONTEXT_DMA_COUNT] =
{
    ~0,
    NV097_SET_VERTEX_DATA_ARRAY_OFFSET_CONTEXT_DMA_VERTEX_A,
    NV097_SET_VERTEX_DATA_ARRAY_OFFSET_CONTEXT_DMA_VERTEX_B,
};
#endif


//--------------------------------------------------------------------------
// D3D conversion stuff
//--------------------------------------------------------------------------

#if (NVARCH >= 0x010)
// note we define these in terms of STENCIL_OP_FAIL, but the values are
// actually the same for STENCIL_OP_ZFAIL and STENCIL_OP_ZPASS
const DWORD nv056StencilOp[D3D_STENCIL_OP_COUNT] =
{
    ~0,                                     // undefined
    NV056_SET_STENCIL_OP_FAIL_V_KEEP,       // D3DSTENCILOP_KEEP    = 1
    NV056_SET_STENCIL_OP_FAIL_V_ZERO,       // D3DSTENCILOP_ZERO    = 2
    NV056_SET_STENCIL_OP_FAIL_V_REPLACE,    // D3DSTENCILOP_REPLACE = 3
    NV056_SET_STENCIL_OP_FAIL_V_INCRSAT,    // D3DSTENCILOP_INCRSAT = 4
    NV056_SET_STENCIL_OP_FAIL_V_DECRSAT,    // D3DSTENCILOP_DECRSAT = 5
    NV056_SET_STENCIL_OP_FAIL_V_INVERT,     // D3DSTENCILOP_INVERT  = 6
    NV056_SET_STENCIL_OP_FAIL_V_INCR,       // D3DSTENCILOP_INCR    = 7
    NV056_SET_STENCIL_OP_FAIL_V_DECR        // D3DSTENCILOP_DECR    = 8
};

// note we define these in terms of STENCIL_OP_FAIL, but the values are
// actually the same for STENCIL_OP_ZFAIL and STENCIL_OP_ZPASS
const DWORD nv097StencilOp[D3D_STENCIL_OP_COUNT] =
{
    ~0,                                     // undefined
    NV097_SET_STENCIL_OP_FAIL_V_KEEP,       // D3DSTENCILOP_KEEP    = 1
    NV097_SET_STENCIL_OP_FAIL_V_ZERO,       // D3DSTENCILOP_ZERO    = 2
    NV097_SET_STENCIL_OP_FAIL_V_REPLACE,    // D3DSTENCILOP_REPLACE = 3
    NV097_SET_STENCIL_OP_FAIL_V_INCRSAT,    // D3DSTENCILOP_INCRSAT = 4
    NV097_SET_STENCIL_OP_FAIL_V_DECRSAT,    // D3DSTENCILOP_DECRSAT = 5
    NV097_SET_STENCIL_OP_FAIL_V_INVERT,     // D3DSTENCILOP_INVERT  = 6
    NV097_SET_STENCIL_OP_FAIL_V_INCR,       // D3DSTENCILOP_INCR    = 7
    NV097_SET_STENCIL_OP_FAIL_V_DECR        // D3DSTENCILOP_DECR    = 8
};

const DWORD nv056StencilFunc[D3D_CMP_FUNC_COUNT] =
{
    ~0,                                     // undefined
    NV056_SET_STENCIL_FUNC_V_NEVER,         // D3DCMP_NEVER        = 1
    NV056_SET_STENCIL_FUNC_V_LESS,          // D3DCMP_LESS         = 2
    NV056_SET_STENCIL_FUNC_V_EQUAL,         // D3DCMP_EQUAL        = 3
    NV056_SET_STENCIL_FUNC_V_LEQUAL,        // D3DCMP_LESSEQUAL    = 4
    NV056_SET_STENCIL_FUNC_V_GREATER,       // D3DCMP_GREATER      = 5
    NV056_SET_STENCIL_FUNC_V_NOTEQUAL,      // D3DCMP_NOTEQUAL     = 6
    NV056_SET_STENCIL_FUNC_V_GEQUAL,        // D3DCMP_GREATEREQUAL = 7
    NV056_SET_STENCIL_FUNC_V_ALWAYS         // D3DCMP_ALWAYS       = 8
};

const DWORD nv097StencilFunc[D3D_CMP_FUNC_COUNT] =
{
    ~0,                                     // undefined
    NV097_SET_STENCIL_FUNC_V_NEVER,         // D3DCMP_NEVER        = 1
    NV097_SET_STENCIL_FUNC_V_LESS,          // D3DCMP_LESS         = 2
    NV097_SET_STENCIL_FUNC_V_EQUAL,         // D3DCMP_EQUAL        = 3
    NV097_SET_STENCIL_FUNC_V_LEQUAL,        // D3DCMP_LESSEQUAL    = 4
    NV097_SET_STENCIL_FUNC_V_GREATER,       // D3DCMP_GREATER      = 5
    NV097_SET_STENCIL_FUNC_V_NOTEQUAL,      // D3DCMP_NOTEQUAL     = 6
    NV097_SET_STENCIL_FUNC_V_GEQUAL,        // D3DCMP_GREATEREQUAL = 7
    NV097_SET_STENCIL_FUNC_V_ALWAYS         // D3DCMP_ALWAYS       = 8
};

const DWORD nv056AlphaFunc[D3D_CMP_FUNC_COUNT] =
{
    ~0,                                     // undefined
    NV056_SET_ALPHA_FUNC_V_NEVER,           // D3DCMP_NEVER        = 1
    NV056_SET_ALPHA_FUNC_V_LESS,            // D3DCMP_LESS         = 2
    NV056_SET_ALPHA_FUNC_V_EQUAL,           // D3DCMP_EQUAL        = 3
    NV056_SET_ALPHA_FUNC_V_LEQUAL,          // D3DCMP_LESSEQUAL    = 4
    NV056_SET_ALPHA_FUNC_V_GREATER,         // D3DCMP_GREATER      = 5
    NV056_SET_ALPHA_FUNC_V_NOTEQUAL,        // D3DCMP_NOTEQUAL     = 6
    NV056_SET_ALPHA_FUNC_V_GEQUAL,          // D3DCMP_GREATEREQUAL = 7
    NV056_SET_ALPHA_FUNC_V_ALWAYS           // D3DCMP_ALWAYS       = 8
};

const DWORD nv097AlphaFunc[D3D_CMP_FUNC_COUNT] =
{
    ~0,                                     // undefined
    NV097_SET_ALPHA_FUNC_V_NEVER,           // D3DCMP_NEVER        = 1
    NV097_SET_ALPHA_FUNC_V_LESS,            // D3DCMP_LESS         = 2
    NV097_SET_ALPHA_FUNC_V_EQUAL,           // D3DCMP_EQUAL        = 3
    NV097_SET_ALPHA_FUNC_V_LEQUAL,          // D3DCMP_LESSEQUAL    = 4
    NV097_SET_ALPHA_FUNC_V_GREATER,         // D3DCMP_GREATER      = 5
    NV097_SET_ALPHA_FUNC_V_NOTEQUAL,        // D3DCMP_NOTEQUAL     = 6
    NV097_SET_ALPHA_FUNC_V_GEQUAL,          // D3DCMP_GREATEREQUAL = 7
    NV097_SET_ALPHA_FUNC_V_ALWAYS           // D3DCMP_ALWAYS       = 8
};

const DWORD nv056DepthFunc[D3D_CMP_FUNC_COUNT] =
{
    ~0,                                     // undefined
    NV056_SET_DEPTH_FUNC_V_NEVER,           // D3DCMP_NEVER        = 1
    NV056_SET_DEPTH_FUNC_V_LESS,            // D3DCMP_LESS         = 2
    NV056_SET_DEPTH_FUNC_V_EQUAL,           // D3DCMP_EQUAL        = 3
    NV056_SET_DEPTH_FUNC_V_LEQUAL,          // D3DCMP_LESSEQUAL    = 4
    NV056_SET_DEPTH_FUNC_V_GREATER,         // D3DCMP_GREATER      = 5
    NV056_SET_DEPTH_FUNC_V_NOTEQUAL,        // D3DCMP_NOTEQUAL     = 6
    NV056_SET_DEPTH_FUNC_V_GEQUAL,          // D3DCMP_GREATEREQUAL = 7
    NV056_SET_DEPTH_FUNC_V_ALWAYS           // D3DCMP_ALWAYS       = 8
};

const DWORD nv097DepthFunc[D3D_CMP_FUNC_COUNT] =
{
    ~0,                                     // undefined
    NV097_SET_DEPTH_FUNC_V_NEVER,           // D3DCMP_NEVER        = 1
    NV097_SET_DEPTH_FUNC_V_LESS,            // D3DCMP_LESS         = 2
    NV097_SET_DEPTH_FUNC_V_EQUAL,           // D3DCMP_EQUAL        = 3
    NV097_SET_DEPTH_FUNC_V_LEQUAL,          // D3DCMP_LESSEQUAL    = 4
    NV097_SET_DEPTH_FUNC_V_GREATER,         // D3DCMP_GREATER      = 5
    NV097_SET_DEPTH_FUNC_V_NOTEQUAL,        // D3DCMP_NOTEQUAL     = 6
    NV097_SET_DEPTH_FUNC_V_GEQUAL,          // D3DCMP_GREATEREQUAL = 7
    NV097_SET_DEPTH_FUNC_V_ALWAYS           // D3DCMP_ALWAYS       = 8
};

// we set these based on NV056 SFACTORs, but NV056 DFACTORs are the same
const DWORD nv056BlendFunc[D3D_BLEND_COUNT] =
{
    ~0,                                                  // undefined
    NV056_SET_BLEND_FUNC_SFACTOR_V_ZERO,                 // D3DBLEND_ZERO            = 1
    NV056_SET_BLEND_FUNC_SFACTOR_V_ONE,                  // D3DBLEND_ONE             = 2
    NV056_SET_BLEND_FUNC_SFACTOR_V_SRC_COLOR,            // D3DBLEND_SRCCOLOR        = 3
    NV056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_COLOR,  // D3DBLEND_INVSRCCOLOR     = 4
    NV056_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA,            // D3DBLEND_SRCALPHA        = 5
    NV056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_ALPHA,  // D3DBLEND_INVSRCALPHA     = 6
    NV056_SET_BLEND_FUNC_SFACTOR_V_DST_ALPHA,            // D3DBLEND_DESTALPHA       = 7
    NV056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_ALPHA,  // D3DBLEND_INVDESTALPHA    = 8
    NV056_SET_BLEND_FUNC_SFACTOR_V_DST_COLOR,            // D3DBLEND_DESTCOLOR       = 9
    NV056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_COLOR,  // D3DBLEND_INVDESTCOLOR    = 10
    NV056_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA_SATURATE,   // D3DBLEND_SRCALPHASAT     = 11
    NV056_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA,            // D3DBLEND_BOTHSRCALPHA    = 12
    NV056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_ALPHA   // D3DBLEND_BOTHINVSRCALPHA = 13
};

// we set these based on NV097 SFACTORs, but NV097 DFACTORs are the same
const DWORD nv097BlendFunc[D3D_BLEND_COUNT] =
{
    ~0,                                                  // undefined
    NV097_SET_BLEND_FUNC_SFACTOR_V_ZERO,                 // D3DBLEND_ZERO            = 1
    NV097_SET_BLEND_FUNC_SFACTOR_V_ONE,                  // D3DBLEND_ONE             = 2
    NV097_SET_BLEND_FUNC_SFACTOR_V_SRC_COLOR,            // D3DBLEND_SRCCOLOR        = 3
    NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_COLOR,  // D3DBLEND_INVSRCCOLOR     = 4
    NV097_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA,            // D3DBLEND_SRCALPHA        = 5
    NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_ALPHA,  // D3DBLEND_INVSRCALPHA     = 6
    NV097_SET_BLEND_FUNC_SFACTOR_V_DST_ALPHA,            // D3DBLEND_DESTALPHA       = 7
    NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_ALPHA,  // D3DBLEND_INVDESTALPHA    = 8
    NV097_SET_BLEND_FUNC_SFACTOR_V_DST_COLOR,            // D3DBLEND_DESTCOLOR       = 9
    NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_COLOR,  // D3DBLEND_INVDESTCOLOR    = 10
    NV097_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA_SATURATE,   // D3DBLEND_SRCALPHASAT     = 11
    NV097_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA,            // D3DBLEND_BOTHSRCALPHA    = 12
    NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_ALPHA   // D3DBLEND_BOTHINVSRCALPHA = 13
};

// New DX8 blend operations
const DWORD nv056BlendOp[D3D_BLEND_OP_COUNT] = {
    ~0,
    NV056_SET_BLEND_EQUATION_V_FUNC_ADD,                     // D3DBLENDOP_ADD
    NV056_SET_BLEND_EQUATION_V_FUNC_SUBTRACT,                // D3DBLENDOP_SUBTRACT
    NV056_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT,        // D3DBLENDOP_REVSUBTRACT
    NV056_SET_BLEND_EQUATION_V_MIN,                          // D3DBLENDOP_MIN
    NV056_SET_BLEND_EQUATION_V_MAX                           // D3DBLENDOP_MAX
};

const DWORD nv097BlendOp[D3D_BLEND_OP_COUNT] = {
    ~0,
    NV097_SET_BLEND_EQUATION_V_FUNC_ADD,                     // D3DBLENDOP_ADD
    NV097_SET_BLEND_EQUATION_V_FUNC_SUBTRACT,                // D3DBLENDOP_SUBTRACT
    NV097_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT,        // D3DBLENDOP_REVSUBTRACT
    NV097_SET_BLEND_EQUATION_V_MIN,                          // D3DBLENDOP_MIN
    NV097_SET_BLEND_EQUATION_V_MAX                           // D3DBLENDOP_MAX
};

// these are defined in terms of TEXTUREADDRESSU, but values for TEXTUREADDRESSV are the same
const DWORD nv056TextureAddress[D3D_TADDRESS_COUNT] =
{
    ~0,                                                  // undefined
    NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_WRAP,       // D3DTADDRESS_WRAP     = 1
    NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_MIRROR,     // D3DTADDRESS_MIRROR   = 2
    NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP,      // D3DTADDRESS_CLAMP    = 3
    NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_WRAP        // D3DTADDRESS_BORDER   = 4
};

#if (NVARCH >= 0x020)
// these are defined in terms of TEXTUREADDRESSU, but values for TEXTUREADDRESSV are the same
const DWORD nv097TextureAddress[D3D_TADDRESS_COUNT] =
{
    ~0,                                                  // undefined
    NV097_SET_TEXTURE_ADDRESS_U_WRAP,                    // D3DTADDRESS_WRAP     = 1
    NV097_SET_TEXTURE_ADDRESS_U_MIRROR,                  // D3DTADDRESS_MIRROR   = 2
    NV097_SET_TEXTURE_ADDRESS_U_CLAMP_TO_EDGE,           // D3DTADDRESS_CLAMP    = 3
    NV097_SET_TEXTURE_ADDRESS_U_BORDER                   // D3DTADDRESS_BORDER   = 4
};
#endif

const DWORD nv056TextureMagFilter[D3D_MAGFILTER_COUNT] =
{
    ~0,                                                  // undefined
    NV056_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST,         // D3DTFG_POINT         = 1
    NV056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR,          // D3DTFG_LINEAR        = 2
    NV056_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST,         // D3DTFG_FLATCUBIC     = 3
    NV056_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST,         // D3DTFG_GAUSSIANCUBIC = 4
    NV056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR,          // D3DTFG_ANISOTROPIC   = 5  (Mag aniso is bilinear in HW, and this passes WHQL.)
};

#if (NVARCH >= 0x020)
const DWORD nv097TextureMagFilter[D3D_MAGFILTER_COUNT] =
{
    ~0,                                                  // undefined
    NV097_SET_TEXTURE_FILTER_MAG_BOX_LOD0,               // D3DTFG_POINT         = 1
    NV097_SET_TEXTURE_FILTER_MAG_TENT_LOD0,              // D3DTFG_LINEAR        = 2
    NV097_SET_TEXTURE_FILTER_MAG_BOX_LOD0,               // D3DTFG_FLATCUBIC     = 3
    NV097_SET_TEXTURE_FILTER_MAG_BOX_LOD0,               // D3DTFG_GAUSSIANCUBIC = 4
    ~0                                                   // D3DTFG_ANISOTROPIC   = 5  (invalid. we have to deal with this separately)
};
#endif

// notes on these values:
// in openGL, foo_mipmap_bar means:
// - use the 'foo' filter within mipmaps
// - use the 'bar' filter between mipmaps
// stupid DX5 (and hence the HW definitions) were/are reversed

const DWORD nv056TextureMinFilter[D3D_MINFILTER_COUNT][D3D_MIPFILTER_COUNT] =
{
    // minfilter = 0 (undefined)
    ~0,                                                   // undefined
    ~0,                                                   // D3DTFP_NONE    = 1
    ~0,                                                   // D3DTFP_POINT   = 2
    ~0,                                                   // D3DTFP_LINEAR  = 3

    // D3DTFN_POINT       = 1
    NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR,           // undefined (use default? HMH)
    NV056_SET_TEXTURE_FILTER_TEXTUREMIN_NEAREST,          // D3DTFP_NONE    = 1
    NV056_SET_TEXTURE_FILTER_TEXTUREMIN_MIPNEAREST,       // D3DTFP_POINT   = 2
    NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPNEAREST, // D3DTFP_LINEAR  = 3

    // D3DTFN_LINEAR      = 2
    NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR,           // undefined (use default)
    NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR,           // D3DTFP_NONE    = 1
    NV056_SET_TEXTURE_FILTER_TEXTUREMIN_MIPLINEAR,        // D3DTFP_POINT   = 2
    NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPLINEAR,  // D3DTFP_LINEAR  = 3

    // D3DTFN_ANISOTROPIC = 3 (invalid. we have to deal with this separately)
    ~0,                                                   // undefined
    ~0,                                                   // D3DTFP_NONE    = 1
    ~0,                                                   // D3DTFP_POINT   = 2
    ~0,                                                   // D3DTFP_LINEAR  = 3
};

#if (NVARCH >= 0x020)
const DWORD nv097TextureMinFilter[D3D_MINFILTER_COUNT][D3D_MIPFILTER_COUNT] =
{
    // minfilter = 0 (undefined)
    ~0,                                                   // undefined
    ~0,                                                   // D3DTFP_NONE    = 1
    ~0,                                                   // D3DTFP_POINT   = 2
    ~0,                                                   // D3DTFP_LINEAR  = 3

    // D3DTFN_POINT       = 1
    ~0,                                                   // undefined
    NV097_SET_TEXTURE_FILTER_MIN_BOX_LOD0,                // D3DTFP_NONE    = 1
    NV097_SET_TEXTURE_FILTER_MIN_BOX_NEARESTLOD,          // D3DTFP_POINT   = 2
    NV097_SET_TEXTURE_FILTER_MIN_BOX_TENT_LOD,            // D3DTFP_LINEAR  = 3

    // D3DTFN_LINEAR      = 2
    NV097_SET_TEXTURE_FILTER_MIN_TENT_LOD0,               // undefined (use default)
    NV097_SET_TEXTURE_FILTER_MIN_TENT_LOD0,               // D3DTFP_NONE    = 1
    NV097_SET_TEXTURE_FILTER_MIN_TENT_NEARESTLOD,         // D3DTFP_POINT   = 2
    NV097_SET_TEXTURE_FILTER_MIN_TENT_TENT_LOD,           // D3DTFP_LINEAR  = 3

    // D3DTFN_ANISOTROPIC = 3 (invalid. we have to deal with this separately)
    ~0,                                                   // undefined
    ~0,                                                   // D3DTFP_NONE    = 1
    ~0,                                                   // D3DTFP_POINT   = 2
    ~0,                                                   // D3DTFP_LINEAR  = 3
};

#endif  // NVARCH >= 0x020

const DWORD dx8MinFilterMapping[] =
{
    ~0,                   // D3DTEXF_NONE
    D3DTFN_POINT,         // D3DTEXF_POINT
    D3DTFN_LINEAR,        // D3DTEXF_LINEAR
    D3DTFN_ANISOTROPIC,   // D3DTEXF_ANISOTROPIC
    ~0,                   // D3DTEXF_FLATCUBIC
    ~0                    // D3DTEXF_GAUSSIANCUBIC
};

const DWORD dx8MagFilterMapping[] =
{
    ~0,                   // D3DTEXF_NONE
    D3DTFG_POINT,         // D3DTEXF_POINT
    D3DTFG_LINEAR,        // D3DTEXF_LINEAR
    D3DTFG_ANISOTROPIC,   // D3DTEXF_ANISOTROPIC
    D3DTFG_FLATCUBIC,     // D3DTEXF_FLATCUBIC
    D3DTFG_GAUSSIANCUBIC  // D3DTEXF_GAUSSIANCUBIC
};

const DWORD dx8MipFilterMapping[] =
{
    D3DTFP_NONE,          // D3DTEXF_NONE
    D3DTFP_POINT,         // D3DTEXF_POINT
    D3DTFP_LINEAR,        // D3DTEXF_LINEAR
    ~0,                   // D3DTEXF_ANISOTROPIC
    ~0,                   // D3DTEXF_FLATCUBIC
    ~0                    // D3DTEXF_GAUSSIANCUBIC
};

//---------------------------------------------------------------------------

// mappings between vertex attributes, streams, and HW registers

// map positions of D3D vertex attributes to indices in the driver's
// vertex attribute array and the HW's fixed-pipe input registers

const DWORD defaultInputRegMap[D3D_INPUTREGMAP_COUNT] = {
       // Microsoft                             -> NV fixed pipe mapping
    0, // D3DVSDE_POSITION     0  Position         Param[0]   Position            X,Y,Z,W
    1, // D3DVSDE_BLENDWEIGHT  1  BlendWeight      Param[1]   Skin Weights        W,W,W,W
    5, // D3DVSDE_BLENDINDICES 2  BlendIndices     Param[5]   Fog(OGL)            F,*,*,*
    2, // D3DVSDE_NORMAL       3  Normal           Param[2]   Normal              X,Y,Z,*
    6, // D3DVSDE_PSIZE        4  PointSize        Param[6]   Point Size          P,*,*,*
    3, // D3DVSDE_DIFFUSE      5  Diffuse          Param[3]   Diffuse Color       R,G,B,A
    4, // D3DVSDE_SPECULAR     6  Specular         Param[4]   Specular Color      R,G,B,A
    9, // D3DVSDE_TEXCOORD0    7  Texcoord0        Param[9]   Texture0            S,T,R,Q
   10, // D3DVSDE_TEXCOORD1    8  Texcoord1        Param[10]  Texture1            S,T,R,Q
   11, // D3DVSDE_TEXCOORD2    9  Texcoord2        Param[11]  Texture2            S,T,R,Q
   12, // D3DVSDE_TEXCOORD3    10 Texcoord3        Param[12]  Texture3            S,T,R,Q
   13, // D3DVSDE_TEXCOORD4    11 Texcoord4        Param[13]  Texture4            S,T,R,Q
   14, // D3DVSDE_TEXCOORD5    12 Texcoord5        Param[14]  Texture5            S,T,R,Q
   15, // D3DVSDE_TEXCOORD6    13 Texcoord6        Param[15]  Texture6            S,T,R,Q
    7, // D3DVSDE_TEXCOORD7    14 Texcoord7        Param[7]   Texture7            S,T,R,Q
    8, // D3DVSDE_POSITION2    15 n/a              Param[8]   unused              *,*,*,*
    8, // D3DVSDE_NORMAL2      16 n/a              Param[8]   unused              *,*,*,*
};

// map output of MS shader program to HW's vertex shader output registers

const DWORD defaultOutputRegMap[D3D_OUTPUTREGMAP_COUNT] = {
    0, // 0  vertex
    3, // 1  diffuse
    4, // 2  specular
    7, // 3  backfacing diffuse - unused
    8, // 4  backfacing specular - unused
    5, // 5  fog
    6, // 6  point size
    9, // 7  texture 0
   10, // 8  texture 1
   11, // 9  texture 2
   12, // 10 texture 3
   13, // 11 texture 4 (undefined in NV20)
   14, // 12 texture 5 (undefined in NV20)
   15, // 13 texture 6 (undefined in NV20)
    1, // 14 undefined in NV20
    2, // 15 undefined in NV20
};

#endif  // NVARCH >= 0x010

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvSwiz.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvSwiz.cpp                                                        *
*   Texture swizzling routines (some HW dependence).                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 10/20/98 - wrote it                     *
*       Ben de Waal                 07/07/99 - rewrote it                   *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#include "x86.h"

// swizzling flags
#define NV_SWIZFLAG_SRCLINEAR       0x00000000
#define NV_SWIZFLAG_SRCSWIZZLED     0x00000001
#define NV_SWIZFLAG_DESTLINEAR      0x00000000
#define NV_SWIZFLAG_DESTSWIZZLED    0x00000002
#define NV_SWIZFLAG_PALETTIZED      0x00000004
#define NV_SWIZFLAG_ALLOWHW         0x80000000

#define NV_SWIZVAL_MAX              16

BOOL nvSwizzleBlt (DWORD     dwSrcAddr,
                   DWORD     dwSrcAlloc,
                   DWORD     dwSrcLogW,
                   DWORD     dwSrcLogH,
                   DWORD     dwSrcX0,
                   DWORD     dwSrcY0,
                   DWORD     dwSrcX1,
                   DWORD     dwSrcY1,
                   DWORD     dwSrcPitch,
                   CTexture *pSrcTexture,  /* may be NULL if no texture is involved */
                   DWORD     dwDestAddr,
                   DWORD     dwDestAlloc,
                   DWORD     dwDestLogW,
                   DWORD     dwDestLogH,
                   DWORD     dwDestX,
                   DWORD     dwDestY,
                   DWORD     dwDestPitch,
                   CTexture *pDestTexture, /* may be NULL if no texture is involved */
                   DWORD     dwBPP,
                   DWORD     dwFlags);



/*
 * constants
 */
#define L2MB        5
#define MB          (1<<L2MB)   // swizzle macroblock size

#define MB_UMASK    ((MB*MB-1) & 0x55555555)
#define MB_VMASK    ((MB*MB-1) & 0xaaaaaaaa)

/*
 * macros
 */
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

#define TEXELCOPY(d,s,bpp)                            \
{                                                     \
    if ((bpp) == 2) *(WORD*)(d)  = *(WORD*)(s);       \
    else if ((bpp) == 4) *(DWORD*)(d) = *(DWORD*)(s); \
    else *(BYTE*)(d)  = *(BYTE*)(s);                  \
}

#define PREF_POLICY 0
#define NUM_LINES 2
#define movaps_r_rm8(r,rm,ofs)      __asm _emit 0x0f __asm _emit 0x28 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movaps_rm8_r(rm,ofs,r)      __asm _emit 0x0f __asm _emit 0x29 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movups_r_rm8(r,rm,ofs)      __asm _emit 0x0f __asm _emit 0x10 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movups_rm8_r(rm,ofs,r)      __asm _emit 0x0f __asm _emit 0x11 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define prefetch_rm8(h,rm,ofs)      __asm _emit 0x0f __asm _emit 0x18 __asm _emit (mREG(h) | (rm)) __asm _emit (ofs)
#define _femms                      __asm _emit 0x0f __asm _emit 0x0e

// Prefetch the first couple of lines of a macro block for the Texture Blt code
// This handles 16bpp textures

__forceinline void MB_prefetch16(DWORD dwSrcBase, DWORD dwSrcPitch)
{
#ifdef PREFETCH_TESTING
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_PREFETCH)
    {
        __asm
        {
            mov eax,[dwSrcBase]
    #if (NUM_LINES > 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
    #endif
    #if (NUM_LINES > 1)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
    #endif
    #if (NUM_LINES > 2)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
    #endif
    #if (NUM_LINES > 3)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
    #endif
    #if (NUM_LINES > 4)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
    #endif
    #if (NUM_LINES > 5)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
    #endif
    #if (NUM_LINES > 6)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
    #endif
    #if (NUM_LINES > 7)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
    #endif
        }
    }
#else
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & (FS_WILLAMETTE | FS_ATHLON))
    {
        __asm
        {
            mov eax,[dwSrcBase]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
        }
    }
    else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
    {
        __asm
        {
            mov eax,[dwSrcBase]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
        }

    }


#endif

}

// Prefetch the first couple of lines of a macro block for the Texture Blt code
// This handles 32bpp textures

__forceinline void MB_prefetch32(DWORD dwSrcBase, DWORD dwSrcPitch)
{
#ifdef PREFETCH_TESTING
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_PREFETCH)
    {
        __asm
        {
            mov eax,[dwSrcBase]
    #if (NUM_LINES > 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 96)
    #endif
    #if (NUM_LINES > 1)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 96)
    #endif
    #if (NUM_LINES > 2)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 96)
    #endif
    #if (NUM_LINES > 3)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 96)
    #endif
    #if (NUM_LINES > 4)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 96)
    #endif
    #if (NUM_LINES > 5)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 96)
    #endif
    #if (NUM_LINES > 6)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 96)
    #endif
    #if (NUM_LINES > 7)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 96)
    #endif
    #if (NUM_LINES > 8)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 96)
    #endif
        }
    }
#else
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & (FS_WILLAMETTE | FS_ATHLON))
    {
        __asm
        {
            mov eax,[dwSrcBase]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
        }
    }
    else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
    {
        __asm
        {
            mov eax,[dwSrcBase]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 96)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 96)
        }
    }
#endif
}


/*
 * swizzle table buffer layout
 */
BYTE nvTexelScratchBuffer[8192];  // must be as wide as the widest pitch (4 * 2048 = 8192)

/*****************************************************************************
 * swizzle address generation
 *****************************************************************************/
struct SWIZZLE_ADDR
{
    DWORD dwBase;
    DWORD dwOffset;
    DWORD dwLine;

    DWORD dwDUDXOr;
    DWORD dwDUDXAnd;
    DWORD dwDUDXAdd;

    DWORD dwDVDYOr;
    DWORD dwDVDYAnd;
    DWORD dwDVDYAdd;
};

__inline DWORD nvSwizzleAddrGet (SWIZZLE_ADDR *lpSA)
{
    return lpSA->dwBase + lpSA->dwOffset;
}

__inline void nvSwizzleAddrNext (SWIZZLE_ADDR *lpSA)
{
    DWORD u,v;

    u              = ((lpSA->dwOffset | lpSA->dwDUDXOr) + lpSA->dwDUDXAdd) & lpSA->dwDUDXAnd;
    v              =   lpSA->dwOffset & lpSA->dwDVDYAnd;
    lpSA->dwOffset = u | v;
}

__inline void nvSwizzleAddrNewLine (SWIZZLE_ADDR *lpSA)
{
    DWORD u,v;

    u            =   lpSA->dwLine & lpSA->dwDUDXAnd;
    v            = ((lpSA->dwLine | lpSA->dwDVDYOr) + lpSA->dwDVDYAdd) & lpSA->dwDVDYAnd;
    lpSA->dwLine = lpSA->dwOffset = u | v;
}

void nvSwizzleAddrCreate
(
    SWIZZLE_ADDR *lpSA,
    DWORD         dwBase,
    DWORD         dwX,
    DWORD         dwY,
    DWORD         dwLogW,
    DWORD         dwLogH,
    DWORD         dwBPP
)
{
    if (!dwLogW)
    {
        lpSA->dwBase    = dwBase;
        lpSA->dwOffset  = lpSA->dwLine
                        = dwY * dwBPP;
        lpSA->dwDUDXAnd = 0;
        lpSA->dwDUDXOr  = 0;
        lpSA->dwDUDXAdd = 0;
        lpSA->dwDVDYAnd = ~0;
        lpSA->dwDVDYOr  = 0;
        lpSA->dwDVDYAdd = dwBPP;
    }
    else if (!dwLogH)
    {
        lpSA->dwBase    = dwBase;
        lpSA->dwOffset  = lpSA->dwLine
                        = dwX * dwBPP;
        lpSA->dwDUDXAnd = ~0;
        lpSA->dwDUDXOr  = 0;
        lpSA->dwDUDXAdd = dwBPP;
        lpSA->dwDVDYAnd = 0;
        lpSA->dwDVDYOr  = 0;
        lpSA->dwDVDYAdd = 0;
    }
    else
    {
        DWORD dwLog       = min(dwLogW,dwLogH);
        DWORD dw2Log      = dwLog << 1;            // # of bits to interleave
        DWORD dwUpperMask = ~((1 << dw2Log) - 1);  // bits to preserve
        DWORD dwLowerMask = ~dwUpperMask;          // bits to interleave

        /*
         * calc offset
         */
        DWORD dwUpperU    = (dwX << dwLog) & dwUpperMask;
        DWORD dwUpperV    = (dwY << dwLog) & dwUpperMask;

        DWORD dwLower     = ((dwX & 0x001) <<  0) | ((dwY & 0x001) <<  1)
                          | ((dwX & 0x002) <<  1) | ((dwY & 0x002) <<  2)
                          | ((dwX & 0x004) <<  2) | ((dwY & 0x004) <<  3)
                          | ((dwX & 0x008) <<  3) | ((dwY & 0x008) <<  4)
                          | ((dwX & 0x010) <<  4) | ((dwY & 0x010) <<  5)
                          | ((dwX & 0x020) <<  5) | ((dwY & 0x020) <<  6)
                          | ((dwX & 0x040) <<  6) | ((dwY & 0x040) <<  7)
                          | ((dwX & 0x080) <<  7) | ((dwY & 0x080) <<  8)
                          | ((dwX & 0x100) <<  8) | ((dwY & 0x100) <<  9)
                          | ((dwX & 0x200) <<  9) | ((dwY & 0x200) << 10)
                          | ((dwX & 0x400) << 10) | ((dwY & 0x400) << 11)
                          | ((dwX & 0x800) << 11) | ((dwY & 0x800) << 12);

        lpSA->dwBase   = dwBase;
        lpSA->dwOffset = lpSA->dwLine
                       = ((dwLower & dwLowerMask) | dwUpperU | dwUpperV) * dwBPP;

        /*
         * calc masks
         */
        lpSA->dwDUDXOr  = (0xaaaaaaaa & dwLowerMask) * dwBPP;
        lpSA->dwDUDXAnd = ((dwLogW > dwLogH) ? (0x55555555 | dwUpperMask)
                                             : (0x55555555 & dwLowerMask)) * dwBPP;
        lpSA->dwDUDXAdd = dwBPP;
        lpSA->dwDVDYOr  = (0x55555555 & dwLowerMask) * dwBPP;
        lpSA->dwDVDYAnd = ((dwLogW < dwLogH) ? (0xaaaaaaaa | dwUpperMask)
                                             : (0xaaaaaaaa & dwLowerMask)) * dwBPP;
        lpSA->dwDVDYAdd = dwBPP << 1;
    }
}

/*
 * SOFTWARE SWIZZLE
 * ----------------
 */

/*
 * nvSwizzleSmallBlock
 *
 * swizzles any texture with a dimension less than 8 (i.e. 2048 x 4)
 */
void nvSwizzleSmallBlock
(
    DWORD dwSrcBase,
    DWORD dwSrcPitch,

    DWORD dwDestBase,

    DWORD dwLogW,
    DWORD dwLogH,
    DWORD dwBPP
)
{
    SWIZZLE_ADDR sa;
    DWORD        dwCount,dwSize,dwLine;
    DWORD        dwScratch0,dwScratch1;
    DWORD        x,y;
    void        *pMemory;

    /*
     * figure out memory requirements
     */
    dwCount = 1     << (dwLogW + dwLogH);
    dwSize  = dwBPP << (dwLogW + dwLogH);
    if (dwSize > 4096)
    {
        pMemory = AllocIPM(dwSize * 2);
        dwScratch0 = (DWORD)pMemory;
        dwScratch1 = ((DWORD)pMemory) + dwSize;
    }
    else
    {
        pMemory    = NULL;
        dwScratch0 = (DWORD)(nvTexelScratchBuffer + 0);
        dwScratch1 = (DWORD)(nvTexelScratchBuffer + 4096);
    }

    /*
     * read texels
     */
    dwLine = dwBPP << dwLogW;
    if (dwLine != dwSrcPitch)
    {
        DWORD u = dwSrcBase;
        DWORD v = dwScratch0;
        for (y = (1 << dwLogH); y; y--)
        {
            nvMemCopy (v,u,dwLine);
            v += dwLine;
            u += dwSrcPitch;
        }
    }
    else
    {
        nvMemCopy (dwScratch0,dwSrcBase,dwLine << dwLogH);
    }

    /*
     * prepare swizzle address generation
     */
    nvSwizzleAddrCreate (&sa,dwScratch1,0,0,dwLogW,dwLogH,dwBPP);

    /*
     * do swizzle
     */
    switch (dwBPP)
    {
        case 1:
        {
            for (y = (1 << dwLogH); y; y--)
            {
                for (x = (1 << dwLogW); x; x--)
                {
                    *(BYTE*)nvSwizzleAddrGet(&sa) = *(BYTE*)dwScratch0;

                    dwScratch0 += 1;
                    nvSwizzleAddrNext (&sa);
                }
                nvSwizzleAddrNewLine (&sa);
            }
            break;
        }
        case 2:
        {
            for (y = (1 << dwLogH); y; y--)
            {
                for (x = (1 << dwLogW); x; x--)
                {
                    *(WORD*)nvSwizzleAddrGet(&sa) = *(WORD*)dwScratch0;

                    dwScratch0 += 2;
                    nvSwizzleAddrNext (&sa);
                }
                nvSwizzleAddrNewLine (&sa);
            }
            break;
        }
        case 4:
        {
            for (y = (1 << dwLogH); y; y--)
            {
                for (x = (1 << dwLogW); x; x--)
                {
                    *(DWORD*)nvSwizzleAddrGet(&sa) = *(DWORD*)dwScratch0;

                    dwScratch0 += 4;
                    nvSwizzleAddrNext (&sa);
                }
                nvSwizzleAddrNewLine (&sa);
            }
            break;
        }
    }

    /*
     * write texels
     */
    nvMemCopy (dwDestBase,dwScratch1,dwSize);

    /*
     * free memory
     */
    if (pMemory) FreeIPM (pMemory);
}

/*
 * nvSwizzleMacroBlock_LS
 *
 * swizzles a full MBxMB block (lin -> swz)
 */
void nvSwizzleMacroBlock_LS
(
    DWORD dwSrcBase,
    DWORD dwSrcPitch,
    DWORD dwDestBase,
    DWORD dwBPP
)
{
    DWORD numLines = (pDriverData->nvD3DPerfData.dwCPUFeatureSet & (FS_WILLAMETTE | FS_ATHLON)) ? 3 : 2;

    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_PREFETCH)
    {
        switch (dwBPP)
        {
            case 1:
            {
                break;  //falling through to default supporrt
                        //TODO add KNI support for 8 bpp textures
            }
            case 2: // 16bpp Pentium3
            {

                {
                    DWORD src = dwSrcBase;
                    DWORD pref = src+numLines*dwSrcPitch;
                    DWORD dst = (DWORD)nvTexelScratchBuffer;
                    DWORD v = 0;
                    DWORD y;

                    for (y = MB; y; y--)
                    {
                        DWORD addr;

                        addr  = src;
                        src  += dwSrcPitch;

#define NXT1(u)  ((((u) | (MB_VMASK*2)) + 1*2) & (MB_UMASK*2))
#define NXT2(u)  NXT1(NXT1(u))
#define NXT4(u)  NXT2(NXT2(u))
#define NXT8(u)  NXT4(NXT4(u))
#define NXT16(u) NXT8(NXT8(u))
#define NXT32(u) NXT16(NXT16(u))

                        // MB assumed to be 32
                        __asm {
                            push esi
                            push edi
                            push ebx

                        // load 8 texels
                            mov eax,[addr]
                            mov ebx,[eax]
                            mov ecx,[eax + 4]
                            mov edx,[eax + 8]
                            mov edi,[eax + 12]

                            mov eax,[v]

                            mov esi,eax
                          //or esi,0
                            add esi,[dst]
                            mov [esi],ebx // 2 at a time

                            mov esi,eax
                            or  esi,NXT2(0)
                            add esi,[dst]
                            mov [esi],ecx

                            mov esi,eax
                            or  esi,NXT4(0)
                            add esi,[dst]
                            mov [esi],edx

                            mov esi,eax
                            or  esi,NXT4(NXT2(0))
                            add esi,[dst]
                            mov [esi],edi

                        // 8 more texels
                            mov eax,[addr]
                            mov ebx,[eax + 16]
                            mov ecx,[eax + 20]
                            mov edx,[eax + 24]
                            mov edi,[eax + 28]

                            mov eax,[v]

                            mov esi,eax
                            or  esi,NXT8(0)
                            add esi,[dst]
                            mov [esi],ebx // 2 at a time

                            mov esi,eax
                            or  esi,NXT8(NXT2(0))
                            add esi,[dst]
                            mov [esi],ecx

                            mov esi,eax
                            or  esi,NXT8(NXT4(0))
                            add esi,[dst]
                            mov [esi],edx

                            mov esi,eax
                            or  esi,NXT8(NXT4(NXT2(0)))
                            add esi,[dst]
                            mov [esi],edi

                        // 8 more texels
                            mov eax,[addr]
                            mov ebx,[eax + 32]
                            mov ecx,[eax + 36]
                            mov edx,[eax + 40]
                            mov edi,[eax + 44]

                            mov eax,[v]

                            mov esi,eax
                            or  esi,NXT16(0)
                            add esi,[dst]
                            mov [esi],ebx // 2 at a time

                            mov esi,eax
                            or  esi,NXT16(NXT2(0))
                            add esi,[dst]
                            mov [esi],ecx

                            mov esi,eax
                            or  esi,NXT16(NXT4(0))
                            add esi,[dst]
                            mov [esi],edx

                            mov esi,eax
                            or  esi,NXT16(NXT4(NXT2(0)))
                            add esi,[dst]
                            mov [esi],edi

                        // 8 more texels
                            mov eax,[addr]
                            mov ebx,[eax + 48]
                            mov ecx,[eax + 52]
                            mov edx,[eax + 56]
                            mov edi,[eax + 60]

                            mov eax,[v]

                            mov esi,eax
                            or  esi,NXT16(NXT8(0))
                            add esi,[dst]
                            mov [esi],ebx // 2 at a time

                            mov esi,eax
                            or  esi,NXT16(NXT8(NXT2(0)))
                            add esi,[dst]
                            mov [esi],ecx

                            mov esi,eax
                            or  esi,NXT16(NXT8(NXT4(0)))
                            add esi,[dst]
                            mov [esi],edx

                            mov esi,eax
                            or  esi,NXT16(NXT8(NXT4(NXT2(0))))
                            add esi,[dst]
                            mov [esi],edi
#if (NUM_LINES > 0)
                            mov ecx,[pref]
                            prefetch_rm8 (PREF_POLICY,rmIND8(rECX), 0)
                            prefetch_rm8 (PREF_POLICY,rmIND8(rECX),32)
                            add ecx, [dwSrcPitch]
                            mov [pref], ecx
#endif

                            pop ebx
                            pop edi
                            pop esi
                        }

                        v = ((v | (MB_UMASK*2)) + 2*2) & (MB_VMASK*2);
                    }

                    nvMemCopy (dwDestBase,(DWORD)nvTexelScratchBuffer,MB*MB*2);
                }

                return;
            }

            case 4:
            {
                DWORD src = dwSrcBase;
                DWORD pref = src+numLines*dwSrcPitch;
                DWORD dst = (DWORD)nvTexelScratchBuffer;
                DWORD v = 0;
                DWORD y;

                if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
                {
                    _femms
                }
                for (y = MB; y; y--)
                {
                    DWORD u;
                    DWORD addr;

                    addr  = src;
                    src  += dwSrcPitch;

                    u = 0;
#undef NXT1
#undef NXT2
#undef NXT4
#undef NXT8
#undef NXT16
#undef NXT32
#define NXT1(u)  ((((u) | (MB_VMASK*4)) + 1*4) & (MB_UMASK*4))
#define NXT2(u)  NXT1(NXT1(u))
#define NXT4(u)  NXT2(NXT2(u))
#define NXT8(u)  NXT4(NXT4(u))
#define NXT16(u) NXT8(NXT8(u))
#define NXT32(u) NXT16(NXT16(u))
                        __asm {
                            push esi
                            push edi
                            push ebx

#if (NUM_LINES == 0)
                            mov ecx,[pref]
                            prefetch_rm8 (PREF_POLICY,rmIND8(rECX), 0)
                            prefetch_rm8 (PREF_POLICY,rmIND8(rECX),32)
                            prefetch_rm8 (PREF_POLICY,rmIND8(rECX), 64)
                            prefetch_rm8 (PREF_POLICY,rmIND8(rECX), 96)
                            add ecx, [dwSrcPitch]
                            mov [pref], ecx
#endif
                        // load 8 texels
                            mov eax,[addr]
                            movq    mm0 ,[eax]
                            movq    mm1,[eax + 8]
                            movq    mm2,[eax + 16]
                            movq    mm3,[eax + 24]

                            mov eax,[v]

                            mov esi,eax
                          //or esi,0
                            add esi,[dst]
                            movq [esi],mm0 // 2 at a time

                            mov esi,eax
                            or  esi,NXT2(0)
                            add esi,[dst]
                            movq [esi],mm1

                            mov esi,eax
                            or  esi,NXT4(0)
                            add esi,[dst]
                            movq [esi],mm2

                            mov esi,eax
                            or  esi,NXT4(NXT2(0))
                            add esi,[dst]
                            movq [esi],mm3

                        // 8 more texels
                            mov eax,[addr]
                            movq mm0,[eax + 32]
                            movq mm1,[eax + 40]
                            movq mm2,[eax + 48]
                            movq mm3,[eax + 56]

                            mov eax,[v]

                            mov esi,eax
                            or  esi,NXT8(0)
                            add esi,[dst]
                            movq [esi],mm0 // 2 at a time

                            mov esi,eax
                            or  esi,NXT8(NXT2(0))
                            add esi,[dst]
                            movq [esi],mm1

                            mov esi,eax
                            or  esi,NXT8(NXT4(0))
                            add esi,[dst]
                            movq [esi],mm2

                            mov esi,eax
                            or  esi,NXT8(NXT4(NXT2(0)))
                            add esi,[dst]
                            movq [esi],mm3


                        // 8 more texels
                            mov eax,[addr]
                            movq mm0,[eax + 64]
                            movq mm1,[eax + 72]
                            movq mm2,[eax + 80]
                            movq mm3,[eax + 88]

                            mov eax,[v]

                            mov esi,eax
                            or  esi,NXT16(0)
                            add esi,[dst]
                            movq [esi],mm0 // 2 at a time

                            mov esi,eax
                            or  esi,NXT16(NXT2(0))
                            add esi,[dst]
                            movq [esi],mm1

                            mov esi,eax
                            or  esi,NXT16(NXT4(0))
                            add esi,[dst]
                            movq [esi],mm2

                            mov esi,eax
                            or  esi,NXT16(NXT4(NXT2(0)))
                            add esi,[dst]
                            movq [esi],mm3


                            // 8 more texels
                            mov eax,[addr]
                            movq mm0,[eax + 96]
                            movq mm1,[eax + 104]
                            movq mm2,[eax + 112]
                            movq mm3,[eax + 120]

                            mov eax,[v]

                            mov esi,eax
                            or  esi,NXT16(NXT8(0))
                            add esi,[dst]
                            movq [esi],mm0 // 2 at a time

                            mov esi,eax
                            or  esi,NXT16(NXT8(NXT2(0)))
                            add esi,[dst]
                            movq [esi],mm1

                            mov esi,eax
                            or  esi,NXT16(NXT8(NXT4(0)))
                            add esi,[dst]
                            movq [esi],mm2

                            mov esi,eax
                            or  esi,NXT16(NXT8(NXT4(NXT2(0))))
                            add esi,[dst]
                            movq [esi],mm3

#if (NUM_LINES > 0)
                            mov ecx,[pref]
                            prefetch_rm8 (PREF_POLICY,rmIND8(rECX), 0)
                            prefetch_rm8 (PREF_POLICY,rmIND8(rECX),32)
                            prefetch_rm8 (PREF_POLICY,rmIND8(rECX), 64)
                            prefetch_rm8 (PREF_POLICY,rmIND8(rECX), 96)
                            add ecx, [dwSrcPitch]
                            mov [pref], ecx
#endif

                            pop ebx
                            pop edi
                            pop esi
                        }
                    v = ((v | (MB_UMASK*4)) + 2*4) & (MB_VMASK*4);
                }

                nvMemCopy (dwDestBase,(DWORD)nvTexelScratchBuffer,MB*MB*4);
                if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
                {
                    _femms
                }
                else
                __asm { emms };
                return;
            }


        }
    }

    /*
     * default code
     */
    switch (dwBPP)
    {
        case 1:
        {
            DWORD src = dwSrcBase;
            DWORD dst = (DWORD)nvTexelScratchBuffer;
            DWORD v = 0;
            DWORD y;

            for (y = MB; y; y--)
            {
                DWORD u,x;
                DWORD addr;

                addr  = src;
                src  += dwSrcPitch;

                u = 0;
                for (x = MB; x; x--)
                {
                    DWORD store = dst + (u | v) * 1;
                    *(BYTE*)store = *(BYTE*)addr;

                    addr += 1;
                    u     = ((u | (MB_VMASK*1)) + 1*1) & (MB_UMASK*1);
                }
                v = ((v | (MB_UMASK*1)) + 2*1) & (MB_VMASK*1);
            }

            nvMemCopy (dwDestBase,(DWORD)nvTexelScratchBuffer,MB*MB*1);
            break;
        }

        case 2:
        {
            DWORD src = dwSrcBase;
            DWORD dst = (DWORD)nvTexelScratchBuffer;
            DWORD v = 0;
            DWORD y;

            for (y = MB; y; y--)
            {
                DWORD u,x;
                DWORD addr;

                addr  = src;
                src  += dwSrcPitch;

                u = 0;
                for (x = MB; x; x--)
                {
                    DWORD store = dst + (u | v);
                    *(WORD*)store = *(WORD*)addr;

                    addr += 2;
                    u     = ((u | (MB_VMASK*2)) + 1*2) & (MB_UMASK*2);
                }
                v = ((v | (MB_UMASK*2)) + 2*2) & (MB_VMASK*2);
            }

            nvMemCopy (dwDestBase,(DWORD)nvTexelScratchBuffer,MB*MB*2);
            break;
        }

        case 4:
        {
            DWORD src = dwSrcBase;
            DWORD dst = (DWORD)nvTexelScratchBuffer;
            DWORD v = 0;
            DWORD y;

            for (y = MB; y; y--)
            {
                DWORD u,x;
                DWORD addr;

                addr  = src;
                src  += dwSrcPitch;

                u = 0;
                for (x = MB; x; x--)
                {
                    DWORD store = dst + (u | v);
                    *(DWORD*)store = *(DWORD*)addr;

                    addr += 4;
                    u     = ((u | (MB_VMASK*4)) + 1*4) & (MB_UMASK*4);
                }
                v = ((v | (MB_UMASK*4)) + 2*4) & (MB_VMASK*4);
            }

            nvMemCopy (dwDestBase,(DWORD)nvTexelScratchBuffer,MB*MB*4);
            break;
        }
    }
}


/*
 * nvSwizzleBlt_Lin_Swz_FullTexture
 *
 * software swizzle algorithm for full textures
 *  full texture means:
 *    source width & height == dest width & height
 *    blt rectangle is (0,0) - (w,h)
 */
void nvSwizzleBlt_Lin_Swz_FullTexture
(
    DWORD dwSrcBase,
    DWORD dwSrcPitch,

    DWORD dwDestBase,

    DWORD dwLogW,
    DWORD dwLogH,
    DWORD dwBPP
)
{
    SWIZZLE_ADDR sa;
    DWORD        dwMBPP,dwMBPP2;
    DWORD        x,y;

    dbgTracePush ("nvSwizzleBlt_Lin_Swz_FullTexture");

    /*
     * handle small cases
     */
    if ((dwLogW < L2MB) || (dwLogH < L2MB))
    {
        nvSwizzleSmallBlock (dwSrcBase,dwSrcPitch,
                             dwDestBase,
                             dwLogW,dwLogH,dwBPP);
        dbgTracePop();
        return;
    }

    /*
     * adjust width & height for macroblocks
     */
    dwLogW -= L2MB;
    dwLogH -= L2MB;
    dwMBPP  = dwBPP << L2MB;
    dwMBPP2 = dwBPP << (L2MB + L2MB);


    // Prefetch the Scratch buffer

    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_PREFETCH)
    {
        __asm
        {

            mov eax,offset nvTexelScratchBuffer
            mov ecx,(MB * MB * 4) / 32
    xxx32:   prefetch_rm8 (1,rmIND8(rEAX), 0)
             add eax,32
             dec ecx
            jnz xxx32
        }
    }

    /*
     * optimize for thin vertical case (swizzle bit does not work for this)
     */
    if (!dwLogW)
    {
        // Prefetch first 2 lines of the texture. nVSwizzleMacroBlock_LS prefetches 2 ahead
        if (dwBPP == 4) MB_prefetch32(dwSrcBase, dwSrcPitch);
        if (dwBPP == 2) MB_prefetch16(dwSrcBase, dwSrcPitch);

        for (y = (1 << dwLogH); y; y--)
        {
            nvSwizzleMacroBlock_LS (dwSrcBase,dwSrcPitch,
                                    dwDestBase,
                                    dwBPP);
            dwSrcBase  += dwSrcPitch << L2MB;
            dwDestBase += dwMBPP2;
        }
        dbgTracePop();
        return;
    }

    // Prefetch first 2 lines of the texture. nVSwizzleMacroBlock_LS prefetches 2 ahead
    if (dwBPP == 4) MB_prefetch32(dwSrcBase, dwSrcPitch);
    if (dwBPP == 2) MB_prefetch16(dwSrcBase, dwSrcPitch);
    /*
     * prepare swizzle address generation
     */
    nvSwizzleAddrCreate (&sa,dwDestBase,0,0,dwLogW,dwLogH,dwMBPP2);

    /*
     * do macroblock swizzle
     */
    for (y = (1 << dwLogH); y; y--)
    {
        DWORD dwSrc = dwSrcBase;

        for (x = (1 << dwLogW); x; x--)
        {
            nvSwizzleMacroBlock_LS (dwSrc,dwSrcPitch,
                                    nvSwizzleAddrGet(&sa),
                                    dwBPP);

            nvSwizzleAddrNext (&sa);
            dwSrc += dwBPP << L2MB;
        }

        nvSwizzleAddrNewLine (&sa);
        dwSrcBase += dwSrcPitch << L2MB;
    }

    dbgTracePop();
}

/*
 * nvSwizzleBlt_Lin_Lin
 *
 * simple SW bit-blt
 */
void nvSwizzleBlt_Lin_Lin
(
    DWORD dwSrcAddr,
    DWORD dwSrcPitch,

    DWORD dwDestAddr,
    DWORD dwDestPitch,

    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwSubHeight,
    DWORD dwBPP
)
{
    DWORD dwBytes = dwWidth * dwBPP;
    DWORD y;

    dbgTracePush ("nvSwizzleBlt_Lin_Lin");

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (a,dwSrcAddr,dwBytes);
            dwSrcAddr += dwSrcPitch;
            a         += dwBytes;
        }

        /*
         * write linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (dwDestAddr,a,dwBytes);
            a          += dwBytes;
            dwDestAddr += dwDestPitch;
        }

        y -= f;
    }

    dbgTracePop();
}

/*
 * nvSwizzleBlt_Swz_Lin
 *
 * deswizzle anything
 */
void nvSwizzleBlt_Swz_Lin
(
    SWIZZLE_ADDR *lpSA,

    DWORD         dwDestAddr,
    DWORD         dwDestPitch,

    DWORD         dwWidth,
    DWORD         dwHeight,
    DWORD         dwSubHeight,
    DWORD         dwBPP
)
{
    DWORD dwBytes = dwWidth * dwBPP;
    DWORD y;

    dbgTracePush ("nvSwizzleBlt_Swz_Lin");

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;

        for (h = f; h; h--)
        {
            DWORD x;

            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (a,nvSwizzleAddrGet(lpSA),dwBPP);
                a += dwBPP;
                nvSwizzleAddrNext (lpSA);
            }

            nvSwizzleAddrNewLine (lpSA);
        }

        /*
         * write linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (dwDestAddr,a,dwBytes);
            a          += dwBytes;
            dwDestAddr += dwDestPitch;
        }

        y -= f;
    }

    dbgTracePop();
}

/*
 * nvSwizzleBlt_Lin_Swz
 *
 * swizzles anything
 */
void nvSwizzleBlt_Lin_Swz
(
    DWORD         dwSrcAddr,
    DWORD         dwSrcPitch,

    SWIZZLE_ADDR *lpSA,

    DWORD         dwWidth,
    DWORD         dwHeight,
    DWORD         dwSubHeight,
    DWORD         dwBPP
)
{
    DWORD dwBytes   = dwWidth * dwBPP;
    DWORD y;

    dbgTracePush ("nvSwizzleBlt_Lin_Swz");

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (a,dwSrcAddr,dwBytes);
            a         += dwBytes;
            dwSrcAddr += dwSrcPitch;
        }

        /*
         * write swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            DWORD x;

            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (nvSwizzleAddrGet(lpSA),a,dwBPP);
                a += dwBPP;
                nvSwizzleAddrNext (lpSA);
            }
            nvSwizzleAddrNewLine (lpSA);
        }

        y -= f;
    }

    dbgTracePop();
}

/*
 * nvSwizzleBlt_Swz_Swz
 *
 * swizzle - swizzle copy, handles anything
 */
void nvSwizzleBlt_Swz_Swz
(
    SWIZZLE_ADDR *lpSASrc,

    SWIZZLE_ADDR *lpSADest,

    DWORD         dwWidth,
    DWORD         dwHeight,
    DWORD         dwSubHeight,
    DWORD         dwBPP
)
{
    DWORD dwBytes   = dwWidth * dwBPP;
    DWORD y;

    dbgTracePush ("nvSwizzleBlt_Swz_Swz");

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            DWORD x;

            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (a,nvSwizzleAddrGet(lpSASrc),dwBPP);
                a += dwBPP;
                nvSwizzleAddrNext (lpSASrc);
            }
            nvSwizzleAddrNewLine (lpSASrc);
        }

        /*
         * write swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            DWORD x;

            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (nvSwizzleAddrGet(lpSADest),a,dwBPP);
                a += dwBPP;
                nvSwizzleAddrNext (lpSADest);
            }
            nvSwizzleAddrNewLine (lpSADest);
        }

        y -= f;
    }

    dbgTracePop();
}

/*****************************************************************************
 * HARDWARE SWIZZLE
 *****************************************************************************/

/*
 * nvHWSwizzleBlt
 *
 * perform a HW swizzle blt
 */
void nvHWSwizzleBlt
(
    DWORD dwSrcOffset,
    DWORD dwSrcPitch,
    DWORD dwImageColorFormat,
    DWORD dwSrcX0,
    DWORD dwSrcY0,
    DWORD dwSrcAlloc,

    DWORD dwDstSwizzleOffset,
    DWORD dwLogWidth,
    DWORD dwLogHeight,
    DWORD dwSurfaceColorFormat,

    DWORD dwDstX0,
    DWORD dwDstY0,

    DWORD dwBlitWidth,
    DWORD dwBlitHeight
)
{
    dbgTracePush ("nvHWSwizzleBlt");

    // target surface
    nvglSetObject          (NV_DD_SPARE, D3D_CONTEXT_SURFACE_SWIZZLED);
    nvglSetSwizzledSurface (NV_DD_SPARE,
                            (DRF_NUM(052,_SET_FORMAT,_COLOR ,dwSurfaceColorFormat)
                            |DRF_NUM(052,_SET_FORMAT,_WIDTH ,dwLogWidth)
                            |DRF_NUM(052,_SET_FORMAT,_HEIGHT,dwLogHeight)),
                             dwDstSwizzleOffset);

    // format
    nvglSetObject               (NV_DD_SPARE, D3D_SCALED_IMAGE_FROM_MEMORY);
    nvglSetScaledImageFormat    (NV_DD_SPARE, dwImageColorFormat);

    // source memory context
    switch (dwSrcAlloc & CSimpleSurface::HEAP_LOCATION_MASK) {
        case CSimpleSurface::HEAP_AGP:
            nvglSetScaledImageContextImage (NV_DD_SPARE, D3D_CONTEXT_DMA_HOST_MEMORY);
            break;
        case CSimpleSurface::HEAP_VID:
            nvglSetScaledImageContextImage (NV_DD_SPARE, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
            break;
        case CSimpleSurface::HEAP_PCI:
            nvglSetScaledImageContextImage (NV_DD_SPARE, D3D_CONTEXT_DMA_HOST_MEMORY);
            break;
        default:
            DPF ("unknown context");
            dbgD3DError();
            break;
    }

    // clip
    nvglScaledImageClip          (NV_DD_SPARE, ((DWORD)dwDstX0), ((DWORD)dwDstY0), dwBlitWidth, dwBlitHeight);
    nvglScaledImageOut           (NV_DD_SPARE, ((DWORD)dwDstX0), ((DWORD)dwDstY0), dwBlitWidth, dwBlitHeight);
    nvglScaledImageDeltaDuDxDvDy (NV_DD_SPARE, (1<<20), (1<<20));

    // Need to make sure the boundary is big enough to work around an anomoly in the scaled image from
    // memory object.
    if (dwBlitWidth < NV4_SCALED_IMAGE_CUTOFF) dwBlitWidth = NV4_SCALED_IMAGE_CUTOFF;

    // even align the input width to prevent an RM exception
    nvglScaledImageInSize   (NV_DD_SPARE, (dwSrcX0 + dwBlitWidth + 1) & ~1, dwSrcY0 + dwBlitHeight);
    nvglScaledImageInFormat (NV_DD_SPARE,
                             (DRF_NUM(077,_IMAGE_IN_FORMAT,_PITCH,        dwSrcPitch)
                             |DRF_DEF(077,_IMAGE_IN_FORMAT,_ORIGIN,       _CORNER)
                             |DRF_DEF(077,_IMAGE_IN_FORMAT,_INTERPOLATOR, _ZOH)));
    nvglScaledImageInOffset (NV_DD_SPARE, dwSrcOffset);
    nvglScaledImageInPoint  (NV_DD_SPARE, dwSrcX0 << 4, dwSrcY0 << 4);

    pDriverData->dDrawSpareSubchannelObject   = D3D_SCALED_IMAGE_FROM_MEMORY;
#if (NVARCH >= 0x010)
    getDC()->dwOutOfContextCelsiusDirtyFlags |= CELSIUS_DIRTY_SURFACE; // this logic kills celcius surface state somehow.
#endif  // NVARCH >= 0x010

    dbgTracePop();
}

/*
  BUGBUG
  new swizzle entry points sit on top of old logic.
  will rewrite / integrate later.
*/

/*****************************************************************************
 * nvSwizBlt_cpu_lin2lin
 *
 * CPU swizzle blt from linear to linear
 */

void nvSwizBlt_cpu_lin2lin
(
    DWORD dwSrcAddr,
    DWORD dwSrcPitch,
    DWORD dwSrcX,
    DWORD dwSrcY,
    DWORD dwDstAddr,
    DWORD dwDstPitch,
    DWORD dwDstX,
    DWORD dwDstY,
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwBPP
)
{
    dbgTracePush ("nvSwizBlt_cpu_lin2lin");

    DWORD        dwSubHeight = 2048 / (dwWidth * dwBPP);
    if (!dwSubHeight) dwSubHeight = 1;
                 else dwSubHeight = min(dwSubHeight,dwHeight);

    nvSwizzleBlt_Lin_Lin (dwSrcAddr + dwSrcY * dwSrcPitch + dwSrcX * dwBPP,dwSrcPitch,
                          dwDstAddr + dwDstY * dwDstPitch + dwDstX * dwBPP,dwDstPitch,
                          dwWidth,dwHeight,dwSubHeight,dwBPP);

    dbgTracePop();
}


// Converts bits IHGFEDCBA to 00I00H00G00F00E00D00C00B00A
DWORD swizTable3D_512[] = {
    0x0000000, 0x0000001, 0x0000008, 0x0000009, 0x0000040, 0x0000041, 0x0000048, 0x0000049, 0x0000200, 0x0000201, 0x0000208, 0x0000209, 0x0000240, 0x0000241, 0x0000248, 0x0000249, 0x0001000, 0x0001001, 0x0001008, 0x0001009, 0x0001040, 0x0001041, 0x0001048, 0x0001049, 0x0001200, 0x0001201, 0x0001208, 0x0001209, 0x0001240, 0x0001241, 0x0001248, 0x0001249,
    0x0008000, 0x0008001, 0x0008008, 0x0008009, 0x0008040, 0x0008041, 0x0008048, 0x0008049, 0x0008200, 0x0008201, 0x0008208, 0x0008209, 0x0008240, 0x0008241, 0x0008248, 0x0008249, 0x0009000, 0x0009001, 0x0009008, 0x0009009, 0x0009040, 0x0009041, 0x0009048, 0x0009049, 0x0009200, 0x0009201, 0x0009208, 0x0009209, 0x0009240, 0x0009241, 0x0009248, 0x0009249,
    0x0040000, 0x0040001, 0x0040008, 0x0040009, 0x0040040, 0x0040041, 0x0040048, 0x0040049, 0x0040200, 0x0040201, 0x0040208, 0x0040209, 0x0040240, 0x0040241, 0x0040248, 0x0040249, 0x0041000, 0x0041001, 0x0041008, 0x0041009, 0x0041040, 0x0041041, 0x0041048, 0x0041049, 0x0041200, 0x0041201, 0x0041208, 0x0041209, 0x0041240, 0x0041241, 0x0041248, 0x0041249,
    0x0048000, 0x0048001, 0x0048008, 0x0048009, 0x0048040, 0x0048041, 0x0048048, 0x0048049, 0x0048200, 0x0048201, 0x0048208, 0x0048209, 0x0048240, 0x0048241, 0x0048248, 0x0048249, 0x0049000, 0x0049001, 0x0049008, 0x0049009, 0x0049040, 0x0049041, 0x0049048, 0x0049049, 0x0049200, 0x0049201, 0x0049208, 0x0049209, 0x0049240, 0x0049241, 0x0049248, 0x0049249,
    0x0200000, 0x0200001, 0x0200008, 0x0200009, 0x0200040, 0x0200041, 0x0200048, 0x0200049, 0x0200200, 0x0200201, 0x0200208, 0x0200209, 0x0200240, 0x0200241, 0x0200248, 0x0200249, 0x0201000, 0x0201001, 0x0201008, 0x0201009, 0x0201040, 0x0201041, 0x0201048, 0x0201049, 0x0201200, 0x0201201, 0x0201208, 0x0201209, 0x0201240, 0x0201241, 0x0201248, 0x0201249,
    0x0208000, 0x0208001, 0x0208008, 0x0208009, 0x0208040, 0x0208041, 0x0208048, 0x0208049, 0x0208200, 0x0208201, 0x0208208, 0x0208209, 0x0208240, 0x0208241, 0x0208248, 0x0208249, 0x0209000, 0x0209001, 0x0209008, 0x0209009, 0x0209040, 0x0209041, 0x0209048, 0x0209049, 0x0209200, 0x0209201, 0x0209208, 0x0209209, 0x0209240, 0x0209241, 0x0209248, 0x0209249,
    0x0240000, 0x0240001, 0x0240008, 0x0240009, 0x0240040, 0x0240041, 0x0240048, 0x0240049, 0x0240200, 0x0240201, 0x0240208, 0x0240209, 0x0240240, 0x0240241, 0x0240248, 0x0240249, 0x0241000, 0x0241001, 0x0241008, 0x0241009, 0x0241040, 0x0241041, 0x0241048, 0x0241049, 0x0241200, 0x0241201, 0x0241208, 0x0241209, 0x0241240, 0x0241241, 0x0241248, 0x0241249,
    0x0248000, 0x0248001, 0x0248008, 0x0248009, 0x0248040, 0x0248041, 0x0248048, 0x0248049, 0x0248200, 0x0248201, 0x0248208, 0x0248209, 0x0248240, 0x0248241, 0x0248248, 0x0248249, 0x0249000, 0x0249001, 0x0249008, 0x0249009, 0x0249040, 0x0249041, 0x0249048, 0x0249049, 0x0249200, 0x0249201, 0x0249208, 0x0249209, 0x0249240, 0x0249241, 0x0249248, 0x0249249,
    0x1000000, 0x1000001, 0x1000008, 0x1000009, 0x1000040, 0x1000041, 0x1000048, 0x1000049, 0x1000200, 0x1000201, 0x1000208, 0x1000209, 0x1000240, 0x1000241, 0x1000248, 0x1000249, 0x1001000, 0x1001001, 0x1001008, 0x1001009, 0x1001040, 0x1001041, 0x1001048, 0x1001049, 0x1001200, 0x1001201, 0x1001208, 0x1001209, 0x1001240, 0x1001241, 0x1001248, 0x1001249,
    0x1008000, 0x1008001, 0x1008008, 0x1008009, 0x1008040, 0x1008041, 0x1008048, 0x1008049, 0x1008200, 0x1008201, 0x1008208, 0x1008209, 0x1008240, 0x1008241, 0x1008248, 0x1008249, 0x1009000, 0x1009001, 0x1009008, 0x1009009, 0x1009040, 0x1009041, 0x1009048, 0x1009049, 0x1009200, 0x1009201, 0x1009208, 0x1009209, 0x1009240, 0x1009241, 0x1009248, 0x1009249,
    0x1040000, 0x1040001, 0x1040008, 0x1040009, 0x1040040, 0x1040041, 0x1040048, 0x1040049, 0x1040200, 0x1040201, 0x1040208, 0x1040209, 0x1040240, 0x1040241, 0x1040248, 0x1040249, 0x1041000, 0x1041001, 0x1041008, 0x1041009, 0x1041040, 0x1041041, 0x1041048, 0x1041049, 0x1041200, 0x1041201, 0x1041208, 0x1041209, 0x1041240, 0x1041241, 0x1041248, 0x1041249,
    0x1048000, 0x1048001, 0x1048008, 0x1048009, 0x1048040, 0x1048041, 0x1048048, 0x1048049, 0x1048200, 0x1048201, 0x1048208, 0x1048209, 0x1048240, 0x1048241, 0x1048248, 0x1048249, 0x1049000, 0x1049001, 0x1049008, 0x1049009, 0x1049040, 0x1049041, 0x1049048, 0x1049049, 0x1049200, 0x1049201, 0x1049208, 0x1049209, 0x1049240, 0x1049241, 0x1049248, 0x1049249,
    0x1200000, 0x1200001, 0x1200008, 0x1200009, 0x1200040, 0x1200041, 0x1200048, 0x1200049, 0x1200200, 0x1200201, 0x1200208, 0x1200209, 0x1200240, 0x1200241, 0x1200248, 0x1200249, 0x1201000, 0x1201001, 0x1201008, 0x1201009, 0x1201040, 0x1201041, 0x1201048, 0x1201049, 0x1201200, 0x1201201, 0x1201208, 0x1201209, 0x1201240, 0x1201241, 0x1201248, 0x1201249,
    0x1208000, 0x1208001, 0x1208008, 0x1208009, 0x1208040, 0x1208041, 0x1208048, 0x1208049, 0x1208200, 0x1208201, 0x1208208, 0x1208209, 0x1208240, 0x1208241, 0x1208248, 0x1208249, 0x1209000, 0x1209001, 0x1209008, 0x1209009, 0x1209040, 0x1209041, 0x1209048, 0x1209049, 0x1209200, 0x1209201, 0x1209208, 0x1209209, 0x1209240, 0x1209241, 0x1209248, 0x1209249,
    0x1240000, 0x1240001, 0x1240008, 0x1240009, 0x1240040, 0x1240041, 0x1240048, 0x1240049, 0x1240200, 0x1240201, 0x1240208, 0x1240209, 0x1240240, 0x1240241, 0x1240248, 0x1240249, 0x1241000, 0x1241001, 0x1241008, 0x1241009, 0x1241040, 0x1241041, 0x1241048, 0x1241049, 0x1241200, 0x1241201, 0x1241208, 0x1241209, 0x1241240, 0x1241241, 0x1241248, 0x1241249,
    0x1248000, 0x1248001, 0x1248008, 0x1248009, 0x1248040, 0x1248041, 0x1248048, 0x1248049, 0x1248200, 0x1248201, 0x1248208, 0x1248209, 0x1248240, 0x1248241, 0x1248248, 0x1248249, 0x1249000, 0x1249001, 0x1249008, 0x1249009, 0x1249040, 0x1249041, 0x1249048, 0x1249049, 0x1249200, 0x1249201, 0x1249208, 0x1249209, 0x1249240, 0x1249241, 0x1249248, 0x1249249
};

DWORD swiz3DMasks[] = { 0x0000000, 0x0000001, 0x0000009, 0x0000049, 0x0000249, 0x0001249, 0x0009249, 0x0049249, 0x0249249, 0x1249249 };



/*****************************************************************************
 * nvSwizBlt_cpu_lin2swz
 *
 * CPU swizzle blt from linear to swizzle
 */
void nvSwizBlt_cpu_lin2swz
(
    DWORD dwSrcAddr,
    DWORD dwSrcPitch,
    DWORD dwSrcX,
    DWORD dwSrcY,
    DWORD dwDstAddr,
    DWORD dwDstX,
    DWORD dwDstY,
    DWORD dwDstLogWidth,
    DWORD dwDstLogHeight,
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwBPP
)
{
    dbgTracePush ("nvSwizBlt_cpu_lin2swz");

    /* DO NOT REMOVE
    DWORD dwSize      = dwWidth * dwBPP;
    DWORD dwDstPitch  = dwBPP << dwDstLogWidth;
    dwSrcAddr        += dwSrcY * dwSrcPitch + dwSrcX * dwBPP;
    dwDstAddr        += (dwDstY << dwDstLogWidth) + dwDstX * dwBPP;
    for (DWORD y = dwHeight; y; y--)
    {
        nvMemCopy (dwDstAddr,dwSrcAddr,dwSize);
        dwDstAddr += dwDstPitch;
        dwSrcAddr += dwSrcPitch;
    }

    return;
//*/

    BOOL bFullTexture = !dwSrcX && !dwSrcY
                     && !dwDstX && !dwDstY
                     && (dwWidth  == (1U << dwDstLogWidth))
                     && (dwHeight == (1U << dwDstLogHeight));

    if (bFullTexture)
    {
        nvSwizzleBlt_Lin_Swz_FullTexture (dwSrcAddr,dwSrcPitch,
                                          dwDstAddr,dwDstLogWidth,dwDstLogHeight,
                                          dwBPP);
/* DO NOT REMOVE
        DWORD dwSrc = dwSrcAddr;
        DWORD dwDst = VIDMEM_ADDR(pDriverData->CurrentVisibleSurfaceAddress);
        for (DWORD y = 0; y < dwHeight; y++)
        {
            nvMemCopy ((void*)dwDst,(void*)dwSrc,dwWidth * dwBPP);
            dwDst += ((DIBENGINEHDR1 *)pDXShare->pFlatDibeng)->deDeltaScan;
            dwSrc += dwSrcPitch;
        }
__asm int 3;
        dwSrc = dwDstAddr;
        dwDst = VIDMEM_ADDR(pDriverData->CurrentVisibleSurfaceAddress);
        for (y = 0; y < dwHeight; y++)
        {
            nvMemCopy ((void*)dwDst,(void*)dwSrc,dwBPP << dwDstLogWidth);
            dwDst += ((DIBENGINEHDR1 *)pDXShare->pFlatDibeng)->deDeltaScan;
            dwSrc += dwBPP << dwDstLogWidth;
        }
__asm int 3;
//*/
    }
    else
    {
        SWIZZLE_ADDR Dest;
        DWORD        dwSubHeight = 2048 / (dwWidth * dwBPP);
        if (!dwSubHeight) dwSubHeight = 1;
                     else dwSubHeight = min(dwSubHeight,dwHeight);

        nvSwizzleAddrCreate (&Dest,dwDstAddr,dwDstX,dwDstY,dwDstLogWidth,dwDstLogHeight,dwBPP);

        nvSwizzleBlt_Lin_Swz (dwSrcAddr + dwSrcY * dwSrcPitch + dwSrcX * dwBPP,dwSrcPitch,
                              &Dest,
                              dwWidth,dwHeight,dwSubHeight,dwBPP);
    }

    dbgTracePop();
}

//
// The slowest CPU volume swizzler ever...
//
void nvVolumeSwizBlt_cpu_lin2swz(
    DWORD dwSrcAddr,
    DWORD dwSrcPitch,
    DWORD dwSrcSlicePitch,
    DWORD dwSrcX,
    DWORD dwSrcY,
    DWORD dwSrcZ,
    DWORD dwDstAddr,
    DWORD dwDstX,
    DWORD dwDstY,
    DWORD dwDstZ,
    DWORD dwDstLogWidth,
    DWORD dwDstLogHeight,
    DWORD dwDstLogDepth,
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwDepth,
    DWORD dwBPP
) {
    dbgTracePush ("nvVolumeSwizBlt_cpu_lin2swz");

    nvAssert(dwWidth <= 512);
    nvAssert(dwHeight <= 512);
    nvAssert(dwDepth <= 512);

    DWORD dwDstIndex, dwTempDstIndex, dwSrcIndex;
    DWORD i, j, k;

    DWORD dwMask = swiz3DMasks[dwDstLogWidth] | (swiz3DMasks[dwDstLogHeight] << 1) | (swiz3DMasks[dwDstLogDepth] << 2);
    DWORD dwTotalBits = dwDstLogWidth + dwDstLogHeight + dwDstLogDepth;
    DWORD dwTempMask, dwMaskIndex;

#define VOLUME_SWIZZLE_BLIT(type)                                                                               \
    for (k=0; k<dwDepth; k++) {                                                                                 \
        for (j=0; j<dwHeight; j++) {                                                                            \
            for (i=0; i<dwWidth; i++) {                                                                         \
                dwTempDstIndex  =  swizTable3D_512[i+dwDstX]       |                                            \
                                  (swizTable3D_512[j+dwDstY] << 1) |                                            \
                                  (swizTable3D_512[k+dwDstZ] << 2);                                             \
                dwTempMask = dwMask;                                                                            \
                dwDstIndex = 0;                                                                                 \
                dwMaskIndex = 0;                                                                                \
                while (dwTempMask) {                                                                            \
                    while (!(dwTempMask & 1)) {                                                                 \
                        dwTempDstIndex >>= 1;                                                                   \
                        dwTempMask >>= 1;                                                                       \
                    }                                                                                           \
                    dwDstIndex |= dwTempDstIndex & (1 << dwMaskIndex);                                          \
                    dwTempMask >>= 1;                                                                           \
                    dwMaskIndex++;                                                                              \
                }                                                                                               \
                dwSrcIndex = (dwSrcX+i)*dwBPP + dwSrcPitch*(j+dwSrcY) + dwSrcSlicePitch*(k+dwSrcZ);             \
                ((type *)dwDstAddr)[dwDstIndex] = *(type *)&((char *)dwSrcAddr)[dwSrcIndex];                    \
            }                                                                                                   \
        }                                                                                                       \
    }

    switch (dwBPP) {
        case 1:
            VOLUME_SWIZZLE_BLIT(BYTE);
            break;
        case 2:
            VOLUME_SWIZZLE_BLIT(WORD);
            break;
        case 4:
            VOLUME_SWIZZLE_BLIT(DWORD);
            break;
        default:
            // Bad bit depth
            nvAssert(0);
    }

    dbgTracePop();
}

/*****************************************************************************
 * nvSwizBlt_lin2swz
 *
 * CPU and GPU combined swizzle blt from linear to swizzle
 *
 * KKT 3/5/01:  Called only from nvTextureBltDX7.
 */

DWORD lutFormat[5] = { ~0, NV_SURFACE_FORMAT_Y8, NV_SURFACE_FORMAT_R5G6B5, ~0, NV_SURFACE_FORMAT_A8R8G8B8 };

void nvSwizBlt_lin2swz
(
    PNVD3DCONTEXT pContext,
    DWORD         dwSrcAddr,
    DWORD         dwSrcPitch,
    DWORD         dwSrcSlicePitch,
    DWORD         dwSrcX,
    DWORD         dwSrcY,
    DWORD         dwSrcZ,
    CTexture     *pDstTexture,
    DWORD         dwDstAddr,
    DWORD         dwDstX,
    DWORD         dwDstY,
    DWORD         dwDstZ,
    DWORD         dwDstLogWidth,
    DWORD         dwDstLogHeight,
    DWORD         dwDstLogDepth,
    DWORD         dwWidth,
    DWORD         dwHeight,
    DWORD         dwDepth,
    DWORD         dwBPP
)
{
    dbgTracePush ("nvSwizBlt_lin2swz");

    BOOL bFullTexture = !dwSrcX && !dwSrcY
                     && !dwDstX && !dwDstY
                     && (dwWidth  == (1U << dwDstLogWidth))
                     && (dwHeight == (1U << dwDstLogHeight));

    // get size of texture
    DWORD dwSize = dwSrcPitch * dwHeight;

    if (dwDstLogDepth) {
        // Blitting a volume texture
        nvVolumeSwizBlt_cpu_lin2swz(dwSrcAddr, dwSrcPitch, dwSrcSlicePitch,
                                    dwSrcX, dwSrcY, dwSrcZ,
                                    dwDstAddr, dwDstX, dwDstY, dwDstZ,
                                    dwDstLogWidth, dwDstLogHeight, dwDstLogDepth, dwWidth,
                                    dwHeight, dwDepth, dwBPP);
        dbgTracePop();
        return;
    }

    if ((pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_TEXTURE_USEHW)       // hw allowed blts enabled
     && ((CURRENT_FLIP - COMPLETED_FLIP) < 1)                                       // hw sufficiently idle
     && !(pDstTexture->getSwizzled()->getOffset() & 63)                             // hw can address dest
     && (pDstTexture->getSwizzled()->getHeapLocation() == CSimpleSurface::HEAP_VID) // hw can address dest
     && (dwWidth >= NV4_SCALED_IMAGE_CUTOFF) && (dwHeight >= 4)                     // anything smaller than this isn't worth bothering the hardware with
     && (dwWidth <= 2046) && (dwHeight <= 2047)                                     // dimensions small enough
     && (dwSize < getDC()->defaultVB.getSize() / 4)) {                              // enough staging space

        if (dwBPP == 1) goto cpuCopy;

        // get space
        DWORD dwVBOffset = getDC()->defaultVB.waitForSpace (dwSize + 64 * 12, TRUE);
        if (dwVBOffset == ~0) goto cpuCopy;

        // copy unswizzled texels to scratch surface
        dwVBOffset = (dwVBOffset + 64) & ~63;

                #ifdef NV_PROFILE_COPIES
                NVP_START(NVP_T_LIN2SWZ2);
                #endif
        nvMemCopy (getDC()->defaultVB.getAddress() + dwVBOffset, dwSrcAddr + dwSrcPitch * dwSrcY, dwSize);
                #ifdef NV_PROFILE_COPIES
                NVP_STOP(NVP_T_LIN2SWZ2);
                nvpLogTime (NVP_T_LIN2SWZ2,nvpTime[NVP_T_LIN2SWZ2]);
                #endif
        // capture BLT source
#ifdef CAPTURE
        if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
            CAPTURE_MEMORY_WRITE memwr;
            memwr.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            memwr.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            memwr.dwExtensionID        = CAPTURE_XID_MEMORY_WRITE;
            memwr.dwCtxDMAHandle       = (getDC()->defaultVB.getHeap() == CSimpleSurface::HEAP_VID)
                                       ? NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY
                                       : D3D_CONTEXT_DMA_HOST_MEMORY;
            memwr.dwOffset             = getDC()->defaultVB.getOffset() + dwVBOffset;
            memwr.dwSize               = dwSize;
            captureLog (&memwr,sizeof(memwr));
            captureLog ((void*)getDC()->defaultVB.getAddress(),memwr.dwSize);
        }
#endif

        // lock the texture so that noone else can read from it until we're done writing to it
        pDstTexture->hwLock (pContext, CSimpleSurface::LOCK_NORMAL);

        // program HW to do swizzle
        nvSwizBlt_gpu_lin2swz (getDC()->defaultVB.getOffset() + dwVBOffset,
                               getDC()->defaultVB.getHeap(), dwSrcPitch /*dwBPP << dwDstLogWidth*/, dwSrcX, 0,
                               pDstTexture->getSwizzled()->getOffset(),dwDstX,dwDstY,dwDstLogWidth,dwDstLogHeight,
                               dwWidth,dwHeight,dwBPP);

        // unlock texture
        pDstTexture->hwUnlock();

        getDC()->defaultVB.updateOffset (dwVBOffset + dwSize);
        getDC()->defaultVB.updateMap();

        dbgTracePop();
        return;
    }

cpuCopy:

    if (bFullTexture)
    {
        nvSwizzleBlt_Lin_Swz_FullTexture (dwSrcAddr,dwSrcPitch,
                                          dwDstAddr,dwDstLogWidth,dwDstLogHeight,
                                          dwBPP);
    }
    else
    {
        SWIZZLE_ADDR Dest;
        DWORD        dwSubHeight = 2048 / (dwWidth * dwBPP);
        if (!dwSubHeight) dwSubHeight = 1;
                     else dwSubHeight = min(dwSubHeight,dwHeight);

        nvSwizzleAddrCreate (&Dest,dwDstAddr,dwDstX,dwDstY,dwDstLogWidth,dwDstLogHeight,dwBPP);

        nvSwizzleBlt_Lin_Swz (dwSrcAddr + dwSrcY * dwSrcPitch + dwSrcX * dwBPP,dwSrcPitch,
                              &Dest,
                              dwWidth,dwHeight,dwSubHeight,dwBPP);
    }

    dbgTracePop();
}

/*****************************************************************************
 * nvSwizBlt_cpu_lin2swz
 *
 * CPU swizzle blt from swizzle to linear
 */
void nvSwizBlt_cpu_swz2lin
(
    DWORD dwSrcAddr,
    DWORD dwSrcX,
    DWORD dwSrcY,
    DWORD dwSrcLogWidth,
    DWORD dwSrcLogHeight,
    DWORD dwDstAddr,
    DWORD dwDstPitch,
    DWORD dwDstX,
    DWORD dwDstY,
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwBPP
)
{
    dbgTracePush ("nvSwizBlt_cpu_swz2lin");

    SWIZZLE_ADDR Source;
    DWORD        dwSubHeight = 2048 / (dwWidth * dwBPP);
    if (!dwSubHeight) dwSubHeight = 1;
                 else dwSubHeight = min(dwSubHeight,dwHeight);

    nvSwizzleAddrCreate (&Source,dwSrcAddr,dwSrcX,dwSrcY,dwSrcLogWidth,dwSrcLogHeight,dwBPP);

    nvSwizzleBlt_Swz_Lin (&Source,
                          dwDstAddr + dwDstY * dwDstPitch + dwDstX * dwBPP,dwDstPitch,
                          dwWidth,dwHeight,dwSubHeight,dwBPP);

    dbgTracePop();
}

/*****************************************************************************
 * nvSwizBlt_cpu_swz2swz
 *
 * CPU swizzle blt from swizzle to swizzle
 */
void nvSwizBlt_cpu_swz2swz
(
    DWORD dwSrcAddr,
    DWORD dwSrcX,
    DWORD dwSrcY,
    DWORD dwSrcLogWidth,
    DWORD dwSrcLogHeight,
    DWORD dwDstAddr,
    DWORD dwDstX,
    DWORD dwDstY,
    DWORD dwDstLogWidth,
    DWORD dwDstLogHeight,
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwBPP
)
{
    dbgTracePush ("nvSwizBlt_cpu_swz2swz");

    SWIZZLE_ADDR Source;
    SWIZZLE_ADDR Dest;
    DWORD        dwSubHeight = 2048 / (dwWidth * dwBPP);
    if (!dwSubHeight) dwSubHeight = 1;
                 else dwSubHeight = min(dwSubHeight,dwHeight);

    nvSwizzleAddrCreate (&Source,dwSrcAddr,dwSrcX,dwSrcY,dwSrcLogWidth,dwSrcLogHeight,dwBPP);
    nvSwizzleAddrCreate (&Dest,  dwDstAddr,dwDstX,dwDstY,dwDstLogWidth,dwDstLogHeight,dwBPP);

    // todo - check for FT blts, use linear copy

    nvSwizzleBlt_Swz_Swz (&Source,
                          &Dest,
                          dwWidth,dwHeight,dwSubHeight,dwBPP);

    dbgTracePop();
}


/*****************************************************************************
 * nvSwizBlt_gpu_lin2swz
 *
 * GPU swizzle blt from linear to swizzle
 */
void nvSwizBlt_gpu_lin2swz
(
    DWORD dwSrcOffset,
    DWORD dwSrcHeap,
    DWORD dwSrcPitch,
    DWORD dwSrcX,
    DWORD dwSrcY,
    DWORD dwDstOffset,
    DWORD dwDstX,
    DWORD dwDstY,
    DWORD dwDstLogWidth,
    DWORD dwDstLogHeight,
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwBPP
)
{
    dbgTracePush ("nvSwizBlt_gpu_lin2swz");
    DWORD dwImageColorFormat;
    DWORD dwFormat = lutFormat[dwBPP];
    nvAssert(dwFormat != ~0);

#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0089_SCALEDIMG) {
        dwImageColorFormat = nv089SurfaceFormat[dwFormat];
    }
    else
#endif  // NVARCH >= 0x010
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0077_SCALEDIMG) {
        dwImageColorFormat = nv077SurfaceFormat[dwFormat];
    }

    DWORD dwSurfaceColorFormat = nv052SurfaceFormat[dwFormat];

    assert (dwImageColorFormat   != ~0);
    assert (dwSurfaceColorFormat != ~0);

    // NOTE: HW may not swizzle 8bpp correctly or at all!
    nvHWSwizzleBlt (dwSrcOffset,dwSrcPitch,dwImageColorFormat,dwSrcX,dwSrcY,dwSrcHeap,
                    dwDstOffset,dwDstLogWidth,dwDstLogHeight,dwSurfaceColorFormat,dwDstX,dwDstY,
                    dwWidth,dwHeight);

    dbgFlushType (NVDBG_FLUSH_2D);

    dbgTracePop();
}

////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////

extern "C++"
{

#define CPB_templ template<const DWORD cdwAMask,const DWORD cdwABitPos,const DWORD cdwABitCount,\
                           const DWORD cdwRMask,const DWORD cdwRBitPos,const DWORD cdwRBitCount,\
                           const DWORD cdwGMask,const DWORD cdwGBitPos,const DWORD cdwGBitCount,\
                           const DWORD cdwBMask,const DWORD cdwBBitPos,const DWORD cdwBBitCount,\
                           const DWORD cdwBPP,const DWORD cdwPalType,\
                           const DWORD cdwGetOrMask>

#define CPB_args cdwAMask,cdwABitPos,cdwABitCount,\
                 cdwRMask,cdwRBitPos,cdwRBitCount,\
                 cdwGMask,cdwGBitPos,cdwGBitCount,\
                 cdwBMask,cdwBBitPos,cdwBBitCount,\
                 cdwBPP,cdwPalType,\
                 cdwGetOrMask

CPB_templ class CPBAbstract
{
protected:
    struct PE
    {
        DWORD color;
        DWORD next;
        DWORD prev;
        DWORD index;
        DWORD count;
        DWORD numChildren;
        DWORD child[16];

        inline void init (void) { memset(this, 0xFF, sizeof(*this)); count = numChildren = 0; }
    };
    PE    *m_aSet;
    DWORD  m_adwRoot[9];
    DWORD  m_dwTop;
    DWORD  m_dwNextAlloc;
    DWORD  m_dwSize;
    DWORD  m_dwColors;

protected:
    inline DWORD mask (DWORD dwPel) const { return dwPel | cdwGetOrMask; }
    inline DWORD get  (BYTE *p)     const { return mask((cdwBPP == 4) ? (*(DWORD*)p) : ((DWORD)*(WORD*)p)); }
    inline DWORD getA (DWORD dwPel) const { return (dwPel & cdwAMask) >> cdwABitPos; }
    inline DWORD getR (DWORD dwPel) const { return (dwPel & cdwRMask) >> cdwRBitPos; }
    inline DWORD getG (DWORD dwPel) const { return (dwPel & cdwGMask) >> cdwGBitPos; }
    inline DWORD getB (DWORD dwPel) const { return (dwPel & cdwBMask) >> cdwBBitPos; }

    inline void put (BYTE *p,DWORD dw)
    {
        if (cdwBPP == 4) *(DWORD*)p = dw;
                    else *(WORD*)p = (WORD)dw;
    }

protected:
    BOOL grow (void);

    inline DWORD allocNode (void)
    {
        // march on
        m_dwNextAlloc++;
        if (m_dwNextAlloc >= m_dwSize)
        {
            // we are out of space - grow
            if (!grow()) return ~0;
        }

        // return free node
        m_aSet[m_dwNextAlloc].init();
        return m_dwNextAlloc;
    }
    inline DWORD lookup (DWORD dwPel)
    {
        DWORD a = getA(dwPel);
        DWORD r = getR(dwPel);
        DWORD g = getG(dwPel);
        DWORD b = getB(dwPel);

        DWORD curr = m_dwTop;
        for (DWORD i = 0; i < 9; i++)
        {
            // found it yet?
            if (!m_aSet[curr].numChildren)
            {
                return m_aSet[curr].index;
            }

            // get child
            DWORD child = ((a & 128) >> 4) | ((r & 128) >> 5) | ((g & 128) >> 6) | ((b & 128) >> 7);

            // next
            curr = m_aSet[curr].child[child];
            a <<= 1;
            r <<= 1;
            g <<= 1;
            b <<= 1;
        }

        return m_aSet[curr].index;
    }

protected:
    BOOL addToTable (DWORD dwPel);
    void swizzle    (DWORD dwSrcAddr,DWORD dwSrcPitch,SWIZZLE_ADDR *lpSA,DWORD dwWidth,DWORD dwHeight,DWORD dwSubHeight);

public:
    BOOL initTable  (void);
    BOOL buildTable (DWORD dwSource,DWORD dwWidth,DWORD dwHeight);
    BOOL palettize  (BYTE *pbPalette);
    BOOL apply      (DWORD dwSource,DWORD dwDest,DWORD dwWidth,DWORD dwLogWidth,DWORD dwHeight,DWORD dwLogHeight);
    BOOL freeTable  (void);

public:
    BOOL depalettizeInPlace      (DWORD dwSource,DWORD dwDest,DWORD dwWidth,DWORD dwHeight,DWORD *pPalette);
    BOOL depalettizeAndDeswizzle (DWORD dwSource,DWORD dwDest,DWORD dwWidth,DWORD dwLogWidth,DWORD dwHeight,DWORD dwLogHeight,DWORD dwDeviceMemPaletteAddr);
};

////////////////////////////////////////////////////////////////////////////////////////

CPB_templ
BOOL CPBAbstract<CPB_args>::grow
(
    void
)
{
    m_dwSize *= 2;
    if (!ReallocIPM(m_aSet,m_dwSize * sizeof(PE),(void**)&m_aSet)) return FALSE; // out of memory
    if (!m_aSet) return FALSE; // out of memory
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////

CPB_templ
BOOL CPBAbstract<CPB_args>::addToTable
(
    DWORD dwPel
)
{
    DWORD a = getA(dwPel);
    DWORD r = getR(dwPel);
    DWORD g = getG(dwPel);
    DWORD b = getB(dwPel);

    DWORD curr   = m_dwTop;
    BOOL  unique = FALSE;
    for (DWORD i = 0; i < 8; i++)
    {
        // get child
        DWORD child = ((a & 128) >> 4) | ((r & 128) >> 5) | ((g & 128) >> 6) | ((b & 128) >> 7);

        // bump usage count
        m_aSet[curr].count ++;

        // traverse or add?
        if (m_aSet[curr].child[child] == ~0)
        {
            unique = TRUE;

            // add new node
            DWORD next = allocNode();
            if (next == ~0) return FALSE; // abort
            m_aSet[curr].child[child] = next;
            m_aSet[curr].numChildren  ++;

            // add to linked list
            m_aSet[next].prev = ~0;
            m_aSet[next].next = m_adwRoot[i+1];
            if (m_adwRoot[i+1] != ~0) m_aSet[m_adwRoot[i+1]].prev = next;
            m_adwRoot[i+1]    = next;

            // next pos
            curr = next;
        }
        else
        {
            // next pos
            curr = m_aSet[curr].child[child];
        }

        // next
        a <<= 1;
        r <<= 1;
        g <<= 1;
        b <<= 1;
    }

    // set color of leaf
    m_aSet[curr].count ++;
    m_aSet[curr].color = dwPel;
    if (unique) m_dwColors++; // unique color count

    // done
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////

CPB_templ
void CPBAbstract<CPB_args>::swizzle
(
    DWORD         dwSrcAddr,
    DWORD         dwSrcPitch,

    SWIZZLE_ADDR *lpSA,

    DWORD         dwWidth,
    DWORD         dwHeight,
    DWORD         dwSubHeight
)
{
    DWORD dwBytes = dwWidth * cdwBPP;
    DWORD y;

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (a,dwSrcAddr,dwBytes);
            a         += dwBytes;
            dwSrcAddr += dwSrcPitch;
        }

        /*
         * write swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            DWORD x;

            for (x = dwWidth; x; x--)
            {
                DWORD dwPel = 0;
                if (cdwBPP == 4) dwPel = *(DWORD*)a;
                            else dwPel = *(WORD*)a;

                DWORD dwIndex = lookup(mask(dwPel));
                *(BYTE*)(nvSwizzleAddrGet(lpSA)) = (BYTE)dwIndex;

                a += cdwBPP;
                nvSwizzleAddrNext (lpSA);
            }
            nvSwizzleAddrNewLine (lpSA);
        }

        y -= f;
    }
}

////////////////////////////////////////////////////////////////////////////////////////

CPB_templ
BOOL CPBAbstract<CPB_args>::initTable
(
    void
)
{
    // init table
    memset(m_adwRoot, 0xFF, sizeof(m_adwRoot));
    m_dwSize      = 256;
    m_aSet        = (PE*)AllocIPM(m_dwSize * sizeof(PE));
    if (!m_aSet) return FALSE;
    m_aSet[0].init();
    m_adwRoot[0]  = 0;
    m_dwTop       = 0;
    m_dwNextAlloc = 0;

    // init stats
    m_dwColors = 0;

    // done
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////

CPB_templ
BOOL CPBAbstract<CPB_args>::buildTable
(
    DWORD  dwSource,
    DWORD  dwWidth,
    DWORD  dwHeight
)
{
    // build table
    DWORD dwLine  = dwSource;
    DWORD dwPitch = dwWidth * cdwBPP;
    for (DWORD y = 0; y < dwHeight; y++,dwLine += dwPitch)
    {
        for (DWORD xx = 0,x = 0; x < dwWidth; x++, xx += cdwBPP)
        {
            DWORD pel = get((BYTE*)(dwLine+xx));
            if (!addToTable(pel)) return FALSE;
            if (m_dwColors >= 256) return FALSE;
        }
    }

    // done
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////

CPB_templ
BOOL CPBAbstract<CPB_args>::palettize
(
    BYTE *pbPalette
)
{
    // do color reduction
    int lowest = 7;
    while (m_dwColors > 256)
    {
        // find the node with the lowest use count that is not a leaf
        DWORD max = ~0;
        DWORD pos = ~0;
        for (DWORD curr = m_adwRoot[lowest]; curr != ~0; curr = m_aSet[curr].next)
        {
            PE *p = m_aSet + curr;

            if (p->numChildren && (p->count < max))
            {
                max = p->count;
                pos = curr;

                if ((p->numChildren == 1) || (p->count <= 2)) break; // shortcut when useful stuff is found
            }
        }
        if (pos == ~0)
        {
            lowest--;
            continue;
        }

        // combine the child nodes
        DWORD  cmax = 0;
        PE     *p    = m_aSet + pos;
        for (int j = 0; j < 16; j++)
        {
            if (p->child[j] != ~0)
            {
                PE *c = m_aSet + p->child[j];

                assert (!c->numChildren);

                if (c->count > cmax)
                {
                    cmax     = c->count;
                    p->color = c->color;
                }

                DWORD a = c->prev;
                DWORD b = c->next;
                if (a != ~0) m_aSet[a].next = b; else m_adwRoot[lowest+1] = b;
                if (b != ~0) m_aSet[b].prev = a;

                m_dwColors--;
                p->child[j] = ~0;
            }
        }
        m_dwColors++;
        p->numChildren = 0;
    }

    // enumerate and build pallette
    DWORD index = 0;
    for (DWORD i = 0; i < 9; i++)
    {
        for (DWORD curr = m_adwRoot[i]; curr != ~0; curr = m_aSet[curr].next)
        {
            PE *p = m_aSet + curr;
            if (!p->numChildren)
            {
                assert (index < 256); // color reduction failed

                if (cdwBPP == 4) *(DWORD*)(pbPalette + index * 4) = p->color;
                            else *(WORD*)(pbPalette + index * 2) = (WORD)p->color;

                p->index          = index;
                index++;
            }
        }
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////

CPB_templ
BOOL CPBAbstract<CPB_args>::apply
(
    DWORD  dwSource,
    DWORD  dwDest,
    DWORD  dwWidth,
    DWORD  dwLogWidth,
    DWORD  dwHeight,
    DWORD  dwLogHeight
)
{
    // convert image and swizzle
    SWIZZLE_ADDR dest;
    DWORD        dwSubHeight = 2048 / (dwWidth * cdwBPP);
    DWORD        dwPitch     = dwWidth * cdwBPP;
    if (!dwSubHeight) dwSubHeight = 1;
                 else dwSubHeight = min(dwSubHeight,dwHeight);
    nvSwizzleAddrCreate (&dest,dwDest,0,0,dwLogWidth,dwLogHeight,1);
    swizzle(dwSource,dwPitch,&dest,dwWidth,dwHeight,dwSubHeight);

    // done
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////

CPB_templ
BOOL CPBAbstract<CPB_args>::freeTable
(
    void
)
{
    if (m_aSet) FreeIPM (m_aSet);
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////

CPB_templ
BOOL CPBAbstract<CPB_args>::depalettizeInPlace
(
    DWORD dwSource,
    DWORD dwDest,
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD *pPalette
)
{
    // depalettize (bottom up since we do this in place)

    nvAssert(cdwBPP == 4);

    DWORD *dwPixels = (DWORD *)dwDest - 1;         //shift the array to optimize the loop
    BYTE * pIndices = (BYTE *)dwSource - 1;

    for (DWORD a = dwHeight*dwWidth; a; a--)
        dwPixels[a]=pPalette[pIndices[a]];

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////

CPB_templ
BOOL CPBAbstract<CPB_args>::depalettizeAndDeswizzle
(
    DWORD dwSource,
    DWORD dwDest,
    DWORD dwWidth,
    DWORD dwLogWidth,
    DWORD dwHeight,
    DWORD dwLogHeight,
    DWORD dwDeviceMemPaletteAddr
)
{
    // copy palette away
    DWORD adwPalette[256];
    memcpy (adwPalette,(char*)dwDeviceMemPaletteAddr,256 * cdwBPP);

    // deswizzle and depalettize
    SWIZZLE_ADDR source;
    DWORD        dwSubHeight = 2048 / (dwWidth * cdwBPP);
    DWORD        dwPitch     = dwWidth * cdwBPP;
    if (!dwSubHeight) dwSubHeight = 1;
                 else dwSubHeight = min(dwSubHeight,dwHeight);
    nvSwizzleAddrCreate (&source,dwSource,0,0,dwLogWidth,dwLogHeight,1);

    DWORD        dwBytes = dwWidth * cdwBPP;
    DWORD        y;
    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;

        for (h = f; h; h--)
        {
            DWORD x;

            for (x = dwWidth; x; x--)
            {
                DWORD dwPel;
                if (cdwBPP == 4) dwPel = adwPalette[*(BYTE*)nvSwizzleAddrGet(&source)];
                            else dwPel = *(WORD*)(DWORD(adwPalette) + 2 * (DWORD)*(BYTE*)nvSwizzleAddrGet(&source));
                put ((BYTE*)a,dwPel);

                a += cdwBPP;
                nvSwizzleAddrNext (&source);
            }

            nvSwizzleAddrNewLine (&source);
        }

        /*
         * write linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (dwDest,a,dwBytes);
            a          += dwBytes;
            dwDest     += dwPitch;
        }

        y -= f;
    }

    // done
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////

// 32
CPBAbstract<0xff000000,24,8,
          0x00ff0000,16,8,
          0x0000ff00, 8,8,
          0x000000ff, 0,8,
          4,PT_8888,
          0x00000000>        g_PB8888;
CPBAbstract<0x00000000, 0,0,
          0x00ff0000,16,8,
          0x0000ff00, 8,8,
          0x000000ff, 0,8,
          4,PT_X888,
          0xff000000>        g_PBX888;
// 16
CPBAbstract<0x0000,12,4,
          0x0000, 8,4,
          0x0000, 4,4,
          0x0000, 0,4,
          2,PT_4444,
          0x00000000>        g_PB4444;
CPBAbstract<0x8000,15,1,
          0x7c00,10,5,
          0x03e0, 5,5,
          0x001f, 0,5,
          2,PT_1555,
          0x0000>            g_PB1555;
CPBAbstract<0x0000, 0,0,
          0x7c00,10,5,
          0x03e0, 5,5,
          0x001f, 0,5,
          2,PT_X555,
          0x8000>            g_PBX555;
CPBAbstract<0x0000, 0,0,
          0xfe00,11,5,
          0x07e0, 5,6,
          0x001f, 0,5,
          2,PT_565,
          0x0000>            g_PB565;

BOOL CPaletteBuilder::initTable  (DWORD dwPalType)
{
    switch (dwPalType)
    {
        case PT_8888: return g_PB8888.initTable();
        case PT_X888: return g_PBX888.initTable();
        case PT_4444: return g_PB4444.initTable();
        case PT_1555: return g_PB1555.initTable();
        case PT_X555: return g_PBX555.initTable();
        case PT_565 : return g_PB565 .initTable();
    }
    return FALSE;
}
BOOL CPaletteBuilder::buildTable (DWORD dwPalType,DWORD dwSource,DWORD dwWidth,DWORD dwHeight)
{
    switch (dwPalType)
    {
        case PT_8888: return g_PB8888.buildTable(dwSource,dwWidth,dwHeight);
        case PT_X888: return g_PBX888.buildTable(dwSource,dwWidth,dwHeight);
        case PT_4444: return g_PB4444.buildTable(dwSource,dwWidth,dwHeight);
        case PT_1555: return g_PB1555.buildTable(dwSource,dwWidth,dwHeight);
        case PT_X555: return g_PBX555.buildTable(dwSource,dwWidth,dwHeight);
        case PT_565 : return g_PB565 .buildTable(dwSource,dwWidth,dwHeight);
    }
    return FALSE;
}
BOOL CPaletteBuilder::palettize (DWORD dwPalType,BYTE *pbPalette)
{
    switch (dwPalType)
    {
        case PT_8888: return g_PB8888.palettize(pbPalette);
        case PT_X888: return g_PBX888.palettize(pbPalette);
        case PT_4444: return g_PB4444.palettize(pbPalette);
        case PT_1555: return g_PB1555.palettize(pbPalette);
        case PT_X555: return g_PBX555.palettize(pbPalette);
        case PT_565 : return g_PB565 .palettize(pbPalette);
    }
    return FALSE;
}
BOOL CPaletteBuilder::apply (DWORD dwPalType,DWORD dwSource,DWORD dwDest,DWORD dwWidth,DWORD dwLogWidth,DWORD dwHeight,DWORD dwLogHeight)
{
    switch (dwPalType)
    {
        case PT_8888: return g_PB8888.apply(dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight);
        case PT_X888: return g_PBX888.apply(dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight);
        case PT_4444: return g_PB4444.apply(dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight);
        case PT_1555: return g_PB1555.apply(dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight);
        case PT_X555: return g_PBX555.apply(dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight);
        case PT_565 : return g_PB565 .apply(dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight);
    }
    return FALSE;
}
BOOL CPaletteBuilder::freeTable (DWORD dwPalType)
{
    switch (dwPalType)
    {
        case PT_8888: return g_PB8888.freeTable();
        case PT_X888: return g_PBX888.freeTable();
        case PT_4444: return g_PB4444.freeTable();
        case PT_1555: return g_PB1555.freeTable();
        case PT_X555: return g_PBX555.freeTable();
        case PT_565 : return g_PB565 .freeTable();
    }
    return FALSE;
}
BOOL CPaletteBuilder::depalettizeInPlace (DWORD dwPalType,DWORD dwSource,DWORD dwDest,DWORD dwWidth,DWORD dwHeight,DWORD *pPalette)
{
    switch (dwPalType)
    {
        case PT_8888: return g_PB8888.depalettizeInPlace(dwSource,dwDest,dwWidth,dwHeight,pPalette);
        case PT_X888: return g_PBX888.depalettizeInPlace(dwSource,dwDest,dwWidth,dwHeight,pPalette);
        case PT_4444: return g_PB4444.depalettizeInPlace(dwSource,dwDest,dwWidth,dwHeight,pPalette);
        case PT_1555: return g_PB1555.depalettizeInPlace(dwSource,dwDest,dwWidth,dwHeight,pPalette);
        case PT_X555: return g_PBX555.depalettizeInPlace(dwSource,dwDest,dwWidth,dwHeight,pPalette);
        case PT_565 : return g_PB565 .depalettizeInPlace(dwSource,dwDest,dwWidth,dwHeight,pPalette);
    }
    return FALSE;
}
BOOL CPaletteBuilder::depalettizeAndDeswizzle (DWORD dwPalType,DWORD dwSource,DWORD dwDest,DWORD dwWidth,DWORD dwLogWidth,DWORD dwHeight,DWORD dwLogHeight,DWORD dwDeviceMemPaletteAddr)
{
    switch (dwPalType)
    {
        case PT_8888: return g_PB8888.depalettizeAndDeswizzle (dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight,dwDeviceMemPaletteAddr);
        case PT_X888: return g_PBX888.depalettizeAndDeswizzle (dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight,dwDeviceMemPaletteAddr);
        case PT_4444: return g_PB4444.depalettizeAndDeswizzle (dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight,dwDeviceMemPaletteAddr);
        case PT_1555: return g_PB1555.depalettizeAndDeswizzle (dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight,dwDeviceMemPaletteAddr);
        case PT_X555: return g_PBX555.depalettizeAndDeswizzle (dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight,dwDeviceMemPaletteAddr);
        case PT_565 : return g_PB565 .depalettizeAndDeswizzle (dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight,dwDeviceMemPaletteAddr);
    }
    return FALSE;
}

}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvTex.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvTex.cpp
//   HW Specific Texture routines.
//
//  History:
//        Charles Inman (chasi)       01/31/98 - re-wrote and cleaned up.
//        Ben de Waal                 10/12/98 - overhaul
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

//****************************************************************************
//****************************************************************************
//****************************************************************************
//**  CTexture  **************************************************************
//****************************************************************************
//****************************************************************************
//****************************************************************************

//****************************************************************************
// invalidateTextureCache
//
// invalidates the texture cache by forcing at least a write to offset

__inline void invalidateTextureCache
(
    PNVD3DCONTEXT pContext   // may be NULL!!
)
{
    dbgTracePush ("invalidateTextureCache");

    if (pContext) {
#if (NVARCH >= 0x20)
        if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_KELVIN | NVCLASS_FAMILY_CELSIUS)) {
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TEXTURE_STATE;
            pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TEXTURE_STATE;
#ifdef STATE_CULL
            // there's no explicit method to clear nv10's texture cache,
            // but re-sending the offset will do it implicitly
            pContext->hwState.celsius.valid [NV056_SET_TEXTURE_OFFSET(0) >> 2] = 0;
            pContext->hwState.celsius.valid [NV056_SET_TEXTURE_OFFSET(1) >> 2] = 0;
#endif
        }
        else
#endif // NVARCH >= 0x10
        {
            NV_FORCE_TRI_SETUP (pContext);
        }
    }

    dbgTracePop();
}

//****************************************************************************
// updateMipMapChain
//
// what does it do?

__forceinline void updateMipMapChain
(
    PNVD3DCONTEXT pContext,  // may be NULL!!
    CNvObject    *pNvObj
)
{
    dbgTracePush ("updateMipMapChain");

    while (pNvObj) {
        // get texture
        CTexture *pTexture = pNvObj->getTexture();

        // if this level has been renamed, copy data forward
        if (pTexture->isRenamedNotCopied())
        {
            DWORD dwSize = pTexture->getBPP() << (pTexture->getLogWidth() + pTexture->getLogHeight());
            DWORD dwSrc  = pTexture->getPreviousSwizzled()->getAddress();
            DWORD dwDst  = pTexture->getSwizzled()->getAddress();
                    #ifdef NV_PROFILE_COPIES
                    NVP_START(NVP_T_RENAME_FWD);
                    #endif
            nvMemCopy (dwDst,dwSrc,dwSize);
                    #ifdef NV_PROFILE_COPIES
                    NVP_STOP(NVP_T_RENAME_FWD);
                    nvpLogTime (NVP_T_RENAME_FWD,nvpTime[NVP_T_RENAME_FWD]);
                    #endif
            pTexture->tagRenamedAndCopied();
        }

        // handle this texture
        if (!pTexture->getSwizzled()->isUpToDate())
        {
            pTexture->updateSwizzleSurface (pContext);
        }

        // get the next one in the chain
        pNvObj = pNvObj->getAttachedA();
    }

    dbgTracePop();
}

//****************************************************************************
// updateTextureSurfaces
//
// update all out-of-date swizzled surfaces in a complex texture.
// traverses all mipmap levels and all faces of a cubemap.

__forceinline void updateSwizzledSurfaces
(
    PNVD3DCONTEXT pContext,  // may be NULL!!
    CTexture     *pTexture
)
{
    // get this object
    CNvObject *pNvObj = pTexture->getLinear()->getWrapper();

    if (!pTexture->getSwizzled()->isUpToDate() || pTexture->isSubSurfacesDirty())
    {
        if (pTexture->isCubeMap())
        {
            // cube map
            while (pNvObj)
            {
                updateMipMapChain (pContext, pNvObj);
                pNvObj = pNvObj->getAttachedB();
            }
        }
        else
        {
            // simple texture
            updateMipMapChain (pContext, pNvObj);
        }
        pTexture->tagSubSurfacesClean();
    }
}

//****************************************************************************
// CTexture::hwLock
//
// aquire hw access to swizzled surface
//  if not swizzled yet, do it now.
// NOTE: if the surface to be locked is a mipmap, or a subsurface of a cube map,
//  this routine will automatically lock the whole chain (logically one memory region)

void CTexture::hwLock
(
    PNVD3DCONTEXT pContext,  // may be NULL!!
    DWORD         dwAccess
)
{
    dbgTracePush ("CTexture::hwLock");

    // if this texture is not the base, call lock with a base
    //  yes - we can honestly say we use recursion in our driver now!
    nvAssert (getBaseTexture());
    if (!isBaseTexture()) {
        getBaseTexture()->hwLock (pContext,dwAccess);
        dbgTracePop();
        return;
    }

#ifdef TEX_MANAGE
    if (isManaged()) {
        // if the texture is in system memory, we have to bring it into video or AGP
        if (getSwizzled()->getHeapLocation() == CSimpleSurface::HEAP_SYS) {
            BOOL bSuccess = nvTexManageFetch (pContext, this);
            nvAssert (bSuccess);
        }
        else {
            // just make a note of the fact that we've touched this texture
            nvTexManageTouch (pContext, this);
        }
    }
#endif

    // update only if dirty
#if defined(NV_NULL_DRIVER) || defined(NV_NULL_TEXTURE_DRIVER)
    // NOP
#else
    updateSwizzledSurfaces (pContext, this);

    // lock surface explicitly
    m_surfSwizzled.hwLock (dwAccess);
#endif // NULL

    dbgTracePop();
}

//****************************************************************************
// CTexture::internalCanRename
//
// tell surface renamer if it is OK to rename a this texture now

BOOL CTexture::internalCanRename
(
    void
)
{
    //
    // cannot rename cube maps or individual mipmap levels (for now)
    //
    dbgTracePush ("CTexture::internalCanRename");
    BOOL b = (!isCubeMap() && !isUserMipLevel());
    dbgTracePop();
    return b;
}

// helper wrapper

BOOL __stdcall _CTexture_canRename
(
    void *pContext
)
{
    dbgTracePush ("_CTexture_canRename");
    BOOL b = ((CTexture*)pContext)->internalCanRename();
    dbgTracePop();
    return b;
}

//****************************************************************************
// CTexture::enableRenaming
//
// enable texture renaming

void CTexture::internalRename
(
    DWORD dwOldIndex,
    DWORD dwNewIndex
)
{
    dbgTracePush ("CTexture::internalRename");

    // make sure that the 'old' surface does not have any pending
    //  copies. (i.e. we only rename one level ahead without copying).
/*todo*/ //hwLock (NULL,);

    // since we can only rename on a BLT to the top-level, we have to
    // tell all the mipmaps that they should take care of themselves
    // if they do not get updated properly (i.e. copy from old surface)
    DWORD dwAddr = m_surfSwizzled.getSurface(dwNewIndex)->getAddress();
    DWORD dwBPP  = getBPP();
    DWORD dwAdd  = dwBPP << (getLogWidth() + getLogHeight());

    CNvObject *pNvObj = getWrapper();


    if (pNvObj)
    {
        // skip the parent level
        dwAddr  += dwAdd;
        dwAdd  >>= 2;
        if (dwAdd < dwBPP) dwAdd = dwBPP;
        pNvObj = pNvObj->getAttachedA();
    }

    while (pNvObj)
    {
        // get texture
        CTexture *pTexture = pNvObj->getTexture();
        pTexture->tagRenamedNotCopied();
        pTexture->m_surfSwizzled.forceRename(dwNewIndex,dwAddr);

        // update (allow DXT to work down to 1x1 (which is stored as 4x4))
        dwAddr  += dwAdd;
        dwAdd  >>= 2;
        if (dwAdd < dwBPP) dwAdd = dwBPP;

        // get the next one in the chain
        pNvObj = pNvObj->getAttachedA();
    }

    tagSubSurfacesDirty();
    dbgTracePop();
}

// helper wrapper

void __stdcall _CTexture_rename
(
    void         *pTexture,
    DWORD         dwOldIndex,
    DWORD         dwNewIndex
)
{
    dbgTracePush ("_CTexture_rename");
    if(dbgShowState & NVDBG_SHOW_TEXTURE_RENAME)
        DPF("CTexture Renaming Handle: %08x TexAddr: %08x INDEX: %08x->%08x\n",
            (((CTexture*)pTexture)->getWrapper())->getHandle(), pTexture,
            dwOldIndex,dwNewIndex);

    ((CTexture*)pTexture)->internalRename(dwOldIndex,dwNewIndex);
    dbgTracePop();
}

//****************************************************************************
// CTexture::enableRenaming
//
// enable texture renaming

void CTexture::enableRenaming
(
    void
)
{
    dbgTracePush ("CTexture::enableRenaming");
    //
    // enable renaming with special callbacks
    //
    m_surfSwizzled.tagRenameEnable (CComplexSurface<TOTAL_TEX_RENAME>::RENAME_EXTERNAL,
                                    1, // todo: same here
                                    _CTexture_canRename,
                                    _CTexture_rename,
                                    this);
    dbgTracePop();
}

//****************************************************************************
// CTexture::calcMipMapSize
//
// calculates the amount of bytes needed with a given number of mipmaps

DWORD CTexture::calcMipMapSize
(
    DWORD dwLogU,
    DWORD dwLogV,
    DWORD dwLogP,
    DWORD dwMipMapLevels
)
{
    dbgTracePush ("CTexture::calcMipMapSize");

    DWORD dwSize = 0;
    while (dwMipMapLevels)
    {
        dwSize += 1U << (dwLogU + dwLogV + dwLogP);
        if (dwLogU) dwLogU --;
        if (dwLogV) dwLogV --;
        if (dwLogP) dwLogP --;
        dwMipMapLevels --;
    }

    dbgTracePop();
    return dwSize;

/*
    neat code that works for mipmaps that got to Nx1 or 1xN, not 1x1 (if non-square)

    DWORD dwBits  = ((dwLogU + dwLogV) & 1) ? 0xaaaaaaaa : 0x55555555;
    DWORD dwTotal =  ((1 << (dwLogU + dwLogV + 1)) - 1) & dwBits;
    DWORD dwMask  = ~((1 << (dwLogU + dwLogV + 2 - dwMipMapLevels * 2)) - 1);
    return dwTotal & dwMask;
*/
}

//****************************************************************************
// CTexture::getCubeMapFaceNum
//
// get the face number from the face flag

DWORD CTexture::getCubeMapFaceNum
(
    DWORD dwFace              // cubemap face flag
)
{
    DWORD dwFaceNum;

    dbgTracePush ("CTexture::getCubeMapFaceNum");

    switch (dwFace) {
        case DDSCAPS2_CUBEMAP_POSITIVEX:
            dwFaceNum = 0;
            break;
        case DDSCAPS2_CUBEMAP_NEGATIVEX:
            dwFaceNum = 1;
            break;
        case DDSCAPS2_CUBEMAP_POSITIVEY:
            dwFaceNum = 2;
            break;
        case DDSCAPS2_CUBEMAP_NEGATIVEY:
            dwFaceNum = 3;
            break;
        case DDSCAPS2_CUBEMAP_POSITIVEZ:
            dwFaceNum = 4;
            break;
        case DDSCAPS2_CUBEMAP_NEGATIVEZ:
            dwFaceNum = 5;
            break;
    }

    dbgTracePop();
    return dwFaceNum;
}

//****************************************************************************
// CTexture::prepareLinearAsRenderTarget
//
// checks that the linear copy of the texture is in video memory. if it does
//  not exist, or if it is in a different heap, relocate it

BOOL CTexture::prepareLinearAsRenderTarget
(
    void
)
{
    dbgTracePush ("CTexture[%08x]::prepareLinearAsRenderTarget()",this);

    // sanity checks
    assert (this);

    // we are going to use the linear surface, make sure it's up to date
    if (!updateLinearSurface())
    {
        dbgTracePop();
        return FALSE;
    }

    // is it in the right place? (vidmem)
    if (!(getLinear()->getHeapLocation() == CSimpleSurface::HEAP_VID))
    {
        // nope, allocate a version in video memory
        CSimpleSurface surfTemp;
        if (!surfTemp.create (getLinear()->getWrapper(), getLinear()->getFormat(),
                              getLinear()->getWidth(), getLinear()->getHeight(), getLinear()->getDepth(),
                              getLinear()->getMultiSampleBits(), getLinear()->getBPPRequested(), getLinear()->getBPP(),
                              getLinear()->getPitch(), CSimpleSurface::HEAP_VID,
                              CSimpleSurface::HEAP_VID, CSimpleSurface::ALLOCATE_TILED
#ifdef CAPTURE
                             ,CAPTURE_SURFACE_KIND_TEXTURE
#endif
                              ))
        {
            dbgTracePop();
            return FALSE;
        }

        // copy contents from original surface to the new one
        nvMemCopy (surfTemp.getAddress(),
                   getLinear()->getAddress(),
                   getLinear()->getSize());

        // swap surfaces
        //  neat trick to make the temp surface own the old non-vidmem surface
        getLinear()->swap (&surfTemp);

        // destroy old surface
        surfTemp.destroy();
    }

    // tag swizzled out-of-date, so that it gets reswizzled from the linear
    //  surface when it is used as a texture
    getSwizzled()->tagOutOfDate();

    // if this is part of a cube map/mipmap, tag the base as dirty
    //  this will trigger a proper update of all subsurfaces before HW touches them
    if (isUserMipLevel() || isCubeMap())
    {
        getBaseTexture()->tagSubSurfacesDirty();
    }

    // tag linear as up-to-date
    getLinear()->tagUpToDate();

    // done
    dbgTracePop();
    return TRUE;
}

//****************************************************************************
// CTexture::updateLinearSurface
//

BOOL CTexture::updateLinearSurface
(
    void
)
{
    dbgTracePush ("CTexture[%08x]::updateLinearSurface()",this);

    // texture valid
    assert (this);

    // cache active swizzled surface
    CSimpleSurface *pActive = getSwizzled();

    // create a linear surface if it does not exist already
    //  note that the linear surface for render targets get allocated in
    //   CTexture::prepareLinearAsRenderTarget(), and not here
    if (m_surfLinear.isValid())
    {
        // we have a linear surface, is it already up to date?
        if (m_surfLinear.isUpToDate())
        {
            // yes, we have no work!
            dbgTracePop();
            return TRUE;
        }
    }
    else
    {
        // allocate surface
        DWORD dwAllowedHeaps  = pDriverData->GARTLinearBase ? (CSimpleSurface::HEAP_VID | CSimpleSurface::HEAP_AGP | CSimpleSurface::HEAP_SYS)
                                                            : (CSimpleSurface::HEAP_VID | CSimpleSurface::HEAP_PCI | CSimpleSurface::HEAP_SYS);

        DWORD dwPreferredHeap = CSimpleSurface::HEAP_SYS;

        if (!((CSimpleSurface*)&m_surfLinear)->create (getPitch(), getHeight(), getDepth(), getBPP(),
                                                       dwAllowedHeaps, dwPreferredHeap,
                                                       CSimpleSurface::ALLOCATE_SIMPLE
#ifdef CAPTURE
                                                      ,CAPTURE_SURFACE_KIND_TARGET
#endif
                                                       ))
        {
            // no memory - ouch
            DPF ("CTexture::updateLinearSurface: cannot allocate linear surface");
            dbgD3DError();
            dbgTracePop();
            return FALSE;
        }
    }

    // Is the swizzle surface valid?
    //  if so then we deswizzle here. This is skipped usually when the app wants to
    //  lock the texture and hasn't touched a pixel yet
    if (pActive->isValid() && pActive->isUpToDate())
    {
        // deswizzle
                #ifdef NV_PROFILE_CPULOCK
                NVP_START (NVP_T_TEX_ULS);
                #endif
        DDLOCKINDEX(NVSTAT_LOCK_UPDATE_LINEAR);
        m_surfLinear.cpuLock (CSimpleSurface::LOCK_NORMAL);
        pActive->cpuLock (CSimpleSurface::LOCK_NORMAL);
                #ifdef NV_PROFILE_CPULOCK
                NVP_STOP (NVP_T_TEX_ULS);
                nvpLogTime (NVP_T_TEX_ULS,nvpTime[NVP_T_TEX_ULS]);
                #endif
        if (isDXT())
        {
            nvSwizBlt_cpu_lin2lin (pActive->getAddress(),getPitch(),0,0,
                                   m_surfLinear.getAddress(),getPitch(),0,0,
                                   getWidth(),getHeight(),getBPP());
        }
        else
        {
            nvSwizBlt_cpu_swz2lin (pActive->getAddress(),0,0,getLogWidth(),getLogHeight(),
                                   m_surfLinear.getAddress(),getPitch(),0,0,
                                   getWidth(),getHeight(),getBPP());
        }
        pActive->cpuUnlock();
        m_surfLinear.cpuUnlock();
    }

    // update flags & reset dirty rectangle
    m_surfLinear.tagUpToDate();

    // done
    dbgTracePop();
    return TRUE;
}

//****************************************************************************
// CTexture::updateSwizzleSurface
//

BOOL CTexture::updateSwizzleSurface
(
    PNVD3DCONTEXT pContext  // may be NULL!
)
{
    dbgTracePush ("CTexture[%08x]::updateSwizzleSurface()",this);

    // texture valid
    assert (this);

    // get active swizzled surface
    CSimpleSurface *pActive = getSwizzled();

    // create swizzled surface if it does not exist already
    // note that the linear surface for render targets get allocated in
    // CTexture::prepareLinearAsRenderTarget(), and not here

    if (!pActive->isValid()) {
        // allocate surface
        DWORD dwAllowedHeaps  = pDriverData->GARTLinearBase ? (CSimpleSurface::HEAP_VID | CSimpleSurface::HEAP_AGP)
                                                            : (CSimpleSurface::HEAP_VID | CSimpleSurface::HEAP_PCI);

        DWORD dwPreferredHeap = (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_TEXTURE_PREFER_AGP) ? ( CSimpleSurface::HEAP_AGP | CSimpleSurface::HEAP_PCI)
                                                                                                           : CSimpleSurface::HEAP_VID;

        if (!pActive->create (getPitch(), getHeight(), getDepth(), getBPP(),
                              dwAllowedHeaps, dwPreferredHeap,
                              CSimpleSurface::ALLOCATE_SIMPLE
#ifdef CAPTURE
                             ,CAPTURE_SURFACE_KIND_TEXTURE
#endif
                              )) {
            // no memory - ouch
            DPF ("CTexture::updateSwizzleSurface: cannot allocate swizzled surface");
            dbgD3DError();
            dbgTracePop();
            return FALSE;
        }
    }
    else {
        // we have a swizzled surface, is it already up to date?
        if (pActive->isUpToDate()) {
            // yes, we have no work!
            dbgTracePop();
            return TRUE;
        }
    }

    // if the source is up to date, we can now swizzle it
    //  if not, texture corruption will occur because the app failed to init the texture

    if (m_surfLinear.isValid() && m_surfLinear.isUpToDate()) {
        // swizzle
        BOOL bUseHW = (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_TEXTURE_USEHW)
                   && m_surfLinear.hwCanRead()
                   && pActive->hwCanWrite();

        if (bUseHW)
        {
            m_surfLinear.hwLock(CSimpleSurface::LOCK_NORMAL);
            pActive->hwLock(CSimpleSurface::LOCK_NORMAL);
            nvSwizBlt_gpu_lin2swz (m_surfLinear.getOffset(), m_surfLinear.getHeapLocation(),
                                   getPitch(), 0, 0,
                                   pActive->getOffset(), 0, 0,
                                   getLogWidth(), getLogHeight(),
                                   getWidth(), getHeight(),
                                   getBPP());
            pActive->hwUnlock();
            m_surfLinear.hwUnlock();
        }
        else
        {
                    #ifdef NV_PROFILE_CPULOCK
                    NVP_START (NVP_T_TEX_USS);
                    #endif
            DDLOCKINDEX(NVSTAT_LOCK_UPDATE_OPTIMIZED);
            m_surfLinear.cpuLock (CSimpleSurface::LOCK_NORMAL);
            pActive->cpuLock (CSimpleSurface::LOCK_RENAME); // allow renaming
                    #ifdef NV_PROFILE_CPULOCK
                    NVP_STOP (NVP_T_TEX_USS);
                    nvpLogTime (NVP_T_TEX_USS,nvpTime[NVP_T_TEX_USS]);
                    #endif
            if (isDXT())
            {
                nvSwizBlt_cpu_lin2lin (m_surfLinear.getAddress(),getPitch(),0,0,
                                       pActive->getAddress(),getPitch(),0,0,
                                       getWidth(),getHeight(),getBPP());
            }
            else
            {
                nvSwizBlt_cpu_lin2swz (m_surfLinear.getAddress(),getPitch(),0,0,
                                       pActive->getAddress(),0,0,getLogWidth(),getLogHeight(),
                                       getWidth(),getHeight(),getBPP());
            }

            // capture
#ifdef CAPTURE
            if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                CAPTURE_MEMORY_WRITE memwr;
                memwr.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                memwr.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                memwr.dwExtensionID        = CAPTURE_XID_MEMORY_WRITE;
                memwr.dwCtxDMAHandle       = (pActive->getHeapLocation() == CSimpleSurface::HEAP_VID)
                                           ? NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY
                                           : D3D_CONTEXT_DMA_HOST_MEMORY;
                memwr.dwOffset             = pActive->getOffset();
                memwr.dwSize               = getWidth() * getHeight() * getBPP();
                captureLog (&memwr,sizeof(memwr));
                captureLog ((void*)pActive->getAddress(),memwr.dwSize);
            }
#endif

            //
            // BUGBUG this should like below (test with powerslide)
            //
            // problem is that hwLock is called in inner loops after it read the dvb values. if
            //  the lock modifies them, it does not detect that case.
            //
            // can help perf if fixed.
            //
/*            nvSwizBlt_lin2swz (m_surfLinear.getAddress(),getPitch(),0,0,
                                    this,pActive->getAddress(),0,0,getLogWidth(),getLogHeight(),
                                    getWidth(),getHeight(),getBPP());*/
            pActive->cpuUnlock();
            m_surfLinear.cpuUnlock();
            invalidateTextureCache (pContext);
        }
    }

    // update state
    pActive->tagUpToDate();

    // done
    dbgTracePop();
    return TRUE;
}

//****************************************************************************

#if (NVARCH >= 0x010)

// pre-calculate HW-specific control words

void CTexture::calculateNV056ControlWords
(
    void
)
{
    m_dwNV056Control0  = DRF_DEF(056, _SET_TEXTURE_CONTROL0, _ENABLE, _TRUE);
    // these are backward from openGL. d3d can only set the maximum mipmap level, by which they mean
    // the openGL minimum level (d3d maximum = largest sized level to use, not largest level number).
    // the d3d minimum level (the openGL / celsius maximum) is always just the end of the chain
    m_dwNV056Control0 |= DRF_NUM(056, _SET_TEXTURE_CONTROL0, _MAX_LOD_CLAMP, ((m_dwMipMapCount-1) << 8));  // 4.8 fixed point
    // Let's assume these defaults are cool for D3D. Alpha kill works
    // when color key is set to kill (I think).
    m_dwNV056Control0 |= DRF_DEF(056, _SET_TEXTURE_CONTROL0, _ALPHA_KILL_ENABLE, _FALSE);

    m_dwNV056Format  = DRF_NUM(056, _SET_TEXTURE_FORMAT, _CONTEXT_DMA, nv056TextureContextDma[getSwizzled()->getContextDMA()]);
    m_dwNV056Format |= DRF_NUM(056, _SET_TEXTURE_FORMAT, _COLOR, nv056TextureFormat[m_surfLinear.getFormat()]);

    // texel alignment
    m_dwNV056Format |= ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_ZOH_MASK) == D3D_REG_TEXELALIGNMENT_ZOH_CENTER)
                    ? DRF_DEF(056, _SET_TEXTURE_FORMAT, _ORIGIN_ZOH, _CENTER)
                    : DRF_DEF(056, _SET_TEXTURE_FORMAT, _ORIGIN_ZOH, _CORNER);
    m_dwNV056Format |= ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_FOH_MASK) == D3D_REG_TEXELALIGNMENT_FOH_CENTER)
                    ? DRF_DEF(056, _SET_TEXTURE_FORMAT, _ORIGIN_FOH, _CENTER)
                    : DRF_DEF(056, _SET_TEXTURE_FORMAT, _ORIGIN_FOH, _CORNER);

    // levels should already be clamped to 1-15
    nvAssert ((m_dwMipMapCount > 0) && (m_dwMipMapCount < 16));
    m_dwNV056Format |= DRF_NUM(056, _SET_TEXTURE_FORMAT, _MIPMAP_LEVELS, m_dwMipMapCount);
    m_dwNV056Format |= DRF_NUM(056, _SET_TEXTURE_FORMAT, _BASE_SIZE_U, getLogicalLogWidth());
    m_dwNV056Format |= DRF_NUM(056, _SET_TEXTURE_FORMAT, _BASE_SIZE_V, getLogicalLogHeight());
}

#endif  // NVARCH >= 0x010

//****************************************************************************
// CTexture::create
//
// create a base level texture

BOOL CTexture::create
(
    CNvObject *pWrapperObject,   // NvObject wrapping this texture
    DWORD      dwWidth,          // width
    DWORD      dwHeight,         // height
    DWORD      dwDepth,          // depth
    DWORD      dwBPPRequested,   // bytes per pixel requested
    DWORD      dwBPPGranted,     // bytes per pixel granted
    DWORD      dwMipMapCount,    // # of mipmaps (including self)
    DWORD      dwFormat,         // texture format NV_TEXTURE_FORMAT_xxx
    DWORD      dwAllowedHeaps,   // allowed heaps to allocate in
    DWORD      dwPreferredHeap   // preferred heap
)
{
    dbgTracePush ("CTexture[%08x]::create(dwWidth=%d,dwHeight=%d,dwBPP=%d,dwMipMapCount=%d,dwFormat=%x,dwAllowedHeaps=%x,dwPreferredHeap=%x)",
                  this,dwWidth,dwHeight,dwBPPGranted,dwMipMapCount,dwFormat,dwAllowedHeaps,dwPreferredHeap);

    // valid?
    assert (this);

    DWORD dwLogWidth  = dwWidth;
    DWORD dwLogHeight = dwHeight;
    DWORD dwLogDepth  = dwDepth;
    ASM_LOG2 (dwLogWidth);
    ASM_LOG2 (dwLogHeight);
    ASM_LOG2 (dwLogDepth);

    // determine size of texture
    //  - include mipmaps
    DWORD dwSize = calcMipMapSize(dwLogWidth, dwLogHeight, dwLogDepth, dwMipMapCount) * dwBPPGranted;

    // cubemap
    if (isCubeMap())
    {
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            m_dwCubeMapSizeFacePadded = (dwSize + NV_KELVIN_CUBEMAP_FACE_ALIGN) & ~NV_KELVIN_CUBEMAP_FACE_ALIGN;
        } else {
            m_dwCubeMapSizeFacePadded = (isDXT() || isPalettized()) ?
                                        (dwSize + NV_CELSIUS_CUBEMAP_FACE_ALIGN_COMPRESSED) & ~NV_CELSIUS_CUBEMAP_FACE_ALIGN_COMPRESSED :
                                        (dwSize + NV_CELSIUS_CUBEMAP_FACE_ALIGN) & ~NV_CELSIUS_CUBEMAP_FACE_ALIGN;
        }
        dwSize = 6 * m_dwCubeMapSizeFacePadded;
    }

    // if we prefer AGP memory over VID memory
    if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_TEXTURE_PREFER_AGP)
    {
        // if we are allowed agp and video memory to allocate in
        if ((dwPreferredHeap & (CSimpleSurface::HEAP_VID | CSimpleSurface::HEAP_AGP)) == (CSimpleSurface::HEAP_VID | CSimpleSurface::HEAP_AGP))
        {
            // if we want video
            if (dwPreferredHeap == CSimpleSurface::HEAP_VID)
            {
                // override to agp
                dwPreferredHeap = CSimpleSurface::HEAP_AGP;
            }
        }
    }

    // allocate surface
    if (!m_surfSwizzled.create (pWrapperObject, dwSize, dwAllowedHeaps, dwPreferredHeap
#ifdef CAPTURE
                               ,CAPTURE_SURFACE_KIND_TEXTURE
#endif
                                ))
    {
        DPF ("CTexture::create: failed to alloc surface");
        dbgTracePop();
        return FALSE;
    }

    m_surfLinear.setWrapper      (pWrapperObject);
    m_surfLinear.setWidth        (dwWidth);
    m_surfLinear.setHeight       (dwHeight);
    m_surfLinear.setDepth        (dwDepth);
    m_surfLinear.setBPP          (dwBPPGranted);
    m_surfLinear.setBPPRequested (dwBPPRequested);
    m_surfLinear.setFormat       (dwFormat);
    m_surfLinear.setPitch        (dwBPPGranted << dwLogWidth);
    m_surfLinear.setSlicePitch   (dwBPPGranted << (dwLogWidth+dwLogDepth));

    m_dwLogWidth    = dwLogWidth;
    m_dwLogHeight   = dwLogHeight;
    m_dwLogDepth    = dwLogDepth;
    m_dwMipMapCount = dwMipMapCount;

    // pre-calculate HW-specific control words
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        calculateNV056ControlWords();
    }
#endif  // NVARCH >= 0x010

    dbgTracePop();
    return TRUE;
}

//****************************************************************************
// CTexture::create
//
// create a mipmap level texture

BOOL CTexture::create
(
    CNvObject *pWrapperObject,   // NvObject wrapping this texture
    DWORD      dwThisFace,
    CTexture  *pBaseTexture,   // create a mipmap from this base
    DWORD      dwMipMapLevel   // this is the nth mipmap (base = 0)
)
{
    dbgTracePush ("CTexture[%08x]::create(dwThisFace=%d,pBaseTexture=%08x,dwMipMapLevel=%d)",
                  this,dwThisFace,pBaseTexture,dwMipMapLevel);

    // valid?
    assert (this);

    // prepare information for this mipmap level
    DWORD dwBaseLogWidth  = pBaseTexture->getLogWidth();
    DWORD dwBaseLogHeight = pBaseTexture->getLogHeight();
    DWORD dwBaseLogDepth  = pBaseTexture->getLogDepth();
    DWORD dwLogWidth      = DWORD(max(0,int(dwBaseLogWidth  - dwMipMapLevel)));
    DWORD dwLogHeight     = DWORD(max(0,int(dwBaseLogHeight - dwMipMapLevel)));
    DWORD dwLogDepth      = DWORD(max(0,int(dwBaseLogDepth  - dwMipMapLevel)));
    DWORD dwWidth         = 1 << dwLogWidth;
    DWORD dwHeight        = 1 << dwLogHeight;
    DWORD dwDepth         = 1 << dwLogDepth;
    DWORD dwBPP           = pBaseTexture->getBPP();
    DWORD dwBPPRequested  = pBaseTexture->getBPPRequested();
    DWORD dwFormat        = pBaseTexture->getFormat();
    DWORD dwMipMapCount   = pBaseTexture->getMipMapCount() - dwMipMapLevel;
    DWORD dwPitch         = dwBPP << dwLogWidth;
    DWORD dwSize          = calcMipMapSize(dwLogWidth,dwLogHeight,dwLogDepth,dwMipMapCount) * dwBPP;
    DWORD dwAddress       = pBaseTexture->getSwizzled()->getAddress()
                          + pBaseTexture->getSwizzled()->getSize()
                          - dwSize;
    DWORD dwHeapLocation  = pBaseTexture->getSwizzled()->getHeapLocation();

    // cubemap
    if (isCubeMap())
    {
        // copy cube map info from base
        m_dwCubeMapSizeFacePadded = pBaseTexture->m_dwCubeMapSizeFacePadded;

        // get offset to this face
        dwAddress = pBaseTexture->getSwizzled()->getAddress()
                  + getCubeMapFaceNum(dwThisFace) * m_dwCubeMapSizeFacePadded
                  + calcMipMapSize(dwBaseLogWidth,dwBaseLogHeight,dwBaseLogDepth,dwMipMapLevel) * dwBPP;
    }

    // point texture to proper place off of base texture
    if (!m_surfSwizzled.own (dwAddress, dwPitch, dwLogHeight, dwHeapLocation, FALSE))
    {
        DPF ("CTexture::create: failed to claim surface");
        dbgTracePop();
        return FALSE;
    }

    // assign variables
    m_surfLinear.setWrapper      (pWrapperObject);
    m_surfLinear.setWidth        (dwWidth);
    m_surfLinear.setHeight       (dwHeight);
    m_surfLinear.setDepth        (dwDepth);
    m_surfLinear.setBPP          (dwBPP);
    m_surfLinear.setBPPRequested (dwBPPRequested);
    m_surfLinear.setFormat       (dwFormat);
    m_surfLinear.setPitch        (dwBPP << dwLogWidth);
    m_surfLinear.setSlicePitch   (dwBPP << (dwLogWidth+dwLogDepth));

    m_dwLogWidth    = dwLogWidth;
    m_dwLogHeight   = dwLogHeight;
    m_dwLogDepth    = dwLogDepth;
    m_dwMipMapCount = dwMipMapCount;
    m_pBaseTexture  = pBaseTexture;

    // update state
    tagUserMipLevel();

    // pre-calculate HW-specific control words
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        calculateNV056ControlWords();
    }
#endif  // NVARCH >= 0x010

    dbgTracePop();
    return TRUE;
}

#ifdef TEX_MANAGE

//****************************************************************************

// CTexture::fetch
//
// bring a texture from system memory back into HW-readable memory (ie. video or AGP)
// returns TRUE on success, FALSE on failure

BOOL CTexture::fetch (void)
{
    CComplexSurface<TOTAL_TEX_RENAME> newSurfSwizzled;

    dbgTracePush ("CTexture::fetch");

    // this should be the base texture
    nvAssert (isBaseTexture());

    if (getSwizzled()->getHeapLocation() != CSimpleSurface::HEAP_SYS) {
        // texture is already in video or AGP memory. this shouldn't really have been called
        DPF ("attempt to fetch an unevicted texture");
        dbgD3DError();
        dbgTracePop();
        return (TRUE);
    }

    // determine the size of the texture
    DWORD dwSize;
    if (isCubeMap()) {
        dwSize = 6 * m_dwCubeMapSizeFacePadded;
    }
    else {
        dwSize = getBPP() * calcMipMapSize (m_dwLogWidth, m_dwLogHeight, m_dwLogDepth, m_dwMipMapCount);
    }

    // alternately, i think this should work...
    DWORD dwSize2 = m_surfSwizzled.getActiveSurface()->getPitch() * m_surfSwizzled.getActiveSurface()->getHeight();
    nvAssert (dwSize == dwSize2);

    // allocate a new surface in system memory
    DWORD dwPreferredHeap = CSimpleSurface::HEAP_VID;
    DWORD dwAllowedHeaps  = CSimpleSurface::HEAP_VID |
                            ((pDriverData->GARTLinearBase) ?
                                CSimpleSurface::HEAP_AGP :
                                CSimpleSurface::HEAP_PCI);

#ifdef TEX_MANAGE_TEST
    dwAllowedHeaps = dwPreferredHeap = CSimpleSurface::HEAP_VID;
#endif

    if (!newSurfSwizzled.create (m_surfLinear.getWrapper(), dwSize, dwAllowedHeaps, dwPreferredHeap
#ifdef CAPTURE
                                ,CAPTURE_SURFACE_KIND_TEXTURE
#endif
                                ))
    {
        dbgTracePop();
        return (FALSE);
    }

    // copy texture data to the new surface
    nvMemCopy (newSurfSwizzled.getActiveSurface()->getAddress(), m_surfSwizzled.getActiveSurface()->getAddress(), dwSize);

    // swap the new into the old, and destroy the new, which is now the old  :)
    m_surfSwizzled.swap (&newSurfSwizzled);
    newSurfSwizzled.destroy();

    // re-fresh HW control words (heap may have changed)
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        calculateNV056ControlWords();
    }
#endif  // NVARCH >= 0x010

    // run down the attached textures and reset their pointers into the new surface
    CNvObject *pNvObjA, *pNvObjB;
    DWORD     dwFace, dwMMLevel;

    dwFace     = DDSCAPS2_CUBEMAP_POSITIVEX;
    dwMMLevel  = 0;

    // this surface's mipmaps
    pNvObjA = m_surfLinear.getWrapper()->getAttachedA();
    while (pNvObjA) {
        dwMMLevel++;
        pNvObjA->getTexture()->create (pNvObjA, dwFace, this, dwMMLevel);
        pNvObjA = pNvObjA->getAttachedA();
    }

    // run down the cubemap faces (if any)
    pNvObjB = m_surfLinear.getWrapper()->getAttachedB();
    while (pNvObjB) {
        dwFace <<= 1;
        dwMMLevel = 0;
        pNvObjB->getTexture()->create (pNvObjB, dwFace, this, dwMMLevel);
        pNvObjA = pNvObjB->getAttachedA();
        while (pNvObjA) {
            dwMMLevel++;
            pNvObjA->getTexture()->create (pNvObjA, dwFace, this, dwMMLevel);
            pNvObjA = pNvObjA->getAttachedA();
        }
        pNvObjB = pNvObjB->getAttachedB();
    }

    dbgTracePop();
    return (TRUE);
}

//****************************************************************************

// CTexture::evict
//
// evict a texture from video or AGP memory into system memory
// returns TRUE on success, FALSE on failure

BOOL CTexture::evict (void)
{
    CComplexSurface<TOTAL_TEX_RENAME> newSurfSwizzled;

    dbgTracePush ("CTexture::evict");

    // make sure this is a base texture
    nvAssert (isBaseTexture());

    if (isEvicted()) {
        // texture is already evicted. this shouldn't really have been called
        DPF ("ack. attempt to evict texture that's already been evicted");
        dbgD3DError();
        dbgTracePop();
        return (TRUE);
    }

    // if the texture is in use, it can't be evicted
    if (getSwizzled()->isBusy()) {
        dbgTracePop();
        return (FALSE);
    }

    // determine the size of the texture
    DWORD dwSize;
    if (isCubeMap()) {
        dwSize = 6 * m_dwCubeMapSizeFacePadded;
    }
    else {
        dwSize = getBPP() * calcMipMapSize (m_dwLogWidth, m_dwLogHeight, m_dwLogDepth, m_dwMipMapCount);
    }

    // alternately, i think this should work...
    DWORD dwSize2 = m_surfSwizzled.getActiveSurface()->getPitch() * m_surfSwizzled.getActiveSurface()->getHeight();
    nvAssert (dwSize == dwSize2);

    // allocate a new surface in system memory
    if (!newSurfSwizzled.create (m_surfLinear.getWrapper(), dwSize, CSimpleSurface::HEAP_SYS, CSimpleSurface::HEAP_SYS
#ifdef CAPTURE
                                ,CAPTURE_SURFACE_KIND_TEXTURE
#endif
                                 ))
    {
        DPF ("CTexture::evict: failed to alloc system memory surface");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    // copy texture data to the new surface
    nvMemCopy (newSurfSwizzled.getActiveSurface()->getAddress(), m_surfSwizzled.getActiveSurface()->getAddress(), dwSize);

    // swap the new into the old, and destroy the new, which is now the old  :)
    m_surfSwizzled.swap (&newSurfSwizzled);
    newSurfSwizzled.destroy();

    // re-fresh HW control words (heap may have changed)
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        calculateNV056ControlWords();
    }
#endif  // NVARCH >= 0x010

    // run down the attached textures and reset their pointers into the new surface
    CNvObject *pNvObjA, *pNvObjB;
    DWORD     dwFace, dwMMLevel;

    dwFace     = DDSCAPS2_CUBEMAP_POSITIVEX;
    dwMMLevel  = 0;

    // this surface's mipmaps
    pNvObjA = m_surfLinear.getWrapper()->getAttachedA();
    while (pNvObjA) {
        dwMMLevel++;
        pNvObjA->getTexture()->create (pNvObjA, dwFace, this, dwMMLevel);
        pNvObjA = pNvObjA->getAttachedA();
    }

    // run down the cubemap faces (if any)
    pNvObjB = m_surfLinear.getWrapper()->getAttachedB();
    while (pNvObjB) {
        dwFace <<= 1;
        dwMMLevel = 0;
        pNvObjB->getTexture()->create (pNvObjB, dwFace, this, dwMMLevel);
        pNvObjA = pNvObjB->getAttachedA();
        while (pNvObjA) {
            dwMMLevel++;
            pNvObjA->getTexture()->create (pNvObjA, dwFace, this, dwMMLevel);
            pNvObjA = pNvObjA->getAttachedA();
        }
        pNvObjB = pNvObjB->getAttachedB();
    }

    dbgTracePop();
    return (TRUE);
}

#endif  // TEX_MANAGE

//****************************************************************************
// CTexture::destroy
//

BOOL CTexture::destroy
(
    void
)
{
    dbgTracePush ("CTexture[%08x]::destroy()",this);

    // valid?
    assert (this);

    // destroy surface(s)
    if (m_surfLinear.isValid())
    {
        m_surfLinear.destroy();
    }
    m_surfSwizzled.destroy();

    dbgTracePop();
    return TRUE;
}

//****************************************************************************
// CTexture::CTexture
//

CTexture::CTexture
(
    void
)
{
    dbgTracePush ("CTexture[%08x]::CTexture()",this);

    // alloc succeeded?
    assert (this);

    // init
    m_surfLinear.setWidth (0);
    m_surfLinear.setHeight (0);
    m_surfLinear.setDepth (1);
    m_surfLinear.setBPP (0);
    m_surfLinear.setBPPRequested (0);
    m_surfLinear.setFormat (0);

    m_dwFlags         = 0;
    m_pBaseTexture    = this;
    m_dwMipMapCount   = 0;
    m_dwPriority      = 0;

    m_dwNV056Control0 = 0;
    m_dwNV056Format   = 0;

#ifdef TEX_MANAGE
    m_pPrev           = NULL;
    m_pNext           = NULL;
    m_pContext        = NULL;
#endif

    dbgTracePop();
}

//****************************************************************************
// CTexture::~CTexture
//

CTexture::~CTexture
(
    void
)
{
    dbgTracePush ("CTexture[%08x]::~CTexture()",this);

    // valid?
    assert (this);

    // automatically destroy this texture
    destroy();

    // zero out (debug builds)
#ifdef DEBUG
    m_surfLinear.setWidth (0);
    m_surfLinear.setHeight (0);
    m_surfLinear.setDepth (0);
    m_surfLinear.setBPP (0);
    m_surfLinear.setBPPRequested (0);
    m_surfLinear.setFormat (0);
    m_surfLinear.setWrapper (NULL);

    m_dwFlags         = 0;
    m_pBaseTexture    = NULL;
    m_dwMipMapCount   = 0;
    m_dwPriority      = 0;

    m_dwNV056Control0 = 0;
    m_dwNV056Format   = 0;

#ifdef TEX_MANAGE
    m_pPrev           = (CTexture *) 0xCCCCCCCC;
    m_pNext           = (CTexture *) 0xCCCCCCCC;
    m_pContext        = (PNVD3DCONTEXT) 0xCCCCCCCC;
#endif

    m_dwCubeMapSizeFacePadded    = 0;
    // m_pCubeMap        = NULL;
#endif

    dbgTracePop();
}

//****************************************************************************
//****************************************************************************
//****************************************************************************
//**  exports  ***************************************************************
//****************************************************************************
//****************************************************************************
//****************************************************************************
//****************************************************************************

// nvTextureCreateSurface
//
// creates a texture surface with the passed in specicifations
//
// called from only one place in CreateSurface32()

DWORD nvTextureCreateSurface
(
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl,
    LPDDRAWI_DIRECTDRAW_GBL   pDDGbl,
    LPDDSURFACEDESC           pDDSurfDesc
)
{
    dbgTracePush ("nvTextureCreateSurface");

    assert (pDDSLcl);
    assert (pDDGbl);

    LPDDRAWI_DDRAWSURFACE_GBL pGbl = pDDSLcl->lpGbl;
    assert (pGbl);

    // init
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvD3DRecover();
        }
        else {
            dbgTracePop();
            return (DD_OK);
        }
    }

    // calculate surface parameters
    DWORD dwFormat, dwWidth, dwHeight, dwDepth, dwBPPRequested, dwBPPGranted, dwPitch, dwSlicePitch, dwMultiSampleBits;
    BOOL  bFourCC;
    if (nvCalculateSurfaceParams (pDDSLcl, &dwFormat, &bFourCC, &dwWidth, &dwHeight, &dwDepth, &dwMultiSampleBits,
        &dwBPPRequested, &dwBPPGranted, /* pitch is ignored */&dwPitch, &dwSlicePitch, TRUE) != DD_OK) {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Invalid pixel format!");
        //dbgD3DError();  -- not an err: CanCreateSurface32() doesn't do checks, so we need them here
        dbgTracePop();
        return (DDERR_INVALIDPARAMS);
    }

    // dimensions: dwLogWidth, dwLogHeight
    if (!dwWidth                     // zero?
     || !dwHeight                    // zero?
     || !dwDepth
     || (dwWidth  & (dwWidth - 1))   // power of 2?
     || (dwHeight & (dwHeight - 1))
     || (dwDepth & (dwDepth - 1))) // power of 2?
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Invalid texture size!");
        dbgTracePop();
        return (DDERR_INVALIDPARAMS);
    }

    // get log2 of width & height
    DWORD dwLogWidth  = dwWidth;
    DWORD dwLogHeight = dwHeight;
    DWORD dwLogDepth = dwDepth;
    ASM_LOG2(dwLogWidth);
    ASM_LOG2(dwLogHeight);
    ASM_LOG2(dwLogDepth);

    DWORD dwLogLimit =
        (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME) ?
        pDriverData->nvD3DPerfData.dwMaxVolumeTextureSize :
        pDriverData->nvD3DPerfData.dwMaxTextureSize;

    ASM_LOG2(dwLogLimit);

    if ((dwLogWidth  > dwLogLimit) ||
        (dwLogHeight > dwLogLimit) ||
        ((pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME) && (dwLogDepth > dwLogDepth)))
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Invalid texture size!");
        dbgD3DError();
        dbgTracePop();
        return (DDERR_INVALIDPARAMS);
    }

    // dwMipMapCount
    CTexture *pBaseTexture       = NULL; // if defined, current texture is a user mip level
    CTexture *pCubeMapParentFace = NULL; // if defined, current cube map +x face
    DWORD     dwMipMapCount      = 1;
    DWORD     dwMipMapLevel      = 0;

    // handle cube maps
    if (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP)
    {
        // the following check is necessary to get around Microsoft's cubemap topology bug
        // for the +X face mipmaps we will actually be counting the -Z face and its mipmaps
        // this check makes sure that we don't count the -Z parent face. Since all cubemap
        // faces must have the same number of miplevels, this will work in all cases
        LPDDRAWI_DDRAWSURFACE_LCL pMipLcl = pDDSLcl;
        if ( (pMipLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_POSITIVEX)
         && !(pMipLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_MIPMAPSUBLEVEL))
        {
            pMipLcl = pDDSLcl->lpAttachList->lpAttached;
        }
        // count the number of mip map levels
        for (; pMipLcl->lpAttachList; pMipLcl = pMipLcl->lpAttachList->lpAttached) {
            dwMipMapCount++;
        }
        // Check if this is the base level of the first face or some subordinate level.
        if (pDDSLcl->lpAttachListFrom)
        {
            // count the number of levels back to the parent of this face
            for (pMipLcl = pDDSLcl; pMipLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_MIPMAPSUBLEVEL; pMipLcl = pMipLcl->lpAttachListFrom->lpAttached) {
                dwMipMapLevel++;
            }
            // continue back to the parent +X face
            for (; pMipLcl->lpAttachListFrom; pMipLcl = pMipLcl->lpAttachListFrom->lpAttached);
            // get the base texture
            pBaseTexture = GET_PNVOBJ(pMipLcl)->getTexture();
        }
    }
    else
    {
        // has mipmaps?
        if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
        {
            // registry allows?
            if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_USERMIPMAPENABLE_MASK) == D3D_REG_USERMIPMAPENABLE_ENABLE)
            {
                // count the number of mip levels from this texture down
                LPDDRAWI_DDRAWSURFACE_LCL pMipLcl;
                for (pMipLcl = pDDSLcl; pMipLcl->lpAttachList; pMipLcl = pMipLcl->lpAttachList->lpAttached) {
                    dwMipMapCount ++;
                }

                // Check if this is the base level or one of the mip levels.
                if (pDDSLcl->lpAttachListFrom != 0)
                {
                    // figure out what mip level this is, and also at the
                    //  same time, find the base texture
                    for (pMipLcl = pDDSLcl; pMipLcl->lpAttachListFrom; pMipLcl = pMipLcl->lpAttachListFrom->lpAttached) {
                        dwMipMapLevel ++;
                    }

                    // assign base texture
                    pBaseTexture = GET_PNVOBJ(pMipLcl)->getTexture();
                    assert (IS_VALID_PNVOBJ(pBaseTexture));
                }
            }
        }
    }

    // create the texture
    CNvObject *pNvObj   = GET_PNVOBJ (pDDSLcl);
    CTexture  *pTexture = IS_VALID_PNVOBJ(pNvObj) ? pNvObj->getTexture() : NULL;

    if (!pTexture)
    {
        // texture structure not created yet, do it now
#ifndef WINNT
        pNvObj   = new CNvObject (pDDSLcl->dwProcessId);
#else   // WINNT don't have pid
        pNvObj   = new CNvObject (0);
#endif
        pTexture = new CTexture;

        if (!pNvObj || !pTexture) {
            if (pNvObj) pNvObj->release();
            pGbl->fpVidMem = 0;
            SET_PNVOBJ (pDDSLcl, NULL);
            dbgTracePop();
            return (DDERR_OUTOFMEMORY);
        }

        // tag as part of a cube map if needed
        if (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP) {
            pTexture->tagCubeMap();
            //we need to augment the renaming logic to allow for
            //traversing renaming in the cube map direction as well
            //as the mipmap case.
        }
        else if (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME) {
            pTexture->tagVolumeMap();
            //probably shouldn't enable renaming with volumemaps because
            //n^3 size would have serious impacts on memory usage
        }
        else{
            // apply renaming policy
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_TEXTURE_RENAME) {
                pTexture->enableRenaming();
            }
        }

        // store in surface
        pNvObj->setObject (CNvObject::NVOBJ_TEXTURE, pTexture);
        SET_PNVOBJ (pDDSLcl, pNvObj);
    }

#ifdef WINNT
        if (pNvObj)
        {
            // we need this pointer to release memory when the PID differs from the one used at creation time
            pNvObj->setDDSLcl(pDDSLcl);
        }
#endif

    // tag as fourCC (will also automatically select DXT)
    if (bFourCC) {
        pTexture->setFourCC (pGbl->ddpfSurface.dwFourCC);
    }
    else {
        pTexture->setFourCC (0);
    }

    // tag as color keyed
    DWORD dwCK;
    if (nvCalculateColorKey (&dwCK, pDDSLcl, dwFormat)) {
        pTexture->tagColorKey();
        pTexture->setColorKey(dwCK);
    }

    // tag as palletized
    // What should we REALLY be checking here... this is kind of a loose
    // match should the ddraw user HAVE to export both caps or just one???
    if ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_PALETTE) ||
        (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_PALETTEINDEXED8))
    {
        DPF_LEVEL(NVDBG_LEVEL_PALETTE,"Surface marked palettized: pddslcl=%08x pnvobj=%08x ptexture=%08x\n",pDDSLcl, pNvObj, pTexture);
        DPF_LEVEL(NVDBG_LEVEL_PALETTE,"                           %d x %d x %d\n", dwWidth, dwHeight, dwBPPRequested<<2);
        pTexture->tagPalettized();
    }

    // tag as managed
    if ((pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE) ||
        (pBaseTexture && pBaseTexture->isManaged()))
    {
        pTexture->tagManaged();
        DPF_LEVEL(NVDBG_LEVEL_TEXMAN,"Texture %08x marked as managed\n",pTexture);
    }

#ifdef TEX_MANAGE_TEST
    pTexture->tagManaged();
#endif

    // determine DX app version
    DWORD dwDXAppVersion = 0x0700;
    PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
    while (pContext)
    {
        if (pContext->pDriverData == pDriverData)
        {
            dwDXAppVersion = pContext->dwDXAppVersion;
            break;
        }
        pContext = pContext->pContextNext;
    }

    // figure out which heap to allocate from
    DWORD dwAllowedHeaps, dwPreferredHeap;

    if (pTexture->isPalettized()) {
        // palettized textures can only go in video memory due to memory bandwidth limitations
        dwAllowedHeaps  =
        dwPreferredHeap = CSimpleSurface::HEAP_VID;
    }

    else if ((dwDXAppVersion < 0x0700) ||
             (pDriverData->GARTLinearBase == NULL)) {
        // original scheme - used for pre-DX7 apps and PCI cards
        // treat their request as a preference, but allow all allocations to fall back into AGP or PCI
        dwAllowedHeaps = CSimpleSurface::HEAP_VID |
                         (pDriverData->GARTLinearBase ? CSimpleSurface::HEAP_AGP : CSimpleSurface::HEAP_PCI);
        if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) {
            dwPreferredHeap = (pDriverData->GARTLinearBase) ? CSimpleSurface::HEAP_AGP : CSimpleSurface::HEAP_PCI;
        }
        else {
            dwPreferredHeap = CSimpleSurface::HEAP_VID;
        }
    }

    else {
        // new scheme - used for AGP cards on DX7 and beyond
        // rigorously honor app's requests for particular types of memory
        nvAssert (pDriverData->GARTLinearBase);
        if (pDDSLcl->ddsCaps.dwCaps & (DDSCAPS_LOCALVIDMEM | DDSCAPS_3DDEVICE)) {
            // they've explicitly requested video
            nvAssert ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) == 0); // these are supposed to be mutually exclusive
            dwAllowedHeaps  =
            dwPreferredHeap = CSimpleSurface::HEAP_VID;
        }
        else if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) {
            // they've explicitly requested AGP
            nvAssert ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_LOCALVIDMEM) == 0); // these are supposed to be mutually exclusive
            dwAllowedHeaps  =
            dwPreferredHeap = CSimpleSurface::HEAP_AGP;
        }
        else {
            // they explicitly requested neither video nor AGP, so either is OK, but video is preferred
            dwAllowedHeaps  = CSimpleSurface::HEAP_VID | CSimpleSurface::HEAP_AGP;
            dwPreferredHeap = CSimpleSurface::HEAP_VID;
        }
    }

    // initially create the texture in system memory if it's managed
    // and we're using the lazy texture management strategy -- ala microsoft.
    if ((pTexture->isManaged()) &&
        (getDC()->nvD3DRegistryData.regTextureManageStrategy == D3D_REG_TEXTUREMANAGESTRATEGY_LAZY)) {
        dwAllowedHeaps  |=  CSimpleSurface::HEAP_SYS;
        dwPreferredHeap |=  CSimpleSurface::HEAP_SYS;
        dwPreferredHeap &= ~CSimpleSurface::HEAP_VID;
    }

    // create the underlying swizzled surface
    if (pBaseTexture)
    {
        // this is a mipmap level.
        // user mip levels do not own their own memory. they point to memory
        //  off of the base texture. the base texture owns the memory
        DWORD dwThisFace = pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_ALLFACES;

        if (!pTexture->create (pNvObj, dwThisFace, pBaseTexture, dwMipMapLevel))
        {
            pNvObj->release();
            pGbl->fpVidMem = 0;
            SET_PNVOBJ (pDDSLcl, NULL);
            dbgTracePop();
            return (DDERR_OUTOFVIDEOMEMORY);
        }

        // update state
        pTexture->tagUserMipLevel();

        /*
         * For DX6 runtime we need to attach this texture to the chain steming
         * from the base texture. For DX7 it gets done upon CreateTextureEx call
         */
        if (global.dwDXRuntimeVersion < 0x0700) {
            CNvObject *pNvObjFrom;
            LPDDRAWI_DDRAWSURFACE_LCL pFromLcl;
            // Go 1 level up.
            pFromLcl = pDDSLcl->lpAttachListFrom->lpAttached;
            pNvObjFrom = GET_PNVOBJ (pFromLcl);
            assert (IS_VALID_PNVOBJ(pNvObjFrom));
            if (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP)
                pNvObjFrom->setAttachedB (pNvObj);
            else
                pNvObjFrom->setAttachedA (pNvObj);
        }
    }
    else
    {
        // this is a base texture. it owns its own memory and also those of all
        //  possible mipmaps

#ifdef TEX_MANAGE

#ifdef TEX_MANAGE_TEST

        dwAllowedHeaps = dwPreferredHeap = CSimpleSurface::HEAP_VID;
#endif

        BOOL bCreationSuccess, bEvictionSuccess;

        bCreationSuccess = pTexture->create (pNvObj, dwWidth, dwHeight, dwDepth,
                                             dwBPPRequested, dwBPPGranted, dwMipMapCount, dwFormat,
                                             dwAllowedHeaps, dwPreferredHeap);

        if (!bCreationSuccess && pTexture->isManaged()) {

            PNVD3DCONTEXT pContext = (PNVD3DCONTEXT) getDC()->dwContextListHead;

            while (pContext && !bCreationSuccess) {

                nvTexManageResetPtr (pContext);

                do {
                    // evict something and try again
                    bEvictionSuccess = nvTexManageEvict (pContext, NV_TEXMAN_EVICTION_PROTOCOL_ANY);
                    if (bEvictionSuccess) {
                        bCreationSuccess = pTexture->create (pNvObj, dwWidth, dwHeight, dwDepth,
                                                             dwBPPRequested, dwBPPGranted, dwMipMapCount, dwFormat,
                                                             dwAllowedHeaps, dwPreferredHeap);
                    }
                } while (bEvictionSuccess && !bCreationSuccess);

                pContext = pContext->pContextNext;

            }

        }  // !bSuccess

        // if we still haven't managed to create the thing, we have a serious problem
        if (!bCreationSuccess) {
            pNvObj->release();
            pGbl->fpVidMem = 0;
            SET_PNVOBJ (pDDSLcl, NULL);
            dbgTracePop();
            return (DDERR_OUTOFVIDEOMEMORY);
        }

        if (pTexture->isManaged() && !pTexture->isEvicted()) {
            nvTexManageAddTexture ((PNVD3DCONTEXT) getDC()->dwContextListHead,
                                   pTexture, NV_TEXMAN_DEFAULT_CLASS);
        }

#else  // !TEX_MANAGE

        if (!pTexture->create (pNvObj, dwWidth, dwHeight, dwDepth,
                               dwBPPRequested, dwBPPGranted, dwMipMapCount, dwFormat,
                               dwAllowedHeaps, dwPreferredHeap))
        {
            pNvObj->release();
            pGbl->fpVidMem = 0;
            SET_PNVOBJ (pDDSLcl, NULL);
            dbgTracePop();
            return (DDERR_OUTOFVIDEOMEMORY);
        }
#endif  // !TEX_MANAGE
    }

    // update DDraw
#ifdef WINNT
    if (pTexture->getSwizzled()->getHeapLocation() == CSimpleSurface::HEAP_AGP) {
#ifdef NV_AGP
        if (pBaseTexture) { // texture is a user mip level
            // BUGBUG tidy this up with "chunk per process AGP heap manager"
            DWORD dwBaseAddress = pBaseTexture->getSwizzled()->getAddress();
            DWORD dwMipAddress  = pTexture->getSwizzled()->getAddress();
            pGbl->fpVidMem = nvAGPGetUserAddr(dwBaseAddress) + (dwMipAddress - dwBaseAddress);
        } else {
            pGbl->fpVidMem = nvAGPGetUserAddr(pTexture->getSwizzled()->getAddress());
        }
#else
        pGbl->lpVidMemHeap = ppdev->AgpHeap;
        pGbl->fpHeapOffset = pTexture->getSwizzled()->getfpVidMem() + pDriverData->GARTLinearHeapOffset;
#endif
        // set the bits to let Microsoft know we put it in AGP
        pDDSLcl->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
    }
    else
#endif
    {
        pGbl->fpVidMem = pTexture->getSwizzled()->getfpVidMem();
    }

    // set size if linear, else set pitch
    // the correct conditional would be: (pDDSurfDesc->dwFlags & DDSD_LINEARSIZE)
    // but MS apparently hasn't set this flag yet, even though they will do so later. nice.
    if (pTexture->isDXT()) {  // for now these are the only "linear" texture surfaces
        pGbl->dwLinearSize = pTexture->getSize();
    }
    else {
        pGbl->lPitch = pTexture->getPitch();
        pGbl->lSlicePitch = pTexture->getSlicePitch();
    }

    // telling MS that we have an AGP surface causes BLTs not to come our way. Just say nothing...

    //pDDSLcl->ddsCaps.dwCaps = pTexture->getSwizzled()->modifyDDCaps(pDDSLcl->ddsCaps.dwCaps);

    // force DXT surfaces to pre-allocate sysmem copies since WB locks them
    //  all the time. This will evade costly GlobalAlloc calls during run
    if (pTexture->isDXT()) {
        pTexture->updateLinearSurface();
    }

    // done
    dbgTracePop();
    return (DD_OK);
}

//****************************************************************************
// nvTextureDestroySurface
//

BOOL nvTextureDestroySurface
(
    LPDDHAL_DESTROYSURFACEDATA pDestorySurfaceData,
    LPDDRAWI_DDRAWSURFACE_LCL  pDDSLcl
)
{
    dbgTracePush ("nvTextureDestroySurface");

    // sanity checks
    assert (pDestorySurfaceData);
    assert (pDDSLcl);

    LPDDRAWI_DDRAWSURFACE_GBL pGbl = pDDSLcl->lpGbl;
    assert (pGbl);

    // get driver context
    nvSetDriverDataPtrFromDDGbl (pDestorySurfaceData->lpDD);

    // get the texture
    CNvObject *pNvObj   = GET_PNVOBJ (pDDSLcl);
    CTexture  *pTexture = IS_VALID_PNVOBJ(pNvObj) ? pNvObj->getTexture() : NULL;

    if (pTexture)
    {
        BOOL bDestroyTexture = TRUE;
        // make sure that we do not have this texture referenced anywhere
        PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
        while (pContext)
        {

            if (pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] == (DWORD)pNvObj) {
                pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] = 0;
#if (NVARCH >= 0x010)
                pContext->hwState.dwDirtyFlags |= celsiusDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
                pContext->hwState.dwDirtyFlags |= kelvinDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
#endif
                // for legacy apps that use the setContextState calls (e.g. tunnel)
                pContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] = 0;
            }
            if (pContext->tssState[1].dwValue[D3DTSS_TEXTUREMAP] == (DWORD)pNvObj) {
                pContext->tssState[1].dwValue[D3DTSS_TEXTUREMAP] = 0;
#if (NVARCH >= 0x010)
                pContext->hwState.dwDirtyFlags |= celsiusDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
                pContext->hwState.dwDirtyFlags |= kelvinDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
#endif
            }
            pContext = pContext->pContextNext;
        }
        pGbl->fpVidMem = 0;

        if (global.dwDXRuntimeVersion >= 0x0700) {
            bDestroyTexture = (pDDSLcl->dwFlags & DDRAWISURF_INVALID) ? FALSE : TRUE;
        }
        else {
            bDestroyTexture = pTexture->hasHandle();
        }

        // destroy texture object if handle is freed already (or allocated at all)
        if (bDestroyTexture)
        {
            CNvObject *pNvObj = pTexture->getWrapper();

#ifdef WINNT
            // we need this pointer to release memory when the PID differs from the one used at creation time
            pNvObj->setDDSLcl(pDDSLcl);
#endif
#ifdef TEX_MANAGE
            if (pTexture->isManaged() && pTexture->isBaseTexture() && pTexture->isResident()) {
                nvTexManageRemoveTexture (pTexture);
            }
#endif

            // clean up ddraw
            SET_PNVOBJ (pDDSLcl, NULL);
            // BUGBUG what about the object list entry?

            // object release will delete the texture object and surface memory
            pNvObj->release();
        }
    }

    else
    {
        // not our surface - punt
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return FALSE;
    }

    // done
    NvReleaseSemaphore(pDriverData);
    pDestorySurfaceData->ddRVal = DD_OK;
    dbgTracePop();
    return TRUE;
}

//---------------------------------------------------------------------------

// nvTextureBlt
// performs blts to and/or from a texture

DWORD nvTextureBltDX7
(
    PNVD3DCONTEXT   pContext,  // may be NULL!!
    CNvObject      *pSrcObj,   // source nv object
    CNvObject      *pDstObj,   // dest nv object
    D3DBOX         *boxSrc,      // src rect
    DWORD           dwDstX,
    DWORD           dwDstY,
    DWORD           dwDstZ,
    DWORD           dwFlags    // blt flags
)
{
    BOOL bForceTextureInvalidate = FALSE;
    dbgTracePush ("nvTextureBltDX7");

#ifdef NO_TEX_BLTS

    // done
    dbgTracePop();
    return (DD_OK);
#endif


#if defined(NV_NULL_DRIVER) || defined(NV_NULL_TEXTURE_DRIVER)
    dbgTracePop();
    return (DD_OK);
#endif //NV_NULL_DRIVER

    if ((pSrcObj == NULL) || (pDstObj == NULL)) {
        // this routine doesn't handle things without sources (like blitFX)
        // and obviously we always need a destination
        dbgTracePop();
        return (DDERR_UNSUPPORTED);
    }

    DWORD dwSrcClass = pSrcObj->getClass();
    DWORD dwDstClass = pDstObj->getClass();

    if ((dwSrcClass != CNvObject::NVOBJ_TEXTURE) && (dwSrcClass != CNvObject::NVOBJ_SIMPLESURFACE)) {
        dbgTracePop();
        return (DDERR_UNSUPPORTED);
    }
    if ((dwDstClass != CNvObject::NVOBJ_TEXTURE) && (dwDstClass != CNvObject::NVOBJ_SIMPLESURFACE)) {
        dbgTracePop();
        return (DDERR_UNSUPPORTED);
    }

    // extract useful data about the source and destination surfaces

    // src
    DWORD dwSrcAddr;
    DWORD dwSrcPitch;
    DWORD dwSrcSlicePitch;
    DWORD dwSrcBPP;
    DWORD dwSrcHeap;
    DWORD dwSrcFourCC;
    BOOL  bSrcDXT;
    DWORD dwSrcSurfaceWidth;
    DWORD dwSrcSurfaceHeight;
    DWORD dwSrcSurfaceDepth;
    DWORD dwSrcSurfaceLogWidth;
    DWORD dwSrcSurfaceLogHeight;
    DWORD dwSrcSurfaceLogDepth;

    DWORD dwSrcX0 = boxSrc->Left;
    DWORD dwSrcY0 = boxSrc->Top;
    DWORD dwSrcZ0 = boxSrc->Front;
    DWORD dwSrcX1 = boxSrc->Right;
    DWORD dwSrcY1 = boxSrc->Bottom;
    DWORD dwSrcZ1 = boxSrc->Back;

    DWORD bSrcIsVolumeMap;

    CTexture       *pSrcTexture;
    CSimpleSurface *pSrcSurface;

    if (dwSrcClass == CNvObject::NVOBJ_TEXTURE)
    {
        pSrcTexture = pSrcObj->getTexture();
        pSrcSurface = pSrcTexture->getLinear();
        bSrcIsVolumeMap = pSrcTexture->isVolumeMap();

        if (pSrcSurface->isUpToDate()) {
            dwSrcAddr  = pSrcSurface->getAddress();
            dwSrcHeap  = pSrcSurface->getHeapLocation();
        }
        else {
            dwSrcAddr  = pSrcTexture->getSwizzled()->getAddress();
            dwSrcHeap  = pSrcTexture->getSwizzled()->getHeapLocation();
        }
    }
    else  // dwClassSrc == CNvObject::FORMATTEDSURFACE
    {
        pSrcTexture = NULL;
        pSrcSurface = pSrcObj->getSimpleSurface();
        dwSrcAddr   = pSrcSurface->getAddress();
        dwSrcHeap   = pSrcSurface->getHeapLocation();
        bSrcIsVolumeMap = ((dwSrcZ1 - dwSrcZ0) != 1);
    }

    // check if source was previously auto-paletized
    if (pSrcTexture) {
        // if this is the source for a blit, we must restore the original contents
        nvAutoPaletteCheckAndRevert(pSrcTexture, FALSE);
    }

    dwSrcPitch  = pSrcSurface->getPitch();
    dwSrcSlicePitch = pSrcSurface->getSlicePitch();
    dwSrcBPP    = pSrcSurface->getBPP();
    dwSrcFourCC = pSrcSurface->getFourCC();
    bSrcDXT     = pSrcSurface->isDXT();
    dwSrcSurfaceWidth     = pSrcSurface->getWidth();
    dwSrcSurfaceHeight    = pSrcSurface->getHeight();
    dwSrcSurfaceDepth     = pSrcSurface->getDepth();
    dwSrcSurfaceLogWidth  = dwSrcSurfaceWidth;
    dwSrcSurfaceLogHeight = dwSrcSurfaceHeight;
    dwSrcSurfaceLogDepth  = dwSrcSurfaceDepth;
    ASM_LOG2(dwSrcSurfaceLogWidth);
    ASM_LOG2(dwSrcSurfaceLogHeight);
    ASM_LOG2(dwSrcSurfaceLogDepth);

    // dest
    DWORD     dwDstAddr;
    DWORD     dwDstPitch;
    DWORD     dwDstSlicePitch;
    DWORD     dwDstBPP;
    DWORD     dwDstHeap;
    DWORD     dwDstFourCC;
    BOOL      bDstDXT;
    DWORD     dwDstSurfaceWidth;
    DWORD     dwDstSurfaceHeight;
    DWORD     dwDstSurfaceDepth;
    DWORD     dwDstSurfaceLogWidth;
    DWORD     dwDstSurfaceLogHeight;
    DWORD     dwDstSurfaceLogDepth;

    DWORD     dwDstX0 = dwDstX;
    DWORD     dwDstY0 = dwDstY;
    DWORD     dwDstZ0 = dwDstZ;
    DWORD     dwDstX1 = dwDstX0 + (dwSrcX1 - dwSrcX0);
    DWORD     dwDstY1 = dwDstY0 + (dwSrcY1 - dwSrcY0);
    DWORD     dwDstZ1 = dwDstZ0 + (dwSrcZ1 - dwSrcZ0);

    DWORD     bDstIsVolumeMap;

    CTexture       *pDstTexture;
    CSimpleSurface *pDstSurface;

    if (dwDstClass == CNvObject::NVOBJ_TEXTURE)
    {
        pDstTexture = pDstObj->getTexture();
        pDstSurface = pDstTexture->getLinear();
        dwDstAddr   = pDstTexture->getSwizzled()->getAddress();
        dwDstHeap   = pDstTexture->getSwizzled()->getHeapLocation();
        bDstIsVolumeMap = pDstTexture->isVolumeMap();
    }
    else  // dwClassDst == CNvObject::FORMATTEDSURFACE
    {
        pDstTexture = NULL;
        pDstSurface = pDstObj->getSimpleSurface();
        dwDstAddr   = pDstSurface->getAddress();
        dwDstHeap   = pDstSurface->getHeapLocation();
        bDstIsVolumeMap = ((dwDstZ1 - dwDstZ0) != 1);
    }

    dwDstPitch  = pDstSurface->getPitch();
    dwDstSlicePitch = pDstSurface->getSlicePitch();
    dwDstBPP    = pDstSurface->getBPP();
    dwDstFourCC = pDstSurface->getFourCC();
    bDstDXT     = pDstSurface->isDXT();
    dwDstSurfaceWidth     = pDstSurface->getWidth();
    dwDstSurfaceHeight    = pDstSurface->getHeight();
    dwDstSurfaceDepth     = pDstSurface->getDepth();
    dwDstSurfaceLogWidth  = dwDstSurfaceWidth;
    dwDstSurfaceLogHeight = dwDstSurfaceHeight;
    dwDstSurfaceLogDepth  = dwDstSurfaceDepth;
    ASM_LOG2 (dwDstSurfaceLogWidth);
    ASM_LOG2 (dwDstSurfaceLogHeight);
    ASM_LOG2 (dwDstSurfaceLogDepth);

    // derive commonly used values from extracted data
    DWORD dwBlitWidth  = dwSrcX1 - dwSrcX0;
    DWORD dwBlitHeight = dwSrcY1 - dwSrcY0;
    DWORD dwBlitDepth  = dwSrcZ1 - dwSrcZ0;

    BOOL  bFullDstSurface = FALSE;
    if (pDstSurface->isDXT())
    {
        if ((dwBlitWidth  == dwDstSurfaceWidth * 4) &&
            (dwBlitHeight == dwDstSurfaceHeight * 4) &&
            (dwBlitDepth == dwDstSurfaceDepth)) {   // Volume DXT's don't get multiplied, right?
            bFullDstSurface = TRUE;
        }
    }
    else
    {
        if ((dwBlitWidth  == dwDstSurfaceWidth) &&
            (dwBlitHeight == dwDstSurfaceHeight) &&
            (dwBlitDepth == dwDstSurfaceDepth)) {
            bFullDstSurface = TRUE;
        }
    }

    // validate parameters
    if ((dwSrcBPP != dwDstBPP)                    // bit depth must match
     || (!dwBlitHeight)                           // at least something to do
     || (!dwBlitWidth)                            // at least something to do
     || (!dwBlitDepth)                            // at least something to do
     || (!pSrcTexture && !pDstTexture)            // at least one texture involved
     || (bSrcDXT != bDstDXT)                      // we can only blit from one DXT to another
     || (bSrcDXT && (dwSrcFourCC != dwDstFourCC))) // we can only blit between similar DXTs
    {
        dbgTracePop();
        return (DDERR_UNSUPPORTED);
    }

    // this check doesn't seem to be required
/*    if ((dwSrcSurfaceWidth  != dwDstSurfaceWidth) ||
        (dwSrcSurfaceHeight != dwDstSurfaceHeight))
    {
        dbgTracePop();
        return (DDERR_NOSTRETCHHW);
    }*/

    // determine swizzledness. 4cc's are special cases handled first

    BOOL  bSrcSwizzled;
    BOOL  bDstSwizzled;
    DWORD dwSwizzledness;

    if (dwDstFourCC) {
        switch (dwDstFourCC) {
            case FOURCC_NVT0:
            case FOURCC_NVT1:
            case FOURCC_NVT2:
            case FOURCC_NVT3:
            case FOURCC_NVT4:
            case FOURCC_NVT5:
                bSrcSwizzled = TRUE;
                bDstSwizzled = TRUE;
                break;
            case FOURCC_NVS0:
            case FOURCC_NVS1:
            case FOURCC_NVS2:
            case FOURCC_NVS3:
            case FOURCC_NVS4:
            case FOURCC_NVS5:
#ifdef TEXFORMAT_CRD // --------------------------------
            case FOURCC_NVHU:
            case FOURCC_NVHS:
#else // !TEXFORMAT_CRD  --------------------------------
#if defined(HILO_SUPPORT_DX7) || defined(HILO_SUPPORT_DX8)
            case FOURCC_NVHU:
            case FOURCC_NVHS:
#endif
#endif // !TEXFORMAT_CRD  --------------------------------
                bSrcSwizzled = FALSE;
                bDstSwizzled = TRUE;
                break;
            case D3DFMT_Q8W8V8U8:
                bSrcSwizzled = pSrcTexture ? (pSrcTexture->getLinear()->isUpToDate() ? FALSE : TRUE) : FALSE;
                bDstSwizzled = pDstTexture != NULL;
                break;
            case FOURCC_DXT1:
            case FOURCC_DXT2:
            case FOURCC_DXT3:
            case FOURCC_DXT4:
            case FOURCC_DXT5:
                bSrcSwizzled = TRUE;        // well, it's compressed, but we want to use
                bDstSwizzled = TRUE;        // swz to swz blit copy because it supports renaming
                break;
            default:
                DPF ("unhandled 4cc in texture blit");
                dbgD3DError();
                dbgTracePop();
                return (DDERR_UNSUPPORTED);
                break;
        }  // switch
    }

    else {
        bSrcSwizzled = pSrcTexture ? (pSrcTexture->getLinear()->isUpToDate() ? FALSE : TRUE) : FALSE;
        bDstSwizzled = pDstTexture != NULL;
    }

    dwSwizzledness = (bSrcSwizzled ? 0x10 : 0x00) | (bDstSwizzled ? 0x01 : 0x00);

    // determine if we can allow HW to blt the texture
    //  - must be faster
    //  - must not be 1 wide (NV5 cannot do)
    //  - must not be 2046 wide or wdire (NV5 cannot do)
    //  - source must be in a suitable location
    //  - dest must be in a suitable location
    BOOL bAllowHW = (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_TEXTURE_USEHW)
                 && ((dwSrcHeap == CSimpleSurface::HEAP_VID)
                  || (dwSrcHeap == CSimpleSurface::HEAP_AGP)
                  || (dwSrcHeap == CSimpleSurface::HEAP_PCI))
                 && (dwDstHeap == CSimpleSurface::HEAP_VID);
    // exception - vid to vid ALWAYS use HW
    if ((dwSrcHeap == CSimpleSurface::HEAP_VID)
     && (dwDstHeap == CSimpleSurface::HEAP_VID))
    {
        bAllowHW = TRUE;
    }

    // exception - certain dimensions cannot be swizzled (although this also kills lin2lin)
    if ((dwBlitWidth  <= 1)
     || (dwBlitWidth  >= 2046)
     || (dwBlitHeight >= 2046))
    {
        bAllowHW = FALSE;
    }

    // check if this was previously auto-paletized
    if (pDstTexture) {
        nvAutoPaletteCheckAndRevert(pDstTexture, bFullDstSurface);
    }

#if 0
    // Display the source texture on the screen. (DEBUG only)
    dbgDisplayLinearTexture (lpBltData->lpDDSrcSurface,
                             lpBltData->lpDDDestSurface,
                             pDstTexture ? pDstTexture->getFormat()
                                         : pSrcTexture->getFormat());
#endif

    // we've gathered / calculated all the information we need to actually do the blits.
    // there are just a couple of cases we support. Punt on others (ddraw will magically handle!)

#ifdef CNT_TEX
    if ((dwDstHeap == CSimpleSurface::HEAP_VID) && (dwSrcHeap != CSimpleSurface::HEAP_VID)) {
        g_dwVidTexDL[g_dwFrames]++;
    } else if ((dwSrcHeap != CSimpleSurface::HEAP_VID) && (dwSrcHeap != CSimpleSurface::HEAP_AGP) && (dwDstHeap == CSimpleSurface::HEAP_AGP)) {
        g_dwAgpTexDL[g_dwFrames]++;
    }
#endif // CNT_TEX

    if (0) { // TODO  (bAllowHW) {

        // get lock on textures
        if (pSrcTexture) {
            pSrcTexture->hwLock (pContext, CSimpleSurface::LOCK_NORMAL);
        }
        if (pDstTexture) {
            pDstTexture->hwLock (pContext, CSimpleSurface::LOCK_NORMAL);
        }

        // TODO: HW blits

        // release locks on textures
        if (pSrcTexture) {
            pSrcTexture->hwUnlock();
        }
        if (pDstTexture) {
            pDstTexture->hwUnlock();
        }

    }
    else {
        switch (dwSwizzledness)
        {

            case 0x00:  // L -> L
                        #ifdef NV_PROFILE_CPULOCK
                        NVP_START (NVP_T_TEX_BLT);
                        #endif
                DDLOCKINDEX(NVSTAT_LOCK_L2L_COPY);
                if (pSrcTexture) pSrcTexture->cpuLockLin (CSimpleSurface::LOCK_NORMAL);
                if (pDstTexture) pDstTexture->cpuLockLin (CSimpleSurface::LOCK_NORMAL);
                        #ifdef NV_PROFILE_CPULOCK
                        NVP_STOP (NVP_T_TEX_BLT);
                        nvpLogTime (NVP_T_TEX_BLT,nvpTime[NVP_T_TEX_BLT]);
                        #endif

                assert (!bDstDXT); // we dont want dxt blts here

                nvSwizBlt_cpu_lin2lin (dwSrcAddr, dwSrcPitch, dwSrcX0, dwSrcY0,
                                       dwDstAddr, dwDstPitch, dwDstX0, dwDstY0,
                                       dwBlitWidth, dwBlitHeight, dwSrcBPP);

                if (pSrcTexture) pSrcTexture->cpuUnlockLin();
                if (pDstTexture) pDstTexture->cpuUnlockLin();
                break;

            case 0x01:  // L -> S
                        #ifdef NV_PROFILE_CPULOCK
                        NVP_START (NVP_T_TEX_BLT);
                        #endif
                DDLOCKINDEX(NVSTAT_LOCK_L2O_COPY);

                if (pSrcTexture)
                {
                    pSrcTexture->cpuLockLin (CSimpleSurface::LOCK_NORMAL);
                }
                else
                {
                    pSrcSurface->cpuLock (CSimpleSurface::LOCK_NORMAL);
                }
                if (pDstTexture)
                {
                    if (bFullDstSurface)
                    {
                        pDstTexture->cpuLockSwz (CSimpleSurface::LOCK_RENAME);
                        pDstTexture->getSwizzled()->tagUpToDate();
                        dwDstAddr = pDstTexture->getSwizzled()->getAddress();
                    }
                    else
                    {
                        pDstTexture->cpuLockSwz (CSimpleSurface::LOCK_NORMAL);
                    }
                }
                else
                {
                    pDstSurface->cpuLock (CSimpleSurface::LOCK_NORMAL);
                }
                        #ifdef NV_PROFILE_CPULOCK
                        NVP_STOP (NVP_T_TEX_BLT);
                        nvpLogTime (NVP_T_TEX_BLT,nvpTime[NVP_T_TEX_BLT]);
                        #endif
                nvAssert (!bDstDXT); // we dont want dxt blts here

#ifndef CAPTURE
                if (pDstTexture)
                {
#ifndef NO_TEX_SWZ
                    nvSwizBlt_lin2swz (pContext, dwSrcAddr, dwSrcPitch, dwSrcSlicePitch, dwSrcX0, dwSrcY0, dwSrcZ0,
                                       pDstTexture, dwDstAddr, dwDstX0, dwDstY0, dwDstZ0,
                                       dwDstSurfaceLogWidth, dwDstSurfaceLogHeight, dwDstSurfaceLogDepth,
                                       dwBlitWidth, dwBlitHeight, dwBlitDepth, dwSrcBPP);
                }
                else
#else
                    nvSwizBlt_cpu_lin2lin (dwSrcAddr, dwSrcPitch, dwSrcX0, dwSrcY0,
                                           dwDstAddr, dwDstPitch, dwDstX0, dwDstY0,
                                           dwBlitWidth, dwBlitHeight, dwSrcBPP);
                }
                else
#endif // No_Tex_SWZ
#endif  // CAPTURE
                {
#ifndef NO_TEX_SWZ
                    nvSwizBlt_cpu_lin2swz (dwSrcAddr, dwSrcPitch, dwSrcX0, dwSrcY0,
                                           dwDstAddr, dwDstX0, dwDstY0, dwDstSurfaceLogWidth, dwDstSurfaceLogHeight,
                                           dwBlitWidth, dwBlitHeight, dwSrcBPP);
                }
#else
                    nvSwizBlt_cpu_lin2lin (dwSrcAddr, dwSrcPitch, dwSrcX0, dwSrcY0,
                                           dwDstAddr, dwDstPitch, dwDstX0, dwDstY0,
                                           dwBlitWidth, dwBlitHeight, dwSrcBPP);
                }
#endif // No_Tex_SWZ
                // capture
#ifdef CAPTURE
                if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                    CAPTURE_MEMORY_WRITE memwr;
                    memwr.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                    memwr.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                    memwr.dwExtensionID        = CAPTURE_XID_MEMORY_WRITE;
                    memwr.dwCtxDMAHandle       = (pDstTexture->getSwizzled()->getHeapLocation() == CSimpleSurface::HEAP_VID)
                                               ? NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY
                                               : D3D_CONTEXT_DMA_HOST_MEMORY;
                    memwr.dwOffset             = pDstTexture->getSwizzled()->getOffset();
                    memwr.dwSize               = pDstTexture->getWidth() * pDstTexture->getHeight() * pDstTexture->getBPP();
                    captureLog (&memwr,sizeof(memwr));
                    captureLog ((void*)pDstTexture->getSwizzled()->getAddress(),memwr.dwSize);
                }
#endif

                if (pSrcTexture) pSrcTexture->cpuUnlockLin();
                if (pDstTexture)
                {
                    pDstTexture->cpuUnlockSwz();
                    pDstTexture->tagRenamedAndCopied();
                    invalidateTextureCache(pContext);
                    if (pContext)
                        pContext->bStateChange = TRUE;
                    else
                        bForceTextureInvalidate = TRUE;
                }
                break;

            case 0x10:  // S -> L
                        #ifdef NV_PROFILE_CPULOCK
                        NVP_START (NVP_T_TEX_BLT);
                        #endif
                DDLOCKINDEX(NVSTAT_LOCK_O2L_COPY);
                if (pSrcTexture) pSrcTexture->cpuLockSwz (CSimpleSurface::LOCK_NORMAL);
                if (pDstTexture) pDstTexture->cpuLockLin (CSimpleSurface::LOCK_NORMAL);
                        #ifdef NV_PROFILE_CPULOCK
                        NVP_STOP (NVP_T_TEX_BLT);
                        nvpLogTime (NVP_T_TEX_BLT,nvpTime[NVP_T_TEX_BLT]);
                        #endif

                assert (!bDstDXT); // we dont want dxt blts here
#ifndef NO_TEX_SWZ
                nvSwizBlt_cpu_swz2lin (dwSrcAddr, dwSrcX0, dwSrcY0, dwSrcSurfaceLogWidth, dwSrcSurfaceLogHeight,
                                       dwDstAddr, dwDstPitch, dwDstX0, dwDstY0,
                                       dwBlitWidth, dwBlitHeight, dwSrcBPP);
#else
                nvSwizBlt_cpu_lin2lin (dwSrcAddr, dwSrcPitch, dwSrcX0, dwSrcY0,
                                       dwDstAddr, dwDstPitch, dwDstX0, dwDstY0,
                                       dwBlitWidth, dwBlitHeight, dwSrcBPP);
#endif
                if (pSrcTexture) pSrcTexture->cpuUnlockSwz();
                if (pDstTexture) pDstTexture->cpuUnlockLin();
                break;

            case 0x11:  // S -> S
                        #ifdef NV_PROFILE_CPULOCK
                        NVP_START (NVP_T_TEX_BLT);
                        #endif
                DDLOCKINDEX(NVSTAT_LOCK_O2O_COPY);
                if (pSrcTexture) pSrcTexture->cpuLockSwz (CSimpleSurface::LOCK_NORMAL);
                if (pDstTexture)
                {
                    if (bDstDXT && bFullDstSurface)
                    {
                        // allow renaming of DXT surfaces
                        pDstTexture->cpuLockSwz (CSimpleSurface::LOCK_RENAME);
                        dwDstAddr = pDstTexture->getSwizzled()->getAddress();
                    }
                    else
                    {
                        pDstTexture->cpuLockSwz (CSimpleSurface::LOCK_NORMAL);
                    }
                }
                        #ifdef NV_PROFILE_CPULOCK
                        NVP_STOP (NVP_T_TEX_BLT);
                        nvpLogTime (NVP_T_TEX_BLT,nvpTime[NVP_T_TEX_BLT]);
                        #endif
                if (bDstDXT)
                {
                    // we assume that all dxt blts are 4 texel aligned.
                    // if not, we blt a little extra
                    nvSwizBlt_cpu_lin2lin (dwSrcAddr, dwSrcPitch, dwSrcX0 >> 2, dwSrcY0 >> 2,
                                           dwDstAddr, dwDstPitch, dwDstX0 >> 2, dwDstY0 >> 2,
                                           (dwBlitWidth + 3) >> 2, (dwBlitHeight + 3) >> 2, dwSrcBPP);
                }
                else
                {
#ifndef NO_TEX_SWZ
                    nvSwizBlt_cpu_swz2swz (dwSrcAddr, dwSrcX0, dwSrcY0, dwSrcSurfaceLogWidth, dwSrcSurfaceLogHeight,
                                           dwDstAddr, dwDstX0, dwDstY0, dwDstSurfaceLogWidth, dwDstSurfaceLogHeight,
                                           dwBlitWidth, dwBlitHeight, dwSrcBPP);
#else
                    nvSwizBlt_cpu_lin2lin (dwSrcAddr, dwSrcPitch, dwSrcX0, dwSrcY0,
                                           dwDstAddr, dwDstPitch, dwDstX0, dwDstY0,
                                           dwBlitWidth, dwBlitHeight, dwSrcBPP);
#endif
                }
                // capture
#ifdef CAPTURE
                if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                    CAPTURE_MEMORY_WRITE memwr;
                    memwr.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                    memwr.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                    memwr.dwExtensionID        = CAPTURE_XID_MEMORY_WRITE;
                    memwr.dwCtxDMAHandle       = (pDstTexture->getSwizzled()->getHeapLocation() == CSimpleSurface::HEAP_VID)
                                               ? NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY
                                               : D3D_CONTEXT_DMA_HOST_MEMORY;
                    memwr.dwOffset             = pDstTexture->getSwizzled()->getOffset();
                    memwr.dwSize               = pDstTexture->getWidth() * pDstTexture->getHeight() * pDstTexture->getBPP();
                    captureLog (&memwr,sizeof(memwr));
                    captureLog ((void*)pDstTexture->getSwizzled()->getAddress(),memwr.dwSize);
                }
#endif

                if (pSrcTexture) pSrcTexture->cpuUnlockSwz();
                if (pDstTexture)
                {
                    pDstTexture->cpuUnlockSwz();
                    pDstTexture->tagRenamedAndCopied();
                    invalidateTextureCache (pContext);
                    if(!pContext) bForceTextureInvalidate=TRUE;
                }
                break;

            default:
                DPF ("uh oh. unknown swizzledness");
                dbgD3DError();
                break;

        }  // switch

    }

    // update flags
    if (pDstTexture)
    {
        if (dwSwizzledness & 0x01) // dest swizzled?
        {
            pDstTexture->getLinear()->tagOutOfDate();
            pDstTexture->getSwizzled()->tagUpToDate();
        }
        else
        {
            pDstTexture->getSwizzled()->tagOutOfDate();
            pDstTexture->getLinear()->tagUpToDate();
            // if this is part of a cube map/mipmap, tag the base as dirty
            //  this will trigger a proper update of all subsurfaces before HW touches them
            if (pDstTexture->isUserMipLevel() || pDstTexture->isCubeMap())
            {
                pDstTexture->getBaseTexture()->tagSubSurfacesDirty();
            }
        }
    }

    // todo: auto mipmaps

    // force a cache invalidation on all contexts because we might have forced
    // texture renaming and we haven't informed the hardware that we have moved
    // the texture.
    if ((pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_TEXTURE_RENAME) && bForceTextureInvalidate) {
        // run through the list of contexts and invalidate them all
        PNVD3DCONTEXT pCtxt = (PNVD3DCONTEXT) getDC()->dwContextListHead;
        while (pCtxt) {
            invalidateTextureCache (pCtxt);
            pCtxt->bStateChange = TRUE;
            pCtxt = pCtxt->pContextNext;
        }
    }

    // this was a 2D operation
    pDriverData->TwoDRenderingOccurred = TRUE;

    dbgFlushType (NVDBG_FLUSH_2D);

    // Display the swizzled texture on the screen. (DEBUG only)
    if (pDstTexture)
    {
        dbgTextureDisplay (pDstTexture);
    }

    // done
    dbgTracePop();
    return (DD_OK);
}

//---------------------------------------------------------------------------

// fill a sub-rect of a swizzled texture with a color

DWORD nvTextureColorFill
(
    CNvObject *pDstObj,
    DWORD dwX0,         // corner of fill region
    DWORD dwY0,
    DWORD dwFillWidth,  // size of fill region
    DWORD dwFillHeight,
    DWORD dwColor       // fill color
)
{
    DWORD dwX, dwXInterleaved;
    DWORD dwY, dwYInterleaved;
    DWORD dwIndex;

    dbgTracePush ("nvTextureColorFill");

    CTexture *pTex = pDstObj->getTexture();
    nvAssert (pTex);

    // lock the swizzled surface since we're going to mess with it
    DDLOCKINDEX(NVSTAT_LOCK_FILL_OPT);
    pTex->cpuLockSwz (CSimpleSurface::LOCK_NORMAL);

    DWORD dwAddr  = pTex->getSwizzled()->getAddress();
    DWORD dwPitch = pTex->getPitch();
    DWORD dwBPP   = pTex->getBPP();

    DWORD dwTexWidth  = pTex->getWidth();
    DWORD dwTexHeight = pTex->getHeight();

    switch (dwBPP) {

        case 2:
            for (dwY=dwY0; dwY < dwY0+dwFillHeight; dwY++) {
                V_INTERLEAVE (dwYInterleaved, dwY, dwTexWidth, dwTexHeight);
                for (dwX = dwX0; dwX < dwX0+dwFillWidth; dwX++) {
                    U_INTERLEAVE (dwXInterleaved, dwX, dwTexWidth, dwTexHeight);
                    dwIndex = dwXInterleaved | dwYInterleaved;
                    ((WORD*)dwAddr)[dwIndex] = (WORD)dwColor;
                }
            }
            break;

        case 4:
            for (dwY=dwY0; dwY < dwY0+dwFillHeight; dwY++) {
                V_INTERLEAVE (dwYInterleaved, dwY, dwTexWidth, dwTexHeight);
                for (dwX = dwX0; dwX < dwX0+dwFillWidth; dwX++) {
                    U_INTERLEAVE (dwXInterleaved, dwX, dwTexWidth, dwTexHeight);
                    dwIndex = dwXInterleaved | dwYInterleaved;
                    ((DWORD*)dwAddr)[dwIndex] = (DWORD)dwColor;
                }
            }
            break;

        case 1:
            for (dwY=dwY0; dwY < dwY0+dwFillHeight; dwY++) {
                V_INTERLEAVE (dwYInterleaved, dwY, dwTexWidth, dwTexHeight);
                for (dwX = dwX0; dwX < dwX0+dwFillWidth; dwX++) {
                    U_INTERLEAVE (dwXInterleaved, dwX, dwTexWidth, dwTexHeight);
                    dwIndex = dwXInterleaved | dwYInterleaved;
                    ((unsigned char *)dwAddr)[dwIndex] = (unsigned char)dwColor;
                }
            }
            break;
        default:
            DPF ("unknown bit depth in nvTextureColorFill");
            dbgD3DError();
            break;

    } // switch

    // update tags
    pTex->getSwizzled()->tagUpToDate();
    pTex->getLinear()->tagOutOfDate();

    // unlock the swizzled surface
    pTex->cpuUnlockSwz();

    dbgTextureDisplay (pTex);

    dbgTracePop();
    return (DD_OK);
}

//---------------------------------------------------------------------------

DWORD nvTextureStretchBlit
(
    LPSURFINFO pSrcInfo,
    LPSURFINFO pDstInfo
)
{
    dbgTracePush ("nvTextureStretchBlit");

    nvAssert (pDstInfo->pObj);
    CTexture *pTexDst = pDstInfo->pObj->getTexture();
    nvAssert (pTexDst);

    // lock the swizzled surface since we're going to mess with it
    DDLOCKINDEX(NVSTAT_LOCK_STR_BLT);
    pTexDst->cpuLockSwz (CSimpleSurface::LOCK_NORMAL);

    DWORD dwAddrSrc = pSrcInfo->fpVidMem;
    DWORD dwAddrDst = pDstInfo->fpVidMem;

    DWORD dwPitchSrc = pSrcInfo->dwPitch;
    DWORD dwBPP = pSrcInfo->dwBytesPerPixel;

    DWORD dwWidthDst  = pTexDst->getWidth();
    DWORD dwHeightDst = pTexDst->getHeight();

    DWORD dwXDst, dwXDstInterleaved;
    DWORD dwYDst, dwYDstInterleaved;
    DWORD dwOffsetSrc, dwIndexDst;

    float fXSrc, fYSrc;

    float fdxSrc_dxDst = float(pSrcInfo->dwSubRectWidth)  / float(pDstInfo->dwSubRectWidth);
    float fdySrc_dyDst = float(pSrcInfo->dwSubRectHeight) / float(pDstInfo->dwSubRectHeight);

    switch (dwBPP) {

        case 2:

            fYSrc = float (pSrcInfo->dwSubRectY);

            for (dwYDst=pDstInfo->dwSubRectY; dwYDst < pDstInfo->dwSubRectY + pDstInfo->dwSubRectHeight; dwYDst++) {

                V_INTERLEAVE (dwYDstInterleaved, dwYDst, dwWidthDst, dwHeightDst);

                fXSrc = float (pSrcInfo->dwSubRectX);

                for (dwXDst=pDstInfo->dwSubRectX; dwXDst < pDstInfo->dwSubRectX + pDstInfo->dwSubRectWidth; dwXDst++) {

                    U_INTERLEAVE (dwXDstInterleaved, dwXDst, dwWidthDst, dwHeightDst);

                    dwIndexDst  = dwXDstInterleaved | dwYDstInterleaved;
                    dwOffsetSrc = (DWORD(fYSrc) * dwPitchSrc) + (DWORD(fXSrc) * dwBPP);

                    ((WORD*)dwAddrDst)[dwIndexDst] = *(WORD*)(dwAddrSrc + dwOffsetSrc);

                    // increment src x coord
                    fXSrc += fdxSrc_dxDst;
                }

                // increment src y coord
                fYSrc += fdySrc_dyDst;
            }

            break;

        case 4:

            fYSrc = float (pSrcInfo->dwSubRectY);

            for (dwYDst=pDstInfo->dwSubRectY; dwYDst < pDstInfo->dwSubRectY + pDstInfo->dwSubRectHeight; dwYDst++) {

                V_INTERLEAVE (dwYDstInterleaved, dwYDst, dwWidthDst, dwHeightDst);

                fXSrc = float (pSrcInfo->dwSubRectX);

                for (dwXDst=pDstInfo->dwSubRectX; dwXDst < pDstInfo->dwSubRectX + pDstInfo->dwSubRectWidth; dwXDst++) {

                    U_INTERLEAVE (dwXDstInterleaved, dwXDst, dwWidthDst, dwHeightDst);

                    dwIndexDst  = dwXDstInterleaved | dwYDstInterleaved;
                    dwOffsetSrc = (DWORD(fYSrc) * dwPitchSrc) + (DWORD(fXSrc) * dwBPP);

                    ((DWORD*)dwAddrDst)[dwIndexDst] = *(DWORD*)(dwAddrSrc + dwOffsetSrc);

                    // increment src x coord
                    fXSrc += fdxSrc_dxDst;
                }

                // increment src y coord
                fYSrc += fdySrc_dyDst;
            }

            break;

        default:
            DPF ("unknown bit depth in nvTextureStretchBlit");
            dbgD3DError();
            break;

    } // switch

    // update tags
    pTexDst->getSwizzled()->tagUpToDate();
    pTexDst->getLinear()->tagOutOfDate();

    // unlock the swizzled surface
    pTexDst->cpuUnlockSwz();

    dbgTextureDisplay (pTexDst);

    dbgTracePop();
    return (DD_OK);

}

//---------------------------------------------------------------------------

// nvTextureLock
//
// locks a texture so the user can party on the texels

DWORD nvTextureLock
(
    CTexture         *pTexture,
    LPDDHAL_LOCKDATA  lpLockData
)
{
    DWORD retVal;
    retVal = DDHAL_DRIVER_NOTHANDLED;

    dbgTracePush ("nvTextureLock");

    assert (pTexture);

    // figure out what we need to do
    BOOL  bNoLinear   = FALSE;
    BOOL  bNoSysLock  = lpLockData->dwFlags & DDLOCK_NOSYSLOCK;
    DWORD dwOldLinear = pTexture->getLinear()->getAddress();

    if (pTexture->hasAutoPalette())
    {
        lpLockData->ddRVal = DD_OK;
        return DDHAL_DRIVER_NOTHANDLED;
    }

    // swizzled NVT format textures
    if ((pTexture->getFourCC() & FOURCC_NVT_MASK) == FOURCC_NVTx)
    {
        bNoLinear = TRUE;
    }
    else  // linear format
    {
        pTexture->updateLinearSurface();
        // tag swizzled surface as not up to date (since lock impicitly modifies the linear copy)
        // but NOT if the LOCK flags indicates they don't intend to change the contents
        if(!(lpLockData->dwFlags & DDLOCK_READONLY)){
            // only mark dirty if user intends to change linear contents.
            pTexture->getSwizzled()->tagOutOfDate();

            // if this is part of a cube map/mipmap, tag the base as dirty
            //  this will trigger a proper update of all subsurfaces before HW touches them
            if (pTexture->isUserMipLevel() || pTexture->isCubeMap())
            {
                pTexture->getBaseTexture()->tagSubSurfacesDirty();
            }
        }
    }

    // now that linear surface may exist, get its heap location
    DWORD dwHeapLocation = pTexture->getLinear()->getHeapLocation();

    // setup DDRAW with surface information. Under WINNT, DirectX uses
    // the offset in fpVidMem to calculate a per process surface address.

    if (bNoLinear) // compressed or swizzled format
    {
        dwHeapLocation = pTexture->getSwizzled()->getHeapLocation();

#ifdef NV_AGP
        if( dwHeapLocation & CSimpleSurface::HEAP_AGP )
        {
            DWORD dwBaseAddress = pTexture->getBaseTexture()->getSwizzled()->getAddress();
            DWORD dwMipAddress  = pTexture->getSwizzled()->getAddress();
            lpLockData->lpSurfData = (void *)(nvAGPGetUserAddr(dwBaseAddress) + (dwMipAddress - dwBaseAddress));
        }
        else
#endif // NV_AGP
        {
            lpLockData->lpSurfData                   = (void*) pTexture->getSwizzled()->getfpVidMem();
            // we already set this in nvTextureCreateSurface
            //lpLockData->lpDDSurface->lpGbl->lPitch   = pTexture->getPitch();
        }

        lpLockData->lpDDSurface->lpGbl->fpVidMem = bNoSysLock // renaming can happen at any time - force ddraw to comply
                                                 ? 0
                                                 : (DWORD)lpLockData->lpSurfData;
    }
    else
    {
        // DX6 DDRAW BUG:
        // for reasons totally unknown to humanity the lock will return an incorrect alias to
        // the locked surface when NOSYSLOCK flag is set and lpSurfData == fpVidMem.
        // it seems that ddraw thinks that the memory did not move so the internal alias is
        // still valid. Fact of the matter is that it is wrong.
        // attempt to spoof ddraw into doing the right thing here.
        if ((global.dwDXRuntimeVersion < 0x0700) && (bNoSysLock) && (!dwOldLinear)) // 1st time created - thus we moved the surface
        {
            lpLockData->lpSurfData                   = (void*)pTexture->getLinear()->getfpVidMem();
            lpLockData->lpDDSurface->lpGbl->fpVidMem = pTexture->getSwizzled()->getfpVidMem();
            // we already set this in nvTextureCreateSurface
            //lpLockData->lpDDSurface->lpGbl->lPitch   = pTexture->getPitch();
        }
        else
        {
            lpLockData->lpSurfData                   = (void*)pTexture->getLinear()->getfpVidMem();
            lpLockData->lpDDSurface->lpGbl->fpVidMem = (DWORD)lpLockData->lpSurfData;
            // we already set this in nvTextureCreateSurface
            //lpLockData->lpDDSurface->lpGbl->lPitch   = pTexture->getPitch();
        }
    }

    // tell texture that CPU wants access
            #ifdef NV_PROFILE_CPULOCK
            NVP_START (NVP_T_TEX_LOCK);
            #endif
    DDLOCKINDEX(NVSTAT_LOCK_TEX_NORMAL);
    if (bNoLinear) pTexture->getSwizzled()->cpuLock (CSimpleSurface::LOCK_NORMAL);
              else pTexture->getLinear()->cpuLock (CSimpleSurface::LOCK_NORMAL);
            #ifdef NV_PROFILE_CPULOCK
            NVP_STOP (NVP_T_TEX_LOCK);
            nvpLogTime (NVP_T_TEX_LOCK,nvpTime[NVP_T_TEX_LOCK]);
            #endif

    // done
    lpLockData->ddRVal = DD_OK;
    dbgTracePop();

#ifdef WINNT
    /* If the user's copy of the the texture is in system memory, must handle. */
    if ((dwHeapLocation & CSimpleSurface::HEAP_ANYWHERE) && (dwHeapLocation & CSimpleSurface::HEAP_SYS)) {
        retVal = DDHAL_DRIVER_HANDLED;
    }
#endif // WINNT
    // return NOTHANDLED because for Locks the return values are reversed from what
    // would make any sense whatsoever.
    return retVal;
}

//---------------------------------------------------------------------------

// nvTextureUnlock
//
// unlocks a texture after the user partied on the texels

DWORD nvTextureUnlock
(
    CTexture           *pTexture,
    LPDDHAL_UNLOCKDATA  lpUnlockData
)
{
    dbgTracePush ("nvTextureUnlock");

    assert (pTexture);

    // unlock texture
    if (pTexture->isFourCC()
     && !pTexture->isDXT())  // swizzled format
    {
        pTexture->cpuUnlockSwz();
        // force hw fetch
        PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
        while (pContext)
        {
            invalidateTextureCache (pContext);
            pContext = pContext->pContextNext;
        }
    }
    else
    {
        pTexture->cpuUnlockLin();
    }


    // if this texture is in use, we must set the texture stage dirty bit
    // to force invalidation of the texture cache
    CNvObject *pNvObj = pTexture->getWrapper();
    PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
    while (pContext)
    {
        if ((pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] == (DWORD)pNvObj) ||
            (pContext->tssState[1].dwValue[D3DTSS_TEXTUREMAP] == (DWORD)pNvObj)) {
            invalidateTextureCache (pContext);
        }
        pContext = pContext->pContextNext;
    }

    // done
    lpUnlockData->ddRVal = DD_OK;

    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

//---------------------------------------------------------------------------

// D3DCreateTextureContexts
//
// allocate the system memory texture context DMA

DWORD D3DCreateTextureContexts
(
    DWORD   dwHeapBase,
    DWORD   dwNewLimit
)
{
    DWORD   dwStatus;

    dbgTracePush ("D3DCreateTextureContexts");

    dwStatus = NVOS03_STATUS_ERROR_BAD_LIMIT;

    if (dwHeapBase && dwNewLimit) {
        dwStatus = NvRmAllocContextDma(pDriverData->dwRootHandle,
                                       D3D_CONTEXT_DMA_HOST_MEMORY,
                                       NV01_CONTEXT_DMA,
                                       DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_ONLY) |
                                       DRF_DEF(OS03, _FLAGS, _LOCKED, _ALWAYS) |
                                       DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
                                       (PVOID) dwHeapBase,
                                       dwNewLimit);
    }

    // Force both triangle states to be resent.
    pDriverData->dDrawSpareSubchannelObject = 0;
    // let ddraw know we messed with the celsius object
    pDriverData->dwMostRecentHWUser = MODULE_ID_D3D;

    DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"Vid Heap: Address:%08x Size:%08x\n",pDriverData->BaseAddress,pDriverData->TotalVRAM);

    dbgTracePop();
    return (dwStatus);
}

//---------------------------------------------------------------------------

// Destroy all texture DMA contexts and free all allocated system memory for shutdown.

void D3DDestroyTextureContexts
(
    GLOBALDATA *pDriverData
)
{
    dbgTracePush ("D3DDestroyTextureContexts");
    NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, D3D_CONTEXT_DMA_HOST_MEMORY);
    dbgTracePop();
}

//---------------------------------------------------------------------------

BOOL nvTextureDefaultAlloc
(
    void
)
{
    dbgTracePush ("nvTextureDefaultAlloc");

    // create the white texture
    nvAssert (getDC()->pDefaultTexture == NULL);

    getDC()->pDefaultTexture = new CTexture;

    if (!getDC()->pDefaultTexture) {
        DPF ("nvTextureDefaultAlloc - out of memory");
        dbgTracePop();
        return (FALSE);
    }

    if (!getDC()->pDefaultTexture->create (NULL, 1, 1, 1, 2, 2, 1, NV_SURFACE_FORMAT_A1R5G5B5,
                                           CSimpleSurface::HEAP_VID, CSimpleSurface::HEAP_VID)) {
        DPF ("nvTextureDefaultAlloc - out of memory");
        dbgTracePop();
        return (FALSE);
    }

    // fill with a white pixel
    *(WORD*) (getDC()->pDefaultTexture->getSwizzled()->getAddress()) = 0xffff;

    // create the texture used for user clip planes
    nvAssert (getDC()->pClipPlaneTexture == NULL);

    getDC()->pClipPlaneTexture = new CTexture;

    if (!getDC()->pClipPlaneTexture) {
        DPF ("nvTextureDefaultAlloc - out of memory");
        dbgTracePop();
        return(FALSE);
    }

    if (!getDC()->pClipPlaneTexture->create (NULL, 2, 2, 1, 2, 2, 1, NV_SURFACE_FORMAT_A1R5G5B5,
                                             CSimpleSurface::HEAP_VID, CSimpleSurface::HEAP_VID)) {
        DPF ("nvTextureDefaultAlloc - out of memory");
        dbgTracePop();
        return (FALSE);
    }

    // fill with [0 0; 0 1]
    WORD *pData = (WORD*) (getDC()->pClipPlaneTexture->getSwizzled()->getAddress());
    pData[0] = 0x0000;   pData[1] = 0x0000;
    pData[2] = 0x0000;   pData[3] = 0xffff;

    // init spare texture memory
    DWORD dwStatus;
    for (DWORD ii=0; ii<2; ii++) {
        NVHEAP_ALLOC (dwStatus, getDC()->dwSpareTextureAddr[ii], 256 + NV_TEXTURE_PAD, TYPE_TEXTURE);
        if (dwStatus) {
            DPF ("nvTextureDefaultAlloc - failed to allocate spare texture space");
            dbgTracePop();
            return (FALSE);
        }
        getDC()->dwSpareTextureOffset[ii] = ((getDC()->dwSpareTextureAddr[ii] + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN) - pDriverData->BaseAddress;
        pDriverData->DDrawVideoSurfaceCount ++;
    }

    dbgTracePop();
    return (TRUE);
}

//-------------------------------------------------------------------------

void nvTextureDefaultFree
(
    void
)
{
    dbgTracePush ("nvTextureDefaultFree");

    // release the NVIDIA logo
    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_LOGOENABLE_MASK) == D3D_REG_LOGOENABLE_ENABLE) {
        nvFreeLogo();
    }

    // release the default (white) texture
    if (getDC()->pDefaultTexture) {
        getDC()->pDefaultTexture->destroy();
        delete getDC()->pDefaultTexture;
        getDC()->pDefaultTexture = NULL;
    }

    // release the texture used for user clip planes
    if (getDC()->pClipPlaneTexture) {
        getDC()->pClipPlaneTexture->destroy();
        delete getDC()->pClipPlaneTexture;
        getDC()->pClipPlaneTexture = NULL;
    }

    // free the spare texture memory
    for (DWORD ii=0; ii<2; ii++) {
        if (getDC()->dwSpareTextureAddr[ii] != 0xffffffff) {
            NVHEAP_FREE (getDC()->dwSpareTextureAddr[ii]);
            getDC()->dwSpareTextureAddr[ii] = 0;
            getDC()->dwSpareTextureOffset[ii] = 0;
            pDriverData->DDrawVideoSurfaceCount --;
        }
    }

    dbgTracePop();
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvVB.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#include "nvprecomp.h"

/*****************************************************************************
 *****************************************************************************
 *****************************************************************************
 ***  CVertexBuffer  *********************************************************
 *****************************************************************************
 *****************************************************************************
 *****************************************************************************/

/*****************************************************************************
 * CVertexBuffer::prepareSuperTriLookAsideBuffer
 */
BOOL CVertexBuffer::prepareSuperTriLookAsideBuffer
(
    void
)
{
    //
    // fail if we cannot support supertri for this buffer
    //
    if (!getVertexStride()) return FALSE;

    //
    // [re]create buffer if needed
    //
    DWORD dwVertexCount = getSize() / getVertexStride();
    if (dwVertexCount != m_dwSuperTriLookAsideBufferSize)
    {
        destroySuperTriLookAsideBuffer();
        m_dwSuperTriLookAsideBufferSize = dwVertexCount;
    }

    if (!m_pSuperTriLookAsideBuffer)
    {
        // Align to 2 cachelines (1 cacheline for Willamette)
        // this is taken care of internally by AllocIPM (64 byte align)
        DWORD dwSize = dwVertexCount * sizeof(STVERTEX);
        m_pSuperTriLookAsideBuffer = AllocIPM(dwSize);
        if (!m_pSuperTriLookAsideBuffer) return FALSE;
        m_dwFlags |= FLAG_SUPERTRIOWNSMEM;
    }

    //
    // fill out (very slow operation)
    //
    DWORD dwSource = getAddress();
    DWORD dwDest   = (DWORD)m_pSuperTriLookAsideBuffer;
    DWORD *dwDestp = (DWORD *)m_pSuperTriLookAsideBuffer;
    for (DWORD i = 0; i < dwVertexCount; i++)
    {
        nvMemCopy (dwDest, dwSource, sizeof(STVERTEX));
        dwDestp[3] = 0;
        dwSource += getVertexStride();
        dwDestp  += sizeof(STVERTEX)/sizeof(float);
        dwDest   += sizeof(STVERTEX);
    }

    //
    // done
    //
    return TRUE;
}

/*****************************************************************************
 * CVertexBuffer::destroySuperTriLookAsideBuffer
 */
void CVertexBuffer::destroySuperTriLookAsideBuffer
(
    void
)
{
    if (m_dwFlags & FLAG_SUPERTRIOWNSMEM)
    {
        if (m_pSuperTriLookAsideBuffer)
        {
            FreeIPM (m_pSuperTriLookAsideBuffer);
            m_pSuperTriLookAsideBuffer = NULL;
        }
    }
}

/*****************************************************************************
 * CVertexBuffer::CVertexBuffer
 *
 * initialize a VB object
 */
CVertexBuffer::CVertexBuffer
(
    CNvObject *pWrapperObject
)
{
    // tell world
    DPF_LEVEL (NVDBG_LEVEL_SURFACE, "CVertexBuffer[%08x]::CVertexBuffer()", this);

    // assign variables
    m_pWrapperObject = pWrapperObject;

    // init the others
    m_dwFlags                       = 0;
    m_dwSuperTriLookAsideBufferSize = 0;
    m_pSuperTriLookAsideBuffer      = NULL;
    m_dwLockCount                   = 0;
}

/*****************************************************************************
 * CVertexBuffer::~CVertexBuffer
 *
 * destroy a VB object
 */
CVertexBuffer::~CVertexBuffer
(
    void
)
{
    /*
     * tell world
     */
    DPF_LEVEL (NVDBG_LEVEL_SURFACE, "CVertexBuffer[%08x]::~CVertexBuffer()", this);

    destroy();
}

/*****************************************************************************
 *****************************************************************************
 *****************************************************************************
 ***  CCommandBuffer  ********************************************************
 *****************************************************************************
 *****************************************************************************
 *****************************************************************************/

/*****************************************************************************
 * CCommandBuffer::CCommandBuffer
 */
CCommandBuffer::CCommandBuffer
(
    CNvObject                 *pWrapperObject,
    LPDDRAWI_DDRAWSURFACE_LCL  pDDSurfaceLcl
)
{
    /*
     * tell world
     */
    DPF_LEVEL (NVDBG_LEVEL_SURFACE, "CCommandBuffer[%08x]::CCommandBuffer()", this);

    m_pWrapperObject  = pWrapperObject;
    m_pDDSurfaceLcl   = pDDSurfaceLcl;
    m_Surface.setWrapper(pWrapperObject);
#ifdef WINNT
    m_Surface.getWrapper()->setDDSLcl(pDDSurfaceLcl);
#endif
}

/*****************************************************************************
 * CCommandBuffer::~CCommandBuffer
 */
CCommandBuffer::~CCommandBuffer
(
    void
)
{
    /*
     * tell world
     */
    DPF_LEVEL (NVDBG_LEVEL_SURFACE, "CCommandBuffer[%08x]::~CCommandBuffer()", this);
}

/*****************************************************************************
 *****************************************************************************
 *****************************************************************************
 ***  exports  ***************************************************************
 *****************************************************************************
 *****************************************************************************
 *****************************************************************************/

/*****************************************************************************
 * D3DCanCreateExecuteBuffer32
 *
 * D3D callback to check if we can create an execute, vertex or command buffer
 */
DWORD __stdcall D3DCanCreateExecuteBuffer32
(
    LPDDHAL_CANCREATESURFACEDATA pCanCreateSurfaceData
)
{
    dbgTracePush ("D3DCanCreateExecuteBuffer32");

    //
    // figure out if we can create a VB
    //
#ifdef DEBUG
    DWORD         dwLatest       = 0;
    PNVD3DCONTEXT pContext       = (PNVD3DCONTEXT)getDC()->dwContextListHead;
    PNVD3DCONTEXT pActualContext = NULL;
    while (pContext)
    {
        if (pContext->dwTickLastUsed > dwLatest)
        {
            pContext->dwTickLastUsed = dwLatest;
            pActualContext           = pContext;
        }
        pContext = pContext->pContextNext;
    }
    DWORD dwAppRuntimeLevel = pActualContext ? pActualContext->dwDXAppVersion
                                             : 0x0600;

    // show this call
    DPF_LEVEL (NVDBG_LEVEL_SURFACE, "D3DCanCreateExecuteBuffer32: appdx=%04x  rtdx=%04x",
               dwAppRuntimeLevel,global.dwDXRuntimeVersion);
#endif

    //
    // punt if we have DX6 runtime
    //
    if (global.dwDXRuntimeVersion <= 0x600)
    {
        pCanCreateSurfaceData->ddRVal = DDERR_INVALIDCAPS;
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    }

#ifdef DO_NOT_SUPPORT_VERTEX_BUFFERS // see nvprecomp.h
    pCanCreateSurfaceData->ddRVal = DDERR_INVALIDCAPS;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
#endif //!DO_NOT_SUPPORT_VERTEX_BUFFERS

    //
    // is this an optimize call?
    //
    if (pCanCreateSurfaceData->lpDDSurfaceDesc->dwFlags & DDSD_SRCVBHANDLE)
    {
        pCanCreateSurfaceData->ddRVal = DDERR_INVALIDCAPS;
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    }

    nvSetDriverDataPtrFromDDGbl (pCanCreateSurfaceData->lpDD);

    // fail if we don't have AGP memory -
    // on true PCI cards we never get this call, but on an AGP card running with AGP disabled (with the
    // DirectX diagnostic tool) the run-time will puke if we create a vertex buffer in PCI memory
    //
    if (!(pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_PCIBUS))
        if (pDriverData->GARTLinearBase == NULL)
        {
            NvReleaseSemaphore(pDriverData);
            pCanCreateSurfaceData->ddRVal = DDERR_INVALIDCAPS;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }

    //
    // we claim that we can create all types of buffers
    //
    NvReleaseSemaphore(pDriverData);
    pCanCreateSurfaceData->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

/*****************************************************************************
 * D3DCreateExecuteBuffer32
 *
 * D3D callback to create an execute, vertex or command buffer
 */
DWORD __stdcall D3DCreateExecuteBuffer32
(
    LPDDHAL_CREATESURFACEDATA pCreateSurfaceData
)
{
    dbgTracePush ("D3DCreateExecuteBuffer32");

    //
    // is this an optimize call?
    //
    DWORD dwFlags = pCreateSurfaceData->lpDDSurfaceDesc->dwFlags;
    if (dwFlags & DDSD_SRCVBHANDLE)
    {
        pCreateSurfaceData->ddRVal = DDERR_INVALIDCAPS;
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    }

    //
    // get driver context
    //
    nvSetDriverDataPtrFromDDGbl (pCreateSurfaceData->lpDD);

    // Reset NV and get the monitor frequency after a mode reset
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        getDisplayDuration();
        if (!nvEnable32 (pCreateSurfaceData->lpDD)) {
            NvReleaseSemaphore(pDriverData);
            pCreateSurfaceData->ddRVal = DDERR_OUTOFMEMORY;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    //
    // get app version by looking for the presence of FVF flag
    // i begged for a better hint bit from MS - will see.
    //

    // bIsDX6 will be true for DX8 Index Buffers.  No way to code around it, so we will take a
    // dx6 performance hit when we are running on DX8
    BOOL bIsDX6       = FALSE;
    // wa rpeviously: BOOL bIsDX6 = ((dwFlags & DDSD_FVF) != DDSD_FVF); // not valid for command buffers
    BOOL bIsImplicit  = FALSE;
    BOOL bForceSysMem = FALSE;

    /*
     * for all surfaces in SList
     */
    LPDDRAWI_DDRAWSURFACE_LCL *lplpSList = pCreateSurfaceData->lplpSList;
    for(DWORD i = 0; i < pCreateSurfaceData->dwSCnt; i++)
    {
        /*
         * get the dd surface
         */
        LPDDRAWI_DDRAWSURFACE_LCL lpSurf = lplpSList[i];

        /*
         * figure out what to create
         */
        if (lpSurf->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
        {
            if (lpSurf->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VERTEXBUFFER)
            {
            allocVertexBuffer:
                //
                // we have shown that DX6 vertex buffers are slower than MS managing them (3d mark 99)
                //
                BOOL bDoNotHandle = FALSE;
                if (bIsDX6 /*|| bIsImplicit  -- slower now - bdw */) {
                    bDoNotHandle = TRUE;
                }
#ifdef STEREO_SUPPORT
                //All vertices that potentially will be read back in order to be modified for stereo
                //should go to system memory.
                else
                {
                    if (STEREO_ENABLED)
                    {
                        if (bIsImplicit || ((dwFlags & DDSD_FVF) != DDSD_FVF))
                        {
                            //For stereo implicit and DX6 type VBs still go to system memory.
                            bDoNotHandle = TRUE;
                        } else
                        {
                            LPDDSURFACEDESC2 lpSurfDesc2 = (LPDDSURFACEDESC2)pCreateSurfaceData->lpDDSurfaceDesc;
                            if (FVF_TRANSFORMED(lpSurfDesc2->dwFVF))
                            {
                                //We don't want to allocate VBs for transformed vertices in offscreen memory. The
                                //problem is that we will have to physically modify vertices for the left and right
                                //eyes and it is going to be dog slow if the vertices end up in VRAM. So sacrificing
                                //VRAM VBs for this case is our trade off for being able to view stereo.
                                bDoNotHandle = TRUE;
                            }
                        }
                    }
                }
#endif  //STEREO_SUPPORT
                if (bDoNotHandle)
                {
                    NvReleaseSemaphore(pDriverData);
                    pCreateSurfaceData->ddRVal = DDERR_INVALIDCAPS;
                    dbgTracePop();
                    return DDHAL_DRIVER_HANDLED;
                }

                /*
                 * create a vertex buffer
                 */
#ifndef WINNT   // WINNT BUG - what about pid?
                CNvObject      *pNvObj = new CNvObject (lpSurf->dwProcessId);
#else   // WINNT
                CNvObject      *pNvObj = new CNvObject (0);
#endif  // WINNT
                CVertexBuffer  *pVertexBuffer;
                BOOL            bAllowRenaming;

                if (pNvObj)
                {
                    pVertexBuffer = new CVertexBuffer (pNvObj);
                    
                    if (!pVertexBuffer)
                    {
                        pNvObj->release();
                        NvReleaseSemaphore(pDriverData);
                        DPF ("D3DCreateExecuteBuffer32: failed to create CVertexBuffer object");
                        dbgD3DError();
                        pCreateSurfaceData->ddRVal = DDERR_OUTOFMEMORY;
                        dbgTracePop();
                        return DDHAL_DRIVER_HANDLED;
                    }

                    #ifdef DX7PROPER
                    if (bIsDX6)
                    {
                        PF ("1. Vertexbuffer is created from a DX6 interface.");
                        DPF_LEVEL(NVDBG_LEVEL_PERFORMANCE, "Vertex Buffer wasn't created by driver, copy forced");
                    }
                    #endif

                    //
                    // determine where to put the buffer
                    //  - we can force the VB in sysmem (dx6 implicit VB)
                    //  - if app will write only, go for agp or vid mem
                    //
                    DWORD dwAllowed;
                    DWORD dwPreferred;
                    LPDDSURFACEDESC2 lpSurfDesc2 = (LPDDSURFACEDESC2)pCreateSurfaceData->lpDDSurfaceDesc;


                    if ( (lpSurfDesc2->dwFVF & D3DFVF_PSIZE) ||
                         (lpSurf->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_RTPATCHES)
                        )
                    {
                        //force emulated point sprites into system memory
                        //force emulated vertex shaders into system memory
                        bForceSysMem = TRUE;
                    }

                    if (bForceSysMem
                     || !(lpSurf->ddsCaps.dwCaps & DDSCAPS_WRITEONLY)
                     /*|| (bIsImplicit)*/)  // Implicit buffers will be DMA'ed (WB2k)
                    {
                        #ifdef DX7PROPER // inaccurte for supertri case (i.e. actually a good thing)
                            DPF_LEVEL(NVDBG_LEVEL_PERFORMANCE, "Vertex Buffer forced into system memory");
                            PF ("2. Vertexbuffer is forced into system memory.");
                        #endif

                        //
                        // we force system memory with no renaming
                        //
                        dwAllowed      = CSimpleSurface::HEAP_SYS;
                        dwPreferred    = CSimpleSurface::HEAP_SYS;
                        bAllowRenaming = FALSE;

                        // temporary fix for sys mem VB's: allow MS to create them.
                        // we really should map/unmap them into the user space ourselves
                        pCreateSurfaceData->ddRVal = DDERR_GENERIC;
                        
                        // delete the pVertexBuffer we created, release the pNvObject
                        delete pVertexBuffer;
                        pNvObj->release();

                        NvReleaseSemaphore(pDriverData);
                        dbgTracePop();
                        return DDHAL_DRIVER_HANDLED;
                    }
                    else
                    {
                        //
                        // we allow both agp & vid
                        //
                        dwAllowed   = CSimpleSurface::HEAP_VID
                                    | (pDriverData->GARTLinearBase ? CSimpleSurface::HEAP_AGP
                                                                   : CSimpleSurface::HEAP_PCI);
                        //
                        // we prefer vid for machines with fast write cap, else agp (its closer)
                        //
                        // DX8  we'll need to look at memory usage etc...
                        if (lpSurf->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_HINTSTATIC) {
                            dwPreferred = CSimpleSurface::HEAP_VID;
                        }
                        else {
                            dwPreferred = (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_VB_PREFER_AGP) ?
                                          (CSimpleSurface::HEAP_AGP | CSimpleSurface::HEAP_PCI) :
                                          (CSimpleSurface::HEAP_VID);
                        }
                        //
                        // some renaming is allowed
                        //
                        bAllowRenaming = TRUE;
                    }

                    //LPDDSURFACEDESC2 lpSurfDesc2 = (LPDDSURFACEDESC2)pCreateSurfaceData->lpDDSurfaceDesc;
                    // compute a DX8-style shader from the FVF format in order to generate the stride
                    //CVertexShader vShader;
                    //vShader.create ((PNVD3DCONTEXT)(pDriverData->dwContextListHead), lpSurfDesc2->dwFVF);
                    //pVertexBuffer->setVertexStride (vShader.getStride());

                    // set stride to 0. proper stride gets set in DP2
                    pVertexBuffer->setVertexStride (0);

                    // allocate the actual memory
                    DWORD dwSize = lpSurf->lpGbl->dwLinearSize;
#ifdef WINNT
                    pNvObj->setDDSLcl(lpSurf);
#endif
                    if (!pVertexBuffer->create(dwSize,
                                               dwAllowed,
                                               dwPreferred))
                    {
                        // temporary fix for sys mem VB's: allow MS to create them.
                        // we really should map/unmap them into the user space ourselves
                        pCreateSurfaceData->ddRVal = DDERR_GENERIC;

                        // delete the pVertexBuffer we created, release the pNvObject
                        delete pVertexBuffer;
                        pNvObj->release();

                        NvReleaseSemaphore(pDriverData);
                        dbgTracePop();
                        return DDHAL_DRIVER_HANDLED;
                    }

#ifdef MEMORY_ACTIVITY_CAPTURE
                    {
                        for (DWORD a = 0; a < dwSize; a += 4096)
                        {
                            *(DWORD*)(pVertexBuffer->getAddress() + a) = 0xaaaa1111;
                        }
                    }
#endif

                }
                else
                {
                    NvReleaseSemaphore(pDriverData);
                    DPF ("D3DCreateExecuteBuffer32: failed to create CNvObject object");
                    dbgD3DError();
                    pCreateSurfaceData->ddRVal = DDERR_OUTOFMEMORY;
                    dbgTracePop();
                    return DDHAL_DRIVER_HANDLED;
                }

                //
                // tag as dx6 vb
                //
                if (bIsDX6)
                {
                    pVertexBuffer->tagDX6();
                }

                /*
                 * all VBs are renameable
                 */
                if (bAllowRenaming)
                { 
                    pVertexBuffer->tagRenameEnable (CComplexSurface<TOTAL_VB_RENAME>::RENAME_DO_NOTHING);
                }

                //
                // tag flags
                //
                if (bIsImplicit) pVertexBuffer->tagD3DImplicit();

                /*
                 * tell the world
                 */
                DPF_LEVEL (NVDBG_LEVEL_SURFACE, "VB [%08x] created: [%s] incaps=0x%08x, addr=0x%08x ctxdma=%d size=%d pNvObj=%08x",
                           pVertexBuffer,
                           bIsImplicit ? "implicit" : "normal",
                           lpSurf->ddsCaps.dwCaps,
                           pVertexBuffer->getAddress(),
                           pVertexBuffer->getContextDMA(),
                           lpSurf->lpGbl->dwLinearSize,
                           pNvObj);

                /*
                 * populate DDraw
                 */
                pNvObj->setObject (CNvObject::NVOBJ_VERTEXBUFFER, pVertexBuffer);
                SET_PNVOBJ (lpSurf, pNvObj);
                if (global.dwDXRuntimeVersion >= 0x0700) {
                    DPF_LEVEL(NVDBG_LEVEL_SURFACE_ACTIVITY, "Create Vertex Buffer: pDDSLcl = %08x, handle = %02x",
                              lpSurf, lpSurf->lpSurfMore->dwSurfaceHandle);
                }

#ifdef WINNT
                if (pVertexBuffer->getHeapLocation() == CSimpleSurface::HEAP_SYS)
                {
                    lpSurf->lpGbl->fpVidMem = (FLATPTR)pVertexBuffer->getfpVidMem();
                }
                else if (pVertexBuffer->getHeapLocation() == CSimpleSurface::HEAP_AGP)
                {
#ifdef NV_AGP
                    lpSurf->lpGbl->fpVidMem = nvAGPGetUserAddr(pVertexBuffer->getAddress());
#else
                    lpSurf->lpGbl->lpVidMemHeap = ppdev->AgpHeap;
                    lpSurf->lpGbl->fpHeapOffset = pVertexBuffer->getfpVidMem() + pDriverData->GARTLinearHeapOffset;
#endif
                }
                else
#endif
                {
#ifdef WINNT
                    lpSurf->lpGbl->fpHeapOffset  = pVertexBuffer->getfpVidMem();
#endif
                    lpSurf->lpGbl->fpVidMem = pVertexBuffer->getfpVidMem();
                }
#ifdef MCFD
                lpSurf->ddsCaps.dwCaps  = pVertexBuffer->m_blockList.modifyDDCaps(lpSurf->ddsCaps.dwCaps);
#else
                lpSurf->ddsCaps.dwCaps  = pVertexBuffer->getSurface()->modifyDDCaps(lpSurf->ddsCaps.dwCaps);
#endif

#ifndef WINNT
                //
                // must tell dx if it ended up in sysmem (cannot use DDSCAPS_SYSTEMMEMORY)
                //
#ifdef MCFD
                if (!pVertexBuffer->hwCanRead())
                {
                    lpSurf->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_SYSMEMEXECUTEBUFFER;
                }
#else
                if (!pVertexBuffer->getSurface()->hwCanRead())
                {
                    lpSurf->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_SYSMEMEXECUTEBUFFER;
                }
#endif
#endif // WINNT
            }
            else if (lpSurf->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_COMMANDBUFFER)
            {
                /*
                 * create a command buffer
                 */
#ifndef WINNT   // WINNT BUG what about pid?
                CNvObject      *pNvObj = new CNvObject (lpSurf->dwProcessId);
#else   // WINNT
                CNvObject      *pNvObj = new CNvObject (0);
#endif  // WINNT
                CCommandBuffer *pCommandBuffer;

                if (pNvObj)
                {
                    pCommandBuffer = new CCommandBuffer(pNvObj,lpSurf);
                    if (!pCommandBuffer)
                    {
                        pNvObj->release();
                        NvReleaseSemaphore(pDriverData);
                        DPF ("D3DCreateExecuteBuffer32: failed to create CCommandBuffer object");
                        dbgD3DError();
                        pCreateSurfaceData->ddRVal = DDERR_OUTOFVIDEOMEMORY;
                        dbgTracePop();
                        return DDHAL_DRIVER_HANDLED;
                    }

                    /*
                     * allocate the actual memory
                     */
                    pNvObj->setObject (CNvObject::NVOBJ_COMMANDBUFFER, pCommandBuffer);
                    SET_PNVOBJ (lpSurf, pNvObj);

                    if (!pCommandBuffer->create(lpSurf->lpGbl->dwLinearSize))
                    {
                        pNvObj->release();
                        NvReleaseSemaphore(pDriverData);
                        DPF ("D3DCreateExecuteBuffer32: failed to create CCommandBuffer surface");
                        dbgD3DError();
                        pCreateSurfaceData->ddRVal = DDERR_OUTOFMEMORY;
                        dbgTracePop();
                        return DDHAL_DRIVER_HANDLED;
                    }
                }
                else
                {
                    NvReleaseSemaphore(pDriverData);
                    DPF ("D3DCreateExecuteBuffer32: failed to create CNvObject object");
                    dbgD3DError();
                    pCreateSurfaceData->ddRVal = DDERR_OUTOFMEMORY;
                    dbgTracePop();
                    return DDHAL_DRIVER_HANDLED;
                }
                /*
                 * populate DDraw
                 */
                // Command buffers are always system mem, have to change this code if that ever changes.

                lpSurf->lpGbl->fpVidMem = (FLATPTR)pCommandBuffer->getSurface()->getfpVidMem();
                lpSurf->ddsCaps.dwCaps        = pCommandBuffer->getSurface()->modifyDDCaps(lpSurf->ddsCaps.dwCaps);

#ifndef WINNT   // WINNT BUG what do we do here? ANSWER: nothing, DX6 not supported under NT
                lpSurf->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_SYSMEMEXECUTEBUFFER; // must tell dx6 that it ended up in sysmem
#endif  // !WINNT
                /*
                 * tell the world
                 */
                DPF_LEVEL (NVDBG_LEVEL_SURFACE, "Command buffer [%08x] created at 0x%08x, size %d bytes (pNvObj=%08x)",
                           pCommandBuffer,lpSurf->lpGbl->fpVidMem,lpSurf->lpGbl->dwLinearSize,pNvObj);
            }

            else if (lpSurf->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_INDEXBUFFER)
            {
                //just use the default VB create for now.
                bForceSysMem = TRUE;
                goto allocVertexBuffer;
            }

            else
            {
                //
                // Implicit VBs on DX6 MUST be in system memory
                //
                bIsImplicit = TRUE;
                if (bIsDX6)
                {
                    bForceSysMem = TRUE;
                }

                //
                // alloc.
                // use archaic beginners all-purpose symbolic instruction code logic to achieve this.
                //
                goto allocVertexBuffer;
            }
        }

        else
        {
            /*
             * foreign request - we cannot honor
             */
            NvReleaseSemaphore(pDriverData);
            pCreateSurfaceData->ddRVal = DDERR_INVALIDCAPS;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    NvReleaseSemaphore(pDriverData);
    pCreateSurfaceData->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

/*****************************************************************************
 * D3DDestroyExecuteBuffer32
 *
 * D3D callback to destroy an execute, vertex or command buffer
 */
DWORD __stdcall D3DDestroyExecuteBuffer32
(
    LPDDHAL_DESTROYSURFACEDATA pDestroySurfaceData
)
{
    dbgTracePush ("D3DDestroyExecuteBuffer32");

    /*
     * get driver context
     */
    nvSetDriverDataPtrFromDDGbl (pDestroySurfaceData->lpDD);

    //check for mode switch notification
    /*
    //This is commented out due to a MS kernel bug.  On A CTRL-ALT-DELETE, this
    //bit will be a random value.  This causes the app to get an invalid VB pointer
    //and fault. re-enable for Win2K SP2/Whistler

    if (global.dwDXRuntimeVersion >= 0x0700 && pDestroySurfaceData->lpDDSurface->dwFlags & DDRAWISURF_INVALID) {
        //not a true destroy, just notification of lost VB.
        //go ahead and exit?
        pDestroySurfaceData->lpDDSurface->lpGbl->fpVidMem = 0;
        NvReleaseSemaphore(pDriverData);
        pDestroySurfaceData->ddRVal = DD_OK;
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }
    */
    /*
     * extract surface to destroy
     */
    CNvObject *pNvObj = GET_PNVOBJ (pDestroySurfaceData->lpDDSurface);

    // pNvObj will be NULL if we voluntarily bailed out on the creation
    // (we sometimes do this for performance reasons)
    if (pNvObj) {

        switch (pNvObj->getClass())
        {
            /*
             * destroy vertex buffer
             */
            case CNvObject::NVOBJ_VERTEXBUFFER:
            case CNvObject::NVOBJ_COMMANDBUFFER:
            {
#ifdef DEBUG
                if (pNvObj->getClass() == CNvObject::NVOBJ_VERTEXBUFFER)
                {
                    CVertexBuffer *pVertexBuffer = pNvObj->getVertexBuffer();
                    DPF_LEVEL (NVDBG_LEVEL_SURFACE, "Vertex buffer about to be destroyed (pNvObj=%08x, pVB=%08x)",
                        pNvObj,pVertexBuffer);
                }
                else
                {
                    CCommandBuffer *pCommandBuffer = pNvObj->getCommandBuffer();
                    DPF_LEVEL (NVDBG_LEVEL_SURFACE, "Command buffer about to be destroyed (pNvObj=%08x, pCB=%08x)",
                        pNvObj,pCommandBuffer);
                }
                if (global.dwDXRuntimeVersion >= 0x0700) {
                    DPF_LEVEL(NVDBG_LEVEL_SURFACE_ACTIVITY, "Destroy Buffer: pDDSLcl = %08x, handle = %02x",
                              pDestroySurfaceData->lpDDSurface,
                              pDestroySurfaceData->lpDDSurface->lpSurfMore->dwSurfaceHandle);
                }
#endif
                pNvObj->release();

                //
                // update ddraw
                //
                pDestroySurfaceData->lpDDSurface->lpGbl->fpVidMem = 0;
                SET_PNVOBJ (pDestroySurfaceData->lpDDSurface, NULL);
                break;

            }
            /*
             * unknown
             */
            default:
            {
                /*
                 * report error
                 */
                NvReleaseSemaphore(pDriverData);
                DPF ("D3DDestroyExecuteBuffer32: unknown buffer passed in (pNvObj=%08x)",pNvObj);
                dbgD3DError();
                /*
                 * fail
                 */
                pDestroySurfaceData->ddRVal = DDERR_NOTFOUND;
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            }

        }  // switch

    }  // if...

    /*
     * done
     */
    NvReleaseSemaphore(pDriverData);
    pDestroySurfaceData->ddRVal = DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

#ifdef NV_AGP
//
// MS proposed hack for the 6 second delay on mode switch with DX8 SDK apps
// BUGBUG We should not execute this code on Whistler
//
inline void MSAdjustAliasLock(DD_DIRECTDRAW_GLOBAL* lpDD, int iChange)
{
    if ((ppdev->OsVersionInfo.dwMajorVersion == 5ul) && (ppdev->OsVersionInfo.dwMinorVersion == 0ul)) {
        LPDWORD lpTemp = ((DWORD*)lpDD) + 386;
        *lpTemp += iChange;
    }
}
#endif

/*****************************************************************************
 * D3DLockExecuteBuffer32
 *
 * D3D callback to lock an execute, vertex or command buffer
 */
DWORD __stdcall D3DLockExecuteBuffer32
(
    LPDDHAL_LOCKDATA pLockData
)
{
    DWORD dwRetVal;

    dbgTracePush ("D3DLockExecuteBuffer32");

    /*
     * get driver context
     */
    nvSetDriverDataPtrFromDDGbl (pLockData->lpDD);

    /*
     * extract surface
     */
    CNvObject *pNvObj = GET_PNVOBJ (pLockData->lpDDSurface);
    nvAssert(pNvObj);

    switch (pNvObj->getClass())
    {
        /*
         * vertex buffer
         */
        case CNvObject::NVOBJ_VERTEXBUFFER:
        {
            CVertexBuffer *pVertexBuffer = pNvObj->getVertexBuffer();

            if (!pVertexBuffer)
            {
                NvReleaseSemaphore(pDriverData);
                DPF ("D3DLockExecuteBuffer32: cannot lock vertex buffer");
                dbgD3DError();
                pLockData->ddRVal = DDERR_NOTFOUND;
                dbgTracePop();
                return DDHAL_DRIVER_HANDLED;
            }

            // should we rename?
            BOOL bRename   = pLockData->dwFlags & DDLOCK_DISCARDCONTENTS;
            BOOL bDontWait = pLockData->dwFlags & DDLOCK_NOOVERWRITE;

                    #ifdef DX7PROPER
                    if (!bRename)
                    {
                        if (!bDontWait)
                        {
                            DPF_LEVEL(NVDBG_LEVEL_PERFORMANCE, "Vertex Buffer didn't use DDLOCK_DISCARDCONTENTS"
                                "or DDLOCK_NOOVERWRITE");
                            PF ("5. Lock called and VB without DDLOCK_DISCARDCONTENTS.");
                        }
                    }

                    if (bRename && bDontWait)
                    {
                        DPF_LEVEL(NVDBG_LEVEL_PERFORMANCE, "Vertex Buffer used both DDLOCK_DISCARDCONTENTS"
                                "and DDLOCK_NOOVERWRITE at the same time");
                    }
                    #endif

            // lock and rename
                    #ifdef NV_PROFILE_CPULOCK
                    NVP_START (NVP_T_VB_LOCK);
                    #endif

#ifdef DEBUG
            DWORD dwOldAddress, dwNewAddress;
            if (bRename) {
                dwOldAddress = pVertexBuffer->getAddress();
            }
#endif

            if (!bDontWait)
            {
                DDLOCKINDEX(NVSTAT_LOCK_VB);
#ifdef MCFD


/////// a different approach is 

// DDLOCK_DISCARDCONTENTS don't trigger a copy if a renaming occurs
// DDLOCK_NOOVERWRITE --> means READ_ONLY         

                //not finished (Paul, don't look at this code !! )

                if (pLockData->dwFlags & DDLOCK_NOOVERWRITE)
                    pVertexBuffer->LockForCPU(CSimpleSurface::LOCK_READ);
                else
                {
                    if (pLockData->dwFlags & DDLOCK_DISCARDCONTENTS)
                        pVertexBuffer->LockForCPU(CSimpleSurface::LOCK_WRITE);
                    else
                        pVertexBuffer->LockForCPU(CSimpleSurface::LOCK_WRITE, RENAME_POLICY_COPY);
                }

#else
                pVertexBuffer->cpuLock (bRename ? CSimpleSurface::LOCK_RENAME
                                                : CSimpleSurface::LOCK_NORMAL);
#endif
            }

#ifdef DEBUG
            if (bRename) {
                dwNewAddress = pVertexBuffer->getAddress();
                DPF_LEVEL (NVDBG_LEVEL_SURFACE, "VB renamed: %08x -> %08x", dwOldAddress, dwNewAddress);
            }
#endif

            // handles cases where we get dp2 calls before the unlock
            if (bRename){
                pVertexBuffer->tagModified();
            }
                    #ifdef NV_PROFILE_CPULOCK
                    NVP_STOP (NVP_T_VB_LOCK);
                    nvpLogTime (NVP_T_VB_LOCK,nvpTime[NVP_T_VB_LOCK]);
                    #endif

            /*
             * update ddraw
             */
            if (pVertexBuffer->getHeapLocation() == CSimpleSurface::HEAP_SYS)
            {
                pLockData->lpSurfData                   = (void*)pVertexBuffer->getAddress();
                pLockData->lpDDSurface->lpGbl->fpVidMem = (DWORD)pLockData->lpSurfData;
                dwRetVal = DDHAL_DRIVER_HANDLED;
            }
#ifdef WINNT
            else if (pVertexBuffer->getHeapLocation() == CSimpleSurface::HEAP_AGP)
            {
#ifdef NV_AGP
                MSAdjustAliasLock(pLockData->lpDD, 1);
                pVertexBuffer->tagAliasLocked();
                pLockData->lpSurfData = (void *)nvAGPGetUserAddr(pVertexBuffer->getAddress());
                DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "Locking agp VB (%08x), fpVidMem = %08x", pVertexBuffer, pLockData->lpSurfData);
#else
                pLockData->lpDDSurface->lpGbl->fpVidMem    -= pLockData->lpDDSurface->lpGbl->fpHeapOffset; //hack
                pLockData->lpDDSurface->lpGbl->lpVidMemHeap = ppdev->AgpHeap;
                pLockData->lpDDSurface->lpGbl->fpHeapOffset = pVertexBuffer->getfpVidMem() + pDriverData->GARTLinearHeapOffset;
                pLockData->lpDDSurface->lpGbl->fpVidMem    += pLockData->lpDDSurface->lpGbl->fpHeapOffset; //hack
                pLockData->lpSurfData = (void *)pLockData->lpDDSurface->lpGbl->fpVidMem; //hack
#endif
                dwRetVal = DDHAL_DRIVER_HANDLED; //hack should be NOTHANDLED
            }
#endif
            else //video
            {
                pLockData->lpSurfData                   = (void*)pVertexBuffer->getfpVidMem();
                pLockData->lpDDSurface->lpGbl->fpVidMem = pVertexBuffer->getfpVidMem();
#if WINNT
                pLockData->lpDDSurface->lpGbl->fpHeapOffset = pVertexBuffer->getfpVidMem();
                pLockData->lpSurfData = (void *)((LPBYTE)pLockData->lpSurfData + pLockData->fpProcess); //hack
                pLockData->lpDDSurface->lpGbl->fpVidMem += pLockData->fpProcess; //hack
#endif
                dwRetVal = DDHAL_DRIVER_HANDLED; //hack should be NOTHANDLED
            }

            //
            // update our state
            //
            pVertexBuffer->tagD3DLocked();
            pVertexBuffer->bumpLockCount();
            break;
        }
        /*
         * command buffer
         */
        case CNvObject::NVOBJ_COMMANDBUFFER:
        {
            CCommandBuffer *pCommandBuffer = pNvObj->getCommandBuffer();

            if (!pCommandBuffer)
            {
                NvReleaseSemaphore(pDriverData);
                DPF ("D3DLockExecuteBuffer32: cannot lock command buffer");
                dbgD3DError();
                pLockData->ddRVal = DDERR_NOTFOUND;
                dbgTracePop();
                return DDHAL_DRIVER_HANDLED;
            }

            /*
             * lock
             */
            DDLOCKINDEX(NVSTAT_LOCK_EXECUTE_BUFFER);
            pCommandBuffer->cpuLock (CSimpleSurface::LOCK_NORMAL);

            /*
             * update ddraw
             */
            pLockData->lpSurfData                   = (void*)pCommandBuffer->getAddress();
            pLockData->lpDDSurface->lpGbl->fpVidMem = (DWORD)pLockData->lpSurfData;
            dwRetVal = DDHAL_DRIVER_HANDLED;
            break;
        }
        /*
         * unknown
         */
        default:
        {
            /*
             * report error
             */
            DPF ("D3DLockExecuteBuffer32: unknown buffer passed in (pNvObj=%08x)",pNvObj);
            dbgD3DError();
            /*
             * fail
             */
            NvReleaseSemaphore(pDriverData);
            pLockData->ddRVal = DDERR_NOTFOUND;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    /*
     * done
     */
    NvReleaseSemaphore(pDriverData);
    pLockData->ddRVal = DD_OK;
    dbgTracePop();
    return dwRetVal;
}

/*****************************************************************************
 * D3DUnlockExecuteBuffer32
 *
 * D3D callback to unlock an execute, vertex or command buffer
 */
DWORD __stdcall D3DUnlockExecuteBuffer32
(
    LPDDHAL_UNLOCKDATA pUnlockData
)
{
    dbgTracePush ("D3DUnlockExecuteBuffer32");

    /*
     * get driver context
     */
    nvSetDriverDataPtrFromDDGbl (pUnlockData->lpDD);

    /*
     * extract surface
     */
    CNvObject *pNvObj = GET_PNVOBJ (pUnlockData->lpDDSurface);
    

    //bend attempts to unlock an invalid buffer after a few mode switches. FS
    switch (pNvObj ? pNvObj->getClass() : 0)
    {
        /*
         * vertex buffer
         */
        case CNvObject::NVOBJ_VERTEXBUFFER:
        {
            CVertexBuffer *pVertexBuffer = pNvObj->getVertexBuffer();

            if (!pVertexBuffer)
            {
                NvReleaseSemaphore(pDriverData);
                DPF ("D3DUnlockExecuteBuffer32: cannot unlock Vertex buffer");
                dbgD3DError();
                pUnlockData->ddRVal = DDERR_NOTFOUND;
                dbgTracePop();
                return DDHAL_DRIVER_HANDLED;
            }

            // unlock
#ifdef MCFD
            pVertexBuffer->UnlockForCPU();
#else
            pVertexBuffer->cpuUnlock();
#endif
            // update our state
            pVertexBuffer->tagD3DUnlocked();
            pVertexBuffer->tagModified();
            if (pVertexBuffer->getLockCount() > 1)
            {
                pVertexBuffer->destroySuperTriLookAsideBuffer();
                pVertexBuffer->tagDynamic();
            }

#ifdef NV_AGP
            if (pVertexBuffer->isAliasLocked()) {
                MSAdjustAliasLock(pUnlockData->lpDD, -1);
                pVertexBuffer->tagNotAliasLocked();
            }
            DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "Unlocking agp VB (%08x), fpVidMem = %08x", pVertexBuffer, pVertexBuffer->getAddress());
#endif

            // capture
#ifdef CAPTURE
            if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                CAPTURE_MEMORY_WRITE memwr;
                memwr.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                memwr.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                memwr.dwExtensionID        = CAPTURE_XID_MEMORY_WRITE;
                memwr.dwCtxDMAHandle       = (pVertexBuffer->getHeapLocation() == CSimpleSurface::HEAP_VID)
                                           ? NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY
                                           : D3D_CONTEXT_DMA_HOST_MEMORY;
                memwr.dwOffset             = pVertexBuffer->getOffset();
                memwr.dwSize               = pVertexBuffer->getSize();
                captureLog (&memwr,sizeof(memwr));
                captureLog ((void*)pVertexBuffer->getAddress(),memwr.dwSize);
            }
#endif

#if (NVARCH >= 0x020)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                nvglSetNv20KelvinInvalidateVertexCache (NV_DD_KELVIN);
            }
            else
#endif
#if (NVARCH >= 0x010)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                nvglSetNv10CelsiusInvalidateVertexCache (NV_DD_CELSIUS);
            }
#endif

            break;
        }
        /*
         * command buffer
         */
        case CNvObject::NVOBJ_COMMANDBUFFER:
        {
            CCommandBuffer *pCommandBuffer = pNvObj->getCommandBuffer();

            if (!pCommandBuffer)
            {
                NvReleaseSemaphore(pDriverData);
                DPF ("D3DUnlockExecuteBuffer32: cannot unlock command buffer");
                dbgD3DError();
                pUnlockData->ddRVal = DDERR_NOTFOUND;
                dbgTracePop();
                return DDHAL_DRIVER_HANDLED;
            }

            /*
             * unlock
             */
            pCommandBuffer->cpuUnlock();
            break;
        }
        /*
         * unknown
         */
        default:
        {
            /*
             * report error
             */
            NvReleaseSemaphore(pDriverData);
            DPF ("D3DUnlockExecuteBuffer32: unknown buffer passed in (pNvObj=%08x)",pNvObj);
            dbgD3DError();
            /*
             * fail
             */
            pUnlockData->ddRVal = DDERR_NOTFOUND;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    /*
     * done
     */
    NvReleaseSemaphore(pDriverData);
    pUnlockData->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvUtil_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvUtil_link.cpp
//      a pointer to a shared file
//
// **************************************************************************
#include "nvprecomp.h"

#include "..\..\..\common\src\nvUtil.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvVPP_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvVPP_link.cpp
//      a pointer to a shared file
//
// **************************************************************************
//
//  History:
//      Matt Lavoie          09 Sep 2000
//
// **************************************************************************
#include "nvprecomp.h"

#include "..\..\..\common\src\nvVPP.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\StereoFunc_i.cpp ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.*
*                                                                           *
* Module: StereoFunc_i.cpp                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Andrei Osnovich    02/23/00  Created                                *
*                                                                           *
\***************************************************************************/

#ifndef STEREOFUNC_GENERAL_MACROS
#define STEREOFUNC_GENERAL_MACROS
#define EQUAL       0
#define GREATER     1
#define LESS        2
#define X(pV)       (((LPD3DVALUE)pV)[0])
#define Y(pV)       (((LPD3DVALUE)pV)[1])
#define Z(pV)       (((LPD3DVALUE)pV)[2])
#define Z_I(pV)     (((DWORD *)pV)[2])
#define RHW(pV)     (((LPD3DVALUE)pV)[3])
#define RHW_I(pV)   (((DWORD *)pV)[3])
#define GET_REAL_NAME(token) #token
#endif  //STEREOFUNC_GENERAL_MACROS

#ifdef  FAN
    #define FAN_OR_STRIP
#else
#ifdef  STRIP
    #define FAN_OR_STRIP
#endif
#endif

#ifdef  INDEX2
#define INDEX
#endif  //INDEX2

#ifdef  INDEX
#ifdef  FAN_OR_STRIP
#define DEFINE_LOCALS   \
    WORD        wVertNum1; \
    LPBYTE      pVertex1;
#define FOR_ALL_VERTICES \
    for (i = 0; i < dwCount; i++, pIndices += sizeof(WORD))
#define GET_V1_POINTER \
    wVertNum1 = ((WORD *)pIndices)[0];          \
    nvAssert(wVertNum1 < pStereoData->dwVertexRegisterSize); \
    pVertex1 = &pVertices[wVertNum1*pContext->pCurrentVShader->getStride()];
#else   //FAN_OR_STRIP==0
#ifdef  LINE
#define DEFINE_LOCALS   \
    WORD        wVertNum1, wVertNum2; \
    LPBYTE      pVertex1, pVertex2;
#else   //LINE==0
#define DEFINE_LOCALS   \
    WORD        wVertNum1, wVertNum2, wVertNum3; \
    LPBYTE      pVertex1, pVertex2, pVertex3;
#endif  //LINE
#ifdef  INDEX2
#define FOR_ALL_VERTICES \
    for (i = 0; i < dwCount; i++, pIndices += sizeof(D3DHAL_DP2INDEXEDTRIANGLELIST2))
#define GET_V1_POINTER \
    wVertNum1 = ((LPD3DHAL_DP2INDEXEDTRIANGLELIST2)pIndices)->wV1;          \
    nvAssert(wVertNum1 < pStereoData->dwVertexRegisterSize); \
    pVertex1 = &pVertices[wVertNum1*pContext->pCurrentVShader->getStride()];
#define GET_V2_POINTER \
    wVertNum2 = ((LPD3DHAL_DP2INDEXEDTRIANGLELIST2)pIndices)->wV2;          \
    nvAssert(wVertNum2 < pStereoData->dwVertexRegisterSize); \
    pVertex2 = &pVertices[wVertNum2*pContext->pCurrentVShader->getStride()];
#define GET_V3_POINTER \
    wVertNum3 = ((LPD3DHAL_DP2INDEXEDTRIANGLELIST2)pIndices)->wV3;          \
    nvAssert(wVertNum3 < pStereoData->dwVertexRegisterSize); \
    pVertex3 = &pVertices[wVertNum3*pContext->pCurrentVShader->getStride()];
#else   //INDEX2==0
#ifdef  LINE
#define FOR_ALL_VERTICES \
    for (i = 0; i < dwCount; i++, pIndices += sizeof(D3DHAL_DP2INDEXEDLINELIST))
#define GET_V1_POINTER \
    wVertNum1 = ((LPD3DHAL_DP2INDEXEDLINELIST)pIndices)->wV1;           \
    nvAssert(wVertNum1 < pStereoData->dwVertexRegisterSize); \
    pVertex1 = &pVertices[wVertNum1*pContext->pCurrentVShader->getStride()];
#define GET_V2_POINTER \
    wVertNum2 = ((LPD3DHAL_DP2INDEXEDLINELIST)pIndices)->wV2;           \
    nvAssert(wVertNum2 < pStereoData->dwVertexRegisterSize); \
    pVertex2 = &pVertices[wVertNum2*pContext->pCurrentVShader->getStride()];
#else   //LINE==0
#define FOR_ALL_VERTICES \
    for (i = 0; i < dwCount; i++, pIndices += sizeof(D3DHAL_DP2INDEXEDTRIANGLELIST))
#define GET_V1_POINTER \
    wVertNum1 = ((LPD3DHAL_DP2INDEXEDTRIANGLELIST)pIndices)->wV1;           \
    nvAssert(wVertNum1 < pStereoData->dwVertexRegisterSize); \
    pVertex1 = &pVertices[wVertNum1*pContext->pCurrentVShader->getStride()];
#define GET_V2_POINTER \
    wVertNum2 = ((LPD3DHAL_DP2INDEXEDTRIANGLELIST)pIndices)->wV2;           \
    nvAssert(wVertNum2 < pStereoData->dwVertexRegisterSize); \
    pVertex2 = &pVertices[wVertNum2*pContext->pCurrentVShader->getStride()];
#define GET_V3_POINTER \
    wVertNum3 = ((LPD3DHAL_DP2INDEXEDTRIANGLELIST)pIndices)->wV3;           \
    nvAssert(wVertNum3 < pStereoData->dwVertexRegisterSize); \
    pVertex3 = &pVertices[wVertNum3*pContext->pCurrentVShader->getStride()];
#endif  //LINE
#endif  //INDEX2
#endif  //FAN_OR_STRIP
#else   //INDEX=0
#define DEFINE_LOCALS
#define FOR_ALL_VERTICES \
    for (i = 0; i < dwCount; i++, pVertices += pContext->pCurrentVShader->getStride())
#endif  //INDEX

BOOL
CHECK_RHW_CONDITION (
        PNVD3DCONTEXT pContext,
        LPBYTE pVertices,
    #ifdef INDEX
        LPBYTE pIndices,
    #endif //INDEX
        DWORD dwCount,
        DWORD dwCondition)
{
    DWORD       i;
    D3DVALUE    fRHW, fZ;
#ifdef  INDEX
    DEFINE_LOCALS;
#ifdef  FAN_OR_STRIP
    dwCount += 2;
#endif  //FAN_OR_STRIP
#else   //INDEX=0
#ifdef  FAN_OR_STRIP
#ifdef  LINE
    dwCount += 1;
#else   //LINE==0 (TRIANGLE)
    dwCount += 2;
#endif  //LINE
#else   //FAN_OR_STRIP=0
#ifndef POINT
#ifdef  LINE
    dwCount *= 2;
#else   //LINE==0 (TRIANGLE)
    dwCount *= 3;
#endif  //LINE
#endif  //POINT
#endif  //FAN_OR_STRIP
#endif  //INDEX
    switch (dwCondition)
    {
#ifdef  STEREO_CONFIG_ASSIST
    case EQUAL:
        if (pStereoData->StereoSettings.dwFlags & STEREO_FAVORSZOVERRHW)
        {
        //Check if the farthest 2D object is farther than the closest 3D object.
        //If so we need to reinitialize the farthest 2D object.
        if (ConfigAssistInfo.szMax2D > ConfigAssistInfo.szMin)
                ConfigAssistInfo.szMax2D = -9999.f;
        //Check if the closest 2D object is closer than the farthest 3D object.
        //If so we need to reinitialize the closest 2D object.
        if (ConfigAssistInfo.szMin2D < ConfigAssistInfo.szMax)
            ConfigAssistInfo.szMin2D = 9999.f;
            DWORD dwZ;
            BOOL  bForce2D;
            bForce2D = FALSE;
#ifdef  INDEX
            GET_V1_POINTER;
            dwZ = Z_I(pVertex1);
#else   //INDEX=0
            dwZ = Z_I(pVertices);
#endif  //INDEX
            if (pStereoData->StereoSettings.dwFlags & STEREO_RHWEQUALATSCREEN)
            {
#if 0
                if (*(LPD3DVALUE)&dwZ >= pStereoData->fRHW2DDetectionMin)
                    bForce2D = TRUE;
#endif
                if (*(LPD3DVALUE)&dwZ > ConfigAssistInfo.szMin
                    && *(LPD3DVALUE)&dwZ < ConfigAssistInfo.szMax) //This object is inside the 3D object range.
                    bForce2D = TRUE;
            } else
            {
#if 0
                if (*(LPD3DVALUE)&dwZ >= pStereoData->fRHW2DDetectionMin)
                    return FALSE;
#endif
                if (*(LPD3DVALUE)&dwZ > ConfigAssistInfo.szMin
                    && *(LPD3DVALUE)&dwZ < ConfigAssistInfo.szMax) //This object is inside the 3D object range.
                    return FALSE;
            }
            FOR_ALL_VERTICES {
#ifdef  INDEX
                GET_V1_POINTER;
                if (Z_I(pVertex1) != dwZ)
                    return FALSE;
#ifndef FAN_OR_STRIP
                GET_V2_POINTER;
                if (Z_I(pVertex2) != dwZ)
                    return FALSE;
#ifndef LINE
                GET_V3_POINTER;
                if (Z_I(pVertex3) != dwZ)
                    return FALSE;
#endif  //LINE
#endif  //FAN_OR_STRIP
#else   //INDEX=0
                if (Z_I(pVertices) != dwZ)
                    return FALSE;
#endif  //INDEX
            }
            if (!bForce2D)
            {
                if (ConfigAssistInfo.szMin > *(LPD3DVALUE)&dwZ)
                {
                    //Closer than all 3D
                    if (ConfigAssistInfo.szMax2D < *(LPD3DVALUE)&dwZ)
                        ConfigAssistInfo.szMax2D = *(LPD3DVALUE)&dwZ;
                } else
                {
                    //Farther than all 3D
                    if (ConfigAssistInfo.szMin2D > *(LPD3DVALUE)&dwZ)
                        ConfigAssistInfo.szMin2D = *(LPD3DVALUE)&dwZ;
                }
            }
#ifdef  FLAT_STAT
            RegisterFlatObject(*(LPD3DVALUE)&dwZ, dwCount);
#endif  //FLAT_STAT
            return TRUE;
        }
        //Check if the farthest 2D object is farther than the closest 3D object.
        //If so we need to reinitialize the farthest 2D object.
        if (ConfigAssistInfo.rhwMin2D < ConfigAssistInfo.rhwMax)
            ConfigAssistInfo.rhwMin2D = 9999.f;
        //Check if the closest 2D object is closer than the farthest 3D object.
        //If so we need to reinitialize the closest 2D object.
        if (ConfigAssistInfo.rhwMax2D > ConfigAssistInfo.rhwMin)
            ConfigAssistInfo.rhwMax2D = -9999.f;
        DWORD dwRHW;
        BOOL  bForce2D;
        bForce2D = FALSE;
#ifdef  INDEX
        GET_V1_POINTER;
        dwRHW = RHW_I(pVertex1);
#else   //INDEX=0
        dwRHW = RHW_I(pVertices);
#endif  //INDEX
        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWEQUALATSCREEN)
        {
            if (*(LPD3DVALUE)&dwRHW <= pStereoData->fRHW2DDetectionMin)
                bForce2D = TRUE;
            if (*(LPD3DVALUE)&dwRHW < ConfigAssistInfo.rhwMax
                && *(LPD3DVALUE)&dwRHW > ConfigAssistInfo.rhwMin) //This object is inside the 3D object range.
                bForce2D = TRUE;
        } else
        {
            if (*(LPD3DVALUE)&dwRHW <= pStereoData->fRHW2DDetectionMin)
                return FALSE;
            if (*(LPD3DVALUE)&dwRHW < ConfigAssistInfo.rhwMax
                && *(LPD3DVALUE)&dwRHW > ConfigAssistInfo.rhwMin) //This object is inside the 3D object range.
                return FALSE;
        }
        FOR_ALL_VERTICES {
#ifdef  INDEX
            GET_V1_POINTER;
            if (RHW_I(pVertex1) != dwRHW)
                return FALSE;
#ifndef FAN_OR_STRIP
            GET_V2_POINTER;
            if (RHW_I(pVertex2) != dwRHW)
                return FALSE;
#ifndef LINE
            GET_V3_POINTER;
            if (RHW_I(pVertex3) != dwRHW)
                return FALSE;
#endif  //LINE
#endif  //FAN_OR_STRIP
#else   //INDEX=0
            if (RHW_I(pVertices) != dwRHW)
                return FALSE;
#endif  //INDEX
        }
        if (!bForce2D)
        {
            if (ConfigAssistInfo.rhwMax < *(LPD3DVALUE)&dwRHW)
            {
                //Closer than all 3D
                if (ConfigAssistInfo.rhwMin2D > *(LPD3DVALUE)&dwRHW)
                    ConfigAssistInfo.rhwMin2D = *(LPD3DVALUE)&dwRHW;
            } else
            {
                //Farther than all 3D
                if (ConfigAssistInfo.rhwMax2D < *(LPD3DVALUE)&dwRHW)
                    ConfigAssistInfo.rhwMax2D = *(LPD3DVALUE)&dwRHW;
            }
        }
#ifdef  FLAT_STAT
        RegisterFlatObject(*(LPD3DVALUE)&dwRHW, dwCount);
#endif  //FLAT_STAT
        return TRUE;
#endif  //STEREO_CONFIG_ASSIST

    case GREATER:
        if (pStereoData->StereoSettings.dwFlags & STEREO_FAVORSZOVERRHW)
        {
            fZ = pStereoData->StereoSettings.fRHWGreaterAtScreen;
            FOR_ALL_VERTICES {
#ifdef  INDEX
                GET_V1_POINTER;
                if (Z(pVertex1) > fZ)
                    return FALSE;
#ifndef FAN_OR_STRIP
                GET_V2_POINTER;
                if (Z(pVertex2) > fZ)
                    return FALSE;
#ifndef LINE
                GET_V3_POINTER;
                if (Z(pVertex3) > fZ)
                    return FALSE;
#endif  //LINE
#endif  //FAN_OR_STRIP
#else   //INDEX=0
                if (Z(pVertices) > fZ)
                    return FALSE;
#endif  //INDEX
            }
            return TRUE;
        }
        fRHW = pStereoData->StereoSettings.fRHWGreaterAtScreen;
        FOR_ALL_VERTICES {
#ifdef  INDEX
            GET_V1_POINTER;
            if (RHW(pVertex1) < fRHW)
                return FALSE;
#ifndef FAN_OR_STRIP
            GET_V2_POINTER;
            if (RHW(pVertex2) < fRHW)
                return FALSE;
#ifndef LINE
            GET_V3_POINTER;
            if (RHW(pVertex3) < fRHW)
                return FALSE;
#endif  //LINE
#endif  //FAN_OR_STRIP
#else   //INDEX=0
            if (RHW(pVertices) < fRHW)
                return FALSE;
#endif  //INDEX
        }
        return TRUE;

    case LESS:
        if (pStereoData->StereoSettings.dwFlags & STEREO_FAVORSZOVERRHW)
        {
            fZ = pStereoData->StereoSettings.fRHWLessAtScreen;
            FOR_ALL_VERTICES {
#ifdef  INDEX
                GET_V1_POINTER;
                if (Z(pVertex1) < fZ)
                    return FALSE;
#ifndef FAN_OR_STRIP
                GET_V2_POINTER;
                if (Z(pVertex2) < fZ)
                    return FALSE;
#ifndef LINE
                GET_V3_POINTER;
                if (Z(pVertex3) < fZ)
                    return FALSE;
#endif  //LINE
#endif  //FAN_OR_STRIP
#else   //INDEX=0
                if (Z(pVertices) < fZ)
                    return FALSE;
#endif  //INDEX
            }
            return TRUE;
        }
        //Some games like Triple Play 2001 put pop up 2D menus as
        //farthest objects in the scene. Stupid but we have to handle it.
        fRHW = pStereoData->StereoSettings.fRHWLessAtScreen;
        FOR_ALL_VERTICES {
#ifdef  INDEX
            GET_V1_POINTER;
            if (RHW(pVertex1) > fRHW)
                return FALSE;
#ifndef FAN_OR_STRIP
            GET_V2_POINTER;
            if (RHW(pVertex2) > fRHW)
                return FALSE;
#ifndef LINE
            GET_V3_POINTER;
            if (RHW(pVertex3) > fRHW)
                return FALSE;
#endif  //LINE
#endif  //FAN_OR_STRIP
#else   //INDEX=0
            if (RHW(pVertices) > fRHW)
                return FALSE;
#endif  //INDEX
        }
        return TRUE;

    default:
        LOG("%s: unsupported case", GET_REAL_NAME(CHECK_RHW_CONDITION) );
		nvAssert(0);
        break;
    }
    return FALSE;
}

DWORD
STEREO_EYE_FUNCTION_FLIP (
        PNVD3DCONTEXT pContext,
        LPBYTE pVertices,
    #ifdef INDEX
        LPBYTE pIndices,
    #endif //INDEX
        DWORD dwCount)
{
    DWORD       i;
    DWORD       res = 0;
    D3DVALUE    XCorrection;
    DEFINE_LOCALS;

    nvAssert(pStereoData->pVertexRegister);
    if (pStereoData->pVertexRegister->DoAutomaticStage_Flip())
    {
        //Everything has been done automatically.
        return 0;
    }
    //We're required to fill out the stage for the first eye.
#ifdef  INDEX
    pStereoData->pVertexRegister->cleanupInUse();
#ifdef  FAN_OR_STRIP
    dwCount += 2;
#endif  //FAN_OR_STRIP
#else   //INDEX=0
#ifdef  FAN_OR_STRIP
#ifdef  LINE
    dwCount += 1;
#else   //LINE==0 (TRIANGLE)
    dwCount += 2;
#endif  //LINE
#else   //FAN_OR_STRIP=0
#ifndef POINT
#ifdef  LINE
    dwCount *= 2;
#else   //LINE==0 (TRIANGLE)
    dwCount *= 3;
#endif  //LINE
#endif  //POINT
#endif  //FAN_OR_STRIP
#endif  //INDEX

    if (pStereoData->dwLastEye == EYE_LEFT)
    {
        //We're doing the left eye first
        FOR_ALL_VERTICES {
#ifdef  INDEX
            GET_V1_POINTER;
            if (!pStereoData->pVertexRegister->isInUseTag(wVertNum1))
            {
                //Unique vertex.
                pStereoData->pVertexRegister->SaveX((LPD3DVALUE)pVertex1);
                XCorrection = pStereoData->StereoSettings.fScreenStereoSeparation*(1.0f - RHW(pVertex1)*pStereoData->StereoSettings.fPostStereoConvergence);
                pStereoData->pVertexRegister->SaveXCorrection_Flip(XCorrection);
                X(pVertex1) = X(pVertex1) * pStereoData->StereoSettings.fPostStereoXStretch - pStereoData->StereoSettings.fPostStereoXShift - XCorrection;
#ifdef  STEREO_CONFIG_ASSIST
                if (!(ConfigAssistInfo.dwFlags & _2DSUSPECT))
                {
#endif  //STEREO_CONFIG_ASSIST
                    if (pStereoData->fFrameRHWMax < RHW(pVertex1))
                        pStereoData->fFrameRHWMax = RHW(pVertex1);
#ifdef  STEREO_CONFIG_ASSIST
                    if (ConfigAssistInfo.rhwMin > RHW(pVertex1))
                        ConfigAssistInfo.rhwMin = RHW(pVertex1);
                    if (ConfigAssistInfo.szMin > Z(pVertex1))
                        ConfigAssistInfo.szMin = Z(pVertex1);
                    if (ConfigAssistInfo.szMax < Z(pVertex1))
                        ConfigAssistInfo.szMax = Z(pVertex1);
                }
#endif  //STEREO_CONFIG_ASSIST
            }
#ifndef FAN_OR_STRIP
            GET_V2_POINTER;
            if (!pStereoData->pVertexRegister->isInUseTag(wVertNum2))
            {
                //Unique vertex.
                pStereoData->pVertexRegister->SaveX((LPD3DVALUE)pVertex2);
                XCorrection = pStereoData->StereoSettings.fScreenStereoSeparation*(1.0f - RHW(pVertex2)*pStereoData->StereoSettings.fPostStereoConvergence);
                pStereoData->pVertexRegister->SaveXCorrection_Flip(XCorrection);
                X(pVertex2) = X(pVertex2) * pStereoData->StereoSettings.fPostStereoXStretch - pStereoData->StereoSettings.fPostStereoXShift - XCorrection;
#ifdef  STEREO_CONFIG_ASSIST
                if (!(ConfigAssistInfo.dwFlags & _2DSUSPECT))
                {
#endif  //STEREO_CONFIG_ASSIST
                    if (pStereoData->fFrameRHWMax < RHW(pVertex2))
                        pStereoData->fFrameRHWMax = RHW(pVertex2);
#ifdef  STEREO_CONFIG_ASSIST
                    if (ConfigAssistInfo.rhwMin > RHW(pVertex2))
                        ConfigAssistInfo.rhwMin = RHW(pVertex2);
                    if (ConfigAssistInfo.szMin > Z(pVertex2))
                        ConfigAssistInfo.szMin = Z(pVertex2);
                    if (ConfigAssistInfo.szMax < Z(pVertex2))
                        ConfigAssistInfo.szMax = Z(pVertex2);
                }
#endif  //STEREO_CONFIG_ASSIST
            }
#ifndef LINE
            GET_V3_POINTER;
            if (!pStereoData->pVertexRegister->isInUseTag(wVertNum3))
            {
                //Unique vertex.
                pStereoData->pVertexRegister->SaveX((LPD3DVALUE)pVertex3);
                XCorrection = pStereoData->StereoSettings.fScreenStereoSeparation*(1.0f - RHW(pVertex3)*pStereoData->StereoSettings.fPostStereoConvergence);
                pStereoData->pVertexRegister->SaveXCorrection_Flip(XCorrection);
                X(pVertex3) = X(pVertex3) * pStereoData->StereoSettings.fPostStereoXStretch - pStereoData->StereoSettings.fPostStereoXShift - XCorrection;
#ifdef  STEREO_CONFIG_ASSIST
                if (!(ConfigAssistInfo.dwFlags & _2DSUSPECT))
                {
#endif  //STEREO_CONFIG_ASSIST
                    if (pStereoData->fFrameRHWMax < RHW(pVertex3))
                        pStereoData->fFrameRHWMax = RHW(pVertex3);
#ifdef  STEREO_CONFIG_ASSIST
                    if (ConfigAssistInfo.rhwMin > RHW(pVertex3))
                        ConfigAssistInfo.rhwMin = RHW(pVertex3);
                    if (ConfigAssistInfo.szMin > Z(pVertex3))
                        ConfigAssistInfo.szMin = Z(pVertex3);
                    if (ConfigAssistInfo.szMax < Z(pVertex3))
                        ConfigAssistInfo.szMax = Z(pVertex3);
                }
#endif  //STEREO_CONFIG_ASSIST
            }
#endif  //LINE
#endif  //FAN_OR_STRIP
#else   //INDEX=0
            pStereoData->pVertexRegister->SaveX((LPD3DVALUE)pVertices);
            XCorrection = pStereoData->StereoSettings.fScreenStereoSeparation*(1.0f - RHW(pVertices)*pStereoData->StereoSettings.fPostStereoConvergence);
            pStereoData->pVertexRegister->SaveXCorrection_Flip(XCorrection);
            X(pVertices) = X(pVertices) * pStereoData->StereoSettings.fPostStereoXStretch - pStereoData->StereoSettings.fPostStereoXShift - XCorrection;
#ifdef  STEREO_CONFIG_ASSIST
            if (!(ConfigAssistInfo.dwFlags & _2DSUSPECT))
            {
#endif  //STEREO_CONFIG_ASSIST
                if (pStereoData->fFrameRHWMax < RHW(pVertices))
                    pStereoData->fFrameRHWMax = RHW(pVertices);
#ifdef  STEREO_CONFIG_ASSIST
                if (ConfigAssistInfo.rhwMin > RHW(pVertices))
                    ConfigAssistInfo.rhwMin = RHW(pVertices);
                if (ConfigAssistInfo.szMin > Z(pVertices))
                    ConfigAssistInfo.szMin = Z(pVertices);
                if (ConfigAssistInfo.szMax < Z(pVertices))
                    ConfigAssistInfo.szMax = Z(pVertices);
            }
#endif  //STEREO_CONFIG_ASSIST
#endif  //INDEX
        }
    } else
    {
        //We're doing the right eye first
        FOR_ALL_VERTICES {
#ifdef  INDEX
            GET_V1_POINTER;
            if (!pStereoData->pVertexRegister->isInUseTag(wVertNum1))
            {
                //Unique vertex.
                pStereoData->pVertexRegister->SaveX((LPD3DVALUE)pVertex1);
                XCorrection = pStereoData->StereoSettings.fScreenStereoSeparation*(1.0f - RHW(pVertex1)*pStereoData->StereoSettings.fPostStereoConvergence);
                pStereoData->pVertexRegister->SaveXCorrection_Flip(XCorrection);
                X(pVertex1) = X(pVertex1) * pStereoData->StereoSettings.fPostStereoXStretch - pStereoData->StereoSettings.fPostStereoXShift + XCorrection;
#ifdef  STEREO_CONFIG_ASSIST
                if (!(ConfigAssistInfo.dwFlags & _2DSUSPECT))
                {
#endif  //STEREO_CONFIG_ASSIST
                    if (pStereoData->fFrameRHWMax < RHW(pVertex1))
                        pStereoData->fFrameRHWMax = RHW(pVertex1);
#ifdef  STEREO_CONFIG_ASSIST
                    if (ConfigAssistInfo.rhwMin > RHW(pVertex1))
                        ConfigAssistInfo.rhwMin = RHW(pVertex1);
                    if (ConfigAssistInfo.szMin > Z(pVertex1))
                        ConfigAssistInfo.szMin = Z(pVertex1);
                    if (ConfigAssistInfo.szMax < Z(pVertex1))
                        ConfigAssistInfo.szMax = Z(pVertex1);
                }
#endif  //STEREO_CONFIG_ASSIST
            }
#ifndef FAN_OR_STRIP
            GET_V2_POINTER;
            if (!pStereoData->pVertexRegister->isInUseTag(wVertNum2))
            {
                //Unique vertex.
                pStereoData->pVertexRegister->SaveX((LPD3DVALUE)pVertex2);
                XCorrection = pStereoData->StereoSettings.fScreenStereoSeparation*(1.0f - RHW(pVertex2)*pStereoData->StereoSettings.fPostStereoConvergence);
                pStereoData->pVertexRegister->SaveXCorrection_Flip(XCorrection);
                X(pVertex2) = X(pVertex2) * pStereoData->StereoSettings.fPostStereoXStretch - pStereoData->StereoSettings.fPostStereoXShift + XCorrection;
#ifdef  STEREO_CONFIG_ASSIST
                if (!(ConfigAssistInfo.dwFlags & _2DSUSPECT))
                {
#endif  //STEREO_CONFIG_ASSIST
                    if (pStereoData->fFrameRHWMax < RHW(pVertex2))
                        pStereoData->fFrameRHWMax = RHW(pVertex2);
#ifdef  STEREO_CONFIG_ASSIST
                    if (ConfigAssistInfo.rhwMin > RHW(pVertex2))
                        ConfigAssistInfo.rhwMin = RHW(pVertex2);
                    if (ConfigAssistInfo.szMin > Z(pVertex2))
                        ConfigAssistInfo.szMin = Z(pVertex2);
                    if (ConfigAssistInfo.szMax < Z(pVertex2))
                        ConfigAssistInfo.szMax = Z(pVertex2);
                }
#endif  //STEREO_CONFIG_ASSIST
            }
#ifndef LINE
            GET_V3_POINTER;
            if (!pStereoData->pVertexRegister->isInUseTag(wVertNum3))
            {
                //Unique vertex.
                pStereoData->pVertexRegister->SaveX((LPD3DVALUE)pVertex3);
                XCorrection = pStereoData->StereoSettings.fScreenStereoSeparation*(1.0f - RHW(pVertex3)*pStereoData->StereoSettings.fPostStereoConvergence);
                pStereoData->pVertexRegister->SaveXCorrection_Flip(XCorrection);
                X(pVertex3) = X(pVertex3) * pStereoData->StereoSettings.fPostStereoXStretch - pStereoData->StereoSettings.fPostStereoXShift + XCorrection;
#ifdef  STEREO_CONFIG_ASSIST
                if (!(ConfigAssistInfo.dwFlags & _2DSUSPECT))
                {
#endif  //STEREO_CONFIG_ASSIST
                    if (pStereoData->fFrameRHWMax < RHW(pVertex3))
                        pStereoData->fFrameRHWMax = RHW(pVertex3);
#ifdef  STEREO_CONFIG_ASSIST
                    if (ConfigAssistInfo.rhwMin > RHW(pVertex3))
                        ConfigAssistInfo.rhwMin = RHW(pVertex3);
                    if (ConfigAssistInfo.szMin > Z(pVertex3))
                        ConfigAssistInfo.szMin = Z(pVertex3);
                    if (ConfigAssistInfo.szMax < Z(pVertex3))
                        ConfigAssistInfo.szMax = Z(pVertex3);
                }
#endif  //STEREO_CONFIG_ASSIST
            }
#endif  //LINE
#endif  //FAN_OR_STRIP
#else   //INDEX=0
            pStereoData->pVertexRegister->SaveX((LPD3DVALUE)pVertices);
            XCorrection = pStereoData->StereoSettings.fScreenStereoSeparation*(1.0f - RHW(pVertices)*pStereoData->StereoSettings.fPostStereoConvergence);
            pStereoData->pVertexRegister->SaveXCorrection_Flip(XCorrection);
            X(pVertices) = X(pVertices) * pStereoData->StereoSettings.fPostStereoXStretch - pStereoData->StereoSettings.fPostStereoXShift + XCorrection;
#ifdef  STEREO_CONFIG_ASSIST
            if (!(ConfigAssistInfo.dwFlags & _2DSUSPECT))
            {
#endif  //STEREO_CONFIG_ASSIST
                if (pStereoData->fFrameRHWMax < RHW(pVertices))
                    pStereoData->fFrameRHWMax = RHW(pVertices);
#ifdef  STEREO_CONFIG_ASSIST
                if (ConfigAssistInfo.rhwMin > RHW(pVertices))
                    ConfigAssistInfo.rhwMin = RHW(pVertices);
                if (ConfigAssistInfo.szMin > Z(pVertices))
                    ConfigAssistInfo.szMin = Z(pVertices);
                if (ConfigAssistInfo.szMax < Z(pVertices))
                    ConfigAssistInfo.szMax = Z(pVertices);
            }
#endif  //STEREO_CONFIG_ASSIST
#endif  //INDEX
        }
    }
    return res;
}

#ifndef	DRAWPRIMITIVE
#ifndef POINT
HRESULT STEREO_DP2_FUNCTION_FLIP (NV_DP2FUNCTION_ARGLIST)
{
    HRESULT             RetVal;
    DWORD               dwDP2Op = (DWORD)((*ppCommands)->bCommand);
    LPD3DHAL_DP2COMMAND pSaveCommandsPtr = *ppCommands;

#ifdef	STEREO_DEBUG
	//Make sure it is not a rendering to a texture
	CNvObject *pNvObj = pContext->pRenderTarget->getWrapper();
	if (pNvObj->getClass() == CNvObject::NVOBJ_TEXTURE)
		__asm int 3
	//Make sure we render to a stereo surface
	if (pContext->pRenderTarget->isStereo() == 0)
		__asm int 3
	//Do we render to the Z buffer?
	if (pContext->pRenderTarget->isZBuffer())
		__asm int 3
#endif	//STEREO_DEBUG

    StereoLockSubstituteFlush();

    // First thing to determine is whether we take a HW T&L or SW T&L route. It breaks
    // down all our code into two vertually mutually exclusive cases. It is better to keep 
    // it this way for optimal performance
    if (!STEREO_R_US(pContext))
    {
        RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                                  ppCommands,
                                                  pCommandBufferEnd,
                                                  pdwDP2RStates,
                                                  dwDP2Flags);
        return RetVal;
    }
    if (pStereoData->dwHWTnL)
    {
        //This case is going to be the most frequently used in future. We want it fast.
        SetupStereoContext(pContext);
        RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                                  ppCommands,
                                                  pCommandBufferEnd,
                                                  pdwDP2RStates,
                                                  dwDP2Flags);
        *ppCommands = pSaveCommandsPtr; //Restore it for the second pass.
        AlternateStereoContext(pContext);
        RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                                  ppCommands,
                                                  pCommandBufferEnd,
                                                  pdwDP2RStates,
                                                  dwDP2Flags);
        return RetVal;
    }
    
    // And now is SW T&L or HW T&L with transformed vertices
    LPBYTE pVertexBufferBase = (LPBYTE)(pContext->ppDX8Streams[0]->getAddress());

#ifdef  PARTIALRENDERING
    if (PrimitiveStat[4] == PrimitiveStat[1])
       nvAssert(0);
#endif  //PARTIALRENDERING

#ifdef  NOT_IMPLEMENTED
    //LOG("%s: not implemented yet",GET_REAL_NAME( STEREO_DP2_FUNCTION_FLIP ));
    nvAssert (0);
    return ((*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                             ppCommands,
                                             pCommandBufferEnd,
                                             pdwDP2RStates,
                                             dwDP2Flags));
#else   //~NOT_IMPLEMENTED
    //nvAssert (0);
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
#ifdef  INDEX
#ifdef  START_VERTEX
    DWORD dwVertexBufferOffset = pContext->dp2.dwVertexBufferOffset;
    DWORD  dwTotalOffset = dwVertexBufferOffset + ((DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwVStart = (DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = dwTotalOffset;
    LPBYTE pVertices     = (LPBYTE)(pVertexBufferBase+dwTotalOffset);
    LPBYTE pIndices      = lpPrim + sizeof(D3DHAL_DP2STARTVERTEX);
#else   //START_VERTEX==0
    DWORD dwVertexBufferOffset = pContext->dp2.dwVertexBufferOffset;
    pContext->dp2.dwVStart = 0;
    pContext->dp2.dwTotalOffset = dwVertexBufferOffset;
    LPBYTE pVertices     = (LPBYTE)(pVertexBufferBase+dwVertexBufferOffset);
    LPBYTE pIndices      = lpPrim;
#endif  //START_VERTEX
    PSTEREOEYEFUNCINDEX pStereoEyeFunc = NULL;
#else   //INDEX==0
#ifdef  FAN_OR_STRIP
#ifdef  START_VERTEX
    DWORD dwVertexBufferOffset = pContext->dp2.dwVertexBufferOffset;
    DWORD  dwTotalOffset = dwVertexBufferOffset + ((DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwVStart = (DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = dwTotalOffset;
    LPBYTE pVertices     = (LPBYTE)(pVertexBufferBase+dwTotalOffset);
#else   //START_VERTEX==0
    LPBYTE pVertices     = lpPrim;
    pContext->dp2.dwVStart = 0;
    pContext->dp2.dwTotalOffset = 0;
#endif  //START_VERTEX
#ifdef  ADVANCE
    pVertices += sizeof(ADVANCE);
#endif  //ADVANCE
#ifdef  ALIGN
    pVertices = (LPBYTE)(((DWORD)pVertices + 3) & ~3);
#endif  //ALIGN
#else   //FAN_OR_STRIP==0
    DWORD dwVertexBufferOffset = pContext->dp2.dwVertexBufferOffset;
    DWORD  dwTotalOffset = dwVertexBufferOffset + ((DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwVStart = (DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = dwTotalOffset;
    LPBYTE pVertices     = (LPBYTE)(pVertexBufferBase+dwTotalOffset);
#endif  //FAN_OR_STRIP==0
    PSTEREOEYEFUNC      pStereoEyeFunc = NULL;
#endif  //INDEX

#ifdef  STEREO_CONFIG_ASSIST
    ConfigAssistInfo.dwFlags &= ~_2DSUSPECT;
#endif  //STEREO_CONFIG_ASSIST

    SetupStereoContext(pContext);
    if (NV_VERTEX_TRANSFORMED(pContext->pCurrentVShader))
    {
        pStereoEyeFunc = STEREO_EYE_FUNCTION_FLIP;
#ifdef  INDEX
#ifdef  STEREO_CONFIG_ASSIST
#if 1
        if (CHECK_RHW_CONDITION (pContext, pVertices, pIndices, (DWORD)wCommandCount, EQUAL))
            ConfigAssistInfo.dwFlags |= _2DSUSPECT;
#else
        if (CHECK_RHW_CONDITION (pVertices, pIndices, (DWORD)wCommandCount, EQUAL))
            pStereoEyeFunc = NULL;
#endif
#endif  //STEREO_CONFIG_ASSIST
        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN)
        {
            if (CHECK_RHW_CONDITION (pContext, pVertices, pIndices, (DWORD)wCommandCount, GREATER))
                pStereoEyeFunc = NULL;
        }
        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN)
        {
            if (CHECK_RHW_CONDITION (pContext, pVertices, pIndices, (DWORD)wCommandCount, LESS))
                pStereoEyeFunc = NULL;
        }
        if (pStereoEyeFunc)
		{
#ifdef	STEREO_DEBUG
			//Make sure vertices are in the system memory. Otherwise it is going to be sooo slow.
			CVertexBuffer      *pVertexBuffer = pContext->ppDX8Streams[0];
			if (pVertexBuffer && pVertexBuffer->getHeapLocation() != CSimpleSurface::HEAP_SYS)
				__asm int 3
#endif	//STEREO_DEBUG
            (*pStereoEyeFunc)(pContext, pVertices, pIndices, (DWORD)wCommandCount);
		}
#else   //INDEX==0
#ifdef  STEREO_CONFIG_ASSIST
#if 1
        if (CHECK_RHW_CONDITION (pContext, pVertices, (DWORD)wCommandCount, EQUAL))
            ConfigAssistInfo.dwFlags |= _2DSUSPECT;
#else
        if (CHECK_RHW_CONDITION (pContext, pVertices, (DWORD)wCommandCount, EQUAL))
            pStereoEyeFunc = NULL;
#endif
#endif  //STEREO_CONFIG_ASSIST
        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN)
        {
            if (CHECK_RHW_CONDITION (pContext, pVertices, (DWORD)wCommandCount, GREATER))
                pStereoEyeFunc = NULL;
        }
        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN)
        {
            if (CHECK_RHW_CONDITION (pContext, pVertices, (DWORD)wCommandCount, LESS))
                pStereoEyeFunc = NULL;
        }
        if (pStereoEyeFunc)
            (*pStereoEyeFunc)(pContext, pVertices, (DWORD)wCommandCount);
#endif  //INDEX
    }
    RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                              ppCommands,
                                              pCommandBufferEnd,
                                              pdwDP2RStates,
                                              dwDP2Flags);
#ifdef  PER_PRIMITIVE_SYNC
    StereoSync();
#endif  //PER_PRIMITIVE_SYNC

#ifdef  PARTIALRENDERING
    PrimitiveStat[1]++;
    if (PrimitiveStat[2] > PrimitiveStat[1] || PrimitiveStat[3] < PrimitiveStat[1])
    {
        if (pStereoEyeFunc)
        {
#ifdef  INDEX
            (*pStereoEyeFunc)(pContext, pVertices, pIndices, (DWORD)wCommandCount);
            (*pStereoEyeFunc)(pContext, pVertices, pIndices, (DWORD)wCommandCount);
#else   //INDEX==0
            (*pStereoEyeFunc)(pContext, pVertices, (DWORD)wCommandCount);
            (*pStereoEyeFunc)(pContext, pVertices, (DWORD)wCommandCount);
#endif  //INDEX
        }
        return RetVal;
    }
#endif  //PARTIALRENDERING

#ifndef ONE_EYE
    AlternateStereoContext(pContext);
#endif  //ONE_EYE

    if (pStereoEyeFunc)
    {
#ifdef  INDEX
        (*pStereoEyeFunc)(pContext, pVertices, pIndices, (DWORD)wCommandCount);
#else   //INDEX==0
        (*pStereoEyeFunc)(pContext, pVertices, (DWORD)wCommandCount);
#endif  //INDEX
    }

#ifndef NULL_RIGHT_EYE
    *ppCommands = pSaveCommandsPtr; //Restore it for the second pass.
    RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                              ppCommands,
                                              pCommandBufferEnd,
                                              pdwDP2RStates,
                                              dwDP2Flags);
#ifdef  PER_PRIMITIVE_SYNC
    StereoSync();
#endif  //PER_PRIMITIVE_SYNC
#endif  //NULL_RIGHT_EYE

    if (pStereoEyeFunc)
    {
#ifdef  INDEX
        (*pStereoEyeFunc)(pContext, pVertices, pIndices, (DWORD)wCommandCount);
#else   //INDEX==0
        (*pStereoEyeFunc)(pContext, pVertices, (DWORD)wCommandCount);
#endif  //INDEX
    }
    return RetVal;
#endif  //~NOT_IMPLEMENTED
}

#else   //POINT=1
HRESULT STEREO_DP2_FUNCTION_FLIP (NV_DP2FUNCTION_ARGLIST)
{
    HRESULT             RetVal;
    DWORD               dwDP2Op = (DWORD)((*ppCommands)->bCommand);
    LPD3DHAL_DP2COMMAND pSaveCommandsPtr = *ppCommands;

    StereoLockSubstituteFlush();

    // First thing to determine is whether we take a HW T&L or SW T&L route. It breaks
    // down all our code into two vertually mutually exclusive cases. It is better to keep 
    // it this way for optimal performance
    if (!STEREO_R_US(pContext))
    {
        RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                                  ppCommands,
                                                  pCommandBufferEnd,
                                                  pdwDP2RStates,
                                                  dwDP2Flags);
        return RetVal;
    }
    if (pStereoData->dwHWTnL)
    {
        //This case is going to be the most frequently used in future. We want it fast.
        SetupStereoContext(pContext);
        RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                                  ppCommands,
                                                  pCommandBufferEnd,
                                                  pdwDP2RStates,
                                                  dwDP2Flags);
        *ppCommands = pSaveCommandsPtr; //Restore it for the second pass.
        AlternateStereoContext(pContext);
        RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                                  ppCommands,
                                                  pCommandBufferEnd,
                                                  pdwDP2RStates,
                                                  dwDP2Flags);
        return RetVal;
    }
    
#ifdef  NOT_IMPLEMENTED
    //LOG("%s: not implemented yet",GET_REAL_NAME( STEREO_DP2_FUNCTION_FLIP ));
	nvAssert (0);
    return ((*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                             ppCommands,
                                             pCommandBufferEnd,
                                             pdwDP2RStates,
                                             dwDP2Flags));
#else   //~NOT_IMPLEMENTED
    // And now is SW T&L or HW T&L with transformed vertices
    LPBYTE pVertexBufferBase = (LPBYTE)(pContext->ppDX8Streams[0]->getAddress());
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    DWORD dwVertexBufferOffset = pContext->dp2.dwVertexBufferOffset;
    DWORD  dwTotalOffset = dwVertexBufferOffset + ((DWORD)((LPD3DHAL_DP2POINTS)lpPrim)->wVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwVStart = (DWORD)((LPD3DHAL_DP2POINTS)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = dwTotalOffset;
    LPBYTE pVertices     = (LPBYTE)(pVertexBufferBase+dwTotalOffset);
    PSTEREOEYEFUNC      pStereoEyeFunc = NULL;
    nvAssert (wCommandCount == 1); //Haven't implemented more than 1 yet. What a shame!
    wCommandCount = ((LPD3DHAL_DP2POINTS)lpPrim)->wCount;
#ifdef  STEREO_CONFIG_ASSIST
    ConfigAssistInfo.dwFlags &= ~_2DSUSPECT;
#endif  //STEREO_CONFIG_ASSIST

    SetupStereoContext(pContext);
    if (NV_VERTEX_TRANSFORMED(pContext->pCurrentVShader))
    {
        pStereoEyeFunc = STEREO_EYE_FUNCTION_FLIP;
#ifdef  STEREO_CONFIG_ASSIST
#if 1
        if (CHECK_RHW_CONDITION (pContext, pVertices, (DWORD)wCommandCount, EQUAL))
            ConfigAssistInfo.dwFlags |= _2DSUSPECT;
#else
        if (CHECK_RHW_CONDITION (pContext, pVertices, (DWORD)wCommandCount, EQUAL))
            pStereoEyeFunc = NULL;
#endif
#endif  //STEREO_CONFIG_ASSIST
        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN)
        {
            if (CHECK_RHW_CONDITION (pContext, pVertices, (DWORD)wCommandCount, GREATER))
                pStereoEyeFunc = NULL;
        }
        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN)
        {
            if (CHECK_RHW_CONDITION (pContext, pVertices, (DWORD)wCommandCount, LESS))
                pStereoEyeFunc = NULL;
        }
        if (pStereoEyeFunc)
            (*pStereoEyeFunc)(pContext, pVertices, (DWORD)wCommandCount);
    }
    RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                              ppCommands,
                                              pCommandBufferEnd,
                                              pdwDP2RStates,
                                              dwDP2Flags);
#ifdef  PER_PRIMITIVE_SYNC
    StereoSync();
#endif  //PER_PRIMITIVE_SYNC

#ifndef ONE_EYE
    AlternateStereoContext(pContext);
#endif  //ONE_EYE

    if (pStereoEyeFunc)
    {
        (*pStereoEyeFunc)(pContext, pVertices, (DWORD)wCommandCount);
    }

#ifndef NULL_RIGHT_EYE
    *ppCommands = pSaveCommandsPtr; //Restore it for the second pass.
    RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                              ppCommands,
                                              pCommandBufferEnd,
                                              pdwDP2RStates,
                                              dwDP2Flags);
#ifdef  PER_PRIMITIVE_SYNC
    StereoSync();
#endif  //PER_PRIMITIVE_SYNC
#endif  //NULL_RIGHT_EYE

    if (pStereoEyeFunc)
    {
        (*pStereoEyeFunc)(pContext, pVertices, (DWORD)wCommandCount);
    }
    return RetVal;
#endif  //~NOT_IMPLEMENTED
}

#endif  //POINT

#else	//DRAWPRIMITIVE
HRESULT STEREO_DP2_FUNCTION_FLIP (NV_DP2FUNCTION_ARGLIST)
{
    HRESULT             RetVal;
    DWORD               dwDP2Op = (DWORD)((*ppCommands)->bCommand);
    LPD3DHAL_DP2COMMAND pSaveCommandsPtr = *ppCommands;

#ifdef	STEREO_DEBUG
	//Make sure it is not a rendering to a texture
	CNvObject *pNvObj = pContext->pRenderTarget->getWrapper();
	if (pNvObj->getClass() == CNvObject::NVOBJ_TEXTURE)
		__asm int 3
	//Make sure we render to a stereo surface
	if (pContext->pRenderTarget->isStereo() == 0)
		__asm int 3
	//Do we render to the Z buffer?
	if (pContext->pRenderTarget->isZBuffer())
		__asm int 3
#endif	//STEREO_DEBUG

    StereoLockSubstituteFlush();

    // First thing to determine is whether we take a HW T&L or SW T&L route. It breaks
    // down all our code into two vertually mutually exclusive cases. It is better to keep 
    // it this way for optimal performance
    if (!STEREO_R_US(pContext))
    {
        RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                                  ppCommands,
                                                  pCommandBufferEnd,
                                                  pdwDP2RStates,
                                                  dwDP2Flags);
        return RetVal;
    }
	BOOL UseHWTnLPath = FALSE;
	if (STEREODATA(StereoSettings.dwFlags) & STEREO_MIXEDTNLS)
	{
		if (!NV_VERTEX_TRANSFORMED(pContext->pCurrentVShader))
			UseHWTnLPath = TRUE;
	} else
	{
		if (pStereoData->dwHWTnL)
			UseHWTnLPath = TRUE;
	}

    if (UseHWTnLPath)
    {
        //This case is going to be the most frequently used in future. We want it fast.
        SetupStereoContext(pContext);
        RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                                  ppCommands,
                                                  pCommandBufferEnd,
                                                  pdwDP2RStates,
                                                  dwDP2Flags);
        *ppCommands = pSaveCommandsPtr; //Restore it for the second pass.
        AlternateStereoContext(pContext);
        RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                                  ppCommands,
                                                  pCommandBufferEnd,
                                                  pdwDP2RStates,
                                                  dwDP2Flags);
        return RetVal;
    }
    
#ifdef	STEREO_DEBUG
	// Once we got here make sure vertices are in the system memory. 
	// Otherwise it is going to be sooo slow.
	CVertexBuffer      *pVertexBuffer = pContext->ppDX8Streams[0];
	if (pVertexBuffer && pVertexBuffer->getHeapLocation() != CSimpleSurface::HEAP_SYS)
		__asm int 3
#endif	//STEREO_DEBUG

#if 0
	__asm int 3
#endif

    // And now is SW T&L or HW T&L with transformed vertices
    LPBYTE pVertexBufferBase = (LPBYTE)(pContext->ppDX8Streams[0]->getAddress());

#ifdef  NOT_IMPLEMENTED
    //LOG("%s: not implemented yet",GET_REAL_NAME( STEREO_DP2_FUNCTION_FLIP ));
    nvAssert (0);
    return ((*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                             ppCommands,
                                             pCommandBufferEnd,
                                             pdwDP2RStates,
                                             dwDP2Flags));
#else   //~NOT_IMPLEMENTED
    //nvAssert (0);
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

#ifdef	STEREO_DEBUG
    if (wCommandCount != 1)
    {
		__asm int 3
	} 
#endif	//STEREO_DEBUG
#ifdef  INDEX
    LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE lpDPCommand = (LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE)(lpPrim);
    PSTEREOEYEFUNCINDEX      pStereoEyeFunc = NULL;
    PSTEREORHWFUNCINDEX      pStereoRHWFunc = NULL;
#ifdef  START_VERTEX
    DWORD dwVertexBufferOffset = pContext->dp2.dwVertexBufferOffset;
	pContext->dp2.dwVStart      = lpDPCommand->BaseVertexIndex;
    DWORD  dwTotalOffset = dwVertexBufferOffset + ((DWORD)pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwTotalOffset = dwTotalOffset;
    LPBYTE pIndices      = (LPBYTE)(pContext->pIndexBuffer->getAddress() + pContext->pIndexBuffer->getVertexStride()*lpDPCommand->StartIndex);
    pContext->dp2.dwIndexStride = pContext->pIndexBuffer->getVertexStride();
    LPBYTE pVertices     = (LPBYTE)(pVertexBufferBase+dwTotalOffset);
#else   //START_VERTEX==0
    DWORD  dwTotalOffset = ((LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2)lpDPCommand)->BaseVertexOffset;
    pContext->dp2.dwTotalOffset = dwTotalOffset;
    LPBYTE pIndices      = (LPBYTE)(pContext->pIndexBuffer->getAddress() + ((LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2)lpDPCommand)->StartIndexOffset);
    pContext->dp2.dwIndexStride = pContext->pIndexBuffer->getVertexStride();
    LPBYTE pVertices     = (LPBYTE)(pVertexBufferBase+dwTotalOffset);
#endif  //START_VERTEX
#else   //INDEX==0
    LPD3DHAL_DP2DRAWPRIMITIVE lpDPCommand = (LPD3DHAL_DP2DRAWPRIMITIVE)(lpPrim);
    PSTEREOEYEFUNC      pStereoEyeFunc = NULL;
    PSTEREORHWFUNC      pStereoRHWFunc = NULL;
#ifdef  START_VERTEX
    DWORD dwVertexBufferOffset = pContext->dp2.dwVertexBufferOffset;
	pContext->dp2.dwVStart      = lpDPCommand->VStart;
    DWORD  dwTotalOffset = dwVertexBufferOffset + ((DWORD)pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwTotalOffset = dwTotalOffset;
    LPBYTE pVertices     = (LPBYTE)(pVertexBufferBase+dwTotalOffset);
#else   //START_VERTEX==0
    DWORD  dwTotalOffset = ((LPD3DHAL_DP2DRAWPRIMITIVE2)lpDPCommand)->FirstVertexOffset;
    pContext->dp2.dwTotalOffset = dwTotalOffset;
    LPBYTE pVertices     = (LPBYTE)(pVertexBufferBase+dwTotalOffset);
#endif  //START_VERTEX
#endif  //INDEX
#ifdef	STEREO_DEBUG
    if (!lpDPCommand->primType || lpDPCommand->primType == 1)
    {
		__asm int 3
	} 
#endif	//STEREO_DEBUG
#ifdef  INDEX
	pStereoEyeFunc = PrimTypeToStereoDP2Index[lpDPCommand->primType].pStereoEyeFuncIndex;
	pStereoRHWFunc = PrimTypeToStereoDP2Index[lpDPCommand->primType].pStereoRHWFuncIndex;

    SetupStereoContext(pContext);

#ifdef  STEREO_CONFIG_ASSIST
    if (pStereoRHWFunc (pContext, pVertices, pIndices, (DWORD)lpDPCommand->PrimitiveCount, EQUAL))
        ConfigAssistInfo.dwFlags |= _2DSUSPECT;
#endif  //STEREO_CONFIG_ASSIST
    if (pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN)
    {
        if (pStereoRHWFunc (pContext, pVertices, pIndices, (DWORD)lpDPCommand->PrimitiveCount, GREATER))
            pStereoEyeFunc = NULL;
    }
    if (pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN)
    {
        if (pStereoRHWFunc (pContext, pVertices, pIndices, (DWORD)lpDPCommand->PrimitiveCount, LESS))
            pStereoEyeFunc = NULL;
    }

    if (pStereoEyeFunc)
	{
        (*pStereoEyeFunc)(pContext, pVertices, pIndices, (DWORD)lpDPCommand->PrimitiveCount);
	}
    RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                              ppCommands,
                                              pCommandBufferEnd,
                                              pdwDP2RStates,
                                              dwDP2Flags);
    AlternateStereoContext(pContext);
    if (pStereoEyeFunc)
    {
        (*pStereoEyeFunc)(pContext, pVertices, pIndices, (DWORD)lpDPCommand->PrimitiveCount);
    }

    *ppCommands = pSaveCommandsPtr; //Restore it for the second pass.
    RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                              ppCommands,
                                              pCommandBufferEnd,
                                              pdwDP2RStates,
                                              dwDP2Flags);
    if (pStereoEyeFunc)
    {
        (*pStereoEyeFunc)(pContext, pVertices, pIndices, (DWORD)lpDPCommand->PrimitiveCount);
    }
    return RetVal;
#else   //INDEX==0
	pStereoEyeFunc = PrimTypeToStereoDP2[lpDPCommand->primType].pStereoEyeFunc;
	pStereoRHWFunc = PrimTypeToStereoDP2[lpDPCommand->primType].pStereoRHWFunc;

    SetupStereoContext(pContext);

#ifdef  STEREO_CONFIG_ASSIST
    if (pStereoRHWFunc (pContext, pVertices, (DWORD)lpDPCommand->PrimitiveCount, EQUAL))
        ConfigAssistInfo.dwFlags |= _2DSUSPECT;
#endif  //STEREO_CONFIG_ASSIST
    if (pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN)
    {
        if (pStereoRHWFunc (pContext, pVertices, (DWORD)lpDPCommand->PrimitiveCount, GREATER))
            pStereoEyeFunc = NULL;
    }
    if (pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN)
    {
        if (pStereoRHWFunc (pContext, pVertices, (DWORD)lpDPCommand->PrimitiveCount, LESS))
            pStereoEyeFunc = NULL;
    }

    if (pStereoEyeFunc)
	{
        (*pStereoEyeFunc)(pContext, pVertices, (DWORD)lpDPCommand->PrimitiveCount);
	}
    RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                              ppCommands,
                                              pCommandBufferEnd,
                                              pdwDP2RStates,
                                              dwDP2Flags);
    AlternateStereoContext(pContext);
    if (pStereoEyeFunc)
    {
        (*pStereoEyeFunc)(pContext, pVertices, (DWORD)lpDPCommand->PrimitiveCount);
    }

    *ppCommands = pSaveCommandsPtr; //Restore it for the second pass.
    RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                              ppCommands,
                                              pCommandBufferEnd,
                                              pdwDP2RStates,
                                              dwDP2Flags);
    if (pStereoEyeFunc)
    {
        (*pStereoEyeFunc)(pContext, pVertices, (DWORD)lpDPCommand->PrimitiveCount);
    }
    return RetVal;
#endif  //INDEX
#endif  //~NOT_IMPLEMENTED
}

#endif	//DRAWPRIMITIVE

#undef  STEREO_DP2_FUNCTION_OAU
#undef  STEREO_EYE_FUNCTION_OAU
#undef  STEREO_2D_FUNCTION_OAU
#undef  STEREO_DP2_FUNCTION_FLIP
#undef  STEREO_EYE_FUNCTION_FLIP
#undef  CHECK_RHW_CONDITION
#undef  INDEX
#undef  INDEX2
#undef  FAN
#undef  STRIP
#undef  FAN_OR_STRIP
#undef  FOR_ALL_VERTICES
#undef  GET_V1_POINTER
#undef  GET_V2_POINTER
#undef  GET_V3_POINTER
#undef  ADVANCE
#undef  ALIGN
#undef  START_VERTEX
#undef  LINE
#undef  POINT
#undef  DEFINE_LOCALS
#undef  NOT_IMPLEMENTED
#undef	DRAWPRIMITIVE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvVideoPort.cpp ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
*                                                                           *
* Module: nvVideoPort.cpp                                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           3/26/98                                          *
*                                                                           *
\***************************************************************************/

#include "nvprecomp.h"

#pragma hdrstop

volatile U032*  nvTimerPtr = NULL;
vpSurfaces*         pMySurfaces = NULL;
NvNotification* nvMyVPNotifiers = NULL;

#if (!defined(WINNT) && !defined(NVPE))   // WINNT BUG

const DWORD MY_CONNECTION_CAPS= //DDVPCONNECT_DOUBLECLOCK           |
                                            //DDVPCONNECT_VACT                  |
                                            /* we're capable of inverting the polarity */
                                            DDVPCONNECT_INVERTPOLARITY      |
                                            /* we discard at least until the V bit goes low, and potentially more depending
                                              on the setting of YCROP  as well as the current VBI situation  */
                                            //DDVPCONNECT_DISCARDSVREFDATA  |
                                            /* we WILL count the halfline */
                                            DDVPCONNECT_HALFLINE                |
                                            /*  these next are "client" only
                                            //DDVPCONNECT_INTERLACED            |
                                            //DDVPCONNECT_SHAREEVEN         |
                                            //DDVPCONNECT_SHAREODD              |
                                            */
                                            0;

DDPIXELFORMAT pf[] = {
    {sizeof(DDPIXELFORMAT),DDPF_FOURCC,  mmioFOURCC('U','Y','V','Y'),16,(DWORD)-1,(DWORD)-1,(DWORD)-1},
};
/*DDPIXELFORMAT pfvbi[] = {
    {sizeof(DDPIXELFORMAT),DDPF_FOURCC,  mmioFOURCC('R','A','W','8'),8,(DWORD)-1,(DWORD)-1,(DWORD)-1},
};
*/
DDPIXELFORMAT pfvbi[] = {
    {sizeof(DDPIXELFORMAT),DDPF_FOURCC,  mmioFOURCC('R','A','W','8'),8,(DWORD)-1,(DWORD)-1,(DWORD)-1},
};


//#define TESTCALLBACK
#ifdef TESTCALLBACK

void JoeCoolDudesCallbackRoutine(sCallBack* pCallbackStruct);

#endif

U032    getMilliTime(void);


void    getCurrentNanoTimer(U032 *  Most, U032 * Least) {
    volatile U032* myTimerLo = nvTimerPtr;
    volatile U032* myTimerHi = (U032*)(((U032)nvTimerPtr)+0x10);
    ASSERT(nvTimerPtr != NULL);
    ASSERT(Most         != NULL);
    ASSERT(Least        != NULL);
    if(nvTimerPtr!=NULL) {
        *Least = *myTimerLo;
        *Most   = *myTimerHi;
    } else {
        *Least = 0;
        *Most   = 0;
    }
}

U032    getMilliTime(void) {
    U032    bigTime;
    U032    smallTime;

    getCurrentNanoTimer(&bigTime, &smallTime);
    return (smallTime / 1000000) + bigTime * (0xFFFFFFFF/1000000);

}

/*

It appears that BPC has been programmd in such a way as to violate the API for VP.
So we need to compensate.  The problem is that the following scenario can happen.
CanCreateVP   VBI
CreateVP   VBI
UpdateVP   VBI
time passes
CanCreateVP   IMAGE
CreateVP  Image
UpdateVP   VBI+Image
timepasses
Destroy VP.

The key thing here is that the video ports will use the SAME port ID. so that should help us.


*/

DWORD __stdcall CanCreateVideoPort32 (LPDDHAL_CANCREATEVPORTDATA lpInput)
{
    /*
     * If the lpInput->lpDDVideoPortDesc can not be supported, set
     * lpInput->ddRVal to the correct error code and return
     * DDHAL_DRIVER_HANDLED
     */
    /*  this is only a query to see if VideoPort can handle a certain requirement,
        no structures are defined here, or even chip query */
    DPF("***CanCreateVideoPort32");

    ASSERT(lpInput!=NULL);
    ASSERT(lpInput->lpDDVideoPortDesc !=NULL);

    if( pDriverData == NULL ) {
        DPF("   ***VideoPort not creatable  -->  pDriverData = NULL!   YIKES!");
        lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        return DDHAL_DRIVER_HANDLED;
    }
    // Ok, if we got to here that means we're talking to the VXD MiniVDD properly... onward ho!

    // Check structure size
    if(lpInput->lpDDVideoPortDesc->dwSize   < sizeof( DDVIDEOPORTDESC ) ) {
        DPF("   ***VideoPort not creatable  -->  stucture length is not large enough");
        lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        return DDHAL_DRIVER_HANDLED;
    }

    // check input connection GUID
    if ( !IsEqualGUID_C((lpInput->lpDDVideoPortDesc->VideoPortType.guidTypeID), DDVPTYPE_CCIR656) )  {
        DPF("   ***VideoPort not creatable  -->  GUID should be DDVPTYPE_CCIR656");
        lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        return DDHAL_DRIVER_HANDLED;
    }

    // check to see if there are ports available... by looking at local allocation
    if (pDriverData->dwVideoPortsAvailable <=0 ) {

            // check to see if there are ports available... by looking at IDs
       if (lpInput->lpDDVideoPortDesc->dwVideoPortID != 0 ) {
            DPF("   ***VideoPort not creatable  --> not enough video ports");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

        DPF("CanCreate for Second VP with same ID Allowed.... silly API");
    }

    //
    // NV4/5 and NV10 have different hardware limitations
    //
    // Added height checking since "width*height check" has test escapes

    if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {

        if (lpInput->lpDDVideoPortDesc->dwFieldWidth > NV4_MAX_FIELDWIDTH) {
            DPF("   ***VideoPort not creatable  --> field Width is too great");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

        if (lpInput->lpDDVideoPortDesc->dwVBIWidth > NV4_MAX_VBIWIDTH) {
            DPF("   ***VideoPort not creatable  --> VBI field Width is too great");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }
        
        if (lpInput->lpDDVideoPortDesc->dwFieldHeight > NV4_MAX_FIELDHEIGHT) {
            DPF("   ***VideoPort not creatable  --> field Height is too great");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

        if (lpInput->lpDDVideoPortDesc->dwFieldHeight * lpInput->lpDDVideoPortDesc->dwFieldWidth > NV4_MAX_BUFFERLENGTH) {
            DPF("   ***VideoPort not creatable  --> Maximum buffer length exceed by field height too high");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

        if (lpInput->lpDDVideoPortDesc->dwMaxPixelsPerSecond > NV4_MAX_PIXELRATE) {
            DPF("   ***VideoPort not creatable  --> Sorry incoming data rate is too high");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

        if (lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth != 8) {
            DPF("   ***VideoPort not creatable  --> incoming connection width is not 8 bits");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

    }
    else {

        if (lpInput->lpDDVideoPortDesc->dwFieldWidth > NV10_MAX_FIELDWIDTH) {
            DPF("   ***VideoPort not creatable  --> field Width is too great");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

        if (lpInput->lpDDVideoPortDesc->dwVBIWidth > NV10_MAX_VBIWIDTH) {
            DPF("   ***VideoPort not creatable  --> VBI field Width is too great");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

        if (lpInput->lpDDVideoPortDesc->dwFieldHeight > NV10_MAX_FIELDHEIGHT) {
            DPF("   ***VideoPort not creatable  --> field Height is too great");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

        if (lpInput->lpDDVideoPortDesc->dwFieldHeight * lpInput->lpDDVideoPortDesc->dwFieldWidth > NV10_MAX_BUFFERLENGTH) {
            DPF("   ***VideoPort not creatable  --> Maximum buffer length exceed by field height too high");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

        if (lpInput->lpDDVideoPortDesc->dwMaxPixelsPerSecond > NV10_MAX_PIXELRATE) {
            DPF("   ***VideoPort not creatable  --> Sorry incoming data rate is too high");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

        if ( !((lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth  == 8 ) ||
               (lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth  == 16 )) ) {
            DPF("   ***VideoPort not creatable  --> incoming connection width is not 8 or 16 bits");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

    }

#ifdef NOCHECKHERE
            // the ones I'm not capable of   ANDed   with the ones Dx is asking for
    if( (~MY_CONNECTION_CAPS) & lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags ) {
        // if we get here this should indicate that Dx is asking for a capability we're incapable of
        DPF("   ***VideoPort not creatable  --> Some of the capability flags bits are wrong");
        lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        return DDHAL_DRIVER_HANDLED;

    }
#endif

    //  Ok, we've pretty much checked everything we can possibly check here... let's tell'em that
    // we can work!

    lpInput->ddRVal = DD_OK;
    DPF("   ***VideoPort creatable! ***");
    return DDHAL_DRIVER_HANDLED;
}


U032    HookUpVxdStorage(void) {


    HANDLE      aVXDHandle;
    U032 i;

    DPF("NOW ATTEMPTING VXD stuff");



    DPF("\n\n\n\nThe DeviceID is:%d\n\n\n\n",pDriverData->thisDeviceID);

    if( pDriverData->thisDeviceID == 0 ) {
        DPF("We are Primary controller! \n");
#ifdef NV3
        aVXDHandle = NvCreateFile(NV3_PRIMARY_MINIVDD, 0,FILE_SHARE_READ,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#else
        aVXDHandle = NvCreateFile(NVX_PRIMARY_MINIVDD, 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#endif
    } else {
        DPF("We are not primary controller :-( \n");
#ifdef NV3
        aVXDHandle = NvCreateFile(NV3_SECONDARY_MINIVDD, 0,FILE_SHARE_READ,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#else
        aVXDHandle = NvCreateFile(NVX_SECONDARY_MINIVDD, 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#endif
    }

    if((aVXDHandle == NULL) || (aVXDHandle ==INVALID_HANDLE_VALUE)) {
        U032    daError;
        DPF("Can't get Vxd handle   :-(");
        daError = GetLastError();
        DPF("The error was %d  or %x",daError,daError);
        if(daError == 50 ) {
            DPF("Which means most likely that you don't have a version of NVX.VXD or NVXmini2 which supports IOCTL");
        }
        return FALSE;

    }

    // nother block
    {
        U032                inBuffer;
        NVVDDPROCTABLE  aTable;
        U032                outputSize = 0;

        // pass in the pointer to the direct draw object.. this may be useful later
//      inBuffer = (U032) lpInput->lpDD;

        aTable.getStoragePointer = NULL;
        aTable.dwPDDDriver = 0;
        aTable.handleBufferInterrupts = NULL;

        if(DeviceIoControl(aVXDHandle,
                            VDD_IOCTL_NV_FILLTABLE,     // control code of operation to perform
                            &inBuffer,                          // pointer to buffer to supply input data
                            4,                              // size of input buffer
                            &aTable,                    // pointer to buffer to receive output data
                            sizeof(NVVDDPROCTABLE), // size of output buffer
                            &outputSize,                // pointer to variable to receive output byte count
                            NULL                            // pointer to overlapped structure for asynchronous operation
        ) ){
            // cool we made it.   Now copy our temporarly stuff into the real one!

            // first get the storage pointer
            if( aTable.getStoragePointer != NULL ) {
                pMySurfaces = (vpSurfaces*)(aTable.getStoragePointer)();
            } else {
                DPF("didn't get a valid pointer to a routine");

                NvCloseHandle(aVXDHandle);
                return FALSE;
            }

            if( pMySurfaces != NULL ) {
                // we cool!  everybody get funky one more time!  and copy that stuff in
                pMySurfaces->myVXDhandle = aVXDHandle;
                memcpy (&pMySurfaces->myTable, &aTable,  sizeof (NVVDDPROCTABLE));
                NvCloseHandle(aVXDHandle);

            } else {
                DPF("didn't get the storage pointer");

                NvCloseHandle(aVXDHandle);
                return FALSE;
            }

        }   else {
            //  failure
            //close the VXD
            DPF("couldn't call the VXD via IOCTL properly");
            NvCloseHandle(aVXDHandle);
            return FALSE;
        }

    }


    nvMyVPNotifiers = pMySurfaces->pTheNotifiers;
    pMySurfaces->numberOfSurfaces =0;

    for(i=0;i<MAXVPSURFACES;i++) {
        pMySurfaces->Surfaces[i] = NULL;
    }
    pMySurfaces->CurrentBufferSurface[4] = NOSURFACEPROGRAMED;              // to associate the HW buffer with an arrary index

    pMySurfaces->CurrentScanMode =SEPERATEBUF;      // seperate or interleaved buffersx
    if(pMySurfaces->bInvertedFields )   {
        pMySurfaces->lastField = ODD;   // this should be even so we'll always start on odd ( hopefully... :-)
        pMySurfaces->lastVBIField = ODD;
    } else {
        pMySurfaces->lastField = EVEN;
        pMySurfaces->lastVBIField = EVEN;
    }
    pMySurfaces->VBIstart = 0;;
    // general information
    pMySurfaces->bSkipNextField = FALSE;
    pMySurfaces->dwInHeight = 0;
    pMySurfaces->dwInWidth = 0;
    pMySurfaces->dwImageStartLine =10;              // ditch a minimum of 10 lines
    pMySurfaces->dwVBIStartLine = 0;
    pMySurfaces->dwVBIHeight = 0;
    pMySurfaces->dwPreHeight = 0;                   // height and width before prescaling
    pMySurfaces->dwPreWidth = 0;
    pMySurfaces->dwOriginX = 0;                     // orgins to move data within the surface
    pMySurfaces->dwOriginY = 0;
    pMySurfaces->bThreadDead = TRUE;
    pMySurfaces->bThreadRunning = FALSE;

    pMySurfaces->bStopVP = FALSE;                           // indicates to the thread that it should NOT reprogram

    pMySurfaces->Timings.LoopCount=0;

    pMySurfaces->pBuffer0Mem = (U032) NULL;
    pMySurfaces->pBuffer1Mem = (U032) NULL;
    pMySurfaces->curOverlay = 0;            // this way we should start into 0

    // initialize all the callback stuff
    pMySurfaces->ImageCallbackRoutine = NULL;
    pMySurfaces->VBICallbackRoutine = NULL;
    pMySurfaces->myIMGCallbackInfo.intCount = 0;
    pMySurfaces->myVBICallbackInfo.intCount = 0;
    pMySurfaces->myIMGCallbackInfo.dwFlags = 0;
    pMySurfaces->myVBICallbackInfo.dwFlags = 0;
    pMySurfaces->myIMGCallbackInfo.dwVersion = 0x100;
    pMySurfaces->myVBICallbackInfo.dwVersion = 0x100;
    pMySurfaces->myIMGCallbackInfo.curBufferAddr = (U032)NULL;
    pMySurfaces->myVBICallbackInfo.curBufferAddr = (U032)NULL;
    pMySurfaces->myIMGCallbackInfo.lastBufferAddr = (U032)NULL;
    pMySurfaces->myVBICallbackInfo.lastBufferAddr = (U032)NULL;
    pMySurfaces->myIMGCallbackInfo.dwSize = sizeof(sCallBack);
    pMySurfaces->myVBICallbackInfo.dwSize = sizeof(sCallBack);
    pMySurfaces->intermediateCycle = 0;
    if(pDriverData == NULL ) {
        // dude this is PROBLEM!!!
        return FALSE;
    }
    pMySurfaces->pDriverData = pDriverData;
    pDriverData->dwMySurfacesPtr = (unsigned long) pMySurfaces;

    pMySurfaces->DXIRQCallbackSources = 0;;
    pMySurfaces->pDXIRQCallback = (U032) NULL;
    pMySurfaces->dwIrqContext = 0;
    pMySurfaces->SetupComplete = FALSE;
    pMySurfaces->dwNextEmpty = 0;
    pMySurfaces->dwLastEmpty = (MAXTRANSFERS-1);
    pMySurfaces->lastSurface = NOSURFACEPROGRAMED;
    pMySurfaces->lastBuffer = NOSURFACEPROGRAMED;


   pMySurfaces->DropSystem.dwTargetSurface = 0;
   pMySurfaces->DropSystem.dwbIsBobFromInterleave = 0;
   pMySurfaces->DropSystem.dwFieldType = 0;
   pMySurfaces->DropSystem.dwFullBool = 0;
   pMySurfaces->DropSystem.dwDropFields = 0;

    pMySurfaces->DropSystem.dwFullBool =FALSE;   // used to indicate that we just dropped a field and the leap frogging should stop for one frame

    // get a pointer to the timer
    nvTimerPtr = (U032 *) NvDeviceBaseGet(NV_DEV_TIMER, pDriverData->dwDeviceIDNum );
    pMySurfaces->pNvTimer = nvTimerPtr;

    return TRUE;
}

/*
 * CreateVideoPort32
 *
 * This function is optional, define all objects if they have not already been defined.
 */
DWORD __stdcall CreateVideoPort32 (LPDDHAL_CREATEVPORTDATA lpInput)
{
    /*
     * This function allows the HAL to set internal flags and
     * become aware that a video port has been created. It should
     * always return DDHAL_DRIVER_NOTHANDLED.
     */

    /* According to DDHAL documentation, this procedure can return DDHAL_DRIVER_NOTHANDLED
       as well, signifying that the createvideoport fn could not be completed

       DirectDraw MS layer will prevent creating more videoports that is
       available.

       */

    DWORD       returnVal = DDHAL_DRIVER_HANDLED;
    DPF("   ***CreateVideoPort32***");
    // we should only have to get this once on creation

    if(pMySurfaces == NULL )
        if(!HookUpVxdStorage() )
        {
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }
    if( pMySurfaces->pDriverData == NULL )
        if(!HookUpVxdStorage() )
        {
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }


    if( pMySurfaces->SetupComplete ) {
            // we may be attempting a "second" CreateVideo port with the same ID..
            // let's check that.

            //CODE we should probably check here for non-duplicat VBI and Image, but we'll just let that slide for now.

            if (lpInput->lpDDVideoPortDesc->dwVideoPortID == 0 ) {
                // this is the second create
                DPF("***  HACKED second video port create has been called.");
                DPF("  now shunting to hyperspace modulator bypass code.  Turn reality distortion field driver code to 11");


                DPF("  Size of the DDVIDEOPORTDESC structure     %d",lpInput->lpDDVideoPortDesc->dwSize);
                DPF("  Width of the video port field.            %d",lpInput->lpDDVideoPortDesc->dwFieldWidth);
                DPF("  Width of the VBI data.                    %d",lpInput->lpDDVideoPortDesc->dwVBIWidth);
                DPF("  Height of the video port field.           %d",lpInput->lpDDVideoPortDesc->dwFieldHeight);
                DPF("  Microseconds per video field.             %d",lpInput->lpDDVideoPortDesc->dwMicrosecondsPerField);
                DPF("  Maximum pixel rate per second.            %d",lpInput->lpDDVideoPortDesc->dwMaxPixelsPerSecond);
                DPF("  Video port ID (0 - (dwMaxVideoPorts -1)). %d",lpInput->lpDDVideoPortDesc->dwVideoPortID);
                DPF("  Reserved for future use - set to zero.    %d",lpInput->lpDDVideoPortDesc->dwReserved1);

                DPF("  Size of the DDVIDEOPORTDESC.dwSize        %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwSize);
                DPF("              DDVIDEOPORTDESC.dwPortWidth   %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth);
#ifndef __cplusplus
                DPF("              DDVIDEOPORTDESC.guidTypeID    %d",lpInput->lpDDVideoPortDesc->VideoPortType.guidTypeID);
#endif
                DPF("              DDVIDEOPORTDESC.dwFlags       %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags);

                lpInput->ddRVal = DD_OK;
                return returnVal;
            }
    }

    if(lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags & DDVPCONNECT_INTERLACED ) {
        pMySurfaces->bInputInterLaced = TRUE;
    } else {
        pMySurfaces->bInputInterLaced = FALSE;
    }

    if(pMySurfaces->bInputInterLaced)
        pMySurfaces->CurrentCaptureMode =EVENODD;       // indicates which fields will be capture Even
    else
        pMySurfaces->CurrentCaptureMode =PROGRESSIVE;   // we're assuming progressive is ALWAYS even even even



    if(lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags & DDVPCONNECT_INVERTPOLARITY ) {
        DPF("DDVPCONNECT_INVERTPOLARITY     on");
        pMySurfaces->bInvertedFields = TRUE;
        // Now check for the weird exception case when we want to skip half line as well...
        if(lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags & DDVPCONNECT_HALFLINE ) {
            DPF("DDVPCONNECT_HALFLINE       on");
            pMySurfaces->bInvertedFields = FALSE;
        } else {
            DPF("DDVPCONNECT_HALFLINE       off");

        }

    } else {
        DPF("DDVPCONNECT_INVERTPOLARITY     off");
        pMySurfaces->bInvertedFields = FALSE;
    }


    if(lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags & DDVPCONNECT_HALFLINE ) {
        DPF("DDVPCONNECT_HALFLINE             on");
    } else {
        DPF("DDVPCONNECT_HALFLINE             off");
    }


    DPF("***CreateVideoPort32");


    DPF("  Size of the DDVIDEOPORTDESC structure     %d",lpInput->lpDDVideoPortDesc->dwSize);
    DPF("  Width of the video port field.            %d",lpInput->lpDDVideoPortDesc->dwFieldWidth);
    DPF("  Width of the VBI data.                    %d",lpInput->lpDDVideoPortDesc->dwVBIWidth);
    DPF("  Height of the video port field.           %d",lpInput->lpDDVideoPortDesc->dwFieldHeight);
    DPF("  Microseconds per video field.             %d",lpInput->lpDDVideoPortDesc->dwMicrosecondsPerField);
    DPF("  Maximum pixel rate per second.            %d",lpInput->lpDDVideoPortDesc->dwMaxPixelsPerSecond);
    DPF("  Video port ID (0 - (dwMaxVideoPorts -1)). %d",lpInput->lpDDVideoPortDesc->dwVideoPortID);
    DPF("  Reserved for future use - set to zero.    %d",lpInput->lpDDVideoPortDesc->dwReserved1);

    DPF("  Size of the DDVIDEOPORTDESC.dwSize        %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwSize);
    DPF("              DDVIDEOPORTDESC.dwPortWidth   %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth);
#ifndef __cplusplus
    DPF("              DDVIDEOPORTDESC.guidTypeID    %d",lpInput->lpDDVideoPortDesc->VideoPortType.guidTypeID);
#endif
    DPF("              DDVIDEOPORTDESC.dwFlags       %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags);

    DPF("   Reserved for future use - set to zero.     %d",lpInput->lpDDVideoPortDesc->dwReserved2);
    DPF("   Reserved for future use - set to zero.     %d",lpInput->lpDDVideoPortDesc->dwReserved3);


    // We'll assume for now that since CanCreate passed that our parameters are valid at this point
    // we need to setup the entire NV object system at this point

    // theorectically we should not have a channel open... let's check that?

    // get our OWN copy of the driver data

    returnVal = SetupVP ( lpInput);


    //pMySurfaces->pVPChanPtr = (NvChannel * ) pDriverData->NvDevFlatVPE;

    // cannot set this as unallocated here since it must be done once per OVERLAY
    // and not once per VP.
    //pDriverData->dwOverlayEventsAllocated = FALSE;


    // For the overlay flip, store away a channel pointer
    pMySurfaces->pOverlayChanPtr = (NvChannel*) pDriverData->NvDevVideoFlatPio;
    pMySurfaces->dwOverlaySubChan = NV_DD_SPARE;
    pMySurfaces->dwOverlayObjectID = NV_DD_YUV422_VIDEO_FROM_MEMORY;
    pMySurfaces->dwScalerObjectID = NV_DD_VIDEO_SCALER;
    //pMySurfaces->dwDVDObjectID = NV_DD_DVD_SUBPICTURE;
    pMySurfaces->dwDVDObjectID = NV_VIDEO_DVD_SUBPICTURE;
#ifdef TESTCALLBACK

    // let's register an IMAGE callback here and see what happens
    {
        HANDLE bVXDHandle;
        U032     inBuffer;
        //U032   returnCode;
        U032     outputSize;
        SETCALLBPROC    pSetCallback;

        inBuffer = 0;

        bVXDHandle = NvCreateFile(NVX_PRIMARY_MINIVDD, 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);

        if(bVXDHandle != NULL ) {
            if(DeviceIoControl(bVXDHandle,
                                        VDD_IOCTL_NV_GETSETCALLBACK,        // control code of operation to perform
                                        &inBuffer,                          // pointer to buffer to supply input data
                                        4,                                      // size of input buffer
                                        &pSetCallback,                      // pointer to buffer to receive output data
                                        4,                                      // size of output buffer
                                        &outputSize,                        // pointer to variable to receive output byte count
                                        NULL                                    // pointer to overlapped structure for asynchronous operation
                                    )
                 ){

                        // things worked, the
                        inSCBStruct     inBuf;
                        outSCBStruct    outBuf;
                            // NOTE USE OF FLAGS FROM VPCALLBk.h
                        inBuf.flags = IMAGESURFACE;
                        inBuf.pTheCallback = JoeCoolDudesCallbackRoutine;

                        (pSetCallback)(&inBuf,&outBuf);

            } else {

                        // bummer, for some reason, we were unable to set your callback

            }

            NvCloseHandle(bVXDHandle);

        }


    }
#endif

    if(nvTimerPtr == NULL) {
        // get a pointer to the timer
        nvTimerPtr = (U032 *) NvDeviceBaseGet(NV_DEV_TIMER, pDriverData->dwDeviceIDNum );
        pMySurfaces->pNvTimer = nvTimerPtr;

    }
#ifdef ENABLE_VPP_DISPATCH_CODE
// This code is no longer used but may someday be useful.

#ifdef USEVPP
    // kick up the VPP process priority
    pDriverData->vppDispatch.dwThreadPriority = pDriverData->vppDispatch.dwOriginalThreadPriority;
    pDriverData->vppDispatch.dwProcessPriority = pDriverData->vppDispatch.dwOriginalProcessPriority;
    //pDriverData->vppDispatch.dwThreadPriority = THREAD_PRIORITY_TIME_CRITICAL;
    //pDriverData->vppDispatch.dwThreadPriority = THREAD_PRIORITY_HIGHEST;
    //pDriverData->vppDispatch.dwProcessPriority = REALTIME_PRIORITY_CLASS  ;
    pDriverData->vppDispatch.dwCommand = VPPDISPATCH_SETPRIORITY;
    SetEvent(pDriverData->vppDispatch.hSignalGo3);
#endif

#endif

    // don't forget to decrement the number of video ports avail number which is
    lpInput->ddRVal = DD_OK;

    return returnVal;
}


#ifdef TESTCALLBACK

void JoeCoolDudesCallbackRoutine(sCallBack* pCallbackStruct) {
    DPF("WoW we made it to JoeCoolDudesCallbackRoutine interrupt=%d",pCallbackStruct->intCount);


}


#endif
 /*
 * GetVideoPortBandwidth32
 *
 * This function is required
 */
DWORD __stdcall GetVideoPortBandwidth32 (LPDDHAL_GETVPORTBANDWIDTHDATA lpInput)
{

    DPF("***GetVideoPortBandwidth32");
    /*
     * Determine how much bandwidth is available for the specified
     * output format and fill in the information.
     */

     // we are lucky in that we basically only support ONE format  YEAH!

    if (lpInput->dwFlags & DDVPB_TYPE) {
        lpInput->lpBandwidth->dwCaps = DDVPBCAPS_DESTINATION;  // we are limited by the "shrink" of the overlay
    }

    if (lpInput->dwFlags & DDVPB_VIDEOPORT) {
        // The following four should indicate the MINIMUM stretch values represented as percentages times 10
        //  so if we could not stretch below 75% of the orginal size, the we should put in 750
        // for now I'll leave these "as is" because I need to collect the correct values -CJS
        lpInput->lpBandwidth->dwOverlay                 = 1000;
        lpInput->lpBandwidth->dwColorkey                = 1000;  // Overlay/video port/colorkey works at 1X
        lpInput->lpBandwidth->dwYInterpolate            = 1000;  // Overlay/video port works at 1X
        lpInput->lpBandwidth->dwYInterpAndColorkey      = 1000;  // Overlay/video port/interpolation works at 2X
    }


    if (lpInput->dwFlags & DDVPB_OVERLAY) {
        DPF("   We are NOT an overlay limited device but a destination ");
        DPF("      limited device we should not have been called");
    }

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/*
 * GetVideoPortInputFormat32
 *
 * This function is required
 */
DWORD __stdcall GetVideoPortInputFormat32 (LPDDHAL_GETVPORTINPUTFORMATDATA lpInput)
{
   /* Only 1 input format supported UYVY 4:2:2 */
    /* Data stored in 32bit word as U[7:0] Y1[15:8] V[23:16] Y2[31:24] */
    DPF("   ***GetVideoPortInputFormat32");
    /*
    * The HAL is gaurenteed that the buffer in lpInput->lpddpfFormat
    * is large enough to hold the information
    */


    if (lpInput->dwFlags & DDVPFORMAT_VIDEO ) {
        lpInput->dwNumFormats = 1;
        if (lpInput->lpddpfFormat != NULL) {
            memcpy (lpInput->lpddpfFormat, &pf[0],  sizeof (DDPIXELFORMAT));
        }
    }

/*
    if (lpInput->dwFlags & DDVPFORMAT_VBI ) {
        lpInput->dwNumFormats = 1;
        if (lpInput->lpddpfFormat != NULL) {
            memcpy (lpInput->lpddpfFormat, &pf[0],  sizeof (DDPIXELFORMAT));
        }
    }
*/
    if (lpInput->dwFlags & DDVPFORMAT_VBI ) {
        lpInput->dwNumFormats = 1;
        if (lpInput->lpddpfFormat != NULL) {
            memcpy (lpInput->lpddpfFormat, &pfvbi[0],  sizeof (DDPIXELFORMAT));
        }
    }

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoPortOutputFormat32
 *
 * This function is required
 */
DWORD __stdcall GetVideoPortOutputFormat32 (LPDDHAL_GETVPORTOUTPUTFORMATDATA lpInput)
{
    /* OutputFormat does not convert UYUV to RGB, this would be done by Overlay control */
    /* Data stored in 32bit word as U[7:0] Y1[15:8] V[23:16] Y2[31:24] */

    DPF("***GetVideoPortOutputFormat32");

    /* OutputFormat does not convert UYUV to RGB, this would be done by Overlay control */
    /* Data stored in 32bit word as U[7:0] Y1[15:8] V[23:16] Y2[31:24] */

    // default
    lpInput->dwNumFormats = 1;
    if (lpInput->lpddpfOutputFormats != NULL) {
        memcpy (lpInput->lpddpfOutputFormats, lpInput->lpddpfInputFormat, sizeof (DDPIXELFORMAT));
    }

    // for the video data
    if (lpInput->dwFlags & DDVPFORMAT_VIDEO) {// video formats
        // is input format a FOURCC
        if (lpInput->lpddpfInputFormat->dwFlags & DDPF_FOURCC ) {
            // is it UYVY
            if (lpInput->lpddpfInputFormat->dwFourCC == mmioFOURCC('U','Y','V','Y')) {
                // translation of UYVY is UYVY (ie no translation)
            lpInput->dwNumFormats = 1;
           if (lpInput->lpddpfOutputFormats != NULL) {
                    memcpy (lpInput->lpddpfOutputFormats, pf, sizeof (DDPIXELFORMAT) );
                }
            }
        }
    }

    // for the VBI data
    if (lpInput->dwFlags & DDVPFORMAT_VBI) {// VBI formats
        // is input format a FOURCC
        if (lpInput->lpddpfInputFormat->dwFlags & DDPF_FOURCC ) {
            // is it UYVY
            if (lpInput->lpddpfInputFormat->dwFourCC == mmioFOURCC('R','A','W','8')) {
                // translation of UYVY is UYVY (ie no translation)
            lpInput->dwNumFormats = 1;
           if (lpInput->lpddpfOutputFormats != NULL) {
                    memcpy (lpInput->lpddpfOutputFormats, pfvbi, sizeof (DDPIXELFORMAT) );
                }
            }
        }
    }

    lpInput->ddRVal = DD_OK;
   return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoPortField32
 *
 * This function is only required if readback of the current
 * field is supported.
 */
// needed defines for mediaport


DWORD __stdcall GetVideoPortField32 (LPDDHAL_GETVPORTFIELDDATA lpInput)
{
    /*
     * Make sure the video port is ON.  If not, set
     * lpInput->ddRVal to DDERR_VIDEONOTACTIVE and return.
     */

    /*
     * Readback whether the field is even or odd.  lpInput->bField is
     * set to TRUE if the current field is even.
     */
    DPF("***GetVideoPortField32");

    if (pMySurfaces->dwVideoPortStatus == VP_NOT_RUNNING) {
        //DPF("   Video is not active!!!");
        lpInput->bField = 0;
       lpInput->ddRVal = DDERR_VIDEONOTACTIVE;
    } else {
     /*
     * Readback the current line number and put it in
     * lpInput->dwLine
     */

        lpInput->bField = GetField();

        lpInput->ddRVal = DD_OK;

        lpInput->bField = 0;
    }

    return DDHAL_DRIVER_HANDLED;
}

/*
 * GetVideoPortLine32
 *
 * This function is only required if readback of the current
 * video line number (0 relative) is supported.
 */
    /*
     * Make sure the video port is ON.  If not, set
     * lpInput->ddRVal to DDERR_VIDEONOTACTIVE and return.
     */

DWORD __stdcall GetVideoPortLine32 (LPDDHAL_GETVPORTLINEDATA lpInput)
{

    DPF("***GetVideoPortLine32");

    // need channel poiner for this!
    if( GLOBDATAPTR->NvDevFlatVPE == (DWORD) NULL ) {
        lpInput->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
    }

    if (pMySurfaces->dwVideoPortStatus == VP_NOT_RUNNING) {
        //DPF("   Video is not active!!!");
        lpInput->dwLine = 0;
       lpInput->ddRVal = DDERR_VIDEONOTACTIVE;
    } else {
     /*
     * Readback the current line number and put it in
     * lpInput->dwLine
     */

        lpInput->dwLine = getCurLine();
        lpInput->ddRVal = DD_OK;

    }

    return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoPortConnectInfo
 *
 * This is the old:
 * Returns the GUIDs describing the connections that can be supported.
 * Think of a GUID simply as a 128 bit FOURCC that you don't have to
 * register.  This function is required.

 * And this is the new:
 * Fills in specified array of connections
 *
 */
DWORD __stdcall GetVideoPortConnectInfo (LPDDHAL_GETVPORTCONNECTDATA lpInput)
{
    /*
     * If lpInput->lpGUIDs is NULL, simply return the number of GUIDS
     * supported
     */

    // eventually we should check dwPortId if there are more than one port in operation.
    // however since all the port will likely have the same capabilities maybe it's not an
    // issue

    DPF("***GetVideoPortConnectInfo");

#if 0
    lpInput->dwNumEntries = 1;
    if(lpInput->lpConnect == NULL) {
        // this means that Dx is looking for the number of ways you can connect so that it can
        // allocate a structure for the next time around
        lpInput->ddRVal = DD_OK;
    } else {
        // fill in the one structure that we asked for..
        memcpy (&(lpInput->lpConnect->guidTypeID), &DDVPTYPE_CCIR656, sizeof (GUID));
        lpInput->lpConnect->dwPortWidth = 8;
        lpInput->lpConnect->dwFlags = MY_CONNECTION_CAPS;
    }
#else
    lpInput->dwNumEntries = 2;
    if(lpInput->lpConnect == NULL) {
        // this means that Dx is looking for the number of ways you can connect so that it can
        // allocate a structure for the next time around
        lpInput->ddRVal = DD_OK;
    } else {
        // fill in the one structure that we asked for..
        memcpy (&(lpInput->lpConnect[0].guidTypeID), &DDVPTYPE_CCIR656, sizeof (GUID));
        lpInput->lpConnect[0].dwPortWidth = 8;
        lpInput->lpConnect[0].dwFlags = MY_CONNECTION_CAPS;
        lpInput->lpConnect[0].dwSize = sizeof(DDVIDEOPORTCONNECT);
        memcpy (&(lpInput->lpConnect[1].guidTypeID), &DDVPTYPE_CCIR656, sizeof (GUID));
        lpInput->lpConnect[1].dwPortWidth = 16;
        lpInput->lpConnect[1].dwFlags = MY_CONNECTION_CAPS;
        lpInput->lpConnect[1].dwSize = sizeof(DDVIDEOPORTCONNECT);
    }

#endif
    return DDHAL_DRIVER_HANDLED;

}


/*
 * DestroyVideoPort32
 *
 * This optional function notifies the HAL when the video port
 * has been destroyed.
 */
DWORD __stdcall DestroyVideoPort32 (LPDDHAL_DESTROYVPORTDATA lpInput)
{

    DPF("***DestroyVideoPort32");

#ifdef USEVPP
#ifdef ENABLE_VPP_DISPATCH_CODE
// This code is no longer used but may someday be useful.
    // Restore the original priorities
    pDriverData->vppDispatch.dwCommand = VPPDISPATCH_RESTOREPRIORITY;
    SetEvent(pDriverData->vppDispatch.hSignalGo3);
#endif
#endif

    pMySurfaces->ImageCallbackRoutine = NULL;
    pMySurfaces->VBICallbackRoutine = NULL;

    tearDownVP();

    nvTimerPtr = NULL;

    lpInput->ddRVal = DD_OK;


    return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoPortFlipStatus32
 *
 * This required function allows DDRAW to restrict access to a surface
 * until the physical flip has occurred, allowing doubled buffered capture.
 */

    /*
     * If the physical flip has not yet occurred, return
     * DDERR_WASSTILLDRAWING
     */

DWORD __stdcall GetVideoPortFlipStatus32 (LPDDHAL_GETVPORTFLIPSTATUSDATA lpInput)
{

    U032    dwIndex;

    DPF("***GetVideoPortFlipStatus32");

#if 0
    if( GLOBDATAPTR->NvDevFlatVPE == NULL ) {
        lpInput->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
    }

#endif
    if( pMySurfaces->dwVideoPortStatus == VP_NOT_RUNNING ) {
    lpInput->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    // search through all of our known surfaces looking for the one it's curious about
    for (dwIndex = 0; dwIndex < pMySurfaces->numberOfSurfaces ; dwIndex++) {
        if (pMySurfaces->Surfaces[dwIndex]->pVidMem == lpInput->fpSurface) {
            // this means we've found the surface that DX is curious about
            if( pMySurfaces->Surfaces[dwIndex]->pNvNotify == NULL ) {
                ASSERT(1==0);
                DPF("   NOTIFY WAS NULL  !!!!!!!!!!!");
            lpInput->ddRVal = DD_OK;
                return DDHAL_DRIVER_HANDLED;
            }


            if( pMySurfaces->Surfaces[dwIndex]->bAutoFlip ) {
                // in the case of auto-flipping just always say we're done...
                lpInput->ddRVal = DD_OK;
            } else {
                if (pMySurfaces->bFlipRequested == TRUE ) {
                    lpInput->ddRVal = DDERR_WASSTILLDRAWING;
                } else {
                    lpInput->ddRVal = DD_OK;
                }
            }
            // return here... we found the surface
            return DDHAL_DRIVER_HANDLED;
        }
    }

    DPF("   ***FlipStatus having trouble  --> Surface does");
    DPF("          not exist in my list of surfaces");
    lpInput->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;
}


/*
 * FlipVideoPort32
 *
 * This function is required
 *
 * Issues:
 *          Correct use of notifiers
 *          Updating surface logging info
 *          What if new surface has not got same or less capabilites as replaced surface

 *          Does not work because class 66 doesn't allow insertion of buffers
 *
 */

/*
important:
            Curr surface should be known to us
            Targ surface could be new

            both surfaces should have this flag: DDSCAPS_LIVEVIDEO set in ->ddsCaps structure
*/
DWORD __stdcall FlipVideoPort32 (LPDDHAL_FLIPVPORTDATA lpInput)
{

    /*
     * Program registers to do the actual flip
     */

    /*
     * Save information for BOTH lpSurfCurr so we can know in the future
     * when the physical flip has occurred.
     */


    // Check that both surfaces are in our list
    U032    newSurfaceIndex;
    U032    oldSurfaceIndex;
        //  U032    counter;
    DPF("***FlipVideoPort32");
    if( GLOBDATAPTR->NvDevFlatVPE == (DWORD) NULL ) {
        lpInput->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
    }
    lpInput->ddRVal = DD_OK;

    oldSurfaceIndex = findSurface(lpInput->lpSurfCurr);
    if(oldSurfaceIndex  != SURFACENOTFOUND ) {
        newSurfaceIndex = findSurface(lpInput->lpSurfTarg);
        if(newSurfaceIndex == SURFACENOTFOUND ) {
            // in the case of non-interleaved surfaces this might be even more different
            // because we have essentially to replace TWO places where the old surface might be
            // residing...  not just one   non-auto flip SUCKS.
            if( oldSurfaceIndex < pMySurfaces->VBIstart ) {
                replaceSurfaceWithSurface(oldSurfaceIndex,lpInput->lpSurfTarg, FALSE);
            } else {
                replaceSurfaceWithSurface(oldSurfaceIndex,lpInput->lpSurfTarg, TRUE);
            }
            newSurfaceIndex = oldSurfaceIndex;
        }
        pMySurfaces->bFlipRequested = TRUE;

        if(newSurfaceIndex != SURFACENOTFOUND ) {
#if 0
            //  Now do some stuff... uh.. what?

            // Find out which of the buffers what programmed for the old surface
            U032    dwBufferIndex = NOSURFACEPROGRAMED;
            {
                U032 i;
                for(i=0;i<4;i++) {
                    if(oldSurfaceIndex == pMySurfaces->CurrentBufferSurface[i] ) {
                        dwBufferIndex = i;
                        break;
                    }
                }
                if (i == 4 ) {
                    DPF("   Not sure which buffer was attached to the Current Surface in FlipVideoPort");
                    return DDHAL_DRIVER_NOTHANDLED;
                }
            }


            //  We could wait here until we know the hardware is done...
            //  instead we'll just check it real quick and print a whiner if it's not done
            //  and then fail
            {
                NvNotification*     pNotify = pMySurfaces->Surfaces[oldSurfaceIndex]->pNvNotify;
                if(pNotify != NULL) {
                    if (pNotify->status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS ) {
                        DPF("   Attempting to flip out a surface which is still in progress");
                        // we should hang out here until it's done....
                        counter = 0;
                        while((pNotify->status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS ) && (counter < 3000000)) {
                            counter++;
                        }
                    }
                    // check to see if we've had an error
                    //    there are LOTS of these....
                    if ( (pNotify->status != NV04D_NOTIFICATION_STATUS_IN_PROGRESS ) |
                          (pNotify->status != NV04D_NOTIFICATION_STATUS_DONE_SUCCESS ) |
                          (pNotify->status != NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED ) ){
                        DPF("   Attempting to flip out a surface which had an error during capture");
                        //return DDHAL_DRIVER_NOTHANDLED;
                    }
                } else {
                    DPF("   Attempting to flip out a surface where the notifier was NULL");
                    return DDHAL_DRIVER_NOTHANDLED;
                }
            }

#endif
            // Ok, program up the switch
            //ProgramBufferWithSurface(dwBufferIndex,newSurfaceIndex,FALSE);


        } else {
            DPF("   Unable to find Target Surface during FlipVideoPort32");
            DPF("   There was a note that we could be receiving new surfaces ");
            DPF("                      ( Tobin or MS ?)..... need to add code for this");

            return DDHAL_DRIVER_NOTHANDLED;
        }

    } else {
        DPF("   Unable to find Current Surface during FlipVideoPort32");
        return DDHAL_DRIVER_NOTHANDLED;
    }

    lpInput->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;
}

#if 0
U032 startSurfaces(U032 bInterleave, VPSTATE*   pVideoPortStatus ) {
    U032    rValue = DD_OK;
    VPSTATE myState = *pVideoPortStatus;
    // figure out which buffers to program up and launch them...
    if(bInterleave) {
         DPF("   Now Launching surfaces.... INTERLEAVED");
    } else {
         DPF("   Now Launching surfaces.... NOT INTERLEAVED");
    }
    // zero out the last overlay scaler size so we're sure it gets reprogrammed
    pMySurfaces->lastsrcDeltaY = 0;
    pMySurfaces->bStopVP = FALSE;
    if( bInterleave ) {
        // both buffers will point to the same surface
        if( pMySurfaces->VBIstart >0 ) {
            if( ProgramBufferWithSurface(0,0,FALSE) )
                rValue = DDERR_INVALIDPARAMS;

            // since this is interleave always start the second buffer with the first surface
            if( ProgramBufferWithSurface(1,0,FALSE) )
                rValue = DDERR_INVALIDPARAMS;
            myState |= VP_IMAGE_CAPTURING;
        }
    } else {

        // buffers will point to consecutive surfaces
        if( pMySurfaces->VBIstart >0 ) {
            if( ProgramBufferWithSurface(0,0,FALSE) )
                rValue = DDERR_INVALIDPARAMS;
            myState |= VP_IMAGE_CAPTURING;
        }
        // check for another surface
        if( pMySurfaces->VBIstart > 1 ) {
            if( ProgramBufferWithSurface(1,1,FALSE) )
                rValue = DDERR_INVALIDPARAMS;
        } else {
            // fire up the second buffer at the first surface
            if( ProgramBufferWithSurface(1,0,FALSE) )
                rValue = DDERR_INVALIDPARAMS;
        }
    }

    // Now do VBI
    // start first vbi on first surface
    if( (pMySurfaces->numberOfSurfaces - pMySurfaces->VBIstart) > 0 ) {
        if( ProgramBufferWithSurface(2,pMySurfaces->VBIstart,FALSE))
                rValue = DDERR_INVALIDPARAMS;
        myState |= VP_VBI_CAPTURING;

        // now check to see if we have another surface
        if( (pMySurfaces->numberOfSurfaces - pMySurfaces->VBIstart) > 1 ) {
            if( ProgramBufferWithSurface(3,pMySurfaces->VBIstart+1,FALSE))
                    rValue = DDERR_INVALIDPARAMS;
        } else {
            // set second buffer to first surface
            if( ProgramBufferWithSurface(3,pMySurfaces->VBIstart+0,FALSE))
                    rValue = DDERR_INVALIDPARAMS;
        }
    }
    *pVideoPortStatus = myState;

    return rValue;
}

#endif

U032 startNV3DelayedStart(U032  bInterleave, VPSTATE*   pVideoPortStatus, U032 milliSecondsOfDelay ) {

    // ain't nothing happenin here yet.

    // First thing we're goin to do is paint that surface BLACK so as folks don't be noticin' we's gonna do the
    // delay factor for our masters up at microsoft.

    if(milliSecondsOfDelay > 5 )
    {
        U032    n = 2;
        U032    q;

        if(pMySurfaces->VBIstart <2 )
            n = 1;
        if(pMySurfaces->VBIstart <1 )
            return 0;
        for(q=0;q<n;q++) {
            // length in Long words
            U032    length = ( pMySurfaces->Surfaces[q]->dwPitch * pMySurfaces->Surfaces[q]->dwHeight ) / 4;
            U032    startOff = pMySurfaces->Surfaces[q]->pVidMem ;
            U032    i;
            U032*   pOverlay = (U032*) ((U032)startOff);
            for(i=0; i< length ; i++ ) {
                *pOverlay = 0x10801080;
                pOverlay++;
            }
        }
    }

// deficiencies in NV32.h

    nvMyVPNotifiers[NUM004OFFSET].status        = NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED;

    pMySurfaces->pVPChanPtr->subchannel[0].SetObject  = MY_TIMER_OBJECT;

// get a 0.75 second delay in nanoseconds
#define NV3DELAYTIME ( milliSecondsOfDelay*1000*1000 )
    {
        U032    low;
        U032    low1;
        U032    high;

        getCurrentNanoTimer(&high, &low);
        low1 = low;


        low = low + NV3DELAYTIME;
        if( low < low1 ) {
            high = high + 1;
        }
        pMySurfaces->pVPChanPtr->subchannel[0].nv01Timer.SetAlarmTime.nanoseconds[0] = low;
        pMySurfaces->pVPChanPtr->subchannel[0].nv01Timer.SetAlarmTime.nanoseconds[1] = high;
        pMySurfaces->pVPChanPtr->subchannel[0].nv01Timer.SetAlarmNotify =
            NV004_SET_ALARM_NOTIFY_WRITE_THEN_AWAKEN;

        // ok, 3/4 second later we should get a notify!
    }

    //return startSurfaces(bInterleave, pVideoPortStatus );
    return DD_OK;

}


/*
 * UpdateVideoPort32
 *
 * This required function sets up the video port
 */

/* Questions:
 *          What if I want VBI latching while image is not latching ?
 */

DWORD __stdcall UpdateVideoPort32 (LPDDHAL_UPDATEVPORTDATA lpInput)
{

    VPERRORS myErrors;
    U032        bAutoflip;

    DPF("***UpdateVideoPort32");
    if( GLOBDATAPTR->NvDevFlatVPE == (DWORD) NULL ) {
#ifdef NV3
    // this is added to attempt to stop the writing of stop commands during mode switch
    // since it appears that they stop the video stream after receiving surface lost commands
    pMySurfaces->dwVideoPortStatus = VP_NOT_RUNNING;
#endif
        lpInput->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
    }

// Since bruce changed the order of initialization, we should check if we need to reload this
    if(pMySurfaces->pOverlayChanPtr == NULL) {
        DPF("Late overlay channel update!");

        pMySurfaces->pOverlayChanPtr = (NvChannel*) pDriverData->NvDevVideoFlatPio;


    }


    lpInput->ddRVal = DD_OK;

    {
        /*
         * Turn off the video port
         */
//CODE
        DPF("   now Stopping the Video Port");
        // prevent future interrupts from doing anything
        pMySurfaces->bThreadRunning = FALSE;
        // tell the classes to stop
        StopVP();
        // zero out the notifiers

        {
            U032 i;
            for(i=0;i<NUM04DNOTIFIER;i++ ) {
                nvMyVPNotifiers[i+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED;
                nvMyVPNotifiers[i+NUM04DOFFSET].info32 = 0;
                nvMyVPNotifiers[i+NUM04DOFFSET].info16 = 0;
                nvMyVPNotifiers[i+NUM04DOFFSET].timeStamp.nanoseconds[0] = 0;
                nvMyVPNotifiers[i+NUM04DOFFSET].timeStamp.nanoseconds[1] = 0;
            }
        }
        pMySurfaces->dwVideoPortStatus = VP_NOT_RUNNING;

    }

    if (lpInput->dwFlags != DDRAWI_VPORTSTOP) {
#ifdef NV3
        bDelayNV3 = FALSE;
#endif //NV4
        if (lpInput->dwFlags == DDRAWI_VPORTSTART) {
            DPF("   now Starting Video Port for the first time");

        // This is the first round....
#ifdef NV3
            bDelayNV3 = TRUE;
#endif  //NV4

        }

        DPF("   now updating the video port");

        {


            // print some stuff out about the flags we're lookin at:
            if( pMySurfaces->bInvertedFields ) {
                DPF("      field polarity               inverted");
            } else {
                DPF("      field polarity               normal");
            }

            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_AUTOFLIP  ) {
                DPF("      FLAG DVP_AUTOFLIP            on");
            } else {
                DPF("      FLAG DVP_AUTOFLIP            off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_CONVERT       ) {
                DPF("      FLAG DDVP_CONVERT            on");
            } else {
                DPF("      FLAG DDVP_CONVERT            off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_CROP                  ) {
                DPF("      FLAG DDVP_CROP               on");
            } else {
                DPF("      FLAG DDVP_CROP               off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE            ) {
                DPF("      FLAG DDVP_INTERLEAVE         on");
            } else {
                DPF("      FLAG DDVP_INTERLEAVE         off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_MIRRORLEFTRIGHT       ) {
                DPF("      FLAG DDVP_MIRRORLEFTRIGHT    on");
            } else {
                DPF("      FLAG DDVP_MIRRORLEFTRIGHT    off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_MIRRORUPDOWN          ) {
                DPF("      FLAG DDVP_MIRRORUPDOWN       on");
            } else {
                DPF("      FLAG DDVP_MIRRORUPDOWN       off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_PRESCALE              ) {
                DPF("      FLAG DDVP_PRESCALE           on");
            } else {
                DPF("      FLAG DDVP_PRESCALE           off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPEVENFIELDS        ) {
                DPF("      FLAG DDVP_SKIPEVENFIELDS     on");
            } else {
                DPF("      FLAG DDVP_SKIPEVENFIELDS     off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPODDFIELDS         ) {
                DPF("      FLAG DDVP_SKIPODDFIELDS      on");
            } else {
                DPF("      FLAG DDVP_SKIPODDFIELDS      off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SYNCMASTER                ) {
                DPF("      FLAG DDVP_SYNCMASTER         on");
            } else {
                DPF("      FLAG DDVP_SYNCMASTER         off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_VBICONVERT                ) {
                DPF("      FLAG DDVP_VBICONVERT         on");
            } else {
                DPF("      FLAG DDVP_VBICONVERT         off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_VBINOSCALE                ) {
                DPF("      FLAG DDVP_VBINOSCALE         on");
            } else {
                DPF("      FLAG DDVP_VBINOSCALE         off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_OVERRIDEBOBWEAVE      ) {
                //pMySurfaces->bInvertedFields = TRUE;
                DPF("      FLAG DDVP_OVERRIDEBOBWEAVE   on");
            } else {
                DPF("      FLAG DDVP_OVERRIDEBOBWEAVE   off");
            }

            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_IGNOREVBIXCROP        ) {
                DPF("      FLAG DDVP_IGNOREVBIXCROP     on");
            } else {
                DPF("      FLAG DDVP_IGNOREVBIXCROP     off");
            }


        }

        // Decide which capture mode to be in given if we're trying to skip some types of fields


        if( lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPEVENFIELDS ) {
            pMySurfaces->CurrentCaptureMode = ODDODD;
        } else if ( lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPODDFIELDS ) {
            pMySurfaces->CurrentCaptureMode = EVENEVEN;
        } else {
            if(pMySurfaces->bInputInterLaced)
                pMySurfaces->CurrentCaptureMode = EVENODD;
            else
                pMySurfaces->CurrentCaptureMode = PROGRESSIVE;
        }

        if( lpInput->lpVideoInfo->dwVPFlags & DDVP_AUTOFLIP ) {
            bAutoflip = TRUE;
        } else {
            bAutoflip = FALSE;
        }

        if( lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE ) {
            pMySurfaces->CurrentScanMode = INTERLEAVBUF;
        } else {
            pMySurfaces->CurrentScanMode = SEPERATEBUF;
        }

        {
            // Here's where we're going to try to figure out where to put things in the vertical and horz
            // dimensions

            // At key thing here are the two different modes which people are using to capture VBI
            // one is that the VBI data is captured to the very beginning of the VIDEO surface in one big surface
            // the other mode is with a seperate surface

            // we can detect which mode by examining the number of VBI surface if > 0 we're in the second mode

            // When there ARE VBI surfaces, then we should jam the Video data right to the very beginning of the
            // video surface, since we know this is where it will be expected.

            // additionally we've reported DDVPCONNECT_DISCARDSVREFDATA is true which means
            // "/*
            //   * Indicates that any data written to the video port during the VREF
            //   * period will not be written into the frame buffer. This flag is read only.
            //   */"
           //  MS of course not really defining what the VREF period means in their land.


#define VBIVALIDDATALINE  (0x2)


            if( lpInput->lplpDDVBISurface == NULL ) {
                // this indicates that there are NO VBI surfaces associated with this video port update.
                // therefore we should send all the line to the Image surface

                // Ok, given the info the VIP2.0 spec about the "official NTSC" signal
                // the Vbit will go low around between line 9 and 10.
                // Since we're counting from line 1 when we do our Y-crop, we need to
                // add in the lines which microsoft has not counted in their system
#define MAGICMICROSOFTOFFSET    (4)
                // so that's the magic offset... let's see if it works!

                pMySurfaces->dwImageStartLine = MAGICMICROSOFTOFFSET;  // send all the data after line 0

                if ( lpInput->lpVideoInfo->dwVPFlags & DDVP_CROP ) {
                    if((lpInput->lpVideoInfo->rCrop.top + MAGICMICROSOFTOFFSET ) > (signed long) pMySurfaces->dwImageStartLine ) {
                        pMySurfaces->dwImageStartLine = lpInput->lpVideoInfo->rCrop.top;
                    }
                }

            } else {
                // there are some VBI surfaces associated with this video port,
                // so we should send the data to the VBI surfaces where applicable
                pMySurfaces->dwVBIStartLine = VBIVALIDDATALINE; // at least we're not starting with zero this first four are always
                                                                            // empty as best as I know

                pMySurfaces->dwVBIHeight = lpInput->lpVideoInfo->dwVBIHeight;

                // Image start line should be one line after the the sum of these two
                // H.AZAR: unless the flag DDVP_IGNOREVBIXCROP is set. In such case we are told to ignore the VBI cropping !!!
                if ((lpInput->lpVideoInfo->dwVPFlags & DDVP_IGNOREVBIXCROP) && (lpInput->lpVideoInfo->dwVPFlags & DDVP_PRESCALE))
                    pMySurfaces->dwImageStartLine = 1 + pMySurfaces->dwVBIStartLine - VBIVALIDDATALINE;
                else
                    pMySurfaces->dwImageStartLine = 1 + pMySurfaces->dwVBIHeight + pMySurfaces->dwVBIStartLine - VBIVALIDDATALINE;

                // if   dwImageStartLine < 1  then things don't work to well
                if(pMySurfaces->dwImageStartLine < 1) pMySurfaces->dwImageStartLine = 1;

                if ( lpInput->lpVideoInfo->dwVPFlags & DDVP_CROP ) {
                    if(lpInput->lpVideoInfo->rCrop.top > (signed long) pMySurfaces->dwImageStartLine ) {
                        pMySurfaces->dwImageStartLine = lpInput->lpVideoInfo->rCrop.top;
                    }
                }
            }



            // this is the only way I know how to do the check for vertical cropping
            if ( lpInput->lpVideoInfo->dwVPFlags & DDVP_CROP ) {
                pMySurfaces->dwInHeight = (DWORD)lpInput->lpVideoInfo->rCrop.bottom - lpInput->lpVideoInfo->rCrop.top;
                pMySurfaces->dwInWidth  = lpInput->lpVideoInfo->rCrop.right - lpInput->lpVideoInfo->rCrop.left;
                DPF("   UPDATE:         crop TOP %d",lpInput->lpVideoInfo->rCrop.top);
            } else {
                pMySurfaces->dwInHeight = lpInput->lpVideoPort->ddvpDesc.dwFieldHeight;
                pMySurfaces->dwInWidth  = lpInput->lpVideoPort->ddvpDesc.dwFieldWidth;
            }

            // this is something of a hack I suppose
            // pMySurfaces->dwInHeight = pMySurfaces->dwInHeight;

            // H.AZAR: in the case the DDVP_IGNOREVBIXCROP flag is set we must substract the VBIHeight from InHeight
            if ((lpInput->lpVideoInfo->dwVPFlags & DDVP_IGNOREVBIXCROP) && (lpInput->lpVideoInfo->dwVPFlags & DDVP_PRESCALE))
                pMySurfaces->dwInHeight -= pMySurfaces->dwVBIHeight;

            // if we're prescaling then do something
            if (DDVP_PRESCALE & lpInput->lpVideoInfo->dwVPFlags) {
                pMySurfaces->dwPreHeight = lpInput->lpVideoInfo->dwPrescaleHeight;
                pMySurfaces->dwPreWidth  = lpInput->lpVideoInfo->dwPrescaleWidth;
            } else {
                pMySurfaces->dwPreHeight = pMySurfaces->dwInHeight;
                pMySurfaces->dwPreWidth = pMySurfaces->dwInWidth;
            }


            pMySurfaces->dwOriginX = lpInput->lpVideoInfo->dwOriginX;
            pMySurfaces->dwOriginY = lpInput->lpVideoInfo->dwOriginY;
        }

        switch (pMySurfaces->CurrentCaptureMode) {
                case EVENODD:
                    DPF("   UPDATE:     capture mode EVENODD");
                    break;
                case EVENEVEN:
                    DPF("   UPDATE:     capture mode EVENEVEN");
                    break;
                case ODDODD:
                    DPF("   UPDATE:     capture mode ODDODD");
                    break;
        }
        switch (pMySurfaces->CurrentScanMode) {
                case SEPERATEBUF:
                    DPF("   UPDATE:        scan mode SEPERATEBUF");
                    break;
                case INTERLEAVBUF:
                    DPF("   UPDATE:        scan mode INTERLEAVBUF");
                    break;
        }

        DPF("   UPDATE: image start line %d",pMySurfaces->dwImageStartLine);
        DPF("   UPDATE: image in dimens %d,%d",pMySurfaces->dwInWidth,pMySurfaces->dwInHeight);
        DPF("   UPDATE: image pre dimens %d,%d",pMySurfaces->dwPreWidth,pMySurfaces->dwPreHeight);
        DPF("   UPDATE:   image position %d,%d",pMySurfaces->dwOriginX,pMySurfaces->dwOriginY);

        myErrors = replaceSurfaceList(lpInput->dwNumAutoflip,lpInput->dwNumVBIAutoflip,
                                        lpInput->lplpDDSurface, lpInput->lplpDDVBISurface,bAutoflip);

        pMySurfaces->dwVPFlags = lpInput->lpVideoInfo->dwVPFlags;
        if( myErrors == NOVPERROR ) {
          lpInput->ddRVal = startNV3DelayedStart(lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE, &(pMySurfaces->dwVideoPortStatus), 0);
        }   // NOVPERROR
        else {
          // seems like we can't replace the surface... bail out!
          lpInput->ddRVal = DDERR_INVALIDPARAMS;
          return DDHAL_DRIVER_HANDLED;
        }
    }  // DDRAWI_VPORTSTOP

    // this is sort of a big hack since things aren't actually running yet, but DirectShow seems to require it

#ifdef NV3
    //pMySurfaces->dwVideoPortStatus = VP_BOTH_CAPTURING;
#else
    pMySurfaces->dwVideoPortStatus = VP_BOTH_CAPTURING;
#endif
    return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoSignalStatus32
 *
 * This function is required
 */

DWORD __stdcall GetVideoSignalStatus32 ( LPDDHAL_GETVPORTSIGNALDATA lpInput) {

    U032    dwIndex;
    ASSERT(lpInput != NULL);

    DPF("***GetVideoSignalStatus32");
    if( GLOBDATAPTR->NvDevFlatVPE == (DWORD) NULL ) {
        lpInput->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
    }

    if( lpInput == NULL)
    {
        DPF("   Input NULL in GetVideoSignalStatus32");
        return DDHAL_DRIVER_NOTHANDLED;
    }
    // If the video port is not running, then we just don't know...
    if( pMySurfaces->dwVideoPortStatus == VP_NOT_RUNNING ) {
        DPF("   could not get the signal status, the video port is not running");
        // we'll return no signal in this case....
        lpInput->dwStatus = DDVPSQ_NOSIGNAL;
        lpInput->ddRVal = DDERR_VIDEONOTACTIVE;

        return DDHAL_DRIVER_HANDLED;
    }

    lpInput->ddRVal = DD_OK;
    // default for now is that the signal is good
    lpInput->dwStatus = DDVPSQ_SIGNALOK;
    // first check the notifiers to see if there has been ANY sync
    //     do this by seeing if the notify times are none zero

return DDHAL_DRIVER_HANDLED;

    {
        U032    probablyRunning = FALSE;
        for (dwIndex=0;dwIndex<pMySurfaces->numberOfSurfaces;dwIndex++) {
            if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
                if (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0]!=0) {
                    probablyRunning = TRUE;
                    break;
                }
            }
        }

        // if the timer are zero then wait at least 1/24 of a second and check again.
        if(!probablyRunning) {
            // find current time
            U032     tempTime;
            tempTime = getMilliTime();
            //now wait for 1/24 of a second
            while(tempTime + (1000/24) > getMilliTime());
            // and then check one more time for a possible completion
            for (dwIndex=0;dwIndex<pMySurfaces->numberOfSurfaces;dwIndex++) {
                if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
                    if (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0]!=0) {
                        probablyRunning = TRUE;
                        break;
                    }
                }
            }

            // if it's still non zero report no signal
            if(!probablyRunning) {
                lpInput->dwStatus = DDVPSQ_NOSIGNAL;
            }

        }
    }

    // have we already decided that the signal is bad...?
    if( lpInput->dwStatus != DDVPSQ_NOSIGNAL ) {

        // Now the default is that the signal is bad
        lpInput->dwStatus = DDVPSQ_NOSIGNAL;

        // check to see that at least one of of the notifiers is LESS than 1/24 of a second
        // hopefully there's been _some_ event in video land in the last 1/24 of a second
        for (dwIndex=0;dwIndex<pMySurfaces->numberOfSurfaces;dwIndex++) {
            if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
                if (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0]!=0) {
                    U032 diff;
                    // ok, we've got a non-zero surface, let's check to see how recent it is
                    U032    BigCurrentTime;
                    U032    SmallCurrentTime;

                    getCurrentNanoTimer(&BigCurrentTime,&SmallCurrentTime);
                    if(pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[1] < BigCurrentTime ) {
                        // we've got a wrap around situation.  this means that we need to work in weirder math
                        diff = (
                                    ((0x80000000)  - (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0] >> 1))
                                    +  (SmallCurrentTime >> 1)
                                 ) << 1;
                    } else {
                        // do a simple subtraction
                        diff = SmallCurrentTime - pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0];
                    }
                    //diff now has the delta between the notify and "now"
                    // if the notifier is LESS than a frame period then we've got a signal
                    if(diff < MAXFRAMEPERIOD ) {
                        lpInput->dwStatus = DDVPSQ_SIGNALOK;
                    } else {
                        diff = 0;
                        // this is a place for chris's break point's while debugging
                    }

                }
            }
        }

    }

    return DDHAL_DRIVER_HANDLED;
}


/*
 * WaitForVideoPortSync32
 *
 * This function is required
 */


DWORD __stdcall WaitForVideoPortSync32 (LPDDHAL_WAITFORVPORTSYNCDATA lpInput)
{
    DPF("***WaitForVideoPortSync32");

    if( GLOBDATAPTR->NvDevFlatVPE == (DWORD) NULL ) {
        lpInput->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
    }

    lpInput->ddRVal = DDVPSQ_NOSIGNAL;

    // if the port is running then
    if (pMySurfaces->dwVideoPortStatus != VP_NOT_RUNNING) {
        if( lpInput->dwFlags & DDVPWAIT_BEGIN ) {
            // wait for a vsync start.   timeout in lpInput->dwTimeOut
            U032    bigTime;
            U032    smallTime;
            U032    milliTime;
            U032    recentTime[MAXVPSURFACES];
            U032    dwIndex;
            U032    searchMAX;

        // find out what time it is now
            getCurrentNanoTimer(&bigTime, &smallTime);
            milliTime = getMilliTime();

            if( pMySurfaces->VBIstart == 0 ) {
                // we're only running VBI so check ALL the surfaces
                searchMAX = pMySurfaces->numberOfSurfaces;
            } else {
                // there is at least one image surface, so check for that
                searchMAX = pMySurfaces->VBIstart;
            }
            //find the current notifiers for the IMAGE surfaces
            for (dwIndex=0;dwIndex<searchMAX;dwIndex++) {
                if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
                    recentTime[dwIndex] = pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0];
                } else {
                    recentTime[dwIndex] = 0;
                }
            }
            while( (getMilliTime() < ( milliTime + lpInput->dwTimeOut)) && ( lpInput->ddRVal == DDVPSQ_NOSIGNAL) ) {
                for (dwIndex=0;dwIndex<searchMAX;dwIndex++) {
                    if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
                        if( recentTime[dwIndex] < pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0] ) {
                            // ok, ONE Of the notifiers moved foward
                            lpInput->ddRVal = DD_OK;    //  We found a sync
                        }
                    }
                }
            }
            // start a while
        } else if (lpInput->dwFlags & DDVPWAIT_END ) {
            //  timeout in lpInput->dwTimeOut
            // we could wait for ysync that then see which buffer we're on then wait for the line counter
            // to change  .. YUCK
            DPF("   Sorry, don't handle waiting for the end");

            return DDHAL_DRIVER_NOTHANDLED;
        } else if (lpInput->dwFlags & DDVPWAIT_LINE ) {
            //timeout in lpInput->dwTimeOut
                // lpInput ->dwLine
            DPF("   Sorry, can't wait for a particular line");
            return DDHAL_DRIVER_NOTHANDLED;
        };

    }// videoport status

    return DDHAL_DRIVER_HANDLED;
}

#endif //(!defined(WINNT) && !defined(NVPE))   // WINNT BUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\Surfaces.cpp ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
*                                                                           *
* Module: Surfaces.cpp                                                      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           3/26/98                                          *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (!defined(WINNT) && !defined(NVPE))

// we're going to use this definition so that we can
// do this under NT or Win9x "MULTI-MON" which is a cheeser way of saying
// that we're using the NValloc architecture
#define USE_NV_ALLOC_ARCH

// unit specific includes
#include "VidTex.h"

// Hey Folks some storage right here
extern vpSurfaces*          pMySurfaces;
//vpSurfaces            MySurfaces;

NvChannel*          pMyNvChan = NULL;
extern NvNotification*  nvMyVPNotifiers;

#define STARTINGBUF (99)
#define UNKNOWNBUF  (123)


// This is a hack to fix up stuff which a contradiction between the two known systems
// CODE this should be cleaned up as the NV4 style RM moves into NV3 land


BOOLEAN checkScalingOk(U032 in, U032 out ) {
    U032 xIn,yIn,xOut,yOut;
    U032    xRatio;
    /*  Scaling works like this... the output MUST be smaller than the input, and the X ratio must be an integer value
         there is no limit on the Y ratio since it's just a line dropping system
    */

    xIn  = in & 0xFFFF;
    yIn  = in >> 16;
    xOut = out & 0xFFFF;
    yOut = out >> 16;

    if( xIn < xOut ) {
        DPF ("   In dimension X is SMALLER than out X dimension %d, %d",xIn,xOut);
        return FALSE;
    }
    if( yIn < yOut ) {
        DPF ("   In dimension Y is SMALLER than out Y dimension %d, %d",yIn,yOut);
        return FALSE;
    }
    if( xIn % xOut != 0 ) {
        DPF ("   X dimension In does not evenly divide by X out %d, %d",xIn,xOut);
        return FALSE;
    }
    xRatio = xIn / xOut;

    switch (xRatio) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 6:
            case 8:
            case 12:
            case 16:
            case 24:
                break;
            default:
                {
                    DPF ("   Not one of the good scale factors %d, %d, %d",xIn,xOut,xRatio);
                    return FALSE;
                }
                break;
    }

    return TRUE;
}


BOOL GetField(void) {
    BOOL    retvalue = TRUE;
    U032    whiletime = 0;
    FIELDTYPE aField = UNKNOWN;

    // we're not hitting the channel
    //INIT_FREE_COUNT(0);


    // clear the notifiers
    nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

    // put the object into the channel
#ifdef NV3
    pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else
    pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4

    // fire off the command
    pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[0] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;
    pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[1] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;

    // wait for completion
    while ( ((nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
                 (nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)+NUM04DOFFSET].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS))    &&
                (whiletime++ < WHILETIMEOUT) );

    // only one of these should be running right now....
    if( nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].info16 == 0x1 /*NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET*/ ) {
        aField = pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[0]]->field;
    }
    if( nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)+NUM04DOFFSET].info16 == 0x1 /*NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET*/ ) {
        aField = pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[1]]->field;
    }

    if(aField == EVEN ) {
        retvalue = TRUE;
    } else {
        retvalue = FALSE;
    }

    return retvalue;
}

U032 checkNvAllocArchError(U032 error) {
    // returns true if there IS an error
    // otherwise false
    switch (error) {
            case NVOS04_STATUS_SUCCESS:
                return 0;
//              DPF("NVOS04_STATUS_SUCCESS");
                break;
            case NVOS04_STATUS_ERROR_OPERATING_SYSTEM:
                DPF("NVOS04_STATUS_ERROR_OPERATING_SYSTEM");
                return error;
                break;
            case NVOS04_STATUS_ERROR_BAD_OBJECT_PARENT:
                DPF("NVOS04_STATUS_ERROR_BAD_OBJECT_PARENT");
                return error;
                break;
            case NVOS04_STATUS_ERROR_BAD_OBJECT_NEW:
                DPF("NVOS04_STATUS_ERROR_BAD_OBJECT_NEW");
                return error;
                break;
            case NVOS04_STATUS_ERROR_BAD_CLASS:
                DPF("NVOS04_STATUS_ERROR_BAD_CLASS");
                return error;
                break;
            case NVOS04_STATUS_ERROR_BAD_OBJECT_ERROR:
                DPF("NVOS04_STATUS_ERROR_BAD_OBJECT_ERROR");
                return error;
                break;
            case NVOS04_STATUS_ERROR_BAD_FLAGS:
                DPF("NVOS04_STATUS_ERROR_BAD_FLAGS");
                return error;
                break;
            case NVOS04_STATUS_ERROR_INSUFFICIENT_RESOURCES:
                DPF("NVOS04_STATUS_ERROR_INSUFFICIENT_RESOURCES");
                return error;
                break;
            default:
                    DPF("UNKNOWN ERROR");
                    return 1;
    }

    return 0;
}

DWORD SetupVP (LPDDHAL_CREATEVPORTDATA lpInput) {
    U032 error;
    U032 i;
    INIT_FREE_COUNT(0);

    pMyNvChan = pMySurfaces->pVPChanPtr;
    if(pMyNvChan == NULL ) {
        //CODE
        error = NvRmAllocChannelPio ((GLOBDATAPTR)->ROOTHANDLE,
                    NV_WIN_DEVICE,
                    MY_VPE_CHANNEL,
                    NV03_CHANNEL_PIO,
                    0,
                    (PVOID*)&(pMySurfaces->pVPChanPtr),
                    NVOS04_FLAGS_FIFO_RUNOUT_IGNORE);
        if(checkNvAllocArchError(error )) {
            DPF("   Warning: Unable to sucessfully complete NvRmAllocChannelPio");
            return DDHAL_DRIVER_NOTHANDLED;
        }


        pMyNvChan = pMySurfaces->pVPChanPtr;

        // Now store a copy in global land so that the brucerator's code can kill the channel on mode switches
        GLOBDATAPTR->NvDevFlatVPE = (U032) pMySurfaces->pVPChanPtr;

    }

    if(pMyNvChan == NULL ) {
        DPF("   Warning: the NV Channel for VPE is not initialized... sorry");
        return DDHAL_DRIVER_NOTHANDLED;
    } else {

            error = NvRmAllocObject(  (GLOBDATAPTR)->ROOTHANDLE,
                                MY_VPE_CHANNEL,
                                MY_EXTERNAL_DECODER_OBJECT,
                                        NV03_EXTERNAL_VIDEO_DECODER
                                );

            if(checkNvAllocArchError(error )) {
                DPF("NVDD: Cannot allocate External Decoder Object %d",MY_EXTERNAL_DECODER_OBJECT);
                return FALSE;
            }
#ifdef NV3
            error = NvRmAllocObject(  (GLOBDATAPTR)->ROOTHANDLE,
                                MY_VPE_CHANNEL,
                                MY_TIMER_OBJECT,
                                        NV_TIMER
                                      );
#else // !NV3
            error = NvRmAllocObject(  (GLOBDATAPTR)->ROOTHANDLE,
                                MY_VPE_CHANNEL,
                                MY_TIMER_OBJECT,
                                NV01_TIMER
                                );
#endif // !NV3
            if(checkNvAllocArchError(error )) {
                DPF("NVDD: Cannot allocate Timer Object %d",MY_TIMER_OBJECT);
                return FALSE;
            }

            // setup Notify Context

            if (NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
                                MY_EXTERNAL_DECODER_NOTIFIER,
                                NV01_CONTEXT_DMA,
                                DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                                DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                                (PVOID)(((U032)nvMyVPNotifiers) + NUM04DOFFSET*sizeof(NvNotification)),
                                (sizeof( NvNotification)*NUM04DNOTIFIER  - 1)
                         ) != NVOS03_STATUS_SUCCESS )
             {
                DPF((1, "NVDD: Cannot allocate notifier context"));
                return FALSE;
             }


            if (NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
                                MY_TIMER_NOTIFIER,
                                NV01_CONTEXT_DMA,
                                DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                                DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                                (PVOID)(((U032)nvMyVPNotifiers) + NUM004OFFSET*sizeof(NvNotification)),
                                (sizeof( NvNotification)*NUM004NOTIFIER  - 1)
                         ) != NVOS03_STATUS_SUCCESS )
             {
                DPF((1, "NVDD: Cannot allocate notifier context"));
                return FALSE;
             }


            // Plug the notifiers into the main object
            // make sure the object is on the channel
#ifdef NV3
            pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else
            pMyNvChan->subchannel[0].SetObject  = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4

            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaNotifies = MY_EXTERNAL_DECODER_NOTIFIER;

            // do something now to put the port into the proper mode...
            if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
              if( lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth == 16 ) {
                  // this is the something
                  DPF((1, "NVDD: Now switching video port to 16 wide mode"));
                  pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImageConfig = 16 ;/* data width, task bit, null data  02f8-02fb*/
              } else if( lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth == 8 ) {
                  DPF((1, "NVDD: Now switching video port to 8 wide mode"));
                  pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImageConfig = 8 ;/* data width, task bit, null data  02f8-02fb*/
              } else {
                  DPF((1, "NVDD: invalid port width"));
              }
            }
#ifdef NV3
            pMyNvChan->subchannel[0].control.object = MY_TIMER_OBJECT;
            pMyNvChan->subchannel[0].timer.SetAlarmNotifyCtxDma = MY_TIMER_NOTIFIER;
#else
            pMyNvChan->subchannel[0].SetObject  = MY_TIMER_OBJECT;
            pMyNvChan->subchannel[0].nv01Timer.SetContextDmaNotifies = MY_TIMER_NOTIFIER;
#endif // NV4


 //**************************************************************************
 // Allocate a DMA context which points to all of video memory. The limit
 // must be page aligned: i.e. limit = (size in bytes of video mem rounded to the
 // closest page boundary) - 1.
 //**************************************************************************

        {
            void*  pFrameBuffer = (void*)(GLOBDATAPTR)->PBASEADDRESS;
            U032     dwFBLen= DWFBUFFERLEN;

            if (NvRmAllocContextDma(    (GLOBDATAPTR)->ROOTHANDLE,
                                            MY_IMAGE0_BUFFER_CONTEXT,
                                            NV01_CONTEXT_DMA,
                                            DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                                            DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                                            pFrameBuffer,
                                    dwFBLen
                                        ) != NVOS03_STATUS_SUCCESS )
            {
              DPF((1, "NVDD: Cannot allocate dma in memory context for MY_IMAGE0_BUFFER_CONTEXT"));
              return FALSE;
            }

             if (NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
                                            MY_IMAGE1_BUFFER_CONTEXT,
                                            NV01_CONTEXT_DMA,
                                            DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                                            DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                                    pFrameBuffer,
                                    dwFBLen
                                  ) != NVOS03_STATUS_SUCCESS )
              {
              DPF((1, "NVDD: Cannot allocate dma in memory context for MY_IMAGE1_BUFFER_CONTEXT"));
              return FALSE;
              }

            if (NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
                                  MY_VBI0_BUFFER_CONTEXT,
                                  NV01_CONTEXT_DMA,
                                  DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                                  DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                                  pFrameBuffer,
                                  dwFBLen
                                  ) != NVOS03_STATUS_SUCCESS )
            {
              DPF((1, "NVDD: Cannot allocate dma in memory context for MY_VBI0_BUFFER_CONTEXT"));
              return FALSE;
            }

            if (NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
                                  MY_VBI1_BUFFER_CONTEXT,
                                  NV01_CONTEXT_DMA,
                                  DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                                  DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                                  pFrameBuffer,
                                  dwFBLen
                                  ) != NVOS03_STATUS_SUCCESS )
            {
              DPF((1, "NVDD: Cannot allocate dma in memory context for MY_VBI1_BUFFER_CONTEXT"));
              return FALSE;
            }

        }


            CHECK_FREE_COUNT(pMyNvChan,10*5);

            // make sure decoder object is in the channel....
#ifdef NV3
            pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else
            pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4
            // plug in our buffer contexts
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[0]     = MY_IMAGE0_BUFFER_CONTEXT;
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[1]     = MY_IMAGE1_BUFFER_CONTEXT;
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[0]       = MY_VBI0_BUFFER_CONTEXT;
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[1]       = MY_VBI1_BUFFER_CONTEXT;

        // Ok, done setting up the various contexts
        // now we should setup the class with some boring default values

            CHECK_FREE_COUNT(pMyNvChan,10*10);

            for( i = 0; i < 2; i++ ) {
                pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[i].sizeIn     = ((240 << 16 ) | 720 );   // *The next four method may fail if the scaling values do not work out properly.
                pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[i].sizeOut = ((240 << 16 ) | 720 );      // changing either In or Out values will modify the scaling values
                pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[i].offset        =0;         //  *indicates DMA "address" as on offset from frame buffer base

                //  we don't actually want to launch any captures at this point

                pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[i].offset      = 0;
                pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[i].size        = 0;
                //  we don't actually want to launch any captures at this point
            }


        // Ok, reset all the notifiers:

            for (i = 0; i < NUMVPNOTIFIERS ; i++ ) {
                nvMyVPNotifiers[i].status       = NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED;
                nvMyVPNotifiers[i].info32   = 0;
                nvMyVPNotifiers[i].info32   = 0;
                nvMyVPNotifiers[i].timeStamp.nanoseconds[0] = 0;
                nvMyVPNotifiers[i].timeStamp.nanoseconds[1] = 0;
            }


            // this means we're going to try for kevin's new cool callback dealy

            /*
             * NvAllocEvent() specifies a Windows event or callback for NV to send to the
             * application after requesting notifications with the
             * NV_OS_WRITE_THEN_AWAKEN style.
             *    first parameter is the NvChannel
             *    second is the object name
             *    third is the notify index
             *    fourth is the notify event type (NV_OS_EVENT_*)
             *    fifth is the lower 32bits of the 64bit event data
             *    sixth is the upper 32bits of the 64bit event data
             */

            // first object we're going to associate will be the MY_EXTERNAL_DECODER_OBJECT
            // we want to different notifiers associated here.

            pMySurfaces->bThreadDead = FALSE;
            pMySurfaces->bThreadRunning = TRUE;

            // I want VBI/Image/ 0 / 1  all to go to the same place


#ifdef NV3
// until someone gets this define in the right header file
#define  NV01_EVENT_KERNEL_CALLBACK                                (0x00000078)
#endif

            {
                U032 status = 0;

                status = NvRmAllocEvent (   (GLOBDATAPTR)->ROOTHANDLE,
                                        MY_EXTERNAL_DECODER_OBJECT,
                                MY_VBI0_BUFFER_EVENT,
                                NV01_EVENT_KERNEL_CALLBACK,
                                        NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0),
                                        (void*)pMySurfaces->pNotifyCallbackProcV0);

                if( status !=  0x0 /* meaning sucess */ ) {
                    DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
                }

                status = NvRmAllocEvent (   (GLOBDATAPTR)->ROOTHANDLE,
                                        MY_EXTERNAL_DECODER_OBJECT,
                                MY_VBI1_BUFFER_EVENT,
                                NV01_EVENT_KERNEL_CALLBACK,
                                        NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1),
                                        (void*)pMySurfaces->pNotifyCallbackProcV1);
               if( status !=  0x0 /* meaning sucess */ ) {
                    DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
                }
                status = NvRmAllocEvent (   (GLOBDATAPTR)->ROOTHANDLE,
                                        MY_EXTERNAL_DECODER_OBJECT,
                                MY_IMAGE0_BUFFER_EVENT,
                                NV01_EVENT_KERNEL_CALLBACK,
                                        NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0),
                                        (void*)pMySurfaces->pNotifyCallbackProcI0);
               if( status !=  0x0 /* meaning sucess */ ) {
                    DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
                }
                status = NvRmAllocEvent (   (GLOBDATAPTR)->ROOTHANDLE,
                                        MY_EXTERNAL_DECODER_OBJECT,
                                MY_IMAGE1_BUFFER_EVENT,
                                NV01_EVENT_KERNEL_CALLBACK,
                                        NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1),
                                        (void*)pMySurfaces->pNotifyCallbackProcI1);
               if( status !=  0x0 /* meaning sucess */ ) {
                    DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
                }

                 // And finally one for the timer
#ifdef NV3
#define NV004_NOTIFIERS_SET_ALARM_NOTIFY                           (1)
#endif
                 status = NvRmAllocEvent    (   (GLOBDATAPTR)->ROOTHANDLE,
                                        MY_TIMER_OBJECT,
                                MY_TIMER_EVENT,
                                NV01_EVENT_KERNEL_CALLBACK,
                                        NV004_NOTIFIERS_SET_ALARM_NOTIFY,
                                        (void*)pMySurfaces->pTimerNotifyProc);
               if( status !=  0x0 /* meaning sucess */ ) {
                    DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
                }

            }   // event alloc block




        // Decrement the number of ports available count
            (pMySurfaces->pDriverData)->dwVideoPortsAvailable--;


    }

    // this sets up the structures for ring0 data transfers
    SetupMTM();

    pMySurfaces->pVidTexSurf = NULL;
#ifndef NV3
    //initTextureSurf();
#endif

    pMySurfaces->SetupComplete = TRUE;
    return DDHAL_DRIVER_HANDLED;
}


void    tearDownVP(void) {
    U032    error;
    U032    i;
    U032    whiletime;
    INIT_FREE_COUNT(0);

    // stop things from running  ( check to make sure the channel is not null by which we'll assume
    //   that things are not running
    // tell the thread to exit
    pMySurfaces->bThreadRunning = FALSE;

    if(pMyNvChan != NULL)
        StopVP();

#ifndef NV3
    //DestroyTextureSurf();
#endif

    TearDownMTM();
#if 0
    {
             error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, NV_DD_DEV_VIDEO, MY_DVD_SUBPICTURE_OBJECT);


            if(checkNvAllocArchError(error )) {
                DPF("NVDD: Cannot deallocate DVD-subpicture Object %d",MY_DVD_SUBPICTURE_OBJECT);
            }
    }
#endif

    // this should wake up the thread
//  NvSetEvent( pMySurfaces->hVPInterruptEvent );

    // wait for it to die
    whiletime = 0;
    while( (!pMySurfaces->bThreadDead) &
            (whiletime++ < WHILETIMEOUT) );
    // make sure that the thread has really exited
    //TerminateThread((HANDLE)pMySurfaces->VpInterruptId,0);




    if(pMyNvChan != NULL ) {
        CHECK_FREE_COUNT(pMyNvChan,12*4);

        // stop the transfers
#ifdef NV3
        pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else
        pMyNvChan->subchannel[0].SetObject  = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4

        if(pMySurfaces->dwVideoPortStatus != VP_NOT_RUNNING ) {
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferImage   = 0;
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferVbi = 0;
        }

    }


#define NOEVENTFREEFUNCTIONYETFOLKS
#ifdef NOEVENTFREEFUNCTIONYETFOLKS
    DPF("Now ditching the EVENTs ");

    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_EXTERNAL_DECODER_OBJECT, MY_IMAGE0_BUFFER_EVENT);
   checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_EXTERNAL_DECODER_OBJECT, MY_IMAGE1_BUFFER_EVENT);
   checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_EXTERNAL_DECODER_OBJECT, MY_VBI0_BUFFER_EVENT);
   checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_EXTERNAL_DECODER_OBJECT, MY_VBI1_BUFFER_EVENT);
   checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_TIMER_OBJECT, MY_TIMER_EVENT);
    checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, pMySurfaces->dwOverlayObjectID, MY_OVERLAY0_BUFFER_EVENT);
    checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, pMySurfaces->dwOverlayObjectID, MY_OVERLAY1_BUFFER_EVENT);
    checkNvAllocArchError(error);


#endif

    DPF("Now setting notifiers to NULL");
    if(pMyNvChan != NULL ) {

// set notifiers to NULL context DMAs
#ifdef NV3
        pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else
        pMyNvChan->subchannel[0].SetObject  = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4

        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaNotifies = 0;


#ifdef NV3
        pMyNvChan->subchannel[0].control.object = MY_TIMER_OBJECT;
        pMyNvChan->subchannel[0].timer.SetAlarmNotifyCtxDma = 0;
#else
        pMyNvChan->subchannel[0].SetObject  = MY_TIMER_OBJECT;
        pMyNvChan->subchannel[0].nv01Timer.SetContextDmaNotifies = 0;
#endif // NV4

// set DMA for transfers to NULL

#ifdef NV3
        pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else
        pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4

        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[0]     = 0;
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[1]     = 0;
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[0]       = 0;
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[1]       = 0;




    // spin waiting for empty fifo
#ifdef NV3
        while(NvGetFreeCount(pMyNvChan, 0) < NV_GUARANTEED_FIFO_SIZE );
#else
        while(NvGetFreeCount(pMyNvChan, 0) < NV06A_FIFO_GUARANTEED_SIZE );
#endif

    }
//  I'm a bit concerned about syncing the FIFO with these NVRM API calls. but we'll let this slide for now

    DPF("Now ditching the Notifiers");
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_EXTERNAL_DECODER_NOTIFIER);
    checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_TIMER_NOTIFIER);
    checkNvAllocArchError(error);



    DPF("Now ditching the Buffer contexts");
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_IMAGE0_BUFFER_CONTEXT);
    if(checkNvAllocArchError(error)) {
        DPF("that was trouble freeing MY_IMAGE0_BUFFER_CONTEXT");
    }
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_IMAGE1_BUFFER_CONTEXT);
    if(checkNvAllocArchError(error)) {
        DPF("that was trouble freeing MY_IMAGE1_BUFFER_CONTEXT");
    }
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_VBI0_BUFFER_CONTEXT);
    if(checkNvAllocArchError(error)) {
        DPF("that was trouble freeing MY_VBI0_BUFFER_CONTEXT");
    }
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_VBI1_BUFFER_CONTEXT);
    if(checkNvAllocArchError(error)) {
        DPF("that was trouble freeing MY_VBI1_BUFFER_CONTEXT");
    }




    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_VPE_CHANNEL, MY_TIMER_OBJECT);
    if(checkNvAllocArchError(error)) {
        DPF("that was trouble freeing MY_TIMER_OBJECT");
    }
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_VPE_CHANNEL, MY_EXTERNAL_DECODER_OBJECT);

    if(checkNvAllocArchError(error)) {
        DPF("that was trouble freeing MY_EXTERNAL_DECODER_OBJECT");
    }



// increment the number of ports available
    (pMySurfaces->pDriverData)->dwVideoPortsAvailable++;
// shut down Media Port channel

    pMyNvChan = pMySurfaces->pVPChanPtr;
    {
        ULONG status;

        status = NvRmFree((GLOBDATAPTR)->ROOTHANDLE,
                                 NV_WIN_DEVICE,
                                 MY_VPE_CHANNEL);

        if( status == 0x0) {
            pMyNvChan = NULL;
            pMySurfaces->pVPChanPtr = NULL;
        } else {
            DPF("Uh Dude,  I couldn't deallocate the channel pointer... ");

        }
    }


    (pMySurfaces->pDriverData)->NvDevFlatVPE = (DWORD) NULL;
    pMyNvChan = NULL;

    // Ok, reset all the notifiers:

//  CLOSE_HANDLE(pMySurfaces->hThreadHandle);
    for (i = 0; i < NUMVPNOTIFIERS ; i++ ) {
        nvMyVPNotifiers[i].status       = NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED;
        nvMyVPNotifiers[i].info32   = 0;
        nvMyVPNotifiers[i].info32   = 0;
        nvMyVPNotifiers[i].timeStamp.nanoseconds[0] = 0;
        nvMyVPNotifiers[i].timeStamp.nanoseconds[1] = 0;
    }
    pMySurfaces->SetupComplete = FALSE;

}


void StopVP(void) {
    U032    whiletime;

    INIT_FREE_COUNT(0);

#ifdef NV3
    NV_DD_DMA_PUSHER_SYNC();
#endif

    CHECK_FREE_COUNT(pMyNvChan,8);


#ifdef NV3
    pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else
    pMyNvChan->subchannel[0].SetObject  = MY_EXTERNAL_DECODER_OBJECT;
#endif
    DPF ("   Firing Off Stop commands");

    if(pMySurfaces->dwVideoPortStatus != VP_NOT_RUNNING ) {
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferImage   = 0;
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferVbi = 0;
    }
// wait for the last few notifies to show up ?

    pMySurfaces->bStopVP = TRUE;

    whiletime = 0;
    while ( ((nvMyVPNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
                 (nvMyVPNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
                (whiletime++ < WHILETIMEOUT) );

// CODE wait for VBI notifies.. too
//  while (nvMyVPNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS);
//  while (nvMyVPNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS);
    DPF ("   Done waiting for stops");

    // one more time to make sure those register get cleared
    if(pMySurfaces->dwVideoPortStatus != VP_NOT_RUNNING ) {
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferImage   = 0;
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferVbi = 0;
   }

}

DWORD getCurLine(void) {
    U032    whiletime;
    U032    possibleOffset = 0;
    U032    line;
    U032    returnLine;
    INIT_FREE_COUNT(0);

    nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

    returnLine = 0;

    // Put decoder object into the channel
    CHECK_FREE_COUNT(pMyNvChan,1*4);
#ifdef NV3
    pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else
    pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;
#endif

    CHECK_FREE_COUNT(pMyNvChan,8);

    pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[0]       = 0;            // *allows programming of either ODD or EVEN fields
    pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[1]       = 0;            // *allows programming of either ODD or EVEN fields

//CODE   there may still be in issue with divide by ZERO here.. I can't imagine pitch = 0.. but you never know...

    whiletime = 0;

    while ( ((nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
                 (nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
                (whiletime++ < WHILETIMEOUT) );


    if(nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)].info32 == 0x1 /*NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET*/ ) {
        possibleOffset = nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)].info32;
        line = possibleOffset - pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[0]]->dwOffset;
        returnLine = line / pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[0]]->dwPitch;
    }
    if(nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)].info32 == 0x1 /*NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET*/ ) {
        possibleOffset = nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)].info32;
        line = possibleOffset - pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[1]]->dwOffset;
        returnLine = line / pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[1]]->dwPitch;
    }

    return returnLine;
}

U032    notifyIndexFromBuffer(U032 dwBuffer) {
    switch (dwBuffer) {
            case 0:
                return NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0);
                break;
            case 1:
                return NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1);
                break;
            case 2:
                return NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0);
                break;
            case 3:
                return NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1);
                break;
            default:
                {
                    DPF ("   Problem... trying get an index for an unknown buffer notify");
                    return UNKNOWNBUF;
                }
    }
}


VPERRORS replaceSurfaceList(DWORD dwNumAutoflip,DWORD dwNumVBIAutoflip,
                                        LPDDRAWI_DDRAWSURFACE_INT   *lplpDDSurface,
                                        LPDDRAWI_DDRAWSURFACE_INT   *lplpDDVBISurface,
                                        U032 bAutoflip ) {
    VPERRORS    localError = NOVPERROR;
    U032    imageSurfCount = 0;
    U032    VBISurfCount = 0;
    U032    i;
    U032    next;

    pMySurfaces->surfMemAllocCount = 0;

    ASSERT(!((lplpDDSurface         != NULL) ^ (dwNumAutoflip > 0)));
    ASSERT(!((lplpDDVBISurface  != NULL) ^ (dwNumVBIAutoflip > 0)));
    if ((dwNumAutoflip == 0 ) && (dwNumVBIAutoflip ==0 )
         && (bAutoflip)) // H.AZAR (09/02/99): we must check NumAutoflip != 0 only if autoflip flag is set !!!
    {
      return CANTCREATESURFACE;
    }

    DPF ("   We have #Image=%d  #VB=%d autoflip surfaces",dwNumAutoflip,dwNumVBIAutoflip);

    localError = clearAllSurfaces();
    if( localError != NOVPERROR ) {
        return localError;
    }

    imageSurfCount = 0;

    if(lplpDDSurface != NULL) {
        // first count the surfaces
        imageSurfCount = 0;
        if(bAutoflip) {
            while( (imageSurfCount < dwNumAutoflip) &&(lplpDDSurface[imageSurfCount] != NULL )) {
                imageSurfCount++;
            }
        } else {
            while(lplpDDSurface[imageSurfCount] != NULL ) {
                imageSurfCount++;
            }
        }
        if(bAutoflip) {
            if(imageSurfCount > dwNumAutoflip ) {
                DPF("More in list than are autoflip!");
                imageSurfCount = dwNumAutoflip;
            }
        }
        // next add the surfaces to the list
        i = 0;
        while((lplpDDSurface[i] != NULL ) && (i <imageSurfCount) ) {
            next = i + 1;
            if( next == imageSurfCount )
                next = 0;
            localError = addSurface(createSurface(lplpDDSurface[i], bAutoflip, FALSE, NULL,next));
            i=i+1;
        }

        DPF("Added %d Image surfaces",imageSurfCount);
    }
    pMySurfaces->VBIstart = imageSurfCount;


    if(lplpDDVBISurface!=NULL ) {
        // now count VBI surfaces
        VBISurfCount = 0;
        // if we're auto flip then don't check beyond what numVBIAutoflip passes into us since
        // some lamers don't zero terminate their list in this case
        if(bAutoflip) {
            while((VBISurfCount < dwNumVBIAutoflip) && (lplpDDVBISurface[VBISurfCount] != NULL ) ) {
                VBISurfCount++;
            }
        } else {
            while(lplpDDVBISurface[VBISurfCount] != NULL ) {
                VBISurfCount++;
            }
        }
        if(bAutoflip) {
            if(VBISurfCount > dwNumVBIAutoflip ) {
                DPF("More in VBI list than are autoflip!");
                VBISurfCount = dwNumVBIAutoflip;
            }
        }
        // next add the surfaces to the list
        i = 0;
        // All the VBI surfaces are offset by a certain amount
        while((lplpDDVBISurface[i] != NULL ) && (i <VBISurfCount) ) {
            next = i + 1;
            if( next == VBISurfCount )
                next = 0;
            localError = addSurface(createSurface(lplpDDVBISurface[i], bAutoflip, TRUE, NULL,next+pMySurfaces->VBIstart));
            i=i+1;
        }
        DPF("Added %d VBI surfaces",VBISurfCount);
    }


    pMySurfaces->CurrentBufferSurface[0] = NOSURFACEPROGRAMED;
    pMySurfaces->CurrentBufferSurface[1] = NOSURFACEPROGRAMED;
    pMySurfaces->CurrentBufferSurface[2] = NOSURFACEPROGRAMED;
    pMySurfaces->CurrentBufferSurface[3] = NOSURFACEPROGRAMED;

    if( localError == NOVPERROR ) {
        DPF ("   Replaced surfaces - OK");
    } else {
        switch (localError) {
                case    TOOMANYSURFACESERROR:
                    DPF ("   Replaced surfaces - TOOMANYSURFACESERROR");
                    break;
                case CANTCREATESURFACE:
                    DPF ("   Replaced surfaces - CANTCREATESURFACE");
                    break;
                case SURFACENOTFOUND:
                    DPF ("   Replaced surfaces - SURFACENOTFOUND");
                    break;
                case NOSURFACEPROGRAMED:
                    DPF ("   Replaced surfaces - NOSURFACEPROGRAMED");
                    break;
        }

        DPF ("   Replaced surfaces there was a problem = %d",localError);
    }

#if 0
#ifdef DEBUG
    DPF("Now checking the surface thingie");
    {
        U032    i;
        for(i=0;i<pMySurfaces->numberOfSurfaces;i++) {
            DPF("#Surfaces = %d surface = %d, nextSurface = %d, prevSurcace = %d",pMySurfaces->numberOfSurfaces,i,getNextSurface(i),getPrevSurface(i));
        }
    }

    DPF("done checking");

#endif

#endif
    return localError;
}


VPERRORS    addSurface(vpSurfaceInfo*   pNewSurface) {
    ASSERT(pNewSurface  != NULL);

    if(pMySurfaces->numberOfSurfaces >= MAXVPSURFACES ) {
        return  TOOMANYSURFACESERROR;
    }
    if( pNewSurface == NULL) {
        return CANTCREATESURFACE;
    }

    pMySurfaces->Surfaces[pMySurfaces->numberOfSurfaces] = pNewSurface;
    pMySurfaces->numberOfSurfaces++;

    return NOVPERROR;
}

vpSurfaceInfo* createSurface(LPDDRAWI_DDRAWSURFACE_INT pNewSurface, U032 bAutoflip,
                                        U032 bVBI, NvNotification* pToNotify,U032 nextSurface) {


    vpSurfaceInfo*      pSurface;
    U032 Delta;

    ASSERT( pNewSurface != NULL);
    // unlikely to ever be not NULL
    //ASSERT( pToNotify != NULL);
    ASSERT( nextSurface < MAXVPSURFACES);

    pSurface = &pMySurfaces->surfMemory[pMySurfaces->surfMemAllocCount];
    pMySurfaces->surfMemAllocCount++;

    pSurface->surfHandle = pNewSurface;
    pSurface->bAutoFlip = bAutoflip;
    pSurface->pVidMem = VIDMEM_ADDR(pNewSurface->lpLcl->lpGbl->fpVidMem);
    pSurface->ddsCaps = pNewSurface->lpLcl->ddsCaps.dwCaps;
    pSurface->nextSurfaceNum = nextSurface;
    // store the offset of the intermediate hidden surface
    pSurface->dwRes1 = pNewSurface->lpLcl->lpGbl->dwReserved1;
//

    pSurface->dwPitch = pNewSurface->lpLcl->lpGbl->lPitch;



    // move things around in the surface
    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
      Delta = 0;   // in NV10 the overlay can do these calculations..
    } else {
      Delta = pMySurfaces->dwOriginX*2 + pMySurfaces->dwOriginY*pSurface->dwPitch;
    }

    pSurface->dwOffset = (unsigned long) pSurface->pVidMem
                    - (unsigned long)(pMySurfaces->pDriverData)->BaseAddress
                    + Delta;


    if(bVBI) {
        pSurface->dwStartLine = pMySurfaces->dwVBIStartLine;
    } else {
        if( pMySurfaces->CurrentScanMode == INTERLEAVBUF) {
                // both field have bigger pitch
                pSurface->dwPitch = pNewSurface->lpLcl->lpGbl->lPitch * 2;
            }



        //if( pMySurfaces->dwImageStartLine < 6 )
        //  pSurface->dwStartLine = 6;
        //else
            if(pMySurfaces->dwImageStartLine == 1) {
                pSurface->dwStartLine = 16; //tried 17 no much- 15 can see stuff on top of intercast disk - 16?
            } else {
                pSurface->dwStartLine = pMySurfaces->dwImageStartLine;
            }
    }

#define VIDEOEXTRALEN (0)
    // make sure we're not trying to cram something into a surface that's too small
    if(bVBI ) {
        pSurface->dwHeight = pMySurfaces->dwVBIHeight;
    } else {
        if ( pMySurfaces->dwInHeight > pNewSurface->lpLcl->lpGbl->wHeight ) {
            pSurface->dwHeight = pNewSurface->lpLcl->lpGbl->wHeight + VIDEOEXTRALEN;
        } else {
            pSurface->dwHeight = pMySurfaces->dwInHeight + VIDEOEXTRALEN;
        }
    }
    if ( pMySurfaces->dwInWidth > pNewSurface->lpLcl->lpGbl->wWidth ) {
        pSurface->dwWidth = pNewSurface->lpLcl->lpGbl->wWidth;
    } else {
        pSurface->dwWidth = pMySurfaces->dwInWidth;
    }

    pSurface->dwPreScaleSize =  (pMySurfaces->dwPreWidth) | ((pMySurfaces->dwPreHeight+VIDEOEXTRALEN) << 16);
            // we know that there are TWO bytes per pixel in UYVY format
    //pSurface->dwLength = pNewSurface->lpLcl->lpGbl->lPitch * ((U032)pNewSurface->lpLcl->lpGbl->wHeight) * 2;
    pSurface->dwLength = pSurface->dwPitch * (((U032)pSurface->dwHeight) ) * 2;

    return pSurface;
}


VPERRORS replaceSurfaceWithSurface(U032 surfaceToReplace, LPDDRAWI_DDRAWSURFACE_LCL pNewSurface, U032  bVBI) {

    vpSurfaceInfo*      pSurface;
    U032                    Delta;

    ASSERT( pNewSurface != NULL);

    pSurface = pMySurfaces->Surfaces[surfaceToReplace];
// not sure if this is necessary or not....
//  pSurface->pNvNotify = &(nvMyVPNotifiers[notifyIndexFromBuffer(0)]);

    pSurface->surfHandle = pNewSurface;
    // pSurface->bAutoFlip = bAutoflip; // leave this the same!
    pSurface->pVidMem = VIDMEM_ADDR(pNewSurface->lpGbl->fpVidMem);
    pSurface->ddsCaps = pNewSurface->ddsCaps.dwCaps;
    // pSurface->nextSurfaceNum = nextSurface;      // leave this the same!

    pSurface->dwPitch = pNewSurface->lpGbl->lPitch;

    // move things around in the surface
    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
      Delta = 0;   // in NV10 the overlay can do these calculations..
    } else {
      Delta = pMySurfaces->dwOriginX*2 + pMySurfaces->dwOriginY*pSurface->dwPitch;
    }
    pSurface->dwOffset = (unsigned long) pSurface->pVidMem
                    - (unsigned long)(pMySurfaces->pDriverData)->BaseAddress
                    + Delta;

    if( pMySurfaces->CurrentScanMode == INTERLEAVBUF) {
        // both field have bigger pitch
        pSurface->dwPitch = pNewSurface->lpGbl->lPitch * 2;
    }

    if(bVBI) {
        pSurface->dwStartLine = pMySurfaces->dwVBIStartLine;
    } else {
        //if( pMySurfaces->dwImageStartLine < 6 )
        //  pSurface->dwStartLine = 6;
        //else
            if(pMySurfaces->dwImageStartLine == 1) {
                pSurface->dwStartLine = 16; //tried 17 no much- 15 can see stuff on top of intercast disk - 16?
            } else {
                pSurface->dwStartLine = pMySurfaces->dwImageStartLine;
            }
    }

#define VIDEOEXTRALEN (0)
    // make sure we're not trying to cram something into a surface that's too small
    if(bVBI ) {
        pSurface->dwHeight = pMySurfaces->dwVBIHeight;
    } else {
        if ( pMySurfaces->dwInHeight > pNewSurface->lpGbl->wHeight ) {
            pSurface->dwHeight = pNewSurface->lpGbl->wHeight + VIDEOEXTRALEN;
        } else {
            pSurface->dwHeight = pMySurfaces->dwInHeight + VIDEOEXTRALEN;
        }
    }
    if ( pMySurfaces->dwInWidth > pNewSurface->lpGbl->wWidth ) {
        pSurface->dwWidth = pNewSurface->lpGbl->wWidth;
    } else {
        pSurface->dwWidth = pMySurfaces->dwInWidth;
    }

    pSurface->dwPreScaleSize =  (pMySurfaces->dwPreWidth) | ((pMySurfaces->dwPreHeight+VIDEOEXTRALEN) << 16);
            // we know that there are TWO bytes per pixel in UYVY format
    //pSurface->dwLength = pNewSurface->lpGbl->lPitch * ((U032)pNewSurface->lpGbl->wHeight) * 2;
    pSurface->dwLength = pSurface->dwPitch * (((U032)pSurface->dwHeight) ) * 2;

    return NOVPERROR;

}

VPERRORS clearAllSurfaces() {
    U032    i;

    for (i=0;i<pMySurfaces->numberOfSurfaces; i++ ) {
        pMySurfaces->Surfaces[i] = NULL;
    }

    pMySurfaces->surfMemAllocCount = 0;
    pMySurfaces->numberOfSurfaces = 0;

    return NOVPERROR;
}

U032    findSurface(LPDDRAWI_DDRAWSURFACE_LCL pNewSurface ) {
    U032    i;

    for(i = 0 ; i < pMySurfaces->numberOfSurfaces; i ++ ) {
        if( pNewSurface->lpGbl->fpVidMem == pMySurfaces->Surfaces[i]->pVidMem ) {
            // Ok, we found the surface!
            return i;
        }

    }

    return SURFACENOTFOUND;
}

#if 0

FIELDTYPE   getNextFieldType(FIELDTYPE lastFieldType) {

    switch (pMySurfaces->CurrentCaptureMode) {
            case EVENODD:
                if(lastFieldType ==EVEN ) {
                    return ODD;
                } else if( lastFieldType ==ODD ) {
                    return EVEN;
                } else {
                    return EVEN;
                }
                break;
            case EVENEVEN:
                if(lastFieldType ==EVEN ) {
                    return EVEN;
                } else {
                    return EVEN;
                }
                break;
            case ODDODD:
                if(lastFieldType ==ODD ) {
                    return ODD;
                } else {
                    return ODD;
                }
                break;
            default:
                ASSERT(pMySurfaces->CurrentCaptureMode == ODDODD );
    }
}



U032    ProgramBufferWithSurface(U032   dwBufferIndex,U032  newSurfaceIndex, U032 bZeroLength) {
    // This function is responsible for programming up and then launching buffer/surface combination
    // This will finish Asyncronously, and either be relaunched in the case of auto-flip, or be able
    // to report back usefully with the VPE functions
    U032    nextField;
    U032    dwInterleaveAddition;
    INIT_FREE_COUNT(0);

    ASSERT(dwBufferIndex < 4 );
    ASSERT(newSurfaceIndex < MAXVPSURFACES );
    //Update the surface structures
        // notify


    pMySurfaces->Surfaces[newSurfaceIndex]->pNvNotify = &(nvMyVPNotifiers[notifyIndexFromBuffer(dwBufferIndex)]);
    pMySurfaces->CurrentBufferSurface[dwBufferIndex] = newSurfaceIndex;


    // Figure out the whole field thing
    nextField = getNextFieldType(pMySurfaces->lastField);
    pMySurfaces->Surfaces[newSurfaceIndex]->field = nextField;
    pMySurfaces->lastField = nextField;
    pMySurfaces->curSurf = newSurfaceIndex;

#define PRINTPROGRAM
#ifdef PRINTPROGRAM
    DPF("   ProgramBufferWithSurface");
    DPF("           dwBufferIndex = %d",dwBufferIndex);
    DPF("         newSurfaceIndex = %d",newSurfaceIndex);
    DPF("             bZeroLength = %d",bZeroLength);
    switch (nextField) {
            case ODD:
                 DPF("                   field = ODD");
                break;
            case EVEN:
                 DPF("                   field = EVEN");
                break;
            case UNKNOWN:
                 DPF("                   field = UNKNOWN");
                break;
    }
#endif //PRINTPROGRAM

    // if we're interleaving AND we're on the EVEN field then move everything down a bit
    //   OOD field is on top
    if(( pMySurfaces->CurrentScanMode == INTERLEAVBUF) && (nextField == EVEN ) ) {
        dwInterleaveAddition = pMySurfaces->Surfaces[newSurfaceIndex]->dwPitch/2;
    } else {
        dwInterleaveAddition = 0;
    }
    // choose which type of surface this is
    if( dwBufferIndex <2 ) {
        // Image surface
        // setup the field polarity, offset and fire it off


        // Put decoder object into the channel
        CHECK_FREE_COUNT(pMyNvChan,1*4);
#ifdef NV3
        pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else
        pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;
#endif

        // for now use the same "in" as "out"

        CHECK_FREE_COUNT(pMyNvChan,5*4);

        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImageStartLine =
            pMySurfaces->Surfaces[newSurfaceIndex]->dwStartLine;

// check for invalid scaling combo's

        // if prescale is not on 2:1 integer boundaries from output, then fail...
        {
            BOOL bScale = checkScalingOk((pMySurfaces->Surfaces[newSurfaceIndex]->dwWidth) |
                                                    (pMySurfaces->Surfaces[newSurfaceIndex]->dwHeight << 16)
                            ,pMySurfaces->Surfaces[newSurfaceIndex]->dwPreScaleSize);

            if(! bScale ) {
                DPF("   Invalid Scaling parameters in use...");

                return (-7);
            }
        }

        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].sizeIn =
            (pMySurfaces->dwInWidth) | (pMySurfaces->dwInHeight << 16);

        if( bZeroLength ) {
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].sizeOut = 0;
        } else {
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].sizeOut =
                pMySurfaces->Surfaces[newSurfaceIndex]->dwPreScaleSize;
        }

#ifdef PRINTPROGRAM
        DPF("                  offset = %x",pMySurfaces->Surfaces[newSurfaceIndex]->dwOffset + dwInterleaveAddition);
        DPF("                  pitch  = %x",pMySurfaces->Surfaces[newSurfaceIndex]->dwPitch);
#endif //PRINTPROGRAM
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].offset    =
                pMySurfaces->Surfaces[newSurfaceIndex]->dwOffset + dwInterleaveAddition;

        // There is some sly behavior in the field statement...
        // since progressive fields are expected to be delivered in the EVEN fields we only check for OOD
        // and then everything else is considered to be even
        nvMyVPNotifiers[notifyIndexFromBuffer(dwBufferIndex)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].format =
                ( pMySurfaces->Surfaces[newSurfaceIndex]->dwPitch & 0xFFFF )  |
                ((( ( nextField == ODD ) ? NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD : NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD) << 16 ) & 0xFF0000 )  |
                ((NV_OS_WRITE_THEN_AWAKEN << 24 ) & 0xFF000000 ) ;


    } else {
        CHECK_FREE_COUNT(pMyNvChan,3*4);

        // VBI surface
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[dwBufferIndex-2].size  =
            (pMySurfaces->Surfaces[newSurfaceIndex]->dwHeight << 16) | (pMySurfaces->Surfaces[newSurfaceIndex]->dwStartLine) ;

        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[dwBufferIndex-2].offset    =
            pMySurfaces->Surfaces[newSurfaceIndex]->dwOffset;

        nvMyVPNotifiers[notifyIndexFromBuffer(dwBufferIndex)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[dwBufferIndex-2].format =
            ( pMySurfaces->Surfaces[newSurfaceIndex]->dwPitch & 0xFFFF )  |
            ((( ( nextField == ODD ) ? NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD : NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD) << 16 ) & 0xFF0000 )  |
            ((NV_OS_WRITE_THEN_AWAKEN << 24 ) & 0xFF000000 ) ;

    }
    //Update the Capture Class

    return 0;
}


DWORD WINAPI VPInterruptThread(PVOID daParameter) {

    DWORD       waitReturnValue;
    HANDLE  myEvent = (HANDLE) daParameter;

    ASSERT(myEvent != NULL);

    DPF ("   |||||||| Thread Started");

    while(pMySurfaces->bThreadRunning) {
        // sit and wait...
        // we'll wake up on the event which can be triggered EITHER by the RM
        // OR by our parent telling us to wake up and then exit
        waitReturnValue = NvWaitEvent(myEvent,INFINITE);
        if( pMySurfaces->bThreadRunning ) {
            if(!IS_EVENT_ERROR(waitReturnValue)) {
                //DPF ("   interrupt");
                //HandleBufferInterrupt();
                if( pMySurfaces->myTable.handleBufferInterrupts != NULL ) {
                        U032 retval = (pMySurfaces->myTable.handleBufferInterrupts)();
                        if(retval != 0)
                            DPF("FUCKUP!!!!!!!!!   this is ab ad thing    what sometimes this is bad = %8x",retval);
                    } else {
                        ASSERT(1==0);
                        // massive failure... hang out here for a while
                    }
            }
        }
    }

    DPF ("   |||||||| Thread Ending");

    pMySurfaces->bThreadDead = TRUE;

    return 0;
}



#endif
#endif //(!defined(WINNT) && !defined(NVPE))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\TexInit.cpp ===
/***************************************************************************\
* Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: TexInit.cpp                                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           11/16/98                                         *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

extern vpSurfaces*          pMySurfaces;
extern NvNotification*      nvMyVPNotifiers;


void initTextureSurf(void) {
    U032    error;

    // We're going to stuff things into our channel which are NV4 only
    // since the channel is an NV3 channel we have to type cast it to NV4
    // KevinK says this works fine...
    Nv04ChannelPio* nvPtr = (Nv04ChannelPio*)pMySurfaces->pVPChanPtr;

    // allocate the objects and the notifiers
    //   the contexts we have to do on the fly in ring0


    // allocate the notifier for the swiz class
    error = NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
        MY_SWIZ_NOTIFIER,
        NV01_CONTEXT_DMA,
        DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
        DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
        (PVOID)(((U032)nvMyVPNotifiers) + NUM077OFFSET*sizeof(NvNotification)),
        (sizeof( NvNotification)*NUM077NOTIFIER  - 1)
   );
    checkNvAllocArchError(error);

    // allocate the notifer for the 2dswized surface class
    error = NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
        MY_2DSWIZD_NOTIFIER,
        NV01_CONTEXT_DMA,
        DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
        DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
        (PVOID)(((U032)nvMyVPNotifiers) + NUM052OFFSET*sizeof(NvNotification)),
        (sizeof( NvNotification)*NUM052NOTIFIER  - 1)
   );
    checkNvAllocArchError(error);

   // allocate the swizzler object
    error = NvRmAllocObject(  (GLOBDATAPTR)->ROOTHANDLE,
                                MY_VPE_CHANNEL,
                                MY_SWIZ_OBJECT,
                                        NV04_CONTEXT_SURFACE_SWIZZLED
                                );

    checkNvAllocArchError(error);
    // allocate the swizzled surface
    error = NvRmAllocObject(  (GLOBDATAPTR)->ROOTHANDLE,
                                MY_VPE_CHANNEL,
                                MY_2DSWIZD_OBJECT,
                                        NV4_STRETCHED_IMAGE_FROM_CPU
                                );
    checkNvAllocArchError(error);

    //setup subchannels
    // subchannel 3-swiz 4-conv
    nvPtr->subchannel[3].SetObject  = MY_SWIZ_OBJECT;
    nvPtr->subchannel[4].SetObject = MY_2DSWIZD_OBJECT;

    // plug the notifiers in
    nvPtr->subchannel[3].nv04ScaledImageFromMemory.SetContextDmaNotifies = MY_SWIZ_NOTIFIER;
    nvPtr->subchannel[4].nv04ContextSurfaceSwizzled.SetContextDmaNotifies = MY_2DSWIZD_NOTIFIER;
    //
    // entire frame buffer context stolen from VPE stuff
    nvPtr->subchannel[3].nv04ScaledImageFromMemory.SetContextDmaImage = MY_IMAGE0_BUFFER_CONTEXT;
    // I think this is the correct color format...
    nvPtr->subchannel[3].nv04ScaledImageFromMemory.SetContextSurface = MY_2DSWIZD_OBJECT;
    // entire frame buffer context stolen from VPE stuff

}


void DestroyTextureSurf(void) {
    U032    error;

    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_SWIZ_NOTIFIER);
    checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_2DSWIZD_NOTIFIER);
    checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_VPE_CHANNEL, MY_SWIZ_OBJECT);
    checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_VPE_CHANNEL, MY_2DSWIZD_OBJECT);
    checkNvAllocArchError(error);

}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\nvVShad.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvVShad.cpp
//
// **************************************************************************
//
//  History:
//      Hadden Hoppert?           May00           DX8 development
//
// **************************************************************************

#include "nvprecomp.h"

/*****************************************************************************
 *****************************************************************************
 *****************************************************************************
 ***  CVertexShader  *********************************************************
 *****************************************************************************
 *****************************************************************************
 ****************************************************************************/

CVertexShader::CVertexShader()
{
    this->reset();
}

CVertexShader::reset( void )
{
    m_dwHandle    = 0;
    m_dwFVF       = 0;
    m_dwCodeSize  = 0;
    m_pCodeData   = NULL;
    m_dwStride    = 0;
    m_bHasConsts  = FALSE;
    m_one         = 1.0f;
    m_zero        = 0.0f;
    m_ProgramOutput.residentProgram = NULL;
    m_ProgramOutput.residentNumInstructions = 0;
    m_ProgramOutput.residentSize = 0;

    for (int i = 0; i < NV_CAPS_MAX_STREAMS; i++) {
        // sources of the data loaded into the 16 vertex attribute registers
        m_vaSourceData[i].dwStream = VA_STREAM_NONE;
        m_vaSourceData[i].dwOffset = 0;
        m_vaSourceData[i].dwType = 0;
        m_vaSourceData[i].dwSrc  = 0;
        m_vaSourceData[i].flag = AUTONONE;
    }

#if (NVARCH >= 0x020)
    m_pKelvinProgram = NULL;
#endif

    return TRUE;
}

/*****************************************************************************
 * CVertexShader::create
 *
 * create a vertex shader from code
 */
static char *typeDecode[8] = { "D3DVSDT_FLOAT1  ", "D3DVSDT_FLOAT2  ", "D3DVSDT_FLOAT3  ",
                               "D3DVSDT_FLOAT4  ", "D3DVSDT_D3DCOLOR", "D3DVSDT_UBYTE4  ",
                               "D3DVSDT_SHORT2  ", "D3DVSDT_SHORT4  "};

#define SwapSources(a,b)    {   VASOURCEINFO temp;                                      \
                            DWORD dwTemp;                                           \
                    memcpy(&temp, &m_vaSourceData[a], sizeof(VASOURCEINFO));                    \
                            memcpy(&m_vaSourceData[a], &m_vaSourceData[b],sizeof(VASOURCEINFO));                    \
                            memcpy(&m_vaSourceData[b], &temp, sizeof(VASOURCEINFO));                            \
                            for(i=0; i < 16; i++){  if((unsigned int)m_CallerKelvin.inputRegMap[i] == a) break; }           \
                            for(j=0; j < 16; j++){  if((unsigned int)m_CallerKelvin.inputRegMap[j] == b)        break; }    \
                            dwTemp = m_CallerKelvin.inputRegMap[i];                             \
                            m_CallerKelvin.inputRegMap[i] = m_CallerKelvin.inputRegMap[j];                  \
                            m_CallerKelvin.inputRegMap[j] = dwTemp;                             \
                }

CVertexShader::create
(
    PNVD3DCONTEXT pContext,
    DWORD         dwHandle,
    DWORD         dwDeclSize,
    DWORD         dwCodeSize,
    DWORD        *lpDecl,
    DWORD        *lpCode
)
{
    DWORD dwCurrentStream, dwCurrentOffset;
    DWORD dwToken, dwLoadType, dwType, dwReg, dwSwappedReg, dwCount, i, j, dwSrc, dwSwappedSrc;

    // cache the handle
    m_dwHandle = dwHandle;
    nvAssert(m_dwFVF == 0);
    nvAssert( m_dwHandle & 0x1 );

    DPF_LEVEL(NVDBG_LEVEL_VSHADER_INS, "Create vertex shader 0x%02x", dwHandle);

    m_dwCodeSize = dwCodeSize;
    if (dwCodeSize) {
        m_pCodeData = (DWORD *)AllocIPM(dwCodeSize);
        memcpy (m_pCodeData, lpCode, dwCodeSize);  //lpDecl ?
    }

    // parse the declaration
    m_dwStride = 0;

    for (i = 0; i < dwDeclSize; i++, lpDecl++) {

        dwToken = *lpDecl;

        switch ((dwToken & D3DVSD_TOKENTYPEMASK) >> D3DVSD_TOKENTYPESHIFT) {

        case D3DVSD_TOKEN_NOP:
            // NOP or extension
            //nvAssert (dwToken == 0);
            break;

        case D3DVSD_TOKEN_STREAM:
            // stream selector
            dwCurrentStream = (dwToken & D3DVSD_STREAMNUMBERMASK) >> D3DVSD_STREAMNUMBERSHIFT;
            dwCurrentOffset = 0;
            break;

        case D3DVSD_TOKEN_STREAMDATA:
            // stream data definition (map to vertex input memory)
            dwLoadType = (dwToken & D3DVSD_DATALOADTYPEMASK) >> D3DVSD_DATALOADTYPESHIFT;
            if (dwLoadType == 0) {
                // vertex input register load
                dwType = (dwToken & D3DVSD_DATATYPEMASK) >> D3DVSD_DATATYPESHIFT;
                dwReg  = (dwToken & D3DVSD_VERTEXREGMASK) >> D3DVSD_VERTEXREGSHIFT;
                dwSwappedReg  = defaultInputRegMap[dwReg];        //remap inputs to conform to internal formats
                m_vaSourceData[dwSwappedReg].dwStream = dwCurrentStream;
                m_vaSourceData[dwSwappedReg].dwOffset = dwCurrentOffset;
                m_vaSourceData[dwSwappedReg].dwType   = dwType;
                m_vaSourceData[dwSwappedReg].flag     = CVertexShader::AUTONONE;
                DPF_LEVEL (NVDBG_LEVEL_VSHADER_INS, "reg: %02d->%02d , stream: %02d, type: %s, offset %02x, src: %x, flag: %d",
                           dwReg, dwSwappedReg, m_vaSourceData[dwSwappedReg].dwStream, typeDecode[m_vaSourceData[dwSwappedReg].dwType], m_vaSourceData[dwSwappedReg].dwOffset,
                           m_vaSourceData[dwSwappedReg].dwSrc, m_vaSourceData[dwSwappedReg].flag);
                DWORD dwVASize = getVASize(dwSwappedReg);
                dwCurrentOffset += dwVASize;
                m_dwStride      += dwVASize;
            } else {
                // data skip (no register load)
                dwCount = (dwToken & D3DVSD_SKIPCOUNTMASK) >> D3DVSD_SKIPCOUNTSHIFT;
                dwCurrentOffset += dwCount*sizeof(DWORD);
            }
            break;

        case D3DVSD_TOKEN_TESSELLATOR:
            dwReg = (dwToken & D3DVSD_VERTEXREGMASK) >> D3DVSD_VERTEXREGSHIFT;
            dwSwappedReg = defaultInputRegMap[dwReg];        //remap inputs to conform to internal formats
            m_vaSourceData[dwSwappedReg].dwStream = dwCurrentStream;
            m_vaSourceData[dwSwappedReg].dwOffset = NULL;
            dwSrc = (dwToken & D3DVSD_VERTEXREGINMASK) >> D3DVSD_VERTEXREGINSHIFT;
            dwSwappedSrc = defaultInputRegMap[dwSrc];
            m_vaSourceData[dwSwappedReg].dwSrc = dwSwappedSrc;
            m_vaSourceData[dwSwappedReg].dwType   = (dwToken & D3DVSD_DATATYPEMASK)    >> D3DVSD_DATATYPESHIFT;
            if (dwToken & 0x10000000) { // is this a vertex normal def or a UV def
                m_vaSourceData[dwSwappedReg].flag = CVertexShader::AUTOTEXCOORD;
                m_dwStride += 2 * sizeof(DWORD);
            }
            else {
                m_vaSourceData[dwSwappedReg].flag = CVertexShader::AUTONORMAL;
                m_dwStride += 3 * sizeof(DWORD);
            }
            DPF_LEVEL (NVDBG_LEVEL_VSHADER_INS, "reg: %02d->%02d, stream: %02d, type: %s, offset %02x, src: %x->%x, flag: %s",
                       dwReg, dwSwappedReg, m_vaSourceData[dwSwappedReg].dwStream, typeDecode[m_vaSourceData[dwSwappedReg].dwType],
                       m_vaSourceData[dwSwappedReg].dwOffset, dwSrc, dwSwappedSrc,
                       (m_vaSourceData[dwSwappedReg].flag == CVertexShader::AUTOTEXCOORD ? "AUTOTEX" : "AUTONORM" ));
            break;

        case D3DVSD_TOKEN_CONSTMEM:
            // constant memory from shader
            if (!m_bHasConsts) {
                memset(m_numConsts, 0, sizeof(m_numConsts));
                m_bHasConsts = TRUE;
            }
            dwCount = (dwToken & D3DVSD_CONSTCOUNTMASK)   >> D3DVSD_CONSTCOUNTSHIFT;
            dwReg   = (dwToken & D3DVSD_CONSTADDRESSMASK) >> D3DVSD_CONSTADDRESSSHIFT;
            nvAssert(dwReg < D3DVS_CONSTREG_MAX_V1_1);
            nvAssert((dwReg + dwCount) <= D3DVS_CONSTREG_MAX_V1_1);
            memcpy((DWORD *)&m_vertexShaderConstants[dwReg], lpDecl + 1, dwCount * sizeof(VSHADERREGISTER));
            m_numConsts[dwReg] = dwCount;
            lpDecl += 4 * dwCount;
            break;

        case D3DVSD_TOKEN_EXT:
            // extension
            dwCount = (dwToken & D3DVSD_EXTCOUNTMASK) >> D3DVSD_EXTCOUNTSHIFT;
            lpDecl += dwCount;
            break;

        case D3DVSD_TOKEN_END:
            // end-of-array (requires all DWORD bits to be 1)
            i = dwDeclSize; // force exit of for loop
            break;
        }
    }

    //create a kelvin program and upload it
#if (NVARCH >= 0x020)
    if (dwCodeSize)
    {
        m_pKelvinProgram = (PKELVIN_PROGRAM)AllocIPM(sizeof(KELVIN_PROGRAM));

        //parse the D3D code into kelvin meta-code
        nvKelvinParseVertexShaderCode (m_pKelvinProgram, &m_ParsedProgram, lpCode, dwCodeSize);

        m_ParsedProgram.firstInstruction = m_pKelvinProgram->code;
        m_ParsedProgram.liveOnEntry      = FALSE;
        m_ParsedProgram.IsStateProgram   = FALSE; // compiler will add viewport transform code
        vp_Optimize(&m_ParsedProgram, m_pKelvinProgram->dwNumInstructions, 0);

        //compile to kelvin microcode
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
        {
            // set up kelvin compiler
            m_CallerKelvin.caller_id = 0xD3D;
            m_CallerKelvin.malloc    = glLikeAllocIPM;
            m_CallerKelvin.free      = glLikeFreeIPM;
            m_CallerKelvin.mallocArg = NULL;

            memcpy (m_CallerKelvin.inputRegMap,  defaultInputRegMap,  sizeof(defaultInputRegMap));
            memcpy (m_CallerKelvin.outputRegMap, defaultOutputRegMap, sizeof(defaultOutputRegMap));

            DWORD dwStream = getAutoNormalStream();
            //if the autonormal stream is NOT equal to stream 2 (where we can guard curve) swap 2 and wherever it was?
            if(dwStream != VA_STREAM_NONE && dwStream != 2){

                //swap normal stream into position 2
                SwapSources(dwStream,2);

                //if we have created an autonormal make sure that its src is from stream 0 and swap as necessary.
                if(m_vaSourceData[2].dwSrc != 0x0){     //if src for an autonormal is NOT position 0 --> move it there.
                    dwStream = m_vaSourceData[2].dwSrc;
                    SwapSources(dwStream,0);
                }
                m_vaSourceData[2].dwSrc = 0x0;  //input will be swapped below to come from channel 0

            }

            if (!vp_CompileKelvin(&m_CallerKelvin, &m_ParsedProgram, m_pKelvinProgram->dwNumInstructions, &m_ProgramOutput)) {
                DPF ("Failed to compile kelvin vertex shader code");
                dbgD3DError();
            }
        }
        else
        {
            // set up x86 assembly compiler
            m_Caller.caller_id         = 0xD3D;
            m_Caller.malloc            = glLikeAllocIPM;
            m_Caller.free              = glLikeFreeIPM;
            m_Caller.mallocArg         = NULL;
            m_Caller.exec_malloc       = glLikeAllocIPM;
            m_Caller.expf              = expf;
            m_Caller.logf              = logf;
            // we use addresses instead of offsets and then just pass in 0 for the base address later
            m_Caller.attrib_offset     = int(m_Attrib);
            m_Caller.temp_offset       = int(pContext->pVShaderConsts->vertexShaderTemp);
            m_Caller.result_offset     = int(m_Result);
            m_Caller.param_offset      = int(pContext->pVShaderConsts->vertexShaderConstants);
            m_Caller.float_one_offset  = int(&m_one);
            m_Caller.float_zero_offset = int(&m_zero);

            if (!vp_CompileX86(&m_Caller, &m_ParsedProgram, m_pKelvinProgram->dwNumInstructions, &m_ProgramOutput)) {
                DPF ("Failed to compile X86 vertex shader code");
                dbgD3DError();
            }
        }
    }
#endif
    return TRUE;
}

/*****************************************************************************
 * CVertexShader::create
 *
 * create a vertex shader from FVF format
 */
CVertexShader::create
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFVF,
    DWORD         dwHandle
)
{
    static BYTE bTextureSize[4]  = {2*4, 3*4, 4*4, 1*4};
    static BYTE bTextureCount[4] = { 2,   3,   4,   1 };
    static BYTE bTextureType[4]  = { D3DVSDT_FLOAT2,
                                     D3DVSDT_FLOAT3,
                                     D3DVSDT_FLOAT4,
                                     D3DVSDT_FLOAT1 };
    static BYTE bWeightType[6]   = { 0,
                                     D3DVSDT_FLOAT1,
                                     D3DVSDT_FLOAT2,
                                     D3DVSDT_FLOAT3,
                                     D3DVSDT_FLOAT4,
                                     D3DVSDT_FLOAT4 };

    DWORD dwTextureFormats,dwNumTexSets;
    DWORD dwOffset, dwBCount, i;

    nvAssert( dwFVF );

    // if the FVF handle hasn't changed, just return
    if (m_dwFVF == dwFVF) {
        return (TRUE);
    }

    m_dwHandle   = dwHandle;
    m_dwFVF      = dwFVF;
    m_dwCodeSize = 0;

    dwOffset = 0;

    // x,y,z
    m_vaSourceData[defaultInputRegMap[D3DVSDE_POSITION]].dwStream = 0;
    m_vaSourceData[defaultInputRegMap[D3DVSDE_POSITION]].dwType   = D3DVSDT_FLOAT3;
    m_vaSourceData[defaultInputRegMap[D3DVSDE_POSITION]].dwOffset = dwOffset;
    dwOffset += 3*sizeof(DWORD);

    // default to having no geometry other than x,y,z
    m_vaSourceData[defaultInputRegMap[D3DVSDE_BLENDWEIGHT]].dwStream = VA_STREAM_NONE;
    dwBCount = 0;

    // check for geometry beyond just x,y,z
    switch (dwFVF & D3DFVF_POSITION_MASK) {
        case D3DFVF_XYZ:
            break;
        case D3DFVF_XYZRHW:
            m_vaSourceData[defaultInputRegMap[D3DVSDE_POSITION]].dwType = D3DVSDT_FLOAT4;
            dwOffset += 1*sizeof(DWORD);
            break;
        case D3DFVF_XYZB5:   // we have x,y,z,b1,b2,b3,b4,b5
            dwBCount++;
        case D3DFVF_XYZB4:   // we have x,y,z,b1,b2,b3,b4
            dwBCount++;
        case D3DFVF_XYZB3:   // we have x,y,z,b1,b2,b3
            dwBCount++;
        case D3DFVF_XYZB2:   // we have x,y,z,b1,b2
            dwBCount++;
        case D3DFVF_XYZB1:   // we have x,y,z,b1
            dwBCount++;
            m_vaSourceData[defaultInputRegMap[D3DVSDE_BLENDWEIGHT]].dwStream = 0;
            m_vaSourceData[defaultInputRegMap[D3DVSDE_BLENDWEIGHT]].dwType   = bWeightType[dwBCount];
            m_vaSourceData[defaultInputRegMap[D3DVSDE_BLENDWEIGHT]].dwOffset = dwOffset;
            dwOffset += dwBCount * sizeof(D3DVALUE);
            break;
        default:
            DPF ("unknown position mask in FVF");
            dbgD3DError();
            break;
    }  // switch

    // normal
    if (dwFVF & D3DFVF_NORMAL) {
        m_vaSourceData[defaultInputRegMap[D3DVSDE_NORMAL]].dwStream = 0;
        m_vaSourceData[defaultInputRegMap[D3DVSDE_NORMAL]].dwType   = D3DVSDT_FLOAT3;
        m_vaSourceData[defaultInputRegMap[D3DVSDE_NORMAL]].dwOffset = dwOffset;
        dwOffset += 3*sizeof(DWORD);
    }
    else {
        m_vaSourceData[defaultInputRegMap[D3DVSDE_NORMAL]].dwStream = VA_STREAM_NONE;
    }

    // point size
    if (dwFVF & D3DFVF_PSIZE) {
        // must check runtime version since annoying DX7 apps (Isle of Morg)
        // will set the RESERVED1 flag which is the same as the PSIZE flag
        if (pContext->dwDXAppVersion >= 0x800) {
            m_vaSourceData[defaultInputRegMap[D3DVSDE_PSIZE]].dwStream = 0;
            m_vaSourceData[defaultInputRegMap[D3DVSDE_PSIZE]].dwType   = D3DVSDT_FLOAT1;
            m_vaSourceData[defaultInputRegMap[D3DVSDE_PSIZE]].dwOffset = dwOffset;
        }
        dwOffset += 1*sizeof(D3DVALUE);
    }
    else {
        m_vaSourceData[defaultInputRegMap[D3DVSDE_PSIZE]].dwStream = VA_STREAM_NONE;
    }

    // diffuse
    if (dwFVF & D3DFVF_DIFFUSE) {
        m_vaSourceData[defaultInputRegMap[D3DVSDE_DIFFUSE]].dwStream = 0;
        m_vaSourceData[defaultInputRegMap[D3DVSDE_DIFFUSE]].dwType   = D3DVSDT_D3DCOLOR;
        m_vaSourceData[defaultInputRegMap[D3DVSDE_DIFFUSE]].dwOffset = dwOffset;
        dwOffset += 1*sizeof(DWORD);
    }
    else {
        m_vaSourceData[defaultInputRegMap[D3DVSDE_DIFFUSE]].dwStream = VA_STREAM_NONE;
    }

    // specular
    if (dwFVF & D3DFVF_SPECULAR) {
        m_vaSourceData[defaultInputRegMap[D3DVSDE_SPECULAR]].dwStream = 0;
        m_vaSourceData[defaultInputRegMap[D3DVSDE_SPECULAR]].dwType   = D3DVSDT_D3DCOLOR;
        m_vaSourceData[defaultInputRegMap[D3DVSDE_SPECULAR]].dwOffset = dwOffset;
        dwOffset += 1*sizeof(DWORD);
    }
    else {
        m_vaSourceData[defaultInputRegMap[D3DVSDE_SPECULAR]].dwStream = VA_STREAM_NONE;
    }

    // texture coordinates
    dwNumTexSets     = FVF_TEXCOORD_NUMBER(dwFVF);
    dwTextureFormats = dwFVF >> 16;
    for (i=0; i<dwNumTexSets; i++) {
        m_vaSourceData[defaultInputRegMap[D3DVSDE_TEXCOORD0+i]].dwStream = 0;
        m_vaSourceData[defaultInputRegMap[D3DVSDE_TEXCOORD0+i]].dwType   = bTextureType[dwTextureFormats & 0x3];
        m_vaSourceData[defaultInputRegMap[D3DVSDE_TEXCOORD0+i]].dwOffset = dwOffset;
        dwOffset += bTextureSize[dwTextureFormats & 0x3];
        dwTextureFormats >>= 2;
    }
    for (i=dwNumTexSets; i<NV_CAPS_MAX_UV_SETS; i++) {
        m_vaSourceData[defaultInputRegMap[D3DVSDE_TEXCOORD0+i]].dwStream = VA_STREAM_NONE;
    }

    m_dwStride = dwOffset;

    // set dirty state as required
#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TL_MODE |
                                      CELSIUS_DIRTY_FVF     |
                                      CELSIUS_DIRTY_LIGHTS  |
                                      CELSIUS_DIRTY_TEXTURE_STATE;
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF     |
                                      KELVIN_DIRTY_LIGHTS  |
                                      KELVIN_DIRTY_TEXTURE_STATE;
#endif

    return TRUE;
}

/*****************************************************************************
 * CVertexShader::~CVertexShader
 *
 * set the constants of a shader
 */
CVertexShader::~CVertexShader(void)
{
    if (m_pCodeData) {
        FreeIPM (m_pCodeData);
    }

    if (m_ProgramOutput.residentProgram) {
        FreeIPM(m_ProgramOutput.residentProgram);
        m_ProgramOutput.residentProgram = NULL;
        m_ProgramOutput.residentNumInstructions = 0;
        m_ProgramOutput.residentSize = 0;
    }

#if (NVARCH >= 0x020)
    if (m_pKelvinProgram) {
        FreeIPM (m_pKelvinProgram);
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common_disp\src\nvD3DCelsiusBackend.cpp ===
//**************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvGLBackend.c
//        gl immediate mode entry points for the patch shared library
//
//  History:
//        Daniel Rohrer    (drohrer)      23Jun00      created
//
// **************************************************************************

#include "nvprecomp.h"
#ifdef HOSURF_ENABLE

static void nvCelsiusBeginPrimImm(void *info, NV_PATCH_PRIMITIVE_TYPE primType)
{
    getDC()->nvPusher.makeSpace(2);
    switch (primType) {
    case NV_PATCH_PRIMITIVE_TSTRIP:
        getDC()->nvPusher.push (0, 0x00040000 | (NV_DD_CELSIUS << 13) | NV056_SET_BEGIN_END4);
        getDC()->nvPusher.push (1, NV056_SET_BEGIN_END_OP_TRIANGLE_STRIP);
        DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS: Begin TriStrip");
        break;
    case NV_PATCH_PRIMITIVE_TFAN:
        getDC()->nvPusher.push (0, 0x00040000 | (NV_DD_CELSIUS << 13) | NV056_SET_BEGIN_END4);
        getDC()->nvPusher.push (1, NV056_SET_BEGIN_END_OP_TRIANGLE_FAN);
        DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS: Begin TriFan");
        break;
    }
    getDC()->nvPusher.adjust(2);
}

static void nvCelsiusEndPrimImm(void *info)
{
    getDC()->nvPusher.push (0, 0x00040000 | (NV_DD_CELSIUS << 13) | NV056_SET_BEGIN_END4);
    getDC()->nvPusher.push (1, NV056_SET_BEGIN_END_OP_END);
    getDC()->nvPusher.adjust(2);
    DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS: End Prim");
}

#define VIEW_AS_DWORD(f) (*(DWORD *)(&(f)))

// map our enables bits to celsius rendering
static int inline_renderorder[] = {
    D3DVSDE_BLENDWEIGHT,
    D3DVSDE_NORMAL,
    D3DVSDE_TEXCOORD1,
    D3DVSDE_TEXCOORD0,
    D3DVSDE_SPECULAR,
    D3DVSDE_DIFFUSE,
    D3DVSDE_POSITION
};

// This won't work quite right until we have state aliasing for vertex programs.
extern DWORD method_dispatch [9][16][2];
static void nvCelsiusSendPrimImm(void *context, NV_PATCH_EVAL_OUTPUT *pData, int index)
{
    float *pAttribs = &pData->vertexAttribs[index][0][0];
    float *pFinalAttribs;
    NV_PATCH_INFO *info = (NV_PATCH_INFO*)context;
    int evalEnables = info->evalEnables;
    int vertexSize = info->vertexSize;
    int i,j;
    DWORD mapping;
    DWORD packedByte, dwT0, dwT1, dwType;
    PNVD3DCONTEXT pContext;

    BOOL bUseTSSState = FALSE;

    pContext = (PNVD3DCONTEXT)info->context;
    // if we don't have a program we need to double check the TSS State and see what we
    // need to actually output.
    if(pContext && !pContext->pCurrentVShader->hasProgram()){
        // if textures are on enable the texture 'arrays'
        // even though they may not have data... dwT0/dwT1 will fetch from the right place
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0)) {
            DWORD dwTCIndex = (pContext->hwState.dwTexCoordIndices >>  0) & 0xffff;
            dwT0 = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            evalEnables |= (1 << defaultInputRegMap[D3DVSDE_TEXCOORD0]);
        }
        else{
            dwT0 = defaultInputRegMap[D3DVSDE_TEXCOORD0];
            evalEnables &= ~(1 << defaultInputRegMap[D3DVSDE_TEXCOORD0]);
        }
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1)) {
            DWORD dwTCIndex = (pContext->hwState.dwTexCoordIndices >> 16) & 0xffff;
            dwT1 = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            evalEnables |= (1 << defaultInputRegMap[D3DVSDE_TEXCOORD1]);
        }
        else{
            dwT1 = defaultInputRegMap[D3DVSDE_TEXCOORD1];
            evalEnables &= ~(1 << defaultInputRegMap[D3DVSDE_TEXCOORD1]);
        }
        bUseTSSState = TRUE;
        pFinalAttribs = pAttribs;
    }

    getDC()->nvPusher.push (0, (vertexSize << 18) | (NV_DD_CELSIUS << 13) | NVPUSHER_NOINC(NV056_INLINE_ARRAY(0)));
    i=1;

    // do inline vertex data in reverse order
    for (j=0; j<7; j++) {

        mapping = defaultInputRegMap[inline_renderorder[j]];

        if (bUseTSSState) {
            if      (mapping == defaultInputRegMap[D3DVSDE_TEXCOORD0]) mapping = dwT0;
            else if (mapping == defaultInputRegMap[D3DVSDE_TEXCOORD1]) mapping = dwT1;
        }

        nvAssert (mapping >= 0);

        if (evalEnables & (1<<mapping)) {

            nvAssert(pFinalAttribs);
            dwType = info->maps[mapping].Originaltype;

            //hack for weights when someone asks for a weight size greater than we can handle
            if (mapping == defaultInputRegMap[D3DVSDE_BLENDWEIGHT] && dwType > NV_PATCH_VERTEX_FORMAT_FLOAT_1) dwType = NV_PATCH_VERTEX_FORMAT_FLOAT_1;

            switch (dwType) {
                case NV_PATCH_VERTEX_FORMAT_FLOAT_1:
                    DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\t%d\t%f",mapping,pFinalAttribs[4*mapping+0]);
                    getDC()->nvPusher.push (i, VIEW_AS_DWORD(pFinalAttribs[4*mapping+0]));
                    i++; break;
                case NV_PATCH_VERTEX_FORMAT_FLOAT_2:
                    DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\t%d\t%f\t%f",mapping,pFinalAttribs  [4*mapping+0],pFinalAttribs[4*mapping+1]);
                    getDC()->nvPusher.push (i,   VIEW_AS_DWORD(pFinalAttribs[4*mapping+0]));
                    getDC()->nvPusher.push (i+1, VIEW_AS_DWORD(pFinalAttribs[4*mapping+1]));
                    i+=2; break;
                case NV_PATCH_VERTEX_FORMAT_FLOAT_3:
                    DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\t%d\t%f\t%f\t%f",mapping,pFinalAttribs[4*mapping+0],pFinalAttribs[4*mapping+1],pFinalAttribs[4*mapping+2]);
                    if(info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR && mapping == defaultInputRegMap[D3DVSDE_NORMAL]){
                        getDC()->nvPusher.push (i,   (0x80000000^VIEW_AS_DWORD(pFinalAttribs[4*mapping+0])));
                        getDC()->nvPusher.push (i+1, (0x80000000^VIEW_AS_DWORD(pFinalAttribs[4*mapping+1])));
                        getDC()->nvPusher.push (i+2, (0x80000000^VIEW_AS_DWORD(pFinalAttribs[4*mapping+2])));
                    }else{
                        getDC()->nvPusher.push (i,   VIEW_AS_DWORD(pFinalAttribs[4*mapping+0]));
                        getDC()->nvPusher.push (i+1, VIEW_AS_DWORD(pFinalAttribs[4*mapping+1]));
                        getDC()->nvPusher.push (i+2, VIEW_AS_DWORD(pFinalAttribs[4*mapping+2]));
                    }
                    i+=3; break;
                case NV_PATCH_VERTEX_FORMAT_FLOAT_4:
                    DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\t%d\t%f\t%f\t%f\t%f",mapping,pFinalAttribs[4*mapping+0],pFinalAttribs[4*mapping+1],
                                                                             pFinalAttribs[4*mapping+2],pFinalAttribs[4*mapping+3]);
                    getDC()->nvPusher.push (i,   VIEW_AS_DWORD(pFinalAttribs[4*mapping+0]));
                    getDC()->nvPusher.push (i+1, VIEW_AS_DWORD(pFinalAttribs[4*mapping+1]));
                    getDC()->nvPusher.push (i+2, VIEW_AS_DWORD(pFinalAttribs[4*mapping+2]));
                    getDC()->nvPusher.push (i+3, VIEW_AS_DWORD(pFinalAttribs[4*mapping+3]));
                    i+=4; break;
                case NV_PATCH_VERTEX_FORMAT_UBYTE:
                    //packed byte will be expanded by tess to 4 vec float
                    //pack it back down so the backend FVF definition isn't different
                    packedByte  =  max(0,min((int)(pFinalAttribs[4*mapping + 0]*256.0),256));
                    packedByte |= (max(0,min((int)(pFinalAttribs[4*mapping + 1]*256.0),256))<<8);
                    packedByte |= (max(0,min((int)(pFinalAttribs[4*mapping + 2]*256.0),256))<<8);
                    packedByte |= (max(0,min((int)(pFinalAttribs[4*mapping + 3]*256.0),256))<<8);
                    DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\t%d\t%ld",mapping,packedByte);
                    getDC()->nvPusher.push (i, packedByte);
                    i++; break;
                default:
                    DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\tDefault: vertex shouldn't be here!!");
            }
        }
    }
    getDC()->nvPusher.adjust (i);
}

static void nvCelsiusStreamInit(void  *context)
{
    //getDC()->nvPusher.flush(TRUE,CPushBuffer::FLUSH_HEAVY_POLLING);
    //NV_PATCH_INFO *info = (NV_PATCH_INFO*)context;
    return;
}

static void nvCelsiusStreamDestroy(void *context)
{
    //getDC()->nvPusher.flush(TRUE,CPushBuffer::FLUSH_HEAVY_POLLING);
    //NV_PATCH_INFO *info = (NV_PATCH_INFO*)context;
    return;
}

static void nvCelsiusSendFrontFace(void *context, int reversed){
    PNVD3DCONTEXT pContext;
    NV_PATCH_INFO *info = (NV_PATCH_INFO*)context;
    pContext = (PNVD3DCONTEXT)info->context;


    //DCR UGLY HACK -- OGL and D3D have different ordering on vertices so I 'remap' mine on the front end
    //but it forces a reversal in windings for the triangular tesellation case... FIND a better solution
    if(info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR) reversed=1-reversed;
    switch(pContext->dwRenderState[D3DRENDERSTATE_CULLMODE]){
    case D3DCULL_NONE:
            break;
    case D3DCULL_CW:
            reversed=1-reversed;
    case D3DCULL_CCW:
        getDC()->nvPusher.push(0, (0x1 << 18) | (NV_DD_CELSIUS << 13) | NV056_SET_FRONT_FACE);
        if(reversed){
            DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS: Cull CW");
            getDC()->nvPusher.push(1, NV056_SET_FRONT_FACE_V_CW);
        } else {
            DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS: Cull CCW");
            getDC()->nvPusher.push(1, NV056_SET_FRONT_FACE_V_CCW);
        }
        getDC()->nvPusher.adjust(2);
        break;
    default:
        nvAssert(0);    //should never be here
    }
}

static void nvCelsiusBeginPatch(void *info){
    return;
}
static void nvCelsiusEndPatch(void *info){
    return;
}

NV_PATCH_BACKEND nvCelsiusImm_Backend = {
    nvCelsiusStreamInit,
    nvCelsiusStreamDestroy,
    nvCelsiusBeginPrimImm,
    nvCelsiusEndPrimImm,
    nvCelsiusSendPrimImm,
    nvCelsiusSendFrontFace,
    nvCelsiusBeginPatch,
    nvCelsiusEndPatch
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common\src\TransInit.cpp ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: TransInit.cpp                                                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           8/17/98                                          *
*                                                                           *
\***************************************************************************/
// these are intented to be called from surfaces.c setupvp and teardownvp

#include "nvprecomp.h"
#pragma hdrstop

extern vpSurfaces*          pMySurfaces;
extern NvNotification*      nvMyVPNotifiers;
NvChannel*          nvPtr = NULL;


U032 SetupMTM() {
    U032    i;
    U032    error;
    nvPtr = pMySurfaces->pVPChanPtr;

    // allocate the MTM object
#ifdef NV3
    error = NvRmAllocObject(  (GLOBDATAPTR)->ROOTHANDLE,
                                MY_VPE_CHANNEL,
                                MY_MTM_OBJECT,
                                NV_MEMORY_TO_MEMORY_FORMAT
                              );
#else
    error = NvRmAllocObject(  (GLOBDATAPTR)->ROOTHANDLE,
                                MY_VPE_CHANNEL,
                                MY_MTM_OBJECT,
                                NV03_MEMORY_TO_MEMORY_FORMAT
                                );
#endif // !NV3
    if(checkNvAllocArchError(error )) {
        DPF("NVDD: Cannot allocate MTM object %d",MY_EXTERNAL_DECODER_OBJECT);
        return FALSE;
    }


    // allocate the notify context
    error = NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
                                MY_MTM_NOTIFIER,
                                NV01_CONTEXT_DMA,
                                DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                                DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                                (PVOID)(((U032)nvMyVPNotifiers) + NUM039OFFSET*sizeof(NvNotification)),
                                (sizeof( NvNotification)*NUM039NOTIFIER  - 1)
                         );
    if(checkNvAllocArchError(error )) {
        DPF("NVDD: Cannot allocate MTM Notifier object %d",MY_EXTERNAL_DECODER_OBJECT);
        return FALSE;
    }

    // allocate the FROM context
    error = NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
                                MY_MTM_FROM_CONTEXT,
                                NV01_CONTEXT_DMA,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                                DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                                DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                                (PVOID)(void*)((GLOBALDATA*)(pMySurfaces->pDriverData))->BaseAddress,
                                ((((GLOBALDATA*)(pMySurfaces->pDriverData))->VideoHeapEnd - ((GLOBALDATA*)(pMySurfaces->pDriverData))->BaseAddress)) -1
                         );

    if(checkNvAllocArchError(error )) {
        DPF("NVDD: Cannot allocate MTM FROM context object %d",MY_EXTERNAL_DECODER_OBJECT);
        return FALSE;
    }

    // allocate the MTM event
    error = NvRmAllocEvent  (   (GLOBDATAPTR)->ROOTHANDLE,
                                        MY_MTM_OBJECT,
                                MY_MTM_EVENT,
                                NV01_EVENT_KERNEL_CALLBACK,
                                        NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0),
                                        (void*)pMySurfaces->pMTMNotifyCallback);

    if(checkNvAllocArchError(error )) {
        DPF("NVDD: Cannot allocate MTM event object %d",MY_EXTERNAL_DECODER_OBJECT);
        return FALSE;
    }
#if 0
// second one until RM is working

    error = NvRmAllocEvent  (   (GLOBDATAPTR)->ROOTHANDLE,
                                        MY_MTM_OBJECT,
                                MY_MTM_EVENT2,
                                NV01_EVENT_KERNEL_CALLBACK,
                                        NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0),
                                        (void*)pMySurfaces->pMTMNotifyCallback);

    if(checkNvAllocArchError(error )) {
        DPF("NVDD: Cannot allocate MTM event object %d",MY_EXTERNAL_DECODER_OBJECT);
        return FALSE;
    }
// done with second one
#endif

#ifdef NV3
    nvPtr->subchannel[5].control.object = MY_MTM_OBJECT;
#else
    nvPtr->subchannel[5].SetObject  = MY_MTM_OBJECT;
#endif


#ifdef NV3
    nvPtr->subchannel[5].memoryToMemoryFormat.SetBufferNotifyCtxDma = MY_MTM_NOTIFIER;
    nvPtr->subchannel[5].memoryToMemoryFormat.SetBufferInCtxDma = MY_MTM_FROM_CONTEXT;
#else
    nvPtr->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaNotifies = MY_MTM_NOTIFIER;
    nvPtr->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferIn = MY_MTM_FROM_CONTEXT;
#endif

    // Null out the transfers
    for(i=0;i<MAXTRANSFERS;i++) {
        pMySurfaces->MyTransfers[i].TransferID = TRANSFERNOTINUSE;
    }
//  pMySurfaces->pLastTransfer =
    pMySurfaces->pCurrentTransfer = NULL;
    pMySurfaces->bContextCreated    = FALSE;
    return TRUE;
}



void TearDownMTM() {
    U032    i;
    U032    error;
    nvPtr = pMySurfaces->pVPChanPtr;


    // set the transfers to something useless
    for(i=0;i<MAXTRANSFERS;i++) {
        pMySurfaces->MyTransfers[i].TransferID = 0;
    }

    if(nvPtr != NULL ) {
#ifdef NV3
        nvPtr->subchannel[5].control.object = MY_MTM_OBJECT;
#else
        nvPtr->subchannel[5].SetObject  = MY_MTM_OBJECT;
#endif

                                                                            // plug in some null objects
#ifdef NV3
        nvPtr->subchannel[5].memoryToMemoryFormat.SetBufferNotifyCtxDma = 0;
        nvPtr->subchannel[5].memoryToMemoryFormat.SetBufferInCtxDma = 0;
        nvPtr->subchannel[5].memoryToMemoryFormat.SetBufferOutCtxDma = 0;
#else
        nvPtr->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaNotifies = 0;
        nvPtr->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferIn = 0;
        nvPtr->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferOut = 0;
#endif

    // DO a SYNC here.
        // spin waiting for empty fifo
        {
            long countDown = 0x200000;

#ifdef NV3
            while( (NvGetFreeCount(nvPtr, 5) < NV_GUARANTEED_FIFO_SIZE ) && (countDown > 0) )
                NV_SLEEP;
#else
            while( (NvGetFreeCount(nvPtr, 5) < NV06A_FIFO_GUARANTEED_SIZE ) && (countDown > 0) )
                NV_SLEEP;
#endif
        }

    }

    if(pMySurfaces->bContextCreated) {
        error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_MTM_TO_CONTEXT);

        checkNvAllocArchError(error);
        pMySurfaces->bContextCreated = FALSE;

    }

#ifdef NOEVENTFREEFUNCTIONYETFOLKS
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_MTM_OBJECT, MY_MTM_EVENT);
   checkNvAllocArchError(error);
#if 0
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_MTM_OBJECT, MY_MTM_EVENT2);
   checkNvAllocArchError(error);
#endif

#endif

    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_MTM_NOTIFIER);
    checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_MTM_FROM_CONTEXT);
    checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_VPE_CHANNEL, MY_MTM_OBJECT);
    checkNvAllocArchError(error);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common_disp\src\nvPatchConsts.cpp ===
//**************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPatchConsts.cpp
//        file used to indirectly load patch matrix constants
//
//  History:
//        Daniel Rohrer    (drohrer)      23Jun00      created
//
// **************************************************************************
#include "nvprecomp.h"

#pragma warning(disable : 4305)

#include "..\..\..\common\src\nvPatchConsts.c"

#pragma warning(default : 4305)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common_disp\src\nvPatchUtilInit.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein./
//
// ********************************* Direct 3D ******************************
//
//  Module: nvPatchUtilInit.cpp
//      basically just a pointer to a shared file
//
// **************************************************************************
//
//  History:
//      Daniel Rohrer          14Aug2000         DX8 development
//
// **************************************************************************
#include "nvprecomp.h"
#include "..\..\..\common\src\nvPatchUtilInit.c"
//The include file goes to the shared code
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common_disp\src\nvD3DKelvinBackend.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein./
//
// ********************************* Direct 3D ******************************
//
//  Module: nvD3DKelvinBackend.cpp
//      basically just a pointer to a shared file
//
// **************************************************************************
//
//  History:
//      Daniel Rohrer          14Aug2000         DX8 development
//
// **************************************************************************
#include "nvprecomp.h"

#include "..\..\..\common\src\nvD3DKelvinBackend.c"
//The include file goes to the shared code (native kelvin)

// this is the software fallback case which draws emulated triangles... VERY slow and not efficient.
static void nvKelvinBeginPrimImm(void *info, NV_PATCH_PRIMITIVE_TYPE primType)
{
    getDC()->nvPusher.makeSpace(2);
    switch (primType) {
    case NV_PATCH_PRIMITIVE_TSTRIP:
        getDC()->nvPusher.push (0, 0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_BEGIN_END);
        getDC()->nvPusher.push (1, NV056_SET_BEGIN_END_OP_TRIANGLE_STRIP);
        DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS: Begin TriStrip");
        break;
    case NV_PATCH_PRIMITIVE_TFAN:
        getDC()->nvPusher.push (0, 0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_BEGIN_END);
        getDC()->nvPusher.push (1, NV056_SET_BEGIN_END_OP_TRIANGLE_FAN);
        DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS: Begin TriFan");
        break;
    }
    getDC()->nvPusher.adjust(2);
}

static void nvKelvinEndPrimImm(void *info)
{
    getDC()->nvPusher.push (0, 0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_BEGIN_END);
    getDC()->nvPusher.push (1, NV097_SET_BEGIN_END_OP_END);
    getDC()->nvPusher.adjust(2);
    DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS: End Prim");
}

#define VIEW_AS_DWORD(f) (*(DWORD *)(&(f)))

//map our enables bits to kelvin rendering
static int inline_renderorder[] = {
    D3DVSDE_POSITION,
    D3DVSDE_BLENDWEIGHT,
    D3DVSDE_NORMAL,
    D3DVSDE_DIFFUSE,
    D3DVSDE_SPECULAR,
    D3DVSDE_PSIZE,           
    D3DVSDE_TEXCOORD0,
    D3DVSDE_TEXCOORD1,
    D3DVSDE_TEXCOORD2,
    D3DVSDE_TEXCOORD3
};

NV_INLINE int dumpAttribute(float *pFinalAttribs, CVertexShader *pShader, DWORD dwReg, int i){
    DWORD packedByte;
    DWORD index = dwReg*4;
    switch(pShader->getVAType(dwReg)){
    case NV_PATCH_VERTEX_FORMAT_FLOAT_1:
        DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\t%d\t%f",dwReg,pFinalAttribs[4*dwReg+0]);
        getDC()->nvPusher.push (i, VIEW_AS_DWORD(pFinalAttribs[index+0]));
        i++; break;
    case NV_PATCH_VERTEX_FORMAT_FLOAT_2:
        DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\t%d\t%f\t%f",dwReg,pFinalAttribs  [4*dwReg+0],pFinalAttribs[4*dwReg+1]);
        getDC()->nvPusher.push (i,   VIEW_AS_DWORD(pFinalAttribs[index+0]));
        getDC()->nvPusher.push (i+1, VIEW_AS_DWORD(pFinalAttribs[index+1]));
        i+=2; break;
    case NV_PATCH_VERTEX_FORMAT_FLOAT_3:
        DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\t%d\t%f\t%f\t%f",dwReg,pFinalAttribs[4*dwReg+0],pFinalAttribs[4*dwReg+1],pFinalAttribs[4*dwReg+2]);
        getDC()->nvPusher.push (i,   VIEW_AS_DWORD(pFinalAttribs[index+0]));
        getDC()->nvPusher.push (i+1, VIEW_AS_DWORD(pFinalAttribs[index+1]));
        getDC()->nvPusher.push (i+2, VIEW_AS_DWORD(pFinalAttribs[index+2]));
        i+=3; break;
    case NV_PATCH_VERTEX_FORMAT_FLOAT_4:
        DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\t%d\t%f\t%f\t%f\t%f",dwReg,pFinalAttribs[4*dwReg+0],pFinalAttribs[4*dwReg+1],
                                                                 pFinalAttribs[4*dwReg+2],pFinalAttribs[4*dwReg+3]);
        getDC()->nvPusher.push (i,   VIEW_AS_DWORD(pFinalAttribs[index+0]));
        getDC()->nvPusher.push (i+1, VIEW_AS_DWORD(pFinalAttribs[index+1]));
        getDC()->nvPusher.push (i+2, VIEW_AS_DWORD(pFinalAttribs[index+2]));
        getDC()->nvPusher.push (i+3, VIEW_AS_DWORD(pFinalAttribs[index+3]));
        i+=4; break;
    case NV_PATCH_VERTEX_FORMAT_UBYTE:
    case NV_PATCH_VERTEX_FORMAT_D3DCOLOR: 
        //packed byte will be expanded by tess to 4 vec float
        //pack it back down so the backend FVF definition isn't different                                    
        packedByte  = (max(0,min((int)(pFinalAttribs[index + 0]*255.0),255))<<16);
        packedByte |= (max(0,min((int)(pFinalAttribs[index + 1]*255.0),255))<<8);
        packedByte |= (max(0,min((int)(pFinalAttribs[index + 2]*255.0),255))<<0);
        packedByte |= (max(0,min((int)(pFinalAttribs[index + 3]*255.0),255))<<24);
        DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\t%d\t%x",dwReg,packedByte);
        getDC()->nvPusher.push (i, packedByte);
        i++; break; 
    case D3DVSDT_SHORT2:   // 6
    case D3DVSDT_SHORT4:   // 7
    default:
        DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\tDefault: vertex shouldn't be here!!");
        nvAssert(0);
    }
    return i;
}

static void nvKelvinSendPrimImm(void *context, NV_PATCH_EVAL_OUTPUT *pData, int index)
{
    float *pFinalAttribs = &pData->vertexAttribs[index][0][0];
    NV_PATCH_INFO     *info = (NV_PATCH_INFO*)context;
    PNVD3DCONTEXT  pContext = (PNVD3DCONTEXT)info->context;    
    CVertexShader  *pShader = pContext->hwState.pVertexShader;                  
    int i,j,bUsesTexture;    
    DWORD dwReg;

    if (pShader->hasProgram()) {        
        getDC()->nvPusher.push (0, (info->vertexSize << 18) | (NV_DD_KELVIN << 13) | NVPUSHER_NOINC(NV097_INLINE_ARRAY));
        i = 1;
        for(j=0; j < 16; j++){                        
            if(info->evalEnables & 1<<j){
                i = dumpAttribute(pFinalAttribs, pShader, j, i);
            }
        }
        getDC()->nvPusher.adjust(info->vertexSize + 1);
    } else{
        getDC()->nvPusher.push (0, (info->vertexSize << 18) | (NV_DD_KELVIN << 13) | NVPUSHER_NOINC(NV097_INLINE_ARRAY));
        i=1;
        bUsesTexture = 1;
        for(j=0; j < 10; j++){            
            //THIS SHOULD ONLY EVER BE CALLED VIA KELVIN            
            //this will force the inline vertex stride to match kelvin setup in sequencer mode
            dwReg = inline_renderorder[j];                        
            if(!pShader->hasProgram() && dwReg >= D3DVSDE_TEXCOORD0 && dwReg <= D3DVSDE_TEXCOORD3){
                dwReg = defaultInputRegMap[dwReg];            
                bUsesTexture = 0;
                DWORD dwTCIndex, dwVAIndex, dwHWStage;
                for (dwHWStage=0; dwHWStage < KELVIN_NUM_TEXTURES; dwHWStage++) {
                    if ((pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(dwHWStage))) {
                        dwTCIndex = (pContext->hwState.dwTexCoordIndices >> (8*dwHWStage)) & 0xff;
                        dwVAIndex = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
                        if(dwVAIndex == dwReg){ bUsesTexture = 1; break;}
                    }
                }
            }
            else{
                dwReg = defaultInputRegMap[dwReg];            
            }
            if((info->evalEnables & 1<<dwReg) && bUsesTexture){
                i = dumpAttribute(pFinalAttribs, pShader, dwReg,i);
            }
        }
        getDC()->nvPusher.adjust(info->vertexSize + 1);
    }
}

static void nvKelvinStreamInit(void  *context)
{
    //getDC()->nvPusher.flush(TRUE,CPushBuffer::FLUSH_HEAVY_POLLING);
    //NV_PATCH_INFO *info = (NV_PATCH_INFO*)context;
    return;
}

static void nvKelvinStreamDestroy(void *context)
{
    //getDC()->nvPusher.flush(TRUE,CPushBuffer::FLUSH_HEAVY_POLLING);
    //NV_PATCH_INFO *info = (NV_PATCH_INFO*)context;
    return;
}

static void nvKelvinSendFrontFace(void *context, int reversed){
    PNVD3DCONTEXT pContext;
    NV_PATCH_INFO *info = (NV_PATCH_INFO*)context;
    pContext = (PNVD3DCONTEXT)info->context;

    switch(pContext->dwRenderState[D3DRENDERSTATE_CULLMODE]){
    case D3DCULL_NONE:
            break;
    case D3DCULL_CW:
            reversed=1-reversed;
    case D3DCULL_CCW:
        getDC()->nvPusher.push(0, (0x1 << 18) | (NV_DD_KELVIN << 13) | NV097_SET_FRONT_FACE);
        if(reversed){
            DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS: Cull CW");
            getDC()->nvPusher.push(1, NV097_SET_FRONT_FACE_V_CW);
        } else {
            DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS: Cull CCW");
            getDC()->nvPusher.push(1, NV097_SET_FRONT_FACE_V_CCW);
        }
        getDC()->nvPusher.adjust(2);
        break;
    default:
        nvAssert(0);    //should never be here
    }
}

static void nvKelvinBeginPatch(void *context){      
#ifdef DCR_SEMAPHORE
    NV_PATCH_INFO *info = (NV_PATCH_INFO*)context;   
    //COUNTER IS STORED AT OFFSET 0x0 in the page of semaphores
    //SEMAPHORE IS STORED AT 0x4
#if defined(IS_OPENGL)
#if defined(linux)
    //NEED AN INTERLOCK EXCHANGE HERE!!!!
    //COULD WE JUST USE THE CLIP_SPIN LOCK INSTEAD??? TO 
    //MUTEX ANY CHANGES TO THE COUNTER VALUE
#endif
#if defined(OSX)
    //JAYANT SAYS MAC DOESN'T PREEMPTIVE SWITCH YET
    //SO UNTIL OSX IS READY NOTHING NEEDED HERE
#endif
#else
    info->counter = InterlockedIncrement(&(g_FDGlobalData.FDSynchCounter[0]));
#endif       
    //set the semaphore context DMA to the FD semaphore set
    getDC()->nvPusher.push (0, (0x00040000 | (NV_DD_KELVIN << 13) | NV206E_SET_CONTEXT_DMA_SEMAPHORE));
    getDC()->nvPusher.push (1, FD_SEMAPHORE_206E_CONTEXT_DMA);    // must be read-only
    getDC()->nvPusher.push (2, (0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_CONTEXT_DMA_SEMAPHORE));
    getDC()->nvPusher.push (3, FD_SEMAPHORE_097_CONTEXT_DMA);   
   
    getDC()->nvPusher.push (4, (0x00040000 | NV206E_SEMAPHORE_OFFSET));
    getDC()->nvPusher.push (5, 0x4);       
    getDC()->nvPusher.push (6, (0x00040000 | NV206E_SEMAPHORE_ACQUIRE));
    getDC()->nvPusher.push (7, info->counter-1);

    //reset the semaphore context DMA to the standard kelvin flipper
    getDC()->nvPusher.push (8, (0x00040000 | (NV_DD_KELVIN << 13) | NV206E_SET_CONTEXT_DMA_SEMAPHORE));
    getDC()->nvPusher.push (9, CSemaphoreManager::SEMAPHORE_CONTEXT_DMA_FROM_MEMORY);    //must be read-only
    getDC()->nvPusher.push (10, (0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_CONTEXT_DMA_SEMAPHORE));
    getDC()->nvPusher.push (11,  CSemaphoreManager::SEMAPHORE_CONTEXT_DMA_IN_MEMORY);    //must be read-write

    getDC()->nvPusher.adjust (12);
    getDC()->nvPusher.start(TRUE);
#endif
    return;
}

static void nvKelvinEndPatch(void *context){
#ifdef DCR_SEMAPHORE
    NV_PATCH_INFO *info = (NV_PATCH_INFO*)context;   

    //set the semaphore context DMA to the FD semaphore set
    getDC()->nvPusher.push (0, (0x00040000 | (NV_DD_KELVIN << 13) | NV206E_SET_CONTEXT_DMA_SEMAPHORE));
    getDC()->nvPusher.push (1, FD_SEMAPHORE_206E_CONTEXT_DMA);    
    getDC()->nvPusher.push (2, (0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_CONTEXT_DMA_SEMAPHORE));
    getDC()->nvPusher.push (3, FD_SEMAPHORE_097_CONTEXT_DMA);   

    getDC()->nvPusher.push (4, (0x00040000 | NV206E_SEMAPHORE_OFFSET));        
    getDC()->nvPusher.push (5, 0x4);
    getDC()->nvPusher.push (6, (0x00040000 | NV206E_SEMAPHORE_RELEASE));
    getDC()->nvPusher.push (7, info->counter);

    //reset the semaphore context DMA to the standard kelvin flipper
    getDC()->nvPusher.push (8, (0x00040000 | (NV_DD_KELVIN << 13) | NV206E_SET_CONTEXT_DMA_SEMAPHORE));
    getDC()->nvPusher.push (9, CSemaphoreManager::SEMAPHORE_CONTEXT_DMA_FROM_MEMORY);   //must be read-only
    getDC()->nvPusher.push (10, (0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_CONTEXT_DMA_SEMAPHORE));
    getDC()->nvPusher.push (11, CSemaphoreManager::SEMAPHORE_CONTEXT_DMA_IN_MEMORY);    //must be read-write
    
    getDC()->nvPusher.adjust (12);
    getDC()->nvPusher.start(TRUE);
#endif
    return;
}

NV_PATCH_BACKEND nvKelvinImm_Backend = {
    nvKelvinStreamInit,
    nvKelvinStreamDestroy,
    nvKelvinBeginPrimImm,
    nvKelvinEndPrimImm,
    nvKelvinSendPrimImm,
    nvKelvinSendFrontFace,
    nvKelvinBeginPatch,
    nvKelvinEndPatch
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\common_disp\src\nvPatchUtils.cpp ===
//**************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION7
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPatchUtil.cpp
//        file used to indirectly load patch software emulation
//
//  History:
//        Daniel Rohrer    (drohrer)      23Jun00      created
//
// ***************************************************************************

#include "nvprecomp.h"

#ifdef HOSURF_ENABLE
#include "..\..\..\common\src\nvPatchUtil.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\kelvin\inc\nvKelvinAA.h ===
#ifndef _NVKELVINAA_H
#define _NVKELVINAA_H

/*
 * Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvKelvinAA.h                                                      *
*     prototypes for aa routines                                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Scott Cutler                     11Oct2000   created                *
*                                                                           *
\***************************************************************************/

#if (NVARCH >= 0x020)
typedef union _DWORD_float {
    DWORD d;
    float f;
} DF;

typedef unsigned __int64 uint64;
uint64 nvHash64(unsigned char *, unsigned int);

#define KELVIN_AA_NUM_FLIP_CHAIN_SLOTS 16

class CKelvinAAState {
public:
    // Public enums
    typedef enum BufferType { 
        BUFFER_SRT       = 0,          // Super render target
        BUFFER_RT        = 1,          // Normal render target
        BUFFER_SZB       = 2,          // Super Z buffer
        BUFFER_ZB        = 3,          // Normal Z buffer
        BUFFER_SCRATCH   = 4,          // Stratch Z buffer
        BUFFER_MAX       = 5,
        BUFFER_INVALID   = 0xffffffff  // invalid
    };
    
    typedef enum AccessType { 
        ACCESS_READ          = 0, // Read access (write semantics are undefined)
        ACCESS_WRITE         = 1, // Full read/write access
        ACCESS_WRITE_DISCARD = 2, // Write access, except that a) no read access, and b) you must overwrite the entire buffer
        ACCESS_MAX           = 3
    };

    typedef enum AppCompatibilityFlags {
        // Usually, we assume that apps will completely overwrite the contents of the color buffer.
        // This allows the optimization that we don't have to upsample the normal buffer after a
        // flip.  Some apps, particularly ones where there are cursor drawing routines that use
        // read/modify/write blits, break when using this optimization, and as such we can turn it 
        // off.
        APPFLAGS_MAGNIFY_AFTER_FLIP        = 0x00000001,

        // Apps that perform large numbers of upsample/downsample operations often show dithering 
        // artifacts, because of a hardware property where the dither is applied even for colors
        // truncated to 16 bits.  Force dithering off for these apps (we want it on by default
        // because of banding issues).
        APPFLAGS_DISABLE_DITHER            = 0x00000002,

        // Multisampling has the peculiar property where a texture sample can be taken outside 
        // of the border of a triangle.  In most cases this is ok, as triangles that are joined
        // together usually have their textures join in a similar way.  Unfortunately, sometimes
        // apps will store several uncorrelated textures in a single map, and we sometimes sample
        // from these adjacent textures, leading to color artifacts on the edges of some triangles.
        APPFLAGS_FORCE_SUPERSAMPLE         = 0x00000004,

        // Some apps are just fundamentally broken with AA.  Usually this includes apps that perform
        // nasty hacks with the Z buffer.
        APPFLAGS_DISABLE_AA    